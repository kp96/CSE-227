# HG changeset patch
# Parent c68f693a6ae6348ff4dca843035091caaed2f99a
# User Ehsan Akhgari <ehsan@mozilla.com>
Bug 644070 - nsNSSCertificate::defaultServerNickname leaks in case of server name conflict


diff --git a/security/manager/ssl/src/nsCertOverrideService.cpp b/security/manager/ssl/src/nsCertOverrideService.cpp
--- a/security/manager/ssl/src/nsCertOverrideService.cpp
+++ b/security/manager/ssl/src/nsCertOverrideService.cpp
@@ -508,31 +508,35 @@ nsCertOverrideService::RememberValidityO
     return NS_ERROR_FAILURE;
 
   CERTCertificate* nsscert = cert2->GetCert();
   if (!nsscert)
     return NS_ERROR_FAILURE;
 
   CERTCertificateCleaner nsscertCleaner(nsscert);
 
-  nsCAutoString nickname;
-  nickname = nsNSSCertificate::defaultServerNickname(nsscert);
-  if (!aTemporary && !nickname.IsEmpty())
+  char* nickname = nsNSSCertificate::defaultServerNickname(nsscert);
+  if (!aTemporary && nickname && *nickname)
   {
     PK11SlotInfo *slot = PK11_GetInternalKeySlot();
-    if (!slot)
+    if (!slot) {
+      PR_Free(nickname);
       return NS_ERROR_FAILURE;
+    }
   
     SECStatus srv = PK11_ImportCert(slot, nsscert, CK_INVALID_HANDLE, 
-                                    const_cast<char*>(nickname.get()), PR_FALSE);
+                                    nickname, PR_FALSE);
     PK11_FreeSlot(slot);
   
-    if (srv != SECSuccess)
+    if (srv != SECSuccess) {
+      PR_Free(nickname);
       return NS_ERROR_FAILURE;
+    }
   }
+  PR_FREEIF(nickname);
 
   nsCAutoString fpStr;
   nsresult rv = GetCertFingerprintByOidTag(nsscert, 
                   mOidTagForStoringNewHashes, fpStr);
   if (NS_FAILED(rv))
     return rv;
 
   char *dbkey = NULL;
diff --git a/security/manager/ssl/src/nsNSSCallbacks.cpp b/security/manager/ssl/src/nsNSSCallbacks.cpp
--- a/security/manager/ssl/src/nsNSSCallbacks.cpp
+++ b/security/manager/ssl/src/nsNSSCallbacks.cpp
@@ -1094,26 +1094,26 @@ SECStatus PR_CALLBACK AuthCertificateCal
         
         if (node->cert == serverCert) {
           // We don't want to remember the server cert, 
           // the code that cares for displaying page info does this already.
           continue;
         }
 
         // We have found a signer cert that we want to remember.
-        nsCAutoString nickname;
-        nickname = nsNSSCertificate::defaultServerNickname(node->cert);
-        if (!nickname.IsEmpty()) {
+        char* nickname = nsNSSCertificate::defaultServerNickname(node->cert);
+        if (nickname && *nickname) {
           PK11SlotInfo *slot = PK11_GetInternalKeySlot();
           if (slot) {
             PK11_ImportCert(slot, node->cert, CK_INVALID_HANDLE, 
-                            const_cast<char*>(nickname.get()), PR_FALSE);
+                            nickname, PR_FALSE);
             PK11_FreeSlot(slot);
           }
         }
+        PR_FREEIF(nickname);
       }
 
       CERT_DestroyCertList(certList);
     }
 
     // The connection may get terminated, for example, if the server requires
     // a client cert. Let's provide a minimal SSLStatus
     // to the caller that contains at least the cert and its status.
diff --git a/security/manager/ssl/src/nsNSSCertificate.h b/security/manager/ssl/src/nsNSSCertificate.h
--- a/security/manager/ssl/src/nsNSSCertificate.h
+++ b/security/manager/ssl/src/nsNSSCertificate.h
@@ -80,16 +80,18 @@ public:
   nsNSSCertificate(CERTCertificate *cert);
   nsNSSCertificate();
   /* from a request? */
   virtual ~nsNSSCertificate();
   nsresult FormatUIStrings(const nsAutoString &nickname, nsAutoString &nickWithSerial, nsAutoString &details);
   static nsNSSCertificate* Create(CERTCertificate *cert = nsnull);
   static nsNSSCertificate* ConstructFromDER(char *certDER, int derLen);
 
+  // It is the responsibility of the caller of this method to free the returned
+  // string using PR_Free.
   static char* defaultServerNickname(CERTCertificate* cert);
 
 private:
   CERTCertificate *mCert;
   PRBool           mPermDelete;
   PRUint32         mCertType;
   nsCOMPtr<nsIASN1Object> mASN1Structure;
   nsresult CreateASN1Struct();
