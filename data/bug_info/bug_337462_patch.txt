? security/manager/ssl/src/.nsCrypto.cpp.swp
Index: js/src/xpconnect/src/xpccomponents.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpccomponents.cpp,v
retrieving revision 1.95
diff -p -U8 -r1.95 xpccomponents.cpp
--- js/src/xpconnect/src/xpccomponents.cpp	17 Jun 2006 01:03:09 -0000	1.95
+++ js/src/xpconnect/src/xpccomponents.cpp	24 Jun 2006 01:38:06 -0000
@@ -2389,16 +2389,46 @@ nsXPCComponents_utils_Sandbox::CallOrCon
     if (vp)
         *vp = OBJECT_TO_JSVAL(sandbox);
 
     *_retval = JS_TRUE;
     return NS_OK;
 #endif
 }
 
+class ContextHolder : public nsISupports
+{
+public:
+    ContextHolder(JSContext *aOuterCx, JSObject *aSandbox);
+
+    JSContext * GetJSContext()
+    {
+        return mJSContext;
+    }
+
+    NS_DECL_ISUPPORTS
+
+private:
+    XPCAutoJSContext mJSContext;
+};
+
+NS_IMPL_ISUPPORTS0(ContextHolder)
+
+ContextHolder::ContextHolder(JSContext *aOuterCx, JSObject *aSandbox)
+    : mJSContext(JS_NewContext(JS_GetRuntime(aOuterCx), 1024), JS_FALSE)
+{
+    if (mJSContext) {
+        JS_SetOptions(mJSContext,
+                      JSOPTION_DONT_REPORT_UNCAUGHT |
+                      JSOPTION_PRIVATE_IS_NSISUPPORTS);
+        JS_SetGlobalObject(mJSContext, aSandbox);
+        JS_SetContextPrivate(mJSContext, this);
+    }
+}
+
 /***************************************************************************/
 
 /* void evalInSandbox(in AString source, in nativeobj sandbox); */
 NS_IMETHODIMP
 nsXPCComponents_Utils::EvalInSandbox(const nsAString &source)
 {
 #ifdef XPCONNECT_STANDALONE
     return NS_ERROR_NOT_AVAILABLE;
@@ -2455,31 +2485,28 @@ nsXPCComponents_Utils::EvalInSandbox(con
     JSPrincipals *jsPrincipals;
 
     if (!prin ||
         NS_FAILED(prin->GetJSPrincipals(cx, &jsPrincipals)) ||
         !jsPrincipals) {
         return NS_ERROR_FAILURE;
     }
 
-    XPCAutoJSContext sandcx(JS_NewContext(JS_GetRuntime(cx), 1024), false);
-    if(!sandcx) {
+    nsRefPtr<ContextHolder> sandcx = new ContextHolder(cx, sandbox);
+    if(!sandcx || !sandcx->GetJSContext()) {
         JS_ReportError(cx, "Can't prepare context for evalInSandbox");
         JSPRINCIPALS_DROP(cx, jsPrincipals);
         return NS_ERROR_OUT_OF_MEMORY;
     }
 
-    JS_SetOptions(sandcx, JSOPTION_DONT_REPORT_UNCAUGHT);
-    JS_SetGlobalObject(sandcx, sandbox);
-
     XPCPerThreadData *data = XPCPerThreadData::GetData();
     XPCJSContextStack *stack;
     PRBool popContext = PR_FALSE;
     if (data && (stack = data->GetJSContextStack())) {
-        if (NS_FAILED(stack->Push(sandcx))) {
+        if (NS_FAILED(stack->Push(sandcx->GetJSContext()))) {
             JS_ReportError(cx,
                     "Unable to initialize XPConnect with the sandbox context");
             JSPRINCIPALS_DROP(cx, jsPrincipals);
             return NS_ERROR_FAILURE;
         }
 
         popContext = PR_TRUE;
     }
@@ -2495,25 +2522,26 @@ nsXPCComponents_Utils::EvalInSandbox(con
             frame->GetFilename(getter_Copies(filename));
             frame->GetLineNumber(&lineNo);
         } else {
             filename.Assign(jsPrincipals->codebase);
             lineNo = 1;
         }
     }
 
-    AutoJSRequestWithNoCallContext req(sandcx);
-    if (!JS_EvaluateUCScriptForPrincipals(sandcx, sandbox, jsPrincipals,
+    AutoJSRequestWithNoCallContext req(sandcx->GetJSContext());
+    if (!JS_EvaluateUCScriptForPrincipals(sandcx->GetJSContext(), sandbox,
+                                          jsPrincipals,
                                           NS_REINTERPRET_CAST(const jschar *,
                                               PromiseFlatString(source).get()),
                                           source.Length(), filename.get(),
                                           lineNo, rval)) {
         jsval exn;
-        if (JS_GetPendingException(sandcx, &exn)) {
-            AutoJSSuspendRequestWithNoCallContext sus(sandcx);
+        if (JS_GetPendingException(sandcx->GetJSContext(), &exn)) {
+            AutoJSSuspendRequestWithNoCallContext sus(sandcx->GetJSContext());
             AutoJSRequestWithNoCallContext cxreq(cx);
 
             JS_SetPendingException(cx, exn);
             cc->SetExceptionWasThrown(PR_TRUE);
         } else {
             rv = NS_ERROR_OUT_OF_MEMORY;
         }
     } else {
Index: security/manager/ssl/src/nsCrypto.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsCrypto.cpp,v
retrieving revision 1.66
diff -p -U8 -r1.66 nsCrypto.cpp
--- security/manager/ssl/src/nsCrypto.cpp	13 Jun 2006 03:07:44 -0000	1.66
+++ security/manager/ssl/src/nsCrypto.cpp	24 Jun 2006 01:38:07 -0000
@@ -150,16 +150,17 @@ typedef struct nsKeyPairInfoStr {
 
 
 //This class is just used to pass arguments
 //to the nsCryptoRunnable event.
 class nsCryptoRunArgs : public nsISupports {
 public:
   nsCryptoRunArgs();
   virtual ~nsCryptoRunArgs();
+  nsCOMPtr<nsISupports> m_kungFuDeathGrip;
   JSContext *m_cx;
   JSObject  *m_scope;
   nsCOMPtr<nsIPrincipal> m_principals;
   nsXPIDLCString m_jsCallback;
   NS_DECL_ISUPPORTS
 };
 
 //This class is used to run the callback code
@@ -1408,17 +1409,25 @@ nsCreateReqFromKeyPairs(nsKeyPairInfo *k
   retString = NSSBase64_EncodeItem (nsnull, nsnull, 0, encodedReq);
   SECITEM_FreeItem(encodedReq, PR_TRUE);
   return retString;
 loser:
   nsFreeCertReqMessages(certReqMsgs,numRequests);
   return nsnull;;
 }
 
-                                                 
+static nsISupports *
+GetISupportsFromContext(JSContext *cx)
+{
+    if (JS_GetOptions(cx) & JSOPTION_PRIVATE_IS_NSISUPPORTS)
+        return NS_STATIC_CAST(nsISupports *, JS_GetContextPrivate(cx));
+
+    return nsnull;
+}
+
 //The top level method which is a member of nsIDOMCrypto
 //for generate a base64 encoded CRMF request.
 NS_IMETHODIMP
 nsCrypto::GenerateCRMFRequest(nsIDOMCRMFObject** aReturn)
 {
   nsNSSShutDownPreventionLock locker;
   *aReturn = nsnull;
   nsresult nrv;
@@ -1615,16 +1624,17 @@ nsCrypto::GenerateCRMFRequest(nsIDOMCRMF
   nsCOMPtr<nsIPrincipal>principals;
   principals = GetScriptPrincipal(cx);
   NS_ASSERTION(principals, "Couldn't get the principals");
   nsCryptoRunArgs *args = new nsCryptoRunArgs();
   if (!args)
     return NS_ERROR_OUT_OF_MEMORY;
 
   args->m_cx         = cx;
+  args->m_kungFuDeathGrip = GetISupportsFromContext(cx);
   args->m_scope      = JS_GetParent(cx, script_obj);
   args->m_jsCallback.Adopt(jsCallback ? nsCRT::strdup(jsCallback) : 0);
   args->m_principals = principals;
   
   nsCryptoRunnable *cryptoRunnable = new nsCryptoRunnable(args);
   if (!cryptoRunnable)
     return NS_ERROR_OUT_OF_MEMORY;
 
