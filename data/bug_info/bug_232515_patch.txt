diff --git a/mailnews/compose/src/nsMsgSend.cpp b/mailnews/compose/src/nsMsgSend.cpp
--- a/mailnews/compose/src/nsMsgSend.cpp
+++ b/mailnews/compose/src/nsMsgSend.cpp
@@ -641,19 +641,22 @@ nsMsgComposeAndSend::GatherMimeAttachmen
         attachments[i].highbit_count = ma->m_highbit_count;
         attachments[i].ctl_count = ma->m_ctl_count;
         attachments[i].null_count = ma->m_null_count;
         attachments[i].max_line_length = ma->m_max_column;
 
         /* Doesn't really matter, but let's not lie about encoding
            in case it does someday. */
         if (attachments[i].highbit_count > 0 && attachments[i].encoding &&
             !PL_strcasecmp(attachments[i].encoding, ENCODING_7BIT))
-          attachments[i].encoding = ENCODING_8BIT;
+        {
+          PR_Free(attachments[i].encoding);
+          attachments[i].encoding = PL_strdup(ENCODING_8BIT);
+        }
       }
 
       m_attachments_done_callback(nsnull, nsnull, attachments);
       PR_FREEIF(attachments);
       m_attachments_done_callback = nsnull;
     }
     goto FAIL;
   }
 
@@ -807,29 +810,25 @@ nsMsgComposeAndSend::GatherMimeAttachmen
   /*
     Determine the encoding of the main message body before we free it.
     The proper way to do this should be to test whatever text is in mainbody
     just before writing it out, but that will require a fix that is less safe
     and takes more memory. */
   PR_FREEIF(m_attachment1_encoding);
   if (m_attachment1_body)
     mCompFields->GetBodyIsAsciiOnly(&body_is_us_ascii);
 
-  if (mCompFields->GetForceMsgEncoding())
-    body_is_us_ascii = PR_FALSE;
-
-  if (nsMsgI18Nstateful_charset(mCompFields->GetCharacterSet()) ||
-      body_is_us_ascii)
+  if (!mCompFields->GetForceMsgEncoding() && (body_is_us_ascii ||
+      nsMsgI18Nstateful_charset(mCompFields->GetCharacterSet())))
     m_attachment1_encoding = PL_strdup (ENCODING_7BIT);
   else if (mime_use_quoted_printable_p)
     m_attachment1_encoding = PL_strdup (ENCODING_QUOTED_PRINTABLE);
   else
     m_attachment1_encoding = PL_strdup (ENCODING_8BIT);
-
   PR_FREEIF (m_attachment1_body);
 
   maincontainer = mainbody;
 
   // If we were given a pre-saved collection of HTML and contained images,
   // then we want mainbody to point to the HTML lump therein.
   if (m_related_part)
   {
     // If m_related_part is of type text/html, set both maincontainer
@@ -857,33 +856,33 @@ nsMsgComposeAndSend::GatherMimeAttachmen
     status = plainpart->SetType(TEXT_PLAIN);
     if (status < 0)
       goto FAIL;
     status = plainpart->SetFile(m_plaintext->mTmpFile);
     if (status < 0)
       goto FAIL;
 
     m_plaintext->mMainBody = PR_TRUE;
 
-    m_plaintext->AnalyzeSnarfedFile(); // look for 8 bit text, long lines, etc.
+    // Determine Content-Transfer-Encoding for the attachments.
     m_plaintext->PickEncoding(mCompFields->GetCharacterSet(), this);
     const char *charset = mCompFields->GetCharacterSet();
     hdrs = mime_generate_attachment_headers(m_plaintext->m_type,
                         nsnull,
                         m_plaintext->m_encoding,
                         m_plaintext->m_description,
                         m_plaintext->m_x_mac_type,
                         m_plaintext->m_x_mac_creator,
                         nsnull, 0,
                         m_digest_p,
                         m_plaintext,
                         charset,
                         charset,
-                        mCompFields->GetBodyIsAsciiOnly(),
+                        body_is_us_ascii,
                         nsnull,
                         PR_TRUE);
     if (!hdrs)
       goto FAILMEM;
     status = plainpart->SetOtherHeaders(hdrs);
     PR_Free(hdrs);
     hdrs = nsnull;
     if (status < 0)
       goto FAIL;
@@ -3251,18 +3250,54 @@ nsMsgComposeAndSend::Init(
   if (!mUserIdentity) return NS_ERROR_UNEXPECTED;
 
   //
   // First sanity check the composition fields parameter and
   // see if we should continue
   //
   if (!fields)
     return NS_ERROR_OUT_OF_MEMORY;
 
+  m_digest_p = digest_p;
+
+  //
+  // Needed for mime encoding!
+  //
+  PRBool strictly_mime = PR_TRUE;
+  nsCOMPtr<nsIPrefBranch> pPrefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID));
+  if (pPrefBranch)
+  {
+    rv = pPrefBranch->GetBoolPref(PREF_MAIL_STRICTLY_MIME, &strictly_mime);
+    rv = pPrefBranch->GetIntPref(PREF_MAIL_MESSAGE_WARNING_SIZE, (PRInt32 *) &mMessageWarningSize);
+  }
+
+  nsCOMPtr<nsIMsgComposeSecure> secureCompose
+    = do_CreateInstance(NS_MSGCOMPOSESECURE_CONTRACTID, &rv);
+  // It's not an error scenario if there is no secure compose.
+  // The S/MIME extension may be unavailable.
+  if (NS_SUCCEEDED(rv) && secureCompose)
+  {
+    PRBool requiresEncryptionWork = PR_FALSE;
+    rv = secureCompose->RequiresCryptoEncapsulation(aUserIdentity, fields,
+                                                    &requiresEncryptionWork);
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (requiresEncryptionWork)
+    {
+      strictly_mime = PR_TRUE;
+      // RFC2633 3.1.3 doesn't require multipart/signed entities to have
+      // transfer encoding applied for ascii, but do it anyway to make sure
+      // the content (e.g. line endings) isn't mangled along the way.
+      fields->SetForceMsgEncoding(PR_TRUE);
+    }
+  }
+
+  nsMsgMIMESetConformToStandard(strictly_mime);
+  mime_use_quoted_printable_p = strictly_mime;
+
   rv = InitCompositionFields(fields, aOriginalMsgURI, aType);
   if (NS_FAILED(rv))
     return rv;
 
   //
   // At this point, if we are only creating this object to do
   // send operations on externally created RFC822 disk files,
   // make sure we have setup the appropriate nsIFile and
   // move on with life.
@@ -3270,43 +3305,18 @@ nsMsgComposeAndSend::Init(
   //
   // First check to see if we are doing a send operation on an external file
   // or creating the file itself.
   //
   if (sendFile)
   {
     mTempFile = sendFile;
     return NS_OK;
   }
-
-  m_digest_p = digest_p;
-
-  //
-  // Needed for mime encoding!
-  //
-  PRBool strictly_mime = PR_TRUE;
-  nsCOMPtr<nsIPrefBranch> pPrefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID));
-  if (pPrefBranch)
-  {
-    rv = pPrefBranch->GetBoolPref(PREF_MAIL_STRICTLY_MIME, &strictly_mime);
-    rv = pPrefBranch->GetIntPref(PREF_MAIL_MESSAGE_WARNING_SIZE, (PRInt32 *) &mMessageWarningSize);
-  }
-
-  if (!strictly_mime)
-  {
-    nsresult rv = NS_OK;
-    nsCOMPtr<nsIMsgComposeSecure> secureCompose;
-    secureCompose = do_CreateInstance(NS_MSGCOMPOSESECURE_CONTRACTID, &rv);
-    if (NS_SUCCEEDED(rv) && secureCompose)
-      secureCompose->RequiresCryptoEncapsulation(aUserIdentity, fields, &strictly_mime);
-  }
-
-  nsMsgMIMESetConformToStandard(strictly_mime);
-  mime_use_quoted_printable_p = strictly_mime;
 
   // Ok, now watch me pull a rabbit out of my hat....what we need
   // to do here is figure out what the body will be. If this is a
   // MHTML request, then we need to do some processing of the document
   // and figure out what we need to package along with this message
   // to send. See ProcessMultipartRelated() for further details.
   //
 
   //
@@ -3330,19 +3340,19 @@ nsMsgComposeAndSend::Init(
 }
 
 NS_IMETHODIMP nsMsgComposeAndSend::SendDeliveryCallback(nsIURI *aUrl, PRBool inIsNewsDelivery, nsresult aExitCode)
 {
   if (inIsNewsDelivery)
   {
     if (NS_FAILED(aExitCode))
       if (aExitCode != NS_ERROR_ABORT && !NS_IS_MSG_ERROR(aExitCode))
         aExitCode = NS_ERROR_POST_FAILED;
-    
+
     DeliverAsNewsExit(aUrl, aExitCode);
   }
   else
   {
     if (NS_FAILED(aExitCode))
     {
       switch (aExitCode)
       {
         case NS_ERROR_UNKNOWN_HOST:
