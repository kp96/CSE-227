# HG changeset patch
# Parent 32c49de2fe07316a6a6e60da2ff9c26cddf3da87
Bug 675702 - Make nsICertVerificationListener callback happen on the main thread, so that it isn't necessary to use XPCOM proxies or other trickeries for a simple API, r?mayhemer

diff --git a/security/manager/pki/resources/content/viewCertDetails.js b/security/manager/pki/resources/content/viewCertDetails.js
--- a/security/manager/pki/resources/content/viewCertDetails.js
+++ b/security/manager/pki/resources/content/viewCertDetails.js
@@ -129,19 +129,17 @@ function setWindowName()
   //  The chain of trust
   var chain = cert.getChain();
   AddCertChain("treesetDump", chain, "dump_");
   DisplayGeneralDataFromCert(cert);
   BuildPrettyPrint(cert);
   
   if (cert instanceof nsIX509Cert3)
   {
-    cert.requestUsagesArrayAsync(
-            getProxyOnUIThread(new listener(),
-                               Components.interfaces.nsICertVerificationListener));
+    cert.requestUsagesArrayAsync(new listener());
   }
 }
 
  
 function addChildrenToTree(parentTree,label,value,addTwistie)
 {
   var treeChild1 = document.createElement("treechildren");
   var treeElement = addTreeItemToTreeChild(treeChild1,label,value,addTwistie);
@@ -311,30 +309,16 @@ function updateCertDump()
     //  Get the cert from the cert database
     var certdb = Components.classes[nsX509CertDB].getService(nsIX509CertDB);
     var cert = certdb.findCertByDBKey(dbKey,null);
     asn1Tree.loadASN1Structure(cert.ASN1Structure);
   }
   displaySelected();
 }
 
-function getProxyOnUIThread(aObject, aInterface) {
-    var mainThread = Components.
-            classes["@mozilla.org/thread-manager;1"].
-            getService().mainThread;
-
-    var proxyMgr = Components.
-            classes["@mozilla.org/xpcomproxy;1"].
-            getService(Components.interfaces.nsIProxyObjectManager);
-
-    return proxyMgr.getProxyForObject(mainThread,
-            aInterface, aObject, 5);
-    // 5 == NS_PROXY_ALWAYS | NS_PROXY_SYNC
-}
-
 function getCurrentCert()
 {
   var realIndex;
   var tree = document.getElementById('treesetDump');
   if (tree.view.selection.isSelected(tree.currentIndex)
       && document.getElementById('prettyprint_tab').selected) {
     /* if the user manually selected a cert on the Details tab,
        then take that one  */
diff --git a/security/manager/ssl/public/nsIX509Cert3.idl b/security/manager/ssl/public/nsIX509Cert3.idl
--- a/security/manager/ssl/public/nsIX509Cert3.idl
+++ b/security/manager/ssl/public/nsIX509Cert3.idl
@@ -52,17 +52,17 @@ interface nsIX509Cert3 : nsIX509Cert2 {
   const unsigned long CMS_CHAIN_MODE_CertOnly = 1;
   const unsigned long CMS_CHAIN_MODE_CertChain = 2;
   const unsigned long CMS_CHAIN_MODE_CertChainWithRoot = 3;
 
   /**
    *  Async version of nsIX509Cert::getUsagesArray()
    *
    *  Will not block, will request results asynchronously,
-   *  availability of results will be notified.
+   *  availability of results will be notified on the main thread.
    */ 
   void requestUsagesArrayAsync(in nsICertVerificationListener cvl);
 
   /**
    *  Obtain the certificate wrapped in a PKCS#7 SignedData structure,
    *  with or without the certificate chain
    *
    *  @param chainMode Whether to include the chain (with or without the root),
diff --git a/security/manager/ssl/src/nsCertVerificationThread.cpp b/security/manager/ssl/src/nsCertVerificationThread.cpp
--- a/security/manager/ssl/src/nsCertVerificationThread.cpp
+++ b/security/manager/ssl/src/nsCertVerificationThread.cpp
@@ -33,23 +33,48 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsMemory.h"
 #include "nsAutoPtr.h"
 #include "nsCertVerificationThread.h"
+#include "nsThreadUtils.h"
 
 using namespace mozilla;
 
 nsCertVerificationThread *nsCertVerificationThread::verification_thread_singleton;
 
 NS_IMPL_THREADSAFE_ISUPPORTS1(nsCertVerificationResult, nsICertVerificationResult)
 
+namespace {
+class DispatchCertVerificationResult : public nsRunnable
+{
+public:
+  DispatchCertVerificationResult(nsICertVerificationListener* aListener,
+                                 nsIX509Cert3* aCert,
+                                 nsICertVerificationResult* aResult)
+    : mListener(aListener)
+    , mCert(aCert)
+    , mResult(aResult)
+  { }
+
+  NS_IMETHOD Run() {
+    mListener->Notify(mCert, mResult);
+    return NS_OK;
+  }
+
+private:
+  nsCOMPtr<nsICertVerificationListener> mListener;
+  nsCOMPtr<nsIX509Cert3> mCert;
+  nsCOMPtr<nsICertVerificationResult> mResult;
+};
+} // anonymous namespace
+
 void nsCertVerificationJob::Run()
 {
   if (!mListener || !mCert)
     return;
 
   PRUint32 verified;
   PRUint32 count;
   PRUnichar **usages;
@@ -69,17 +94,18 @@ void nsCertVerificationJob::Run()
       vres->mCount = count;
       vres->mUsages = usages;
     }
 
     ires = vres;
   }
   
   nsCOMPtr<nsIX509Cert3> c3 = do_QueryInterface(mCert);
-  mListener->Notify(c3, ires);
+  nsCOMPtr<nsIRunnable> r = new DispatchCertVerificationResult(mListener, c3, ires);
+  NS_DispatchToMainThread(r);
 }
 
 void nsSMimeVerificationJob::Run()
 {
   if (!mMessage || !mListener)
     return;
   
   nsresult rv;
