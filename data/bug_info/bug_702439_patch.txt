diff --git a/content/base/src/nsCSPService.cpp b/content/base/src/nsCSPService.cpp
--- a/content/base/src/nsCSPService.cpp
+++ b/content/base/src/nsCSPService.cpp
@@ -55,6 +55,9 @@
 #include "nsIAsyncVerifyRedirectCallback.h"
 #include "nsAsyncRedirectVerifyHelper.h"
 #include "mozilla/Preferences.h"
+#include "nsServiceManagerUtils.h"
+#include "nsIConsoleService.h"
+#include "nsIScriptError.h"
 
 using namespace mozilla;
 
@@ -283,11 +286,29 @@ CSPService::AsyncOnChannelRedirect(nsICh
 
   // the redirect is permitted, so propagate the Content Security Policy
   // and load type to the redirecting channel
-  nsresult rv;
-  nsCOMPtr<nsIWritablePropertyBag2> props2 = do_QueryInterface(newChannel, &rv);
-  if (props2)
+  nsCOMPtr<nsIWritablePropertyBag2> props2 = do_QueryInterface(newChannel);
+  if (props2) {
     props2->SetPropertyAsInterface(NS_CHANNEL_PROP_CHANNEL_POLICY,
                                    channelPolicy);
+    return NS_OK;
+  }
 
-  return NS_OK;
+  // The redirecting channel isn't a writable property bag, we won't be able
+  // to enforce the load policy if it redirects again, so we stop it now.
+  // Attempt to log a warning to the console.
+  nsCOMPtr<nsIConsoleService> console(do_GetService(NS_CONSOLESERVICE_CONTRACTID));
+  if (console) {
+    nsCOMPtr<nsIScriptError> error(do_CreateInstance(NS_SCRIPTERROR_CONTRACTID));
+    if (error) {
+      nsCAutoString msg, newUriSpec;
+      msg.Append("Unable to redirect to ");
+      newUri->GetSpec(newUriSpec);
+      msg.Append(newUriSpec);
+      error->Init(NS_ConvertUTF8toUTF16(msg).get(), nsnull, nsnull, 0, 0,
+                  nsIScriptError::warningFlag, "Redirect Error");
+      console->LogMessage(error);
+    }
+  }
+
+  return NS_BINDING_FAILED;
 }
diff --git a/content/base/test/Makefile.in b/content/base/test/Makefile.in
--- a/content/base/test/Makefile.in
+++ b/content/base/test/Makefile.in
@@ -529,6 +529,9 @@ _TEST_FILES2 = \
 		test_bug693875.html \
 		test_nodelist_holes.html \
 		test_xhr_abort_after_load.html \
+		test_bug702439.html \
+		test_bug702439.html^headers^ \
+		file_bug702439.html \
 		$(NULL)
 
 _CHROME_FILES =	\
diff --git a/content/base/test/file_bug702439.html b/content/base/test/file_bug702439.html
new file mode 100644
--- /dev/null
+++ b/content/base/test/file_bug702439.html
@@ -0,0 +1,14 @@
+<!DOCTYPE html>
+<html>
+<head>
+<script>
+  function test() {
+    parent.js_url_ran = true;
+    parent.finishTest();
+  }
+</script>
+</head>
+<body>
+<a id="a" href="javascript:test()">click</a>
+</body>
+</html>
diff --git a/content/base/test/test_bug702439.html b/content/base/test/test_bug702439.html
new file mode 100644
--- /dev/null
+++ b/content/base/test/test_bug702439.html
@@ -0,0 +1,34 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=702439
+
+Test that a document with a CSP allows javascript: URLs in its
+subframes to execute.
+-->
+<head>
+  <title>Test for Bug 702439</title>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body onload="runTest();">
+
+<iframe id="frame" src="file_bug702439.html"></iframe>
+
+<script class="testbody" type="text/javascript">
+var js_url_ran = false;
+
+function runTest() {
+  var frame = document.getElementById("frame");
+  frame.contentDocument.getElementById("a").click();
+};
+
+function finishTest() {
+  is(js_url_ran, true, "javascript URL in iframe didn't execute");
+  SimpleTest.finish();
+}
+
+SimpleTest.waitForExplicitFinish();
+</script>
+</body>
+</html>
diff --git a/content/base/test/test_bug702439.html^headers^ b/content/base/test/test_bug702439.html^headers^
new file mode 100644
--- /dev/null
+++ b/content/base/test/test_bug702439.html^headers^
@@ -0,0 +1,1 @@
+X-Content-Security-Policy: default-src *; options inline-script
diff --git a/netwerk/base/public/nsNetUtil.h b/netwerk/base/public/nsNetUtil.h
--- a/netwerk/base/public/nsNetUtil.h
+++ b/netwerk/base/public/nsNetUtil.h
@@ -232,7 +232,7 @@ NS_NewChannel(nsIChannel           **res
             if (loadFlags != nsIRequest::LOAD_NORMAL)
                 rv |= chan->SetLoadFlags(loadFlags);
             if (channelPolicy) {
-                nsCOMPtr<nsIWritablePropertyBag2> props = do_QueryInterface(chan, &rv);
+                nsCOMPtr<nsIWritablePropertyBag2> props = do_QueryInterface(chan);
                 if (props) {
                     props->SetPropertyAsInterface(NS_CHANNEL_PROP_CHANNEL_POLICY,
                                                   channelPolicy);
