{"bug_id":160122,"commitHash":"8f7beba","commit_info":{"sha":"8f7bebaa5c52bd222d3125942fb1f82726ea2aac","commit":{"author":{"name":"Cykesiopka","email":"cykesiopka.bmo@gmail.com","date":"2016-05-11T06:38:55Z"},"committer":{"name":"Cykesiopka","email":"cykesiopka.bmo@gmail.com","date":"2016-05-11T06:38:55Z"},"message":"Bug 160122 - Stop using PR_smprintf in PSM. r=keeler\n\nThe (more) modern Mozilla string classes can be used instead, which at the very\nleast provide built in automatic memory management and performance improvements.\n\nMozReview-Commit-ID: 4l2Er5rkeI0\n\n--HG--\nextra : transplant_source : %A1%16%AB%02m%CA%25HfW%40%96Mq%0D%F0%91%9C%99%29","tree":{"sha":"057a6908897867f53c3b33829d29b4c34ae2cd8c","url":"https://api.github.com/repos/mozilla/gecko-dev/git/trees/057a6908897867f53c3b33829d29b4c34ae2cd8c"},"url":"https://api.github.com/repos/mozilla/gecko-dev/git/commits/8f7bebaa5c52bd222d3125942fb1f82726ea2aac","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/mozilla/gecko-dev/commits/8f7bebaa5c52bd222d3125942fb1f82726ea2aac","html_url":"https://github.com/mozilla/gecko-dev/commit/8f7bebaa5c52bd222d3125942fb1f82726ea2aac","comments_url":"https://api.github.com/repos/mozilla/gecko-dev/commits/8f7bebaa5c52bd222d3125942fb1f82726ea2aac/comments","author":null,"committer":null,"parents":[{"sha":"79ae391df91d367774cccdbf495c7f30d4e74818","url":"https://api.github.com/repos/mozilla/gecko-dev/commits/79ae391df91d367774cccdbf495c7f30d4e74818","html_url":"https://github.com/mozilla/gecko-dev/commit/79ae391df91d367774cccdbf495c7f30d4e74818"}],"stats":{"total":175,"additions":86,"deletions":89},"files":[{"sha":"9d833c84aab428d9b36ed9e37f0a33ae8c6fcb93","filename":"security/certverifier/NSSCertDBTrustDomain.cpp","status":"modified","additions":65,"deletions":60,"changes":125,"blob_url":"https://github.com/mozilla/gecko-dev/blob/8f7bebaa5c52bd222d3125942fb1f82726ea2aac/security/certverifier/NSSCertDBTrustDomain.cpp","raw_url":"https://github.com/mozilla/gecko-dev/raw/8f7bebaa5c52bd222d3125942fb1f82726ea2aac/security/certverifier/NSSCertDBTrustDomain.cpp","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/security/certverifier/NSSCertDBTrustDomain.cpp?ref=8f7bebaa5c52bd222d3125942fb1f82726ea2aac","patch":"@@ -16,6 +16,7 @@\n #include \"cert.h\"\n #include \"certdb.h\"\n #include \"mozilla/UniquePtr.h\"\n+#include \"mozilla/unused.h\"\n #include \"nsNSSCertificate.h\"\n #include \"nsServiceManagerUtils.h\"\n #include \"nss.h\"\n@@ -1016,16 +1017,16 @@ LoadLoadableRoots(/*optional*/ const char* dir, const char* modNameUTF8)\n   int modType;\n   SECMOD_DeleteModule(modNameUTF8, &modType);\n \n-  UniquePtr<char, void(&)(char*)>\n-    pkcs11ModuleSpec(PR_smprintf(\"name=\\\"%s\\\" library=\\\"%s\\\"\", modNameUTF8,\n-                                 escapedFullLibraryPath.get()),\n-                     PR_smprintf_free);\n-  if (!pkcs11ModuleSpec) {\n+  nsAutoCString pkcs11ModuleSpec;\n+  pkcs11ModuleSpec.AppendPrintf(\"name=\\\"%s\\\" library=\\\"%s\\\"\", modNameUTF8,\n+                                escapedFullLibraryPath.get());\n+  if (pkcs11ModuleSpec.IsEmpty()) {\n     return SECFailure;\n   }\n \n-  UniqueSECMODModule rootsModule(SECMOD_LoadUserModule(pkcs11ModuleSpec.get(),\n-                                                       nullptr, false));\n+  UniqueSECMODModule rootsModule(\n+    SECMOD_LoadUserModule(const_cast<char*>(pkcs11ModuleSpec.get()), nullptr,\n+                          false));\n   if (!rootsModule) {\n     return SECFailure;\n   }\n@@ -1049,60 +1050,55 @@ UnloadLoadableRoots(const char* modNameUTF8)\n   }\n }\n \n-char*\n-DefaultServerNicknameForCert(CERTCertificate* cert)\n+nsresult\n+DefaultServerNicknameForCert(const CERTCertificate* cert,\n+                     /*out*/ nsCString& nickname)\n {\n-  char* nickname = nullptr;\n-  int count;\n-  bool conflict;\n-  char* servername = nullptr;\n-\n-  servername = CERT_GetCommonName(&cert->subject);\n-  if (!servername) {\n-    // Certs without common names are strange, but they do exist...\n-    // Let's try to use another string for the nickname\n-    servername = CERT_GetOrgUnitName(&cert->subject);\n-    if (!servername) {\n-      servername = CERT_GetOrgName(&cert->subject);\n-      if (!servername) {\n-        servername = CERT_GetLocalityName(&cert->subject);\n-        if (!servername) {\n-          servername = CERT_GetStateName(&cert->subject);\n-          if (!servername) {\n-            servername = CERT_GetCountryName(&cert->subject);\n-            if (!servername) {\n-              // We tried hard, there is nothing more we can do.\n-              // A cert without any names doesn't really make sense.\n-              return nullptr;\n-            }\n-          }\n-        }\n-      }\n-    }\n+  MOZ_ASSERT(cert);\n+  NS_ENSURE_ARG_POINTER(cert);\n+\n+  UniquePORTString baseName(CERT_GetCommonName(&cert->subject));\n+  if (!baseName) {\n+    baseName = UniquePORTString(CERT_GetOrgUnitName(&cert->subject));\n+  }\n+  if (!baseName) {\n+    baseName = UniquePORTString(CERT_GetOrgName(&cert->subject));\n+  }\n+  if (!baseName) {\n+    baseName = UniquePORTString(CERT_GetLocalityName(&cert->subject));\n+  }\n+  if (!baseName) {\n+    baseName = UniquePORTString(CERT_GetStateName(&cert->subject));\n+  }\n+  if (!baseName) {\n+    baseName = UniquePORTString(CERT_GetCountryName(&cert->subject));\n+  }\n+  if (!baseName) {\n+    return NS_ERROR_FAILURE;\n   }\n \n-  count = 1;\n-  while (1) {\n-    if (count == 1) {\n-      nickname = PR_smprintf(\"%s\", servername);\n+  // This function is only used in contexts where a failure to find a suitable\n+  // nickname does not block the overall task from succeeding.\n+  // As such, we use an arbitrary limit to prevent this nickname searching\n+  // process from taking forever.\n+  static const uint32_t ARBITRARY_LIMIT = 500;\n+  for (uint32_t count = 1; count < ARBITRARY_LIMIT; count++) {\n+    nickname = baseName.get();\n+    if (count != 1) {\n+      nickname.AppendPrintf(\" #%u\", count);\n     }\n-    else {\n-      nickname = PR_smprintf(\"%s #%d\", servername, count);\n-    }\n-    if (!nickname) {\n-      break;\n+    if (nickname.IsEmpty()) {\n+      return NS_ERROR_FAILURE;\n     }\n \n-    conflict = SEC_CertNicknameConflict(nickname, &cert->derSubject,\n-                                        cert->dbhandle);\n+    bool conflict = SEC_CertNicknameConflict(nickname.get(), &cert->derSubject,\n+                                             cert->dbhandle);\n     if (!conflict) {\n-      break;\n+      return NS_OK;\n     }\n-    PR_Free(nickname);\n-    count++;\n   }\n-  PR_FREEIF(servername);\n-  return nickname;\n+\n+  return NS_ERROR_FAILURE;\n }\n \n void\n@@ -1112,6 +1108,11 @@ SaveIntermediateCerts(const UniqueCERTCertList& certList)\n     return;\n   }\n \n+  UniquePK11SlotInfo slot(PK11_GetInternalKeySlot());\n+  if (!slot) {\n+    return;\n+  }\n+\n   bool isEndEntity = true;\n   for (CERTCertListNode* node = CERT_LIST_HEAD(certList);\n         !CERT_LIST_END(node, certList);\n@@ -1133,15 +1134,19 @@ SaveIntermediateCerts(const UniqueCERTCertList& certList)\n     }\n \n     // We have found a signer cert that we want to remember.\n-    char* nickname = DefaultServerNicknameForCert(node->cert);\n-    if (nickname && *nickname) {\n-      UniquePK11SlotInfo slot(PK11_GetInternalKeySlot());\n-      if (slot) {\n-        PK11_ImportCert(slot.get(), node->cert, CK_INVALID_HANDLE,\n-                        nickname, false);\n-      }\n+    nsAutoCString nickname;\n+    nsresult rv = DefaultServerNicknameForCert(node->cert, nickname);\n+    if (NS_FAILED(rv)) {\n+      continue;\n     }\n-    PR_FREEIF(nickname);\n+\n+    // Saving valid intermediate certs to the database is a compatibility hack\n+    // to work around unknown issuer errors for incorrectly configured servers\n+    // that fail to send the necessary intermediate certs. As such, we ignore\n+    // the return value of PK11_ImportCert(), since it doesn't really matter if\n+    // it fails.\n+    Unused << PK11_ImportCert(slot.get(), node->cert, CK_INVALID_HANDLE,\n+                              nickname.get(), false);\n   }\n }\n "},{"sha":"f34f22229ad3a92b29be20ba3968d17231ffd882","filename":"security/certverifier/NSSCertDBTrustDomain.h","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/mozilla/gecko-dev/blob/8f7bebaa5c52bd222d3125942fb1f82726ea2aac/security/certverifier/NSSCertDBTrustDomain.h","raw_url":"https://github.com/mozilla/gecko-dev/raw/8f7bebaa5c52bd222d3125942fb1f82726ea2aac/security/certverifier/NSSCertDBTrustDomain.h","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/security/certverifier/NSSCertDBTrustDomain.h?ref=8f7bebaa5c52bd222d3125942fb1f82726ea2aac","patch":"@@ -10,6 +10,7 @@\n #include \"CertVerifier.h\"\n #include \"ScopedNSSTypes.h\"\n #include \"nsICertBlocklist.h\"\n+#include \"nsString.h\"\n #include \"pkix/pkixtypes.h\"\n #include \"secmodt.h\"\n \n@@ -37,8 +38,8 @@ SECStatus LoadLoadableRoots(/*optional*/ const char* dir,\n \n void UnloadLoadableRoots(const char* modNameUTF8);\n \n-// Caller must free the result with PR_Free\n-char* DefaultServerNicknameForCert(CERTCertificate* cert);\n+nsresult DefaultServerNicknameForCert(const CERTCertificate* cert,\n+                              /*out*/ nsCString& nickname);\n \n void SaveIntermediateCerts(const UniqueCERTCertList& certList);\n "},{"sha":"ddfd5afcafd7b969e52f591e5135919ff0e6ef3c","filename":"security/manager/ssl/nsCertOverrideService.cpp","status":"modified","additions":6,"deletions":9,"changes":15,"blob_url":"https://github.com/mozilla/gecko-dev/blob/8f7bebaa5c52bd222d3125942fb1f82726ea2aac/security/manager/ssl/nsCertOverrideService.cpp","raw_url":"https://github.com/mozilla/gecko-dev/raw/8f7bebaa5c52bd222d3125942fb1f82726ea2aac/security/manager/ssl/nsCertOverrideService.cpp","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/security/manager/ssl/nsCertOverrideService.cpp?ref=8f7bebaa5c52bd222d3125942fb1f82726ea2aac","patch":"@@ -373,27 +373,24 @@ nsCertOverrideService::RememberValidityOverride(const nsACString& aHostName,\n     return NS_ERROR_FAILURE;\n   }\n \n-  char* nickname = DefaultServerNicknameForCert(nsscert.get());\n-  if (!aTemporary && nickname && *nickname)\n-  {\n+  nsAutoCString nickname;\n+  nsresult rv = DefaultServerNicknameForCert(nsscert.get(), nickname);\n+  if (!aTemporary && NS_SUCCEEDED(rv)) {\n     UniquePK11SlotInfo slot(PK11_GetInternalKeySlot());\n     if (!slot) {\n-      PR_Free(nickname);\n       return NS_ERROR_FAILURE;\n     }\n \n     SECStatus srv = PK11_ImportCert(slot.get(), nsscert.get(), CK_INVALID_HANDLE,\n-                                    nickname, false);\n+                                    nickname.get(), false);\n     if (srv != SECSuccess) {\n-      PR_Free(nickname);\n       return NS_ERROR_FAILURE;\n     }\n   }\n-  PR_FREEIF(nickname);\n \n   nsAutoCString fpStr;\n-  nsresult rv = GetCertFingerprintByOidTag(nsscert.get(),\n-                  mOidTagForStoringNewHashes, fpStr);\n+  rv = GetCertFingerprintByOidTag(nsscert.get(), mOidTagForStoringNewHashes,\n+                                  fpStr);\n   if (NS_FAILED(rv))\n     return rv;\n "},{"sha":"e64296ff22b39a439f7cdffe9ca3c2c8015ef170","filename":"security/manager/ssl/nsNSSCertificateDB.cpp","status":"modified","additions":8,"deletions":14,"changes":22,"blob_url":"https://github.com/mozilla/gecko-dev/blob/8f7bebaa5c52bd222d3125942fb1f82726ea2aac/security/manager/ssl/nsNSSCertificateDB.cpp","raw_url":"https://github.com/mozilla/gecko-dev/raw/8f7bebaa5c52bd222d3125942fb1f82726ea2aac/security/manager/ssl/nsNSSCertificateDB.cpp","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/security/manager/ssl/nsNSSCertificateDB.cpp?ref=8f7bebaa5c52bd222d3125942fb1f82726ea2aac","patch":"@@ -1289,13 +1289,9 @@ nsNSSCertificateDB::get_default_nickname(CERTCertificate *cert,\n   NS_ConvertUTF16toUTF8 nickFmt(tmpNickFmt);\n \n   nsAutoCString baseName;\n-  char *temp_nn = PR_smprintf(nickFmt.get(), username.get(), caname.get());\n-  if (!temp_nn) {\n+  baseName.AppendPrintf(nickFmt.get(), username.get(), caname.get());\n+  if (baseName.IsEmpty()) {\n     return;\n-  } else {\n-    baseName = temp_nn;\n-    PR_smprintf_free(temp_nn);\n-    temp_nn = nullptr;\n   }\n \n   nickname = baseName;\n@@ -1310,28 +1306,26 @@ nsNSSCertificateDB::get_default_nickname(CERTCertificate *cert,\n     return;\n \n   if (!PK11_IsInternal(slot.get())) {\n-    char* tmp = PR_smprintf(\"%s:%s\", PK11_GetTokenName(slot.get()),\n-                            baseName.get());\n-    if (!tmp) {\n+    nsAutoCString tmp;\n+    tmp.AppendPrintf(\"%s:%s\", PK11_GetTokenName(slot.get()), baseName.get());\n+    if (tmp.IsEmpty()) {\n       nickname.Truncate();\n       return;\n     }\n     baseName = tmp;\n-    PR_smprintf_free(tmp);\n-\n     nickname = baseName;\n   }\n \n   int count = 1;\n   while (true) {\n     if ( count > 1 ) {\n-      char *tmp = PR_smprintf(\"%s #%d\", baseName.get(), count);\n-      if (!tmp) {\n+      nsAutoCString tmp;\n+      tmp.AppendPrintf(\"%s #%d\", baseName.get(), count);\n+      if (tmp.IsEmpty()) {\n         nickname.Truncate();\n         return;\n       }\n       nickname = tmp;\n-      PR_smprintf_free(tmp);\n     }\n \n     UniqueCERTCertificate dummycert;"},{"sha":"23502460a379d57c9241f20ac7a2e447ae8e17aa","filename":"security/manager/ssl/nsNSSCertificateDB.h","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/mozilla/gecko-dev/blob/8f7bebaa5c52bd222d3125942fb1f82726ea2aac/security/manager/ssl/nsNSSCertificateDB.h","raw_url":"https://github.com/mozilla/gecko-dev/raw/8f7bebaa5c52bd222d3125942fb1f82726ea2aac/security/manager/ssl/nsNSSCertificateDB.h","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/security/manager/ssl/nsNSSCertificateDB.h?ref=8f7bebaa5c52bd222d3125942fb1f82726ea2aac","patch":"@@ -5,13 +5,14 @@\n #ifndef nsNSSCertificateDB_h\n #define nsNSSCertificateDB_h\n \n+#include \"ScopedNSSTypes.h\"\n #include \"certt.h\"\n #include \"mozilla/Mutex.h\"\n #include \"mozilla/RefPtr.h\"\n #include \"mozilla/UniquePtr.h\"\n #include \"nsIX509CertDB.h\"\n #include \"nsNSSShutDown.h\"\n-#include \"ScopedNSSTypes.h\"\n+#include \"nsString.h\"\n \n class nsCString;\n class nsIArray;"},{"sha":"2d44592d1e2815fe008a8e98354d8819681df496","filename":"security/manager/ssl/nsPKCS12Blob.cpp","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/mozilla/gecko-dev/blob/8f7bebaa5c52bd222d3125942fb1f82726ea2aac/security/manager/ssl/nsPKCS12Blob.cpp","raw_url":"https://github.com/mozilla/gecko-dev/raw/8f7bebaa5c52bd222d3125942fb1f82726ea2aac/security/manager/ssl/nsPKCS12Blob.cpp","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/security/manager/ssl/nsPKCS12Blob.cpp?ref=8f7bebaa5c52bd222d3125942fb1f82726ea2aac","patch":"@@ -645,10 +645,9 @@ nsPKCS12Blob::nickname_collision(SECItem *oldNick, PRBool *cancel, void *wincx)\n     // without a corresponding cert.\n     //  XXX If a user imports *many* certs without the 'friendly name'\n     //      attribute, then this may take a long time.  :(\n+    nickname = nickFromPropC;\n     if (count > 1) {\n-      nickname.Adopt(PR_smprintf(\"%s #%d\", nickFromPropC.get(), count));\n-    } else {\n-      nickname = nickFromPropC;\n+      nickname.AppendPrintf(\" #%d\", count);\n     }\n     CERTCertificate *cert = CERT_FindCertByNickname(CERT_GetDefaultCertDB(),\n                                            const_cast<char*>(nickname.get()));"}]},"blames":["ee333796","391584fd","5ab8ccde","ea0e5ac1","3091f378","213974a8","128f004a","ea0e5ac1","391584fd","b1405bc4","3091f378","213974a8","128f004a","61d16d4c","7c4b2ba8","391584fd","4b57cbc1","6c15848f","65539ef8","2af33cad","214543d96","31db9b541","65539ef89","372fe1a59","391584fd9","6a5e8155","31db9b54","9cdbcf49","ab601313","c114606c","54bf02e6","6d758483"]}