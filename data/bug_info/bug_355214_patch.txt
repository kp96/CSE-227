Index: netwerk/base/src/nsProxyAutoConfig.js
===================================================================
RCS file: /cvsroot/mozilla/netwerk/base/src/nsProxyAutoConfig.js,v
retrieving revision 1.43
diff -p -U8 -r1.43 nsProxyAutoConfig.js
--- netwerk/base/src/nsProxyAutoConfig.js	3 Feb 2007 00:15:19 -0000	1.43
+++ netwerk/base/src/nsProxyAutoConfig.js	5 Feb 2007 18:05:17 -0000
@@ -47,16 +47,32 @@
 const kDNS_CONTRACTID = "@mozilla.org/network/dns-service;1";
 const kPAC_CONTRACTID = "@mozilla.org/network/proxy-auto-config;1";
 const kPAC_CID = Components.ID("{63ac8c66-1dd2-11b2-b070-84d00d3eaece}");
 
 const nsISupports        = Components.interfaces.nsISupports;
 const nsIProxyAutoConfig = Components.interfaces.nsIProxyAutoConfig;
 const nsIDNSService      = Components.interfaces.nsIDNSService;
 
+// Loaded once per PAC script, this is a safe way for the supplied functions
+// that require chrome privileges to turn a random untrusted object into a
+// string.
+var safeToString = null;
+function myToString(thisp) {
+    return thisp + '';
+}
+
+// This is like safeToString, except that it calls a given function with a
+// given this and arguments.
+var callFunction = null;
+function myCall(fun, thisp) {
+    var args = Array.prototype.slice.call(arguments, 2);
+    return fun.apply(thisp, args);
+}
+
 // implementor of nsIProxyAutoConfig
 function nsProxyAutoConfig() {};
 
 nsProxyAutoConfig.prototype = {
     // sandbox in which we eval loaded autoconfig js file
     _sandBox: null, 
 
     // ptr to eval'ed FindProxyForURL function
@@ -76,36 +92,47 @@ nsProxyAutoConfig.prototype = {
             this._sandBox = null;
             return;
         }
 
         // allocate a fresh Sandbox to clear global scope for new PAC script
         this._sandBox = new Components.utils.Sandbox(pacURI);
         Components.utils.evalInSandbox(pacUtils, this._sandBox);
 
+        safeToString =
+            Components.utils.evalInSandbox("(" + myToString.toSource() + ")",
+                                           this._sandBox);
+        callFunction =
+            Components.utils.evalInSandbox("(" + myCall.toSource() + ")",
+                                           this._sandBox);
+
         // add predefined functions to pac
         this._sandBox.importFunction(myIpAddress);
         this._sandBox.importFunction(dnsResolve);
         this._sandBox.importFunction(proxyAlert, "alert");
 
         // evaluate loaded js file
         Components.utils.evalInSandbox(pacText, this._sandBox);
         this._findProxyForURL = this._sandBox.FindProxyForURL;
     },
 
     getProxyForURI: function(testURI, testHost) {
         if (!this._findProxyForURL)
             return null;
 
         // Call the original function
-        return this._findProxyForURL.call(this._sandBox, testURI, testHost);
+        return callFunction(this._findProxyForURL, this._sandBox,
+                            testURI, testHost);
     }
 }
 
 function proxyAlert(msg) {
+    // Ensure that we have a string.
+    msg = safeToString(msg);
+
     try {
         // It would appear that the console service is threadsafe.
         var cns = Components.classes["@mozilla.org/consoleservice;1"]
                             .getService(Components.interfaces.nsIConsoleService);
         cns.logStringMessage("PAC-alert: "+msg);
     } catch (e) {
         dump("PAC: proxyAlert ERROR: "+e+"\n");
     }
@@ -117,16 +144,18 @@ function myIpAddress() {
         return dns.resolve(dns.myHostName, 0).getNextAddrAsString();
     } catch (e) {
         return '127.0.0.1';
     }
 }
 
 // wrapper for resolving hostnames called by PAC file
 function dnsResolve(host) {
+    host = safeToString(host);
+
     try {
         return dns.resolve(host, 0).getNextAddrAsString();
     } catch (e) {
         return null;
     }
 }
 
 var pacModule = new Object();
