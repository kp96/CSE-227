Index: mozilla/mailnews/mime/src/mimecms.cpp
===================================================================
RCS file: /cvsroot/mozilla/mailnews/mime/src/mimecms.cpp,v
retrieving revision 1.17
diff -u -r1.17 mimecms.cpp
--- mozilla/mailnews/mime/src/mimecms.cpp	13 Dec 2002 20:47:29 -0000	1.17
+++ mozilla/mailnews/mime/src/mimecms.cpp	28 Feb 2003 09:30:13 -0000
@@ -342,6 +344,72 @@
   return match;
 }
 
+int
+MIMEGetRelativeCryptoNestLevel(MimeObject *obj)
+{
+  /*
+    the part id of any mimeobj is mime_part_address(obj)
+    our currently displayed crypto part is obj
+    the part shown as the toplevel object in the current window is
+        obj->options->part_to_load
+        possibly stored in the toplevel object only ???
+        but hopefully all nested mimeobject point to the same displayooptions
+
+    we need to find out the nesting level of our currently displayed crypto object
+    wrt the shown part in the toplevel window
+  */
+
+  // if we are showing the toplevel message, aTopMessageNestLevel == 0
+  int aTopMessageNestLevel = 0;
+  MimeObject *aTopShownObject = nsnull;
+  if (obj && obj->options->part_to_load) {
+    PRBool aAlreadyFoundTop = PR_FALSE;
+    for (MimeObject *walker = obj; walker; walker = walker->parent) {
+      if (aAlreadyFoundTop) {
+        if (!mime_typep(walker, (MimeObjectClass *) &mimeEncryptedClass)
+            && !mime_typep(walker, (MimeObjectClass *) &mimeMultipartSignedClass)) {
+          ++aTopMessageNestLevel;
+        }
+      }
+      if (!aAlreadyFoundTop && 0 == strcmp(mime_part_address(walker), walker->options->part_to_load)) {
+        aAlreadyFoundTop = PR_TRUE;
+        aTopShownObject = walker;
+      }
+      if (!aAlreadyFoundTop && !walker->parent) {
+        aTopShownObject = walker;
+      }
+    }
+  }
+
+  PRBool CryptoObjectIsChildOfTopShownObject = PR_FALSE;
+  if (!aTopShownObject) {
+    // no sub part specified, top message is displayed, and
+    // our crypto object is definitively a child of it
+    CryptoObjectIsChildOfTopShownObject = PR_TRUE;
+  }
+
+  // if we are the child of the topmost message, aCryptoPartNestLevel == 1
+  int aCryptoPartNestLevel = 0;
+  if (obj) {
+    for (MimeObject *walker = obj; walker; walker = walker->parent) {
+      // Crypto mime objects are transparent wrt nesting.
+      if (!mime_typep(walker, (MimeObjectClass *) &mimeEncryptedClass)
+          && !mime_typep(walker, (MimeObjectClass *) &mimeMultipartSignedClass)) {
+        ++aCryptoPartNestLevel;
+      }
+      if (aTopShownObject && walker->parent == aTopShownObject) {
+        CryptoObjectIsChildOfTopShownObject = PR_TRUE;
+      }
+    }
+  }
+
+  if (!CryptoObjectIsChildOfTopShownObject) {
+    return -1;
+  }
+
+  return aCryptoPartNestLevel - aTopMessageNestLevel;
+}
+
 static void *
 MimeCMS_init(MimeObject *obj,
 			   int (*output_fn) (const char *buf, PRInt32 buf_size,
@@ -442,20 +510,7 @@
   	return -1;
   }
 
-  // if we are the child of the topmost message, aNestLevel == 1
-  int aNestLevel = 0;
-
-  if (data->self) {
-    MimeObject *walker = data->self;
-    while (walker) {
-      // Crypto mime objects are transparent wrt nesting.
-      if (!mime_typep(walker, (MimeObjectClass *) &mimeEncryptedClass)
-          && !mime_typep(walker, (MimeObjectClass *) &mimeMultipartSignedClass)) {
-        ++aNestLevel;
-      }
-      walker = walker->parent;
-    }
-  }
+  int aRelativeNestLevel = MIMEGetRelativeCryptoNestLevel(data->self);
 
   /* Hand an EOF to the crypto library.  It may call data->output_fn.
 	 (Today, the crypto library has no flushing to do, but maybe there
@@ -478,10 +533,14 @@
   if (!data->smimeHeaderSink)
     return 0;
 
+  if (aRelativeNestLevel < 0) {
+    return 0;
+  }
+
   PRInt32 maxNestLevel = 0;
   data->smimeHeaderSink->MaxWantedNesting(&maxNestLevel);
 
-  if (aNestLevel > maxNestLevel)
+  if (aRelativeNestLevel > maxNestLevel)
     return 0;
 
   PRInt32 status = nsICMSMessageErrors::SUCCESS;
@@ -560,7 +619,7 @@
   if (data->ci_is_encrypted)
   {
     data->smimeHeaderSink->EncryptionStatus(
-      aNestLevel,
+      aRelativeNestLevel,
       status,
       certOfInterest
     );
@@ -568,7 +627,7 @@
   else
   {
     data->smimeHeaderSink->SignedStatus(
-      aNestLevel,
+      aRelativeNestLevel,
       status,
       certOfInterest
     );
Index: mozilla/mailnews/mime/src/mimemcms.cpp
===================================================================
RCS file: /cvsroot/mozilla/mailnews/mime/src/mimemcms.cpp,v
retrieving revision 1.16
diff -u -r1.16 mimemcms.cpp
--- mozilla/mailnews/mime/src/mimemcms.cpp	13 Dec 2002 20:47:29 -0000	1.16
+++ mozilla/mailnews/mime/src/mimemcms.cpp	28 Feb 2003 09:30:14 -0000
@@ -181,6 +181,7 @@
 											 char **);
 extern char *MimeCMS_MakeSAURL(MimeObject *obj);
 extern char *IMAP_CreateReloadAllPartsUrl(const char *url);
+extern int MIMEGetRelativeCryptoNestLevel(MimeObject *obj);
 
 static void *
 MimeMultCMS_init (MimeObject *obj)
@@ -442,20 +443,7 @@
   PRInt32 signature_status = nsICMSMessageErrors::GENERAL_ERROR;
   nsCOMPtr<nsIX509Cert> signerCert;
 
-  // if we are the child of the topmost message, aNestLeve == 1
-  int aNestLevel = 0;
-
-  if (data->self) {
-    MimeObject *walker = data->self;
-    while (walker) {
-      // Crypto mime objects are transparent wrt nesting.
-      if (!mime_typep(walker, (MimeObjectClass *) &mimeEncryptedClass)
-          && !mime_typep(walker, (MimeObjectClass *) &mimeMultipartSignedClass)) {
-        ++aNestLevel;
-      }
-      walker = walker->parent;
-    }
-  }
+  int aRelativeNestLevel = MIMEGetRelativeCryptoNestLevel(data->self);
 
   unverified_p = data->self->options->missing_parts; 
 
@@ -533,11 +521,13 @@
 
   PRInt32 maxNestLevel = 0;
   if (data->smimeHeaderSink) {
-    data->smimeHeaderSink->MaxWantedNesting(&maxNestLevel);
+    if (aRelativeNestLevel >= 0) {
+      data->smimeHeaderSink->MaxWantedNesting(&maxNestLevel);
 
-    if (aNestLevel <= maxNestLevel)
-    {
-      data->smimeHeaderSink->SignedStatus(aNestLevel, signature_status, signerCert);
+      if (aRelativeNestLevel <= maxNestLevel)
+      {
+        data->smimeHeaderSink->SignedStatus(aRelativeNestLevel, signature_status, signerCert);
+      }
     }
   }
 
