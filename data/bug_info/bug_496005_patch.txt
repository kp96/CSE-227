# HG changeset patch
# Parent ed958cdc83961766749b7b0d0f7ae415e9b77905

diff --git a/security/manager/ssl/src/nsCrypto.cpp b/security/manager/ssl/src/nsCrypto.cpp
--- a/security/manager/ssl/src/nsCrypto.cpp
+++ b/security/manager/ssl/src/nsCrypto.cpp
@@ -91,16 +91,17 @@ extern "C" {
 }
 #include "cmmf.h"
 #include "nssb64.h"
 #include "base64.h"
 #include "cert.h"
 #include "certdb.h"
 #include "secmod.h"
 #include "nsISaveAsCharset.h"
+#include "nsNativeCharsetUtils.h"
 
 #include "ssl.h" // For SSL_ClearSessionCache
 
 #include "nsNSSCleaner.h"
 NSSCleanupAutoPtrClass(SECKEYPrivateKey, SECKEY_DestroyPrivateKey)
 NSSCleanupAutoPtrClass(PK11SlotInfo, PK11_FreeSlot)
 NSSCleanupAutoPtrClass(CERTCertNicknames, CERT_FreeNicknames)
 NSSCleanupAutoPtrClass(PK11SymKey, PK11_FreeSymKey)
@@ -2954,61 +2955,59 @@ nsPkcs11::DeleteModule(const nsAString& 
   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
   if (NS_FAILED(rv))
     return rv;
 
   if (aModuleName.IsEmpty()) {
     return NS_ERROR_ILLEGAL_VALUE;
   }
   
-  char *modName = ToNewCString(aModuleName);
+  NS_ConvertUTF16toUTF8 modName(aModuleName);
   PRInt32 modType;
-  SECStatus srv = SECMOD_DeleteModule(modName, &modType);
+  SECStatus srv = SECMOD_DeleteModule(modName.get(), &modType);
   if (srv == SECSuccess) {
-    SECMODModule *module = SECMOD_FindModule(modName);
+    SECMODModule *module = SECMOD_FindModule(modName.get());
     if (module) {
       nssComponent->ShutdownSmartCardThread(module);
       SECMOD_DestroyModule(module);
     }
     rv = NS_OK;
   } else {
     rv = NS_ERROR_FAILURE;
   }
-  NS_Free(modName);
   return rv;
 }
 
 //Add a new PKCS11 module to the user's profile.
 NS_IMETHODIMP
 nsPkcs11::AddModule(const nsAString& aModuleName, 
                     const nsAString& aLibraryFullPath, 
                     PRInt32 aCryptoMechanismFlags, 
                     PRInt32 aCipherFlags)
 {
   nsNSSShutDownPreventionLock locker;
   nsresult rv;
   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
 
-  char *moduleName = ToNewCString(aModuleName);
-  char *fullPath   = ToNewCString(aLibraryFullPath);
+  NS_ConvertUTF16toUTF8 moduleName(aModuleName);
+  nsCString fullPath;
+  // NSS doesn't support Unicode path.  Use native charset
+  NS_CopyUnicodeToNative(aLibraryFullPath, fullPath);
   PRUint32 mechFlags = SECMOD_PubMechFlagstoInternal(aCryptoMechanismFlags);
   PRUint32 cipherFlags = SECMOD_PubCipherFlagstoInternal(aCipherFlags);
-  SECStatus srv = SECMOD_AddNewModule(moduleName, fullPath, 
+  SECStatus srv = SECMOD_AddNewModule(moduleName.get(), fullPath.get(), 
                                       mechFlags, cipherFlags);
   if (srv == SECSuccess) {
-    SECMODModule *module = SECMOD_FindModule(moduleName);
+    SECMODModule *module = SECMOD_FindModule(moduleName.get());
     if (module) {
       nssComponent->LaunchSmartCardThread(module);
       SECMOD_DestroyModule(module);
     }
   }
 
-  nsMemory::Free(moduleName);
-  nsMemory::Free(fullPath);
-
   // The error message we report to the user depends directly on 
   // what the return value for SEDMOD_AddNewModule is
   switch (srv) {
   case SECSuccess:
     return NS_OK;
   case SECFailure:
     return NS_ERROR_FAILURE;
   case -2:
