{"bug_id":241013,"commitHash":"c331136","commit_info":{"sha":"c3311361cd76ebf020f9ec9084fbea526d13af4c","commit":{"author":{"name":"bzbarsky%mit.edu","email":"bzbarsky%mit.edu","date":"2004-04-22T17:40:51Z"},"committer":{"name":"bzbarsky%mit.edu","email":"bzbarsky%mit.edu","date":"2004-04-22T17:40:51Z"},"message":"VerifySignature should not leak on various failures.  Bug 241013, r=jgmyers,\nsr=brendan","tree":{"sha":"e7ed54c7ed01993d7b211979568100c813836bb7","url":"https://api.github.com/repos/mozilla/gecko-dev/git/trees/e7ed54c7ed01993d7b211979568100c813836bb7"},"url":"https://api.github.com/repos/mozilla/gecko-dev/git/commits/c3311361cd76ebf020f9ec9084fbea526d13af4c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/mozilla/gecko-dev/commits/c3311361cd76ebf020f9ec9084fbea526d13af4c","html_url":"https://github.com/mozilla/gecko-dev/commit/c3311361cd76ebf020f9ec9084fbea526d13af4c","comments_url":"https://api.github.com/repos/mozilla/gecko-dev/commits/c3311361cd76ebf020f9ec9084fbea526d13af4c/comments","author":null,"committer":null,"parents":[{"sha":"72c9a29bc202dfcbfe9deed191d5f65726582624","url":"https://api.github.com/repos/mozilla/gecko-dev/commits/72c9a29bc202dfcbfe9deed191d5f65726582624","html_url":"https://github.com/mozilla/gecko-dev/commit/72c9a29bc202dfcbfe9deed191d5f65726582624"}],"stats":{"total":112,"additions":61,"deletions":51},"files":[{"sha":"aeda03f64bb784fd12a4b9ab2dd4e443691829c2","filename":"security/manager/ssl/src/nsNSSComponent.cpp","status":"modified","additions":61,"deletions":51,"changes":112,"blob_url":"https://github.com/mozilla/gecko-dev/blob/c3311361cd76ebf020f9ec9084fbea526d13af4c/security/manager/ssl/src/nsNSSComponent.cpp","raw_url":"https://github.com/mozilla/gecko-dev/raw/c3311361cd76ebf020f9ec9084fbea526d13af4c/security/manager/ssl/src/nsNSSComponent.cpp","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/security/manager/ssl/src/nsNSSComponent.cpp?ref=c3311361cd76ebf020f9ec9084fbea526d13af4c","patch":"@@ -1377,31 +1377,26 @@ nsNSSComponent::VerifySignature(const char* aRSABuf, PRUint32 aRSABufLen,\n   *aPrincipal = nsnull;\n \n   nsNSSShutDownPreventionLock locker;\n-  SEC_PKCS7DecoderContext * p7_ctxt = nsnull;\n   SEC_PKCS7ContentInfo * p7_info = nsnull; \n   unsigned char hash[SHA1_LENGTH]; \n-  PRBool rv;\n-\n-  p7_ctxt = SEC_PKCS7DecoderStart(ContentCallback,\n-                        nsnull,\n-                        GetPasswordKeyCallback,\n-                        nsnull,\n-                        GetDecryptKeyCallback,\n-                        nsnull,\n-                        DecryptionAllowedCallback);\n-  if (!p7_ctxt) {\n-    return NS_ERROR_FAILURE;\n-  }\n \n-  if (SEC_PKCS7DecoderUpdate(p7_ctxt,aRSABuf, aRSABufLen) != SECSuccess) {\n-    return NS_ERROR_FAILURE;\n-  }\n+  SECItem item;\n+  item.type = siEncodedCertBuffer;\n+  item.data = (unsigned char*)aRSABuf;\n+  item.len = aRSABufLen;\n+  p7_info = SEC_PKCS7DecodeItem(&item,\n+                                ContentCallback, nsnull,\n+                                GetPasswordKeyCallback, nsnull,\n+                                GetDecryptKeyCallback, nsnull,\n+                                DecryptionAllowedCallback);\n \n-  p7_info = SEC_PKCS7DecoderFinish(p7_ctxt); \n   if (!p7_info) {\n     return NS_ERROR_FAILURE;\n   }\n \n+  // Make sure we call SEC_PKCS7DestroyContentInfo after this point;\n+  // otherwise we leak data in p7_info\n+  \n   //-- If a plaintext was provided, hash it.\n   SECItem digest;\n   digest.data = nsnull;\n@@ -1422,54 +1417,69 @@ nsNSSComponent::VerifySignature(const char* aRSABuf, PRUint32 aRSABufLen,\n   }\n \n   //-- Verify signature\n-  rv = SEC_PKCS7VerifyDetachedSignature(p7_info, certUsageObjectSigner, &digest, HASH_AlgSHA1, PR_TRUE);\n+  PRBool rv = SEC_PKCS7VerifyDetachedSignature(p7_info, certUsageObjectSigner,\n+                                               &digest, HASH_AlgSHA1, PR_TRUE);\n   if (rv != PR_TRUE) {\n     *aErrorCode = PR_GetError();\n   }\n \n   // Get the signing cert //\n   CERTCertificate *cert = p7_info->content.signedData->signerInfos[0]->cert;\n+  nsresult rv2 = NS_OK;\n   if (cert) {\n-    nsCOMPtr<nsIX509Cert> pCert = new nsNSSCertificate(cert);\n-    if (!pCert) {\n-      return NS_ERROR_OUT_OF_MEMORY;\n-    }\n+    // Use |do { } while (0);| as a \"more C++-ish\" thing than goto;\n+    // this way we don't have to worry about goto across variable\n+    // declarations.  We have no loops in this code, so it's OK.\n+    do {\n+      nsCOMPtr<nsIX509Cert> pCert = new nsNSSCertificate(cert);\n+      if (!pCert) {\n+        rv2 = NS_ERROR_OUT_OF_MEMORY;\n+        break;\n+      }\n \n-    nsresult rv2;\n-    if (!mScriptSecurityManager) {\n-      nsAutoLock lock(mutex);\n-      // re-test the condition to prevent double initialization\n       if (!mScriptSecurityManager) {\n-        mScriptSecurityManager = \n-           do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv2);\n-        if (NS_FAILED(rv2)) return rv2;\n+        nsAutoLock lock(mutex);\n+        // re-test the condition to prevent double initialization\n+        if (!mScriptSecurityManager) {\n+          mScriptSecurityManager = \n+            do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv2);\n+          if (NS_FAILED(rv2)) {\n+            break;\n+          }\n+        }\n       }\n-    }\n-\n-    //-- Create a certificate principal with id and organization data\n-    nsAutoString fingerprint;\n-    rv2 = pCert->GetSha1Fingerprint(fingerprint);\n-    if (NS_FAILED(rv2)) return rv2;\n-    nsCOMPtr<nsIPrincipal> certPrincipal;\n-    rv2 = mScriptSecurityManager->\n-      GetCertificatePrincipal(NS_LossyConvertUTF16toASCII(fingerprint).get(),\n-                              nsnull, getter_AddRefs(certPrincipal));\n-    if (NS_FAILED(rv2) || !certPrincipal) return rv2;\n \n-    nsAutoString orgName;\n-    rv2 = pCert->GetOrganization(orgName);\n-    if (NS_FAILED(rv2)) return rv2;\n-    rv2 = certPrincipal->SetCommonName(NS_LossyConvertUTF16toASCII(orgName).get());\n-    if (NS_FAILED(rv2)) return rv2;\n-\n-    NS_ADDREF(*aPrincipal = certPrincipal);\n+      //-- Create a certificate principal with id and organization data\n+      nsAutoString fingerprint;\n+      rv2 = pCert->GetSha1Fingerprint(fingerprint);\n+      if (NS_FAILED(rv2)) {\n+        break;\n+      }\n+      nsCOMPtr<nsIPrincipal> certPrincipal;\n+      rv2 = mScriptSecurityManager->\n+        GetCertificatePrincipal(NS_ConvertUTF16toUTF8(fingerprint).get(),\n+                                nsnull, getter_AddRefs(certPrincipal));\n+      if (NS_FAILED(rv2) || !certPrincipal) {\n+        break;\n+      }\n+      \n+      nsAutoString orgName;\n+      rv2 = pCert->GetOrganization(orgName);\n+      if (NS_FAILED(rv2)) {\n+        break;\n+      }\n+      rv2 = certPrincipal->SetCommonName(NS_ConvertUTF16toUTF8(orgName).get());\n+      if (NS_FAILED(rv2)) {\n+        break;\n+      }\n+    \n+      NS_ADDREF(*aPrincipal = certPrincipal);\n+    } while (0);\n   }\n \n-  if (p7_info) {\n-    SEC_PKCS7DestroyContentInfo(p7_info);\n-  }\n+  SEC_PKCS7DestroyContentInfo(p7_info);\n \n-  return NS_OK;\n+  return rv2;\n }\n \n NS_IMETHODIMP"}]},"blames":["b2141fb5","d007c347","24e6ca57","2ae77cc7","4f540afa"]}