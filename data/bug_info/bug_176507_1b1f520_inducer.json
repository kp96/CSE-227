{"bug_id":176507,"commitHash":"1b1f520","commit_info":{"sha":"1b1f520e94a529640884014eb898765aa71be04b","commit":{"author":{"name":"kaie%kuix.de","email":"kaie%kuix.de","date":"2006-06-26T17:13:13Z"},"committer":{"name":"kaie%kuix.de","email":"kaie%kuix.de","date":"2006-06-26T17:13:13Z"},"message":"Bug 310446, Add a user feedback message when certs for import are being ignored\nalso fixes\nBug 176507, Certificates added without warning or confirmation\nr=rrelyea, string-review=beltzner","tree":{"sha":"1a9c84506217c2c8c4d2f9b93b58da6a1bba00d3","url":"https://api.github.com/repos/mozilla/gecko-dev/git/trees/1a9c84506217c2c8c4d2f9b93b58da6a1bba00d3"},"url":"https://api.github.com/repos/mozilla/gecko-dev/git/commits/1b1f520e94a529640884014eb898765aa71be04b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/mozilla/gecko-dev/commits/1b1f520e94a529640884014eb898765aa71be04b","html_url":"https://github.com/mozilla/gecko-dev/commit/1b1f520e94a529640884014eb898765aa71be04b","comments_url":"https://api.github.com/repos/mozilla/gecko-dev/commits/1b1f520e94a529640884014eb898765aa71be04b/comments","author":null,"committer":null,"parents":[{"sha":"edc12afdc085b93b944bd16275221b4cd8ac073b","url":"https://api.github.com/repos/mozilla/gecko-dev/commits/edc12afdc085b93b944bd16275221b4cd8ac073b","html_url":"https://github.com/mozilla/gecko-dev/commit/edc12afdc085b93b944bd16275221b4cd8ac073b"}],"stats":{"total":123,"additions":101,"deletions":22},"files":[{"sha":"eab5889811add5be8d4c17bc274a75ca263709c0","filename":"security/manager/locales/en-US/chrome/pipnss/pipnss.properties","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/mozilla/gecko-dev/blob/1b1f520e94a529640884014eb898765aa71be04b/security/manager/locales/en-US/chrome/pipnss/pipnss.properties","raw_url":"https://github.com/mozilla/gecko-dev/raw/1b1f520e94a529640884014eb898765aa71be04b/security/manager/locales/en-US/chrome/pipnss/pipnss.properties","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/security/manager/locales/en-US/chrome/pipnss/pipnss.properties?ref=1b1f520e94a529640884014eb898765aa71be04b","patch":"@@ -404,3 +404,8 @@ CertNoNickname=(no nickname)\n CertNoEmailAddress=(no email address)\n NicknameExpired=(expired)\n NicknameNotYetValid=(not yet valid)\n+CaCertExists=This certificate is already installed as a certificate authority.\n+NotACACert=This is not a certificate authority certificate, so it can't be imported into the certificate authority list.\n+NotImportingUnverifiedCert=This certificate can't be verified and will not be imported. The certificate issuer might be unknown or untrusted, the certificate might have expired or been revoked, or the certificate might not have been approved.\n+UserCertIgnoredNoPrivateKey=This personal certificate can't be installed because you do not own the corresponding private key which was created when the certificate was requested.\n+UserCertImported=Your personal certificate has been installed. You should keep a backup copy of this certificate."},{"sha":"83d9b96e4fdfbe3c6620be7f48e514d4d474d544","filename":"security/manager/ssl/src/nsNSSCertificateDB.cpp","status":"modified","additions":93,"deletions":22,"changes":115,"blob_url":"https://github.com/mozilla/gecko-dev/blob/1b1f520e94a529640884014eb898765aa71be04b/security/manager/ssl/src/nsNSSCertificateDB.cpp","raw_url":"https://github.com/mozilla/gecko-dev/raw/1b1f520e94a529640884014eb898765aa71be04b/security/manager/ssl/src/nsNSSCertificateDB.cpp","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/security/manager/ssl/src/nsNSSCertificateDB.cpp?ref=1b1f520e94a529640884014eb898765aa71be04b","patch":"@@ -57,6 +57,9 @@\n #include \"nsIPrefService.h\"\n #include \"nsIPrefBranch.h\"\n #include \"nsComponentManagerUtils.h\"\n+#include \"nsIPrompt.h\"\n+#include \"nsIProxyObjectManager.h\"\n+#include \"nsProxiedService.h\"\n \n #include \"nspr.h\"\n extern \"C\" {\n@@ -365,15 +368,12 @@ nsNSSCertificateDB::handleCACertDownload(nsIArray *x509Certs,\n   CERTCertificateCleaner tmpCertCleaner(tmpCert);\n \n   if (!CERT_IsCACert(tmpCert, NULL)) {\n-    // Should pop up an error dialog.\n+    DisplayCertificateAlert(ctx, \"NotACACert\", certToShow);\n     return NS_ERROR_FAILURE;\n   }\n \n   if (tmpCert->isperm) {\n-    nsPSMUITracker tracker;\n-    if (!tracker.isUIForbidden()) {\n-      dialogs->NotifyCACertExists(ctx);\n-    }\n+    DisplayCertificateAlert(ctx, \"CaCertExists\", certToShow);\n     return NS_ERROR_FAILURE;\n   }\n \n@@ -572,32 +572,41 @@ nsNSSCertificateDB::ImportEmailCertificate(PRUint8 * data, PRUint32 length,\n       CERT_AddCertToListTail(certList, cert);\n   }\n \n-  /* filter out the certs we don't want */\n-  srv = CERT_FilterCertListByUsage(certList, certusage, PR_FALSE);\n-  if (srv != SECSuccess) {\n-    nsrv = NS_ERROR_FAILURE;\n-    goto loser;\n-  }\n-\n   /* go down the remaining list of certs and verify that they have\n    * valid chains, then import them.\n    */\n   now = PR_Now();\n   for (node = CERT_LIST_HEAD(certList);\n        !CERT_LIST_END(node,certList);\n        node = CERT_LIST_NEXT(node)) {\n-    if (CERT_VerifyCert(certdb, node->cert, \n-        PR_TRUE, certusage, now, ctx, NULL) != SECSuccess) {\n+\n+    bool alert_and_skip = false;\n+\n+    if (!node->cert) {\n       continue;\n     }\n \n-    CERTCertificateList *certChain = CERT_CertChainFromCert(node->cert, certusage, PR_FALSE);\n-    if (!certChain) {\n-      continue;\n+    if (CERT_VerifyCert(certdb, node->cert, \n+        PR_TRUE, certusage, now, ctx, NULL) != SECSuccess) {\n+      alert_and_skip = true;\n     }\n \n+    CERTCertificateList *certChain = nsnull;\n     CERTCertificateListCleaner chainCleaner(certChain);\n \n+    if (!alert_and_skip) {\n+      CERT_CertChainFromCert(node->cert, certusage, PR_FALSE);\n+      if (!certChain) {\n+        alert_and_skip = true;\n+      }\n+    }\n+\n+    if (alert_and_skip) {    \n+      nsCOMPtr<nsIX509Cert> certToShow = new nsNSSCertificate(node->cert);\n+      DisplayCertificateAlert(ctx, \"NotImportingUnverifiedCert\", certToShow);\n+      continue;\n+    }\n+\n     /*\n      * CertChain returns an array of SECItems, import expects an array of\n      * SECItem pointers. Create the SECItem Pointers from the array of\n@@ -765,17 +774,29 @@ nsNSSCertificateDB::ImportValidCACertsInList(CERTCertList *certList, nsIInterfac\n   for (node = CERT_LIST_HEAD(certList);\n        !CERT_LIST_END(node,certList);\n        node = CERT_LIST_NEXT(node)) {\n+\n+    bool alert_and_skip = false;\n+\n     if (CERT_VerifyCert(CERT_GetDefaultCertDB(), node->cert, \n         PR_TRUE, certUsageVerifyCA, now, ctx, NULL) != SECSuccess) {\n-      continue;\n+      alert_and_skip = true;\n     }\n \n-    CERTCertificateList *certChain = CERT_CertChainFromCert(node->cert, certUsageAnyCA, PR_FALSE);\n-    if (!certChain) {\n-      continue;\n+    CERTCertificateList *certChain = nsnull;\n+    CERTCertificateListCleaner chainCleaner(certChain);\n+\n+    if (!alert_and_skip) {    \n+      certChain = CERT_CertChainFromCert(node->cert, certUsageAnyCA, PR_FALSE);\n+      if (!certChain) {\n+        alert_and_skip = true;\n+      }\n     }\n \n-    CERTCertificateListCleaner chainCleaner(certChain);\n+    if (alert_and_skip) {    \n+      nsCOMPtr<nsIX509Cert> certToShow = new nsNSSCertificate(node->cert);\n+      DisplayCertificateAlert(ctx, \"NotImportingUnverifiedCert\", certToShow);\n+      continue;\n+    }\n \n     /*\n      * CertChain returns an array of SECItems, import expects an array of\n@@ -798,6 +819,50 @@ nsNSSCertificateDB::ImportValidCACertsInList(CERTCertList *certList, nsIInterfac\n   return NS_OK;\n }\n \n+void nsNSSCertificateDB::DisplayCertificateAlert(nsIInterfaceRequestor *ctx, \n+                                                 const char *stringID, \n+                                                 nsIX509Cert *certToShow)\n+{\n+  nsPSMUITracker tracker;\n+  if (!tracker.isUIForbidden()) {\n+\n+    // This shall be replaced by embedding ovverridable prompts\n+    // as discussed in bug 310446, and should make use of certToShow.\n+\n+    nsresult rv;\n+    nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));\n+    if (NS_SUCCEEDED(rv)) {\n+      nsAutoString tmpMessage;\n+      nssComponent->GetPIPNSSBundleString(stringID, tmpMessage);\n+\n+      // The interface requestor object may not be safe, so proxy the call to get\n+      // the nsIPrompt.\n+\n+      nsCOMPtr<nsIInterfaceRequestor> proxiedCallbacks;\n+      NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,\n+                           NS_GET_IID(nsIInterfaceRequestor),\n+                           ctx,\n+                           NS_PROXY_SYNC,\n+                           getter_AddRefs(proxiedCallbacks));\n+    \n+      nsCOMPtr<nsIPrompt> prompt (do_GetInterface(proxiedCallbacks));\n+      if (!prompt)\n+        return;\n+    \n+      // Finally, get a proxy for the nsIPrompt\n+    \n+      nsCOMPtr<nsIPrompt> proxyPrompt;\n+      NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,\n+                           NS_GET_IID(nsIPrompt),\n+                           prompt,\n+                           NS_PROXY_SYNC,\n+                           getter_AddRefs(proxyPrompt));\n+    \n+      proxyPrompt->Alert(nsnull, tmpMessage.get());\n+    }\n+  }\n+}\n+\n \n NS_IMETHODIMP \n nsNSSCertificateDB::ImportUserCertificate(PRUint8 *data, PRUint32 length, nsIInterfaceRequestor *ctx)\n@@ -830,6 +895,8 @@ nsNSSCertificateDB::ImportUserCertificate(PRUint8 *data, PRUint32 length, nsIInt\n \n   slot = PK11_KeyForCertExists(cert, NULL, ctx);\n   if ( slot == NULL ) {\n+    nsCOMPtr<nsIX509Cert> certToShow = new nsNSSCertificate(cert);\n+    DisplayCertificateAlert(ctx, \"UserCertIgnoredNoPrivateKey\", certToShow);\n     goto loser;\n   }\n   PK11_FreeSlot(slot);\n@@ -852,6 +919,10 @@ nsNSSCertificateDB::ImportUserCertificate(PRUint8 *data, PRUint32 length, nsIInt\n   }\n   PK11_FreeSlot(slot);\n \n+  {\n+    nsCOMPtr<nsIX509Cert> certToShow = new nsNSSCertificate(cert);\n+    DisplayCertificateAlert(ctx, \"UserCertImported\", certToShow);\n+  }\n   rv = NS_OK;\n \n   numCACerts = collectArgs->numcerts - 1;"},{"sha":"fee1cae6a4d4dfb27d693ae07ab932becf92a294","filename":"security/manager/ssl/src/nsNSSCertificateDB.h","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/mozilla/gecko-dev/blob/1b1f520e94a529640884014eb898765aa71be04b/security/manager/ssl/src/nsNSSCertificateDB.h","raw_url":"https://github.com/mozilla/gecko-dev/raw/1b1f520e94a529640884014eb898765aa71be04b/security/manager/ssl/src/nsNSSCertificateDB.h","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/security/manager/ssl/src/nsNSSCertificateDB.h?ref=1b1f520e94a529640884014eb898765aa71be04b","patch":"@@ -68,6 +68,9 @@ class nsNSSCertificateDB : public nsIX509CertDB, public nsIX509CertDB2\n   static nsresult\n   ImportValidCACertsInList(CERTCertList *certList, nsIInterfaceRequestor *ctx);\n \n+  static void DisplayCertificateAlert(nsIInterfaceRequestor *ctx, \n+                                      const char *stringID, nsIX509Cert *certToShow);\n+\n   void getCertNames(CERTCertList *certList,\n                     PRUint32      type, \n                     PRUint32     *_count,"}]},"blames":["084d164f","f88b21c0","d023625a","70a0f220","31db9b54","3a398b46","491abff1","491abff1","31db9b54"]}