Index: content/xul/document/src/nsXULDocument.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/xul/document/src/nsXULDocument.cpp,v
retrieving revision 1.611.2.1.14.4
diff -u -p -7 -r1.611.2.1.14.4 nsXULDocument.cpp
--- content/xul/document/src/nsXULDocument.cpp	7 Feb 2006 08:10:32 -0000	1.611.2.1.14.4
+++ content/xul/document/src/nsXULDocument.cpp	27 Feb 2006 18:28:38 -0000
@@ -148,14 +148,15 @@ static PRBool IsChromeURI(nsIURI* aURI)
 
 const nsForwardReference::Phase nsForwardReference::kPasses[] = {
     nsForwardReference::eConstruction,
     nsForwardReference::eHookup,
     nsForwardReference::eDone
 };
 
+const PRUint32 kMaxAttrNameLength = 512;
 const PRUint32 kMaxAttributeLength = 4096;
 
 //----------------------------------------------------------------------
 //
 // Statics
 //
 
@@ -1543,29 +1544,39 @@ nsXULDocument::Persist(nsIContent* aElem
 
     // Ick. Construct a property from the attribute. Punt on
     // namespaces for now.
     const char* attrstr;
     rv = aAttribute->GetUTF8String(&attrstr);
     if (NS_FAILED(rv)) return rv;
 
+    // Don't bother with unreasonable attributes. We clamp long values,
+    // but truncating attribute names turns it into a different attribute
+    // so there's no point in persisting anything at all
+    if (!attrstr || strlen(attrstr) > kMaxAttrNameLength) {
+        NS_WARNING("Can't persist, Attribute name too long");
+        return NS_ERROR_ILLEGAL_VALUE;
+    }
+
     nsCOMPtr<nsIRDFResource> attr;
     rv = gRDFService->GetResource(nsDependentCString(attrstr),
                                   getter_AddRefs(attr));
     if (NS_FAILED(rv)) return rv;
 
     // Turn the value into a literal
     nsAutoString valuestr;
     rv = aElement->GetAttr(kNameSpaceID_None, aAttribute, valuestr);
     if (NS_FAILED(rv)) return rv;
 
     // prevent over-long attributes that choke the parser (bug 319846)
     // (can't simply Truncate without testing, it's implemented
     // using SetLength and will grow a short string)
-    if (valuestr.Length() > kMaxAttributeLength)
+    if (valuestr.Length() > kMaxAttributeLength) {
+        NS_WARNING("Truncating persisted attribute value");
         valuestr.Truncate(kMaxAttributeLength);
+    }
 
     PRBool novalue = (rv != NS_CONTENT_ATTR_HAS_VALUE);
 
     // See if there was an old value...
     nsCOMPtr<nsIRDFNode> oldvalue;
     rv = mLocalStore->GetTarget(element, attr, PR_TRUE, getter_AddRefs(oldvalue));
     if (NS_FAILED(rv)) return rv;
