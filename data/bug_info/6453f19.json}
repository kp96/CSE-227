{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas6453f19\""},"diff":[{"chunks":[{"content":"@@ -1570,8 +1570,12 @@ nsPlainTextSerializer::OutputQuotesAndIndent(PRBool stripTrailingSpaces /* = PR_","changes":[{"type":"normal","normal":true,"ln1":1570,"ln2":1570,"content":"  * line wrapping, indentation, whitespace compression and other things."},{"type":"normal","normal":true,"ln1":1571,"ln2":1571,"content":"  */"},{"type":"normal","normal":true,"ln1":1572,"ln2":1572,"content":" void"},{"type":"del","del":true,"ln":1573,"content":"-nsPlainTextSerializer::Write(const nsAString& aString)"},{"type":"add","add":true,"ln":1573,"content":"+nsPlainTextSerializer::Write(const nsAString& aStr)"},{"type":"normal","normal":true,"ln1":1574,"ln2":1574,"content":" {"},{"type":"add","add":true,"ln":1575,"content":"+  // XXX Copy necessary to use nsString methods and gain"},{"type":"add","add":true,"ln":1576,"content":"+  // access to underlying buffer"},{"type":"add","add":true,"ln":1577,"content":"+  nsAutoString str(aStr);"},{"type":"add","add":true,"ln":1578,"content":"+"},{"type":"normal","normal":true,"ln1":1575,"ln2":1579,"content":" #ifdef DEBUG_wrapping"},{"type":"normal","normal":true,"ln1":1576,"ln2":1580,"content":"   printf(\"Write(%s): wrap col = %d\\n\","},{"type":"normal","normal":true,"ln1":1577,"ln2":1581,"content":"          NS_ConvertUTF16toUTF8(aString).get(), mWrapColumn);"}],"oldStart":1570,"oldLines":8,"newStart":1570,"newLines":12},{"content":"@@ -1580,17 +1584,32 @@ nsPlainTextSerializer::Write(const nsAString& aString)","changes":[{"type":"normal","normal":true,"ln1":1580,"ln2":1584,"content":"   PRInt32 bol = 0;"},{"type":"normal","normal":true,"ln1":1581,"ln2":1585,"content":"   PRInt32 newline;"},{"type":"normal","normal":true,"ln1":1582,"ln2":1586,"content":"   "},{"type":"del","del":true,"ln":1583,"content":"-  PRInt32 totLen = aString.Length();"},{"type":"add","add":true,"ln":1587,"content":"+  PRInt32 totLen = str.Length();"},{"type":"normal","normal":true,"ln1":1584,"ln2":1588,"content":" "},{"type":"normal","normal":true,"ln1":1585,"ln2":1589,"content":"   // If the string is empty, do nothing:"},{"type":"normal","normal":true,"ln1":1586,"ln2":1590,"content":"   if (totLen <= 0) return;"},{"type":"normal","normal":true,"ln1":1587,"ln2":1591,"content":" "},{"type":"add","add":true,"ln":1592,"content":"+  // For Flowed text change nbsp-ses to spaces at end of lines to allow them"},{"type":"add","add":true,"ln":1593,"content":"+  // to be cut off along with usual spaces if required. (bug #125928)"},{"type":"add","add":true,"ln":1594,"content":"+  if (mFlags & nsIDocumentEncoder::OutputFormatFlowed) {"},{"type":"add","add":true,"ln":1595,"content":"+    PRUnichar nbsp = 160;"},{"type":"add","add":true,"ln":1596,"content":"+    for (PRUint32 i = totLen-1; i >= 0; i--) {"},{"type":"add","add":true,"ln":1597,"content":"+      PRUnichar c = str[i];"},{"type":"add","add":true,"ln":1598,"content":"+      if ('\\n' == c || '\\r' == c || ' ' == c || '\\t' == c)"},{"type":"add","add":true,"ln":1599,"content":"+        continue;"},{"type":"add","add":true,"ln":1600,"content":"+      if (nbsp == c)"},{"type":"add","add":true,"ln":1601,"content":"+        str.Replace(i, 1, ' ');"},{"type":"add","add":true,"ln":1602,"content":"+      else"},{"type":"add","add":true,"ln":1603,"content":"+        break;"},{"type":"add","add":true,"ln":1604,"content":"+    }"},{"type":"add","add":true,"ln":1605,"content":"+  }"},{"type":"add","add":true,"ln":1606,"content":"+"},{"type":"normal","normal":true,"ln1":1588,"ln2":1607,"content":"   // We have two major codepaths here. One that does preformatted text and one"},{"type":"normal","normal":true,"ln1":1589,"ln2":1608,"content":"   // that does normal formatted text. The one for preformatted text calls"},{"type":"normal","normal":true,"ln1":1590,"ln2":1609,"content":"   // Output directly while the other code path goes through AddToLine."},{"type":"normal","normal":true,"ln1":1591,"ln2":1610,"content":"   if ((mPreFormatted && !mWrapColumn) || IsInPre()"},{"type":"normal","normal":true,"ln1":1592,"ln2":1611,"content":"       || ((((!mQuotesPreformatted && mSpanLevel > 0) || mDontWrapAnyQuotes))"},{"type":"del","del":true,"ln":1593,"content":"-          && mEmptyLines >= 0 && aString.First() == PRUnichar('>'))) {"},{"type":"add","add":true,"ln":1612,"content":"+          && mEmptyLines >= 0 && str.First() == PRUnichar('>'))) {"},{"type":"normal","normal":true,"ln1":1594,"ln2":1613,"content":"     // No intelligent wrapping."},{"type":"normal","normal":true,"ln1":1595,"ln2":1614,"content":" "},{"type":"normal","normal":true,"ln1":1596,"ln2":1615,"content":"     // This mustn't be mixed with intelligent wrapping without clearing"}],"oldStart":1580,"oldLines":17,"newStart":1584,"newLines":32},{"content":"@@ -1610,8 +1629,8 @@ nsPlainTextSerializer::Write(const nsAString& aString)","changes":[{"type":"normal","normal":true,"ln1":1610,"ln2":1629,"content":" "},{"type":"normal","normal":true,"ln1":1611,"ln2":1630,"content":"       // Find one of '\\n' or '\\r' using iterators since nsAString"},{"type":"normal","normal":true,"ln1":1612,"ln2":1631,"content":"       // doesn't have the old FindCharInSet function."},{"type":"del","del":true,"ln":1613,"content":"-      nsAString::const_iterator iter;           aString.BeginReading(iter);"},{"type":"del","del":true,"ln":1614,"content":"-      nsAString::const_iterator done_searching; aString.EndReading(done_searching);"},{"type":"add","add":true,"ln":1632,"content":"+      nsAString::const_iterator iter;           str.BeginReading(iter);"},{"type":"add","add":true,"ln":1633,"content":"+      nsAString::const_iterator done_searching; str.EndReading(done_searching);"},{"type":"normal","normal":true,"ln1":1615,"ln2":1634,"content":"       iter.advance(bol); "},{"type":"normal","normal":true,"ln1":1616,"ln2":1635,"content":"       PRInt32 new_newline = bol;"},{"type":"normal","normal":true,"ln1":1617,"ln2":1636,"content":"       newline = kNotFound;"}],"oldStart":1610,"oldLines":8,"newStart":1629,"newLines":8},{"content":"@@ -1627,7 +1646,7 @@ nsPlainTextSerializer::Write(const nsAString& aString)","changes":[{"type":"normal","normal":true,"ln1":1627,"ln2":1646,"content":"       // Done searching"},{"type":"normal","normal":true,"ln1":1628,"ln2":1647,"content":"       if(newline == kNotFound) {"},{"type":"normal","normal":true,"ln1":1629,"ln2":1648,"content":"         // No new lines."},{"type":"del","del":true,"ln":1630,"content":"-        nsAutoString stringpart(Substring(aString, bol, totLen - bol));"},{"type":"add","add":true,"ln":1649,"content":"+        nsAutoString stringpart(Substring(str, bol, totLen - bol));"},{"type":"normal","normal":true,"ln1":1631,"ln2":1650,"content":"         if(!stringpart.IsEmpty()) {"},{"type":"normal","normal":true,"ln1":1632,"ln2":1651,"content":"           PRUnichar lastchar = stringpart[stringpart.Length()-1];"},{"type":"normal","normal":true,"ln1":1633,"ln2":1652,"content":"           if((lastchar == '\\t') || (lastchar == ' ') ||"}],"oldStart":1627,"oldLines":7,"newStart":1646,"newLines":7},{"content":"@@ -1645,7 +1664,9 @@ nsPlainTextSerializer::Write(const nsAString& aString)","changes":[{"type":"normal","normal":true,"ln1":1645,"ln2":1664,"content":"       } "},{"type":"normal","normal":true,"ln1":1646,"ln2":1665,"content":"       else {"},{"type":"normal","normal":true,"ln1":1647,"ln2":1666,"content":"         // There is a newline"},{"type":"del","del":true,"ln":1648,"content":"-        nsAutoString stringpart(Substring(aString, bol, newline-bol));"},{"type":"add","add":true,"ln":1667,"content":"+        nsAutoString stringpart(Substring(str, bol, newline-bol));"},{"type":"add","add":true,"ln":1668,"content":"+        if (mFlags & nsIDocumentEncoder::OutputFormatFlowed)"},{"type":"add","add":true,"ln":1669,"content":"+          stringpart.Trim(\" \", PR_FALSE, PR_TRUE, PR_TRUE);"},{"type":"normal","normal":true,"ln1":1649,"ln2":1670,"content":"         mInWhitespace = PR_TRUE;"},{"type":"normal","normal":true,"ln1":1650,"ln2":1671,"content":"         mCurrentLine.Assign(stringpart);"},{"type":"normal","normal":true,"ln1":1651,"ln2":1672,"content":"         outputLineBreak = PR_TRUE;"}],"oldStart":1645,"oldLines":7,"newStart":1664,"newLines":9},{"content":"@@ -1682,10 +1703,6 @@ nsPlainTextSerializer::Write(const nsAString& aString)","changes":[{"type":"normal","normal":true,"ln1":1682,"ln2":1703,"content":"     return;"},{"type":"normal","normal":true,"ln1":1683,"ln2":1704,"content":"   }"},{"type":"normal","normal":true,"ln1":1684,"ln2":1705,"content":" "},{"type":"del","del":true,"ln":1685,"content":"-  // XXX Copy necessary to use nsString methods and gain"},{"type":"del","del":true,"ln":1686,"content":"-  // access to underlying buffer"},{"type":"del","del":true,"ln":1687,"content":"-  nsAutoString str(aString);"},{"type":"del","del":true,"ln":1688,"content":"-"},{"type":"normal","normal":true,"ln1":1689,"ln2":1706,"content":"   // Intelligent handling of text"},{"type":"normal","normal":true,"ln1":1690,"ln2":1707,"content":"   // If needed, strip out all \"end of lines\""},{"type":"normal","normal":true,"ln1":1691,"ln2":1708,"content":"   // and multiple whitespace between words"}],"oldStart":1682,"oldLines":10,"newStart":1703,"newLines":6}],"deletions":11,"additions":28,"from":"content/base/src/nsPlainTextSerializer.cpp","to":"content/base/src/nsPlainTextSerializer.cpp","index":["577b453..a96590b","100644"]}]}