Index: mozilla/security/manager/ssl/src/nsCrypto.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsCrypto.cpp,v
retrieving revision 1.78
diff -u -u -8 -p -r1.78 nsCrypto.cpp
--- mozilla/security/manager/ssl/src/nsCrypto.cpp	4 Mar 2008 11:25:44 -0000	1.78
+++ mozilla/security/manager/ssl/src/nsCrypto.cpp	5 Jun 2008 07:50:16 -0000
@@ -2267,18 +2267,17 @@ nsCrypto::ImportUserCertificates(const n
   CMMFCertRepContent *certRepContent = nsnull;
   int numResponses = 0;
   nsIX509Cert **certArr = nsnull;
   int i;
   CMMFCertResponse *currResponse;
   CMMFPKIStatus reqStatus;
   CERTCertificate *currCert;
   PK11SlotInfo *slot;
-  PRBool freeLocalNickname = PR_FALSE;
-  char *localNick;
+  nsCAutoString localNick;
   nsCOMPtr<nsIInterfaceRequestor> ctx = new PipUIContext();
   nsresult rv = NS_OK;
   CERTCertList *caPubs = nsnull;
   nsCOMPtr<nsIPK11Token> token;
 
   nickname = ToNewCString(aNickname);
   cmmfResponse = ToNewCString(aCmmfResponse);
   if (nsCRT::strcmp("null", nickname) == 0) {
@@ -2346,29 +2345,27 @@ nsCrypto::ImportUserCertificates(const n
     }
     // Let's figure out which nickname to give the cert.  If 
     // a certificate with the same subject name already exists,
     // then just use that one, otherwise, get the default nickname.
     if (currCert->nickname) {
       localNick = currCert->nickname;
     }
     else if (nickname == nsnull || nickname[0] == '\0') {
-      localNick = nsNSSCertificateDB::default_nickname(currCert, ctx);
-      freeLocalNickname = PR_TRUE;
+      nsNSSCertificateDB::get_default_nickname(currCert, ctx, localNick);
     } else {
       //This is the case where we're getting a brand new
       //cert that doesn't have the same subjectName as a cert
       //that already exists in our db and the CA page has 
       //designated a nickname to use for the newly issued cert.
       localNick = nickname;
     }
-    slot = PK11_ImportCertForKey(currCert, localNick, ctx);
-    if (freeLocalNickname) {
-      nsMemory::Free(localNick);
-      freeLocalNickname = PR_FALSE;
+    {
+      char *cast_const_away = const_cast<char*>(localNick.get());
+      slot = PK11_ImportCertForKey(currCert, cast_const_away, ctx);
     }
     if (slot == nsnull) {
       rv = NS_ERROR_FAILURE;
       goto loser;
     }
     if (aDoForcedBackup) {
       certArr[i] = new nsNSSCertificate(currCert);
       NS_ADDREF(certArr[i]);
Index: mozilla/security/manager/ssl/src/nsNSSCertificateDB.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSCertificateDB.cpp,v
retrieving revision 1.32
diff -u -u -8 -p -r1.32 nsNSSCertificateDB.cpp
--- mozilla/security/manager/ssl/src/nsNSSCertificateDB.cpp	9 Apr 2008 01:48:02 -0000	1.32
+++ mozilla/security/manager/ssl/src/nsNSSCertificateDB.cpp	5 Jun 2008 07:50:18 -0000
@@ -78,16 +78,17 @@ extern "C" {
 #ifdef PR_LOGGING
 extern PRLogModuleInfo* gPIPNSSLog;
 #endif
 
 #include "nsNSSCleaner.h"
 NSSCleanupAutoPtrClass(CERTCertificate, CERT_DestroyCertificate)
 NSSCleanupAutoPtrClass(CERTCertList, CERT_DestroyCertList)
 NSSCleanupAutoPtrClass(CERTCertificateList, CERT_DestroyCertificateList)
+NSSCleanupAutoPtrClass(PK11SlotInfo, PK11_FreeSlot)
 
 static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
 
 
 NS_IMPL_THREADSAFE_ISUPPORTS2(nsNSSCertificateDB, nsIX509CertDB, nsIX509CertDB2)
 
 nsNSSCertificateDB::nsNSSCertificateDB()
 {
@@ -880,17 +881,17 @@ void nsNSSCertificateDB::DisplayCertific
 }
 
 
 NS_IMETHODIMP 
 nsNSSCertificateDB::ImportUserCertificate(PRUint8 *data, PRUint32 length, nsIInterfaceRequestor *ctx)
 {
   nsNSSShutDownPreventionLock locker;
   PK11SlotInfo *slot;
-  char * nickname = NULL;
+  nsCAutoString nickname;
   nsresult rv = NS_ERROR_FAILURE;
   int numCACerts;
   SECItem *CACerts;
   CERTDERCerts * collectArgs;
   PRArenaPool *arena;
   CERTCertificate * cert=NULL;
 
   arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
@@ -920,21 +921,24 @@ nsNSSCertificateDB::ImportUserCertificat
   /* pick a nickname for the cert */
   if (cert->nickname) {
 	/* sigh, we need a call to look up other certs with this subject and
 	 * identify nicknames from them. We can no longer walk down internal
 	 * database structures  rjr */
   	nickname = cert->nickname;
   }
   else {
-    nickname = default_nickname(cert, ctx);
+    get_default_nickname(cert, ctx, nickname);
   }
 
   /* user wants to import the cert */
-  slot = PK11_ImportCertForKey(cert, nickname, ctx);
+  {
+    char *cast_const_away = const_cast<char*>(nickname.get());
+    slot = PK11_ImportCertForKey(cert, cast_const_away, ctx);
+  }
   if (!slot) {
     goto loser;
   }
   PK11_FreeSlot(slot);
 
   {
     nsCOMPtr<nsIX509Cert> certToShow = new nsNSSCertificate(cert);
     DisplayCertificateAlert(ctx, "UserCertImported", certToShow);
@@ -1536,151 +1540,132 @@ nsNSSCertificateDB::ConstructX509FromBas
   }
   
   if (certDER) {
     nsCRT::free(certDER);
   }
   return rv;
 }
 
+void
+nsNSSCertificateDB::get_default_nickname(CERTCertificate *cert, 
+                                         nsIInterfaceRequestor* ctx,
+                                         nsCString &nickname)
+{
+  nickname.Truncate();
 
-
-char *
-nsNSSCertificateDB::default_nickname(CERTCertificate *cert, nsIInterfaceRequestor* ctx)
-{   
   nsNSSShutDownPreventionLock locker;
   nsresult rv;
-  char *username = NULL;
-  char *caname = NULL;
-  char *nickname = NULL;
-  char *tmp = NULL;
-  int count;
-  char *nickFmt=NULL, *nickFmtWithNum = NULL;
-  CERTCertificate *dummycert;
-  PK11SlotInfo *slot=NULL;
   CK_OBJECT_HANDLE keyHandle;
-  nsAutoString tmpNickFmt;
-  nsAutoString tmpNickFmtWithNum;
 
   CERTCertDBHandle *defaultcertdb = CERT_GetDefaultCertDB();
   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
-  if (NS_FAILED(rv)) goto loser; 
+  if (NS_FAILED(rv))
+    return;
 
-  username = CERT_GetCommonName(&cert->subject);
-  if ( username == NULL ) 
-    username = PL_strdup("");
+  nsCAutoString username;
+  char *temp_un = CERT_GetCommonName(&cert->subject);
+  if (temp_un) {
+    username = temp_un;
+    PORT_Free(temp_un);
+    temp_un = nsnull;
+  }
+
+  nsCAutoString caname;
+  char *temp_ca = CERT_GetOrgName(&cert->issuer);
+  if (temp_ca) {
+    caname = temp_ca;
+    PORT_Free(temp_ca);
+    temp_ca = nsnull;
+  }
 
-  if ( username == NULL ) 
-    goto loser;
-    
-  caname = CERT_GetOrgName(&cert->issuer);
-  if ( caname == NULL ) 
-    caname = PL_strdup("");
-  
-  if ( caname == NULL ) 
-    goto loser;
-  
-  count = 1;
+  nsAutoString tmpNickFmt;
   nssComponent->GetPIPNSSBundleString("nick_template", tmpNickFmt);
-  nickFmt = ToNewUTF8String(tmpNickFmt);
+  NS_ConvertUTF16toUTF8 nickFmt(tmpNickFmt);
 
-  nssComponent->GetPIPNSSBundleString("nick_template_with_num", tmpNickFmtWithNum);
-  nickFmtWithNum = ToNewUTF8String(tmpNickFmtWithNum);
+  nsCAutoString baseName;
+  char *temp_nn = PR_smprintf(nickFmt.get(), username.get(), caname.get());
+  if (!temp_nn) {
+    return;
+  } else {
+    baseName = temp_nn;
+    PR_smprintf_free(temp_nn);
+    temp_nn = nsnull;
+  }
 
+  nickname = baseName;
 
-  nickname = PR_smprintf(nickFmt, username, caname);
   /*
    * We need to see if the private key exists on a token, if it does
    * then we need to check for nicknames that already exist on the smart
    * card.
    */
-  slot = PK11_KeyForCertExists(cert, &keyHandle, ctx);
-  if (slot == NULL) {
-    goto loser;
-  }
+  PK11SlotInfo *slot = PK11_KeyForCertExists(cert, &keyHandle, ctx);
+  PK11SlotInfoCleaner slotCleaner(slot);
+  if (!slot)
+    return;
+
   if (!PK11_IsInternal(slot)) {
-    tmp = PR_smprintf("%s:%s", PK11_GetTokenName(slot), nickname);
-    PR_Free(nickname);
-    nickname = tmp;
-    tmp = NULL;
+    char *tmp = PR_smprintf("%s:%s", PK11_GetTokenName(slot), baseName.get());
+    if (!tmp) {
+      nickname.Truncate();
+      return;
+    }
+    baseName = tmp;
+    PR_smprintf_free(tmp);
+
+    nickname = baseName;
   }
-  tmp = nickname;
-  while ( 1 ) {	
+
+  int count = 1;
+  while (true) {
     if ( count > 1 ) {
-      nickname = PR_smprintf("%s #%d", tmp, count);
+      char *tmp = PR_smprintf("%s #%d", baseName.get(), count);
+      if (!tmp) {
+        nickname.Truncate();
+        return;
+      }
+      nickname = tmp;
+      PR_smprintf_free(tmp);
     }
-  
-    if ( nickname == NULL ) 
-      goto loser;
- 
+
+    CERTCertificate *dummycert = nsnull;
+    CERTCertificateCleaner dummycertCleaner(dummycert);
+
     if (PK11_IsInternal(slot)) {
       /* look up the nickname to make sure it isn't in use already */
-      dummycert = CERT_FindCertByNickname(defaultcertdb, nickname);
-      
+      dummycert = CERT_FindCertByNickname(defaultcertdb, nickname.get());
+
     } else {
       /*
        * Check the cert against others that already live on the smart 
        * card.
        */
-      dummycert = PK11_FindCertFromNickname(nickname, ctx);
+      dummycert = PK11_FindCertFromNickname(nickname.get(), ctx);
       if (dummycert != NULL) {
 	/*
 	 * Make sure the subject names are different.
 	 */ 
 	if (CERT_CompareName(&cert->subject, &dummycert->subject) == SECEqual)
 	{
 	  /*
 	   * There is another certificate with the same nickname and
-	   * the same subject name on the smart card, so let's use this
+	   * the same subject name on the smart card, so let's not use this
 	   * nickname.
 	   */
 	  CERT_DestroyCertificate(dummycert);
 	  dummycert = NULL;
 	}
       }
     }
-    if ( dummycert == NULL ) 
-      goto done;
+    if (!dummycert) 
+      break;
     
-    /* found a cert, destroy it and loop */
-    CERT_DestroyCertificate(dummycert);
-    if (tmp != nickname) PR_Free(nickname);
     count++;
-  } /* end of while(1) */
-    
-loser:
-  if ( nickname ) {
-    PR_Free(nickname);
   }
-  nickname = NULL;
-done:
-  if ( caname ) {
-    PR_Free(caname);
-  }
-  if ( username )  {
-    PR_Free(username);
-  }
-  if (slot != NULL) {
-      PK11_FreeSlot(slot);
-      if (nickname != NULL) {
-	      tmp = nickname;
-	      nickname = strchr(tmp, ':');
-	      if (nickname != NULL) {
-	        nickname++;
-	        nickname = PL_strdup(nickname);
-	        PR_Free(tmp);
-             tmp = nsnull;
-	      } else {
-	        nickname = tmp;
-	        tmp = NULL;
-	      }
-      }
-    }
-    PR_FREEIF(tmp);
-    return(nickname);
 }
 
 NS_IMETHODIMP nsNSSCertificateDB::AddCertFromBase64(const char *aBase64, const char *aTrust, const char *aName)
 {
   NS_ENSURE_ARG_POINTER(aBase64);
   nsCOMPtr <nsIX509Cert> newCert;
 
   nsNSSCertTrust trust;
Index: mozilla/security/manager/ssl/src/nsNSSCertificateDB.h
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSCertificateDB.h,v
retrieving revision 1.7
diff -u -u -8 -p -r1.7 nsNSSCertificateDB.h
--- mozilla/security/manager/ssl/src/nsNSSCertificateDB.h	26 Jun 2006 17:13:13 -0000	1.7
+++ mozilla/security/manager/ssl/src/nsNSSCertificateDB.h	5 Jun 2008 07:50:18 -0000
@@ -52,18 +52,19 @@ public:
   NS_DECL_NSIX509CERTDB
   NS_DECL_NSIX509CERTDB2
 
   nsNSSCertificateDB(); 
   virtual ~nsNSSCertificateDB();
 
   // Use this function to generate a default nickname for a user
   // certificate that is to be imported onto a token.
-  static char *
-  default_nickname(CERTCertificate *cert, nsIInterfaceRequestor* ctx);
+  static void
+  get_default_nickname(CERTCertificate *cert, nsIInterfaceRequestor* ctx,
+                       nsCString &nickname);
 
   static nsresult 
   ImportValidCACerts(int numCACerts, SECItem *CACerts, nsIInterfaceRequestor *ctx);
 
 private:
 
   static nsresult
   ImportValidCACertsInList(CERTCertList *certList, nsIInterfaceRequestor *ctx);
