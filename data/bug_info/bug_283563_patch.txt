Index: security/manager/ssl/src/nsKeygenHandler.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsKeygenHandler.cpp,v
retrieving revision 1.33
diff -p -8 -u -r1.33 nsKeygenHandler.cpp
--- security/manager/ssl/src/nsKeygenHandler.cpp	17 Jun 2004 00:13:16 -0000	1.33
+++ security/manager/ssl/src/nsKeygenHandler.cpp	12 Jul 2005 21:22:17 -0000
@@ -305,34 +305,49 @@ GetSlotWithMechanism(PRUint32 aMechanism
         tmpSlot = slotList->head;
         while (tmpSlot) {
             numSlots++;
             tmpSlot = tmpSlot->next;
         }
 
         // Allocate the slot name buffer //
         tokenNameList = NS_STATIC_CAST(PRUnichar**, nsMemory::Alloc(sizeof(PRUnichar *) * numSlots));
+        if (!tokenNameList) {
+            rv = NS_ERROR_OUT_OF_MEMORY;
+            goto loser;
+        }
+
         i = 0;
         slotElement = PK11_GetFirstSafe(slotList);
         while (slotElement) {
-			tokenNameList[i] = ToNewUnicode(NS_ConvertUTF8toUCS2(PK11_GetTokenName(slotElement->slot)));
+            tokenNameList[i] = UTF8ToNewUnicode(nsDependentCString(PK11_GetTokenName(slotElement->slot)));
             slotElement = PK11_GetNextSafe(slotList, slotElement, PR_FALSE);
-            i++;
+            if (tokenNameList[i])
+                i++;
+            else {
+                // OOM. adjust numSlots so we don't free unallocated memory. 
+                numSlots = i;
+                rv = NS_ERROR_OUT_OF_MEMORY;
+                goto loser;
+            }
         }
 
 		/* Throw up the token list dialog and get back the token */
 		rv = getNSSDialogs((void**)&dialogs,
 			               NS_GET_IID(nsITokenDialogs),
                      NS_TOKENDIALOGS_CONTRACTID);
 
 		if (NS_FAILED(rv)) goto loser;
 
     {
       nsPSMUITracker tracker;
-      if (tracker.isUIForbidden()) {
+      if (!tokenNameList || !*tokenNameList) {
+          rv = NS_ERROR_OUT_OF_MEMORY;
+      }
+      else if (tracker.isUIForbidden()) {
         rv = NS_ERROR_NOT_AVAILABLE;
       }
       else {
     		rv = dialogs->ChooseToken(nsnull, (const PRUnichar**)tokenNameList, numSlots, &unicodeTokenChosen, &canceled);
       }
     }
 		NS_RELEASE(dialogs);
 		if (NS_FAILED(rv)) goto loser;
@@ -357,17 +372,17 @@ GetSlotWithMechanism(PRUint32 aMechanism
 
       // Get a reference to the slot //
       PK11_ReferenceSlot(*aSlot);
 loser:
       if (slotList) {
           PK11_FreeSlotList(slotList);
       }
       if (tokenNameList) {
-          nsMemory::Free(tokenNameList);
+          NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(numSlots, tokenNameList);
       }
       return rv;
 }
 
 nsresult
 nsKeygenFormProcessor::GetPublicKey(nsAString& aValue, nsAString& aChallenge, 
 				    nsAFlatString& aKeyType,
 				    nsAString& aOutPublicKey, nsAString& aPqg)
@@ -389,16 +404,17 @@ nsKeygenFormProcessor::GetPublicKey(nsAS
     SECKEYPublicKey *publicKey = nsnull;
     CERTSubjectPublicKeyInfo *spkInfo = nsnull;
     PRArenaPool *arena = nsnull;
     SECStatus sec_rv = SECFailure;
     SECItem spkiItem;
     SECItem pkacItem;
     SECItem signedItem;
     CERTPublicKeyAndChallenge pkac;
+    pkac.challenge.data = nsnull;
     SECKeySizeChoiceInfo *choice = SECKeySizeChoiceList;
     nsIGeneratingKeypairInfoDialogs * dialogs;
     nsKeygenThread *KeygenRunnable = 0;
     nsCOMPtr<nsIKeygenThread> runnable;
 
     // Get the key size //
     while (choice) {
         if (aValue.Equals(choice->name)) {
@@ -418,21 +434,26 @@ nsKeygenFormProcessor::GetPublicKey(nsAS
 
     // Set the keygen mechanism
     if (aKeyType.IsEmpty() || aKeyType.LowerCaseEqualsLiteral("rsa")) {
         type = rsaKey;
         keyGenMechanism = CKM_RSA_PKCS_KEY_PAIR_GEN;
     } else if (aKeyType.LowerCaseEqualsLiteral("dsa")) {
         char * end;
         pqgString = ToNewCString(aPqg);
+        if (!pqgString) {
+            rv = NS_ERROR_OUT_OF_MEMORY;
+            goto loser;
+        }
+
         type = dsaKey;
         keyGenMechanism = CKM_DSA_KEY_PAIR_GEN;
         if (strcmp(pqgString, "null") == 0)
             goto loser;
-            str = pqgString;
+        str = pqgString;
         do {
             end = strchr(str, ',');
             if (end != nsnull)
                 *end = '\0';
             primeBits = pqg_prime_bits(str);
             if (choice->size == primeBits)
                 goto found_match;
             str = end + 1;
@@ -535,18 +556,22 @@ found_match:
     if (sec_rv != SECSuccess) {
         goto loser;
     }
 
     /*
      * set up the PublicKeyAndChallenge data structure, then DER encode it
      */
     pkac.spki = spkiItem;
-	pkac.challenge.len = aChallenge.Length();
+    pkac.challenge.len = aChallenge.Length();
     pkac.challenge.data = (unsigned char *)ToNewCString(aChallenge);
+    if (!pkac.challenge.data) {
+        rv = NS_ERROR_OUT_OF_MEMORY;
+        goto loser;
+    }
     
     sec_rv = DER_Encode(arena, &pkacItem, CERTPublicKeyAndChallengeTemplate, &pkac);
     if ( sec_rv != SECSuccess ) {
         goto loser;
     }
 
     /*
      * now sign the DER encoded PublicKeyAndChallenge
@@ -556,16 +581,20 @@ found_match:
     if ( sec_rv != SECSuccess ) {
         goto loser;
     }
     
     /*
      * Convert the signed public key and challenge into base64/ascii.
      */
     keystring = BTOA_DataToAscii(signedItem.data, signedItem.len);
+    if (!keystring) {
+        rv = NS_ERROR_OUT_OF_MEMORY;
+        goto loser;
+    }
 
     CopyASCIItoUTF16(keystring, aOutPublicKey);
     nsCRT::free(keystring);
 
     rv = NS_OK;
 loser:
     if ( sec_rv != SECSuccess ) {
         if ( privateKey ) {
@@ -588,16 +617,22 @@ loser:
       PORT_FreeArena(arena, PR_TRUE);
     }
     if (slot != nsnull) {
         PK11_FreeSlot(slot);
     }
     if (KeygenRunnable) {
       NS_RELEASE(KeygenRunnable);
     }
+    if (pqgString) {
+        nsMemory::Free(pqgString);
+    }
+    if (pkac.challenge.data) {
+        nsMemory::Free(pkac.challenge.data);
+    }
     return rv;
 }
 
 NS_METHOD 
 nsKeygenFormProcessor::ProcessValue(nsIDOMHTMLElement *aElement, 
 				    const nsString& aName, 
 				    nsString& aValue) 
 { 
