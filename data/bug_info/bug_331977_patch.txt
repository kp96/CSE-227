Index: mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp,v
retrieving revision 1.110
diff -u -2 -0 -p -w -r1.110 nsNSSIOLayer.cpp
--- mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp	20 May 2006 02:36:48 -0000	1.110
+++ mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp	30 Jun 2006 21:15:47 -0000
@@ -1059,74 +1059,73 @@ isTLSIntoleranceError(PRInt32 err, PRBoo
 PRInt32
 nsSSLThread::checkHandshake(PRInt32 bytesTransfered, PRFileDesc* ssl_layer_fd, nsNSSSocketInfo *socketInfo)
 {
   // This is where we work around all of those SSL servers that don't 
   // conform to the SSL spec and shutdown a connection when we request
   // SSL v3.1 (aka TLS).  The spec says the client says what version
   // of the protocol we're willing to perform, in our case SSL v3.1
   // In its response, the server says which version it wants to perform.
   // Many servers out there only know how to do v3.0.  Next, we're supposed
   // to send back the version of the protocol we requested (ie v3.1).  At
   // this point many servers's implementations are broken and they shut
   // down the connection when they don't see the version they sent back.
   // This is supposed to prevent a man in the middle from forcing one
   // side to dumb down to a lower level of the protocol.  Unfortunately,
   // there are enough broken servers out there that such a gross work-around
   // is necessary.  :(
 
   PRBool handleHandshakeResultNow;
   socketInfo->GetHandshakePending(&handleHandshakeResultNow);
 
-  if (0 > bytesTransfered && handleHandshakeResultNow) {
+  if (0 > bytesTransfered) {
     PRInt32 err = PR_GetError();
+    PRBool wantRetry = PR_FALSE;
 
+    if (handleHandshakeResultNow) {
     // Let's see if there was an error set by the SSL libraries that we
     // should tell the user about.
     if (PR_WOULD_BLOCK_ERROR == err) {
-      // we are not yet ready to handle the result code from the 
-      // first transfer after the handshake
-      handleHandshakeResultNow = PR_FALSE;
       socketInfo->SetHandshakeInProgress(PR_TRUE);
+        return bytesTransfered;
     }
-    else {
-      PRBool wantRetry = PR_FALSE;
+      
       PRBool withInitialCleartext = socketInfo->GetHasCleartextPhase();
 
       // When not using a proxy we'll see a connection reset error.
       // When using a proxy, we'll see an end of file error.
       // In addition check for some error codes where it is reasonable
       // to retry without TLS.
 
       if (isTLSIntoleranceError(err, withInitialCleartext)) {
         wantRetry = nsSSLIOLayerHelpers::rememberPossibleTLSProblemSite(ssl_layer_fd, socketInfo);
 
         if (wantRetry) {
           // We want to cause the network layer to retry the connection.
           PR_SetError(PR_CONNECT_RESET_ERROR, 0);
         }
       }
+    }
 
       if (!wantRetry && (IS_SSL_ERROR(err) || IS_SEC_ERROR(err))) {
         nsHandleSSLError(socketInfo, err);
       }
     }
-  }
 
   // TLS intolerant servers only cause the first transfer to fail, so let's 
   // set the HandshakePending attribute to false so that we don't try the logic
   // above again in a subsequent transfer.
   if (handleHandshakeResultNow) {
     socketInfo->SetHandshakePending(PR_FALSE);
     socketInfo->SetHandshakeInProgress(PR_FALSE);
   }
   
   return bytesTransfered;
 }
 
 static PRInt16 PR_CALLBACK
 nsSSLIOLayerPoll(PRFileDesc *fd, PRInt16 in_flags, PRInt16 *out_flags)
 {
   nsNSSShutDownPreventionLock locker;
 
   if (!out_flags)
   {
     NS_WARNING("nsSSLIOLayerPoll called with null out_flags");
