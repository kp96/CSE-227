diff --git a/toolkit/mozapps/extensions/src/nsExtensionManager.js.in b/toolkit/mozapps/extensions/src/nsExtensionManager.js.in
index 2cc92a9..898991c 100644
--- a/toolkit/mozapps/extensions/src/nsExtensionManager.js.in
+++ b/toolkit/mozapps/extensions/src/nsExtensionManager.js.in
@@ -2319,16 +2319,17 @@ var Blocklist = {
    *                 Each value in the version range array is a JS Object that
    *                 has the following properties:
    *                   "minVersion"  The minimum version in a version range
    *                                 (default = 0)
    *                   "maxVersion"  The maximum version in a version range
    *                                 (default = *)
    */
   entries: null,
+  _pluginEntries: null,
 
   notify: function() {
     if (getPref("getBoolPref", PREF_BLOCKLIST_ENABLED, true) == false)
       return;
 
     try {
       var dsURI = gPref.getCharPref(PREF_BLOCKLIST_URL);
     }
@@ -2379,21 +2380,21 @@ var Blocklist = {
       return;
     }
     var blocklistFile = getFile(KEY_PROFILEDIR, [FILE_BLOCKLIST]);
     if (blocklistFile.exists())
       blocklistFile.remove(false);
     var fos = openSafeFileOutputStream(blocklistFile);
     fos.write(request.responseText, request.responseText.length);
     closeSafeFileOutputStream(fos);
-    this.entries = this._loadBlocklistFromFile(getFile(KEY_PROFILEDIR,
-                                                       [FILE_BLOCKLIST]));
+    this._loadBlocklistFromFile(getFile(KEY_PROFILEDIR, [FILE_BLOCKLIST]));
     var em = Components.classes["@mozilla.org/extensions/manager;1"]
                        .getService(Components.interfaces.nsIExtensionManager);
     em.checkForBlocklistChanges();
+    this._checkPluginsList();
   },
 
   onXMLError: function(aEvent) {
     try {
       var request = aEvent.target;
       // the following may throw (e.g. a local file or timeout)
       var status = request.status;
     }
@@ -2446,93 +2447,158 @@ var Blocklist = {
    *     <emItem id="item_4@domain">
    *       <versionRange>
    *         <targetApplication>
    *           <versionRange minVersion="1.5" maxVersion="1.5.*"/>
    *         </targetApplication>
    *       </versionRange>
    *     <emItem id="item_5@domain"/>
    *   </emItems>
+   *   <pluginItems>
+   *     <pluginItem>
+   *       <match name="name" exp="BadPlugin"/>
+   *     </pluginItem>
+   *   </pluginItems>
    * </blocklist> 
    */
   _loadBlocklistFromFile: function(file) {
     if (getPref("getBoolPref", PREF_BLOCKLIST_ENABLED, true) == false) {
       LOG("Blocklist::_loadBlocklistFromFile: blocklist is disabled");
-      return { };
+      return;
     }
 
     if (!file.exists()) {
       LOG("Blocklist::_loadBlocklistFromFile: XML File does not exist");
-      return { };
+      return;
     }
 
-    var result = { };
     var fileStream = Components.classes["@mozilla.org/network/file-input-stream;1"]
                                .createInstance(Components.interfaces.nsIFileInputStream);
     fileStream.init(file, MODE_RDONLY, PERMS_FILE, 0);
     try {
       var parser = Components.classes["@mozilla.org/xmlextras/domparser;1"]
                              .createInstance(Components.interfaces.nsIDOMParser);
       var doc = parser.parseFromStream(fileStream, "UTF-8", file.fileSize, "text/xml");
       if (doc.documentElement.namespaceURI != XMLURI_BLOCKLIST) {
         LOG("Blocklist::_loadBlocklistFromFile: aborting due to incorrect " +
             "XML Namespace.\r\nExpected: " + XMLURI_BLOCKLIST + "\r\n" +
             "Received: " + doc.documentElement.namespaceURI);
-        return { };
+        return;
       }
 
-      const kELEMENT_NODE = Components.interfaces.nsIDOMNode.ELEMENT_NODE;
-      var itemNodes = this._getItemNodes(doc.documentElement.childNodes);
-      for (var i = 0; i < itemNodes.length; ++i) {
-        var blocklistElement = itemNodes[i];
-        if (blocklistElement.nodeType != kELEMENT_NODE ||
-            blocklistElement.localName != "emItem")
-          continue;
-
-        blocklistElement.QueryInterface(Components.interfaces.nsIDOMElement);
-        var versionNodes = blocklistElement.childNodes;
-        var id = blocklistElement.getAttribute("id");
-        result[id] = [];
-        for (var x = 0; x < versionNodes.length; ++x) {
-          var versionRangeElement = versionNodes[x];
-          if (versionRangeElement.nodeType != kELEMENT_NODE ||
-              versionRangeElement.localName != "versionRange")
-            continue;
-
-          result[id].push(new BlocklistItemData(versionRangeElement));
-        }
-        // if only the extension ID is specified block all versions of the
-        // extension for the current application.
-        if (result[id].length == 0)
-          result[id].push(new BlocklistItemData(null));
-      }
+      var childNodes = doc.documentElement.childNodes;
+      this.entries = this._processItemNodes(childNodes, "em",
+                                            this._handleEmItemNode);
+      this._pluginEntries = this._processItemNodes(childNodes, "plugin",
+                                                   this._handlePluginItemNode);
     }
     catch (e) {
       LOG("Blocklist::_loadBlocklistFromFile: Error constructing blocklist " + e);
-      return { };
+      return;
     }
     fileStream.close();
-    return result;
   },
 
-  _getItemNodes: function(deChildNodes) {
+  _processItemNodes: function(deChildNodes, prefix, handler) {
     const kELEMENT_NODE = Components.interfaces.nsIDOMNode.ELEMENT_NODE;
+    var result = [];
+    var itemNodes;
+    var containerName = prefix + "Items";
     for (var i = 0; i < deChildNodes.length; ++i) {
       var emItemsElement = deChildNodes[i];
       if (emItemsElement.nodeType == kELEMENT_NODE &&
-          emItemsElement.localName == "emItems")
-        return emItemsElement.childNodes;
+          emItemsElement.localName == containerName) {
+        itemNodes = emItemsElement.childNodes;
+        break;
+      }
+    }
+    if (!itemNodes)
+      return result;
+
+    var itemName = prefix + "Item";
+    for (var i = 0; i < itemNodes.length; ++i) {
+      var blocklistElement = itemNodes[i];
+      if (blocklistElement.nodeType != kELEMENT_NODE ||
+          blocklistElement.localName != itemName)
+        continue;
+
+      blocklistElement.QueryInterface(Components.interfaces.nsIDOMElement);
+      handler(blocklistElement, result);
+    }
+    return result;
+  },
+
+  _handleEmItemNode: function(blocklistElement, result) {
+    const kELEMENT_NODE = Components.interfaces.nsIDOMNode.ELEMENT_NODE;
+    var versionNodes = blocklistElement.childNodes;
+    var id = blocklistElement.getAttribute("id");
+    result[id] = [];
+    for (var x = 0; x < versionNodes.length; ++x) {
+      var versionRangeElement = versionNodes[x];
+      if (versionRangeElement.nodeType != kELEMENT_NODE ||
+          versionRangeElement.localName != "versionRange")
+        continue;
+
+      result[id].push(new BlocklistItemData(versionRangeElement));
     }
-    return [ ];
+    // if only the extension ID is specified block all versions of the
+    // extension for the current application.
+    if (result[id].length == 0)
+      result[id].push(new BlocklistItemData(null));
+  },
+
+  _handlePluginItemNode: function(blocklistElement, result) {
+    const kELEMENT_NODE = Components.interfaces.nsIDOMNode.ELEMENT_NODE;
+    var matchNodes = blocklistElement.childNodes;
+    var matchList;
+    for (var x = 0; x < matchNodes.length; ++x) {
+      var matchElement = matchNodes[x];
+      if (matchElement.nodeType != kELEMENT_NODE ||
+          matchElement.localName != "match")
+        continue;
+
+      var name = matchElement.getAttribute("name");
+      var exp = matchElement.getAttribute("exp");
+      if (!matchList)
+        matchList = { };
+      matchList[name] = new RegExp(exp, "m");
+    }
+    if (matchList)
+      result.push(matchList);
+  },
+
+  _checkPlugin: function(plugin) {
+    for each (var matchList in this._pluginEntries) {
+      var matchFailed = false;
+      for (var name in matchList) {
+        if (typeof(plugin[name]) != "string" ||
+            !matchList[name].test(plugin[name])) {
+          matchFailed = true;
+          break;
+        }
+      }
+
+      if (!matchFailed) {
+        plugin.blocklisted = true;
+        return;
+      }
+    }
+    plugin.blocklisted = false;
+  },
+
+  _checkPluginsList: function() {
+    this._ensureBlocklist();
+    var phs = Components.classes["@mozilla.org/plugin/host;1"]
+                        .getService(Components.interfaces.nsIPluginHost);
+    phs.getPluginTags({ }).forEach(this._checkPlugin, this);
   },
 
   _ensureBlocklist: function() {
     if (!this.entries)
-      this.entries = this._loadBlocklistFromFile(getFile(KEY_PROFILEDIR, 
-                                                         [FILE_BLOCKLIST]));
+      this._loadBlocklistFromFile(getFile(KEY_PROFILEDIR, [FILE_BLOCKLIST]));
   }
 };
 
 /**
  * Helper for constructing a blocklist.
  */
 function BlocklistItemData(versionRangeElement) {
   var versionRange = this.getBlocklistVersionRange(versionRangeElement);
@@ -2632,16 +2698,17 @@ function ExtensionManager() {
     gXPCOMABI = UNKNOWN_XPCOM_ABI;
   }
   gPref = Components.classes["@mozilla.org/preferences-service;1"]
                     .getService(Components.interfaces.nsIPrefBranch2);
 
   gOS = Components.classes["@mozilla.org/observer-service;1"]
                   .getService(Components.interfaces.nsIObserverService);
   gOS.addObserver(this, "xpcom-shutdown", false);
+  gOS.addObserver(this, "plugins-list-updated", false);
 
   gConsole = Components.classes["@mozilla.org/consoleservice;1"]
                        .getService(Components.interfaces.nsIConsoleService);  
   
   gRDF = Components.classes["@mozilla.org/rdf/rdf-service;1"]
                    .getService(Components.interfaces.nsIRDFService);
   gInstallManifestRoot = gRDF.GetResource(RDFURI_INSTALL_MANIFEST_ROOT);
   
@@ -2713,16 +2780,19 @@ ExtensionManager.prototype = {
     case "nsPref:changed":
       if (data == PREF_EM_LOGGING_ENABLED)
         this._loggingToggled();
       else if (data == PREF_EM_CHECK_COMPATIBILITY)
         this._checkCompatToggled();
       else if ((data == PREF_MATCH_OS_LOCALE) || (data == PREF_SELECTED_LOCALE))
         this._updateLocale();
       break;
+    case "plugins-list-updated":
+      Blocklist._checkPluginsList();
+      break;
     }
   },
   
   /**
    * Refresh the logging enabled global from preferences when the user changes
    * the preference settting.
    */
   _loggingToggled: function() {
@@ -2815,16 +2885,17 @@ ExtensionManager.prototype = {
     ww.openWindow(null, EMURL, null, EMFEATURES, param);
   },
 
   /**
    * Clean up on application shutdown to avoid leaks.
    */
   _shutdown: function() {
     gOS.removeObserver(this, "xpcom-shutdown");
+    gOS.removeObserver(this, "plugins-list-updated");
     gOS.removeObserver(this, "profile-after-change");
 
     // Release strongly held services.
     gOS = null;
     if (this._ds && gRDF) 
       gRDF.UnregisterDataSource(this._ds)
     gRDF = null;
     if (gPref) {
