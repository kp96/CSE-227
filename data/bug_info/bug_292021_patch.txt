Index: configure.in
===================================================================
RCS file: /cvsroot/mozilla/configure.in,v
retrieving revision 1.1443
retrieving revision 1.1443.2.3
diff -p -u -1 -0 -r1.1443 -r1.1443.2.3
--- configure.in	22 Apr 2005 19:06:27 -0000	1.1443
+++ configure.in	8 Jun 2005 00:27:36 -0000	1.1443.2.3
@@ -4632,20 +4632,33 @@ MOZ_ARG_DISABLE_BOOL(installer,
 [  --disable-installer     Disable building of installer],
     MOZ_INSTALLER=,
     MOZ_INSTALLER=1 )
 # Automatically disable installer if xpinstall isn't built
 if test -z "$MOZ_XPINSTALL"; then
     MOZ_INSTALLER=
 fi
 AC_SUBST(MOZ_INSTALLER)
 
 dnl ========================================================
+dnl Updater
+dnl ========================================================
+
+if test "$MOZ_XUL_APP"; then
+    MOZ_UPDATER=1
+fi
+MOZ_ARG_DISABLE_BOOL(updater,
+[  --disable-updater       Disable building of updater],
+    MOZ_UPDATER=,
+    MOZ_UPDATER=1 )
+AC_SUBST(MOZ_UPDATER)
+
+dnl ========================================================
 dnl ActiveX
 dnl ========================================================
 MOZ_NO_ACTIVEX_SUPPORT=1
 MOZ_ACTIVEX_SCRIPTING_SUPPORT=
 case "$target_os" in
     msvc*|mks*|cygwin*|mingw*|wince*)
         if test -z "$GNU_CC"; then 
             MOZ_NO_ACTIVEX_SUPPORT=
             MOZ_ACTIVEX_SCRIPTING_SUPPORT=1
         fi
Index: client.mk
===================================================================
RCS file: /cvsroot/mozilla/client.mk,v
retrieving revision 1.231
retrieving revision 1.231.2.4
diff -p -u -1 -0 -r1.231 -r1.231.2.4
--- client.mk	21 Apr 2005 13:24:56 -0000	1.231
+++ client.mk	8 Jun 2005 00:19:21 -0000	1.231.2.4
@@ -58,20 +58,21 @@
 #     suite (Seamonkey suite)
 #     browser (aka Firefox)
 #     mail (aka Thunderbird)
 #     composer (standalone composer, aka NVU)
 #     calendar (aka Sunbird, use this to build the calendar extensions also)
 #     xulrunner
 #     macbrowser (aka Camino)
 #
 # Other common MOZ_CO_MODULE options include the following:
 #   mozilla/other-licenses/libart_lgpl
+#   mozilla/other-licenses/bsdiff
 #   mozilla/tools/codesighs
 #
 # Other targets (gmake -f client.mk [targets...]),
 #    checkout
 #    build
 #    clean (realclean is now the same as clean)
 #    distclean
 #
 # See http://www.mozilla.org/build/ for more information.
 #
@@ -95,20 +96,22 @@ AVAILABLE_PROJECTS = \
   composer \
   calendar \
   xulrunner \
   macbrowser \
   $(NULL)
 
 MODULES_core :=                                \
   SeaMonkeyAll                                  \
   mozilla/ipc/ipcd                              \
   mozilla/modules/libpr0n                       \
+  mozilla/modules/libmar                        \
+  mozilla/modules/libbz2                        \
   mozilla/accessible                            \
   mozilla/security/manager                      \
   mozilla/toolkit                               \
   mozilla/storage                               \
   mozilla/db/sqlite3                            \
   $(NULL)
 
 LOCALES_core :=                                 \
   netwerk                                       \
   dom                                           \
Index: Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/Makefile.in,v
retrieving revision 1.290
retrieving revision 1.290.2.7
diff -p -u -1 -0 -r1.290 -r1.290.2.7
--- Makefile.in	19 Apr 2005 17:19:41 -0000	1.290
+++ Makefile.in	8 Jun 2005 00:19:21 -0000	1.290.2.7
@@ -118,20 +118,25 @@ endif
 
 ifndef MOZ_NATIVE_ZLIB
 tier_1_dirs	+= modules/zlib
 endif
 
 # Installer needs standalone libjar, hence standalone zlib
 ifdef MOZ_INSTALLER
 tier_1_dirs	+= modules/zlib/standalone
 endif
 
+ifdef MOZ_UPDATER
+tier_1_dirs += modules/libbz2
+tier_1_dirs += modules/libmar
+endif
+
 ifdef MOZ_SVG_RENDERER_LIBART
 tier_1_dirs	+= other-licenses/libart_lgpl
 endif
 
 #
 # tier 2 - base libraries
 # 
 tier_2_dirs	= \
 		js \
 		xpcom \
Index: allmakefiles.sh
===================================================================
RCS file: /cvsroot/mozilla/allmakefiles.sh,v
retrieving revision 1.558
retrieving revision 1.558.2.3
diff -p -u -1 -0 -r1.558 -r1.558.2.3
--- allmakefiles.sh	19 Apr 2005 17:19:41 -0000	1.558
+++ allmakefiles.sh	8 Jun 2005 00:19:21 -0000	1.558.2.3
@@ -1177,20 +1177,29 @@ if [ ! "$SYSTEM_ZLIB" ]; then
 	modules/zlib/Makefile
 	modules/zlib/src/Makefile
 "
 fi
 
 MAKEFILES_zlib="
     $MAKEFILES_zlib
     modules/zlib/standalone/Makefile
 "
 
+MAKEFILES_libbz2="
+    modules/libbz2/Makefile
+    modules/libbz2/src/Makefile
+"
+
+MAKEFILES_libmar="
+    modules/libmar/Makefile
+    modules/libmar/src/Makefile
+"
 
 if [ ! "$SYSTEM_PNG" ]; then
     MAKEFILES_libimg="$MAKEFILES_libimg modules/libimg/png/Makefile"
 fi
 
 MAKEFILES_gnome="
     toolkit/Makefile
     toolkit/components/Makefile
     toolkit/components/gnome/Makefile
 "
@@ -1571,20 +1580,22 @@ $MAKEFILES_view
 $MAKEFILES_webshell
 $MAKEFILES_widget
 $MAKEFILES_xft
 $MAKEFILES_xpcom
 $MAKEFILES_xpcom_obsolete
 $MAKEFILES_xpcom_tests
 $MAKEFILES_xpconnect
 $MAKEFILES_xpinstall
 $MAKEFILES_xpfe
 $MAKEFILES_zlib
+$MAKEFILES_libbz2
+$MAKEFILES_libmar
 "
 
 if test -n "$MOZ_PSM"; then
     add_makefiles "$MAKEFILES_psm2"
 fi
 
 if test -n "$MOZ_CALENDAR"; then
     add_makefiles "$MAKEFILES_calendar"
 fi
 
Index: toolkit/mozapps/update/src/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/toolkit/mozapps/update/src/Makefile.in,v
retrieving revision 1.5
retrieving revision 1.5.4.2
diff -p -u -1 -0 -r1.5 -r1.5.4.2
--- toolkit/mozapps/update/src/Makefile.in	1 Feb 2005 17:07:29 -0000	1.5
+++ toolkit/mozapps/update/src/Makefile.in	7 Jun 2005 06:55:24 -0000	1.5.4.2
@@ -37,17 +37,21 @@
 
 DEPTH   = ../../../..
 topsrcdir = @top_srcdir@
 srcdir    = @srcdir@
 VPATH   = @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 MODULE = extensions
 
+ifdef MOZ_UPDATER
+DIRS = updater
+endif
+
 EXTRA_COMPONENTS = nsUpdateService.js
 
 include $(topsrcdir)/config/rules.mk
 
 nsUpdateService.js: nsUpdateService.js.in
 	$(PERL) $(MOZILLA_DIR)/config/preprocessor.pl $(DEFINES) $(ACDEFINES) $^ > $@ 
 
Index: browser/locales/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/browser/locales/Makefile.in,v
retrieving revision 1.10
retrieving revision 1.10.2.1
diff -p -u -1 -0 -r1.10 -r1.10.2.1
--- browser/locales/Makefile.in	22 Apr 2005 18:33:55 -0000	1.10
+++ browser/locales/Makefile.in	7 Jun 2005 07:31:09 -0000	1.10.2.1
@@ -1,10 +1,11 @@
+# vim:set ts=8 sw=8 sts=8 noet:
 # ***** BEGIN LICENSE BLOCK *****
 # Version: MPL 1.1/GPL 2.0/LGPL 2.1
 #
 # The contents of this file are subject to the Mozilla Public License Version
 # 1.1 (the "License"); you may not use this file except in compliance with
 # the License. You may obtain a copy of the License at
 # http://www.mozilla.org/MPL/
 #
 # Software distributed under the License is distributed on an "AS IS" basis,
 # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
@@ -212,10 +213,19 @@ langpack-%:
 # This is a generic target that will make a langpack, repack ZIP (+tarball)
 # builds, and repack an installer if applicable. It is called from the
 # tinderbox scripts. Alter it with caution.
 
 installers-%:
 	@$(MAKE) langpack-$*
 	@$(MAKE) repackage-zip-$*
 ifeq (WINNT,$(OS_ARCH))
 	@$(MAKE) repackage-win32-installer-$*
 endif
+
+ifdef MOZ_UPDATER
+libs:: $(addprefix $(LOCALE_SRCDIR)/,updater/updater.ini)
+ifeq ($(OS_ARCH),WINNT)
+	iconv -f UTF-8 -t $(WIN_INSTALLER_CHARSET) $< > $(FINAL_TARGET)/updater.ini
+else
+	$(INSTALL) $^ $(FINAL_TARGET)
+endif
+endif
Index: browser/locales/en-US/updater/updater.ini
===================================================================
RCS file: browser/locales/en-US/updater/updater.ini
diff -N browser/locales/en-US/updater/updater.ini
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ browser/locales/en-US/updater/updater.ini	7 Jun 2005 07:31:10 -0000	1.1.2.1
@@ -0,0 +1,4 @@
+; This file is in the UTF-8 encoding
+[Strings]
+Title=Updating Firefox
+Info=Applying updates to Firefox.  Please do not interrupt this process.
Index: toolkit/mozapps/update/src/updater/Makefile.in
===================================================================
RCS file: toolkit/mozapps/update/src/updater/Makefile.in
diff -N toolkit/mozapps/update/src/updater/Makefile.in
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/mozapps/update/src/updater/Makefile.in	7 Jun 2005 07:30:41 -0000	1.1.2.8
@@ -0,0 +1,85 @@
+# vim:set ts=8 sw=8 sts=8 noet:
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla Toolkit Application Update.
+#
+# The Initial Developer of the Original Code is
+# Benjamin Smedberg <benjamin@smedbergs.us>
+
+# Portions created by the Initial Developer are Copyright (C) 2005
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+
+DEPTH		= ../../../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+CPPSRCS = \
+	updater.cpp \
+	bspatch.cpp \
+	archivereader.cpp \
+	$(NULL)
+
+PROGRAM = updater$(BIN_SUFFIX)
+
+REQUIRES = libmar libbz2
+
+LIBS += \
+	$(DIST)/lib/$(LIB_PREFIX)mar.$(LIB_SUFFIX) \
+	$(DIST)/lib/$(LIB_PREFIX)bz2.$(LIB_SUFFIX) \
+	$(NULL)
+
+ifeq ($(OS_ARCH),WINNT)
+HAVE_PROGRESSUI = 1
+RCINCLUDE = updater.rc
+CPPSRCS += progressui_win.cpp
+OS_LIBS += $(call EXPAND_LIBNAME,comctl32 ws2_32)
+ifndef GNU_CC
+RCFLAGS += -I$(srcdir)
+else
+RCFLAGS += --include-dir $(srcdir)
+endif
+endif
+
+ifneq ($(MOZ_ENABLE_GTK2)$(MOZ_ENABLE_GTK),)
+HAVE_PROGRESSUI = 1
+CPPSRCS += progressui_gtk.cpp
+OS_CXXFLAGS += $(TK_CFLAGS)
+OS_LIBS += $(TK_LIBS)
+endif
+
+ifndef HAVE_PROGRESSUI
+CPPSRCS += progressui_null.cpp
+endif
+
+include $(topsrcdir)/config/rules.mk
Index: toolkit/mozapps/update/src/updater/archivereader.cpp
===================================================================
RCS file: toolkit/mozapps/update/src/updater/archivereader.cpp
diff -N toolkit/mozapps/update/src/updater/archivereader.cpp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/mozapps/update/src/updater/archivereader.cpp	7 Jun 2005 07:51:25 -0000	1.1.2.7
@@ -0,0 +1,146 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Darin Fisher <darin@meer.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include <string.h>
+#include <fcntl.h>
+#include "bzlib.h"
+#include "archivereader.h"
+#include "errors.h"
+
+#if defined(XP_UNIX)
+# include <sys/types.h>
+#elif defined(XP_WIN)
+# include <io.h>
+#endif
+
+int
+ArchiveReader::Open(const char *path)
+{
+  if (mArchive)
+    Close();
+
+  mArchive = mar_open(path);
+  if (!mArchive)
+    return IO_ERROR;
+
+  return OK;
+}
+
+void
+ArchiveReader::Close()
+{
+  if (mArchive) {
+    mar_close(mArchive);
+    mArchive = NULL;
+  }
+}
+
+int
+ArchiveReader::ExtractFile(const char *name, const char *dest)
+{
+  const MarItem *item = mar_find_item(mArchive, name);
+  if (!item)
+    return IO_ERROR;
+
+#ifdef XP_WIN
+  int fd = _open(dest, _O_BINARY|_O_CREAT|_O_TRUNC|_O_WRONLY, item->flags);
+#else
+  int fd = creat(dest, item->flags);
+#endif
+  if (fd == -1)
+    return IO_ERROR;
+
+  FILE *fp = fdopen(fd, "wb");
+  if (!fp)
+    return IO_ERROR;
+
+  int rv = ExtractItemToStream(item, fp);
+
+  fclose(fp);
+  return rv;
+}
+
+int
+ArchiveReader::ExtractItemToStream(const MarItem *item, FILE *fp)
+{
+  /* decompress the data chunk by chunk */
+
+  char inbuf[BUFSIZ], outbuf[BUFSIZ];
+  bz_stream strm;
+  int offset, inlen, ret = OK;
+
+  memset(&strm, 0, sizeof(strm));
+  if (BZ2_bzDecompressInit(&strm, 0, 0) != BZ_OK)
+    return UNEXPECTED_ERROR;
+
+  offset = 0;
+  for (;;) {
+    if (offset < (int) item->length && strm.avail_in == 0) {
+      inlen = mar_read(mArchive, item, offset, inbuf, BUFSIZ);
+      if (inlen <= 0)
+        return -1;
+      offset += inlen;
+      strm.next_in = inbuf;
+      strm.avail_in = inlen;
+    }
+
+    strm.next_out = outbuf;
+    strm.avail_out = BUFSIZ;
+
+    ret = BZ2_bzDecompress(&strm);
+    if (ret != BZ_OK && ret != BZ_STREAM_END) {
+      ret = IO_ERROR;
+      break;
+    }
+
+    if (strm.avail_out < BUFSIZ) {
+      if (fwrite(outbuf, BUFSIZ - strm.avail_out, 1, fp) != 1) {
+        ret = IO_ERROR;
+        break;
+      }
+    }
+
+    if (ret == BZ_STREAM_END) {
+      ret = OK;
+      break;
+    }
+  }
+
+  BZ2_bzDecompressEnd(&strm);
+  return ret;
+}
Index: toolkit/mozapps/update/src/updater/archivereader.h
===================================================================
RCS file: toolkit/mozapps/update/src/updater/archivereader.h
diff -N toolkit/mozapps/update/src/updater/archivereader.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/mozapps/update/src/updater/archivereader.h	2 Jun 2005 00:04:15 -0000	1.1.2.2
@@ -0,0 +1,63 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Darin Fisher <darin@meer.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef ArchiveReader_h__
+#define ArchiveReader_h__
+
+#include <stdio.h>
+#include "mar.h"
+
+// This class provides an API to extract files from an update archive.
+class ArchiveReader
+{
+public:
+  ArchiveReader() : mArchive(NULL) {}
+  ~ArchiveReader() { Close(); }
+
+  int Open(const char *path);
+  void Close();
+
+  int ExtractFile(const char *item, const char *destination);
+
+private:
+  int ExtractItemToStream(const MarItem *item, FILE *fp);
+
+  MarFile *mArchive;
+};
+
+#endif  // ArchiveReader_h__
Index: toolkit/mozapps/update/src/updater/bspatch.cpp
===================================================================
RCS file: toolkit/mozapps/update/src/updater/bspatch.cpp
diff -N toolkit/mozapps/update/src/updater/bspatch.cpp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/mozapps/update/src/updater/bspatch.cpp	7 Jun 2005 07:51:25 -0000	1.1.2.3
@@ -0,0 +1,189 @@
+/*-
+ * Copyright 2003,2004 Colin Percival
+ * All rights reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted providing that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Changelog:
+ * 2005-04-26 - Define the header as a C structure, add a CRC32 checksum to
+ *              the header, and make all the types 32-bit.
+ *                --Benjamin Smedberg <benjamin@smedbergs.us>
+ */
+
+#include "bspatch.h"
+
+#include <sys/stat.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <string.h>
+#include <limits.h>
+
+#if defined(XP_UNIX)
+# include <unistd.h>
+#elif defined(XP_WIN)
+# include <io.h>
+#endif
+
+#ifdef XP_WIN
+#include <winsock2.h>
+#else
+#include <arpa/inet.h>
+#endif
+
+#ifndef SSIZE_MAX
+# define SSIZE_MAX LONG_MAX
+#endif
+
+int
+MBS_ReadHeader(int fd, MBSPatchHeader *header)
+{
+  int s = read(fd, header, sizeof(MBSPatchHeader));
+  if (s != sizeof(MBSPatchHeader))
+    return BSP_ERROR_IO;
+
+  header->slen      = ntohl(header->slen);
+  header->scrc32    = ntohl(header->scrc32);
+  header->dlen      = ntohl(header->dlen);
+  header->cblen     = ntohl(header->cblen);
+  header->difflen   = ntohl(header->difflen);
+  header->extralen  = ntohl(header->extralen);
+
+  struct stat hs;
+  s = fstat(fd, &hs);
+  if (s)
+    return BSP_ERROR_IO;
+
+  if (memcmp(header->tag, "MBDIFF10", 8) != 0)
+    return BSP_ERROR_CORRUPT;
+
+  if (sizeof(MBSPatchHeader) +
+      header->cblen +
+      header->difflen +
+      header->extralen != PRUint32(hs.st_size))
+    return BSP_ERROR_CORRUPT;
+
+  return BSP_OK;
+}
+         
+int
+MBS_ApplyPatch(const MBSPatchHeader *header, int patchfd,
+               unsigned char *fbuffer, int filefd)
+{
+  unsigned char *fbufend = fbuffer + header->slen;
+
+  unsigned char *buf = (unsigned char*) malloc(header->cblen +
+                                               header->difflen +
+                                               header->extralen);
+  if (!buf)
+    return BSP_ERROR_NOMEM;
+
+  int rv = BSP_OK;
+
+  int r = header->cblen + header->difflen + header->extralen;
+  unsigned char *wb = buf;
+  while (r) {
+    int c = read(patchfd, wb, (r > SSIZE_MAX) ? SSIZE_MAX : r);
+    if (c < 0) {
+      rv = BSP_ERROR_IO;
+      goto end;
+    }
+
+    r -= c;
+
+    if (c == 0 && r) {
+      rv = BSP_ERROR_CORRUPT;
+      goto end;
+    }
+  }
+
+  {
+    MBSPatchTriple *ctrlsrc = (MBSPatchTriple*) buf;
+    unsigned char *diffsrc = buf + header->cblen;
+    unsigned char *extrasrc = diffsrc + header->difflen;
+
+    MBSPatchTriple *ctrlend = (MBSPatchTriple*) diffsrc;
+    unsigned char *diffend = extrasrc;
+    unsigned char *extraend = extrasrc + header->extralen;
+
+    do {
+      ctrlsrc->x = ntohl(ctrlsrc->x);
+      ctrlsrc->y = ntohl(ctrlsrc->y);
+      ctrlsrc->z = ntohl(ctrlsrc->z);
+
+#ifdef DEBUG_bsmedberg
+      printf("Applying block:\n"
+             " x: %u\n"
+             " y: %u\n"
+             " z: %i\n",
+             ctrlsrc->x,
+             ctrlsrc->y,
+             ctrlsrc->z);
+#endif
+
+      /* Add x bytes from oldfile to x bytes from the diff block */
+
+      if (fbuffer + ctrlsrc->x > fbufend ||
+          diffsrc + ctrlsrc->x > diffend) {
+        rv = BSP_ERROR_CORRUPT;
+        goto end;
+      }
+      for (PRUint32 i = 0; i < ctrlsrc->x; ++i) {
+        diffsrc[i] += fbuffer[i];
+      }
+      if ((PRUint32) write(filefd, diffsrc, ctrlsrc->x) != ctrlsrc->x) {
+        rv = BSP_ERROR_IO;
+        goto end;
+      }
+      fbuffer += ctrlsrc->x;
+      diffsrc += ctrlsrc->x;
+
+      /* Copy y bytes from the extra block */
+
+      if (extrasrc + ctrlsrc->y > extraend) {
+        rv = BSP_ERROR_CORRUPT;
+        goto end;
+      }
+      if ((PRUint32) write(filefd, extrasrc, ctrlsrc->y) != ctrlsrc->y) {
+        rv = BSP_ERROR_IO;
+        goto end;
+      }
+      extrasrc += ctrlsrc->y;
+
+      /* "seek" forwards in oldfile by z bytes */
+
+      if (fbuffer + ctrlsrc->z > fbufend) {
+        rv = BSP_ERROR_CORRUPT;
+        goto end;
+      }
+      fbuffer += ctrlsrc->z;
+
+      /* and on to the next control block */
+
+      ++ctrlsrc;
+    } while (ctrlsrc < ctrlend);
+  }
+
+end:
+  free(buf);
+  return rv;
+}
Index: toolkit/mozapps/update/src/updater/bspatch.h
===================================================================
RCS file: toolkit/mozapps/update/src/updater/bspatch.h
diff -N toolkit/mozapps/update/src/updater/bspatch.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/mozapps/update/src/updater/bspatch.h	7 Jun 2005 07:51:25 -0000	1.1.2.4
@@ -0,0 +1,99 @@
+/*-
+ * Copyright 2003,2004 Colin Percival
+ * All rights reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted providing that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Changelog:
+ * 2005-04-26 - Define the header as a C structure, add a CRC32 checksum to
+ *              the header, and make all the types 32-bit.
+ *                --Benjamin Smedberg <benjamin@smedbergs.us>
+ */
+
+#ifndef bspatch_h__
+#define bspatch_h__
+
+// We use the NSPR types, but we don't link with NSPR
+#include "prtypes.h"
+
+/* return values for bspatch */
+#define BSP_OK             0
+#define BSP_ERROR_IO      -1
+#define BSP_ERROR_CORRUPT -2
+#define BSP_ERROR_NOMEM   -3
+
+typedef struct MBSPatchHeader_ {
+  /* "MBDIFF10" */
+  char tag[8];
+  
+  /* Length of the file to be patched */
+  PRUint32 slen;
+
+  /* CRC32 of the file to be patched */
+  PRUint32 scrc32;
+
+  /* Length of the result file */
+  PRUint32 dlen;
+
+  /* Length of the control block in bytes */
+  PRUint32 cblen;
+
+  /* Length of the diff block in bytes */
+  PRUint32 difflen;
+
+  /* Length of the extra block in bytes */
+  PRUint32 extralen;
+
+  /* Control block (MBSPatchTriple[]) */
+  /* Diff block (binary data) */
+  /* Extra block (binary data) */
+} MBSPatchHeader;
+
+/**
+ * Read the header of a patch file into the MBSPatchHeader structure.
+ *
+ * @param fd Must have been opened for reading, and be at the beginning
+ *           of the file.
+ */
+int MBS_ReadHeader(int fd, MBSPatchHeader *header);
+
+/**
+ * Apply a patch. This method does not validate the checksum of the original
+ * file: client code should validate the checksum before calling this method.
+ *
+ * @param patchfd Must have been processed by MBS_ReadHeader
+ * @param fbuffer The original file read into a memory buffer of length
+ *                header->slen.
+ * @param filefd  Must have been opened for writing. Should be truncated
+ *                to header->dlen if it is an existing file. The offset
+ *                should be at the beginning of the file.
+ */
+int MBS_ApplyPatch(const MBSPatchHeader *header, int patchfd,
+                   unsigned char *fbuffer, int filefd);
+
+typedef struct MBSPatchTriple_ {
+  PRUint32 x; /* add x bytes from oldfile to x bytes from the diff block */
+  PRUint32 y; /* copy y bytes from the extra block */
+  PRInt32  z; /* seek forwards in oldfile by z bytes */
+} MBSPatchTriple;
+
+#endif  // bspatch_h__
Index: toolkit/mozapps/update/src/updater/errors.h
===================================================================
RCS file: toolkit/mozapps/update/src/updater/errors.h
diff -N toolkit/mozapps/update/src/updater/errors.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/mozapps/update/src/updater/errors.h	2 Jun 2005 00:04:15 -0000	1.1.2.3
@@ -0,0 +1,52 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Darin Fisher <darin@meer.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef Errors_h__
+#define Errors_h__
+
+#define OK 0
+#define MEM_ERROR 1
+#define IO_ERROR 2
+#define USAGE_ERROR 3
+#define CRC_ERROR 4
+#define PARSE_ERROR 5
+#define SOURCE_ERROR 6
+#define TARGET_ERROR 7
+#define UNEXPECTED_ERROR 8
+
+#endif  // Errors_h__
Index: toolkit/mozapps/update/src/updater/progressui.h
===================================================================
RCS file: toolkit/mozapps/update/src/updater/progressui.h
diff -N toolkit/mozapps/update/src/updater/progressui.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/mozapps/update/src/updater/progressui.h	4 May 2005 20:58:09 -0000	1.1.2.1
@@ -0,0 +1,54 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Darin Fisher <darin@meer.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef PROGRESSUI_H__
+#define PROGRESSUI_H__
+
+// Called to perform any initialization of the widget toolkit
+int InitProgressUI(int *argc, char ***argv);
+
+// Called on the main thread at startup
+int ShowProgressUI();
+
+// May be called from any thread
+void QuitProgressUI();
+
+// May be called from any thread: progress is a number between 0 and 100
+void UpdateProgressUI(float progress);
+
+#endif  // PROGRESSUI_H__
Index: toolkit/mozapps/update/src/updater/progressui_gtk.cpp
===================================================================
RCS file: toolkit/mozapps/update/src/updater/progressui_gtk.cpp
diff -N toolkit/mozapps/update/src/updater/progressui_gtk.cpp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/mozapps/update/src/updater/progressui_gtk.cpp	2 Jun 2005 22:37:28 -0000	1.1.2.4
@@ -0,0 +1,191 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Darin Fisher <darin@meer.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include <stdio.h>
+#include <gtk/gtk.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+
+#define TIMER_INTERVAL 100
+#define MAX_TEXT_LEN 200
+
+static float    sProgressVal;  // between 0 and 100
+static gboolean sQuit = FALSE;
+static guint    sTimerID;
+
+static GtkWidget *sWin;
+static GtkWidget *sLabel;
+static GtkWidget *sProgressBar;
+
+static const char *sProgramPath;
+
+// stack based FILE wrapper to ensure that fclose is called.
+class AutoFILE {
+public:
+  AutoFILE(FILE *fp) : fp_(fp) {}
+  ~AutoFILE() { if (fp_) fclose(fp_); }
+  operator FILE *() { return fp_; }
+private:
+  FILE *fp_;
+};
+
+// very basic parser for updater.ini
+static gboolean
+ReadStrings(char title[MAX_TEXT_LEN], char info[MAX_TEXT_LEN])
+{
+  char path[PATH_MAX];
+  snprintf(path, sizeof(path), "%s.ini", sProgramPath);
+
+  AutoFILE fp = fopen(path, "r");
+  if (!fp)
+    return FALSE;
+
+  if (!fgets(title, MAX_TEXT_LEN, fp))
+    return FALSE;
+  if (!fgets(title, MAX_TEXT_LEN, fp))
+    return FALSE;
+  if (!fgets(info, MAX_TEXT_LEN, fp))
+    return FALSE;
+
+  // trim trailing newline character and leading 'key='
+
+  char *strings[] = {
+    title, info, NULL
+  };
+  for (char **p = strings; *p; ++p) {
+    int len = strlen(*p);
+    if (len)
+      (*p)[len - 1] = '\0';
+
+    char *eq = strchr(*p, '=');
+    if (!eq)
+      return FALSE;
+    memmove(*p, eq + 1, len - (eq - *p + 1));
+  }
+
+  return TRUE;
+}
+
+static gboolean
+UpdateDialog(gpointer data)
+{
+  if (sQuit)
+  {
+    gtk_widget_hide(sWin);
+    gtk_main_quit();
+  }
+
+  float progress = sProgressVal;
+
+  gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(sProgressBar),
+                                progress / 100.0);
+
+  return TRUE;
+}
+
+static void
+DoNothing()
+{
+}
+
+int
+InitProgressUI(int *pargc, char ***pargv)
+{
+  sProgramPath = (*pargv)[0];
+
+  gtk_init(pargc, pargv);
+  return 0;
+}
+
+int
+ShowProgressUI()
+{
+  // Only show the Progress UI if the process is taking significant time.
+  // Here we measure significant time as taking more than one second.
+
+  usleep(500000);
+
+  if (sQuit || sProgressVal > 50.0f)
+    return 0;
+
+  char titleText[MAX_TEXT_LEN], infoText[MAX_TEXT_LEN]; 
+  if (!ReadStrings(titleText, infoText))
+    return -1;
+  
+  sWin = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+  if (!sWin)
+    return -1;
+  gtk_window_set_title(GTK_WINDOW(sWin), titleText);
+  gtk_window_set_type_hint(GTK_WINDOW(sWin), GDK_WINDOW_TYPE_HINT_DIALOG);
+  gtk_window_set_position(GTK_WINDOW(sWin), GTK_WIN_POS_CENTER_ALWAYS);
+  gtk_window_set_resizable(GTK_WINDOW(sWin), FALSE);
+  gtk_window_set_decorated(GTK_WINDOW(sWin), FALSE);
+  gtk_signal_connect(GTK_OBJECT(sWin), "delete", DoNothing, NULL);
+
+  GtkWidget *vbox = gtk_vbox_new(TRUE, 6);
+  sLabel = gtk_label_new(infoText);
+  gtk_misc_set_alignment(GTK_MISC(sLabel), 0.0f, 0.0f);
+  sProgressBar = gtk_progress_bar_new();
+
+  gtk_box_pack_start(GTK_BOX(vbox), sLabel, FALSE, FALSE, 0);
+  gtk_box_pack_start(GTK_BOX(vbox), sProgressBar, TRUE, TRUE, 0);
+
+  sTimerID = g_timeout_add(TIMER_INTERVAL, UpdateDialog, NULL);
+
+  gtk_container_set_border_width(GTK_CONTAINER(sWin), 10);
+  gtk_container_add(GTK_CONTAINER(sWin), vbox);
+  gtk_widget_show_all(sWin);
+
+  gtk_main();
+  return 0;
+}
+
+// Called on a background thread
+void
+QuitProgressUI()
+{
+  sQuit = TRUE;
+}
+
+// Called on a background thread
+void
+UpdateProgressUI(float progress)
+{
+  sProgressVal = progress;  // 32-bit writes are atomic
+}
Index: toolkit/mozapps/update/src/updater/progressui_null.cpp
===================================================================
RCS file: toolkit/mozapps/update/src/updater/progressui_null.cpp
diff -N toolkit/mozapps/update/src/updater/progressui_null.cpp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/mozapps/update/src/updater/progressui_null.cpp	19 May 2005 17:43:58 -0000	1.1.2.1
@@ -0,0 +1,57 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Darin Fisher <darin@meer.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "progressui.h"
+
+int InitProgressUI(int *argc, char ***argv)
+{
+  return 0;
+}
+
+int ShowProgressUI()
+{
+  return 0;
+}
+
+void QuitProgressUI()
+{
+}
+
+void UpdateProgressUI(float progress)
+{
+}
Index: toolkit/mozapps/update/src/updater/progressui_win.cpp
===================================================================
RCS file: toolkit/mozapps/update/src/updater/progressui_win.cpp
diff -N toolkit/mozapps/update/src/updater/progressui_win.cpp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/mozapps/update/src/updater/progressui_win.cpp	4 May 2005 20:58:09 -0000	1.1.2.1
@@ -0,0 +1,196 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Darin Fisher <darin@meer.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include <stdio.h>
+#include <windows.h>
+#include <commctrl.h>
+#include <process.h>
+#include "resource.h"
+
+#define TIMER_ID 1
+#define TIMER_INTERVAL 100
+
+static float sProgress;  // between 0 and 100
+static BOOL  sQuit = FALSE;
+
+static BOOL
+GetStringsFile(char filename[MAX_PATH])
+{
+  if (!GetModuleFileName(NULL, filename, MAX_PATH))
+    return FALSE;
+
+  char *dot = strrchr(filename, '.');
+  if (!dot || stricmp(dot + 1, "exe"))
+    return FALSE;
+
+  strcpy(dot + 1, "ini");
+  return TRUE;
+}
+
+static void
+UpdateDialog(HWND hDlg)
+{
+  int pos = int(sProgress + 0.5f);
+  SendMessage(GetDlgItem(hDlg, IDC_PROGRESS), PBM_SETPOS, pos, 0L);
+}
+
+// The code in this function is from MSDN:
+// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/windowing/dialogboxes/usingdialogboxes.asp
+static void
+CenterDialog(HWND hDlg)
+{
+  RECT rc, rcOwner, rcDlg;
+
+  // Get the owner window and dialog box rectangles. 
+  HWND desktop = GetDesktopWindow();
+
+  GetWindowRect(desktop, &rcOwner); 
+  GetWindowRect(hDlg, &rcDlg); 
+  CopyRect(&rc, &rcOwner); 
+
+  // Offset the owner and dialog box rectangles so that 
+  // right and bottom values represent the width and 
+  // height, and then offset the owner again to discard 
+  // space taken up by the dialog box. 
+
+  OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top); 
+  OffsetRect(&rc, -rc.left, -rc.top); 
+  OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom); 
+
+  // The new position is the sum of half the remaining 
+  // space and the owner's original position. 
+
+  SetWindowPos(hDlg, 
+               HWND_TOP, 
+               rcOwner.left + (rc.right / 2), 
+               rcOwner.top + (rc.bottom / 2), 
+               0, 0,          // ignores size arguments 
+               SWP_NOSIZE); 
+}
+
+static void
+SetItemText(HWND hwnd, const char *key, const char *ini)
+{
+  char text[512];
+  if (!GetPrivateProfileString("Strings", key, NULL, text, sizeof(text), ini))
+    return;
+  SetWindowText(hwnd, text);
+}
+
+static void
+InitDialog(HWND hDlg)
+{
+  char filename[MAX_PATH];
+  if (!GetStringsFile(filename))
+    return;
+
+  SetItemText(hDlg, "Title", filename);
+  SetItemText(GetDlgItem(hDlg, IDC_INFO), "Info", filename);
+
+  SendMessage(GetDlgItem(hDlg, IDC_PROGRESS), PBM_SETRANGE, 0,
+              MAKELPARAM(0, 100));
+
+  CenterDialog(hDlg);  // make dialog appear in the center of the screen
+
+  SetTimer(hDlg, TIMER_ID, TIMER_INTERVAL, NULL);
+}
+
+// Message handler for about box.
+static LRESULT CALLBACK
+DialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
+{
+  switch (message)
+  {
+  case WM_INITDIALOG:
+    InitDialog(hDlg);
+    return TRUE;
+
+  case WM_TIMER:
+    if (sQuit)
+      EndDialog(hDlg, 0);
+    else
+      UpdateDialog(hDlg);
+    return TRUE;
+
+  case WM_COMMAND:
+    return TRUE;
+  }
+  return FALSE;
+}
+
+int
+InitProgressUI(int *argc, char ***argv)
+{
+  return 0;
+}
+
+int
+ShowProgressUI()
+{
+  // Only show the Progress UI if the process is taking significant time.
+  // Here we measure significant time as taking more than one second.
+
+  Sleep(500);
+
+  if (sQuit || sProgress > 50.0f)
+    return 0;
+
+  INITCOMMONCONTROLSEX icc = {
+    sizeof(INITCOMMONCONTROLSEX),
+    ICC_PROGRESS_CLASS
+  };
+  InitCommonControlsEx(&icc);
+
+  DialogBox(GetModuleHandle(NULL),
+            MAKEINTRESOURCE(IDD_DIALOG), NULL,
+            (DLGPROC) DialogProc);
+
+  return 0;
+}
+
+void
+QuitProgressUI()
+{
+  sQuit = TRUE;
+}
+
+void
+UpdateProgressUI(float progress)
+{
+  sProgress = progress;  // 32-bit writes are atomic
+}
Index: toolkit/mozapps/update/src/updater/resource.h
===================================================================
RCS file: toolkit/mozapps/update/src/updater/resource.h
diff -N toolkit/mozapps/update/src/updater/resource.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/mozapps/update/src/updater/resource.h	4 May 2005 20:58:09 -0000	1.1.2.1
@@ -0,0 +1,18 @@
+//{{NO_DEPENDENCIES}}
+// Microsoft Visual C++ generated include file.
+// Used by updater.rc
+//
+#define IDD_DIALOG                      101
+#define IDC_PROGRESS                    1000
+#define IDC_INFO                        1002
+
+// Next default values for new objects
+// 
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NEXT_RESOURCE_VALUE        102
+#define _APS_NEXT_COMMAND_VALUE         40001
+#define _APS_NEXT_CONTROL_VALUE         1003
+#define _APS_NEXT_SYMED_VALUE           101
+#endif
+#endif
Index: toolkit/mozapps/update/src/updater/updater.cpp
===================================================================
RCS file: toolkit/mozapps/update/src/updater/updater.cpp
diff -N toolkit/mozapps/update/src/updater/updater.cpp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/mozapps/update/src/updater/updater.cpp	7 Jun 2005 07:51:25 -0000	1.1.2.18
@@ -0,0 +1,1038 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Application Update.
+ *
+ * The Initial Developer of the Original Code is
+ * Benjamin Smedberg <benjamin@smedbergs.us>
+ *
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Darin Fisher <darin@meer.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/**
+ *  update.manifest
+ *  ---------------
+ *
+ *  contents = 1*( line )
+ *  line     = method LWS *( param LWS ) CRLF
+ *  method   = "add" | "remove" | "patch"
+ *  CRLF     = "\r\n"
+ *  LWS      = 1*( " " | "\t" )
+ */
+
+#include "bspatch.h"
+#include "progressui.h"
+#include "archivereader.h"
+#include "errors.h"
+#include "bzlib.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <limits.h>
+
+#if defined(XP_UNIX)
+# include <sys/wait.h>
+# include <unistd.h>
+#elif defined(XP_WIN)
+# include <windows.h>
+# include <direct.h>
+# include <io.h>
+# define F_OK 00
+# define W_OK 02
+# define R_OK 04
+# define access _access
+# define snprintf _snprintf
+# define fchmod(a,b)
+#endif
+
+#ifndef _O_BINARY
+# define _O_BINARY 0
+#endif
+
+#ifndef NULL
+# define NULL (0)
+#endif
+
+#ifndef SSIZE_MAX
+# define SSIZE_MAX LONG_MAX
+#endif
+
+#ifndef MAXPATHLEN
+# ifdef MAX_PATH
+#  define MAXPATHLEN MAX_PATH
+# elif defined(_MAX_PATH)
+#  define MAXPATHLEN _MAX_PATH
+# elif defined(CCHMAXPATH)
+#  define MAXPATHLEN CCHMAXPATH
+# else
+#  define MAXPATHLEN 1024
+# endif
+#endif
+
+//-----------------------------------------------------------------------------
+
+// This variable lives in libbz2.  It's declared in bzlib_private.h, so we just
+// declare it here to avoid including that entire header file.
+extern "C" unsigned int BZ2_crc32Table[256];
+
+static unsigned int
+crc32(const unsigned char *buf, unsigned int len)
+{
+  unsigned int crc = 0xffffffffL;
+
+  const unsigned char *end = buf + len;
+  for (; buf != end; ++buf)
+    crc = (crc << 8) ^ BZ2_crc32Table[(crc >> 24) ^ *buf];
+
+  crc = ~crc;
+  return crc;
+}
+
+//-----------------------------------------------------------------------------
+
+typedef void (* ThreadFunc)(void *param);
+
+#ifdef XP_WIN
+#include <process.h>
+
+class Thread
+{
+public:
+  int Run(ThreadFunc func, void *param)
+  {
+    mThreadFunc = func;
+    mThreadParam = param;
+
+    unsigned threadID;
+    mThread = (HANDLE) _beginthreadex(NULL, 0, ThreadMain, this, 0, &threadID);
+    
+    return mThread ? 0 : -1;
+  }
+  int Join()
+  {
+    WaitForSingleObject(mThread, INFINITE);
+    CloseHandle(mThread);
+    return 0;
+  }
+private:
+  static unsigned __stdcall ThreadMain(void *p)
+  {
+    Thread *self = (Thread *) p;
+    self->mThreadFunc(self->mThreadParam);
+    return 0;
+  }
+  HANDLE     mThread;
+  ThreadFunc mThreadFunc;
+  void      *mThreadParam;
+};
+
+#else
+#include <pthread.h>
+
+class Thread
+{
+public:
+  int Run(ThreadFunc func, void *param)
+  {
+    return pthread_create(&thr, NULL, (void* (*)(void *)) func, param);
+  }
+  int Join()
+  {
+    void *result;
+    return pthread_join(thr, &result);
+  }
+private:
+  pthread_t thr;
+};
+
+#endif
+
+//-----------------------------------------------------------------------------
+
+static char* gSourcePath;
+static ArchiveReader gArchiveReader;
+
+static const char kWhitespace[] = " \t";
+static const char kNL[] = "\r\n";
+static const char kQuote[] = "\"";
+
+static inline PRUint32
+mmin(PRUint32 a, PRUint32 b)
+{
+  return (a > b) ? b : a;
+}
+
+static char*
+mstrtok(const char *delims, char **str)
+{
+  if (!*str || !**str)
+    return NULL;
+
+  // skip leading "whitespace"
+  char *ret = *str;
+  const char *d;
+  do {
+    for (d = delims; *d != '\0'; ++d) {
+      if (*ret == *d) {
+        ++ret;
+        break;
+      }
+    }
+  } while (*d);
+
+  if (!*ret) {
+    *str = ret;
+    return NULL;
+  }
+
+  char *i = ret;
+  do {
+    for (d = delims; *d != '\0'; ++d) {
+      if (*i == *d) {
+        *i = '\0';
+        *str = ++i;
+        return ret;
+      }
+    }
+    ++i;
+  } while (*i);
+
+  *str = NULL;
+  return ret;
+}
+
+// Ensure that the directory containing this file exists.
+static int ensure_parent_dir(const char *path)
+{
+  char *slash = strrchr(path, '/');
+  if (slash)
+  {
+    *slash = '\0';
+    ensure_parent_dir(path);
+#ifdef XP_WIN
+    _mkdir(path);
+#else
+    mkdir(path, 0755);
+#endif
+    *slash = '/';
+  }
+  return OK;
+}
+
+static int copy_file(const char *spath, const char *dpath)
+{
+  int rv = ensure_parent_dir(dpath);
+  if (rv)
+    return rv;
+
+  struct stat ss;
+
+  int sfd = open(spath, O_RDONLY | _O_BINARY);
+  if (sfd < 0 || fstat(sfd, &ss))
+    return IO_ERROR;
+
+  int dfd = open(dpath, O_WRONLY | O_TRUNC | O_CREAT | _O_BINARY, ss.st_mode);
+  if (dfd < 0) {
+    close(sfd);
+    return IO_ERROR;
+  }
+
+  char buf[BUFSIZ];
+  int sc;
+  while ((sc = read(sfd, buf, sizeof(buf))) > 0) {
+    int dc;
+    char *bp = buf;
+    while ((dc = write(dfd, bp, (unsigned int) sc)) > 0) {
+      if ((sc -= dc) == 0)
+        break;
+      bp += dc;
+    }
+    if (dc < 0) {
+      rv = IO_ERROR;
+      goto end;
+    }
+  }
+  if (sc < 0) {
+    rv = IO_ERROR;
+    goto end;
+  }
+
+end:
+  close(sfd);
+  close(dfd);
+
+  return rv;
+}
+
+//-----------------------------------------------------------------------------
+// LOGGING
+
+static FILE *gLogFP = NULL;
+
+static void LogInit()
+{
+  if (gLogFP)
+    return;
+
+  char logFile[MAXPATHLEN];
+  snprintf(logFile, MAXPATHLEN, "%s/update.log", gSourcePath);
+
+  gLogFP = fopen(logFile, "w");
+}
+
+static void LogFinish()
+{
+  if (!gLogFP)
+    return;
+
+  fclose(gLogFP);
+  gLogFP = NULL;
+}
+
+static void LogPrintf(const char *fmt, ... )
+{
+  if (!gLogFP)
+    return;
+
+  va_list ap;
+  va_start(ap, fmt);
+  vfprintf(gLogFP, fmt, ap);
+  va_end(ap);
+}
+
+#define LOG(args) LogPrintf args
+
+//-----------------------------------------------------------------------------
+
+#define BACKUP_EXT ".moz-backup"
+
+// Create a backup copy of the specified file alongside it.
+static int backup_create(const char *path)
+{
+  char backup[MAXPATHLEN];
+  snprintf(backup, sizeof(backup), "%s" BACKUP_EXT, path);
+
+  int rv = copy_file(path, backup);
+  if (rv)
+    return IO_ERROR;
+
+  return OK;
+}
+
+// Copy the backup copy of the specified file back overtop
+// the specified file.
+// XXX should be a file move instead
+static int backup_restore(const char *path)
+{
+  char backup[MAXPATHLEN];
+  snprintf(backup, sizeof(backup), "%s" BACKUP_EXT, path);
+
+  int rv = copy_file(backup, path);
+  if (rv)
+    return IO_ERROR;
+
+  rv = remove(backup);
+  if (rv)
+    return IO_ERROR;
+
+  return OK;
+}
+
+// Discard the backup copy of the specified file.
+static int backup_discard(const char *path)
+{
+  char backup[MAXPATHLEN];
+  snprintf(backup, sizeof(backup), "%s" BACKUP_EXT, path);
+
+  int rv = remove(backup);
+  if (rv)
+    return IO_ERROR;
+
+  return OK;
+}
+
+// Helper function for post-processing a temporary backup.
+static void backup_finish(const char *path, int status)
+{
+  if (status == OK)
+    backup_discard(path);
+  else
+    backup_restore(path);
+}
+
+//-----------------------------------------------------------------------------
+
+static int DoUpdate();
+
+static const int ACTION_DESCRIPTION_BUFSIZE = 256;
+
+class Action
+{
+public:
+  Action() : mNext(NULL) { }
+  virtual ~Action() { }
+
+  virtual int Parse(char *line) = 0;
+
+  // Do any preprocessing to ensure that the action can be performed.  Execute
+  // will be called if this Action and all others return OK from this method.
+  virtual int Prepare() = 0;
+
+  // Perform the operation.  Return OK to indicate success.  After all actions
+  // have been executed, Finish will be called.  A requirement of Execute is
+  // that it's operation be reversable from Finish.
+  virtual int Execute() = 0;
+  
+  // Finish is called after execution of all actions.  If status is OK, then
+  // all actions were successfully executed.  Otherwise, some action failed.
+  virtual void Finish(int status) = 0;
+
+private:
+  Action* mNext;
+
+  friend class ActionList;
+};
+
+class RemoveFile : public Action
+{
+public:
+  RemoveFile() : mFile(NULL) { }
+
+  int Parse(char *line);
+  int Prepare();
+  int Execute();
+  void Finish(int status);
+
+private:
+  const char* mFile;
+};
+
+int
+RemoveFile::Parse(char *line)
+{
+  // format "<deadfile>"
+
+  mFile = mstrtok(kQuote, &line);
+  if (!mFile)
+    return PARSE_ERROR;
+
+  return OK;
+}
+
+int
+RemoveFile::Prepare()
+{
+  LOG(("PREPARE REMOVE %s\n", mFile));
+
+  // We expect the file to exist if we are to remove it.
+  int rv = access(mFile, F_OK);
+  if (rv)
+    return IO_ERROR;
+
+  char *slash = strrchr(mFile, '/');
+  if (slash) {
+    *slash = '\0';
+    rv = access(mFile, W_OK);
+    *slash = '/';
+  } else {
+    rv = access(".", W_OK);
+  }
+
+  if (rv)
+    return IO_ERROR;
+
+  return OK;
+}
+
+int
+RemoveFile::Execute()
+{
+  LOG(("EXECUTE REMOVE %s\n", mFile));
+
+  // save a complete copy of the old file, and then remove the
+  // old file.  we'll clean up the copy in Finish.
+
+  int rv = backup_create(mFile);
+  if (rv)
+    return rv;
+
+  rv = remove(mFile);
+  if (rv)
+    return IO_ERROR;
+
+  return OK;
+}
+
+void
+RemoveFile::Finish(int status)
+{
+  LOG(("FINISH REMOVE %s\n", mFile));
+
+  backup_finish(mFile, status);
+}
+
+class AddFile : public Action
+{
+public:
+  AddFile() : mFile(NULL) { }
+
+  int Parse(char *line);
+  int Prepare(); // check that the source file exists
+  int Execute();
+  void Finish(int status);
+
+private:
+  const char *mFile;
+};
+
+int
+AddFile::Parse(char *line)
+{
+  // format "<newfile>"
+
+  mFile = mstrtok(kQuote, &line);
+  if (!mFile)
+    return PARSE_ERROR;
+
+  return OK;
+}
+
+int
+AddFile::Prepare()
+{
+  LOG(("PREPARE ADD %s\n", mFile));
+
+  return OK;
+}
+
+int
+AddFile::Execute()
+{
+  LOG(("EXECUTE ADD %s\n", mFile));
+
+  int rv;
+
+  // First make sure that we can actually get rid of any existing file.
+  if (access(mFile, F_OK) == 0)
+  {
+    rv = backup_create(mFile);
+    if (rv)
+      return rv;
+
+    rv = remove(mFile);
+    if (rv)
+      return IO_ERROR;
+  }
+  else
+  {
+    rv = ensure_parent_dir(mFile);
+    if (rv)
+      return rv;
+  }
+    
+  return gArchiveReader.ExtractFile(mFile, mFile);
+}
+
+void
+AddFile::Finish(int status)
+{
+  LOG(("FINISH ADD %s\n", mFile));
+
+  backup_finish(mFile, status);
+}
+
+class PatchFile : public Action
+{
+public:
+  PatchFile() : mPatchIndex(-1), pfd(-1), buf(NULL) { }
+  ~PatchFile();
+
+  int Parse(char *line);
+  int Prepare(); // check for the patch file and for checksums
+  int Execute();
+  void Finish(int status);
+
+private:
+  int LoadSourceFile(int ofd);
+
+  static int sPatchIndex;
+
+  const char *mPatchFile;
+  const char *mFile;
+  int mPatchIndex;
+  MBSPatchHeader header;
+  int pfd;
+  unsigned char *buf;
+};
+
+int PatchFile::sPatchIndex = 0;
+
+PatchFile::~PatchFile()
+{
+  if (pfd >= 0)
+    close(pfd);
+
+  // delete the temporary patch file
+  char spath[MAXPATHLEN];
+  snprintf(spath, MAXPATHLEN, "%s/%d.patch", gSourcePath, mPatchIndex);
+  remove(spath);
+
+  free(buf);
+}
+
+int
+PatchFile::LoadSourceFile(int ofd)
+{
+  struct stat os;
+  int rv = fstat(ofd, &os);
+  if (rv)
+    return IO_ERROR;
+
+  if (PRUint32(os.st_size) != header.slen)
+    return BSP_ERROR_CORRUPT;
+
+  buf = (unsigned char*) malloc(header.slen);
+  if (!buf)
+    return BSP_ERROR_NOMEM;
+
+  int r = header.slen;
+  unsigned char *rb = buf;
+  while (r) {
+    int c = read(ofd, rb, mmin(BUFSIZ,r));
+    if (c < 0)
+      return IO_ERROR;
+
+    r -= c;
+    rb += c;
+
+    if (c == 0 && r)
+      return BSP_ERROR_CORRUPT;
+  }
+
+  // Verify that the contents of the source file correspond to what we expect.
+
+  unsigned int crc = crc32(buf, header.slen);
+
+  if (crc != header.scrc32) {
+    LOG(("CRC check failed\n"));
+    return BSP_ERROR_CORRUPT;
+  }
+  
+  return OK;
+}
+
+int
+PatchFile::Parse(char *line)
+{
+  // format "<patchfile>" "<filetopatch>"
+
+  mPatchFile = mstrtok(kQuote, &line);
+  if (!mPatchFile)
+    return PARSE_ERROR;
+
+  // consume whitespace between args
+  char *q = mstrtok(kQuote, &line);
+  if (!q)
+    return PARSE_ERROR;
+
+  mFile = mstrtok(kQuote, &line);
+  if (!mFile)
+    return PARSE_ERROR;
+
+  return OK;
+}
+
+int
+PatchFile::Prepare()
+{
+  LOG(("PREPARE PATCH %s\n", mFile));
+
+  // extract the patch to a temporary file
+  mPatchIndex = sPatchIndex++;
+
+  char spath[MAXPATHLEN];
+  snprintf(spath, MAXPATHLEN, "%s/%d.patch", gSourcePath, mPatchIndex);
+
+  remove(spath);
+
+  int rv = gArchiveReader.ExtractFile(mPatchFile, spath);
+  if (rv)
+    return rv;
+
+  // XXXdarin from here down should be moved into the Execute command.
+  //          no need to open all of the patch files and read all of 
+  //          the source files before applying any patches.
+
+  pfd = open(spath, O_RDONLY | _O_BINARY);
+  if (pfd < 0)
+    return IO_ERROR;
+
+  rv = MBS_ReadHeader(pfd, &header);
+  if (rv)
+    return rv;
+
+  int ofd = open(mFile, O_RDONLY | _O_BINARY);
+  if (ofd < 0)
+    return IO_ERROR;
+
+  rv = LoadSourceFile(ofd);
+  if (rv)
+    LOG(("LoadSourceFile failed\n"));
+  close(ofd);
+
+  return rv;
+}
+
+int
+PatchFile::Execute()
+{
+  LOG(("EXECUTE PATCH %s\n", mFile));
+
+  // Create backup copy of the destination file before proceeding.
+
+  struct stat ss;
+  if (stat(mFile, &ss))
+    return IO_ERROR;
+
+  int rv = backup_create(mFile);
+  if (rv)
+    return rv;
+
+  rv = remove(mFile);
+  if (rv)
+    return IO_ERROR;
+
+  int ofd = open(mFile, O_WRONLY | O_TRUNC | O_CREAT | _O_BINARY, ss.st_mode);
+  if (ofd < 0)
+    return IO_ERROR;
+
+  return MBS_ApplyPatch(&header, pfd, buf, ofd);
+}
+
+void
+PatchFile::Finish(int status)
+{
+  LOG(("FINISH PATCH %s\n", mFile));
+
+  backup_finish(mFile, status);
+}
+
+static int
+LaunchCallbackApp(const char *cmdLine)
+{
+  // Someone will probably tell me that using 'system' is a bad idea, but for
+  // now it seems like it fits the bill.  It saves us from having to parse the
+  // command line in order to call execv, and it nicely blocks this process
+  // until the command line is finished executing.
+
+  return system(cmdLine);
+}
+
+static void
+WriteStatusFile(int status)
+{
+  // This is how we communicate our completion status to the main application.
+
+  char filename[MAXPATHLEN];
+  snprintf(filename, MAXPATHLEN, "%s/update.status", gSourcePath);
+
+  int fd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | _O_BINARY, 0644);
+  if (fd < 0)
+    return;
+
+  const char *text = (status == OK) ? "succeeded\n" : "failed\n";
+  write(fd, text, strlen(text));
+  close(fd);
+}
+
+static void
+UpdateThreadFunc(void *param)
+{
+  // open ZIP archive and process...
+
+  char dataFile[MAXPATHLEN];
+  snprintf(dataFile, MAXPATHLEN, "%s/update.mar", gSourcePath);
+
+  int rv = gArchiveReader.Open(dataFile);
+  if (rv == OK) {
+    rv = DoUpdate();
+    gArchiveReader.Close();
+  }
+
+  if (rv)
+    LOG(("failed: %d\n", rv));
+  else
+    LOG(("succeeded\n"));
+  WriteStatusFile(rv);
+
+  LOG(("calling QuitProgressUI\n"));
+  QuitProgressUI();
+}
+
+int main(int argc, char **argv)
+{
+  InitProgressUI(&argc, &argv);
+
+  if (argc < 3) {
+    fprintf(stderr, "Usage: updater <dir-path> <callback> [parent-pid]\n");
+    return 1;
+  }
+
+  if (argc > 3) {
+    int pid = atoi(argv[3]);
+    if (!pid)
+      return 1;
+#ifdef XP_WIN
+    HANDLE parent = OpenProcess(SYNCHRONIZE, FALSE, (DWORD) pid);
+    // May return NULL if the parent process has already gone away.  Otherwise,
+    // wait for the parent process to exit before starting the update.
+    if (parent) {
+      DWORD result = WaitForSingleObject(parent, 5000);
+      CloseHandle(parent);
+      if (result != WAIT_OBJECT_0)
+        return 1;
+      // The process may be signaled before it releases the executable image.
+      // This is a terrible hack, but it'll have to do for now :-(
+      Sleep(50);
+    }
+#else
+    int status;
+    waitpid(pid, &status, 0);
+#endif
+  }
+
+  gSourcePath = argv[1];
+
+  LogInit();
+
+  // Run update process on a background thread.  ShowProgressUI may return
+  // before QuitProgressUI has been called, so wait for UpdateThreadFunc to
+  // terminate.
+  Thread t;
+  if (t.Run(UpdateThreadFunc, NULL) == 0)
+    ShowProgressUI();
+  t.Join();
+
+  LogFinish();
+
+  return LaunchCallbackApp(argv[2]);
+}
+
+class ActionList
+{
+public:
+  ActionList() : mFirst(NULL), mLast(NULL), mCount(0) { }
+  ~ActionList();
+
+  void Append(Action* action);
+  int Prepare();
+  int Execute();
+  void Finish(int status);
+
+private:
+  Action *mFirst;
+  Action *mLast;
+  int     mCount;
+};
+
+ActionList::~ActionList()
+{
+  Action* a = mFirst;
+  while (a) {
+    Action *b = a;
+    a = a->mNext;
+    delete b;
+  }
+}
+
+void
+ActionList::Append(Action *action)
+{
+  if (mLast)
+    mLast->mNext = action;
+  else
+    mFirst = action;
+
+  mLast = action;
+  mCount++;
+}
+
+int
+ActionList::Prepare()
+{
+  Action *a = mFirst;
+  while (a) {
+    int rv = a->Prepare();
+    if (rv)
+      return rv;
+
+    a = a->mNext;
+  }
+
+  UpdateProgressUI(1.0f);
+
+  return OK;
+}
+
+int
+ActionList::Execute()
+{
+  int i = 0;
+  float divisor = mCount / 98.0f;
+
+  Action *a = mFirst;
+  while (a) {
+    UpdateProgressUI(1.0f + float(i++) / divisor);
+
+    int rv = a->Execute();
+    if (rv)
+    {
+      LOG(("### execution failed\n"));
+      return rv;
+    }
+
+    a = a->mNext;
+  }
+
+  return OK;
+}
+
+void
+ActionList::Finish(int status)
+{
+  Action *a = mFirst;
+  while (a) {
+    a->Finish(status);
+    a = a->mNext;
+  }
+
+  UpdateProgressUI(100.0f);
+}
+
+int DoUpdate()
+{
+  char manifest[MAXPATHLEN];
+  snprintf(manifest, MAXPATHLEN, "%s/update.manifest", gSourcePath);
+
+  // extract the manifest
+  int rv = gArchiveReader.ExtractFile("update.manifest", manifest);
+  if (rv)
+    return rv;
+
+  int mfd = open(manifest, O_RDONLY);
+  if (mfd < 0)
+    return -1;
+
+  struct stat ms;
+  rv = fstat(mfd, &ms);
+  if (rv)
+    return IO_ERROR;
+
+  char *mbuf = (char*) malloc(ms.st_size + 1);
+  if (!mbuf)
+    return BSP_ERROR_NOMEM;
+
+  int r = ms.st_size;
+  char *rb = mbuf;
+  while (r) {
+    int c = read(mfd, rb, mmin(SSIZE_MAX,r));
+    if (c < 0)
+      return IO_ERROR;
+
+    r -= c;
+    rb += c;
+
+    if (c == 0 && r)
+      return BSP_ERROR_CORRUPT;
+  }
+  mbuf[ms.st_size] = '\0';
+
+  ActionList list;
+
+  rb = mbuf;
+  char *line;
+  while((line = mstrtok(kNL, &rb)) != 0) {
+    // skip comments
+    if (*line == '#')
+      continue;
+
+    char *token = mstrtok(kWhitespace, &line);
+    if (!token)
+      return PARSE_ERROR;
+
+    Action *action = NULL;
+    if (strcmp(token, "remove") == 0) {
+      action = new RemoveFile();
+    }
+    else if (strcmp(token, "add") == 0) {
+      action = new AddFile();
+    }
+    else if (strcmp(token, "patch") == 0) {
+      action = new PatchFile();
+    }
+    else {
+      return PARSE_ERROR;
+    }
+
+    if (!action)
+      return BSP_ERROR_NOMEM;
+
+    rv = action->Parse(line);
+    if (rv)
+      return rv;
+
+    list.Append(action);
+  }
+
+  rv = list.Prepare();
+  if (rv)
+    return rv;
+
+  rv = list.Execute();
+
+  list.Finish(rv);
+  return rv;
+}
+
+#if defined(XP_WIN) && !defined(DEBUG)
+// We need WinMain in order to not be a console app.  This function is unused
+// if we are a console application.
+int WINAPI WinMain( HINSTANCE, HINSTANCE, LPSTR args, int )
+{
+  // Do the real work.
+  return main(__argc, __argv);
+}
+#endif
Index: toolkit/mozapps/update/src/updater/updater.exe.manifest
===================================================================
RCS file: toolkit/mozapps/update/src/updater/updater.exe.manifest
diff -N toolkit/mozapps/update/src/updater/updater.exe.manifest
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/mozapps/update/src/updater/updater.exe.manifest	4 May 2005 20:58:09 -0000	1.1.2.1
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+<assemblyIdentity
+        version="1.0.0.0"
+        processorArchitecture="X86"
+        name="Updater"
+        type="win32"
+/>
+<description>Updater</description>
+<dependency>
+        <dependentAssembly>
+                <assemblyIdentity
+                        type="win32"
+                        name="Microsoft.Windows.Common-Controls"
+                        version="6.0.0.0"
+                        processorArchitecture="X86"
+                        publicKeyToken="6595b64144ccf1df"
+                        language="*"
+                />
+        </dependentAssembly>
+</dependency>
+</assembly>
Index: toolkit/mozapps/update/src/updater/updater.rc
===================================================================
RCS file: toolkit/mozapps/update/src/updater/updater.rc
diff -N toolkit/mozapps/update/src/updater/updater.rc
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/mozapps/update/src/updater/updater.rc	4 May 2005 20:58:09 -0000	1.1.2.1
@@ -0,0 +1,104 @@
+// Microsoft Visual C++ generated resource script.
+//
+#include "resource.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "afxres.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// English (U.S.) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
+#ifdef _WIN32
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+#pragma code_page(1252)
+#endif //_WIN32
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// RT_MANIFEST
+//
+
+1                       RT_MANIFEST             "updater.exe.manifest"
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Dialog
+//
+
+IDD_DIALOG DIALOGEX 0, 0, 253, 46
+STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
+FONT 8, "MS Shell Dlg", 400, 0, 0x1
+BEGIN
+    CONTROL         "",IDC_PROGRESS,"msctls_progress32",WS_BORDER,7,29,239,
+                    10
+    LTEXT           "",IDC_INFO,7,7,239,17
+END
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// DESIGNINFO
+//
+
+#ifdef APSTUDIO_INVOKED
+GUIDELINES DESIGNINFO 
+BEGIN
+    IDD_DIALOG, DIALOG
+    BEGIN
+        LEFTMARGIN, 7
+        RIGHTMARGIN, 246
+        TOPMARGIN, 7
+        BOTTOMMARGIN, 39
+    END
+END
+#endif    // APSTUDIO_INVOKED
+
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE 
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE 
+BEGIN
+    "#include ""afxres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE 
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+#endif    // English (U.S.) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
