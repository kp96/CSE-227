Index: caps/idl/nsIPrincipal.idl
===================================================================
RCS file: /cvsroot/mozilla/caps/idl/nsIPrincipal.idl,v
retrieving revision 1.32
diff -u -p -d -8 -r1.32 nsIPrincipal.idl
--- caps/idl/nsIPrincipal.idl	22 Jul 2005 19:05:38 -0000	1.32
+++ caps/idl/nsIPrincipal.idl	17 Feb 2006 03:25:09 -0000
@@ -46,17 +46,17 @@ struct JSContext;
 struct JSPrincipals;
 %}
 
 interface nsIURI;
 
 [ptr] native JSContext(JSContext);
 [ptr] native JSPrincipals(JSPrincipals);
 
-[uuid(fb9ddeb9-26f9-46b8-85d5-3978aaee05aa)]
+[scriptable, uuid(fb9ddeb9-26f9-46b8-85d5-3978aaee05aa)]
 interface nsIPrincipal : nsISerializable
 {
     /**
      * Values of capabilities for each principal. Order is
      * significant: if an operation is performed on a set
      * of capabilities, the minimum is computed.
      */
     const short ENABLE_DENIED                = 1;
@@ -68,85 +68,91 @@ interface nsIPrincipal : nsISerializable
      * Returns the security preferences associated with this principal.
      * prefBranch will be set to the pref branch to which these preferences
      * pertain.  id is a pseudo-unique identifier, pertaining to either the
      * fingerprint or the origin.  subjectName is a name that identifies the
      * entity this principal represents (may be empty).  grantedList and
      * deniedList are space-separated lists of capabilities which were
      * explicitly granted or denied by a pref.
      */
-    void getPreferences(out string prefBranch, out string id,
-                        out string subjectName,
-                        out string grantedList, out string deniedList);
+    [noscript] void getPreferences(out string prefBranch, out string id,
+                                   out string subjectName,
+                                   out string grantedList,
+                                   out string deniedList);
 
     /**
      * Returns whether the other principal is equivalent to this principal.
      * Principals are considered equal if they are the same principal,
      * they have the same origin, or have the same certificate fingerprint ID
      */
     boolean equals(in nsIPrincipal other);
 
     /**
      * Returns a hash value for the principal.
      */
-    readonly attribute unsigned long hashValue;
+    [noscript] readonly attribute unsigned long hashValue;
 
     /**
      * Returns the JS equivalent of the principal.
      * @see JSPrincipals.h
      */
-    JSPrincipals getJSPrincipals(in JSContext cx);
+    [noscript] JSPrincipals getJSPrincipals(in JSContext cx);
 
     /**
      * The domain security policy of the principal.
      */
     // XXXcaa should this be here?  The script security manager is the only
     // thing that should care about this.  Wouldn't storing this data in one
     // of the hashtables in nsScriptSecurityManager be better?
     // XXXbz why is this writable?  Who should have write access to this?  What
     // happens if this principal is in our hashtable and we pass it out of the
     // security manager and someone writes to this field?  Especially if they
     // write garbage?  If we need to give someone other than the security
     // manager a way to set this (which I question, since it can increase the
     // permissions of a page) it should be a |void clearSecurityPolicy()|
     // method.
-    attribute voidPtr securityPolicy;
+    [noscript] attribute voidPtr securityPolicy;
 
     // XXXcaa probably should be turned into {get|set}CapabilityFlags
     // XXXbz again, what if this lives in our hashtable and someone
     // messes with it?  Is that OK?
-    short canEnableCapability(in string capability);
-    void setCanEnableCapability(in string capability, in short canEnable);
-    boolean isCapabilityEnabled(in string capability, in voidPtr annotation);
-    void enableCapability(in string capability, inout voidPtr annotation);
-    void revertCapability(in string capability, inout voidPtr annotation);
-    void disableCapability(in string capability, inout voidPtr annotation);
+    [noscript] short canEnableCapability(in string capability);
+    [noscript] void setCanEnableCapability(in string capability,
+                                           in short canEnable);
+    [noscript] boolean isCapabilityEnabled(in string capability,
+                                           in voidPtr annotation);
+    [noscript] void enableCapability(in string capability,
+                                     inout voidPtr annotation);
+    [noscript] void revertCapability(in string capability,
+                                     inout voidPtr annotation);
+    [noscript] void disableCapability(in string capability,
+                                      inout voidPtr annotation);
 
     /**
      * The codebase URI to which this principal pertains.  This is
      * generally the document URI.
      */
-    readonly attribute nsIURI URI;
+    [noscript] readonly attribute nsIURI URI;
 
     /**
      * The domain URI to which this principal pertains.
      * This is congruent with HTMLDocument.domain, and may be null.
      * Setting this has no effect on the URI.
      */
-    attribute nsIURI domain;
+    [noscript] attribute nsIURI domain;
 
     /**
      * The origin of this principal's domain, if non-null, or its
      * codebase URI otherwise. An origin is defined as:
      * scheme + host + port.
      */
     // XXXcaa this should probably be turned into an nsIURI.
     // The system principal's origin should be some caps namespace
     // with a chrome URI.  All of chrome should probably be the same.
-    readonly attribute string origin;
+    [noscript] readonly attribute string origin;
 
     /**
      * Whether this principal is associated with a certificate.
      */
     readonly attribute boolean hasCertificate;
 
     /**
      * The fingerprint ID of this principal's certificate.
@@ -180,17 +186,17 @@ interface nsIPrincipal : nsISerializable
      * The non-principal is not equal to itself or any other principal, and
      * therefore does not subsume itself.
      *
      * Both codebase and certificate principals are subsumed by the system
      * principal, but no codebase or certificate principal yet subsumes any
      * other codebase or certificate principal.  This may change in a future
      * release; note that nsIPrincipal is unfrozen, not slated to be frozen.
      */
-    boolean subsumes(in nsIPrincipal other);
+    [noscript] boolean subsumes(in nsIPrincipal other);
 
     /**
      * The subject name for the certificate.  This actually identifies the
      * subject of the certificate.  This may well not be a string that would
      * mean much to a typical user on its own (e.g. it may have a number of
      * different names all concatenated together with some information on what
      * they mean in between).
      *
Index: caps/idl/nsIScriptSecurityManager.idl
===================================================================
RCS file: /cvsroot/mozilla/caps/idl/nsIScriptSecurityManager.idl,v
retrieving revision 1.66
diff -u -p -d -8 -r1.66 nsIScriptSecurityManager.idl
--- caps/idl/nsIScriptSecurityManager.idl	22 Jul 2005 19:05:38 -0000	1.66
+++ caps/idl/nsIScriptSecurityManager.idl	17 Feb 2006 03:25:10 -0000
@@ -36,17 +36,17 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsISupports.idl"
 #include "nsIPrincipal.idl"
 #include "nsIXPCSecurityManager.idl"
 interface nsIURI;
 
 
-[scriptable, uuid(f4d74511-2b2d-4a14-a3e4-a392ac5ac3ff)]
+[scriptable, uuid(6c86a0d8-7a19-42a4-be18-d282a26388fd)]
 interface nsIScriptSecurityManager : nsIXPCSecurityManager
 {
     ///////////////// Security Checks //////////////////
     /**
      * Checks whether the running script is allowed to access aProperty.
      */
     [noscript] void checkPropertyAccess(in JSContextPtr aJSContext,
                                         in JSObjectPtr aJSObject,
@@ -98,19 +98,19 @@ interface nsIScriptSecurityManager : nsI
      *
      * Will return error code NS_ERROR_DOM_BAD_URI if the load request 
      * should be denied.
      *
      * @param aPrincipal the URI causing the load
      * @param uri the URI that is being loaded
      * @param flags the permission set, see above
      */
-    [noscript] void checkLoadURIWithPrincipal(in nsIPrincipal aPrincipal,
-                                              in nsIURI uri, 
-                                              in unsigned long flags);
+    void checkLoadURIWithPrincipal(in nsIPrincipal aPrincipal,
+                                   in nsIURI uri, 
+                                   in unsigned long flags);
 
     /**
      * Check that content from "from" can load "uri".
      *
      * Will return error code NS_ERROR_DOM_BAD_URI if the load request 
      * should be denied.
      *
      * @param from the URI causing the load
@@ -252,30 +252,32 @@ interface nsIScriptSecurityManager : nsI
      */
     void checkSameOriginURI(in nsIURI aSourceURI,
                             in nsIURI aTargetURI);
 
     /**
      * Returns OK if aSourcePrincipal and aTargetPrincipal
      * have the same "origin" (scheme, host, and port).
      */
-    [noscript] void checkSameOriginPrincipal(in nsIPrincipal aSourcePrincipal,
-                                             in nsIPrincipal aTargetPrincipal);
+    void checkSameOriginPrincipal(in nsIPrincipal aSourcePrincipal,
+                                  in nsIPrincipal aTargetPrincipal);
 
     /**
      * Returns the principal of the global object of the given context, or null
      * if no global or no principal.
      */
     [noscript] nsIPrincipal getPrincipalFromContext(in JSContextPtr cx);
 
     /**
      * Utility method for comparing two URIs.  For security purposes, two URIs
      * are equivalent if their schemes, hosts, and ports (if any) match.  This
      * method returns true if aSubjectURI and aObjectURI have the same origin,
      * false otherwise.
+     // FIXME: Bug 327243 -- this is no longer used outside caps.
+     // Should it even be exposed?
      */
     [noscript] boolean securityCompareURIs(in nsIURI aSubjectURI,
                                            in nsIURI aObjectURI);
 };
 
 %{C++
 #define NS_SCRIPTSECURITYMANAGER_CONTRACTID "@mozilla.org/scriptsecuritymanager;1"
 #define NS_SCRIPTSECURITYMANAGER_CLASSNAME "scriptsecuritymanager"
