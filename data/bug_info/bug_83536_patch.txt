? .fast-update
? obj-debug
? obj-opt
? accessible/.fast-update
? calendar/.fast-update
? ipc/ipcd/.fast-update
? modules/libpr0n/.fast-update
? nsprpub/.fast-update
? other-licenses/libart_lgpl/.fast-update
? other-licenses/libical/.fast-update
? security/manager/.fast-update
Index: caps/idl/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/caps/idl/Makefile.in,v
retrieving revision 1.13
diff -p -u -d -8 -r1.13 Makefile.in
--- caps/idl/Makefile.in	28 Dec 2002 01:12:53 -0000	1.13
+++ caps/idl/Makefile.in	23 Jul 2003 23:08:58 -0000
@@ -27,17 +27,14 @@ VPATH		= @srcdir@
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= caps
 GRE_MODULE	= 1
 
 XPIDLSRCS	= \
 		nsIScriptSecurityManager.idl \
 		nsIPrincipal.idl \
-		nsICodebasePrincipal.idl \
-		nsICertificatePrincipal.idl \
-		nsIAggregatePrincipal.idl \
 		nsISignatureVerifier.idl \
 		nsISecurityCheckedComponent.idl \
 		$(NULL)
 
 include $(topsrcdir)/config/rules.mk
 
Index: caps/idl/nsIPrincipal.idl
===================================================================
RCS file: /cvsroot/mozilla/caps/idl/nsIPrincipal.idl,v
retrieving revision 1.25
diff -p -u -d -8 -r1.25 nsIPrincipal.idl
--- caps/idl/nsIPrincipal.idl	8 Jan 2003 08:40:20 -0000	1.25
+++ caps/idl/nsIPrincipal.idl	23 Jul 2003 23:08:58 -0000
@@ -9,22 +9,24 @@
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
- * The Initial Developer of the Original Code is 
+ * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1999-2000
+ * Portions created by the Initial Developer are Copyright (C) 1999-2003
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ *   Mitchell Stoltz <mstoltz@netscape.com>
+ *   Christopher A. Aillon <christopher@aillon.com>
  *
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
@@ -39,46 +41,112 @@
 /* Defines the abstract interface for a principal. */
 
 #include "nsISerializable.idl"
 
 %{C++
 struct JSPrincipals;
 %}
 
+interface nsIURI;
+
 [ptr] native JSPrincipals(JSPrincipals);
 
 [uuid(ff9313d0-25e1-11d2-8160-006008119d7a)]
-interface nsIPrincipal : nsISerializable {
-
-    // Values of capabilities for each principal. Order is
-    // significant: if an operation is performed on a set
-    // of capabilities, the minimum is computed.
+interface nsIPrincipal : nsISerializable
+{
+    /**
+     * Values of capabilities for each principal. Order is
+     * significant: if an operation is performed on a set
+     * of capabilities, the minimum is computed.
+     */
     const short ENABLE_DENIED                = 1;
     const short ENABLE_UNKNOWN               = 2;
     const short ENABLE_WITH_USER_PERMISSION  = 3;
     const short ENABLE_GRANTED               = 4;
 
-    string ToString();
+    /**
+     * Returns the security preferences associated with this principal.
+     * prefBranch will be set to the pref branch to which these preferences
+     * pertain.  id is a psuedo-unique identifier, pertaining to either the
+     * certificateID or the origin.  grantedList and deniedList are
+     * space-separated lists of capabilities which were explicitly granted
+     * or denied by a pref.
+     */
+    void getPreferences(out string prefBranch, out string id,
+                        out string grantedList, out string deniedList);
 
-    string ToUserVisibleString();
+    /**
+     * Returns whether the other principal is equivalent to this principal.
+     * Principals are considered equal if they are the same principal,
+     * they have the same origin, or have the same certificate ID
+     */
+    boolean equals(in nsIPrincipal other);
 
-    void GetPreferences(out string prefName, out string id, 
-                        out string grantedList, out string deniedList);
+    /**
+     * Returns a hash value for the principal.
+     */
+    readonly attribute unsigned long hashValue;
 
-    boolean Equals(in nsIPrincipal other);
+    /**
+     * Returns the JS equivalent of the principal.
+     * @see JSPrincipals.h
+     */
+    readonly attribute JSPrincipals jsPrincipals;
 
-    unsigned long HashValue();
+    /**
+     * The domain security policy of the principal.
+     */
+    // XXXcaa should this be here?  The script security manager is the only
+    // thing that should care about this.  Wouldn't storing this data in one
+    // of the hashtables in nsScriptSecurityManager be better?
+    attribute voidPtr securityPolicy;
 
-    JSPrincipals GetJSPrincipals();
+    // XXXcaa probably should be turned into {get|set}CapabilityFlags
+    short canEnableCapability(in string capability);
+    void setCanEnableCapability(in string capability, in short canEnable);
+    boolean isCapabilityEnabled(in string capability, in voidPtr annotation);
+    void enableCapability(in string capability, inout voidPtr annotation);
+    void revertCapability(in string capability, inout voidPtr annotation);
+    void disableCapability(in string capability, inout voidPtr annotation);
 
-    short CanEnableCapability(in string capability);
+    /**
+     * The codebase URI to which this principal pertains.  This is
+     * generally the document URI.  Setting this will reset the domain
+     * to null.
+     */
+    attribute nsIURI URI;
 
-    void SetCanEnableCapability(in string capability, in short canEnable);
+    /**
+     * The domain URI to which this principal pertains.
+     * This is congruent with HTMLDocument.domain, and may be null.
+     * Setting this has no effect on the URI.
+     */
+    attribute nsIURI domain;
 
-    boolean IsCapabilityEnabled(in string capability, in voidPtr annotation);
-    
-    void EnableCapability(in string capability, inout voidPtr annotation);
+    /**
+     * The origin of this principal's domain, if non-null, or its
+     * codebase URI otherwise. An origin is defined as:
+     * scheme + host + port.
+     */
+    // XXXcaa this should probably be turned into an nsIURI.
+    // The system principal's origin should be some caps namespace
+    // with a chrome URI.  All of chrome should probably be the same.
+    readonly attribute string origin;
 
-    void RevertCapability(in string capability, inout voidPtr annotation);
+    /**
+     * Whether this principal is associated with a certificate.
+     */
+    readonly attribute boolean hasCertificate;
 
-    void DisableCapability(in string capability, inout voidPtr annotation);
+    /**
+     * The fingerprint ID of this principal's certificate.
+     */
+    // XXXcaa kaie says this may not be unique.  We should probably
+    // consider using something else for this....
+    attribute string certificateID;
+
+    /**
+     * The common name for the certificate.
+     * This pertains to the certificate authority organization.
+     */
+    attribute string commonName;
 };
Index: caps/idl/nsIScriptSecurityManager.idl
===================================================================
RCS file: /cvsroot/mozilla/caps/idl/nsIScriptSecurityManager.idl,v
retrieving revision 1.56
diff -p -u -d -8 -r1.56 nsIScriptSecurityManager.idl
--- caps/idl/nsIScriptSecurityManager.idl	29 May 2003 21:56:33 -0000	1.56
+++ caps/idl/nsIScriptSecurityManager.idl	23 Jul 2003 23:08:58 -0000
@@ -129,48 +129,47 @@ interface nsIScriptSecurityManager : nsI
                                          in nsIPrincipal principal);
 
     ///////////////// Principals /////////////////////// 
     /**
      * Return the principal of the innermost frame of the currently 
      * executing script. Will return null if there is no script 
      * currently executing.
      */
-    nsIPrincipal getSubjectPrincipal();
+    [noscript] nsIPrincipal getSubjectPrincipal();
 
     /**
      * Return the all-powerful system principal.
      */
-    nsIPrincipal getSystemPrincipal();
+    [noscript] nsIPrincipal getSystemPrincipal();
 
     /**
-     * Return a principal that can be QI'd to nsICertificatePrincipal.
+     * Return a principal with the specified certificate ID.
      */
-    nsIPrincipal getCertificatePrincipal(in string CertID);
+    [noscript] nsIPrincipal getCertificatePrincipal(in string CertID);
 
     /**
-     * Return a principal that can be QI'd to nsICodebasePrincipal and 
-     * has the same origin as aURI.
+     * Return a principal that has the same origin as aURI.
      */
-    nsIPrincipal getCodebasePrincipal(in nsIURI aURI);
+    [noscript] nsIPrincipal getCodebasePrincipal(in nsIURI aURI);
 
     ///////////////// Capabilities API /////////////////////
     /**
      * Request that 'capability' can be enabled by scripts or applets
      * running with 'principal'. Will prompt user if
      * necessary. Returns nsIPrincipal::ENABLE_GRANTED or
      * nsIPrincipal::ENABLE_DENIED based on user's choice.
      */
-    void requestCapability(in nsIPrincipal principal, in string capability,
-                           out short result);
+    [noscript] short requestCapability(in nsIPrincipal principal,
+                                       in string capability);
     
     /**
      * Return true if the currently executing script has 'capability' enabled.
      */
-    boolean IsCapabilityEnabled(in string capability);
+    boolean isCapabilityEnabled(in string capability);
     
     /**
      * Enable 'capability' in the innermost frame of the currently executing
      * script.
      */
     void enableCapability(in string capability);
 
     /**
Index: caps/include/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/caps/include/Makefile.in,v
retrieving revision 1.19
diff -p -u -d -8 -r1.19 Makefile.in
--- caps/include/Makefile.in	18 Dec 2001 09:09:58 -0000	1.19
+++ caps/include/Makefile.in	23 Jul 2003 23:08:58 -0000
@@ -24,19 +24,13 @@ topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= caps
 
 EXPORTS		= \
-		nsBasePrincipal.h \
-		nsSystemPrincipal.h \
-		nsCertificatePrincipal.h \
-		nsCodebasePrincipal.h \
-		nsAggregatePrincipal.h \
-		nsJSPrincipals.h \
-		nsScriptSecurityManager.h \
-		$(NULL)
+            nsJSPrincipals.h \
+            $(NULL)
 
 include $(topsrcdir)/config/rules.mk
 
Index: caps/include/nsJSPrincipals.h
===================================================================
RCS file: /cvsroot/mozilla/caps/include/nsJSPrincipals.h,v
retrieving revision 1.8
diff -p -u -d -8 -r1.8 nsJSPrincipals.h
--- caps/include/nsJSPrincipals.h	25 Sep 2001 01:03:53 -0000	1.8
+++ caps/include/nsJSPrincipals.h	23 Jul 2003 23:08:58 -0000
@@ -31,24 +31,25 @@
  * use your version of this file under the terms of the NPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the NPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 /* describes principals by their orginating uris*/
-#ifndef _NS_JSPRINCIPALS_H_
-#define _NS_JSPRINCIPALS_H_
+
+#ifndef nsJSPrincipals_h__
+#define nsJSPrincipals_h__
 #include "jsapi.h"
 #include "nsIPrincipal.h"
 
 struct nsJSPrincipals : JSPrincipals {
   static nsresult Startup();
   nsJSPrincipals();
   nsresult Init(char *prin);
   ~nsJSPrincipals(void);
 
-  nsIPrincipal *nsIPrincipalPtr;
+  nsIPrincipal *nsIPrincipalPtr; // [WEAK] it owns us.
 };
 
-#endif /* _NS_JSPRINCIPALS_H_ */
+#endif /* nsJSPrincipals_h__ */
 
Index: caps/include/nsPrincipal.h
===================================================================
RCS file: caps/include/nsPrincipal.h
diff -N caps/include/nsPrincipal.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ caps/include/nsPrincipal.h	23 Jul 2003 23:08:58 -0000
@@ -0,0 +1,128 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2003
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Christopher A. Aillon <christopher@aillon.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsPrincipal_h__
+#define nsPrincipal_h__
+
+#include "nsAutoPtr.h"
+#include "nsCOMPtr.h"
+#include "nsVoidArray.h"
+#include "nsHashtable.h"
+#include "nsJSPrincipals.h"
+
+class nsIObjectInputStream;
+class nsIObjectOutputStream;
+
+class nsPrincipal : public nsIPrincipal
+{
+public:
+  nsPrincipal();
+  nsPrincipal(nsIURI *aURI);
+
+protected:
+  virtual ~nsPrincipal();
+
+public:
+  // Our refcount is managed by mJSPrincipals.  Use this macro to avoid
+  // an extra refcount member.
+  NS_DECL_ISUPPORTS_INHERITED
+protected:
+  // XXXcaa Probably unnecessary.  See bug 143559.
+  NS_DECL_OWNINGTHREAD
+public:
+
+  NS_DECL_NSIPRINCIPAL
+  NS_DECL_NSISERIALIZABLE
+
+  nsresult InitFromPersistent(const char* aPrefName,
+                              const char* aToken,
+                              const char* aGrantedList,
+                              const char* aDeniedList,
+                              PRBool aIsCert = PR_FALSE,
+                              PRBool aTrusted = PR_FALSE);
+
+  enum AnnotationValue { AnnotationEnabled=1, AnnotationDisabled };
+
+  nsresult SetCapability(const char *capability, void **annotation, 
+                         AnnotationValue value);
+
+  static const char sInvalid[];
+
+protected:
+  nsJSPrincipals mJSPrincipals;
+  nsVoidArray mAnnotations;
+  nsHashtable mCapabilities;
+  nsCString mPrefName;
+  static PRInt32 sCapabilitiesOrdinal;
+
+  // XXXcaa This is a semi-hack.  The best solution here is to keep
+  // a reference to an interface here, except there is no interface
+  // that we can use yet.
+  struct Certificate
+  {
+    Certificate(const char* aCertID, const char* aName)
+      : certificateID(aCertID),
+        commonName(aName)
+    {
+    };
+    nsCString certificateID;
+    nsCString commonName;
+  };
+
+  // Keep this is a pointer, even though it may slightly increase the
+  // cost of keeping a certificate, this is a good tradeoff though since
+  // it is very rare that we actually have a certificate.
+  nsAutoPtr<Certificate> mCert;
+
+  void* mSecurityPolicy;
+
+  nsCOMPtr<nsIURI> mCodebase;
+  nsCOMPtr<nsIURI> mDomain;
+  PRUint8 mType;
+  PRPackedBool mTrusted;
+};
+
+
+#define NS_PRINCIPAL_CLASSNAME  "principal"
+#define NS_PRINCIPAL_CONTRACTID "@mozilla.org/principal;1"
+#define NS_PRINCIPAL_CID \
+  { 0x36102b6b, 0x7b62, 0x451a, \
+    { 0xa1, 0xc8, 0xa0, 0xd4, 0x56, 0xc9, 0x2d, 0xc5 }}
+
+
+#endif // nsPrincipal_h__
Index: caps/include/nsScriptSecurityManager.h
===================================================================
RCS file: /cvsroot/mozilla/caps/include/nsScriptSecurityManager.h,v
retrieving revision 1.69
diff -p -u -d -8 -r1.69 nsScriptSecurityManager.h
--- caps/include/nsScriptSecurityManager.h	26 Jun 2003 03:26:59 -0000	1.69
+++ caps/include/nsScriptSecurityManager.h	23 Jul 2003 23:08:58 -0000
@@ -17,87 +17,132 @@
  * The Initial Developer of the Original Code is 
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998-2000
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *  Norris Boyd  <nboyd@atg.com>
  *  Mitch Stoltz <mstoltz@netscape.com>
+ *  Christopher A. Aillon <christopher@aillon.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the NPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the NPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-#ifndef _NS_SCRIPT_SECURITY_MANAGER_H_
-#define _NS_SCRIPT_SECURITY_MANAGER_H_
+#ifndef nsScriptSecurityManager_h__
+#define nsScriptSecurityManager_h__
 
 #include "nsIScriptSecurityManager.h"
 #include "nsIPrincipal.h"
 #include "jsapi.h"
 #include "jsdbgapi.h"
 #include "nsIXPCSecurityManager.h"
+#include "nsInterfaceHashtable.h"
 #include "nsHashtable.h"
 #include "nsCOMPtr.h"
 #include "nsIPrefService.h"
 #include "nsISecurityPref.h"
 #include "nsIJSContextStack.h"
 #include "nsIObserver.h"
 #include "pldhash.h"
 #include "plstr.h"
 
 class nsIDocShell;
 class nsString;
 class nsIClassInfo;
+class nsIIOService;
+class nsIXPConnect;
 class nsSystemPrincipal;
 struct ClassPolicy;
 
+#if defined(DEBUG_mstoltz) || defined(DEBUG_caillon)
+#define DEBUG_CAPS_HACKER
+#endif
+
+#ifdef DEBUG_CAPS_HACKER
+#define DEBUG_CAPS_CheckPropertyAccessImpl
+#define DEBUG_CAPS_LookupPolicy
+#define DEBUG_CAPS_CheckComponentPermissions
+#endif
+
+#if 0
+#define DEBUG_CAPS_CanCreateWrapper
+#define DEBUG_CAPS_CanCreateInstance
+#define DEBUG_CAPS_CanGetService
+#endif
+
 /////////////////////
-// nsIPrincipalKey //
+// PrincipalKey //
 /////////////////////
 
-class nsIPrincipalKey : public nsHashKey {
+class NS_COM PrincipalKey : public PLDHashEntryHdr
+{
 public:
-    nsIPrincipalKey(nsIPrincipal* key) {
-        mKey = key;
-        NS_IF_ADDREF(mKey);
+    typedef const nsIPrincipal* KeyType;
+    typedef const nsIPrincipal* KeyTypePointer;
+
+    PrincipalKey(const nsIPrincipal* key)
+      : mKey(NS_CONST_CAST(nsIPrincipal*, key))
+    {
     }
-    
-    ~nsIPrincipalKey(void) {
-        NS_IF_RELEASE(mKey);
+
+    PrincipalKey(const PrincipalKey& toCopy)
+      : mKey(toCopy.mKey)
+    {
+    } 
+
+    ~PrincipalKey()
+    {
     }
-    
-    PRUint32 HashCode(void) const {
-        PRUint32 hash;
-        mKey->HashValue(&hash);
-        return hash;
+
+    KeyType GetKey() const
+    {
+        return mKey;
     }
-    
-    PRBool Equals(const nsHashKey* aKey) const {
+
+    KeyTypePointer GetKeyPointer() const
+    {
+        return mKey;
+    }
+
+    PRBool KeyEquals(KeyTypePointer aKey) const
+    {
         PRBool eq;
-        mKey->Equals(((nsIPrincipalKey*) aKey)->mKey, &eq);
+        mKey->Equals(NS_CONST_CAST(nsIPrincipal*, aKey),
+                     &eq);
         return eq;
     }
-    
-    nsHashKey *Clone(void) const {
-        return new nsIPrincipalKey(mKey);
+
+    static KeyTypePointer KeyToPointer(KeyType aKey)
+    {
+        return aKey;
     }
 
-protected:
-    nsIPrincipal* mKey;
+    static PLDHashNumber HashKey(KeyTypePointer aKey)
+    {
+        PRUint32 hash;
+        NS_CONST_CAST(nsIPrincipal*, aKey)->GetHashValue(&hash);
+        return PLDHashNumber(hash);
+    }
+
+    enum { ALLOW_MEMMOVE = PR_TRUE };
+
+private:
+    nsCOMPtr<nsIPrincipal> mKey;
 };
 
 ////////////////////
 // Policy Storage //
 ////////////////////
 
 // Property Policy
 union SecurityLevel
@@ -208,33 +253,36 @@ InitClassPolicyEntry(PLDHashTable *table
 }
 
 // Domain Policy
 class DomainPolicy : public PLDHashTable
 {
 public:
     DomainPolicy() : mWildcardPolicy(nsnull),
                      mRefCount(0)
-                     
     {
-        static PLDHashTableOps domainPolicyOps =
+    }
+
+    PRBool Init()
+    {
+        static const PLDHashTableOps domainPolicyOps =
         {
             PL_DHashAllocTable,
             PL_DHashFreeTable,
             PL_DHashGetKeyStub,
             PL_DHashStringKey,
             MatchClassPolicyKey,
             PL_DHashMoveEntryStub,
             ClearClassPolicyEntry,
             PL_DHashFinalizeStub,
             InitClassPolicyEntry
         };
 
-        PL_DHashTableInit(this, &domainPolicyOps, nsnull,
-                          sizeof(ClassPolicy), 16);
+        return PL_DHashTableInit(this, &domainPolicyOps, nsnull,
+                                 sizeof(ClassPolicy), 16);
     }
 
     ~DomainPolicy()
     {
         PL_DHashTableFinish(this);
     }
 
     void Hold()
@@ -392,45 +440,46 @@ private:
                    nsISecurityPref* securityPref);
 
 #ifdef XPC_IDISPATCH_SUPPORT
     // While this header is included outside of caps, this class isn't 
     // referenced so this should be fine.
     nsresult
     CheckComponentPermissions(JSContext *cx, const nsCID &aCID);
 #endif
-#ifdef DEBUG_mstoltz
+#ifdef DEBUG_CAPS_HACKER
     void
     PrintPolicyDB();
 #endif
 
     // JS strings we need to clean up on shutdown
     static jsval sEnabledID;
 
     inline void
     JSEnabledPrefChanged(nsISecurityPref* aSecurityPref);
 
-    static const char* sJSEnabledPrefName;
-    static const char* sJSMailEnabledPrefName;
+    static const char sJSEnabledPrefName[];
+    static const char sJSMailEnabledPrefName[];
 
     nsObjectHashtable* mOriginToPolicyMap;
     DomainPolicy* mDefaultPolicy;
     nsObjectHashtable* mCapabilities;
 
     nsCOMPtr<nsIPrefBranch> mPrefBranch;
     nsCOMPtr<nsISecurityPref> mSecurityPref;
-    nsIPrincipal* mSystemPrincipal;
+    nsCOMPtr<nsIPrincipal> mSystemPrincipal;
     nsCOMPtr<nsIPrincipal> mSystemCertificate;
-    nsSupportsHashtable* mPrincipals;
-    PRBool mIsJavaScriptEnabled;
-    PRBool mIsMailJavaScriptEnabled;
-    PRBool mIsWritingPrefs;
+    nsInterfaceHashtable<PrincipalKey, nsIPrincipal> mPrincipals;
     nsCOMPtr<nsIThreadJSContextStack> mJSContextStack;
-    PRBool mNameSetRegistered;
-    PRBool mPolicyPrefsChanged;
+    PRPackedBool mIsJavaScriptEnabled;
+    PRPackedBool mIsMailJavaScriptEnabled;
+    PRPackedBool mIsWritingPrefs;
+    PRPackedBool mPolicyPrefsChanged;
 #ifdef XPC_IDISPATCH_SUPPORT    
-    PRBool mXPCDefaultGrantAll;
-    static const char* sXPCDefaultGrantAllName;
+    PRPackedBool mXPCDefaultGrantAll;
+    static const char sXPCDefaultGrantAllName[];
 #endif
-};
 
-#endif /*_NS_SCRIPT_SECURITY_MANAGER_H_*/
+    static nsIIOService* sIOService;
+    static nsIXPConnect* sXPConnect;
+};
 
+#endif // nsScriptSecurityManager_h__
Index: caps/include/nsSystemPrincipal.h
===================================================================
RCS file: /cvsroot/mozilla/caps/include/nsSystemPrincipal.h,v
retrieving revision 1.14
diff -p -u -d -8 -r1.14 nsSystemPrincipal.h
--- caps/include/nsSystemPrincipal.h	25 Sep 2001 01:03:53 -0000	1.14
+++ caps/include/nsSystemPrincipal.h	23 Jul 2003 23:08:58 -0000
@@ -9,17 +9,17 @@
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
- * The Initial Developer of the Original Code is 
+ * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1999-2000
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
  *
  * Alternatively, the contents of this file may be used under the terms of
@@ -33,59 +33,41 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the NPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /* The privileged system principal. */
 
-#ifndef _NS_SYSTEM_PRINCIPAL_H_
-#define _NS_SYSTEM_PRINCIPAL_H_
+#ifndef nsSystemPrincipal_h__
+#define nsSystemPrincipal_h__
 
-#include "nsBasePrincipal.h"
+#include "nsIPrincipal.h"
+#include "nsJSPrincipals.h"
 
 #define NS_SYSTEMPRINCIPAL_CLASSNAME "systemprincipal"
 #define NS_SYSTEMPRINCIPAL_CID \
 { 0x4a6212db, 0xaccb, 0x11d3, \
 { 0xb7, 0x65, 0x0, 0x60, 0xb0, 0xb6, 0xce, 0xcb }}
 #define NS_SYSTEMPRINCIPAL_CONTRACTID "@mozilla.org/systemprincipal;1"
 
 
-class nsSystemPrincipal : public nsBasePrincipal {
+class nsSystemPrincipal : public nsIPrincipal
+{
 public:
-    
-    NS_DECL_ISUPPORTS
+    NS_DECL_ISUPPORTS_INHERITED
+    NS_DECL_NSIPRINCIPAL
     NS_DECL_NSISERIALIZABLE
-    
-    NS_IMETHOD ToString(char **result);
-
-    NS_IMETHOD ToUserVisibleString(char **result);
-
-    NS_IMETHOD Equals(nsIPrincipal *other, PRBool *result);
-
-    NS_IMETHOD HashValue(PRUint32 *result);
-
-    NS_IMETHOD CanEnableCapability(const char *capability, PRInt16 *result);
-
-    NS_IMETHOD SetCanEnableCapability(const char *capability, 
-                                      PRInt16 canEnable);
-
-    NS_IMETHOD IsCapabilityEnabled(const char *capability, void * annotation, 
-                                   PRBool *result);
-
-    NS_IMETHOD EnableCapability(const char *capability, void * *annotation);
-
-    NS_IMETHOD RevertCapability(const char *capability, void * *annotation);
-
-    NS_IMETHOD DisableCapability(const char *capability, void * *annotation);
 
-    NS_IMETHOD GetPreferences(char** aPrefName, char** aID, 
-                              char** aGrantedList, char** aDeniedList);
-    
-    NS_IMETHOD Init();
+    nsresult Init();
 
     nsSystemPrincipal();
 
+protected:
     virtual ~nsSystemPrincipal(void);
+
+    nsJSPrincipals mJSPrincipals;
+    // XXX Probably unnecessary.  See bug 143559.
+    NS_DECL_OWNINGTHREAD
 };
 
-#endif // _NS_SYSTEM_PRINCIPAL_H_
+#endif // nsSystemPrincipal_h__
Index: caps/src/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/caps/src/Makefile.in,v
retrieving revision 1.57
diff -p -u -d -8 -r1.57 Makefile.in
--- caps/src/Makefile.in	30 Apr 2003 09:19:50 -0000	1.57
+++ caps/src/Makefile.in	23 Jul 2003 23:08:58 -0000
@@ -45,21 +45,18 @@ REQUIRES	= xpcom \
 		  plugin \
 		  intl \
 		  docshell \
 		  windowwatcher \
 		  content \
 		  $(NULL)
 
 CPPSRCS		= \
-		nsBasePrincipal.cpp \
+		nsPrincipal.cpp \
 		nsSystemPrincipal.cpp \
-		nsCertificatePrincipal.cpp \
-		nsCodebasePrincipal.cpp \
-		nsAggregatePrincipal.cpp \
 		nsJSPrincipals.cpp \
 		nsScriptSecurityManager.cpp \
 		nsSecurityManagerFactory.cpp \
 		$(NULL)
 
 ifdef XPC_IDISPATCH_SUPPORT
 DEFINES += -DXPC_IDISPATCH_SUPPORT
 endif
Index: caps/src/nsJSPrincipals.cpp
===================================================================
RCS file: /cvsroot/mozilla/caps/src/nsJSPrincipals.cpp,v
retrieving revision 1.18
diff -p -u -d -8 -r1.18 nsJSPrincipals.cpp
--- caps/src/nsJSPrincipals.cpp	13 Mar 2003 21:24:37 -0000	1.18
+++ caps/src/nsJSPrincipals.cpp	23 Jul 2003 23:08:58 -0000
@@ -30,17 +30,20 @@
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the NPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the NPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
-#include "nsCodebasePrincipal.h"
+
+#include "nsString.h"
+#include "nsIObjectOutputStream.h"
+#include "nsIObjectInputStream.h"
 #include "nsJSPrincipals.h"
 #include "plstr.h"
 #include "nsXPIDLString.h"
 #include "nsCOMPtr.h"
 #include "jsapi.h"
 #include "jsxdrapi.h"
 #include "nsIJSRuntimeService.h"
 #include "nsIServiceManager.h"
@@ -133,17 +136,17 @@ nsTranscodeJSPrincipals(JSXDRState *xdr,
                     // Any decode-mode JSXDRState whose userdata points to an
                     // nsIObjectInputStream instance must use nsMemory to Alloc
                     // and Free its data buffer.  Swap the new buffer we just
                     // read for the old, exhausted data.
                     olddata = (char*) ::JS_XDRMemGetData(xdr, &oldsize);
                     nsMemory::Free(olddata);
                     ::JS_XDRMemSetData(xdr, data, size);
 
-                    prin->GetJSPrincipals(jsprinp);
+                    prin->GetJsPrincipals(jsprinp);
                 }
             }
         }
     }
 
     if (NS_FAILED(rv)) {
         ::JS_ReportError(xdr->cx, "can't %scode principals (failure code %x)",
                          (xdr->mode == JSXDR_ENCODE) ? "en" : "de",
@@ -180,16 +183,22 @@ nsJSPrincipals::nsJSPrincipals()
     refcount = 0;
     destroy = nsDestroyJSPrincipals;
     nsIPrincipalPtr = nsnull;
 }
 
 nsresult
 nsJSPrincipals::Init(char *aCodebase)
 {
+    if (codebase)
+    {
+        NS_ERROR("Init called twice!");
+        return NS_ERROR_UNEXPECTED;
+    }
+
     codebase = aCodebase;
     return NS_OK;
 }
 
 nsJSPrincipals::~nsJSPrincipals()
 {
     if (codebase)
         PL_strfree(codebase);
Index: caps/src/nsPrincipal.cpp
===================================================================
RCS file: caps/src/nsPrincipal.cpp
diff -N caps/src/nsPrincipal.cpp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ caps/src/nsPrincipal.cpp	23 Jul 2003 23:08:58 -0000
@@ -0,0 +1,784 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2003
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Christopher A. Aillon <christopher@aillon.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nscore.h"
+#include "nsScriptSecurityManager.h"
+#include "nsString.h"
+#include "nsReadableUtils.h"
+#include "plstr.h"
+#include "nsCRT.h"
+#include "nsIURI.h"
+#include "nsNetUtil.h"
+#include "nsJSPrincipals.h"
+#include "nsVoidArray.h"
+#include "nsHashtable.h"
+#include "nsIObjectInputStream.h"
+#include "nsIObjectOutputStream.h"
+
+#include "nsPrincipal.h"
+
+
+// Static member variables
+PRInt32 nsPrincipal::sCapabilitiesOrdinal = 0;
+const char nsPrincipal::sInvalid[] = "Invalid";
+
+
+nsPrincipal::nsPrincipal()
+  : mCapabilities(7)
+{
+}
+
+
+NS_IMPL_QUERY_INTERFACE2_CI(nsPrincipal,
+                            nsIPrincipal,
+                            nsISerializable)
+NS_IMPL_CI_INTERFACE_GETTER2(nsPrincipal,
+                             nsIPrincipal,
+                             nsISerializable)
+
+NS_IMETHODIMP_(nsrefcnt)
+nsPrincipal::AddRef()
+{
+  NS_PRECONDITION(PRInt32(mJSPrincipals.refcount) >= 0, "illegal refcnt");
+  // XXXcaa does this need to be threadsafe?  See bug 143559.
+  nsrefcnt count = PR_AtomicIncrement((PRInt32 *)&mJSPrincipals.refcount);
+  NS_LOG_ADDREF(this, count, "nsPrincipal", sizeof(*this));
+  return count;
+}
+
+NS_IMETHODIMP_(nsrefcnt)
+nsPrincipal::Release()
+{
+  NS_PRECONDITION(0 != mJSPrincipals.refcount, "dup release");
+  nsrefcnt count = PR_AtomicDecrement((PRInt32 *)&mJSPrincipals.refcount);
+  NS_LOG_RELEASE(this, count, "nsPrincipal");
+  if (count == 0) {
+    NS_DELETEXPCOM(this);
+  }
+
+  return count;
+}
+
+nsPrincipal::nsPrincipal(nsIURI *aURI)
+  : mSecurityPolicy(nsnull),
+    mCodebase(aURI)
+{
+}
+
+
+PR_STATIC_CALLBACK(PRBool)
+deleteElement(void* aElement, void *aData)
+{
+  nsHashtable *ht = (nsHashtable *) aElement;
+  delete ht;
+  return PR_TRUE;
+}
+
+nsPrincipal::~nsPrincipal(void)
+{
+  mAnnotations.EnumerateForwards(deleteElement, nsnull);
+  delete mCert;
+}
+
+NS_IMETHODIMP
+nsPrincipal::GetJsPrincipals(JSPrincipals **jsprin)
+{
+  if (!mJSPrincipals.nsIPrincipalPtr) {
+    // Don't addref here, since we are referencing each other.
+    mJSPrincipals.nsIPrincipalPtr = this;
+  }
+
+  *jsprin = &mJSPrincipals;
+
+  // JSPRINCIPALS_HOLD does not use its first argument.
+  // Just use a dummy cx to save the codesize.
+  JSPRINCIPALS_HOLD(cx, *jsprin);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrincipal::GetOrigin(char **aOrigin)
+{
+  nsIURI* uri = mDomain ? mDomain : mCodebase;
+  NS_ASSERTION(uri, "No Domain or Codebase");
+
+  nsCAutoString hostPort;
+  nsresult rv = uri->GetHostPort(hostPort);
+  if (NS_SUCCEEDED(rv)) {
+    nsCAutoString scheme;
+    rv = uri->GetScheme(scheme);
+    NS_ENSURE_SUCCESS(rv, rv);
+    *aOrigin = ToNewCString(scheme + NS_LITERAL_CSTRING("://") + hostPort);
+  }
+  else {
+    // Some URIs (e.g., nsSimpleURI) don't support host. Just
+    // get the full spec.
+    nsCAutoString spec;
+    rv = uri->GetSpec(spec);
+    NS_ENSURE_SUCCESS(rv, rv);
+    *aOrigin = ToNewCString(spec);
+  }
+
+  return *aOrigin ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+NS_IMETHODIMP
+nsPrincipal::GetSecurityPolicy(void** aSecurityPolicy)
+{
+  *aSecurityPolicy = mSecurityPolicy;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrincipal::SetSecurityPolicy(void* aSecurityPolicy)
+{
+  mSecurityPolicy = aSecurityPolicy;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrincipal::Equals(nsIPrincipal *aOther, PRBool *aResult)
+{
+  *aResult = PR_FALSE;
+
+  if (!aOther) {
+    NS_WARNING("Need a principal to compare this to!");
+    return NS_OK;
+  }
+
+  if (this != aOther) {
+    if (mCert) {
+      PRBool otherHasCert;
+      aOther->GetHasCertificate(&otherHasCert);
+      if (!otherHasCert) {
+        return NS_OK;
+      }
+
+      nsXPIDLCString otherCertID;
+      aOther->GetCertificateID(getter_Copies(otherCertID));
+      if (!otherCertID.Equals(mCert->certificateID)) {
+        return NS_OK;
+      }
+    }
+
+    // Codebases are equal if they have the same origin.
+    nsIURI *origin = mDomain ? mDomain : mCodebase;
+    nsCOMPtr<nsIURI> otherOrigin;
+    aOther->GetDomain(getter_AddRefs(otherOrigin));
+    if (!otherOrigin) {
+      aOther->GetURI(getter_AddRefs(otherOrigin));
+    }
+
+    return nsScriptSecurityManager::SecurityCompareURIs(origin,
+                                                        otherOrigin,
+                                                        aResult);
+  }
+
+  *aResult = PR_TRUE;
+  return NS_OK;
+}
+
+
+NS_IMETHODIMP
+nsPrincipal::CanEnableCapability(const char *capability, PRInt16 *result)
+{
+  // If this principal is marked invalid, can't enable any capabilities
+  nsCStringKey invalidKey(sInvalid);
+  if (mCapabilities.Exists(&invalidKey)) {
+    *result = nsIPrincipal::ENABLE_DENIED;
+
+    return NS_OK;
+  }
+
+  const char *start = capability;
+  *result = nsIPrincipal::ENABLE_GRANTED;
+  for(;;) {
+    const char *space = PL_strchr(start, ' ');
+    PRInt32 len = space ? space - start : strlen(start);
+    nsCAutoString capString(start, len);
+    nsCStringKey key(capString);
+    PRInt16 value = (PRInt16)NS_PTR_TO_INT32(mCapabilities.Get(&key));
+    if (value == 0) {
+      value = nsIPrincipal::ENABLE_UNKNOWN;
+    }
+
+    if (value < *result) {
+      *result = value;
+    }
+
+    if (!space) {
+      break;
+    }
+
+    start = space + 1;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrincipal::SetCanEnableCapability(const char *capability,
+                                    PRInt16 canEnable)
+{
+  // If this principal is marked invalid, can't enable any capabilities
+
+  nsCStringKey invalidKey(sInvalid);
+  if (mCapabilities.Exists(&invalidKey)) {
+    return NS_OK;
+  }
+
+  if (PL_strcmp(capability, sInvalid) == 0) {
+    mCapabilities.Reset();
+  }
+
+  const char *start = capability;
+  for(;;) {
+    const char *space = PL_strchr(start, ' ');
+    int len = space ? space - start : strlen(start);
+    nsCAutoString capString(start, len);
+    nsCStringKey key(capString);
+    mCapabilities.Put(&key, NS_INT32_TO_PTR(canEnable));
+    if (!space) {
+      break;
+    }
+
+    start = space + 1;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrincipal::IsCapabilityEnabled(const char *capability, void *annotation,
+                                 PRBool *result)
+{
+  *result = PR_FALSE;
+  nsHashtable *ht = (nsHashtable *) annotation;
+  if (!ht) {
+    return NS_OK;
+  }
+  const char *start = capability;
+  for(;;) {
+    const char *space = PL_strchr(start, ' ');
+    int len = space ? space - start : strlen(start);
+    nsCAutoString capString(start, len);
+    nsCStringKey key(capString);
+    *result = (ht->Get(&key) == (void *) AnnotationEnabled);
+    if (!*result) {
+      // If any single capability is not enabled, then return false.
+      return NS_OK;
+    }
+
+    if (!space) {
+      return NS_OK;
+    }
+
+    start = space + 1;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrincipal::EnableCapability(const char *capability, void **annotation)
+{
+  return SetCapability(capability, annotation, AnnotationEnabled);
+}
+
+NS_IMETHODIMP
+nsPrincipal::DisableCapability(const char *capability, void **annotation)
+{
+  return SetCapability(capability, annotation, AnnotationDisabled);
+}
+
+NS_IMETHODIMP
+nsPrincipal::RevertCapability(const char *capability, void **annotation)
+{
+  if (*annotation) {
+    nsHashtable *ht = (nsHashtable *) *annotation;
+    const char *start = capability;
+    for(;;) {
+      const char *space = PL_strchr(start, ' ');
+      int len = space ? space - start : strlen(start);
+      nsCAutoString capString(start, len);
+      nsCStringKey key(capString);
+      ht->Remove(&key);
+      if (!space) {
+        return NS_OK;
+      }
+
+      start = space + 1;
+    }
+  }
+  return NS_OK;
+}
+
+nsresult
+nsPrincipal::SetCapability(const char *capability, void **annotation,
+                           AnnotationValue value)
+{
+  if (*annotation == nsnull) {
+    *annotation = new nsHashtable(5);
+    if (!*annotation) {
+       return NS_ERROR_OUT_OF_MEMORY;
+     }
+
+    // This object owns its annotations. Save them so we can release
+    // them when we destroy this object.
+    mAnnotations.AppendElement(*annotation);
+  }
+
+  const char *start = capability;
+  for(;;) {
+    const char *space = PL_strchr(start, ' ');
+    int len = space ? space - start : strlen(start);
+    nsCAutoString capString(start, len);
+    nsCStringKey key(capString);
+    nsHashtable *ht = (nsHashtable *) *annotation;
+    ht->Put(&key, (void *) value);
+    if (!space) {
+      break;
+    }
+
+    start = space + 1;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrincipal::GetHasCertificate(PRBool* aResult)
+{
+  *aResult = (mCert != nsnull);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrincipal::GetURI(nsIURI** aURI)
+{
+  NS_IF_ADDREF(*aURI = mCodebase);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrincipal::SetURI(nsIURI* aURI)
+{
+  mCodebase = aURI;
+  mDomain = nsnull;
+  // Codebase has changed, forget cached security policy
+  mSecurityPolicy = nsnull;
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrincipal::SetCertificateID(const char* aID)
+{
+  if (!aID) {
+    mCert = nsnull;
+    return NS_OK;
+  }
+
+  if (!mCert) {
+    mCert = new Certificate(aID, "");
+    if (!mCert) {
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrincipal::GetCertificateID(char** aID)
+{
+  NS_ENSURE_STATE(mCert);
+
+  *aID = ToNewCString(mCert->certificateID);
+  if (!*aID) {
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrincipal::GetCommonName(char** aName)
+{
+  NS_ENSURE_STATE(mCert);
+
+  *aName = ToNewCString(mCert->commonName);
+  if (!*aName) {
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrincipal::SetCommonName(const char* aName)
+{
+  if (!mCert) {
+    NS_ERROR("You must first initialize the certificate with an ID");
+    return NS_ERROR_FAILURE;
+  }
+
+  mCert->commonName = aName;
+
+  return NS_OK;
+}
+
+
+NS_IMETHODIMP
+nsPrincipal::GetHashValue(PRUint32* aValue)
+{
+  NS_PRECONDITION(mCert || mCodebase, "Need a cert or codebase");
+
+  // If there is a certificate, it takes precendence over the codebase.
+  if (mCert) {
+    *aValue = nsCRT::HashCode(mCert->certificateID.get(), nsnull);
+  }
+  else {
+    nsCAutoString str;
+    mCodebase->GetSpec(str);
+    *aValue = nsCRT::HashCode(str.get(), nsnull);
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrincipal::GetDomain(nsIURI** aDomain)
+{
+  NS_IF_ADDREF(*aDomain = mDomain);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrincipal::SetDomain(nsIURI* aDomain)
+{
+  mDomain = aDomain;
+  // Domain has changed, forget cached security policy
+  mSecurityPolicy = nsnull;
+
+  return NS_OK;
+}
+
+nsresult
+nsPrincipal::InitFromPersistent(const char* aPrefName,
+                                const char* aToken,
+                                const char* aGrantedList,
+                                const char* aDeniedList,
+                                PRBool aIsCert,
+                                PRBool aTrusted)
+{
+  if (aIsCert) {
+    SetCertificateID(aToken);
+  }
+  else {
+    nsCOMPtr<nsIURI> uri;
+    nsresult rv = NS_NewURI(getter_AddRefs(uri), aToken, nsnull);
+    if (NS_FAILED(rv)) {
+      NS_ERROR("Malformed URI in capability.principal preference.");
+      return rv;
+    }
+
+    nsCAutoString token;
+    rv = uri->GetSpec(token);
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+
+    rv = mJSPrincipals.Init(PL_strdup(token.get()));
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+
+    mTrusted = aTrusted;
+  }
+
+  //-- Empty the capability table
+  mCapabilities.Reset();
+
+  //-- Save the preference name
+  mPrefName = aPrefName;
+
+  const char* ordinalBegin = PL_strpbrk(aPrefName, "1234567890");
+  if (ordinalBegin) {
+    PRIntn n = atoi(ordinalBegin);
+    if (sCapabilitiesOrdinal <= n) {
+      sCapabilitiesOrdinal = n + 1;
+    }
+  }
+
+  //-- Store the capabilities
+  nsresult rv = NS_OK;
+  if (aGrantedList) {
+    rv = SetCanEnableCapability(aGrantedList, nsIPrincipal::ENABLE_GRANTED);
+  }
+
+  if (NS_SUCCEEDED(rv) && aDeniedList) {
+    rv = SetCanEnableCapability(aDeniedList, nsIPrincipal::ENABLE_DENIED);
+  }
+
+  return rv;
+}
+
+struct CapabilityList
+{
+  nsCString* granted;
+  nsCString* denied;
+};
+
+PR_STATIC_CALLBACK(PRBool)
+AppendCapability(nsHashKey *aKey, void *aData, void *capListPtr)
+{
+  CapabilityList* capList = (CapabilityList*)capListPtr;
+  PRInt16 value = (PRInt16)NS_PTR_TO_INT32(aData);
+  nsCStringKey* key = (nsCStringKey *)aKey;
+  if (value == nsIPrincipal::ENABLE_GRANTED) {
+    capList->granted->Append(key->GetString(), key->GetStringLength());
+    capList->granted->Append(' ');
+  }
+  else if (value == nsIPrincipal::ENABLE_DENIED) {
+    capList->denied->Append(key->GetString(), key->GetStringLength());
+    capList->denied->Append(' ');
+  }
+
+  return PR_TRUE;
+}
+
+NS_IMETHODIMP
+nsPrincipal::GetPreferences(char** aPrefName, char** aID,
+                            char** aGrantedList, char** aDeniedList)
+{
+  if (mPrefName.IsEmpty()) {
+    if (mCert) {
+      mPrefName.Assign("capability.principal.certificate.p");
+    }
+    else {
+      mPrefName.Assign("capability.principal.codebase.p");
+    }
+
+    mPrefName.AppendInt(sCapabilitiesOrdinal++);
+    mPrefName.Append(".id");
+  }
+
+  *aPrefName = nsnull;
+  *aID = nsnull;
+  *aGrantedList = nsnull;
+  *aDeniedList = nsnull;
+
+  //-- Preference name
+  *aPrefName = ToNewCString(mPrefName);
+  if (!aPrefName) {
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  //-- ID
+  nsresult rv;
+  if (mCert) {
+    rv = GetCertificateID(aID);
+  }
+  else {
+    rv = GetOrigin(aID);
+  }
+
+  if (NS_FAILED(rv)) {
+    nsMemory::Free(aPrefName);
+    return rv;
+  }
+
+  //-- Capabilities
+  nsCAutoString grantedListStr, deniedListStr;
+  CapabilityList capList = CapabilityList();
+  capList.granted = &grantedListStr;
+  capList.denied = &deniedListStr;
+  mCapabilities.Enumerate(AppendCapability, (void*)&capList);
+
+  if (!grantedListStr.IsEmpty()) {
+    grantedListStr.Truncate(grantedListStr.Length() - 1);
+    *aGrantedList = ToNewCString(grantedListStr);
+    if (!*aGrantedList) {
+      nsMemory::Free(aPrefName);
+      nsMemory::Free(aID);
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+  }
+
+  if (!deniedListStr.IsEmpty()) {
+    deniedListStr.Truncate(deniedListStr.Length() - 1);
+    *aDeniedList = ToNewCString(deniedListStr);
+    if (!*aDeniedList) {
+      nsMemory::Free(aPrefName);
+      nsMemory::Free(aID);
+      if (*aGrantedList) {
+        nsMemory::Free(aGrantedList);
+      }
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+  }
+
+  return NS_OK;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+ReadAnnotationEntry(nsIObjectInputStream* aStream, nsHashKey** aKey,
+                    void** aData)
+{
+  nsresult rv;
+  nsCStringKey* key = new nsCStringKey(aStream, &rv);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  PRUint32 value;
+  rv = aStream->Read32(&value);
+  if (NS_FAILED(rv)) {
+    delete key;
+    return rv;
+  }
+
+  *aKey = key;
+  *aData = (void*) value;
+  return NS_OK;
+}
+
+PR_STATIC_CALLBACK(void)
+FreeAnnotationEntry(nsIObjectInputStream* aStream, nsHashKey* aKey,
+                    void* aData)
+{
+  delete aKey;
+}
+
+NS_IMETHODIMP
+nsPrincipal::Read(nsIObjectInputStream* aStream)
+{
+  PRUint32 annotationCount;
+  nsresult rv = aStream->Read32(&annotationCount);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  for (PRInt32 i = 0, n = PRInt32(annotationCount); i < n; i++) {
+    nsHashtable *ht = new nsHashtable(aStream,
+                                      ReadAnnotationEntry,
+                                      FreeAnnotationEntry,
+                                      &rv);
+    if (!ht) {
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    if (NS_FAILED(rv)) {
+      delete ht;
+      return rv;
+    }
+
+    if (!mAnnotations.InsertElementAt(NS_REINTERPRET_CAST(void*, ht), i)) {
+      delete ht;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+  }
+
+  PRBool hasCapabilities;
+  rv = aStream->ReadBoolean(&hasCapabilities);
+  if (NS_SUCCEEDED(rv) && hasCapabilities) {
+    mCapabilities = nsHashtable(aStream,
+                                ReadAnnotationEntry,
+                                FreeAnnotationEntry,
+                                &rv);
+  }
+
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  rv = NS_ReadOptionalCString(aStream, mPrefName);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  return NS_OK;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+WriteScalarValue(nsIObjectOutputStream* aStream, void* aData)
+{
+  PRUint32 value = NS_PTR_TO_INT32(aData);
+
+  return aStream->Write32(value);
+}
+
+NS_IMETHODIMP
+nsPrincipal::Write(nsIObjectOutputStream* aStream)
+{
+  PRUint32 annotationCount = PRUint32(mAnnotations.Count());
+  nsresult rv = aStream->Write32(annotationCount);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  for (PRInt32 i = 0, n = PRInt32(annotationCount); i < n; i++) {
+    nsHashtable *ht = NS_REINTERPRET_CAST(nsHashtable *, mAnnotations[i]);
+    rv = ht->Write(aStream, WriteScalarValue);
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+  }
+
+  PRBool hasCapabilities = (mCapabilities.Count() > 0);
+  rv = aStream->WriteBoolean(hasCapabilities);
+  if (NS_SUCCEEDED(rv) && hasCapabilities) {
+    rv = mCapabilities.Write(aStream, WriteScalarValue);
+  }
+
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  rv = NS_WriteOptionalStringZ(aStream, mPrefName.get());
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  return NS_OK;
+}
Index: caps/src/nsScriptSecurityManager.cpp
===================================================================
RCS file: /cvsroot/mozilla/caps/src/nsScriptSecurityManager.cpp,v
retrieving revision 1.210
diff -p -u -d -8 -r1.210 nsScriptSecurityManager.cpp
--- caps/src/nsScriptSecurityManager.cpp	27 Jun 2003 03:10:49 -0000	1.210
+++ caps/src/nsScriptSecurityManager.cpp	23 Jul 2003 23:08:59 -0000
@@ -18,17 +18,17 @@
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998-2000
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  * Norris Boyd
  * Mitch Stoltz
  * Steve Morse
- *
+ * Christopher A. Aillon
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the NPL, indicate your
@@ -42,31 +42,29 @@
 #include "nsIServiceManager.h"
 #include "nsIScriptObjectPrincipal.h"
 #include "nsIScriptContext.h"
 #include "nsIURL.h"
 #include "nsIJARURI.h"
 #include "nspr.h"
 #include "nsJSPrincipals.h"
 #include "nsSystemPrincipal.h"
-#include "nsCodebasePrincipal.h"
-#include "nsCertificatePrincipal.h"
-#include "nsAggregatePrincipal.h"
+#include "nsPrincipal.h"
 #include "nsXPIDLString.h"
 #include "nsCRT.h"
 #include "nsIJSContextStack.h"
 #include "nsDOMError.h"
 #include "nsDOMCID.h"
 #include "jsdbgapi.h"
 #include "nsIXPConnect.h"
 #include "nsIXPCSecurityManager.h"
 #include "nsTextFormatter.h"
 #include "nsIStringBundle.h"
 #include "nsNetUtil.h"
-#include "nsDirectoryService.h"
+#include "nsIProperties.h"
 #include "nsDirectoryServiceDefs.h"
 #include "nsIFile.h"
 #include "nsIZipReader.h"
 #include "nsIJAR.h"
 #include "nsIPluginInstance.h"
 #include "nsIXPConnect.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIDOMWindowInternal.h"
@@ -75,23 +73,22 @@
 #include "nsIPrompt.h"
 #include "nsIWindowWatcher.h"
 #include "nsIConsoleService.h"
 #include "nsISecurityCheckedComponent.h"
 #include "nsIPrefBranchInternal.h"
 #include "nsIJSRuntimeService.h"
 #include "nsIObserverService.h"
 #include "nsIContent.h"
+#include "nsAutoPtr.h"
 
-static NS_DEFINE_IID(kIStringBundleServiceIID, NS_ISTRINGBUNDLESERVICE_IID);
-static NS_DEFINE_IID(kStringBundleServiceCID, NS_STRINGBUNDLESERVICE_CID);
-static NS_DEFINE_CID(kCScriptNameSetRegistryCID,
-                     NS_SCRIPT_NAMESET_REGISTRY_CID);
 static NS_DEFINE_CID(kZipReaderCID, NS_ZIPREADER_CID);
-static NS_DEFINE_IID(kObserverServiceIID, NS_IOBSERVERSERVICE_IID);
+
+nsIIOService* nsScriptSecurityManager::sIOService = nsnull;
+nsIXPConnect* nsScriptSecurityManager::sXPConnect = nsnull;
 
 ///////////////////////////
 // Convenience Functions //
 ///////////////////////////
 // Result of this function should not be freed.
 static inline const PRUnichar *
 JSValIDToString(JSContext *cx, const jsval idval)
 {
@@ -111,18 +108,20 @@ GetScriptContext(JSContext *cx)
 }
 
 // Helper class to get stuff from the ClassInfo and not waste extra time with
 // virtual method calls for things it has already gotten
 class ClassInfoData
 {
 public:
     ClassInfoData(nsIClassInfo *aClassInfo, const char *aName)
-        : mClassInfo(aClassInfo), mDidGetFlags(PR_FALSE),
-          mName(NS_CONST_CAST(char *, aName)), mMustFreeName(PR_FALSE)
+        : mClassInfo(aClassInfo),
+          mName(NS_CONST_CAST(char *, aName)),
+          mDidGetFlags(PR_FALSE),
+          mMustFreeName(PR_FALSE)
     {
     }
 
     ~ClassInfoData()
     {
         if (mMustFreeName)
             nsMemory::Free(mName);
     }
@@ -169,20 +168,20 @@ public:
             }
         }
 
         return mName;
     }
 
 private:
     nsIClassInfo *mClassInfo; // WEAK
-    PRBool mDidGetFlags;
     PRUint32 mFlags;
     char *mName;
-    PRBool mMustFreeName;
+    PRPackedBool mDidGetFlags;
+    PRPackedBool mMustFreeName;
 };
  
 JSContext *
 nsScriptSecurityManager::GetCurrentJSContext()
 {
     // Get JSContext from stack.
     if (!mJSContextStack)
     {
@@ -215,25 +214,25 @@ nsScriptSecurityManager::GetSafeJSContex
 /* Static function for comparing two URIs - for security purposes,
  * two URIs are equivalent if their scheme, host, and port are equal.
  */
 /*static*/ nsresult
 nsScriptSecurityManager::SecurityCompareURIs(nsIURI* aSourceURI,
                                              nsIURI* aTargetURI,
                                              PRBool* result)
 {
-    nsresult rv;
     *result = PR_FALSE;
 
     if (aSourceURI == aTargetURI)
     {
         *result = PR_TRUE;
         return NS_OK;
     }
-    if (aTargetURI == nsnull) 
+
+    if (!aTargetURI) 
     {
         // return false
         return NS_OK;
     }
 
     // If either uri is a jar URI, get the base URI
     nsCOMPtr<nsIJARURI> jarURI;
     nsCOMPtr<nsIURI> sourceBaseURI(aSourceURI);
@@ -247,35 +246,30 @@ nsScriptSecurityManager::SecurityCompare
         jarURI->GetJARFile(getter_AddRefs(targetBaseURI));
     }
 
     if (!sourceBaseURI || !targetBaseURI)
         return NS_ERROR_FAILURE;
 
     // Compare schemes
     nsCAutoString targetScheme;
-    rv = targetBaseURI->GetScheme(targetScheme);
+    nsresult rv = targetBaseURI->GetScheme(targetScheme);
     nsCAutoString sourceScheme;
     if (NS_SUCCEEDED(rv))
         rv = sourceBaseURI->GetScheme(sourceScheme);
-    if (NS_SUCCEEDED(rv) && 
-        targetScheme.Equals(sourceScheme, nsCaseInsensitiveCStringComparator())) 
+    if (NS_SUCCEEDED(rv) && targetScheme.Equals(sourceScheme))
     {
-        if (targetScheme.Equals(NS_LITERAL_CSTRING("file"),
-            nsCaseInsensitiveCStringComparator()))
+        if (targetScheme.Equals(NS_LITERAL_CSTRING("file")))
         {
             // All file: urls are considered to have the same origin.
             *result = PR_TRUE;
         }
-        else if (targetScheme.Equals(NS_LITERAL_CSTRING("imap"),
-                                     nsCaseInsensitiveCStringComparator()) ||
-                 targetScheme.Equals(NS_LITERAL_CSTRING("mailbox"),
-                                     nsCaseInsensitiveCStringComparator()) ||
-                 targetScheme.Equals(NS_LITERAL_CSTRING("news"),
-                                     nsCaseInsensitiveCStringComparator()))
+        else if (targetScheme.Equals(NS_LITERAL_CSTRING("imap")) ||
+                 targetScheme.Equals(NS_LITERAL_CSTRING("mailbox")) ||
+                 targetScheme.Equals(NS_LITERAL_CSTRING("news")))
         {
             // Each message is a distinct trust domain; use the 
             // whole spec for comparison
             nsCAutoString targetSpec;
             if (NS_FAILED(targetBaseURI->GetSpec(targetSpec)))
                 return NS_ERROR_FAILURE;
             nsCAutoString sourceSpec;
             if (NS_FAILED(sourceBaseURI->GetSpec(sourceSpec)))
@@ -302,44 +296,32 @@ nsScriptSecurityManager::SecurityCompare
                 if (NS_SUCCEEDED(rv))
                     rv = sourceBaseURI->GetPort(&sourcePort);
                 *result = NS_SUCCEEDED(rv) && targetPort == sourcePort;
                 // If the port comparison failed, see if either URL has a
                 // port of -1. If so, replace -1 with the default port
                 // for that scheme.
                 if (!*result && (sourcePort == -1 || targetPort == -1))
                 {
+                    NS_ENSURE_STATE(sIOService);
+
                     PRInt32 defaultPort;
-                    //XXX had to hard-code the defualt port for http(s) here.
-                    //    remove this after darin fixes bug 113206
-                    if (sourceScheme.Equals(NS_LITERAL_CSTRING("http"),
-                                            nsCaseInsensitiveCStringComparator()))
-                        defaultPort = 80;
-                    else if (sourceScheme.Equals(NS_LITERAL_CSTRING("https"),
-                                                 nsCaseInsensitiveCStringComparator()))
-                        defaultPort = 443;
-                    else
+                    nsCOMPtr<nsIProtocolHandler> protocolHandler;
+                    rv = sIOService->GetProtocolHandler(sourceScheme.get(),
+                                                        getter_AddRefs(protocolHandler));
+                    if (NS_FAILED(rv))
                     {
-                        nsCOMPtr<nsIIOService> ioService(
-                            do_GetService(NS_IOSERVICE_CONTRACTID));
-                        if (!ioService)
-                            return NS_ERROR_FAILURE;
-                        nsCOMPtr<nsIProtocolHandler> protocolHandler;
-                        rv = ioService->GetProtocolHandler(sourceScheme.get(),
-                                                           getter_AddRefs(protocolHandler));
-                        if (NS_FAILED(rv))
-                        {
-                            *result = PR_FALSE;
-                            return NS_OK;
-                        }
-                    
-                        rv = protocolHandler->GetDefaultPort(&defaultPort);
-                        if (NS_FAILED(rv) || defaultPort == -1)
-                            return NS_OK; // No default port for this scheme
+                        *result = PR_FALSE;
+                        return NS_OK;
                     }
+                    
+                    rv = protocolHandler->GetDefaultPort(&defaultPort);
+                    if (NS_FAILED(rv) || defaultPort == -1)
+                        return NS_OK; // No default port for this scheme
+
                     if (sourcePort == -1)
                         sourcePort = defaultPort;
                     else if (targetPort == -1)
                         targetPort = defaultPort;
                     *result = targetPort == sourcePort;
                 }
             }
         }
@@ -529,37 +511,31 @@ nsScriptSecurityManager::CheckSameOrigin
         return rv;
 
     if (!sourcePrincipal)
     {
         NS_WARNING("CheckSameOrigin called on script w/o principals; should this happen?");
         return NS_OK;
     }
 
-    PRBool equals = PR_FALSE;
-    rv = sourcePrincipal->Equals(mSystemPrincipal, &equals);
-    if (NS_SUCCEEDED(rv) && equals)
+    if (sourcePrincipal == mSystemPrincipal)
     {
         // This is a system (chrome) script, so allow access
         return NS_OK;
     }
 
     // Get the original URI from the source principal.
     // This has the effect of ignoring any change to document.domain
     // which must be done to avoid DNS spoofing (bug 154930)
-    nsCOMPtr<nsIAggregatePrincipal> sourceAgg(do_QueryInterface(sourcePrincipal, &rv));
-    NS_ENSURE_SUCCESS(rv, rv); // If it's not a system principal, it must be an aggregate
-    nsCOMPtr<nsIPrincipal> sourceOriginal;
-    rv = sourceAgg->GetOriginalCodebase(getter_AddRefs(sourceOriginal));
-    NS_ENSURE_SUCCESS(rv, rv);
-    nsCOMPtr<nsICodebasePrincipal> sourceCodebase(do_QueryInterface(sourcePrincipal, &rv));
-    NS_ENSURE_SUCCESS(rv, rv);
     nsCOMPtr<nsIURI> sourceURI;
-    rv = sourceCodebase->GetURI(getter_AddRefs(sourceURI));
-    NS_ENSURE_TRUE(sourceURI, NS_ERROR_FAILURE);
+    sourcePrincipal->GetDomain(getter_AddRefs(sourceURI));
+    if (!sourceURI) {
+      sourcePrincipal->GetURI(getter_AddRefs(sourceURI));
+      NS_ENSURE_TRUE(sourceURI, NS_ERROR_FAILURE);
+    }
 
     // Compare origins
     PRBool sameOrigin = PR_FALSE;
     rv = SecurityCompareURIs(sourceURI, aTargetURI, &sameOrigin);
     NS_ENSURE_SUCCESS(rv, rv);
 
     if (!sameOrigin)
     {
@@ -605,27 +581,25 @@ nsScriptSecurityManager::CheckPropertyAc
                                                  nsIClassInfo* aClassInfo,
                                                  const char* aClassName, jsval aProperty,
                                                  void** aCachedClassPolicy)
 {
     nsCOMPtr<nsIPrincipal> subjectPrincipal;
     if (NS_FAILED(GetSubjectPrincipal(cx, getter_AddRefs(subjectPrincipal))))
         return NS_ERROR_FAILURE;
 
-    PRBool equals;
-    if (!subjectPrincipal ||
-        NS_SUCCEEDED(subjectPrincipal->Equals(mSystemPrincipal, &equals)) && equals)
+    if (!subjectPrincipal || subjectPrincipal == mSystemPrincipal)
         // We have native code or the system principal: just allow access
         return NS_OK;
 
     nsresult rv;
     // Hold the class info data here so we don't have to go back to virtual
     // methods all the time
     ClassInfoData classInfoData(aClassInfo, aClassName);
-#ifdef DEBUG_mstoltz
+#ifdef DEBUG_CAPS_CheckPropertyAccessImpl
     nsCAutoString propertyName;
     propertyName.AssignWithConversion((PRUnichar*)JSValIDToString(cx, aProperty));
     printf("### CanAccess(%s.%s, %i) ", classInfoData.GetName(), 
            propertyName.get(), aAction);
 #endif
 
     //-- Look up the security policy for this class and subject domain
     SecurityLevel securityLevel;
@@ -647,32 +621,32 @@ nsScriptSecurityManager::CheckPropertyAc
     }
 
     if (SECURITY_ACCESS_LEVEL_FLAG(securityLevel))
     // This flag means securityLevel is allAccess, noAccess, or sameOrigin
     {
         switch (securityLevel.level)
         {
         case SCRIPT_SECURITY_NO_ACCESS:
-#ifdef DEBUG_mstoltz
+#ifdef DEBUG_CAPS_CheckPropertyAccessImpl
             printf("noAccess ");
 #endif
             rv = NS_ERROR_DOM_PROP_ACCESS_DENIED;
             break;
 
         case SCRIPT_SECURITY_ALL_ACCESS:
-#ifdef DEBUG_mstoltz
+#ifdef DEBUG_CAPS_CheckPropertyAccessImpl
             printf("allAccess ");
 #endif
             rv = NS_OK;
             break;
 
         case SCRIPT_SECURITY_SAME_ORIGIN_ACCESS:
             {
-#ifdef DEBUG_mstoltz
+#ifdef DEBUG_CAPS_CheckPropertyAccessImpl
                 printf("sameOrigin ");
 #endif
                 nsCOMPtr<nsIPrincipal> objectPrincipal;
                 if(aJSObject)
                 {
                     rv = doGetObjectPrincipal(cx,
                                               NS_REINTERPRET_CAST(JSObject*,
                                                                   aJSObject),
@@ -691,26 +665,26 @@ nsScriptSecurityManager::CheckPropertyAc
                     NS_ERROR("CheckPropertyAccessImpl called without a target object or URL");
                     return NS_ERROR_FAILURE;
                 }
                 rv = CheckSameOriginDOMProp(subjectPrincipal, objectPrincipal,
                                             aAction, (PRBool)aTargetURI);
                 break;
             }
         default:
-#ifdef DEBUG_mstoltz
+#ifdef DEBUG_CAPS_CheckPropertyAccessImpl
                 printf("ERROR ");
 #endif
             NS_ERROR("Bad Security Level Value");
             return NS_ERROR_FAILURE;
         }
     }
     else // if SECURITY_ACCESS_LEVEL_FLAG is false, securityLevel is a capability
     {
-#ifdef DEBUG_mstoltz
+#ifdef DEBUG_CAPS_CheckPropertyAccessImpl
         printf("Cap:%s ", securityLevel.capability);
 #endif
         PRBool capabilityEnabled = PR_FALSE;
         rv = IsCapabilityEnabled(securityLevel.capability, &capabilityEnabled);
         if (NS_FAILED(rv) || !capabilityEnabled)
             rv = NS_ERROR_DOM_SECURITY_ERR;
         else
             rv = NS_OK;
@@ -724,17 +698,17 @@ nsScriptSecurityManager::CheckPropertyAc
                               "implement nsIContent!  Fasten your seat belt.");
         if (content->IsNativeAnonymous()) {
             rv = NS_ERROR_DOM_SECURITY_ERR;
         }
     }
 
     if (NS_SUCCEEDED(rv))
     {
-#ifdef DEBUG_mstoltz
+#ifdef DEBUG_CAPS_CheckPropertyAccessImpl
     printf(" GRANTED.\n");
 #endif
         return rv;
     }
 
     //--See if the object advertises a non-default level of access
     //  using nsISecurityCheckedComponent
     nsCOMPtr<nsISecurityCheckedComponent> checkedComponent =
@@ -768,26 +742,25 @@ nsScriptSecurityManager::CheckPropertyAc
             case nsIXPCSecurityManager::ACCESS_CALL_METHOD:
                 checkedComponent->CanCallMethod(objIID,
                                                 JSValIDToString(cx, aProperty),
                                                 getter_Copies(objectSecurityLevel));
             }
         }
     }
     rv = CheckXPCPermissions(aObj, objectSecurityLevel);
-#ifdef DEBUG_mstoltz
+#ifdef DEBUG_CAPS_CheckPropertyAccessImpl
     if(NS_SUCCEEDED(rv))
         printf("CheckXPCPerms GRANTED.\n");
     else
         printf("CheckXPCPerms DENIED.\n");
 #endif
 
     if (NS_FAILED(rv)) //-- Security tests failed, access is denied, report error
     {
-        //XXX Clean up string usage here too
         nsCAutoString errorMsg("Permission denied to ");
         switch(aAction)
         {
         case nsIXPCSecurityManager::ACCESS_GET_PROPERTY:
             errorMsg += "get property ";
             break;
         case nsIXPCSecurityManager::ACCESS_SET_PROPERTY:
             errorMsg += "set property ";
@@ -796,21 +769,20 @@ nsScriptSecurityManager::CheckPropertyAc
             errorMsg += "call method ";
         }
         errorMsg += classInfoData.GetName();
         errorMsg += '.';
         errorMsg.AppendWithConversion((PRUnichar*)JSValIDToString(cx, aProperty));
 
         JS_SetPendingException(cx,
                                STRING_TO_JSVAL(JS_NewStringCopyZ(cx, errorMsg.get())));
-        nsCOMPtr<nsIXPConnect> xpc = do_GetService(nsIXPConnect::GetCID());
-        if (xpc)
+        if (sXPConnect)
         {
             nsCOMPtr<nsIXPCNativeCallContext> xpcCallContext;
-            xpc->GetCurrentNativeCallContext(getter_AddRefs(xpcCallContext));
+            sXPConnect->GetCurrentNativeCallContext(getter_AddRefs(xpcCallContext));
             if (xpcCallContext)
                 xpcCallContext->SetExceptionWasThrown(PR_TRUE);
         }
     }
 
     return rv;
 }
 
@@ -820,59 +792,62 @@ nsScriptSecurityManager::CheckSameOrigin
                                                           PRBool aIsCheckConnect)
 {
     /*
     ** Get origin of subject and object and compare.
     */
     if (aSubject == aObject)
         return NS_OK;
 
+    nsCOMPtr<nsIURI> subjectURI;
+    nsCOMPtr<nsIURI> objectURI;
+    aSubject->GetDomain(getter_AddRefs(subjectURI));
+    if (!subjectURI) {
+      aSubject->GetURI(getter_AddRefs(subjectURI));
+    }
+
+    aObject->GetDomain(getter_AddRefs(objectURI));
+    if (!objectURI) {
+      aObject->GetURI(getter_AddRefs(objectURI));
+    }
+
     PRBool isSameOrigin = PR_FALSE;
-    nsresult rv = aSubject->Equals(aObject, &isSameOrigin);
+    nsresult rv = SecurityCompareURIs(subjectURI, objectURI, &isSameOrigin);
     NS_ENSURE_SUCCESS(rv, rv);
 
     if (isSameOrigin)
     {   // If either the subject or the object has changed its principal by
         // explicitly setting document.domain then the other must also have
         // done so in order to be considered the same origin. This prevents
         // DNS spoofing based on document.domain (154930)
 
         // But this restriction does not apply to CheckConnect calls, since
         // that's called for data-only load checks like XMLHTTPRequest, where
         // the target document has not yet loaded and can't have set its domain
         // (bug 163950)
         if (aIsCheckConnect)
             return NS_OK;
 
-        nsCOMPtr<nsIAggregatePrincipal> subjectAgg(do_QueryInterface(aSubject, &rv));
-        NS_ENSURE_SUCCESS(rv, rv);
-        PRBool subjectDomainChanged = PR_FALSE;
-        subjectAgg->GetDomainChanged(&subjectDomainChanged);
+        nsCOMPtr<nsIURI> subjectDomain;
+        aSubject->GetDomain(getter_AddRefs(subjectDomain));
 
-        nsCOMPtr<nsIAggregatePrincipal> objectAgg(do_QueryInterface(aObject, &rv));
-        NS_ENSURE_SUCCESS(rv, rv);
-        PRBool objectDomainChanged = PR_FALSE;
-        objectAgg->GetDomainChanged(&objectDomainChanged);
+        nsCOMPtr<nsIURI> objectDomain;
+        aObject->GetDomain(getter_AddRefs(objectDomain));
 
         // If both or neither explicitly set their domain, allow the access
-        if (!(subjectDomainChanged || objectDomainChanged) ||
-            (subjectDomainChanged && objectDomainChanged))
+        if (!subjectDomain == !objectDomain)
             return NS_OK;
     }
 
     // Allow access to about:blank
-    nsCOMPtr<nsICodebasePrincipal> objectCodebase(do_QueryInterface(aObject));
-    if (objectCodebase)
-    {
-        nsXPIDLCString origin;
-        rv = objectCodebase->GetOrigin(getter_Copies(origin));
-        NS_ENSURE_SUCCESS(rv, rv);
-        if (nsCRT::strcasecmp(origin, "about:blank") == 0)
-            return NS_OK;
-    }
+    nsXPIDLCString origin;
+    rv = aObject->GetOrigin(getter_Copies(origin));
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (nsCRT::strcasecmp(origin, "about:blank") == 0)
+        return NS_OK;
 
     /*
     ** Access tests failed, so now report error.
     */
     return NS_ERROR_DOM_PROP_ACCESS_DENIED;
 }
 
 
@@ -923,34 +898,27 @@ nsScriptSecurityManager::LookupPolicy(ns
     if (mPolicyPrefsChanged)
     {
         rv = InitPolicies();
         if (NS_FAILED(rv))
             return rv;
     }
 
     DomainPolicy* dpolicy = nsnull;
-    nsCOMPtr<nsIAggregatePrincipal> agg(do_QueryInterface(aPrincipal));
-    NS_ASSERTION(agg, "Subject principal not an aggregate - this shouldn't happen");
-    if (agg)
-        agg->GetCachedSecurityPolicy((void**)&dpolicy);
+    aPrincipal->GetSecurityPolicy((void**)&dpolicy);
 
     if (!dpolicy && mOriginToPolicyMap)
     {
         //-- Look up the relevant domain policy, if any
-#ifdef DEBUG_mstoltz
+#ifdef DEBUG_CAPS_LookupPolicy
         printf("DomainLookup ");
 #endif
 
-        nsCOMPtr<nsICodebasePrincipal> codebase(do_QueryInterface(aPrincipal));
-        if (!codebase)
-            return NS_ERROR_FAILURE;
-
         nsXPIDLCString origin;
-        if (NS_FAILED(rv = codebase->GetOrigin(getter_Copies(origin))))
+        if (NS_FAILED(rv = aPrincipal->GetOrigin(getter_Copies(origin))))
             return rv;
  
         const char *start = origin;
         const char *nextToLastDot = nsnull;
         const char *lastDot = nsnull;
         const char *colon = nsnull;
         const char *p = start;
         while (*p)
@@ -982,31 +950,31 @@ nsScriptSecurityManager::LookupPolicy(ns
                 break;
             }
             de = de->mNext;
         }
 
         if (!dpolicy)
             dpolicy = mDefaultPolicy;
 
-        agg->SetCachedSecurityPolicy((void*)dpolicy);
+        aPrincipal->SetSecurityPolicy((void*)dpolicy);
     }
 
     ClassPolicy* cpolicy = nsnull;
 
     if ((dpolicy == mDefaultPolicy) && aCachedClassPolicy)
     {
         // No per-domain policy for this principal (the more common case)
         // so look for a cached class policy from the object wrapper
         cpolicy = *aCachedClassPolicy;
     }
 
     if (!cpolicy)
     { //-- No cached policy for this class, need to look it up
-#ifdef DEBUG_mstoltz
+#ifdef DEBUG_CAPS_LookupPolicy
         printf("ClassLookup ");
 #endif
 
         cpolicy = NS_REINTERPRET_CAST(ClassPolicy*,
                                       PL_DHashTableOperate(dpolicy,
                                                            aClassName,
                                                            PL_DHASH_LOOKUP));
 
@@ -1077,29 +1045,23 @@ nsScriptSecurityManager::CheckLoadURIFro
     if (NS_FAILED(GetSubjectPrincipal(cx, getter_AddRefs(principal))))
         return NS_ERROR_FAILURE;
 
     // Native code can load all URIs.
     if (!principal)
         return NS_OK;
 
     // The system principal can load all URIs.
-    PRBool equals = PR_FALSE;
-    if (NS_FAILED(principal->Equals(mSystemPrincipal, &equals)))
-        return NS_ERROR_FAILURE;
-    if (equals)
+    if (principal == mSystemPrincipal)
         return NS_OK;
 
-    // Otherwise, principal should have a codebase that we can use to
+    // Otherwise, principal should have a codebase URI that we can use to
     // do the remaining tests.
-    nsCOMPtr<nsICodebasePrincipal> codebase(do_QueryInterface(principal));
-    if (!codebase)
-        return NS_ERROR_FAILURE;
     nsCOMPtr<nsIURI> uri;
-    if (NS_FAILED(codebase->GetURI(getter_AddRefs(uri))))
+    if (NS_FAILED(principal->GetURI(getter_AddRefs(uri))))
         return NS_ERROR_FAILURE;
     if (NS_SUCCEEDED(CheckLoadURI(uri, aURI, nsIScriptSecurityManager::STANDARD )))
         return NS_OK;
 
     // See if we're attempting to load a file: URI. If so, let a
     // UniversalFileRead capability trump the above check.
     PRBool isFile = PR_FALSE;
     PRBool isRes = PR_FALSE;
@@ -1138,17 +1100,17 @@ nsScriptSecurityManager::GetBaseURISchem
     if (NS_FAILED(rv)) return rv;
 
     //-- If uri is a view-source URI, drill down to the base URI
     nsCAutoString path;
     while(PL_strcmp(scheme.get(), "view-source") == 0)
     {
         rv = uri->GetPath(path);
         if (NS_FAILED(rv)) return rv;
-        rv = NS_NewURI(getter_AddRefs(uri), path, nsnull);
+        rv = NS_NewURI(getter_AddRefs(uri), path, nsnull, nsnull, sIOService);
         if (NS_FAILED(rv)) return rv;
         rv = uri->GetScheme(scheme);
         if (NS_FAILED(rv)) return rv;
     }
 
     //-- If uri is a jar URI, drill down again
     nsCOMPtr<nsIJARURI> jarURI;
     PRBool isJAR = PR_FALSE;
@@ -1316,17 +1278,17 @@ nsresult
 nsScriptSecurityManager::ReportError(JSContext* cx, const nsAString& messageTag,
                                      nsIURI* aSource, nsIURI* aTarget)
 {
     nsresult rv;
     NS_ENSURE_TRUE(aSource && aTarget, NS_ERROR_NULL_POINTER);
 
     // First, create the error message text
     // create a bundle for the localization
-    nsCOMPtr<nsIStringBundleService> bundleService(do_GetService(kStringBundleServiceCID, &rv));
+    nsCOMPtr<nsIStringBundleService> bundleService(do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv));
     NS_ENSURE_SUCCESS(rv, rv);
 
     nsCOMPtr<nsIStringBundle> bundle;
     rv = bundleService->CreateBundle(PROPERTIES_URL, getter_AddRefs(bundle));
     NS_ENSURE_SUCCESS(rv, rv);
 
     // Get the source URL spec
     nsCAutoString sourceSpec;
@@ -1353,21 +1315,20 @@ nsScriptSecurityManager::ReportError(JSC
     // Otherwise, print the error message directly to the JS console
     // and to standard output
     if (cx)
     {
         JS_SetPendingException(cx,
             STRING_TO_JSVAL(JS_NewUCStringCopyZ(cx,
                 NS_REINTERPRET_CAST(const jschar*, message.get()))));
         // Tell XPConnect that an exception was thrown, if appropriate
-        nsCOMPtr<nsIXPConnect> xpc = do_GetService(nsIXPConnect::GetCID());
-        if (xpc)
+        if (sXPConnect)
         {
             nsCOMPtr<nsIXPCNativeCallContext> xpcCallContext;
-            xpc->GetCurrentNativeCallContext(getter_AddRefs(xpcCallContext));
+            sXPConnect->GetCurrentNativeCallContext(getter_AddRefs(xpcCallContext));
              if (xpcCallContext)
                 xpcCallContext->SetExceptionWasThrown(PR_TRUE);
         }
     }
     else // Print directly to the console
     {
         nsCOMPtr<nsIConsoleService> console(
             do_GetService("@mozilla.org/consoleservice;1"));
@@ -1381,20 +1342,24 @@ nsScriptSecurityManager::ReportError(JSC
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsScriptSecurityManager::CheckLoadURIStr(const char* aSourceURIStr, const char* aTargetURIStr,
                                          PRUint32 aFlags)
 {
     nsCOMPtr<nsIURI> source;
-    nsresult rv = NS_NewURI(getter_AddRefs(source), nsDependentCString(aSourceURIStr), nsnull);
+    nsresult rv = NS_NewURI(getter_AddRefs(source),
+                            nsDependentCString(aSourceURIStr),
+                            nsnull, nsnull, sIOService);
     NS_ENSURE_SUCCESS(rv, rv);
     nsCOMPtr<nsIURI> target;
-    rv = NS_NewURI(getter_AddRefs(target), nsDependentCString(aTargetURIStr), nsnull);
+    rv = NS_NewURI(getter_AddRefs(target),
+                   nsDependentCString(aTargetURIStr),
+                   nsnull, nsnull, sIOService);
     NS_ENSURE_SUCCESS(rv, rv);
     return CheckLoadURI(source, target, aFlags);
 }
 
 NS_IMETHODIMP
 nsScriptSecurityManager::CheckFunctionAccess(JSContext *aCx, void *aFunObj,
                                              void *aTargetObj)
 {
@@ -1418,18 +1383,17 @@ nsScriptSecurityManager::CheckFunctionAc
         rv = doGetObjectPrincipal(aCx, (JSObject*)aFunObj,
                                   getter_AddRefs(subject));
     }
 
     if (NS_FAILED(rv)) return rv;
     if (!subject) return NS_ERROR_FAILURE;
 
 
-    PRBool isSystem;
-    if (NS_SUCCEEDED(subject->Equals(mSystemPrincipal, &isSystem)) && isSystem)
+    if (subject == mSystemPrincipal)
         // This is the system principal: just allow access
         return NS_OK;
 
     // Check if the principal the function was compiled under is
     // allowed to execute scripts.
 
     PRBool result;
     rv = CanExecuteScripts(aCx, subject, &result);
@@ -1444,38 +1408,17 @@ nsScriptSecurityManager::CheckFunctionAc
     */
     JSObject* obj = (JSObject*)aTargetObj;
     nsCOMPtr<nsIPrincipal> object;
     if (NS_FAILED(doGetObjectPrincipal(aCx, obj, getter_AddRefs(object))))
         return NS_ERROR_FAILURE;
     if (subject == object)
         return NS_OK;
 
-    PRBool isSameOrigin = PR_FALSE;
-    if (NS_FAILED(subject->Equals(object, &isSameOrigin)))
-        return NS_ERROR_FAILURE;
-
-    if (isSameOrigin)
-        return NS_OK;
-
-    // Allow access to about:blank
-    nsCOMPtr<nsICodebasePrincipal> objectCodebase(do_QueryInterface(object));
-    if (objectCodebase)
-    {
-        nsXPIDLCString origin;
-        if (NS_FAILED(objectCodebase->GetOrigin(getter_Copies(origin))))
-            return NS_ERROR_FAILURE;
-        if (nsCRT::strcasecmp(origin, "about:blank") == 0)
-            return NS_OK;
-    }
-
-    /*
-    ** Access tests failed.  Fail silently without a JS exception.
-    */
-    return NS_ERROR_DOM_SECURITY_ERR;
+    return CheckSameOriginPrincipalInternal(subject, object, PR_TRUE);
 }
 
 nsresult
 nsScriptSecurityManager::GetRootDocShell(JSContext *cx, nsIDocShell **result)
 {
     nsresult rv;
     *result = nsnull;
     nsCOMPtr<nsIDocShell> docshell;
@@ -1507,95 +1450,86 @@ nsScriptSecurityManager::CanExecuteScrip
         // Even if JavaScript is disabled, we must still execute system scripts
         *result = PR_TRUE;
         return NS_OK;
     }
 
     //-- Always allow chrome pages to run scripts
     //   This is for about: URLs, which are chrome but don't
     //   have the system principal
-    nsresult rv;
     if (!mIsJavaScriptEnabled)
     {
-        nsCOMPtr<nsICodebasePrincipal> codebase(do_QueryInterface(aPrincipal));
-        if (codebase)
+        nsCOMPtr<nsIURI> principalURI;
+        aPrincipal->GetURI(getter_AddRefs(principalURI));
+        if (principalURI)
         {
-            nsXPIDLCString origin;
-            rv = codebase->GetOrigin(getter_Copies(origin));
-            static const char chromePrefix[] = "chrome:";
-            if (NS_SUCCEEDED(rv) &&
-                (PL_strncmp(origin, chromePrefix, sizeof(chromePrefix)-1) == 0))
+            PRBool isChrome = PR_FALSE;
+            principalURI->SchemeIs("chrome", &isChrome);
+            if (isChrome)
             {
                 *result = PR_TRUE;
-                return NS_OK;
+                return NS_OK;              
             }
         }
     }
 
     //-- See if the current window allows JS execution
     nsCOMPtr<nsIScriptContext> scriptContext = GetScriptContext(cx);
     if (!scriptContext) return NS_ERROR_FAILURE;
     nsCOMPtr<nsIScriptGlobalObject> globalObject;
     scriptContext->GetGlobalObject(getter_AddRefs(globalObject));
     if (!globalObject) return NS_ERROR_FAILURE;
     
+    nsresult rv;
     nsCOMPtr<nsIDocShell> docshell;
     globalObject->GetDocShell(getter_AddRefs(docshell));
-    nsCOMPtr<nsIDocShellTreeItem> treeItem;
-    if (docshell) 
+    nsCOMPtr<nsIDocShellTreeItem> globalObjTreeItem = do_QueryInterface(docshell);
+    if (globalObjTreeItem) 
     {
-        treeItem = do_QueryInterface(docshell);
+        nsCOMPtr<nsIDocShellTreeItem> treeItem(globalObjTreeItem);
         nsCOMPtr<nsIDocShellTreeItem> parentItem;
+
         // Walk up the docshell tree to see if any containing docshell disallows scripts
-        do 
+        do
         {
             rv = docshell->GetAllowJavascript(result);
             if (NS_FAILED(rv)) return rv;
             if (!*result)
                 return NS_OK; // Do not run scripts
-            if (treeItem) 
-            {
-                treeItem->GetParent(getter_AddRefs(parentItem));
-                if (parentItem)
-                {
-                    treeItem = parentItem;
-                    docshell = do_QueryInterface(treeItem, &rv);
-                    NS_ASSERTION(docshell, "cannot get a docshell from a treeItem!");
-                    if (NS_FAILED(rv)) break;
-                }
+            treeItem->GetParent(getter_AddRefs(parentItem));
+            treeItem.swap(parentItem);
+            docshell = do_QueryInterface(treeItem);
+#ifdef DEBUG
+            if (treeItem && !docshell) {
+              NS_ERROR("cannot get a docshell from a treeItem!");
             }
-        } while (parentItem);
+#endif // DEBUG
+        } while (treeItem && docshell);
     }
 
     //-- See if JS is disabled globally (via prefs)
     *result = mIsJavaScriptEnabled;
-    if (mIsJavaScriptEnabled != mIsMailJavaScriptEnabled) 
+    if (mIsJavaScriptEnabled != mIsMailJavaScriptEnabled && globalObjTreeItem) 
     {
-        // Get docshell from the global window again.
-        globalObject->GetDocShell(getter_AddRefs(docshell));
-        treeItem = do_QueryInterface(docshell);
-        if (treeItem) 
+        nsCOMPtr<nsIDocShellTreeItem> rootItem;
+        globalObjTreeItem->GetRootTreeItem(getter_AddRefs(rootItem));
+        docshell = do_QueryInterface(rootItem);
+        if (docshell) 
         {
-            nsCOMPtr<nsIDocShellTreeItem> rootItem;
-            treeItem->GetRootTreeItem(getter_AddRefs(rootItem));
-            docshell = do_QueryInterface(rootItem);
-            if (docshell) 
+            // Is this script running from mail?
+            PRUint32 appType;
+            rv = docshell->GetAppType(&appType);
+            if (NS_FAILED(rv)) return rv;
+            if (appType == nsIDocShell::APP_TYPE_MAIL) 
             {
-                // Is this script running from mail?
-                PRUint32 appType;
-                rv = docshell->GetAppType(&appType);
-                if (NS_FAILED(rv)) return rv;
-                if (appType == nsIDocShell::APP_TYPE_MAIL) 
-                {
-                    *result = mIsMailJavaScriptEnabled;
-                }
+                *result = mIsMailJavaScriptEnabled;
             }
         }
     }
-    
+
     if (!*result)
         return NS_OK; // Do not run scripts
 
     //-- Check for a per-site policy
     static const char jsPrefGroupName[] = "javascript";
 
     SecurityLevel secLevel;
     rv = LookupPolicy(aPrincipal, (char*)jsPrefGroupName, sEnabledID,
@@ -1628,20 +1562,19 @@ nsScriptSecurityManager::GetSubjectPrinc
 NS_IMETHODIMP
 nsScriptSecurityManager::GetSystemPrincipal(nsIPrincipal **result)
 {
     if (!mSystemPrincipal)
     {
         mSystemPrincipal = new nsSystemPrincipal();
         if (!mSystemPrincipal)
             return NS_ERROR_OUT_OF_MEMORY;
-        NS_ADDREF(mSystemPrincipal);
     }
-    *result = mSystemPrincipal;
-    NS_ADDREF(*result);
+
+    NS_ADDREF(*result = mSystemPrincipal);
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsScriptSecurityManager::SubjectPrincipalIsSystem(PRBool* aIsSystem)
 {
     NS_ENSURE_ARG_POINTER(aIsSystem);
     *aIsSystem = PR_FALSE;
@@ -1664,116 +1597,82 @@ nsScriptSecurityManager::SubjectPrincipa
 
     return mSystemPrincipal->Equals(subject, aIsSystem);
 }
 
 NS_IMETHODIMP
 nsScriptSecurityManager::GetCertificatePrincipal(const char* aCertID,
                                                  nsIPrincipal **result)
 {
-    nsresult rv;
     //-- Create a certificate principal
-    nsCertificatePrincipal *certificate = new nsCertificatePrincipal();
+    nsRefPtr<nsPrincipal> certificate = new nsPrincipal();
     if (!certificate)
         return NS_ERROR_OUT_OF_MEMORY;
-    NS_ADDREF(certificate);
-    if (NS_FAILED(certificate->Init(aCertID)))
-    {
-        NS_RELEASE(certificate);
-        return NS_ERROR_FAILURE;
-    }
-    nsCOMPtr<nsIPrincipal> principal(do_QueryInterface((nsBasePrincipal*)certificate, &rv));
-    NS_RELEASE(certificate);
-    if (NS_FAILED(rv)) return rv;
 
-    if (mPrincipals)
-    {
-        // Check to see if we already have this principal.
-        nsIPrincipalKey key(principal);
-        nsCOMPtr<nsIPrincipal> fromTable = (nsIPrincipal *) mPrincipals->Get(&key);
-        if (fromTable)
-            principal = fromTable;
-    }
+    nsresult rv = certificate->SetCertificateID(aCertID);
+    if (NS_FAILED(rv))
+        return rv;
 
-    //-- Bundle this certificate principal into an aggregate principal
-    nsAggregatePrincipal* agg = new nsAggregatePrincipal();
-    if (!agg) return NS_ERROR_OUT_OF_MEMORY;
-    rv = agg->SetCertificate(principal);
-    if (NS_FAILED(rv)) return rv;
-    principal = do_QueryInterface((nsBasePrincipal*)agg, &rv);
-    if (NS_FAILED(rv)) return rv;
+    nsCOMPtr<nsIPrincipal> principal(certificate);
+
+    // Check to see if we already have this principal.
+    nsCOMPtr<nsIPrincipal> fromTable;
+    mPrincipals.Get(principal, getter_AddRefs(fromTable));
+    if (fromTable)
+        principal = fromTable;
+
+    NS_ADDREF(*result = principal);
 
-    *result = principal;
-    NS_ADDREF(*result);
     return NS_OK;
 }
 
 nsresult
 nsScriptSecurityManager::CreateCodebasePrincipal(nsIURI* aURI, nsIPrincipal **result)
 {
-    nsresult rv = NS_OK;
-    nsCodebasePrincipal *codebase = new nsCodebasePrincipal();
+    nsRefPtr<nsPrincipal> codebase = new nsPrincipal(aURI);
     if (!codebase)
         return NS_ERROR_OUT_OF_MEMORY;
-    NS_ADDREF(codebase);
-    if (NS_FAILED(codebase->Init(aURI)))
-    {
-        NS_RELEASE(codebase);
-        return NS_ERROR_FAILURE;
-    }
-    rv = CallQueryInterface((nsBasePrincipal*)codebase, result);
-    NS_RELEASE(codebase);
-    return rv;
+
+    NS_ADDREF(*result = codebase);
+
+    return NS_OK;
 }
 
 NS_IMETHODIMP
 nsScriptSecurityManager::GetCodebasePrincipal(nsIURI *aURI,
                                               nsIPrincipal **result)
 {
     nsresult rv;
     nsCOMPtr<nsIPrincipal> principal;
     rv = CreateCodebasePrincipal(aURI, getter_AddRefs(principal));
     if (NS_FAILED(rv)) return rv;
 
-    if (mPrincipals)
+    //-- Check to see if we already have this principal.
+    nsCOMPtr<nsIPrincipal> fromTable;
+    mPrincipals.Get(principal, getter_AddRefs(fromTable));
+    if (fromTable)
+        principal = fromTable;
+    else //-- Check to see if we have a more general principal
     {
-        //-- Check to see if we already have this principal.
-        nsIPrincipalKey key(principal);
-        nsCOMPtr<nsIPrincipal> fromTable = (nsIPrincipal *) mPrincipals->Get(&key);
+        nsXPIDLCString originUrl;
+        rv = principal->GetOrigin(getter_Copies(originUrl));
+        if (NS_FAILED(rv)) return rv;
+        nsCOMPtr<nsIURI> newURI;
+        rv = NS_NewURI(getter_AddRefs(newURI), originUrl, nsnull, sIOService);
+        if (NS_FAILED(rv)) return rv;
+        nsCOMPtr<nsIPrincipal> principal2;
+        rv = CreateCodebasePrincipal(newURI, getter_AddRefs(principal2));
+        if (NS_FAILED(rv)) return rv;
+        mPrincipals.Get(principal2, getter_AddRefs(fromTable));
         if (fromTable)
             principal = fromTable;
-        else //-- Check to see if we have a more general principal
-        {
-            nsCOMPtr<nsICodebasePrincipal> codebasePrin(do_QueryInterface(principal));
-            nsXPIDLCString originUrl;
-            rv = codebasePrin->GetOrigin(getter_Copies(originUrl));
-            if (NS_FAILED(rv)) return rv;
-            nsCOMPtr<nsIURI> newURI;
-            rv = NS_NewURI(getter_AddRefs(newURI), originUrl, nsnull);
-            if (NS_FAILED(rv)) return rv;
-            nsCOMPtr<nsIPrincipal> principal2;
-            rv = CreateCodebasePrincipal(newURI, getter_AddRefs(principal2));
-            if (NS_FAILED(rv)) return rv;
-             nsIPrincipalKey key2(principal2);
-                fromTable = (nsIPrincipal *) mPrincipals->Get(&key2);
-            if (fromTable)
-                principal = fromTable;
-        }		
     }
 
-    //-- Bundle this codebase principal into an aggregate principal
-    nsAggregatePrincipal* agg = new nsAggregatePrincipal();
-    if (!agg) return NS_ERROR_OUT_OF_MEMORY;
-    rv = agg->SetCodebase(principal);
-    if (NS_FAILED(rv)) return rv;
-    principal = do_QueryInterface((nsBasePrincipal*)agg, &rv);
-    if (NS_FAILED(rv)) return rv;
+    NS_IF_ADDREF(*result = principal);
 
-    *result = principal;
-    NS_ADDREF(*result);
     return NS_OK;
 }
 
 nsresult
 nsScriptSecurityManager::GetPrincipalFromContext(JSContext *cx,
                                                  nsIPrincipal **result)
 {
     *result = nsnull;
@@ -1839,18 +1738,18 @@ nsScriptSecurityManager::GetFunctionObje
         }
 
         if (NS_FAILED(GetScriptPrincipal(cx, script,
                                          getter_AddRefs(scriptPrincipal))))
             return NS_ERROR_FAILURE;
 
     }
 
-    *result = scriptPrincipal.get();
-    NS_IF_ADDREF(*result);
+    NS_IF_ADDREF(*result = scriptPrincipal);
+
     return NS_OK;
 }
 
 nsresult
 nsScriptSecurityManager::GetFramePrincipal(JSContext *cx,
                                            JSStackFrame *fp,
                                            nsIPrincipal **result)
 {
@@ -1985,42 +1884,28 @@ nsScriptSecurityManager::doGetObjectPrin
 
     // Couldn't find a principal for this object.
     return NS_ERROR_FAILURE;
 }
 
 nsresult
 nsScriptSecurityManager::SavePrincipal(nsIPrincipal* aToSave)
 {
-    nsresult rv;
-    nsCOMPtr<nsIPrincipal> persistent = aToSave;
-    nsCOMPtr<nsIAggregatePrincipal> aggregate(do_QueryInterface(aToSave, &rv));
-    if (NS_SUCCEEDED(rv))
-        if (NS_FAILED(aggregate->GetPrimaryChild(getter_AddRefs(persistent))))
-            return NS_ERROR_FAILURE;
-
     //-- Save to mPrincipals
-    if (!mPrincipals)
-    {
-        mPrincipals = new nsSupportsHashtable(31);
-        if (!mPrincipals)
-            return NS_ERROR_OUT_OF_MEMORY;
-    }
-    nsIPrincipalKey key(persistent);
-    mPrincipals->Put(&key, persistent);
+    mPrincipals.Put(aToSave, aToSave);
 
     //-- Save to prefs
     nsXPIDLCString idPrefName;
     nsXPIDLCString id;
     nsXPIDLCString grantedList;
     nsXPIDLCString deniedList;
-    rv = persistent->GetPreferences(getter_Copies(idPrefName),
-                                    getter_Copies(id),
-                                    getter_Copies(grantedList),
-                                    getter_Copies(deniedList));
+    nsresult rv = aToSave->GetPreferences(getter_Copies(idPrefName),
+                                          getter_Copies(id),
+                                          getter_Copies(grantedList),
+                                          getter_Copies(deniedList));
     if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
 
     nsXPIDLCString grantedPrefName;
     nsXPIDLCString deniedPrefName;
     rv = PrincipalPrefNames( idPrefName,
                              getter_Copies(grantedPrefName),
                              getter_Copies(deniedPrefName)  );
     if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
@@ -2139,17 +2024,17 @@ nsScriptSecurityManager::CheckConfirmDia
         nsCOMPtr<nsIWindowWatcher> wwatch(do_GetService(NS_WINDOWWATCHER_CONTRACTID));
         if (wwatch)
           wwatch->GetNewPrompter(0, getter_AddRefs(prompter));
         if (!prompter)
             return PR_FALSE;
     }
 
     // create a bundle for the localization
-    nsCOMPtr<nsIStringBundleService> bundleService(do_GetService(kStringBundleServiceCID, &rv));
+    nsCOMPtr<nsIStringBundleService> bundleService(do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv));
     if (NS_FAILED(rv))
         return PR_FALSE;
 
     nsCOMPtr<nsIStringBundle> bundle;
     rv = bundleService->CreateBundle(PROPERTIES_URL, getter_AddRefs(bundle));
     if (NS_FAILED(rv))
         return PR_FALSE;
 
@@ -2163,21 +2048,28 @@ nsScriptSecurityManager::CheckConfirmDia
                                    getter_Copies(check));
     if (NS_FAILED(rv))
         return PR_FALSE;
     rv = bundle->GetStringFromName(NS_LITERAL_STRING("Titleline").get(),
                                    getter_Copies(title));
     if (NS_FAILED(rv))
         return PR_FALSE;
 
-    nsXPIDLCString source;
-    rv = aPrincipal->ToUserVisibleString(getter_Copies(source));
+    nsXPIDLCString val;
+    PRBool hasCert;
+    aPrincipal->GetHasCertificate(&hasCert);
+    if (hasCert)
+        rv = aPrincipal->GetCommonName(getter_Copies(val));
+    else
+        rv = aPrincipal->GetOrigin(getter_Copies(val));
+
     if (NS_FAILED(rv))
         return PR_FALSE;
-    PRUnichar* message = nsTextFormatter::smprintf(query.get(), source.get());
+
+    PRUnichar* message = nsTextFormatter::smprintf(query.get(), val.get());
     NS_ENSURE_TRUE(message, PR_FALSE);
 
     PRInt32 buttonPressed = 1; // If the user exits by clicking the close box, assume No (button 1)
     rv = prompter->ConfirmEx(title.get(), message,
                              (nsIPrompt::BUTTON_TITLE_YES * nsIPrompt::BUTTON_POS_0) +
                              (nsIPrompt::BUTTON_TITLE_NO * nsIPrompt::BUTTON_POS_1),
                              nsnull, nsnull, nsnull, check.get(), checkValue, &buttonPressed);
     nsTextFormatter::smprintf_free(message);
@@ -2306,20 +2198,17 @@ nsScriptSecurityManager::SetCanEnableCap
         if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
 #ifdef XP_MAC
         // On Mac, this file will be located in the Essential Files folder
         systemCertFile->AppendNative(NS_LITERAL_CSTRING("Essential Files"));
         if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
 #endif
         systemCertFile->AppendNative(NS_LITERAL_CSTRING("systemSignature.jar"));
         if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
-        nsCOMPtr<nsIZipReader> systemCertZip;
-        rv = nsComponentManager::CreateInstance(kZipReaderCID, nsnull,
-                                                NS_GET_IID(nsIZipReader),
-                                                getter_AddRefs(systemCertZip));
+        nsCOMPtr<nsIZipReader> systemCertZip = do_CreateInstance(kZipReaderCID, &rv);
         if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
         systemCertZip->Init(systemCertFile);
         rv = systemCertZip->Open();
         if (NS_SUCCEEDED(rv))
         {
             nsCOMPtr<nsIJAR> systemCertJar(do_QueryInterface(systemCertZip, &rv));
             if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
             rv = systemCertJar->GetCertificatePrincipal(nsnull,
@@ -2361,25 +2250,25 @@ nsScriptSecurityManager::SetCanEnableCap
 
 NS_IMETHODIMP
 nsScriptSecurityManager::CanCreateWrapper(JSContext *cx,
                                           const nsIID &aIID,
                                           nsISupports *aObj,
                                           nsIClassInfo *aClassInfo,
                                           void **aPolicy)
 {
-#if 0
+#ifdef DEBUG_CAPS_CanCreateWrapper
     char* iidStr = aIID.ToString();
     printf("### CanCreateWrapper(%s) ", iidStr);
-    PR_FREEIF(iidStr);
+    nsCRT::free(iidStr);
 #endif
 // XXX Special case for nsIXPCException ?
     if (ClassInfoData(aClassInfo, nsnull).IsDOMClass())
     {
-#if 0
+#ifdef DEBUG_CAPS_CanCreateWrapper
         printf("DOM class - GRANTED.\n");
 #endif
         return NS_OK;
     }
 
     //--See if the object advertises a non-default level of access
     //  using nsISecurityCheckedComponent
     nsCOMPtr<nsISecurityCheckedComponent> checkedComponent =
@@ -2401,17 +2290,26 @@ nsScriptSecurityManager::CanCreateWrappe
             if (className)
             {
                 errorMsg += "of class ";
                 errorMsg += className;
             }
         }
         JS_SetPendingException(cx,
                                STRING_TO_JSVAL(JS_NewStringCopyZ(cx, errorMsg.get())));
+
+#ifdef DEBUG_CAPS_CanCreateWrapper
+        printf("DENIED.\n");
     }
+    else
+    {
+        printf("GRANTED.\n");
+#endif
+    }
+
     return rv;
 }
 
 #ifdef XPC_IDISPATCH_SUPPORT
 nsresult
 nsScriptSecurityManager::CheckComponentPermissions(JSContext *cx,
                                                    const nsCID &aCID)
 {
@@ -2422,17 +2320,17 @@ nsScriptSecurityManager::CheckComponentP
 
     // Reformat the CID string so it's suitable for prefs
     nsXPIDLCString cidTemp;
     cidTemp.Adopt(aCID.ToString());
     nsCAutoString cid(NS_LITERAL_CSTRING("CID") +
                       Substring(cidTemp, 1, cidTemp.Length() - 2));
     ToUpperCase(cid);
 
-#ifdef DEBUG_mstoltz
+#ifdef DEBUG_CAPS_CheckComponentPermissions
     printf("### CheckComponentPermissions(ClassID.%s) ",cid.get());
 #endif
 
     // Look up the policy for this class.
     // while this isn't a property we'll treat it as such, using ACCESS_CALL_METHOD
     jsval cidVal = STRING_TO_JSVAL(::JS_InternString(cx, cid.get()));
 
     SecurityLevel securityLevel;
@@ -2444,74 +2342,97 @@ nsScriptSecurityManager::CheckComponentP
 
     // If there's no policy stored, use the "security.classID.allowByDefault" pref 
     if (securityLevel.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)
         securityLevel.level = mXPCDefaultGrantAll ? SCRIPT_SECURITY_ALL_ACCESS :
                                                     SCRIPT_SECURITY_NO_ACCESS;
 
     if (securityLevel.level == SCRIPT_SECURITY_ALL_ACCESS)
     {
-#ifdef DEBUG_mstoltz
+#ifdef DEBUG_CAPS_CheckComponentPermissions
         printf(" GRANTED.\n");
 #endif
         return NS_OK;
     }
 
-#ifdef DEBUG_mstoltz
+#ifdef DEBUG_CAPS_CheckComponentPermissions
     printf(" DENIED.\n");
 #endif
     return NS_ERROR_DOM_PROP_ACCESS_DENIED;
 }
 #endif
 
 NS_IMETHODIMP
 nsScriptSecurityManager::CanCreateInstance(JSContext *cx,
                                            const nsCID &aCID)
 {
+#ifdef DEBUG_CAPS_CanCreateInstance
+    char* cidStr = aCID.ToString();
+    printf("### CanCreateInstance(%s) ", cidStr);
+    nsCRT::free(cidStr);
+#endif
+
     nsresult rv = CheckXPCPermissions(nsnull, nsnull);
     if (NS_FAILED(rv))
 #ifdef XPC_IDISPATCH_SUPPORT
     {
         rv = CheckComponentPermissions(cx, aCID);
     }
     if (NS_FAILED(rv))
 #endif
     {
         //-- Access denied, report an error
         nsCAutoString errorMsg("Permission denied to create instance of class. CID=");
         nsXPIDLCString cidStr;
         cidStr += aCID.ToString();
         errorMsg.Append(cidStr);
         JS_SetPendingException(cx,
                                STRING_TO_JSVAL(JS_NewStringCopyZ(cx, errorMsg.get())));
+
+#ifdef DEBUG_CAPS_CanCreateInstance
+        printf("DENIED\n");
+    }
+    else
+    {
+        printf("GRANTED\n");
+#endif
     }
     return rv;
 }
 
 NS_IMETHODIMP
 nsScriptSecurityManager::CanGetService(JSContext *cx,
                                        const nsCID &aCID)
 {
-#if 0
+#ifdef DEBUG_CAPS_CanGetService
     char* cidStr = aCID.ToString();
     printf("### CanGetService(%s) ", cidStr);
-    PR_FREEIF(cidStr);
+    nsCRT::free(cidStr);
 #endif
 
     nsresult rv = CheckXPCPermissions(nsnull, nsnull);
     if (NS_FAILED(rv))
     {
         //-- Access denied, report an error
         nsCAutoString errorMsg("Permission denied to get service. CID=");
         nsXPIDLCString cidStr;
         cidStr += aCID.ToString();
         errorMsg.Append(cidStr);
         JS_SetPendingException(cx,
                                STRING_TO_JSVAL(JS_NewStringCopyZ(cx, errorMsg.get())));
+
+#ifdef DEBUG_CAPS_CanGetService
+        printf("DENIED\n");
     }
+    else
+    {
+        printf("GRANTED\n");
+#endif
+    }
+
     return rv;
 }
 
 
 NS_IMETHODIMP
 nsScriptSecurityManager::CanAccess(PRUint32 aAction,
                                    nsIXPCNativeCallContext* aCallContext,
                                    JSContext* cx,
@@ -2615,43 +2536,48 @@ nsScriptSecurityManager::Observe(nsISupp
 
 /////////////////////////////////////////////
 // Constructor, Destructor, Initialization //
 /////////////////////////////////////////////
 nsScriptSecurityManager::nsScriptSecurityManager(void)
     : mOriginToPolicyMap(nsnull),
       mDefaultPolicy(nsnull),
       mCapabilities(nsnull),
-      mSystemPrincipal(nsnull), mPrincipals(nsnull),
       mIsJavaScriptEnabled(PR_FALSE),
       mIsMailJavaScriptEnabled(PR_FALSE),
       mIsWritingPrefs(PR_FALSE),
-      mNameSetRegistered(PR_FALSE),
       mPolicyPrefsChanged(PR_TRUE)
 #ifdef XPC_IDISPATCH_SUPPORT
       ,mXPCDefaultGrantAll(PR_FALSE)
 #endif
 {
     NS_ASSERTION(sizeof(long) == sizeof(void*), "long and void* have different lengths on this platform. This may cause a security failure.");
+    mPrincipals.Init(31);
 }
 
 
 nsresult nsScriptSecurityManager::Init()
 {
     JSContext* cx = GetSafeJSContext();
     if (!cx) return NS_ERROR_FAILURE;   // this can happen of xpt loading fails
     
     ::JS_BeginRequest(cx);
     if (sEnabledID == JSVAL_VOID)
         sEnabledID = STRING_TO_JSVAL(::JS_InternString(cx, "enabled"));
     ::JS_EndRequest(cx);
 
     nsresult rv = InitPrefs();
     NS_ENSURE_SUCCESS(rv, rv);
 
+    rv = CallGetService(NS_IOSERVICE_CONTRACTID, &sIOService);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = CallGetService(nsIXPConnect::GetCID(), &sXPConnect);
+    NS_ENSURE_SUCCESS(rv, rv);
+
     //-- Register security check callback in the JS engine
     //   Currently this is used to control access to function.caller
     nsCOMPtr<nsIJSRuntimeService> runtimeService =
         do_GetService("@mozilla.org/js/xpc/RuntimeService;1", &rv);
     NS_ENSURE_SUCCESS(rv, rv);
 
     JSRuntime *rt;
     rv = runtimeService->GetRuntime(&rt);
@@ -2670,26 +2596,27 @@ nsresult nsScriptSecurityManager::Init()
 static nsScriptSecurityManager *gScriptSecMan = nsnull;
 
 jsval nsScriptSecurityManager::sEnabledID   = JSVAL_VOID;
 
 nsScriptSecurityManager::~nsScriptSecurityManager(void)
 {
     delete mOriginToPolicyMap;
     delete mDefaultPolicy;
-    NS_IF_RELEASE(mSystemPrincipal);
-    delete mPrincipals;
     delete mCapabilities;
     gScriptSecMan = nsnull;
 }
 
 void
 nsScriptSecurityManager::Shutdown()
 {
     sEnabledID = JSVAL_VOID;
+
+    NS_IF_RELEASE(sIOService);
+    NS_IF_RELEASE(sXPConnect);
 }
 
 nsScriptSecurityManager *
 nsScriptSecurityManager::GetScriptSecurityManager()
 {
     if (!gScriptSecMan)
     {
         nsScriptSecurityManager* ssManager = new nsScriptSecurityManager();
@@ -2705,26 +2632,18 @@ nsScriptSecurityManager::GetScriptSecuri
  
         rv = nsJSPrincipals::Startup();
         if (NS_FAILED(rv)) {
             NS_WARNING("can't initialize JS engine security protocol glue!");
             delete ssManager;
             return nsnull;
         }
  
-        nsCOMPtr<nsIXPConnect> xpc = do_GetService(nsIXPConnect::GetCID(), &rv);
-        if (NS_FAILED(rv) || !xpc) {
-            NS_WARNING("Failed to get the XPConnect service");
-            delete ssManager;
-            return nsnull;
-        }
- 
-            rv = xpc->SetDefaultSecurityManager(
-                        NS_STATIC_CAST(nsIXPCSecurityManager*, ssManager),
-                            nsIXPCSecurityManager::HOOK_ALL);
+        rv = sXPConnect->SetDefaultSecurityManager(ssManager,
+                                                   nsIXPCSecurityManager::HOOK_ALL);
         if (NS_FAILED(rv)) {
             NS_WARNING("Failed to install xpconnect security manager!");
             delete ssManager;
             return nsnull;
         }
 
         gScriptSecMan = ssManager;
     }
@@ -2741,39 +2660,38 @@ nsScriptSecurityManager::SystemPrincipal
     if (gScriptSecMan)
         gScriptSecMan->GetSystemPrincipal(&sysprin);
     return NS_STATIC_CAST(nsSystemPrincipal*, sysprin);
 }
 
 nsresult
 nsScriptSecurityManager::InitPolicies()
 {
-    nsresult rv;
-
     // Reset the "dirty" flag
     mPolicyPrefsChanged = PR_FALSE;
 
     // Clear any policies cached on XPConnect wrappers
-    nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
-    if (NS_FAILED(rv)) return rv;
-    rv = xpc->ClearAllWrappedNativeSecurityPolicies();
+    NS_ENSURE_STATE(sXPConnect);
+    nsresult rv = sXPConnect->ClearAllWrappedNativeSecurityPolicies();
     if (NS_FAILED(rv)) return rv;
 
     //-- Reset mOriginToPolicyMap
     delete mOriginToPolicyMap;
     mOriginToPolicyMap =
       new nsObjectHashtable(nsnull, nsnull, DeleteDomainEntry, nsnull);
 
     //-- Reset and initialize the default policy
     delete mDefaultPolicy;
-    mDefaultPolicy =
-      new DomainPolicy();
+    mDefaultPolicy = new DomainPolicy();
     if (!mOriginToPolicyMap || !mDefaultPolicy)
         return NS_ERROR_OUT_OF_MEMORY;
 
+    if (!mDefaultPolicy->Init())
+        return NS_ERROR_UNEXPECTED;
+
     //-- Initialize the table of security levels
     if (!mCapabilities)
     {
         mCapabilities = 
           new nsObjectHashtable(nsnull, nsnull, DeleteCapability, nsnull);
         if (!mCapabilities)
             return NS_ERROR_OUT_OF_MEMORY;
     }
@@ -2819,32 +2737,41 @@ nsScriptSecurityManager::InitPolicies()
                                                 getter_Copies(domainList));
         if (NS_FAILED(rv))
             continue;
 
         DomainPolicy* domainPolicy = new DomainPolicy();
         if (!domainPolicy)
             return NS_ERROR_OUT_OF_MEMORY;
 
+        if (!domainPolicy->Init())
+        {
+            delete domainPolicy;
+            return NS_ERROR_UNEXPECTED;
+        }
+
         //-- Parse list of sites and create an entry in mOriginToPolicyMap for each
         char* domainStart = (char*)domainList.get();
         char* domainCurrent = domainStart;
         char* lastDot = nsnull;
         char* nextToLastDot = nsnull;
         PRBool moreDomains = PR_TRUE;
         while (moreDomains)
         {
             if (*domainCurrent == ' ' || *domainCurrent == '\0')
             {
                 moreDomains = (*domainCurrent != '\0');
                 *domainCurrent = '\0';
                 nsCStringKey key(nextToLastDot ? nextToLastDot+1 : domainStart);
                 DomainEntry *newEntry = new DomainEntry(domainStart, domainPolicy);
                 if (!newEntry)
+                {
+                    delete domainPolicy;
                     return NS_ERROR_OUT_OF_MEMORY;
+                }
 #ifdef DEBUG
                 newEntry->mPolicyName_DEBUG = nameBegin;
 #endif
                 DomainEntry *existingEntry = (DomainEntry *)
                     mOriginToPolicyMap->Get(&key);
                 if (!existingEntry)
                     mOriginToPolicyMap->Put(&key, newEntry);
                 else
@@ -2877,59 +2804,59 @@ nsScriptSecurityManager::InitPolicies()
             {
                 nextToLastDot = lastDot;
                 lastDot = domainCurrent;
             }
             domainCurrent++;
         }
 
         rv = InitDomainPolicy(cx, nameBegin, domainPolicy);
-        NS_ENSURE_SUCCESS(rv, rv);
+        if (NS_FAILED(rv))
+            return rv;
     }
 
-#ifdef DEBUG_mstoltz
+#ifdef DEBUG_CAPS_HACKER
     PrintPolicyDB();
 #endif
     return NS_OK;
 }
 
 
 nsresult
 nsScriptSecurityManager::InitDomainPolicy(JSContext* cx,
                                           const char* aPolicyName,
                                           DomainPolicy* aDomainPolicy)
 {
     nsresult rv;
     nsCAutoString policyPrefix(sPolicyPrefix +
-			       nsDependentCString(aPolicyName) +
-			       NS_LITERAL_CSTRING("."));
+                               nsDependentCString(aPolicyName) +
+                               NS_LITERAL_CSTRING("."));
     PRUint32 prefixLength = policyPrefix.Length() - 1; // subtract the '.'
 
-    // XXX fix string use here.
     PRUint32 prefCount;
     char** prefNames;
     rv = mPrefBranch->GetChildList(policyPrefix.get(),
-				   &prefCount, &prefNames);
+                                   &prefCount, &prefNames);
     if (NS_FAILED(rv)) return rv;
     if (prefCount == 0)
         return NS_OK;
 
     //-- Populate the policy
     PRUint32 currentPref = 0;
     for (; currentPref < prefCount; currentPref++)
     {
         // Get the class name
-        const char* start = prefNames[currentPref] + prefixLength +1;
+        const char* start = prefNames[currentPref] + prefixLength + 1;
         char* end = PL_strchr(start, '.');
         if (!end) // malformed pref, bail on this one
             continue;
         static const char sitesStr[] = "sites";
 
-	// We dealt with "sites" in InitPolicies(), so no need to do
-	// that again...
+        // We dealt with "sites" in InitPolicies(), so no need to do
+        // that again...
         if (PL_strncmp(start, sitesStr, sizeof(sitesStr)-1) == 0)
             continue;
 
         // Get the pref value
         nsXPIDLCString prefValue;
         rv = mSecurityPref->SecurityGetCharPref(prefNames[currentPref],
                                                 getter_Copies(prefValue));
         if (NS_FAILED(rv) || !prefValue)
@@ -3075,108 +3002,99 @@ nsScriptSecurityManager::InitPrincipals(
 
         nsXPIDLCString grantedPrefName;
         nsXPIDLCString deniedPrefName;
         nsresult rv = PrincipalPrefNames(aPrefNames[c],
                                          getter_Copies(grantedPrefName),
                                          getter_Copies(deniedPrefName));
         if (rv == NS_ERROR_OUT_OF_MEMORY)
             return rv;
-        else if (NS_FAILED(rv))
+        if (NS_FAILED(rv))
             continue;
 
-        char* grantedList = nsnull;
-        mSecurityPref->SecurityGetCharPref(grantedPrefName, &grantedList);
-        char* deniedList = nsnull;
-        mSecurityPref->SecurityGetCharPref(deniedPrefName, &deniedList);
+        nsXPIDLCString grantedList;
+        mSecurityPref->SecurityGetCharPref(grantedPrefName, getter_Copies(grantedList));
+        nsXPIDLCString deniedList;
+        mSecurityPref->SecurityGetCharPref(deniedPrefName, getter_Copies(deniedList));
 
         //-- Delete prefs if their value is the empty string
-        if ((!id || id[0] == '\0') ||
-            ((!grantedList || grantedList[0] == '\0') && (!deniedList || deniedList[0] == '\0')))
+        if (id.IsEmpty() || (grantedList.IsEmpty() && deniedList.IsEmpty()))
         {
             mSecurityPref->SecurityClearUserPref(aPrefNames[c]);
             mSecurityPref->SecurityClearUserPref(grantedPrefName);
             mSecurityPref->SecurityClearUserPref(deniedPrefName);
-            PR_FREEIF(grantedList);
-            PR_FREEIF(deniedList);
             continue;
         }
 
         //-- Create a principal based on the prefs
         static const char certificateName[] = "capability.principal.certificate";
         static const char codebaseName[] = "capability.principal.codebase";
         static const char codebaseTrustedName[] = "capability.principal.codebaseTrusted";
-        nsCOMPtr<nsIPrincipal> principal;
+
+        PRBool isCert = PR_FALSE;
+        PRBool isTrusted = PR_FALSE;
+        
         if (PL_strncmp(aPrefNames[c], certificateName,
-                       sizeof(certificateName)-1) == 0)
+                       sizeof(certificateName) - 1) == 0)
         {
-            nsCertificatePrincipal *certificate = new nsCertificatePrincipal();
-            if (certificate) {
-                NS_ADDREF(certificate);
-                if (NS_SUCCEEDED(certificate->InitFromPersistent(aPrefNames[c], id,
-                                                                 grantedList, deniedList)))
-                    principal = do_QueryInterface((nsBasePrincipal*)certificate);
-                NS_RELEASE(certificate);
-            }
-        } else if(PL_strncmp(aPrefNames[c], codebaseName,
-                             sizeof(codebaseName)-1) == 0)
+            isCert = PR_TRUE;
+        }
+        else if (PL_strncmp(aPrefNames[c], codebaseName,
+                            sizeof(codebaseName) - 1) == 0)
         {
-            nsCodebasePrincipal *codebase = new nsCodebasePrincipal();
-            if (codebase) {
-                NS_ADDREF(codebase);
-                PRBool trusted = (PL_strncmp(aPrefNames[c], codebaseTrustedName,
-                                             sizeof(codebaseTrustedName)-1) == 0);
-                if (NS_SUCCEEDED(codebase->InitFromPersistent(aPrefNames[c], id,
-                                                              grantedList, deniedList,
-                                                              trusted)))
-                    principal = do_QueryInterface((nsBasePrincipal*)codebase);
-                NS_RELEASE(codebase);
-            }
+            isTrusted = (PL_strncmp(aPrefNames[c], codebaseTrustedName,
+                                    sizeof(codebaseTrustedName) - 1) == 0);
+        }
+        else
+        {
+          NS_ERROR("Not a codebase or a certificate?!");
         }
-        PR_FREEIF(grantedList);
-        PR_FREEIF(deniedList);
 
-        if (principal)
+        nsCOMPtr<nsIPrincipal> principal;
+        nsRefPtr<nsPrincipal> newPrincipal = new nsPrincipal();
+        if (newPrincipal)
         {
-            if (!mPrincipals)
-            {
-                mPrincipals = new nsSupportsHashtable(31);
-                if (!mPrincipals)
-                    return NS_ERROR_OUT_OF_MEMORY;
-            }
-            nsIPrincipalKey key(principal);
-            mPrincipals->Put(&key, principal);
+            rv = newPrincipal->InitFromPersistent(aPrefNames[c], id,
+                                                  grantedList, deniedList,
+                                                  isCert, isTrusted);
+            if (NS_SUCCEEDED(rv))
+                principal = do_QueryInterface(newPrincipal);
         }
+
+        if (principal)
+            mPrincipals.Put(principal, principal);
     }
     return NS_OK;
 }
 
-const char* nsScriptSecurityManager::sJSEnabledPrefName = "javascript.enabled";
-const char* nsScriptSecurityManager::sJSMailEnabledPrefName = "javascript.allow.mailnews";
+const char nsScriptSecurityManager::sJSEnabledPrefName[] =
+    "javascript.enabled";
+const char nsScriptSecurityManager::sJSMailEnabledPrefName[] =
+    "javascript.allow.mailnews";
 #ifdef XPC_IDISPATCH_SUPPORT
-const char* nsScriptSecurityManager::sXPCDefaultGrantAllName =
-                "security.classID.allowByDefault";
+const char nsScriptSecurityManager::sXPCDefaultGrantAllName[] =
+    "security.classID.allowByDefault";
 #endif
+
 inline void
 nsScriptSecurityManager::JSEnabledPrefChanged(nsISecurityPref* aSecurityPref)
 {
-    if (NS_FAILED(mSecurityPref->SecurityGetBoolPref(sJSEnabledPrefName,
-                                                     &mIsJavaScriptEnabled)))
-        // Default to enabled.
-        mIsJavaScriptEnabled = PR_TRUE;
+    PRBool temp;
+    nsresult rv = mSecurityPref->SecurityGetBoolPref(sJSEnabledPrefName, &temp);
+    // JavaScript defaults to enabled in failure cases.
+    mIsJavaScriptEnabled = NS_FAILED(rv) || temp;
+
+    rv = mSecurityPref->SecurityGetBoolPref(sJSMailEnabledPrefName, &temp);
+    // JavaScript in Mail defaults to enabled in failure cases.
+    mIsMailJavaScriptEnabled = NS_FAILED(rv) || temp;
 
-    if (NS_FAILED(mSecurityPref->SecurityGetBoolPref(sJSMailEnabledPrefName,
-                                                     &mIsMailJavaScriptEnabled)))
-        // Default to enabled.
-        mIsMailJavaScriptEnabled = PR_TRUE;
 #ifdef XPC_IDISPATCH_SUPPORT
-    if (NS_FAILED(mSecurityPref->SecurityGetBoolPref(sXPCDefaultGrantAllName,
-                                                     &mXPCDefaultGrantAll)))
-        // Default to disabled.
-        mXPCDefaultGrantAll = PR_FALSE;
+    rv = mSecurityPref->SecurityGetBoolPref(sXPCDefaultGrantAllName, &temp);
+    // Granting XPC Priveleges defaults to disabled in failure cases.
+    mXPCDefaultGrantAll = NS_SUCCEEDED(rv) && temp;
 #endif
 }
 
 nsresult
 nsScriptSecurityManager::InitPrefs()
 {
     nsresult rv;
     nsCOMPtr<nsIPrefService> prefService(do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
@@ -3213,17 +3131,17 @@ nsScriptSecurityManager::InitPrefs()
     //-- Set a callback for principal changes
     prefBranchInternal->AddObserver(sPrincipalPrefix, this, PR_FALSE);
 
     return NS_OK;
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 // The following code prints the contents of the policy DB to the console.
-#ifdef DEBUG_mstoltz
+#ifdef DEBUG_CAPS_HACKER
 
 //typedef PLDHashOperator
 //(* PR_CALLBACK PLDHashEnumerator)(PLDHashTable *table, PLDHashEntryHdr *hdr,
 //                                      PRUint32 number, void *arg);
 PR_STATIC_CALLBACK(PLDHashOperator)
 PrintPropertyPolicy(PLDHashTable *table, PLDHashEntryHdr *entry,
                     PRUint32 number, void *arg)
 {
Index: caps/src/nsSecurityManagerFactory.cpp
===================================================================
RCS file: /cvsroot/mozilla/caps/src/nsSecurityManagerFactory.cpp,v
retrieving revision 1.34
diff -p -u -d -8 -r1.34 nsSecurityManagerFactory.cpp
--- caps/src/nsSecurityManagerFactory.cpp	29 May 2003 04:27:03 -0000	1.34
+++ caps/src/nsSecurityManagerFactory.cpp	23 Jul 2003 23:08:59 -0000
@@ -38,19 +38,17 @@
 /*Factory for internal browser security resource managers*/
 
 #include "nsCOMPtr.h"
 #include "nsIModule.h"
 #include "nsIGenericFactory.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsScriptSecurityManager.h"
 #include "nsIPrincipal.h"
-#include "nsAggregatePrincipal.h"
-#include "nsCertificatePrincipal.h"
-#include "nsCodebasePrincipal.h"
+#include "nsPrincipal.h"
 #include "nsSystemPrincipal.h"
 #include "nsIScriptNameSpaceManager.h"
 #include "nsIScriptExternalNameSet.h"
 #include "nsIScriptContext.h"
 #include "nsICategoryManager.h"
 #include "nsXPIDLString.h"
 #include "nsCOMPtr.h"
 #include "nsIServiceManager.h"
@@ -229,18 +227,18 @@ netscape_security_invalidate(JSContext *
     nsresult rv;
     nsCOMPtr<nsIScriptSecurityManager> securityManager = 
              do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
     if (NS_FAILED(rv)) 
         return JS_FALSE;
 
     //    NS_ASSERTION(cx == GetCurrentContext(), "unexpected context");
 
-    rv = securityManager->SetCanEnableCapability(principalID, 
-                                                 nsBasePrincipal::Invalid,
+    rv = securityManager->SetCanEnableCapability(principalID,
+                                                 nsPrincipal::sInvalid,
                                                  nsIPrincipal::ENABLE_GRANTED);
     if (NS_FAILED(rv))
         return JS_FALSE;
     return JS_TRUE;
 }
 
 static JSFunctionSpec PrivilegeManager_static_methods[] = {
     { "isPrivilegeEnabled", netscape_security_isPrivilegeEnabled,   1},
@@ -305,27 +303,23 @@ nsSecurityNameSet::InitializeNameSet(nsI
 
     return JS_DefineFunctions(cx, obj, PrivilegeManager_static_methods)
            ? NS_OK
            : NS_ERROR_FAILURE;
 }
 
 
 
-NS_GENERIC_FACTORY_CONSTRUCTOR(nsAggregatePrincipal)
-NS_GENERIC_FACTORY_CONSTRUCTOR(nsCertificatePrincipal)
-NS_GENERIC_FACTORY_CONSTRUCTOR(nsCodebasePrincipal)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsPrincipal)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsSecurityNameSet)
 NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(nsSystemPrincipal,
     nsScriptSecurityManager::SystemPrincipalSingletonConstructor)
 
 
-NS_DECL_CLASSINFO(nsAggregatePrincipal)
-NS_DECL_CLASSINFO(nsCertificatePrincipal)
-NS_DECL_CLASSINFO(nsCodebasePrincipal)
+NS_DECL_CLASSINFO(nsPrincipal)
 NS_DECL_CLASSINFO(nsSystemPrincipal)
 
 
 static NS_IMETHODIMP
 Construct_nsIScriptSecurityManager(nsISupports *aOuter, REFNSIID aIID, 
                                    void **aResult)
 {
     if (!aResult)
@@ -383,52 +377,26 @@ static const nsModuleComponentInfo capsC
       nsnull,
       nsnull,
       nsnull,
       nsnull,
       nsnull,
       nsIClassInfo::MAIN_THREAD_ONLY
     },
 
-    { NS_AGGREGATEPRINCIPAL_CLASSNAME, 
-      NS_AGGREGATEPRINCIPAL_CID, 
-      NS_AGGREGATEPRINCIPAL_CONTRACTID,
-      nsAggregatePrincipalConstructor,
-      nsnull,
-      nsnull,
-      nsnull,
-      NS_CI_INTERFACE_GETTER_NAME(nsAggregatePrincipal),
-      nsnull,
-      &NS_CLASSINFO_NAME(nsAggregatePrincipal),
-      nsIClassInfo::MAIN_THREAD_ONLY | nsIClassInfo::EAGER_CLASSINFO
-    },
-
-    { NS_CERTIFICATEPRINCIPAL_CLASSNAME, 
-      NS_CERTIFICATEPRINCIPAL_CID, 
-      NS_CERTIFICATEPRINCIPAL_CONTRACTID,
-      nsCertificatePrincipalConstructor,
-      nsnull,
-      nsnull,
-      nsnull,
-      NS_CI_INTERFACE_GETTER_NAME(nsCertificatePrincipal),
-      nsnull,
-      &NS_CLASSINFO_NAME(nsCertificatePrincipal),
-      nsIClassInfo::MAIN_THREAD_ONLY | nsIClassInfo::EAGER_CLASSINFO
-    },
-
-    { NS_CODEBASEPRINCIPAL_CLASSNAME, 
-      NS_CODEBASEPRINCIPAL_CID, 
-      NS_CODEBASEPRINCIPAL_CONTRACTID,
-      nsCodebasePrincipalConstructor,
+    { NS_PRINCIPAL_CLASSNAME, 
+      NS_PRINCIPAL_CID, 
+      NS_PRINCIPAL_CONTRACTID,
+      nsPrincipalConstructor,
       nsnull,
       nsnull,
       nsnull,
-      NS_CI_INTERFACE_GETTER_NAME(nsCodebasePrincipal),
+      NS_CI_INTERFACE_GETTER_NAME(nsPrincipal),
       nsnull,
-      &NS_CLASSINFO_NAME(nsCodebasePrincipal),
+      &NS_CLASSINFO_NAME(nsPrincipal),
       nsIClassInfo::MAIN_THREAD_ONLY | nsIClassInfo::EAGER_CLASSINFO
     },
 
     { NS_SYSTEMPRINCIPAL_CLASSNAME, 
       NS_SYSTEMPRINCIPAL_CID, 
       NS_SYSTEMPRINCIPAL_CONTRACTID,
       nsSystemPrincipalConstructor,
       nsnull,
Index: caps/src/nsSystemPrincipal.cpp
===================================================================
RCS file: /cvsroot/mozilla/caps/src/nsSystemPrincipal.cpp,v
retrieving revision 1.22
diff -p -u -d -8 -r1.22 nsSystemPrincipal.cpp
--- caps/src/nsSystemPrincipal.cpp	8 Jan 2003 19:15:49 -0000	1.22
+++ caps/src/nsSystemPrincipal.cpp	23 Jul 2003 23:08:59 -0000
@@ -42,62 +42,75 @@
 #include "nsSystemPrincipal.h"
 #include "nsIComponentManager.h"
 #include "nsIServiceManager.h"
 #include "nsIURL.h"
 #include "nsCOMPtr.h"
 #include "nsXPIDLString.h"
 #include "nsReadableUtils.h"
 #include "nsCRT.h"
+#include "nsString.h"
 
 
-NS_IMPL_QUERY_INTERFACE2_CI(nsSystemPrincipal, nsIPrincipal, nsISerializable)
-NS_IMPL_CI_INTERFACE_GETTER2(nsSystemPrincipal, nsIPrincipal, nsISerializable)
-
-NSBASEPRINCIPALS_ADDREF(nsSystemPrincipal);
-NSBASEPRINCIPALS_RELEASE(nsSystemPrincipal);
-
-
-///////////////////////////////////////
-// Methods implementing nsIPrincipal //
-///////////////////////////////////////
+NS_IMPL_QUERY_INTERFACE2_CI(nsSystemPrincipal,
+                            nsIPrincipal,
+                            nsISerializable)
+NS_IMPL_CI_INTERFACE_GETTER2(nsSystemPrincipal,
+                             nsIPrincipal,
+                             nsISerializable)
 
-NS_IMETHODIMP
-nsSystemPrincipal::ToString(char **result)
+NS_IMETHODIMP_(nsrefcnt) 
+nsSystemPrincipal::AddRef()
 {
-    nsAutoString buf;
-    buf.Assign(NS_LITERAL_STRING("[System]"));
-
-    *result = ToNewCString(buf);
-    return *result ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+  NS_PRECONDITION(PRInt32(mJSPrincipals.refcount) >= 0, "illegal refcnt");
+  nsrefcnt count = PR_AtomicIncrement((PRInt32 *)&mJSPrincipals.refcount);
+  NS_LOG_ADDREF(this, count, "nsSystemPrincipal", sizeof(*this));
+  return count;
 }
 
-NS_IMETHODIMP
-nsSystemPrincipal::ToUserVisibleString(char **result)
+NS_IMETHODIMP_(nsrefcnt)
+nsSystemPrincipal::Release()
 {
-    return ToString(result);
+  NS_PRECONDITION(0 != mJSPrincipals.refcount, "dup release");
+  nsrefcnt count = PR_AtomicDecrement((PRInt32 *)&mJSPrincipals.refcount);
+  NS_LOG_RELEASE(this, count, "nsSystemPrincipal");
+  if (count == 0) {
+    NS_DELETEXPCOM(this);
+  }
+
+  return count;
 }
 
+
+///////////////////////////////////////
+// Methods implementing nsIPrincipal //
+///////////////////////////////////////
+
 NS_IMETHODIMP
 nsSystemPrincipal::GetPreferences(char** aPrefName, char** aID, 
                                   char** aGrantedList, char** aDeniedList)
 {
     // The system principal should never be streamed out
+    *aPrefName = nsnull;
+    *aID = nsnull;
+    *aGrantedList = nsnull;
+    *aDeniedList = nsnull;
+
     return NS_ERROR_FAILURE; 
 }
 
 NS_IMETHODIMP
 nsSystemPrincipal::Equals(nsIPrincipal *other, PRBool *result)
 {
     *result = (other == this);
     return NS_OK;
 }
 
 NS_IMETHODIMP
-nsSystemPrincipal::HashValue(PRUint32 *result)
+nsSystemPrincipal::GetHashValue(PRUint32 *result)
 {
     *result = NS_PTR_TO_INT32(this);
     return NS_OK;
 }
 
 NS_IMETHODIMP 
 nsSystemPrincipal::CanEnableCapability(const char *capability, 
                                        PRInt16 *result)
@@ -122,33 +135,130 @@ nsSystemPrincipal::IsCapabilityEnabled(c
 {
     *result = PR_TRUE;
     return NS_OK;
 }
 
 NS_IMETHODIMP 
 nsSystemPrincipal::EnableCapability(const char *capability, void **annotation)
 {
+    *annotation = nsnull;
     return NS_OK;
 }
 
 NS_IMETHODIMP 
 nsSystemPrincipal::RevertCapability(const char *capability, void **annotation)
 {
+    *annotation = nsnull;
     return NS_OK;
 }
 
 NS_IMETHODIMP 
 nsSystemPrincipal::DisableCapability(const char *capability, void **annotation) 
 {
     // Can't disable the capabilities of the system principal.
     // XXX might be handy to be able to do so!
+    *annotation = nsnull;
     return NS_ERROR_FAILURE;
 }
 
+NS_IMETHODIMP 
+nsSystemPrincipal::GetURI(nsIURI** aURI)
+{
+    *aURI = nsnull;
+    return NS_OK;
+}
+
+NS_IMETHODIMP 
+nsSystemPrincipal::SetURI(nsIURI* aURI)
+{
+    return NS_OK;
+}
+
+NS_IMETHODIMP 
+nsSystemPrincipal::GetOrigin(char** aOrigin)
+{
+    *aOrigin = ToNewCString(NS_LITERAL_CSTRING("[System]"));
+    return *aOrigin ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+NS_IMETHODIMP 
+nsSystemPrincipal::SetCertificateID(const char* aID)
+{
+    return NS_OK;
+}
+
+
+NS_IMETHODIMP 
+nsSystemPrincipal::GetCertificateID(char** aID)
+{
+    *aID = nsnull;
+    return NS_OK;
+}
+
+NS_IMETHODIMP 
+nsSystemPrincipal::GetCommonName(char** aName)
+{
+    *aName = nsnull;
+    return NS_OK;
+}
+
+NS_IMETHODIMP 
+nsSystemPrincipal::SetCommonName(const char* aName)
+{
+    return NS_OK;
+}
+
+NS_IMETHODIMP 
+nsSystemPrincipal::GetHasCertificate(PRBool* aResult)
+{
+    *aResult = PR_FALSE;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSystemPrincipal::GetDomain(nsIURI** aDomain)
+{
+    *aDomain = nsnull;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSystemPrincipal::SetDomain(nsIURI* aDomain)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSystemPrincipal::GetSecurityPolicy(void** aSecurityPolicy)
+{
+    *aSecurityPolicy = nsnull;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSystemPrincipal::SetSecurityPolicy(void* aSecurityPolicy)
+{
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSystemPrincipal::GetJsPrincipals(JSPrincipals **jsprin)
+{
+    if (mJSPrincipals.nsIPrincipalPtr == nsnull) {
+        mJSPrincipals.nsIPrincipalPtr = this;
+        // No need for a ADDREF since it is a self-reference
+    }
+
+    *jsprin = &mJSPrincipals;
+    JSPRINCIPALS_HOLD(cx, *jsprin);
+    return NS_OK;
+}
+
+
 //////////////////////////////////////////
 // Methods implementing nsISerializable //
 //////////////////////////////////////////
 
 NS_IMETHODIMP
 nsSystemPrincipal::Read(nsIObjectInputStream* aStream)
 {
     // no-op: CID is sufficient to identify the mSystemPrincipal singleton
@@ -165,17 +275,17 @@ nsSystemPrincipal::Write(nsIObjectOutput
 /////////////////////////////////////////////
 // Constructor, Destructor, initialization //
 /////////////////////////////////////////////
 
 nsSystemPrincipal::nsSystemPrincipal()
 {
 }
 
-NS_IMETHODIMP
+nsresult
 nsSystemPrincipal::Init()
 {
     char *codebase = nsCRT::strdup("[System Principal]");
     if (!codebase)
         return NS_ERROR_OUT_OF_MEMORY;
     if (NS_FAILED(mJSPrincipals.Init(codebase))) 
         return NS_ERROR_FAILURE;
     return NS_OK;
Index: content/base/src/nsDocument.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/base/src/nsDocument.cpp,v
retrieving revision 3.445
diff -p -u -d -8 -r3.445 nsDocument.cpp
--- content/base/src/nsDocument.cpp	21 Jul 2003 22:04:46 -0000	3.445
+++ content/base/src/nsDocument.cpp	23 Jul 2003 23:08:59 -0000
@@ -82,17 +82,17 @@
 #include "nsNodeInfoManager.h"
 #include "nsIXBLService.h"
 #include "nsIXPointer.h"
 #include "nsIFileChannel.h"
 
 #include "nsNetUtil.h"     // for NS_MakeAbsoluteURI
 
 #include "nsIScriptSecurityManager.h"
-#include "nsIAggregatePrincipal.h"
+#include "nsIPrincipal.h"
 #include "nsIPrivateDOMImplementation.h"
 
 #include "nsIDOMWindowInternal.h"
 #include "nsPIDOMWindow.h"
 #include "nsIDOMElement.h"
 
 #include "nsIBoxObject.h"
 #include "nsPIBoxObject.h"
@@ -843,28 +843,32 @@ nsDocument::GetPrincipal(nsIPrincipal **
   NS_ADDREF(*aPrincipal);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDocument::AddPrincipal(nsIPrincipal *aNewPrincipal)
 {
-  nsresult rv;
+  NS_PRECONDITION(aNewPrincipal, "Null principal!");
+
   if (!mPrincipal) {
     nsCOMPtr<nsIPrincipal> principal;
-    rv = GetPrincipal(getter_AddRefs(principal));
+    nsresult rv = GetPrincipal(getter_AddRefs(principal));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
-  nsCOMPtr<nsIAggregatePrincipal> agg(do_QueryInterface(mPrincipal, &rv));
-  if (NS_SUCCEEDED(rv)) {
-    rv = agg->Intersect(aNewPrincipal);
-    if (NS_FAILED(rv))
-      return rv;
+  PRBool hasCert;
+  mPrincipal->GetHasCertificate(&hasCert);
+  if (hasCert) {
+    PRBool equal;
+    mPrincipal->Equals(aNewPrincipal, &equal);
+    if (!equal) {
+      mPrincipal->SetCertificateID(nsnull);
+    }
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDocument::GetContentType(nsAString& aContentType)
 {
Index: content/base/src/nsFrameLoader.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/base/src/nsFrameLoader.cpp,v
retrieving revision 1.21
diff -p -u -d -8 -r1.21 nsFrameLoader.cpp
--- content/base/src/nsFrameLoader.cpp	14 Jul 2003 07:36:49 -0000	1.21
+++ content/base/src/nsFrameLoader.cpp	23 Jul 2003 23:08:59 -0000
@@ -54,17 +54,16 @@
 #include "nsIDocShellTreeItem.h"
 #include "nsIDocShellTreeNode.h"
 #include "nsIDocShellTreeOwner.h"
 #include "nsIDocShellLoadInfo.h"
 #include "nsIBaseWindow.h"
 #include "nsIWebShell.h"
 
 #include "nsIScriptSecurityManager.h"
-#include "nsICodebasePrincipal.h"
 
 #include "nsIURI.h"
 #include "nsNetUtil.h"
 
 #include "nsHTMLAtoms.h"
 #include "nsINameSpaceManager.h"
 
 // Bug 98158: Limit to the number of total docShells in one page.
@@ -186,22 +185,18 @@ nsFrameLoader::LoadFrame()
   nsCOMPtr<nsIURI> referrer;
   nsCOMPtr<nsIPrincipal> principal;
   rv = secMan->GetSubjectPrincipal(getter_AddRefs(principal));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // If we were called from script, get the referring URL from the script
 
   if (principal) {
-    nsCOMPtr<nsICodebasePrincipal> codebase(do_QueryInterface(principal));
-
-    if (codebase) {
-      rv = codebase->GetURI(getter_AddRefs(referrer));
-      NS_ENSURE_SUCCESS(rv, rv);
-    }
+    rv = principal->GetURI(getter_AddRefs(referrer));
+    NS_ENSURE_SUCCESS(rv, rv);
 
     // Pass the script principal to the docshell
 
     loadInfo->SetOwner(principal);
   }
 
   if (!referrer) {
     // We're not being called form script, tell the docshell
Index: content/base/src/nsGenericElement.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/base/src/nsGenericElement.cpp,v
retrieving revision 3.279
diff -p -u -d -8 -r3.279 nsGenericElement.cpp
--- content/base/src/nsGenericElement.cpp	14 Jul 2003 05:35:09 -0000	3.279
+++ content/base/src/nsGenericElement.cpp	23 Jul 2003 23:08:59 -0000
@@ -69,17 +69,17 @@
 #include "nsIPrivateDOMEvent.h"
 #include "nsDOMCID.h"
 #include "nsIServiceManager.h"
 #include "nsIDOMCSSStyleDeclaration.h"
 #include "nsDOMCSSDeclaration.h"
 #include "nsINameSpaceManager.h"
 #include "nsContentList.h"
 #include "nsDOMError.h"
-#include "nsScriptSecurityManager.h"
+#include "nsIScriptSecurityManager.h"
 #include "nsIDOMMutationEvent.h"
 #include "nsMutationEvent.h"
 
 #include "nsIBindingManager.h"
 #include "nsIXBLBinding.h"
 #include "nsIDOMCSSStyleDeclaration.h"
 #include "nsIDOMViewCSS.h"
 #include "nsIXBLService.h"
Index: content/base/src/nsNodeInfoManager.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/base/src/nsNodeInfoManager.cpp,v
retrieving revision 1.20
diff -p -u -d -8 -r1.20 nsNodeInfoManager.cpp
--- content/base/src/nsNodeInfoManager.cpp	13 Jun 2003 20:07:50 -0000	1.20
+++ content/base/src/nsNodeInfoManager.cpp	23 Jul 2003 23:08:59 -0000
@@ -38,16 +38,17 @@
 
 #include "nsNodeInfoManager.h"
 #include "nsNodeInfo.h"
 #include "nsCOMPtr.h"
 #include "nsString.h"
 #include "nsIAtom.h"
 #include "nsIDocument.h"
 #include "nsIPrincipal.h"
+#include "nsIURI.h"
 #include "nsISupportsArray.h"
 #include "nsContentUtils.h"
 
 nsNodeInfoManager* nsNodeInfoManager::gAnonymousNodeInfoManager = nsnull;
 PRUint32 nsNodeInfoManager::gNodeManagerCount = 0;
 
 
 nsresult NS_NewNodeInfoManager(nsINodeInfoManager** aResult)
Index: content/base/src/nsNodeInfoManager.h
===================================================================
RCS file: /cvsroot/mozilla/content/base/src/nsNodeInfoManager.h,v
retrieving revision 1.11
diff -p -u -d -8 -r1.11 nsNodeInfoManager.h
--- content/base/src/nsNodeInfoManager.h	13 Jun 2003 20:07:50 -0000	1.11
+++ content/base/src/nsNodeInfoManager.h	23 Jul 2003 23:08:59 -0000
@@ -37,20 +37,20 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsNodeInfoManager_h___
 #define nsNodeInfoManager_h___
 
 #include "nsINodeInfo.h"
 #include "nsCOMPtr.h"
 #include "plhash.h"
-#include "nsIURI.h"
-#include "nsIPrincipal.h"
 
 class nsNodeInfo;
+class nsIPrincipal;
+class nsIURI;
 
 
 class nsNodeInfoManager : public nsINodeInfoManager
 {
 public:
   NS_DECL_ISUPPORTS
 
   // nsINodeInfoManager
Index: content/base/src/nsRange.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/base/src/nsRange.cpp,v
retrieving revision 1.167
diff -p -u -d -8 -r1.167 nsRange.cpp
--- content/base/src/nsRange.cpp	13 Jun 2003 20:07:51 -0000	1.167
+++ content/base/src/nsRange.cpp	23 Jul 2003 23:08:59 -0000
@@ -56,17 +56,17 @@
 #include "nsDOMError.h"
 #include "nsIContentIterator.h"
 #include "nsIDOMNodeList.h"
 #include "nsIParser.h"
 #include "nsIComponentManager.h"
 #include "nsParserCIID.h"
 #include "nsIHTMLFragmentContentSink.h"
 #include "nsIEnumerator.h"
-#include "nsScriptSecurityManager.h"
+#include "nsIScriptSecurityManager.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIScriptContext.h"
 #include "nsIHTMLDocument.h"
 #include "nsCRT.h"
 
 #include "nsIJSContextStack.h"
 // XXX Temporary inclusion to deal with fragment parsing
 #include "nsHTMLParts.h"
Index: content/base/src/nsScriptLoader.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/base/src/nsScriptLoader.cpp,v
retrieving revision 1.40
diff -p -u -d -8 -r1.40 nsScriptLoader.cpp
--- content/base/src/nsScriptLoader.cpp	14 Jul 2003 07:36:51 -0000	1.40
+++ content/base/src/nsScriptLoader.cpp	23 Jul 2003 23:08:59 -0000
@@ -863,28 +863,26 @@ nsScriptLoader::OnStreamComplete(nsIStre
       ProcessPendingReqests();
       return NS_OK;
     }
 
     //-- Merge the principal of the script file with that of the document
     if (channel) {
       nsCOMPtr<nsISupports> owner;
       channel->GetOwner(getter_AddRefs(owner));
-      nsCOMPtr<nsIPrincipal> prin;
-      
-      if (owner) {
-        prin = do_QueryInterface(owner, &rv);
-      }
-      
-      rv = mDocument->AddPrincipal(prin);
-      if (NS_FAILED(rv)) {
-        mPendingRequests.RemoveObject(request);
-        FireScriptAvailable(rv, request, NS_LITERAL_STRING(""));
-        ProcessPendingReqests();
-        return NS_OK;
+      nsCOMPtr<nsIPrincipal> principal = do_QueryInterface(owner);
+
+      if (principal) {
+        rv = mDocument->AddPrincipal(principal);
+        if (NS_FAILED(rv)) {
+          mPendingRequests.RemoveObject(request);
+          FireScriptAvailable(rv, request, NS_LITERAL_STRING(""));
+          ProcessPendingReqests();
+          return NS_OK;
+        }
       }
     }
   }
 
 
   // If we're not the first in the pending list, we mark ourselves
   // as loaded and just stay on the list.
   NS_ASSERTION(mPendingRequests.Count() > 0, "aContext is a pending request!");
Index: content/events/src/nsEventListenerManager.h
===================================================================
RCS file: /cvsroot/mozilla/content/events/src/nsEventListenerManager.h,v
retrieving revision 1.59
diff -p -u -d -8 -r1.59 nsEventListenerManager.h
--- content/events/src/nsEventListenerManager.h	22 Jun 2003 13:12:14 -0000	1.59
+++ content/events/src/nsEventListenerManager.h	23 Jul 2003 23:08:59 -0000
@@ -37,17 +37,16 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsEventListenerManager_h__
 #define nsEventListenerManager_h__
 
 #include "nsIEventListenerManager.h"
 #include "jsapi.h"
 #include "nsCOMPtr.h"
-#include "nsIPrincipal.h"
 #include "nsIDOMEventReceiver.h"
 #include "nsIDOM3EventTarget.h"
 #include "nsHashtable.h"
 #include "nsIScriptContext.h"
 
 class nsIDOMEvent;
 class nsIAtom;
 
Index: content/html/document/src/nsHTMLContentSink.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/html/document/src/nsHTMLContentSink.cpp,v
retrieving revision 3.637
diff -p -u -d -8 -r3.637 nsHTMLContentSink.cpp
--- content/html/document/src/nsHTMLContentSink.cpp	22 Jul 2003 18:37:36 -0000	3.637
+++ content/html/document/src/nsHTMLContentSink.cpp	23 Jul 2003 23:09:00 -0000
@@ -111,18 +111,16 @@
 #include "nsStyleConsts.h"
 #include "nsINameSpaceManager.h"
 #include "nsIDOMHTMLMapElement.h"
 #include "nsIRefreshURI.h"
 #include "nsICookieService.h"
 #include "nsVoidArray.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsIPrincipal.h"
-#include "nsICodebasePrincipal.h"
-#include "nsIAggregatePrincipal.h"
 #include "nsTextFragment.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIScriptGlobalObjectOwner.h"
 
 #include "nsIParserService.h"
 #include "nsISelectElement.h"
 #include "nsITextAreaElement.h"
 
@@ -5176,34 +5174,25 @@ HTMLContentSink::ProcessHeaderData(nsIAt
     // by SetDomain
 
     nsCOMPtr<nsIPrincipal> docPrincipal;
     rv = mDocument->GetPrincipal(getter_AddRefs(docPrincipal));
     if (NS_FAILED(rv) || !docPrincipal) {
       return rv;
     }
 
-    nsCOMPtr<nsIAggregatePrincipal> agg(do_QueryInterface(docPrincipal, &rv));
-    // Document principal should always be an aggregate
-    NS_ENSURE_SUCCESS(rv, rv);
+    nsCOMPtr<nsIURI> codebaseURI;
+    docPrincipal->GetURI(getter_AddRefs(codebaseURI));
 
-    nsCOMPtr<nsIPrincipal> originalPrincipal;
-    rv = agg->GetOriginalCodebase(getter_AddRefs(originalPrincipal));
-    nsCOMPtr<nsICodebasePrincipal> originalCodebase =
-      do_QueryInterface(originalPrincipal, &rv);
-    if (NS_FAILED(rv)) {
+    if (!codebaseURI) {
       // Document's principal is not a codebase (may be system), so
       // can't set cookies
 
       return NS_OK;
     }
-
-    nsCOMPtr<nsIURI> codebaseURI;
-    rv = originalCodebase->GetURI(getter_AddRefs(codebaseURI));
-    NS_ENSURE_SUCCESS(rv, rv);
 
     char *cookie = ToNewUTF8String(aValue);
     nsCOMPtr<nsIScriptGlobalObject> globalObj;
     nsCOMPtr<nsIPrompt> prompt;
     mDocument->GetScriptGlobalObject(getter_AddRefs(globalObj));
     if (globalObj) {
       nsCOMPtr<nsIDOMWindowInternal> window (do_QueryInterface(globalObj));
       if (window) {
Index: content/html/document/src/nsHTMLDocument.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/html/document/src/nsHTMLDocument.cpp,v
retrieving revision 3.499
diff -p -u -d -8 -r3.499 nsHTMLDocument.cpp
--- content/html/document/src/nsHTMLDocument.cpp	15 Jul 2003 02:07:55 -0000	3.499
+++ content/html/document/src/nsHTMLDocument.cpp	23 Jul 2003 23:09:00 -0000
@@ -80,18 +80,17 @@
 #include "nsIBaseWindow.h"
 #include "nsIWebShellServices.h"
 #include "nsIDocumentLoader.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIScriptContext.h"
 #include "nsIXPConnect.h"
 #include "nsContentList.h"
 #include "nsDOMError.h"
-#include "nsICodebasePrincipal.h"
-#include "nsIAggregatePrincipal.h"
+#include "nsIPrincipal.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsIScrollableView.h"
 
 #include "nsIIOService.h"
 #include "nsICookieService.h"
 
 #include "nsIServiceManager.h"
 #include "nsIConsoleService.h"
@@ -1891,21 +1890,20 @@ void
 nsHTMLDocument::GetDomainURI(nsIURI **aURI)
 {
   *aURI = nsnull;
 
   nsCOMPtr<nsIPrincipal> principal;
   if (NS_FAILED(GetPrincipal(getter_AddRefs(principal))))
     return;
 
-  nsCOMPtr<nsICodebasePrincipal> codebase = do_QueryInterface(principal);
-  if (!codebase)
-    return;
-
-  codebase->GetURI(aURI);
+  principal->GetDomain(aURI);
+  if (!*aURI) {
+    principal->GetURI(aURI);
+  }
 }
 
 
 NS_IMETHODIMP
 nsHTMLDocument::GetDomain(nsAString& aDomain)
 {
   nsCOMPtr<nsIURI> uri;
   GetDomainURI(getter_AddRefs(uri));
@@ -1967,37 +1965,20 @@ nsHTMLDocument::SetDomain(const nsAStrin
   NS_ConvertUTF8toUCS2 newURIString(scheme);
   newURIString.Append(NS_LITERAL_STRING("://") + aDomain +
                       NS_ConvertUTF8toUCS2(path));
 
   nsCOMPtr<nsIURI> newURI;
   if (NS_FAILED(NS_NewURI(getter_AddRefs(newURI), newURIString)))
     return NS_ERROR_FAILURE;
 
-  // Get codebase principal
-  nsresult rv;
-  nsCOMPtr<nsIScriptSecurityManager> securityManager =
-           do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
-  if (NS_FAILED(rv))
-    return NS_ERROR_FAILURE;
-  nsCOMPtr<nsIPrincipal> newCodebase;
-  rv = securityManager->GetCodebasePrincipal(newURI,
-                                             getter_AddRefs(newCodebase));
-    if (NS_FAILED(rv))
-    return NS_ERROR_FAILURE;
-  nsCOMPtr<nsIAggregatePrincipal> agg = do_QueryInterface(mPrincipal, &rv);
-  NS_ASSERTION(NS_SUCCEEDED(rv), "Principal not an aggregate.");
-  if (NS_FAILED(rv))
-    return NS_ERROR_FAILURE;
-
-  rv = agg->SetCodebase(newCodebase);
+  nsresult rv = mPrincipal->SetDomain(newURI);
 
   // Bug 13871: Frameset spoofing - note that document.domain was set
   if (NS_SUCCEEDED(rv)) {
-    agg->SetDomainChanged(PR_TRUE);
     mDomainWasSet = PR_TRUE;
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 nsHTMLDocument::WasDomainSet(PRBool* aDomainWasSet)
@@ -2252,33 +2233,26 @@ nsHTMLDocument::GetCookie(nsAString& aCo
 
   nsresult rv = NS_OK;
   nsAutoString str;
 
   nsCOMPtr<nsICookieService> service = do_GetService(kCookieServiceCID, &rv);
   if (service) {
     // Get a URI from the document principal. We use the original
     // codebase in case the codebase was changed by SetDomain
-    nsCOMPtr<nsIAggregatePrincipal> agg(do_QueryInterface(mPrincipal, &rv));
-    // Document principal should always be an aggregate
-    NS_ENSURE_SUCCESS(rv, rv);
+    nsCOMPtr<nsIURI> codebaseURI;
+    mPrincipal->GetURI(getter_AddRefs(codebaseURI));
+
+    if (!codebaseURI) {
+      // Document's principal is not a codebase (may be system), so
+      // can't set cookies
 
-    nsCOMPtr<nsIPrincipal> originalPrincipal;
-    rv = agg->GetOriginalCodebase(getter_AddRefs(originalPrincipal));
-    nsCOMPtr<nsICodebasePrincipal> originalCodebase(
-        do_QueryInterface(originalPrincipal, &rv));
-    if (NS_FAILED(rv)) {
-      // Document's principal is not a codebase, so can't get cookies
       return NS_OK;
     }
 
-    nsCOMPtr<nsIURI> codebaseURI;
-    rv = originalCodebase->GetURI(getter_AddRefs(codebaseURI));
-    NS_ENSURE_SUCCESS(rv, rv);
-
     nsXPIDLCString cookie;
       rv = service->GetCookieString(codebaseURI, mChannel, getter_Copies(cookie));
     if (NS_SUCCEEDED(rv) && cookie)
       CopyASCIItoUCS2(nsDependentCString(cookie), aCookie);
   }
   return rv;
 }
 
@@ -2304,35 +2278,26 @@ nsHTMLDocument::SetCookie(const nsAStrin
     this->GetScriptGlobalObject(getter_AddRefs(globalObj));
     if (globalObj) {
       nsCOMPtr<nsIDOMWindowInternal> window (do_QueryInterface(globalObj));
       if (window) {
         window->GetPrompter(getter_AddRefs(prompt));
       }
     }
 
-    // Get a URI from the document principal. We use the original
-    // codebase in case the codebase was changed by SetDomain
-    nsCOMPtr<nsIAggregatePrincipal> agg(do_QueryInterface(mPrincipal, &rv));
-    // Document principal should always be an aggregate
-    NS_ENSURE_SUCCESS(rv, rv);
+    nsCOMPtr<nsIURI> codebaseURI;
+    mPrincipal->GetURI(getter_AddRefs(codebaseURI));
+
+    if (!codebaseURI) {
+      // Document's principal is not a codebase (may be system), so
+      // can't set cookies
 
-    nsCOMPtr<nsIPrincipal> originalPrincipal;
-    rv = agg->GetOriginalCodebase(getter_AddRefs(originalPrincipal));
-    nsCOMPtr<nsICodebasePrincipal> originalCodebase(
-        do_QueryInterface(originalPrincipal, &rv));
-    if (NS_FAILED(rv)) {
-      // Document's principal is not a codebase, so can't set cookies
       return NS_OK;
     }
 
-    nsCOMPtr<nsIURI> codebaseURI;
-    rv = originalCodebase->GetURI(getter_AddRefs(codebaseURI));
-    NS_ENSURE_SUCCESS(rv, rv);
-
     rv = NS_ERROR_OUT_OF_MEMORY;
     char* cookie = ToNewCString(aCookie);
     if (cookie) {
       rv = service->SetCookieString(codebaseURI, prompt, cookie, mChannel);
       nsCRT::free(cookie);
     }
   }
   return rv;
@@ -2698,29 +2663,22 @@ nsHTMLDocument::ScriptWriteCommon(PRBool
     nsCOMPtr<nsIScriptSecurityManager> secMan =
       do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
 
     nsCOMPtr<nsIPrincipal> subject;
     rv = secMan->GetSubjectPrincipal(getter_AddRefs(subject));
     NS_ENSURE_SUCCESS(rv, rv);
 
-    // why is the above code duplicated below???
-    rv = secMan->GetSubjectPrincipal(getter_AddRefs(subject));
-    NS_ENSURE_SUCCESS(rv, rv);
-
     if (subject) {
-      nsCOMPtr<nsICodebasePrincipal> codebase = do_QueryInterface(subject);
-      if (codebase) {
-        nsCOMPtr<nsIURI> subjectURI;
-        rv = codebase->GetURI(getter_AddRefs(subjectURI));
-        NS_ENSURE_SUCCESS(rv, rv);
+      nsCOMPtr<nsIURI> subjectURI;
+      subject->GetURI(getter_AddRefs(subjectURI));
 
+      if (subjectURI) {
         mDocumentURL = subjectURI;
-
         mPrincipal = subject;
       }
     }
   }
 
   if (ncc) {
     // We're called from JS, concatenate the extra arguments into
     // string_buffer
Index: content/xml/document/src/nsXMLContentSink.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/xml/document/src/nsXMLContentSink.cpp,v
retrieving revision 1.278
diff -p -u -d -8 -r1.278 nsXMLContentSink.cpp
--- content/xml/document/src/nsXMLContentSink.cpp	22 Jul 2003 18:37:42 -0000	1.278
+++ content/xml/document/src/nsXMLContentSink.cpp	23 Jul 2003 23:09:00 -0000
@@ -93,18 +93,16 @@
 #include "nsReadableUtils.h"
 #include "nsUnicharUtils.h"
 #include "nsICookieService.h"
 #include "nsIPrompt.h"
 #include "nsIDOMWindowInternal.h"
 #include "nsIChannel.h"
 #include "nsIHttpChannel.h"
 #include "nsIPrincipal.h"
-#include "nsIAggregatePrincipal.h"
-#include "nsICodebasePrincipal.h"
 #include "nsXBLAtoms.h"
 #include "nsXMLPrettyPrinter.h"
 
 // XXX misnamed header file, but oh well
 #include "nsHTMLTokens.h"
 
 static const char kNameSpaceSeparator = ':';
 #define kXSLType "text/xsl"
@@ -1077,35 +1075,29 @@ nsXMLContentSink::ProcessHeaderData(nsIA
   else if (aHeader == nsHTMLAtoms::setcookie) {
     nsCOMPtr<nsICookieService> cookieServ = do_GetService(NS_COOKIESERVICE_CONTRACTID, &rv);
     if (NS_FAILED(rv)) return rv;
     
     // Get a URI from the document principal
     // We use the original codebase in case the codebase was changed by SetDomain
     nsCOMPtr<nsIPrincipal> docPrincipal;
     rv = mDocument->GetPrincipal(getter_AddRefs(docPrincipal));
-    if (NS_FAILED(rv)) return rv;
-    if (!docPrincipal) return NS_OK;
-
-    nsCOMPtr<nsIAggregatePrincipal> agg(do_QueryInterface(docPrincipal, &rv));
-    // Document principal should always be an aggregate
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    nsCOMPtr<nsIPrincipal> originalPrincipal;
-    rv = agg->GetOriginalCodebase(getter_AddRefs(originalPrincipal));
-    nsCOMPtr<nsICodebasePrincipal> originalCodebase(
-        do_QueryInterface(originalPrincipal, &rv));
-    if (NS_FAILED(rv)) {
-      // Document's principal is not a codebase (may be system), so can't set cookies
-      return NS_OK; 
+    if (NS_FAILED(rv) || !docPrincipal) {
+      return rv;
     }
 
     nsCOMPtr<nsIURI> codebaseURI;
-    rv = originalCodebase->GetURI(getter_AddRefs(codebaseURI));
-    NS_ENSURE_SUCCESS(rv, rv);
+    docPrincipal->GetURI(getter_AddRefs(codebaseURI));
+
+    if (!codebaseURI) {
+      // Document's principal is not a codebase (may be system), so
+      // can't set cookies
+
+      return NS_OK;
+    }
 
     nsCOMPtr<nsIScriptGlobalObject> globalObj;
     nsCOMPtr<nsIPrompt> prompt;
     mDocument->GetScriptGlobalObject(getter_AddRefs(globalObj));
     if (globalObj) {
       nsCOMPtr<nsIDOMWindowInternal> window (do_QueryInterface(globalObj));
       if (window) {
         window->GetPrompter(getter_AddRefs(prompt));
Index: content/xml/document/src/nsXMLDocument.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/xml/document/src/nsXMLDocument.cpp,v
retrieving revision 1.185
diff -p -u -d -8 -r1.185 nsXMLDocument.cpp
--- content/xml/document/src/nsXMLDocument.cpp	25 Jun 2003 23:59:34 -0000	1.185
+++ content/xml/document/src/nsXMLDocument.cpp	23 Jul 2003 23:09:00 -0000
@@ -71,19 +71,18 @@
 #include "nsXPIDLString.h"
 #include "nsIHttpChannel.h"
 #include "nsIURI.h"
 #include "nsIServiceManager.h"
 #include "nsICharsetAlias.h"
 #include "nsICharsetAlias.h"
 #include "nsNetUtil.h"
 #include "nsDOMError.h"
-#include "nsScriptSecurityManager.h"
+#include "nsIScriptSecurityManager.h"
 #include "nsIPrincipal.h"
-#include "nsIAggregatePrincipal.h"
 #include "nsLayoutCID.h"
 #include "nsDOMAttribute.h"
 #include "nsGUIEvent.h"
 #include "nsIFIXptr.h"
 #include "nsIXPointer.h"
 #include "nsCExternalHandlerService.h"
 #include "nsIMIMEService.h"
 #include "nsNetUtil.h"
@@ -325,31 +324,17 @@ nsXMLDocument::OnRedirect(nsIHttpChannel
     rv = secMan->CheckSameOrigin(nsnull, newLocation);
 
     stack->Pop(&cx);
   
     if (NS_FAILED(rv))
       return rv;
   }
 
-  nsCOMPtr<nsIPrincipal> newCodebase;
-  rv = secMan->GetCodebasePrincipal(newLocation,
-                                    getter_AddRefs(newCodebase));
-  if (NS_FAILED(rv))
-    return NS_ERROR_FAILURE;
-
-  nsCOMPtr<nsIAggregatePrincipal> agg = do_QueryInterface(mPrincipal, &rv);
-  NS_ASSERTION(NS_SUCCEEDED(rv), "Principal not an aggregate.");
-
-  if (NS_FAILED(rv))
-    return NS_ERROR_FAILURE;
-
-  rv = agg->SetCodebase(newCodebase);
-
-  return rv;
+  return mPrincipal->SetURI(newLocation);
 }
 
 NS_IMETHODIMP
 nsXMLDocument::EvaluateFIXptr(const nsAString& aExpression, nsIDOMRange **aRange)
 {
   nsresult rv;
   nsCOMPtr<nsIFIXptrEvaluator> e =
     do_CreateInstance("@mozilla.org/xmlextras/fixptrevaluator;1", &rv);
Index: content/xul/document/src/nsXULDocument.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/xul/document/src/nsXULDocument.cpp,v
retrieving revision 1.572
diff -p -u -d -8 -r1.572 nsXULDocument.cpp
--- content/xul/document/src/nsXULDocument.cpp	11 Jul 2003 21:15:11 -0000	1.572
+++ content/xul/document/src/nsXULDocument.cpp	23 Jul 2003 23:09:01 -0000
@@ -63,17 +63,17 @@
 */
 
 // Note the ALPHABETICAL ORDERING
 #include "nsXULDocument.h"
 
 #include "nsDOMError.h"
 #include "nsIBoxObject.h"
 #include "nsIChromeRegistry.h"
-#include "nsICodebasePrincipal.h"
+#include "nsIPrincipal.h"
 #include "nsIContentSink.h" // for NS_CONTENT_ID_COUNTER_BASE
 #include "nsIScrollableView.h"
 #include "nsIContentViewer.h"
 #include "nsGUIEvent.h"
 #include "nsIDOMXULElement.h"
 #include "nsIElementFactory.h"
 #include "nsIPrivateDOMEvent.h"
 #include "nsIRDFNode.h"
Index: docshell/base/nsDocShell.cpp
===================================================================
RCS file: /cvsroot/mozilla/docshell/base/nsDocShell.cpp,v
retrieving revision 1.557
diff -p -u -d -8 -r1.557 nsDocShell.cpp
--- docshell/base/nsDocShell.cpp	8 Jul 2003 19:17:54 -0000	1.557
+++ docshell/base/nsDocShell.cpp	23 Jul 2003 23:09:02 -0000
@@ -47,17 +47,17 @@
 #include "nsPoint.h"
 #include "nsGfxCIID.h"
 #include "nsIPrompt.h"
 #include "nsIAuthPrompt.h"
 #include "nsTextFormatter.h"
 #include "nsIHttpEventSink.h"
 #include "nsIUploadChannel.h"
 #include "nsISecurityEventSink.h"
-#include "nsScriptSecurityManager.h"
+#include "nsIScriptSecurityManager.h"
 #include "nsDocumentCharsetInfoCID.h"
 #include "nsICanvasFrame.h"
 #include "nsContentPolicyUtils.h" // NS_CheckContentLoadPolicy(...)
 #include "nsICategoryManager.h"
 #include "nsXPCOMCID.h"
 #include "nsISeekableStream.h"
 
 // we want to explore making the document own the load group
@@ -100,17 +100,16 @@
 #include "nsPIDOMWindow.h"
 #include "nsIDOMDocument.h"
 #include "nsICachingChannel.h"
 #include "nsICacheEntryDescriptor.h"
 #include "nsIMultiPartChannel.h"
 #include "nsIWyciwygChannel.h"
 
 // The following are for bug #13871: Prevent frameset spoofing
-#include "nsICodebasePrincipal.h"
 #include "nsIHTMLDocument.h"
 
 // For reporting errors with the console service.
 // These can go away if error reporting is propagated up past nsDocShell.
 #include "nsIConsoleService.h"
 #include "nsIScriptError.h"
 
 // used to dispatch urls to default protocol handlers
@@ -950,21 +949,18 @@ PRBool ValidateOrigin(nsIDocShellTreeIte
 
   nsCOMPtr<nsIDocument> targetDocument(do_QueryInterface(targetDOMDocument));
   NS_ENSURE_TRUE(targetDocument, NS_ERROR_FAILURE);
 
   nsCOMPtr<nsIPrincipal> targetPrincipal;
   rv = targetDocument->GetPrincipal(getter_AddRefs(targetPrincipal));
   NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && targetPrincipal, rv);
 
-  nsCOMPtr<nsICodebasePrincipal> targetCodebasePrincipal(do_QueryInterface(targetPrincipal));
-  NS_ENSURE_TRUE(targetCodebasePrincipal, PR_TRUE);
-
   nsCOMPtr<nsIURI> targetPrincipalURI;
-  rv = targetCodebasePrincipal->GetURI(getter_AddRefs(targetPrincipalURI));
+  rv = targetPrincipal->GetURI(getter_AddRefs(targetPrincipalURI));
   NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && targetPrincipalURI, PR_TRUE);
 
   // Find out if document.domain was set for HTML documents
   PRBool documentDomainSet = PR_FALSE;
   nsCOMPtr<nsIHTMLDocument> targetHTMLDocument(do_QueryInterface(targetDocument));
 
   // If we don't have an HTML document, fall through with documentDomainSet false
   if (targetHTMLDocument) {
Index: dom/src/base/nsGlobalWindow.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/base/nsGlobalWindow.cpp,v
retrieving revision 1.607
diff -p -u -d -8 -r1.607 nsGlobalWindow.cpp
--- dom/src/base/nsGlobalWindow.cpp	20 Jul 2003 07:45:52 -0000	1.607
+++ dom/src/base/nsGlobalWindow.cpp	23 Jul 2003 23:09:02 -0000
@@ -68,17 +68,16 @@
 #include "nsIJVMManager.h"
 #endif
 #include "nsContentCID.h"
 
 // Interfaces Needed
 #include "nsIWidget.h"
 #include "nsIBaseWindow.h"
 #include "nsICharsetConverterManager.h"
-#include "nsICodebasePrincipal.h"
 #include "nsIContent.h"
 #include "nsIWebBrowserPrint.h"
 #include "nsIContentViewerEdit.h"
 #include "nsIDocShell.h"
 #include "nsIDocShellLoadInfo.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsIDocShellTreeNode.h"
 #include "nsIDocCharset.h"
@@ -4663,22 +4662,23 @@ GlobalWindowImpl::OpenInternal(const nsA
         CallQueryInterface(domReturn, aReturn);
 
         // Save the prinicpal of the calling script
         // We need it to decide whether to clear the scope in SetNewDocument
         NS_ASSERTION(sSecMan, "No Security Manager Found!");
         if (sSecMan) {
           nsCOMPtr<nsIPrincipal> principal;
           sSecMan->GetSubjectPrincipal(getter_AddRefs(principal));
-          nsCOMPtr<nsICodebasePrincipal> codebasePrin(do_QueryInterface(principal));
-          if (codebasePrin) {
+          if (principal) {
             nsCOMPtr<nsIURI> subjectURI;
-            codebasePrin->GetURI(getter_AddRefs(subjectURI));
-            nsCOMPtr<nsPIDOMWindow> domReturnPrivate(do_QueryInterface(domReturn));
-            domReturnPrivate->SetOpenerScriptURL(subjectURI);
+            principal->GetURI(getter_AddRefs(subjectURI));
+            if (subjectURI) {
+              nsCOMPtr<nsPIDOMWindow> domReturnPrivate(do_QueryInterface(domReturn));
+              domReturnPrivate->SetOpenerScriptURL(subjectURI);
+            }
           }
         }
       }
     }
   }
 
   return rv;
 }
Index: dom/src/base/nsJSEnvironment.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/base/nsJSEnvironment.cpp,v
retrieving revision 1.198
diff -p -u -d -8 -r1.198 nsJSEnvironment.cpp
--- dom/src/base/nsJSEnvironment.cpp	11 Jul 2003 22:54:29 -0000	1.198
+++ dom/src/base/nsJSEnvironment.cpp	23 Jul 2003 23:09:02 -0000
@@ -623,30 +623,30 @@ nsJSContext::EvaluateStringWithValue(con
     aScopeObject = ::JS_GetGlobalObject(mContext);
 
   // Safety first: get an object representing the script's principals, i.e.,
   // the entities who signed this script, or the fully-qualified-domain-name
   // or "codebase" from which it was loaded.
   JSPrincipals *jsprin;
   nsCOMPtr<nsIPrincipal> principal = aPrincipal;
   if (aPrincipal) {
-    aPrincipal->GetJSPrincipals(&jsprin);
+    aPrincipal->GetJsPrincipals(&jsprin);
   }
   else {
     nsCOMPtr<nsIScriptGlobalObject> global;
     GetGlobalObject(getter_AddRefs(global));
     if (!global)
       return NS_ERROR_FAILURE;
     nsCOMPtr<nsIScriptObjectPrincipal> objPrincipal = do_QueryInterface(global, &rv);
     if (NS_FAILED(rv))
       return NS_ERROR_FAILURE;
     rv = objPrincipal->GetPrincipal(getter_AddRefs(principal));
     if (NS_FAILED(rv))
       return NS_ERROR_FAILURE;
-    principal->GetJSPrincipals(&jsprin);
+    principal->GetJsPrincipals(&jsprin);
   }
   // From here on, we must JSPRINCIPALS_DROP(jsprin) before returning...
 
   PRBool ok = PR_FALSE;
   nsCOMPtr<nsIScriptSecurityManager> securityManager;
   rv = GetSecurityManager(getter_AddRefs(securityManager));
   if (NS_SUCCEEDED(rv))
     rv = securityManager->CanExecuteScripts(mContext, principal, &ok);
@@ -801,30 +801,30 @@ nsJSContext::EvaluateString(const nsAStr
     aScopeObject = ::JS_GetGlobalObject(mContext);
 
   // Safety first: get an object representing the script's principals, i.e.,
   // the entities who signed this script, or the fully-qualified-domain-name
   // or "codebase" from which it was loaded.
   JSPrincipals *jsprin;
   nsCOMPtr<nsIPrincipal> principal = aPrincipal;
   if (aPrincipal) {
-    aPrincipal->GetJSPrincipals(&jsprin);
+    aPrincipal->GetJsPrincipals(&jsprin);
   }
   else {
     nsCOMPtr<nsIScriptGlobalObject> global;
     GetGlobalObject(getter_AddRefs(global));
     if (!global)
       return NS_ERROR_FAILURE;
     nsCOMPtr<nsIScriptObjectPrincipal> objPrincipal = do_QueryInterface(global, &rv);
     if (NS_FAILED(rv))
       return NS_ERROR_FAILURE;
     rv = objPrincipal->GetPrincipal(getter_AddRefs(principal));
     if (NS_FAILED(rv))
       return NS_ERROR_FAILURE;
-    principal->GetJSPrincipals(&jsprin);
+    principal->GetJsPrincipals(&jsprin);
   }
   // From here on, we must JSPRINCIPALS_DROP(jsprin) before returning...
 
   PRBool ok = PR_FALSE;
   nsCOMPtr<nsIScriptSecurityManager> securityManager;
   rv = GetSecurityManager(getter_AddRefs(securityManager));
   if (NS_SUCCEEDED(rv))
     rv = securityManager->CanExecuteScripts(mContext, principal, &ok);
@@ -914,17 +914,17 @@ nsJSContext::CompileScript(const PRUnich
 {
   nsresult rv;
   NS_ENSURE_ARG_POINTER(aPrincipal);
 
   if (!aScopeObject)
     aScopeObject = ::JS_GetGlobalObject(mContext);
 
   JSPrincipals *jsprin;
-  aPrincipal->GetJSPrincipals(&jsprin);
+  aPrincipal->GetJsPrincipals(&jsprin);
   // From here on, we must JSPRINCIPALS_DROP(jsprin) before returning...
 
   PRBool ok = PR_FALSE;
   nsCOMPtr<nsIScriptSecurityManager> securityManager;
   rv = GetSecurityManager(getter_AddRefs(securityManager));
   if (NS_SUCCEEDED(rv))
     rv = securityManager->CanExecuteScripts(mContext, aPrincipal, &ok);
   if (NS_FAILED(rv)) {
@@ -1088,17 +1088,17 @@ nsJSContext::CompileEventHandler(void *a
     // since that opens up security exploits with delayed event
     // handler compilation on stale DOM objects (objects that live in
     // a document that has already been unloaded).
     nsCOMPtr<nsIPrincipal> prin;
     nsresult rv = sSecurityManager->GetObjectPrincipal(mContext, target,
                                                        getter_AddRefs(prin));
     NS_ENSURE_SUCCESS(rv, rv);
 
-    prin->GetJSPrincipals(&jsprin);
+    prin->GetJsPrincipals(&jsprin);
     NS_ENSURE_TRUE(jsprin, NS_ERROR_NOT_AVAILABLE);
   }
 
   const char *charName = AtomToEventHandlerName(aName);
 
   JSFunction* fun =
       ::JS_CompileUCFunctionForPrincipals(mContext, target, jsprin,
                                           charName, 1, gEventArgv,
@@ -1141,17 +1141,17 @@ nsJSContext::CompileFunction(void* aTarg
   GetGlobalObject(getter_AddRefs(global));
   if (global) {
     // XXXbe why the two-step QI? speed up via a new GetGlobalObjectData func?
     nsCOMPtr<nsIScriptObjectPrincipal> globalData = do_QueryInterface(global);
     if (globalData) {
       nsCOMPtr<nsIPrincipal> prin;
       if (NS_FAILED(globalData->GetPrincipal(getter_AddRefs(prin))))
         return NS_ERROR_FAILURE;
-      prin->GetJSPrincipals(&jsprin);
+      prin->GetJsPrincipals(&jsprin);
     }
   }
 
   JSObject *target = (JSObject*)aTarget;
   JSFunction* fun =
       ::JS_CompileUCFunctionForPrincipals(mContext, target, jsprin,
                                           PromiseFlatCString(aName).get(),
                                           aArgCount, aArgArray,
Index: dom/src/base/nsLocation.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/base/nsLocation.cpp,v
retrieving revision 1.113
diff -p -u -d -8 -r1.113 nsLocation.cpp
--- dom/src/base/nsLocation.cpp	3 Jul 2003 02:45:25 -0000	1.113
+++ dom/src/base/nsLocation.cpp	23 Jul 2003 23:09:02 -0000
@@ -53,17 +53,16 @@
 #include "nsNetUtil.h"
 #include "plstr.h"
 #include "prprf.h"
 #include "prmem.h"
 #include "nsCOMPtr.h"
 #include "nsEscape.h"
 #include "nsJSUtils.h"
 #include "nsIScriptSecurityManager.h"
-#include "nsICodebasePrincipal.h"
 #include "nsIDOMWindow.h"
 #include "nsIDOMDocument.h"
 #include "nsIDocument.h"
 #include "nsIJSContextStack.h"
 #include "nsXPIDLString.h"
 #include "nsDOMError.h"
 #include "nsDOMClassInfo.h"
 #include "nsCRT.h"
Index: dom/src/jsurl/nsJSProtocolHandler.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/jsurl/nsJSProtocolHandler.cpp,v
retrieving revision 1.95
diff -p -u -d -8 -r1.95 nsJSProtocolHandler.cpp
--- dom/src/jsurl/nsJSProtocolHandler.cpp	14 Jul 2003 21:06:21 -0000	1.95
+++ dom/src/jsurl/nsJSProtocolHandler.cpp	23 Jul 2003 23:09:02 -0000
@@ -50,17 +50,16 @@
 #include "nsIGenericFactory.h"
 #include "nsIServiceManager.h"
 #include "nsIURI.h"
 #include "nsIScriptContext.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIScriptGlobalObjectOwner.h"
 #include "nsIPrincipal.h"
 #include "nsIScriptSecurityManager.h"
-#include "nsICodebasePrincipal.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsIStringStream.h"
 #include "nsIWindowMediator.h"
 #include "nsIDOMWindowInternal.h"
 #include "nsIDOMDocument.h"
 #include "nsIJSConsoleService.h"
 #include "nsIConsoleService.h"
@@ -225,42 +224,31 @@ nsresult nsJSThunk::EvaluateScript(nsICh
         nsCOMPtr<nsIPrincipal> objectPrincipal;
         rv = securityManager->GetObjectPrincipal(
                                 (JSContext*)scriptContext->GetNativeContext(),
                                 globalJSObject,
                                 getter_AddRefs(objectPrincipal));
         if (NS_FAILED(rv))
             return rv;
 
-        PRBool equals = PR_FALSE;
-        if ((NS_FAILED(objectPrincipal->Equals(principal, &equals)) || !equals)) {
-            // If the principals aren't equal
-
-            nsCOMPtr<nsIPrincipal> systemPrincipal;
-            securityManager->GetSystemPrincipal(getter_AddRefs(systemPrincipal));
-            if (principal.get() != systemPrincipal.get()) {
-                // and the script to be run does not have the system principal
-
-                nsCOMPtr<nsICodebasePrincipal> 
-                    objectCodebase(do_QueryInterface(objectPrincipal));
-                nsXPIDLCString objectOrigin;
-                rv = objectCodebase->GetOrigin(getter_Copies(objectOrigin));
-                if (PL_strcmp("about:blank", objectOrigin) != 0) {
-                    // and the target window is not about:blank, then
-                    // don't run the script. Print a message to the console and
-                    // return undefined.
-
-                    nsCOMPtr<nsIConsoleService> 
-                        console(do_GetService("@mozilla.org/consoleservice;1"));
-                    if (console) {
-                            console->LogStringMessage(
-                                NS_LITERAL_STRING("Attempt to load a javascript: URL from one host\nin a window displaying content from another host\nwas blocked by the security manager.").get());
-                    }
-                    return NS_ERROR_DOM_RETVAL_UNDEFINED;
+        nsCOMPtr<nsIPrincipal> systemPrincipal;
+        securityManager->GetSystemPrincipal(getter_AddRefs(systemPrincipal));
+        if (principal != systemPrincipal) {
+            rv = securityManager->CheckSameOriginPrincipal(principal,
+                                                           objectPrincipal);
+            if (NS_FAILED(rv)) {
+                nsCOMPtr<nsIConsoleService> console =
+                    do_GetService("@mozilla.org/consoleservice;1");
+                if (console) {
+                    // XXX Localize me!
+                    console->LogStringMessage(
+                        NS_LITERAL_STRING("Attempt to load a javascript: URL from one host\nin a window displaying content from another host\nwas blocked by the security manager.").get());
                 }
+
+                return NS_ERROR_DOM_RETVAL_UNDEFINED;
             }
         }
     }
     else {
         // No owner from channel, use the current URI to generate a principal
         rv = securityManager->GetCodebasePrincipal(mURI, 
                                                    getter_AddRefs(principal));
         if (NS_FAILED(rv) || !principal) {
@@ -295,19 +283,19 @@ nsresult nsJSThunk::EvaluateScript(nsICh
     return rv;
 }
 
 nsresult nsJSThunk::BringUpConsole(nsIDOMWindow *aDomWindow)
 {
     nsresult rv;
 
     // First, get the Window Mediator service.
-    nsCOMPtr<nsIWindowMediator> windowMediator;
+    nsCOMPtr<nsIWindowMediator> windowMediator =
+        do_GetService(kWindowMediatorCID, &rv);
 
-    windowMediator = do_GetService(kWindowMediatorCID, &rv);
     if (NS_FAILED(rv)) return rv;
 
     // Next, find out whether there's a console already open.
     nsCOMPtr<nsIDOMWindowInternal> console;
     rv = windowMediator->GetMostRecentWindow(NS_LITERAL_STRING("global:console").get(),
                                              getter_AddRefs(console));
     if (NS_FAILED(rv)) return rv;
 
Index: embedding/browser/activex/src/plugin/LegacyPlugin.cpp
===================================================================
RCS file: /cvsroot/mozilla/embedding/browser/activex/src/plugin/LegacyPlugin.cpp,v
retrieving revision 1.41
diff -p -u -d -8 -r1.41 LegacyPlugin.cpp
--- embedding/browser/activex/src/plugin/LegacyPlugin.cpp	13 Jun 2003 20:08:56 -0000	1.41
+++ embedding/browser/activex/src/plugin/LegacyPlugin.cpp	23 Jul 2003 23:09:04 -0000
@@ -399,17 +399,17 @@ MozAxAutoPushJSContext::MozAxAutoPushJSC
     if (!hasScript)
     {
         nsCOMPtr<nsIPrincipal> principal;
         mPushResult = CreatePrincipal(aURI, getter_AddRefs(principal));
 
         if (NS_SUCCEEDED(mPushResult))
         {
             JSPrincipals* jsprinc;
-            principal->GetJSPrincipals(&jsprinc);
+            principal->GetJsPrincipals(&jsprinc);
 
             mFrame.script = JS_CompileScriptForPrincipals(cx, JS_GetGlobalObject(cx),
                                                           jsprinc, "", 0, "", 1);
             JSPRINCIPALS_DROP(cx, jsprinc);
 
             if (mFrame.script)
             {
                 mFrame.down = cx->fp;
Index: extensions/webservices/schema/src/nsSchemaLoader.cpp
===================================================================
RCS file: /cvsroot/mozilla/extensions/webservices/schema/src/nsSchemaLoader.cpp,v
retrieving revision 1.19
diff -p -u -d -8 -r1.19 nsSchemaLoader.cpp
--- extensions/webservices/schema/src/nsSchemaLoader.cpp	16 Jun 2003 11:17:07 -0000	1.19
+++ extensions/webservices/schema/src/nsSchemaLoader.cpp	23 Jul 2003 23:09:12 -0000
@@ -38,17 +38,17 @@
 #include "nsNetUtil.h"
 
 // string includes
 #include "nsReadableUtils.h"
 
 // XPConnect includes
 #include "nsIXPConnect.h"
 #include "nsIScriptSecurityManager.h"
-#include "nsICodebasePrincipal.h"
+#include "nsIPrincipal.h"
 
 // XPCOM includes
 #include "nsIServiceManager.h"
 #include "nsIComponentManager.h"
 
 ////////////////////////////////////////////////////////////
 //
 // nsSchemaAtoms implementation
@@ -808,20 +808,17 @@ nsSchemaLoader::GetResolvedURI(const nsA
 
     nsCOMPtr<nsIScriptSecurityManager> secMan(do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv));
     if (NS_FAILED(rv)) return rv;
 
     nsCOMPtr<nsIURI> baseURI;
     nsCOMPtr<nsIPrincipal> principal;
     rv = secMan->GetSubjectPrincipal(getter_AddRefs(principal));
     if (NS_SUCCEEDED(rv)) {
-      nsCOMPtr<nsICodebasePrincipal> codebase = do_QueryInterface(principal);
-      if (codebase) {
-        codebase->GetURI(getter_AddRefs(baseURI));
-      }
+      principal->GetURI(getter_AddRefs(baseURI));
     }
     
     rv = NS_NewURI(aURI, aSchemaURI, nsnull, baseURI);
     if (NS_FAILED(rv)) return rv;
     
     rv = secMan->CheckLoadURIFromScript(cx, *aURI);
     if (NS_FAILED(rv))
     {
Index: extensions/webservices/security/src/nsWebScriptsAccess.cpp
===================================================================
RCS file: /cvsroot/mozilla/extensions/webservices/security/src/nsWebScriptsAccess.cpp,v
retrieving revision 1.10
diff -p -u -d -8 -r1.10 nsWebScriptsAccess.cpp
--- extensions/webservices/security/src/nsWebScriptsAccess.cpp	1 Jul 2003 19:03:46 -0000	1.10
+++ extensions/webservices/security/src/nsWebScriptsAccess.cpp	23 Jul 2003 23:09:12 -0000
@@ -38,17 +38,17 @@
 #include "nsWebScriptsAccess.h"
 #include "nsString.h"
 #include "nsAutoPtr.h"
 #include "nsIDOMDocument.h"
 #include "nsIDOMElement.h"
 #include "nsIDOMNodeList.h"
 #include "nsIDOMAttr.h"
 #include "nsIDOMNamedNodeMap.h"
-#include "nsICodebasePrincipal.h"
+#include "nsIPrincipal.h"
 #include "nsIURL.h"
 #include "nsReadableUtils.h"
 #include "nsIHttpChannel.h"
 #include "nsNetUtil.h"
 #include "nsIXPConnect.h"
 #include "jsapi.h"
 
 #include "nsISOAPCall.h"
@@ -255,23 +255,17 @@ nsWebScriptsAccess::GetCodebaseURI(nsIUR
       do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   nsCOMPtr<nsIPrincipal> principal;
   rv = mSecurityManager->GetSubjectPrincipal(getter_AddRefs(principal));
   NS_ENSURE_SUCCESS(rv, rv);
   
-  nsCOMPtr<nsICodebasePrincipal> codebase(do_QueryInterface(principal, &rv));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  rv = codebase->GetURI(aCodebase);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  return NS_OK;
+  return principal->GetURI(aCodebase);
 }
 
 nsresult 
 nsWebScriptsAccess::CreateEntry(const char* aKey,
                                 const PRBool aIsDelegated,
                                 AccessInfoEntry** aEntry)
 {
   NS_ENSURE_ARG_POINTER(aEntry);
Index: extensions/webservices/soap/src/nsHTTPSOAPTransport.cpp
===================================================================
RCS file: /cvsroot/mozilla/extensions/webservices/soap/src/nsHTTPSOAPTransport.cpp,v
retrieving revision 1.36
diff -p -u -d -8 -r1.36 nsHTTPSOAPTransport.cpp
--- extensions/webservices/soap/src/nsHTTPSOAPTransport.cpp	12 Jun 2003 20:18:25 -0000	1.36
+++ extensions/webservices/soap/src/nsHTTPSOAPTransport.cpp	23 Jul 2003 23:09:12 -0000
@@ -39,30 +39,29 @@
 #include "nsXPIDLString.h"
 #include "nsHTTPSOAPTransport.h"
 #include "nsIComponentManager.h"
 #include "nsIDOMDocument.h"
 #include "nsIDOMText.h"
 #include "nsIURI.h"
 #include "nsNetUtil.h"
 #include "nsIScriptSecurityManager.h"
-#include "nsICodebasePrincipal.h"
+#include "nsIPrincipal.h"
 #include "nsIVariant.h"
 #include "nsString.h"
 #include "nsSOAPUtils.h"
 #include "nsSOAPCall.h"
 #include "nsSOAPException.h"
 #include "nsSOAPResponse.h"
 #include "nsISOAPCallCompletion.h"
 #include "nsIDOMEventTarget.h"
 #include "nsIDOMSerializer.h"
 #include "nsIWebScriptsAccessService.h"
 #include "nsMemory.h"
 #include "nsIDocument.h"
-#include "nsIAggregatePrincipal.h"
 
 nsHTTPSOAPTransport::nsHTTPSOAPTransport()
 {
 }
 
 nsHTTPSOAPTransport::~nsHTTPSOAPTransport()
 {
 }
@@ -118,33 +117,25 @@ nsresult ChangePrincipal(nsIDOMDocument*
   rv = secMgr->CheckSameOrigin(nsnull, targetURI);
   // change the principal only if the script security 
   // manager has denied access.
   if (NS_FAILED(rv)) {
     nsCOMPtr<nsIPrincipal> subjectPrincipal;
     rv = secMgr->GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
     NS_ENSURE_SUCCESS(rv, rv);
 
-    nsCOMPtr<nsIAggregatePrincipal> subjectAgg = 
-      do_QueryInterface(subjectPrincipal, &rv);
-    NS_ENSURE_SUCCESS(rv, rv);
-       
-    nsCOMPtr<nsIPrincipal> subjectCodebase;
-    rv = subjectAgg->GetOriginalCodebase(getter_AddRefs(subjectCodebase));
+    nsCOMPtr<nsIURI> subjectURI;
+    rv = subjectPrincipal->GetURI(getter_AddRefs(subjectURI));
     NS_ENSURE_SUCCESS(rv, rv);
-       
+
     nsCOMPtr<nsIPrincipal> targetPrincipal;
     rv = targetDoc->GetPrincipal(getter_AddRefs(targetPrincipal));
     NS_ENSURE_SUCCESS(rv, rv);
 
-    nsCOMPtr<nsIAggregatePrincipal> targetAgg = 
-      do_QueryInterface(targetPrincipal, &rv);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    rv = targetAgg->SetCodebase(subjectCodebase);
+    rv = targetPrincipal->SetURI(subjectURI);
   }
   return rv;
 }
 
 /**
  * Get and check the transport URI for accessibility.  In the future,
  * this might also attempt to automatically add a mustUnderstand
  * header to messages for untrusted sources and send them anyway.
@@ -211,34 +202,30 @@ static nsresult GetTransportURI(nsISOAPC
       rc = secMan->GetSubjectPrincipal(getter_AddRefs(principal));
       if (NS_FAILED(rc)) 
         return rc;
       if (!principal) {
         return SOAP_EXCEPTION(NS_ERROR_FAILURE,
                               "SOAP_INVOKE_VERIFY_PRINCIPAL", 
                               "Source-verified message cannot be sent without principal.");
       }
-      nsCOMPtr<nsICodebasePrincipal> codebase = do_QueryInterface(principal,&rc);
-      if (NS_FAILED(rc)) 
-        return rc;
-  
-      if (!codebase) {
+
+      nsCOMPtr<nsIURI> uri;
+      principal->GetURI(getter_AddRefs(uri));
+      if (!uri) {
         return SOAP_EXCEPTION(NS_ERROR_FAILURE,
-                              "SOAP_INVOKE_VERIFY_CODEBASE", 
-                              "Source-verified message cannot be sent without codebase.");
+                              "SOAP_INVOKE_VERIFY_URI", 
+                              "Source-verified message cannot be sent without URI.");
       }
-  
-      char* str;
 
-      rc = codebase->GetSpec(&str);
+      nsCAutoString spec;
+      rc = uri->GetSpec(spec);
       if (NS_FAILED(rc)) 
         return rc;
-      CopyASCIItoUCS2(nsDependentCString(str), sourceURI);
-      nsMemory::Free(str);
-
+      CopyASCIItoUCS2(spec, sourceURI);
     }
 
 //  Adding a header to tell the server that it must understand and verify the source of the call
 
     nsCOMPtr<nsIDOMElement> element;
     rc = aCall->GetHeader(getter_AddRefs(element));
     if (NS_FAILED(rc)) 
       return rc;
Index: extensions/webservices/wsdl/src/nsWSDLLoader.cpp
===================================================================
RCS file: /cvsroot/mozilla/extensions/webservices/wsdl/src/nsWSDLLoader.cpp,v
retrieving revision 1.20
diff -p -u -d -8 -r1.20 nsWSDLLoader.cpp
--- extensions/webservices/wsdl/src/nsWSDLLoader.cpp	16 Jun 2003 11:17:08 -0000	1.20
+++ extensions/webservices/wsdl/src/nsWSDLLoader.cpp	23 Jul 2003 23:09:12 -0000
@@ -35,17 +35,17 @@
 #include "nsIDOM3Node.h"
 
 // string includes
 #include "nsReadableUtils.h"
 
 // XPConnect includes
 #include "nsIXPConnect.h"
 #include "nsIScriptSecurityManager.h"
-#include "nsICodebasePrincipal.h"
+#include "nsIPrincipal.h"
 
 // XPCOM includes
 #include "nsIServiceManager.h"
 #include "nsIComponentManager.h"
 
 // XMLExtras includes
 #include "nsISOAPMessage.h"
 
@@ -213,20 +213,17 @@ nsWSDLLoader::GetResolvedURI(const nsASt
       do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
     if (NS_FAILED(rv))
       return rv;
 
     nsCOMPtr<nsIURI> baseURI;
     nsCOMPtr<nsIPrincipal> principal;
     rv = secMan->GetSubjectPrincipal(getter_AddRefs(principal));
     if (NS_SUCCEEDED(rv)) {
-      nsCOMPtr<nsICodebasePrincipal> codebase = do_QueryInterface(principal);
-      if (codebase) {
-        codebase->GetURI(getter_AddRefs(baseURI));
-      }
+      principal->GetURI(getter_AddRefs(baseURI));
     }
 
     rv = NS_NewURI(aURI, aWSDLURI, nsnull, baseURI);
     if (NS_FAILED(rv))
       return rv;
 
     rv = secMan->CheckLoadURIFromScript(cx, *aURI);
     if (NS_FAILED(rv)) {
Index: extensions/xmlextras/base/src/nsDOMSerializer.cpp
===================================================================
RCS file: /cvsroot/mozilla/extensions/xmlextras/base/src/nsDOMSerializer.cpp,v
retrieving revision 1.22
diff -p -u -d -8 -r1.22 nsDOMSerializer.cpp
--- extensions/xmlextras/base/src/nsDOMSerializer.cpp	17 Jun 2003 16:40:33 -0000	1.22
+++ extensions/xmlextras/base/src/nsDOMSerializer.cpp	23 Jul 2003 23:09:12 -0000
@@ -45,17 +45,16 @@
 #include "nsIDocumentEncoder.h"
 #include "nsIComponentManager.h"
 #include "nsIContentSerializer.h"
 #include "nsString.h"
 #include "nsReadableUtils.h"
 
 #include "nsIJSContextStack.h"
 #include "nsIScriptSecurityManager.h"
-#include "nsICodebasePrincipal.h"
 #include "nsIURI.h"
 
 nsDOMSerializer::nsDOMSerializer()
 {
 }
 
 nsDOMSerializer::~nsDOMSerializer()
 {
@@ -151,21 +150,18 @@ nsresult CheckSameOrigin(nsIDOMNode *aRo
     nsCOMPtr<nsIDocument> doc(do_QueryInterface(owner_doc));
 
     if (doc) {
       nsCOMPtr<nsIPrincipal> principal;
       nsCOMPtr<nsIURI> root_uri;
 
       doc->GetPrincipal(getter_AddRefs(principal));
 
-      nsCOMPtr<nsICodebasePrincipal> codebase_principal =
-        do_QueryInterface(principal);
-
-      if (codebase_principal) {
-        codebase_principal->GetURI(getter_AddRefs(root_uri));
+      if (principal) {
+        principal->GetURI(getter_AddRefs(root_uri));
       }
 
       if (root_uri) {
         nsCOMPtr<nsIScriptSecurityManager> secMan = 
           do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
         NS_ENSURE_SUCCESS(rv, rv);
 
         rv = secMan->CheckSameOrigin(cx, root_uri);
Index: js/src/liveconnect/nsCLiveconnect.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/liveconnect/nsCLiveconnect.cpp,v
retrieving revision 1.29
diff -p -u -d -8 -r1.29 nsCLiveconnect.cpp
--- js/src/liveconnect/nsCLiveconnect.cpp	25 Feb 2003 05:59:50 -0000	1.29
+++ js/src/liveconnect/nsCLiveconnect.cpp	23 Jul 2003 23:09:14 -0000
@@ -205,17 +205,17 @@ AutoPushJSContext::AutoPushJSContext(nsI
                 break;
             }
             tempFP = tempFP->down;
         };
 
         if (!hasScript)
         {
             JSPrincipals* jsprinc;
-            principal->GetJSPrincipals(&jsprinc);
+            principal->GetJsPrincipals(&jsprinc);
 
             mFrame.script = JS_CompileScriptForPrincipals(cx, JS_GetGlobalObject(cx),
                                                           jsprinc, "", 0, "", 1);
             JSPRINCIPALS_DROP(cx, jsprinc);
 
             if (mFrame.script)
             {
                 mFrame.down = cx->fp;
Index: js/src/xpconnect/loader/mozJSComponentLoader.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/loader/mozJSComponentLoader.cpp,v
retrieving revision 1.90
diff -p -u -d -8 -r1.90 mozJSComponentLoader.cpp
--- js/src/xpconnect/loader/mozJSComponentLoader.cpp	23 Mar 2003 07:22:16 -0000	1.90
+++ js/src/xpconnect/loader/mozJSComponentLoader.cpp	23 Jul 2003 23:09:15 -0000
@@ -263,17 +263,17 @@ EvalInSandbox(JSContext *cx, JSObject *o
     
     nsCOMPtr<nsIPrincipal> principal;
     nsCOMPtr<nsIScriptSecurityManager> secman = 
         do_GetService(kScriptSecurityManagerContractID);
     if (!secman ||
         NS_FAILED(secman->GetCodebasePrincipal(iURL,
                                                getter_AddRefs(principal))) ||
         !principal ||
-        NS_FAILED(principal->GetJSPrincipals(&jsPrincipals)) ||
+        NS_FAILED(principal->GetJsPrincipals(&jsPrincipals)) ||
         !jsPrincipals) {
         JS_ReportError(cx, "Can't get principals for evalInSandbox");
         return JS_FALSE;
     }
     
     JSBool ok;
     JSContext *sandcx = JS_NewContext(JS_GetRuntime(cx), 8192);
     if (!sandcx) {
@@ -991,17 +991,17 @@ mozJSComponentLoader::GlobalForLocation(
     JSCLAutoContext cx(mRuntime);
     if (NS_FAILED(cx.GetError()))
         return nsnull;
 
 #ifndef XPCONNECT_STANDALONE
     nsCOMPtr<nsIScriptObjectPrincipal> backstagePass =
       new BackstagePass(mSystemPrincipal);
 
-    rv = mSystemPrincipal->GetJSPrincipals(&jsPrincipals);
+    rv = mSystemPrincipal->GetJsPrincipals(&jsPrincipals);
     if (NS_FAILED(rv) || !jsPrincipals)
         return nsnull;
 
 #else
     nsCOMPtr<nsISupports> backstagePass = new BackstagePass();
 #endif
 
     JSCLAutoErrorReporterSetter aers(cx, Reporter);
Index: js/src/xpconnect/loader/mozJSSubScriptLoader.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp,v
retrieving revision 1.13
diff -p -u -d -8 -r1.13 mozJSSubScriptLoader.cpp
--- js/src/xpconnect/loader/mozJSSubScriptLoader.cpp	23 Mar 2003 07:22:16 -0000	1.13
+++ js/src/xpconnect/loader/mozJSSubScriptLoader.cpp	23 Jul 2003 23:09:15 -0000
@@ -294,17 +294,17 @@ mozJSSubScriptLoader::LoadSubScript (con
     {
         errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_READUNDERFLOW);
         goto return_exception;
     }
 
     /* we can't hold onto jsPrincipals as a module var because the
      * JSPRINCIPALS_DROP macro takes a JSContext, which we won't have in the
      * destructor */
-    rv = mSystemPrincipal->GetJSPrincipals(&jsPrincipals);
+    rv = mSystemPrincipal->GetJsPrincipals(&jsPrincipals);
     if (NS_FAILED(rv) || !jsPrincipals) {
         delete[] buf;
         return rv;
     }
 
     /* set our own error reporter so we can report any bad things as catchable
      * exceptions, including the source/line number */
     er = JS_SetErrorReporter (cx, ExceptionalErrorReporter);
Index: layout/html/document/src/nsFrameFrame.cpp
===================================================================
RCS file: /cvsroot/mozilla/layout/html/document/src/nsFrameFrame.cpp,v
retrieving revision 3.230
diff -p -u -d -8 -r3.230 nsFrameFrame.cpp
--- layout/html/document/src/nsFrameFrame.cpp	11 Jul 2003 21:15:29 -0000	3.230
+++ layout/html/document/src/nsFrameFrame.cpp	23 Jul 2003 23:09:18 -0000
@@ -71,17 +71,16 @@
 #include "nsFrameSetFrame.h"
 #include "nsIDOMHTMLFrameElement.h"
 #include "nsIDOMHTMLIFrameElement.h"
 #include "nsIDOMXULElement.h"
 #include "nsIFrameLoader.h"
 #include "nsLayoutAtoms.h"
 #include "nsIChromeEventHandler.h"
 #include "nsIScriptSecurityManager.h"
-#include "nsICodebasePrincipal.h"
 #include "nsXPIDLString.h"
 #include "nsIScrollable.h"
 #include "nsINameSpaceManager.h"
 #include "nsIPrintContext.h"
 #include "nsIPrintPreviewContext.h"
 #include "nsIWidget.h"
 #include "nsIWebProgress.h"
 #include "nsIWebProgressListener.h"
Index: modules/libpref/src/nsPrefBranch.cpp
===================================================================
RCS file: /cvsroot/mozilla/modules/libpref/src/nsPrefBranch.cpp,v
retrieving revision 1.49
diff -p -u -d -8 -r1.49 nsPrefBranch.cpp
--- modules/libpref/src/nsPrefBranch.cpp	8 Jan 2003 22:05:48 -0000	1.49
+++ modules/libpref/src/nsPrefBranch.cpp	23 Jul 2003 23:09:27 -0000
@@ -41,17 +41,17 @@
 #include "nsILocalFile.h"
 #include "nsIObserverService.h"
 #include "nsXPCOM.h"
 #include "nsISupportsPrimitives.h"
 #include "nsIDirectoryService.h"
 #include "nsString.h"
 #include "nsReadableUtils.h"
 #include "nsXPIDLString.h"
-#include "nsScriptSecurityManager.h"
+#include "nsIScriptSecurityManager.h"
 #include "nsIStringBundle.h"
 #include "prefapi.h"
 #include "prmem.h"
 #include "pldhash.h"
 
 #include "nsIFileSpec.h"  // this should be removed eventually
 #include "prefapi_private_data.h"
 
@@ -63,18 +63,16 @@ struct EnumerateData {
 
 struct PrefCallbackData {
   nsIPrefBranch *pBranch;
   nsISupports   *pObserver;
   PRBool        bIsWeakRef;
 };
 
 
-static NS_DEFINE_CID(kSecurityManagerCID, NS_SCRIPTSECURITYMANAGER_CID);
-
 // Prototypes
 extern PrefResult pref_UnlockPref(const char *key);
 PR_STATIC_CALLBACK(PLDHashOperator)
   pref_enumChild(PLDHashTable *table, PLDHashEntryHdr *heh,
                  PRUint32 i, void *arg);
 static int PR_CALLBACK NotifyObserver(const char *newpref, void *data);
 
 // this needs to be removed!
@@ -892,17 +890,17 @@ nsresult nsPrefBranch::getValidatedPrefN
   }
 
   // now that we have the pref, check it against the ScriptSecurityManager
   if ((fullPref[0] == 'c') &&
     PL_strncmp(fullPref, capabilityPrefix, sizeof(capabilityPrefix)-1) == 0)
   {
     nsresult rv;
     nsCOMPtr<nsIScriptSecurityManager> secMan = 
-             do_GetService(kSecurityManagerCID, &rv);
+             do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
     PRBool enabled;
 
     if (NS_FAILED(rv))
       return NS_ERROR_FAILURE;
     rv = secMan->IsCapabilityEnabled("CapabilityPreferencesAccess", &enabled);
     if (NS_FAILED(rv) || !enabled)
       return NS_ERROR_FAILURE;
   }
Index: modules/oji/src/ProxyClassLoader.cpp
===================================================================
RCS file: /cvsroot/mozilla/modules/oji/src/ProxyClassLoader.cpp,v
retrieving revision 1.9
diff -p -u -d -8 -r1.9 ProxyClassLoader.cpp
--- modules/oji/src/ProxyClassLoader.cpp	24 Jun 2003 21:42:53 -0000	1.9
+++ modules/oji/src/ProxyClassLoader.cpp	23 Jul 2003 23:09:27 -0000
@@ -40,17 +40,16 @@
 
 #include "jsapi.h"
 #include "jsjava.h"
 #include "prprf.h"
 
 #include "nsIServiceManager.h"
 #include "nsIJSContextStack.h"
 #include "nsIPrincipal.h"
-#include "nsICodebasePrincipal.h"
 #include "nsIScriptContext.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIScriptObjectPrincipal.h"
 #include "nsNetUtil.h"
 #include "ProxyJNI.h"
 #include "nsCNullSecurityContext.h"
 
 /**
@@ -65,19 +64,17 @@ static nsresult getScriptCodebase(JSCont
     if (scriptContext) {
         nsCOMPtr<nsIScriptGlobalObject> scriptGlobal;
         scriptContext->GetGlobalObject(getter_AddRefs(scriptGlobal));
         nsCOMPtr<nsIScriptObjectPrincipal> scriptObjectPrincipal = do_QueryInterface(scriptGlobal);
         if (scriptObjectPrincipal) {
             nsCOMPtr<nsIPrincipal> principal;
             scriptObjectPrincipal->GetPrincipal(getter_AddRefs(principal));
             if (principal) {
-                nsCOMPtr<nsICodebasePrincipal> codebasePrincipal = do_QueryInterface(principal);
-                if (codebasePrincipal)
-                    return codebasePrincipal->GetURI(result);
+                return principal->GetURI(result);
             }
         }
     }
     return NS_ERROR_FAILURE;
 }
 
 /**
  * Obtain the netscape.oji.ProxyClassLoader instance associated with the
Index: modules/oji/src/lcglue.cpp
===================================================================
RCS file: /cvsroot/mozilla/modules/oji/src/lcglue.cpp,v
retrieving revision 1.47
diff -p -u -d -8 -r1.47 lcglue.cpp
--- modules/oji/src/lcglue.cpp	24 Jun 2003 21:42:53 -0000	1.47
+++ modules/oji/src/lcglue.cpp	23 Jul 2003 23:09:27 -0000
@@ -353,27 +353,27 @@ get_JSPrincipals_from_java_caller_impl(J
             if (NS_SUCCEEDED(rv)) {
                 nsCOMPtr<nsIURI> codebaseURI;
                 rv = NS_NewURI(getter_AddRefs(codebaseURI), nsDependentCString(codebase));
                 if (NS_SUCCEEDED(rv)) {
                     nsCOMPtr<nsIPrincipal> principal;
                     rv = ssm->GetCodebasePrincipal(codebaseURI, getter_AddRefs(principal));
                     if (NS_SUCCEEDED(rv)) {
                         JSPrincipals* jsprincipals;
-                        principal->GetJSPrincipals(&jsprincipals);
+                        principal->GetJsPrincipals(&jsprincipals);
                         return jsprincipals;
                     }
                 }
             }
         }
     } else {
         nsCOMPtr<nsIPrincipal> principal = do_QueryInterface(credentials);
         if (principal) {
             JSPrincipals* jsprincipals;
-            principal->GetJSPrincipals(&jsprincipals);
+            principal->GetJsPrincipals(&jsprincipals);
             return jsprincipals;
         }
     }
     return NULL;
 }
 
 JS_STATIC_DLL_CALLBACK(jobject)
 get_java_wrapper_impl(JNIEnv *pJNIEnv, jint a_jsobject)
Index: modules/oji/src/nsCSecurityContext.cpp
===================================================================
RCS file: /cvsroot/mozilla/modules/oji/src/nsCSecurityContext.cpp,v
retrieving revision 1.26
diff -p -u -d -8 -r1.26 nsCSecurityContext.cpp
--- modules/oji/src/nsCSecurityContext.cpp	24 Jun 2003 21:42:53 -0000	1.26
+++ modules/oji/src/nsCSecurityContext.cpp	23 Jul 2003 23:09:27 -0000
@@ -49,24 +49,21 @@
 #include "jsdbgapi.h"
 #include "nsCSecurityContext.h"
 #include "nsIScriptContext.h"
 #include "jvmmgr.h"
 
 // For GetOrigin()
 
 #include "nsCOMPtr.h"
-#include "nsJSPrincipals.h"
-#include "nsSystemPrincipal.h"
-#include "nsCodebasePrincipal.h"
-#include "nsCertificatePrincipal.h"
-#include "nsScriptSecurityManager.h"
+#include "nsIScriptSecurityManager.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIServiceManager.h"
 #include "nsIScriptObjectPrincipal.h"
+#include "nsIPrincipal.h"
 #include "nsCRT.h"
 
 #include "nsTraceRefcnt.h"
 
 static NS_DEFINE_IID(kISecurityContextIID, NS_ISECURITYCONTEXT_IID);
 static NS_DEFINE_IID(kISupportsIID, NS_ISUPPORTS_IID);
 
 
@@ -157,78 +154,57 @@ nsCSecurityContext::GetOrigin(char* buf,
                             return NS_ERROR_FAILURE; 
                        
                    }
                 }
             }
         }
     }
 
-    nsCOMPtr<nsICodebasePrincipal> codebase = do_QueryInterface(m_pPrincipal);
-    if (!codebase) 
-        return NS_ERROR_FAILURE;
-
-    char* origin=nsnull;
-    codebase->GetOrigin(&origin);
+    nsXPIDLCString origin;
+    m_pPrincipal->GetOrigin(getter_Copies(origin));
 
-    if (origin) {
-        PRInt32 originlen = (PRInt32) strlen(origin);
-        if (!buf || buflen<=originlen) {
-            if (origin) {
-                nsCRT::free(origin);
-            }
-            return NS_ERROR_FAILURE;
-        }
+    if (origin.IsEmpty()) {
+        return NS_ERROR_FAILURE;
+    }
 
-        // Copy the string into to user supplied buffer. Is there a better
-        // way to do this?
+    // Copy the string into to user supplied buffer. Is there a better
+    // way to do this?
 
-        memcpy(buf,origin,originlen);
-        buf[originlen]=nsnull; // Gotta terminate it.
-        nsCRT::free(origin);
-    } else {
-        *buf = nsnull;
-    }
+    PRInt32 originlen = origin.Length();
+    memcpy(buf, origin, originlen);
+    buf[originlen] = nsnull; // Gotta terminate it.
 
     return NS_OK;
 }
 
 NS_METHOD 
 nsCSecurityContext::GetCertificateID(char* buf, int buflen)
 {
-    nsCOMPtr<nsIPrincipal> principal = NULL;
+    nsCOMPtr<nsIPrincipal> principal;
   
     // Get the Script Security Manager.
 
     nsresult rv      = NS_OK;
     nsCOMPtr<nsIScriptSecurityManager> secMan = 
              do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
     if (NS_FAILED(rv) || !secMan) return NS_ERROR_FAILURE;
 
-
     secMan->GetSubjectPrincipal(getter_AddRefs(principal));
-    nsCOMPtr<nsICertificatePrincipal> cprincipal = do_QueryInterface(principal);
-    if (!cprincipal) 
-        return NS_ERROR_FAILURE;
 
-    char* certificate = nsnull;
-    cprincipal->GetCertificateID(&certificate);
+    nsXPIDLCString certificate;
+    principal->GetCertificateID(getter_Copies(certificate));
 
-    if (certificate) {
-        PRInt32 certlen = (PRInt32) strlen(certificate);
-        if( buflen<=certlen ) {
-            nsCRT::free(certificate);
-            return NS_ERROR_FAILURE;
-        }
-        memcpy(buf,certificate,certlen);
-        buf[certlen]=nsnull;
-        nsCRT::free(certificate);
-    } else {
-        *buf = nsnull;
+    PRInt32 certlen = certificate.Length();
+    if (buflen <= certlen) {
+        return NS_ERROR_FAILURE;
     }
+
+    memcpy(buf, certificate.get(), certlen);
+    buf[certlen] = nsnull;
 
     return NS_OK;
 }
 
 ////////////////////////////////////////////////////////////////////////////
 // from nsCSecurityContext:
 extern PRUintn tlsIndex3_g;
 
Index: modules/oji/src/nsJVMManager.cpp
===================================================================
RCS file: /cvsroot/mozilla/modules/oji/src/nsJVMManager.cpp,v
retrieving revision 1.59
diff -p -u -d -8 -r1.59 nsJVMManager.cpp
--- modules/oji/src/nsJVMManager.cpp	20 Jul 2003 07:47:10 -0000	1.59
+++ modules/oji/src/nsJVMManager.cpp	23 Jul 2003 23:09:27 -0000
@@ -63,24 +63,20 @@
 #include "nsIStringBundle.h"
 
 #include "nsIPref.h"
 #include "lcglue.h"
 
 #include "nspr.h"
 #include "plstr.h"
 #include "nsCOMPtr.h"
-//#include "nsJSPrincipals.h"
-//#include "nsSystemPrincipal.h"
-//#include "nsCodebasePrincipal.h"
-#include "nsCertificatePrincipal.h"
+#include "nsIPrincipal.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsISignatureVerifier.h"
 
-//#include "nsScriptSecurityManager.h"
 
 extern "C" int XP_PROGRESS_STARTING_JAVA;
 extern "C" int XP_PROGRESS_STARTING_JAVA_DONE;
 extern "C" int XP_JAVA_NO_CLASSES;
 extern "C" int XP_JAVA_GENERAL_FAILURE;
 extern "C" int XP_JAVA_STARTUP_FAILED;
 extern "C" int XP_JAVA_DEBUGGER_FAILED;
 
@@ -966,25 +962,18 @@ nsJVMManager::IsAllPermissionGranted(
 
     // Ask the Script Security Manager to make a Certificate Principal.
     // The fingerprint is a one way hash of this certificate. It is used
     // as the key to store the principal in the principal database.
 
     rv = secMan->GetCertificatePrincipal(lastFP, &pIPrincipal);
     if (NS_FAILED(rv)) return PR_FALSE;
 
-    // Get the nsICertificatePrincipal interface so that we can set the
-    // common name. The common name is a user meaningful string.
-    
-    nsCOMPtr<nsICertificatePrincipal> pICertificate = do_QueryInterface(pIPrincipal, &rv);
-    if (NS_FAILED(rv) || !pICertificate) return PR_FALSE;
-
     // Set the common name.
-
-    rv = pICertificate->SetCommonName(lastCN);
+    rv = pIPrincipal->SetCommonName(lastCN);
 
     PRInt16 ret;
 
     secMan->RequestCapability(pIPrincipal,"AllPermission",&ret);
 
     PR_ASSERT(isGranted);
     *isGranted = (ret!=0);
 
Index: netwerk/protocol/jar/src/nsJARChannel.cpp
===================================================================
RCS file: /cvsroot/mozilla/netwerk/protocol/jar/src/nsJARChannel.cpp,v
retrieving revision 1.101
diff -p -u -d -8 -r1.101 nsJARChannel.cpp
--- netwerk/protocol/jar/src/nsJARChannel.cpp	20 Jul 2003 07:47:20 -0000	1.101
+++ netwerk/protocol/jar/src/nsJARChannel.cpp	23 Jul 2003 23:09:29 -0000
@@ -17,22 +17,21 @@
  *
  */
 
 #include "nsJARChannel.h"
 #include "nsJARProtocolHandler.h"
 #include "nsMimeTypes.h"
 #include "nsNetUtil.h"
 
-#include "nsScriptSecurityManager.h"
-#include "nsIAggregatePrincipal.h"
+#include "nsIScriptSecurityManager.h"
+#include "nsIPrincipal.h"
 #include "nsIFileURL.h"
 #include "nsIJAR.h"
 
-static NS_DEFINE_CID(kScriptSecurityManagerCID, NS_SCRIPTSECURITYMANAGER_CID);
 static NS_DEFINE_CID(kZipReaderCID, NS_ZIPREADER_CID);
 
 //-----------------------------------------------------------------------------
 
 #if defined(PR_LOGGING)
 //
 // set NSPR_LOG_MODULES=nsJarProtocol:5
 //
@@ -419,32 +418,38 @@ nsJARChannel::GetOwner(nsISupports **res
 
     nsCOMPtr<nsIPrincipal> cert;
     rv = jar->GetCertificatePrincipal(mJarEntry.get(), getter_AddRefs(cert));
     if (NS_FAILED(rv)) return rv;
 
     if (cert) {
         // Get the codebase principal
         nsCOMPtr<nsIScriptSecurityManager> secMan = 
-                 do_GetService(kScriptSecurityManagerCID, &rv);
+                 do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
         if (NS_FAILED(rv)) return rv;
 
         nsCOMPtr<nsIPrincipal> codebase;
         rv = secMan->GetCodebasePrincipal(mJarBaseURI, 
                                           getter_AddRefs(codebase));
         if (NS_FAILED(rv)) return rv;
-    
+
+        nsCOMPtr<nsIURI> codebaseURI;
+        codebase->GetURI(getter_AddRefs(codebaseURI));
+
+        nsCOMPtr<nsIURI> domainURI;
+        codebase->GetDomain(getter_AddRefs(domainURI));
+        
         // Join the certificate and the codebase
-        nsCOMPtr<nsIAggregatePrincipal> agg = do_QueryInterface(cert, &rv);
+        rv = cert->SetURI(codebaseURI);
         if (NS_FAILED(rv)) return rv;
 
-        rv = agg->SetCodebase(codebase);
+        rv = cert->SetDomain(domainURI);
         if (NS_FAILED(rv)) return rv;
 
-        mOwner = do_QueryInterface(agg, &rv);
+        mOwner = do_QueryInterface(cert, &rv);
         if (NS_FAILED(rv)) return rv;
 
         NS_ADDREF(*result = mOwner);
     }
     return NS_OK;
 }
 
 NS_IMETHODIMP
Index: security/manager/ssl/src/nsCrypto.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsCrypto.cpp,v
retrieving revision 1.36
diff -p -u -d -8 -r1.36 nsCrypto.cpp
--- security/manager/ssl/src/nsCrypto.cpp	24 Jun 2003 21:42:56 -0000	1.36
+++ security/manager/ssl/src/nsCrypto.cpp	23 Jul 2003 23:09:33 -0000
@@ -42,22 +42,22 @@
 #include "nsIXPConnect.h"
 #include "nsIEventQueueService.h"
 #include "nsIEventQueue.h"
 #include "nsIRunnable.h"
 #include "nsIWindowWatcher.h"
 #include "nsIPrompt.h"
 #include "nsIFilePicker.h"
 #include "nsJSPrincipals.h"
-#include "nsScriptSecurityManager.h"
 #include "nsIPrincipal.h"
 #include "nsXPIDLString.h"
 #include "nsIGenKeypairInfoDlg.h"
 #include "nsIDOMCryptoDialogs.h"
 #include "jsapi.h"
+#include "jsdbgapi.h"
 #include <ctype.h>
 #include "nsReadableUtils.h"
 #include "pk11func.h"
 #include "keyhi.h"
 #include "cryptohi.h"
 #include "seccomon.h"
 extern "C" {
 #include "crmf.h"
@@ -1783,17 +1783,17 @@ nsCryptoRunnable::~nsCryptoRunnable()
 //Implementation that runs the callback passed to 
 //crypto.generateCRMFRequest as an event.
 NS_IMETHODIMP
 nsCryptoRunnable::Run()
 {
   nsNSSShutDownPreventionLock locker;
   JSPrincipals *principals;
 
-  nsresult rv = m_args->m_principals->GetJSPrincipals(&principals);
+  nsresult rv = m_args->m_principals->GetJsPrincipals(&principals);
   if (NS_FAILED(rv))
     return NS_ERROR_FAILURE;
 
   jsval retval;
   if (JS_EvaluateScriptForPrincipals(m_args->m_cx, m_args->m_scope, principals,
                                      m_args->m_jsCallback, 
                                      strlen(m_args->m_jsCallback),
                                      nsnull, 0,
Index: security/manager/ssl/src/nsCrypto.h
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsCrypto.h,v
retrieving revision 1.5
diff -p -u -d -8 -r1.5 nsCrypto.h
--- security/manager/ssl/src/nsCrypto.h	2 Oct 2002 10:51:02 -0000	1.5
+++ security/manager/ssl/src/nsCrypto.h	23 Jul 2003 23:09:33 -0000
@@ -23,31 +23,31 @@
 #ifndef _nsCrypto_h_
 #define _nsCrypto_h_
 #include "nsCOMPtr.h"
 #include "nsIDOMCRMFObject.h"
 #include "nsIDOMCrypto.h"
 #include "nsIDOMPkcs11.h"
 #include "nsString.h"
 #include "jsapi.h"
-#include "nsIPrincipal.h"
 
 #define NS_CRYPTO_CLASSNAME "Crypto JavaScript Class"
 #define NS_CRYPTO_CID \
   {0x929d9320, 0x251e, 0x11d4, { 0x8a, 0x7c, 0x00, 0x60, 0x08, 0xc8, 0x44, 0xc3} }
 
 #define NS_PKCS11_CLASSNAME "Pkcs11 JavaScript Class"
 #define NS_PKCS11_CID \
   {0x74b7a390, 0x3b41, 0x11d4, { 0x8a, 0x80, 0x00, 0x60, 0x08, 0xc8, 0x44, 0xc3} }
 
 #define PSM_VERSION_STRING "2.4"
 
 class nsIPSMComponent;
 class nsIDOMScriptObjectFactory;
 class nsIEventQueue;
+class nsIPrincipal;
 
 
 class nsCRMFObject : public nsIDOMCRMFObject
 {
 public:
   nsCRMFObject();
   virtual ~nsCRMFObject();
 
Index: security/manager/ssl/src/nsNSSComponent.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSComponent.cpp,v
retrieving revision 1.107
diff -p -u -d -8 -r1.107 nsNSSComponent.cpp
--- security/manager/ssl/src/nsNSSComponent.cpp	20 Jul 2003 07:47:35 -0000	1.107
+++ security/manager/ssl/src/nsNSSComponent.cpp	23 Jul 2003 23:09:33 -0000
@@ -53,17 +53,16 @@
 #include "nsIRunnable.h"
 #include "plevent.h"
 #include "nsCRT.h"
 #include "nsCRLInfo.h"
 
 #include "nsIWindowWatcher.h"
 #include "nsIPrompt.h"
 #include "nsProxiedService.h"
-#include "nsICertificatePrincipal.h"
 #include "nsReadableUtils.h"
 #include "nsIDateTimeFormat.h"
 #include "prtypes.h"
 #include "nsInt64.h"
 #include "nsTime.h"
 #include "nsIEntropyCollector.h"
 #include "nsIBufEntropyCollector.h"
 #include "nsIServiceManager.h"
@@ -1456,23 +1455,21 @@ nsNSSComponent::VerifySignature(const ch
     //-- Create a certificate principal with id and organization data
     nsAutoString fingerprint;
     rv2 = pCert->GetSha1Fingerprint(fingerprint);
     NS_LossyConvertUCS2toASCII fingerprintStr(fingerprint);
     if (NS_FAILED(rv2)) return rv2;
     rv2 = mScriptSecurityManager->GetCertificatePrincipal(fingerprintStr.get(), aPrincipal);
     if (NS_FAILED(rv2) || !*aPrincipal) return rv2;
 
-    nsCOMPtr<nsICertificatePrincipal> certPrincipal = do_QueryInterface(*aPrincipal, &rv2);
-    if (NS_FAILED(rv2)) return rv2;
     nsAutoString orgName;
     rv2 = pCert->GetOrganization(orgName);
     if (NS_FAILED(rv2)) return rv2;
     NS_LossyConvertUCS2toASCII  orgNameStr(orgName);
-    rv2 = certPrincipal->SetCommonName(orgNameStr.get());
+    rv2 = (*aPrincipal)->SetCommonName(orgNameStr.get());
     if (NS_FAILED(rv2)) return rv2;
   }
 
   if (p7_info) {
     SEC_PKCS7DestroyContentInfo(p7_info);
   }
 
   return NS_OK;
Index: xpinstall/src/CertReader.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpinstall/src/CertReader.cpp,v
retrieving revision 1.6
diff -p -u -d -8 -r1.6 CertReader.cpp
--- xpinstall/src/CertReader.cpp	19 Jan 2003 20:01:23 -0000	1.6
+++ xpinstall/src/CertReader.cpp	23 Jul 2003 23:09:47 -0000
@@ -37,16 +37,20 @@
 #include "zipstruct.h"
 
 #include "CertReader.h"
 
 #include "nsCRT.h"
 #include "nsIServiceManager.h"
 #include "nsISignatureVerifier.h"
 #include "nsIInputStream.h"
+#include "nsIPrincipal.h"
+#include "nsIURI.h"
+#include "nsPICertNotification.h"
+
 
 #include "nsNetUtil.h"
 
 // just a guess at the max size of the cert.
 #define MAX_SIGNATURE_SIZE (32*1024) 
 
 
 /*
Index: xpinstall/src/CertReader.h
===================================================================
RCS file: /cvsroot/mozilla/xpinstall/src/CertReader.h,v
retrieving revision 1.1
diff -p -u -d -8 -r1.1 CertReader.h
--- xpinstall/src/CertReader.h	17 Dec 2002 00:59:34 -0000	1.1
+++ xpinstall/src/CertReader.h	23 Jul 2003 23:09:47 -0000
@@ -31,21 +31,22 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsCOMPtr.h"
 #include "nsIStreamListener.h"
 #include "nsString.h"
-#include "nsISignatureVerifier.h"
-#include "nsICertificatePrincipal.h"
-#include "nsIPrincipal.h"
-#include "nsIURI.h"
-#include "nsPICertNotification.h"
+
+class nsISignatureVerifier;
+class nsIPrincipal;
+class nsIURI;
+class nsPICertNotification;
+
 
 class CertReader : public nsIStreamListener
 {
 public:
   CertReader(nsIURI* uri, nsISupports* aContext, nsPICertNotification* aObs);
   virtual ~CertReader();
 
   NS_DECL_ISUPPORTS
Index: xpinstall/src/nsSoftwareUpdateRun.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpinstall/src/nsSoftwareUpdateRun.cpp,v
retrieving revision 1.80
diff -p -u -d -8 -r1.80 nsSoftwareUpdateRun.cpp
--- xpinstall/src/nsSoftwareUpdateRun.cpp	30 Apr 2003 06:49:00 -0000	1.80
+++ xpinstall/src/nsSoftwareUpdateRun.cpp	23 Jul 2003 23:09:47 -0000
@@ -50,17 +50,16 @@
 #include "nsILocalFile.h"
 #include "nsIChromeRegistry.h"
 #include "nsInstallTrigger.h"
 #include "nsIConsoleService.h"
 #include "nsIScriptError.h"
 
 #include "nsIJAR.h"
 #include "nsIPrincipal.h"
-#include "nsICertificatePrincipal.h"
 
 static NS_DEFINE_CID(kSoftwareUpdateCID,  NS_SoftwareUpdate_CID);
 static NS_DEFINE_CID(kEventQueueServiceCID, NS_EVENTQUEUESERVICE_CID);
 
 extern JSObject *InitXPInstallObjects(JSContext *jscontext, JSObject *global, 
                                       nsIFile* jarfile, const PRUnichar* url, 
                                       const PRUnichar* args, PRUint32 flags, 
                                       nsIXULChromeRegistry* registry, 
@@ -77,18 +76,19 @@ static nsresult SetupInstallContext(nsIZ
 extern "C" void RunInstallOnThread(void *data);
 
 
 nsresult VerifySigning(nsIZipReader* hZip, nsIPrincipal* aPrincipal)
 {
     if (!aPrincipal) 
         return NS_OK; // not signed, but not an error
 
-    nsCOMPtr<nsICertificatePrincipal> cp(do_QueryInterface(aPrincipal));
-    if (!cp) 
+    PRBool hasCert;
+    aPrincipal->GetHasCertificate(&hasCert);
+    if (!hasCert)
         return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIJAR> jar(do_QueryInterface(hZip));
     if (!jar)
         return NS_ERROR_FAILURE;
 
     // See if the archive is signed at all first
     nsCOMPtr<nsIPrincipal> principal;
Index: xpinstall/src/nsXPITriggerInfo.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpinstall/src/nsXPITriggerInfo.cpp,v
retrieving revision 1.18
diff -p -u -d -8 -r1.18 nsXPITriggerInfo.cpp
--- xpinstall/src/nsXPITriggerInfo.cpp	17 Dec 2002 00:59:37 -0000	1.18
+++ xpinstall/src/nsXPITriggerInfo.cpp	23 Jul 2003 23:09:47 -0000
@@ -1,9 +1,9 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
  * The contents of this file are subject to the Netscape Public
  * License Version 1.1 (the "License"); you may not use this file
  * except in compliance with the License. You may obtain a copy of
  * the License at http://www.mozilla.org/NPL/
  *
  * Software distributed under the License is distributed on an "AS
  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@@ -22,17 +22,16 @@
  *     Daniel Veditz <dveditz@netscape.com>
  */
 
 #include "nscore.h"
 #include "nsXPITriggerInfo.h"
 #include "nsDebug.h"
 #include "nsIServiceManager.h"
 #include "nsIEventQueueService.h"
-#include "nsICertificatePrincipal.h"
 
 static NS_DEFINE_IID(kEventQueueServiceCID, NS_EVENTQUEUESERVICE_CID);
 
 
 //
 // nsXPITriggerItem
 //
 MOZ_DECL_CTOR_COUNTER(nsXPITriggerItem)
@@ -88,25 +87,27 @@ PRBool nsXPITriggerItem::IsRelativeURL()
     PRInt32 spos = mURL.FindChar('/');
     return (cpos > spos);
 }
 
 
 void
 nsXPITriggerItem::SetPrincipal(nsIPrincipal* aPrincipal)
 {
-	mPrincipal = aPrincipal;
+    mPrincipal = aPrincipal;
 
-	nsCOMPtr<nsICertificatePrincipal> cp(do_QueryInterface(aPrincipal));
-	if (cp) {
-		nsXPIDLCString cName;
-		cp->GetCommonName(getter_Copies(cName));
-		mCertName = NS_ConvertUTF8toUCS2(cName);
-	}
+    PRBool hasCert;
+    aPrincipal->GetHasCertificate(&hasCert);
+    if (hasCert) {
+        nsXPIDLCString cName;
+        aPrincipal->GetCommonName(getter_Copies(cName));
+        mCertName = NS_ConvertUTF8toUCS2(cName);
+    }
 }
+
 //
 // nsXPITriggerInfo
 //
 
 MOZ_DECL_CTOR_COUNTER(nsXPITriggerInfo)
 
 nsXPITriggerInfo::nsXPITriggerInfo()
   : mCx(0), mCbval(JSVAL_NULL)
