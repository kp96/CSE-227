# HG changeset patch
# User Blake Kaplan <mrbkap@gmail.com>
# Date 1305804714 -7200
# Node ID acbb220964582384227cefec1b4cf936e768dc78
# Parent  e67746e7febde6b4f0e404e81b4dc2dea371a0d5
try: -b do -p linux,win32 -u all

diff --git a/caps/idl/nsIPrincipal.idl b/caps/idl/nsIPrincipal.idl
--- a/caps/idl/nsIPrincipal.idl
+++ b/caps/idl/nsIPrincipal.idl
@@ -47,17 +47,17 @@ struct JSPrincipals;
 %}
 
 interface nsIURI;
 interface nsIContentSecurityPolicy;
 
 [ptr] native JSContext(JSContext);
 [ptr] native JSPrincipals(JSPrincipals);
 
-[scriptable, uuid(799ab95c-0038-4e0f-b705-74c21f185bb5)]
+[scriptable, uuid(B406A2DB-E547-4C95-B8E2-AD09ECB54CE0)]
 interface nsIPrincipal : nsISerializable
 {
     /**
      * Values of capabilities for each principal. Order is
      * significant: if an operation is performed on a set
      * of capabilities, the minimum is computed.
      */
     const short ENABLE_DENIED                = 1;
@@ -82,16 +82,21 @@ interface nsIPrincipal : nsISerializable
     /**
      * Returns whether the other principal is equivalent to this principal.
      * Principals are considered equal if they are the same principal,
      * they have the same origin, or have the same certificate fingerprint ID
      */
     boolean equals(in nsIPrincipal other);
 
     /**
+     * Like equals, but doesn't take document.domain changes into account.
+     */
+    boolean equalsWithoutDomain(in nsIPrincipal other);
+
+    /**
      * Returns a hash value for the principal.
      */
     [noscript] readonly attribute unsigned long hashValue;
 
     /**
      * Returns the JS equivalent of the principal.
      * @see JSPrincipals.h
      */
diff --git a/caps/include/nsPrincipal.h b/caps/include/nsPrincipal.h
--- a/caps/include/nsPrincipal.h
+++ b/caps/include/nsPrincipal.h
@@ -126,16 +126,19 @@ protected:
     nsCOMPtr<nsISupports> cert;
   };
 
   nsresult SetCertificate(const nsACString& aFingerprint,
                           const nsACString& aSubjectName,
                           const nsACString& aPrettyName,
                           nsISupports* aCert);
 
+  // Checks whether this principal's certificate equals aOther's.
+  PRBool CertificateEquals(nsIPrincipal *aOther);
+
   // Keep this is a pointer, even though it may slightly increase the
   // cost of keeping a certificate, this is a good tradeoff though since
   // it is very rare that we actually have a certificate.
   nsAutoPtr<Certificate> mCert;
 
   DomainPolicy* mSecurityPolicy;
 
   nsCOMPtr<nsIContentSecurityPolicy> mCSP;
diff --git a/caps/src/nsNullPrincipal.cpp b/caps/src/nsNullPrincipal.cpp
--- a/caps/src/nsNullPrincipal.cpp
+++ b/caps/src/nsNullPrincipal.cpp
@@ -158,16 +158,22 @@ nsNullPrincipal::Equals(nsIPrincipal *aO
 {
   // Just equal to ourselves.  Note that nsPrincipal::Equals will return false
   // for us since we have a unique domain/origin/etc.
   *aResult = (aOther == this);
   return NS_OK;
 }
 
 NS_IMETHODIMP
+nsNullPrincipal::EqualsWithoutDomain(nsIPrincipal *aOther, PRBool *aResult)
+{
+  return Equals(aOther, aResult);
+}
+
+NS_IMETHODIMP
 nsNullPrincipal::GetHashValue(PRUint32 *aResult)
 {
   *aResult = (NS_PTR_TO_INT32(this) >> 2);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsNullPrincipal::GetJSPrincipals(JSContext *cx, JSPrincipals **aJsprin)
diff --git a/caps/src/nsPrincipal.cpp b/caps/src/nsPrincipal.cpp
--- a/caps/src/nsPrincipal.cpp
+++ b/caps/src/nsPrincipal.cpp
@@ -304,63 +304,74 @@ nsPrincipal::SetSecurityPolicy(void* aSe
  
   if (mSecurityPolicy)
     mSecurityPolicy->Drop();
   
   mSecurityPolicy = newPolicy;
   return NS_OK;
 }
 
+PRBool
+nsPrincipal::CertificateEquals(nsIPrincipal *aOther)
+{
+  PRBool otherHasCert;
+  aOther->GetHasCertificate(&otherHasCert);
+  if (otherHasCert != (mCert != nsnull)) {
+    // One has a cert while the other doesn't.  Not equal.
+    return PR_FALSE;
+  }
+
+  if (!mCert)
+    return PR_TRUE;
+
+  nsCAutoString str;
+  aOther->GetFingerprint(str);
+  if (!str.Equals(mCert->fingerprint))
+    return PR_FALSE;
+
+  // If either subject name is empty, just let the result stand (so that
+  // nsScriptSecurityManager::SetCanEnableCapability works), but if they're
+  // both non-empty, only claim equality if they're equal.
+  if (!mCert->subjectName.IsEmpty()) {
+    // Check the other principal's subject name
+    aOther->GetSubjectName(str);
+    return str.Equals(mCert->subjectName) || str.IsEmpty();
+  }
+
+  return PR_TRUE;
+}
+
 NS_IMETHODIMP
 nsPrincipal::Equals(nsIPrincipal *aOther, PRBool *aResult)
 {
-  *aResult = PR_FALSE;
-
   if (!aOther) {
     NS_WARNING("Need a principal to compare this to!");
+    *aResult = PR_FALSE;
     return NS_OK;
   }
 
   if (this != aOther) {
-    PRBool otherHasCert;
-    aOther->GetHasCertificate(&otherHasCert);
-    if (otherHasCert != (mCert != nsnull)) {
-      // One has a cert while the other doesn't.  Not equal.
+    if (!CertificateEquals(aOther)) {
+      *aResult = PR_FALSE;
       return NS_OK;
     }
 
     if (mCert) {
-      nsCAutoString str;
-      aOther->GetFingerprint(str);
-      *aResult = str.Equals(mCert->fingerprint);
-
-      // If either subject name is empty, just let the result stand (so that
-      // nsScriptSecurityManager::SetCanEnableCapability works), but if they're
-      // both non-empty, only claim equality if they're equal.
-      if (*aResult && !mCert->subjectName.IsEmpty()) {
-        // Check the other principal's subject name
-        aOther->GetSubjectName(str);
-        *aResult = str.Equals(mCert->subjectName) || str.IsEmpty();
-      }
-
-      if (!*aResult) {
-        return NS_OK;
-      }
-
       // If either principal has no URI, it's the saved principal from
       // preferences; in that case, test true.  Do NOT test true if the two
       // principals have URIs with different codebases.
       nsCOMPtr<nsIURI> otherURI;
       nsresult rv = aOther->GetURI(getter_AddRefs(otherURI));
       if (NS_FAILED(rv)) {
         *aResult = PR_FALSE;
         return rv;
       }
 
       if (!otherURI || !mCodebase) {
+        *aResult = PR_TRUE;
         return NS_OK;
       }
 
       // Fall through to the codebase comparison.
     }
 
     // Codebases are equal if they have the same origin.
     *aResult =
@@ -369,16 +380,44 @@ nsPrincipal::Equals(nsIPrincipal *aOther
     return NS_OK;
   }
 
   *aResult = PR_TRUE;
   return NS_OK;
 }
 
 NS_IMETHODIMP
+nsPrincipal::EqualsWithoutDomain(nsIPrincipal *aOther, PRBool *aResult)
+{
+  if (this == aOther) {
+    *aResult = PR_TRUE;
+    return NS_OK;
+  }
+
+  *aResult = PR_FALSE;
+  if (!CertificateEquals(aOther)) {
+    return NS_OK;
+  }
+
+  nsCOMPtr<nsIURI> otherURI;
+  nsresult rv = aOther->GetURI(getter_AddRefs(otherURI));
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  NS_ASSERTION(otherURI && mCodebase,
+               "shouldn't be calling this on principals from preferences");
+
+  // Compare codebases.
+  *aResult = nsScriptSecurityManager::SecurityCompareURIs(mCodebase,
+                                                          otherURI);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsPrincipal::Subsumes(nsIPrincipal *aOther, PRBool *aResult)
 {
   return Equals(aOther, aResult);
 }
 
 static PRBool
 URIIsLocalFile(nsIURI *aURI)
 {
diff --git a/caps/src/nsSystemPrincipal.cpp b/caps/src/nsSystemPrincipal.cpp
--- a/caps/src/nsSystemPrincipal.cpp
+++ b/caps/src/nsSystemPrincipal.cpp
@@ -106,16 +106,22 @@ nsSystemPrincipal::GetPreferences(char**
 NS_IMETHODIMP
 nsSystemPrincipal::Equals(nsIPrincipal *other, PRBool *result)
 {
     *result = (other == this);
     return NS_OK;
 }
 
 NS_IMETHODIMP
+nsSystemPrincipal::EqualsWithoutDomain(nsIPrincipal *other, PRBool *result)
+{
+    return Equals(other, result);
+}
+
+NS_IMETHODIMP
 nsSystemPrincipal::Subsumes(nsIPrincipal *other, PRBool *result)
 {
     *result = PR_TRUE;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSystemPrincipal::CheckMayLoad(nsIURI* uri, PRBool aReport)
diff --git a/js/src/xpconnect/src/nsXPConnect.cpp b/js/src/xpconnect/src/nsXPConnect.cpp
--- a/js/src/xpconnect/src/nsXPConnect.cpp
+++ b/js/src/xpconnect/src/nsXPConnect.cpp
@@ -1034,27 +1034,22 @@ nsresult
 xpc_CreateGlobalObject(JSContext *cx, JSClass *clasp,
                        nsIPrincipal *principal, nsISupports *ptr,
                        bool wantXrays, JSObject **global,
                        JSCompartment **compartment)
 {
     NS_ABORT_IF_FALSE(NS_IsMainThread(), "using a principal off the main thread?");
     NS_ABORT_IF_FALSE(principal, "bad key");
 
-    nsCOMPtr<nsIURI> uri;
-    nsresult rv = principal->GetURI(getter_AddRefs(uri));
-    if(NS_FAILED(rv))
-        return UnexpectedFailure(rv);
-
     XPCCompartmentMap& map = nsXPConnect::GetRuntimeInstance()->GetCompartmentMap();
-    xpc::PtrAndPrincipalHashKey key(ptr, uri);
+    xpc::PtrAndPrincipalHashKey key(ptr, principal);
     if(!map.Get(&key, compartment))
     {
         xpc::PtrAndPrincipalHashKey *priv_key =
-            new xpc::PtrAndPrincipalHashKey(ptr, uri);
+            new xpc::PtrAndPrincipalHashKey(ptr, principal);
         xpc::CompartmentPrivate *priv =
             new xpc::CompartmentPrivate(priv_key, wantXrays, NS_IsMainThread());
         if(!CreateNewCompartment(cx, clasp, principal, priv,
                                  global, compartment))
         {
             return UnexpectedFailure(NS_ERROR_FAILURE);
         }
 
diff --git a/js/src/xpconnect/src/xpcinlines.h b/js/src/xpconnect/src/xpcinlines.h
--- a/js/src/xpconnect/src/xpcinlines.h
+++ b/js/src/xpconnect/src/xpcinlines.h
@@ -1,9 +1,10 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=4 sw=4 et tw=79:
  *
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
@@ -42,24 +43,29 @@
 
 #ifndef xpcinlines_h___
 #define xpcinlines_h___
 
 /***************************************************************************/
 PRBool
 xpc::PtrAndPrincipalHashKey::KeyEquals(const PtrAndPrincipalHashKey* aKey) const
 {
-  if(aKey->mPtr != mPtr)
-    return PR_FALSE;
+    if(aKey->mPtr != mPtr)
+        return PR_FALSE;
+    if(aKey->mPrincipal == mPrincipal)
+        return PR_TRUE;
 
-  if(!mURI || !aKey->mURI)
-      return mURI == aKey->mURI;
+    PRBool equals;
+    if(NS_FAILED(mPrincipal->EqualsWithoutDomain(aKey->mPrincipal, &equals)))
+    {
+        NS_ERROR("we failed, guessing!");
+        return PR_FALSE;
+    }
 
-  nsIScriptSecurityManager *ssm = nsXPConnect::gScriptSecurityManager;
-  return !ssm || NS_SUCCEEDED(ssm->CheckSameOriginURI(mURI, aKey->mURI, PR_FALSE));
+    return equals;
 }
 
 inline void
 XPCJSRuntime::AddVariantRoot(XPCTraceableVariant* variant)
 {
     variant->AddToRootSet(GetMapLock(), &mVariantRoots);
 }
 
diff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h
--- a/js/src/xpconnect/src/xpcprivate.h
+++ b/js/src/xpconnect/src/xpcprivate.h
@@ -242,27 +242,30 @@ namespace xpc {
 
 class PtrAndPrincipalHashKey : public PLDHashEntryHdr
 {
   public:
     typedef PtrAndPrincipalHashKey *KeyType;
     typedef const PtrAndPrincipalHashKey *KeyTypePointer;
 
     PtrAndPrincipalHashKey(const PtrAndPrincipalHashKey *aKey)
-      : mPtr(aKey->mPtr), mURI(aKey->mURI), mSavedHash(aKey->mSavedHash)
+      : mPtr(aKey->mPtr), mPrincipal(aKey->mPrincipal),
+        mSavedHash(aKey->mSavedHash)
     {
         MOZ_COUNT_CTOR(PtrAndPrincipalHashKey);
     }
 
-    PtrAndPrincipalHashKey(nsISupports *aPtr, nsIURI *aURI)
-      : mPtr(aPtr), mURI(aURI)
+    PtrAndPrincipalHashKey(nsISupports *aPtr, nsIPrincipal *aPrincipal)
+      : mPtr(aPtr), mPrincipal(aPrincipal)
     {
         MOZ_COUNT_CTOR(PtrAndPrincipalHashKey);
-        mSavedHash = mURI
-                     ? NS_SecurityHashURI(mURI)
+        nsCOMPtr<nsIURI> uri;
+        aPrincipal->GetURI(getter_AddRefs(uri));
+        mSavedHash = uri
+                     ? NS_SecurityHashURI(uri)
                      : (NS_PTR_TO_UINT32(mPtr.get()) >> 2);
     }
 
     ~PtrAndPrincipalHashKey()
     {
         MOZ_COUNT_DTOR(PtrAndPrincipalHashKey);
     }
 
@@ -280,17 +283,17 @@ class PtrAndPrincipalHashKey : public PL
     {
         return aKey->mSavedHash;
     }
 
     enum { ALLOW_MEMMOVE = PR_TRUE };
 
   protected:
     nsCOMPtr<nsISupports> mPtr;
-    nsCOMPtr<nsIURI> mURI;
+    nsCOMPtr<nsIPrincipal> mPrincipal;
 
     // During shutdown, when we GC, we need to remove these keys from the hash
     // table. However, computing the saved hash, NS_SecurityHashURI calls back
     // into XPCOM (which is illegal during shutdown). In order to avoid this,
     // we compute the hash up front, so when we're in GC during shutdown, we
     // don't have to call into XPCOM.
     PLDHashNumber mSavedHash;
 };
diff --git a/js/src/xpconnect/wrappers/AccessCheck.cpp b/js/src/xpconnect/wrappers/AccessCheck.cpp
--- a/js/src/xpconnect/wrappers/AccessCheck.cpp
+++ b/js/src/xpconnect/wrappers/AccessCheck.cpp
@@ -67,27 +67,24 @@ AccessCheck::isSameOrigin(JSCompartment 
     nsIPrincipal *bprin = GetCompartmentPrincipal(b);
 
     // If either a or b doesn't have principals, we don't have enough
     // information to tell. Seeing as how this is Gecko, we are default-unsafe
     // in this case.
     if (!aprin || !bprin)
         return true;
 
-    nsCOMPtr<nsIURI> auri;
-    aprin->GetURI(getter_AddRefs(auri));
+    PRBool equals;
+    nsresult rv = aprin->EqualsWithoutDomain(bprin, &equals);
+    if (NS_FAILED(rv)) {
+        NS_ERROR("unable to ask about equality");
+        return false;
+    }
 
-    nsCOMPtr<nsIURI> buri;
-    bprin->GetURI(getter_AddRefs(buri));
-
-    if (!auri || !buri)
-        return aprin == bprin;
-
-    nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
-    return !ssm || NS_SUCCEEDED(ssm->CheckSameOriginURI(auri, buri, PR_FALSE));
+    return equals;
 }
 
 bool
 AccessCheck::isLocationObjectSameOrigin(JSContext *cx, JSObject *wrapper)
 {
     JSObject *obj = wrapper->unwrap()->getParent();
     if (!obj->getClass()->ext.innerObject) {
         obj = obj->unwrap();
