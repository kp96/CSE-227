# HG changeset patch
# Parent fc302667922ff27ee102b04baa9900e96d687c67
# User Blake Kaplan <mrbkap@gmail.com>
Fix bug 605167.

diff --git a/dom/base/nsDOMClassInfo.cpp b/dom/base/nsDOMClassInfo.cpp
--- a/dom/base/nsDOMClassInfo.cpp
+++ b/dom/base/nsDOMClassInfo.cpp
@@ -7011,16 +7011,21 @@ nsWindowSH::OuterObject(nsIXPConnectWrap
 
   JSObject *winObj = win->FastGetGlobalJSObject();
   if (!winObj) {
     NS_ASSERTION(origWin->IsOuterWindow(), "What window is this?");
     *_retval = obj;
     return NS_OK;
   }
 
+  if (!JS_WrapObject(cx, &winObj)) {
+    *_retval = nsnull;
+    return NS_ERROR_UNEXPECTED;
+  }
+
   *_retval = winObj;
   return NS_OK;
 }
 
 // DOM Location helper
 
 NS_IMETHODIMP
 nsLocationSH::CheckAccess(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
diff --git a/js/src/xpconnect/wrappers/WrapperFactory.cpp b/js/src/xpconnect/wrappers/WrapperFactory.cpp
--- a/js/src/xpconnect/wrappers/WrapperFactory.cpp
+++ b/js/src/xpconnect/wrappers/WrapperFactory.cpp
@@ -72,16 +72,29 @@ DoubleWrap(JSContext *cx, JSObject *obj,
     if (flags & WrapperFactory::WAIVE_XRAY_WRAPPER_FLAG) {
         js::SwitchToCompartment sc(cx, obj->compartment());
         return JSWrapper::New(cx, obj, NULL, obj->getParent(),
                               &WaiveXrayWrapperWrapper);
     }
     return obj;
 }
 
+static JSObject *
+GetCurrentOuter(JSContext *cx, JSObject *obj)
+{
+    OBJ_TO_OUTER_OBJECT(cx, obj);
+    if (obj->isWrapper() && !obj->getClass()->ext.innerObject) {
+        obj = obj->unwrap();
+        NS_ASSERTION(obj->getClass()->ext.innerObject,
+                     "weird object, expecting an outer window proxy");
+    }
+
+    return obj;
+}
+
 JSObject *
 WrapperFactory::PrepareForWrapping(JSContext *cx, JSObject *scope, JSObject *obj, uintN flags)
 {
     // Don't unwrap an outer window, just double wrap it if needed.
     if (obj->getClass()->ext.innerObject)
         return DoubleWrap(cx, obj, flags);
 
     // Here are the rules for wrapping:
@@ -89,19 +102,19 @@ WrapperFactory::PrepareForWrapping(JSCon
     JS_ASSERT(!obj->isWrapper());
 
     // As soon as an object is wrapped in a security wrapper, it morphs to be
     // a fat wrapper. (see also: bug XXX).
     if (IS_SLIM_WRAPPER(obj) && !MorphSlimWrapper(cx, obj))
         return nsnull;
 
     // We only hand out outer objects to script.
-    OBJ_TO_OUTER_OBJECT(cx, obj);
-    if (!obj)
-        return nsnull;
+    GetCurrentOuter(cx, obj);
+    if (obj->getClass()->ext.innerObject)
+        return DoubleWrap(cx, obj, flags);
 
     // Now, our object is ready to be wrapped, but several objects (notably
     // nsJSIIDs) have a wrapper per scope. If we are about to wrap one of
     // those objects in a security wrapper, then we need to hand back the
     // wrapper for the new scope instead. Also, global objects don't move
     // between scopes so for those we also want to return the wrapper. So...
     if (!IS_WN_WRAPPER(obj) || !obj->getParent())
         return DoubleWrap(cx, obj, flags);
@@ -275,19 +288,17 @@ WrapperFactory::WaiveXrayAndWrap(JSConte
 {
     if (JSVAL_IS_PRIMITIVE(*vp))
         return JS_WrapValue(cx, vp);
 
     JSObject *obj = JSVAL_TO_OBJECT(*vp)->unwrap();
 
     // We have to make sure that if we're wrapping an outer window, that
     // the .wrappedJSObject also wraps the outer window.
-    OBJ_TO_OUTER_OBJECT(cx, obj);
-    if (!obj)
-        return false;
+    obj = GetCurrentOuter(cx, obj);
 
     {
         js::SwitchToCompartment sc(cx, obj->compartment());
         obj = JSWrapper::New(cx, obj, NULL, obj->getParent(), &WaiveXrayWrapperWrapper);
         if (!obj)
             return false;
     }
 
