# HG changeset patch
# Parent 36f94e464e62834a3e1e5c45ca9dcb0791edfb4f
# User Blake Kaplan <mrbkap@gmail.com>
Fix bug 691359.

diff --git a/dom/base/nsDOMClassInfo.cpp b/dom/base/nsDOMClassInfo.cpp
--- a/dom/base/nsDOMClassInfo.cpp
+++ b/dom/base/nsDOMClassInfo.cpp
@@ -10036,30 +10036,24 @@ nsStringArraySH::GetProperty(nsIXPConnec
 
 // History helper
 
 NS_IMETHODIMP
 nsHistorySH::PreCreate(nsISupports *nativeObj, JSContext *cx,
                        JSObject *globalObj, JSObject **parentObj)
 {
   nsHistory *history = (nsHistory *)nativeObj;
-  nsIDocShell *ds = history->GetDocShell();
-  if (!ds) {
-    NS_WARNING("Refusing to create a history object in the wrong scope");
-    return NS_ERROR_UNEXPECTED;
-  }
-
-  nsCOMPtr<nsIScriptGlobalObject> sgo = do_GetInterface(ds);
-  if (!sgo) {
-    NS_WARNING("Refusing to create a history object in the wrong scope because the "
-               "docshell is being destroyed");
-    return NS_ERROR_UNEXPECTED;
-  }
-
-  *parentObj = sgo->GetGlobalJSObject();
+  nsCOMPtr<nsPIDOMWindow> innerWindow;
+  history->GetWindow(getter_AddRefs(innerWindow));
+  if (!innerWindow) {
+    NS_WARNING("refusing to create history object in the wrong scope");
+    return NS_ERROR_FAILURE;
+  }
+
+  *parentObj = static_cast<nsGlobalWindow *>(innerWindow.get())->FastGetGlobalJSObject();
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsHistorySH::GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
                          JSObject *obj, jsid id, jsval *vp, PRBool *_retval)
 {
   PRBool is_number = PR_FALSE;
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -1079,24 +1079,24 @@ nsGlobalWindow::CleanUp(PRBool aIgnoreMo
 
   // Guarantee idempotence.
   if (mCleanedUp)
     return;
   mCleanedUp = PR_TRUE;
 
   mNavigator = nsnull;
   mScreen = nsnull;
-  mHistory = nsnull;
   mMenubar = nsnull;
   mToolbar = nsnull;
   mLocationbar = nsnull;
   mPersonalbar = nsnull;
   mStatusbar = nsnull;
   mScrollbars = nsnull;
   mLocation = nsnull;
+  mHistory = nsnull;
   mFrames = nsnull;
   mApplicationCache = nsnull;
   mIndexedDB = nsnull;
   delete mPendingStorageEventsObsolete;
 
 
   ClearControllers();
 
@@ -1231,16 +1231,17 @@ nsGlobalWindow::FreeInnerObjects(PRBool 
   mChromeEventHandler = nsnull;
 
   if (mListenerManager) {
     mListenerManager->Disconnect();
     mListenerManager = nsnull;
   }
 
   mLocation = nsnull;
+  mHistory = nsnull;
 
   if (mDocument) {
     NS_ASSERTION(mDoc, "Why is mDoc null?");
 
     // Remember the document's principal.
     mDocumentPrincipal = mDoc->NodePrincipal();
   }
 
@@ -2383,18 +2384,16 @@ nsGlobalWindow::SetDocShell(nsIDocShell*
     nsCycleCollector_DEBUG_shouldBeFreed(static_cast<nsIScriptGlobalObject*>(this));
 #endif
   }
 
   mDocShell = aDocShell;        // Weak Reference
 
   if (mNavigator)
     mNavigator->SetDocShell(aDocShell);
-  if (mHistory)
-    mHistory->SetDocShell(aDocShell);
   if (mFrames)
     mFrames->SetDocShell(aDocShell);
   if (mScreen)
     mScreen->SetDocShell(aDocShell);
 
   // tell our member elements about the new browserwindow
   nsCOMPtr<nsIWebBrowserChrome> browserChrome;
   GetWebBrowserChrome(getter_AddRefs(browserChrome));
@@ -2905,22 +2904,22 @@ nsGlobalWindow::GetScreen(nsIDOMScreen**
   NS_IF_ADDREF(*aScreen = mScreen);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsGlobalWindow::GetHistory(nsIDOMHistory** aHistory)
 {
-  FORWARD_TO_OUTER(GetHistory, (aHistory), NS_ERROR_NOT_INITIALIZED);
+  FORWARD_TO_INNER(GetHistory, (aHistory), NS_ERROR_NOT_INITIALIZED);
 
   *aHistory = nsnull;
 
-  if (!mHistory && mDocShell) {
-    mHistory = new nsHistory(mDocShell);
+  if (!mHistory) {
+    mHistory = new nsHistory(this);
     if (!mHistory) {
       return NS_ERROR_OUT_OF_MEMORY;
     }
   }
 
   NS_IF_ADDREF(*aHistory = mHistory);
   return NS_OK;
 }
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -897,17 +897,16 @@ protected:
   nsCOMPtr<nsIScriptContext>    mContext;
   nsWeakPtr                     mOpener;
   nsCOMPtr<nsIControllers>      mControllers;
   nsCOMPtr<nsIArray>            mArguments;
   nsCOMPtr<nsIArray>            mArgumentsLast;
   nsCOMPtr<nsIPrincipal>        mArgumentsOrigin;
   nsRefPtr<nsNavigator>         mNavigator;
   nsRefPtr<nsScreen>            mScreen;
-  nsRefPtr<nsHistory>           mHistory;
   nsRefPtr<nsDOMWindowList>     mFrames;
   nsRefPtr<nsBarProp>           mMenubar;
   nsRefPtr<nsBarProp>           mToolbar;
   nsRefPtr<nsBarProp>           mLocationbar;
   nsRefPtr<nsBarProp>           mPersonalbar;
   nsRefPtr<nsBarProp>           mStatusbar;
   nsRefPtr<nsBarProp>           mScrollbars;
   nsCOMPtr<nsIWeakReference>    mWindowUtils;
@@ -928,16 +927,17 @@ protected:
   // These member variable are used only on inner windows.
   nsCOMPtr<nsIEventListenerManager> mListenerManager;
   PRCList                       mTimeouts;
   // If mTimeoutInsertionPoint is non-null, insertions should happen after it.
   nsTimeout*                    mTimeoutInsertionPoint;
   PRUint32                      mTimeoutPublicIdCounter;
   PRUint32                      mTimeoutFiringDepth;
   nsRefPtr<nsLocation>          mLocation;
+  nsRefPtr<nsHistory>           mHistory;
 
   // Holder of the dummy java plugin, used to expose window.java and
   // window.packages.
   nsRefPtr<nsDummyJavaPluginOwner> mDummyJavaPluginOwner;
 
   // These member variables are used on both inner and the outer windows.
   nsCOMPtr<nsIPrincipal> mDocumentPrincipal;
   nsCOMPtr<nsIDocument> mDoc;  // For fast access to principals
diff --git a/dom/base/nsHistory.cpp b/dom/base/nsHistory.cpp
--- a/dom/base/nsHistory.cpp
+++ b/dom/base/nsHistory.cpp
@@ -1,9 +1,10 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=2 sw=2 et tw=78: */
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
@@ -63,17 +64,18 @@
 static const char* sAllowPushStatePrefStr  =
   "browser.history.allowPushState";
 static const char* sAllowReplaceStatePrefStr =
   "browser.history.allowReplaceState";
 
 //
 //  History class implementation 
 //
-nsHistory::nsHistory(nsIDocShell* aDocShell) : mDocShell(aDocShell)
+nsHistory::nsHistory(nsPIDOMWindow* aInnerWindow)
+  : mInnerWindow(do_GetWeakReference(aInnerWindow))
 {
 }
 
 nsHistory::~nsHistory()
 {
 }
 
 
@@ -86,42 +88,39 @@ NS_INTERFACE_MAP_BEGIN(nsHistory)
   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(History)
 NS_INTERFACE_MAP_END
 
 
 NS_IMPL_ADDREF(nsHistory)
 NS_IMPL_RELEASE(nsHistory)
 
 
-void
-nsHistory::SetDocShell(nsIDocShell *aDocShell)
-{
-  mDocShell = aDocShell; // Weak Reference
-}
-
 NS_IMETHODIMP
 nsHistory::GetLength(PRInt32* aLength)
 {
   nsCOMPtr<nsISHistory>   sHistory;
 
   // Get session History from docshell
-  GetSessionHistoryFromDocShell(mDocShell, getter_AddRefs(sHistory));
+  GetSessionHistoryFromDocShell(GetDocShell(), getter_AddRefs(sHistory));
   NS_ENSURE_TRUE(sHistory, NS_ERROR_FAILURE);
   return sHistory->GetCount(aLength);
 }
 
 NS_IMETHODIMP
 nsHistory::GetCurrent(nsAString& aCurrent)
 {
+  if (!nsContentUtils::IsCallerTrustedForRead())
+    return NS_ERROR_DOM_SECURITY_ERR;
+
   PRInt32 curIndex=0;
   nsCAutoString curURL;
   nsCOMPtr<nsISHistory> sHistory;
 
   // Get SessionHistory from docshell
-  GetSessionHistoryFromDocShell(mDocShell, getter_AddRefs(sHistory));
+  GetSessionHistoryFromDocShell(GetDocShell(), getter_AddRefs(sHistory));
   NS_ENSURE_TRUE(sHistory, NS_ERROR_FAILURE);
 
   // Get the current index at session History
   sHistory->GetIndex(&curIndex);
   nsCOMPtr<nsIHistoryEntry> curEntry;
   nsCOMPtr<nsIURI>     uri;
 
   // Get the SH entry for the current index
@@ -135,22 +134,25 @@ nsHistory::GetCurrent(nsAString& aCurren
   CopyUTF8toUTF16(curURL, aCurrent);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsHistory::GetPrevious(nsAString& aPrevious)
 {
+  if (!nsContentUtils::IsCallerTrustedForRead())
+    return NS_ERROR_DOM_SECURITY_ERR;
+
   PRInt32 curIndex;
   nsCAutoString prevURL;
   nsCOMPtr<nsISHistory>  sHistory;
 
   // Get session History from docshell
-  GetSessionHistoryFromDocShell(mDocShell, getter_AddRefs(sHistory));
+  GetSessionHistoryFromDocShell(GetDocShell(), getter_AddRefs(sHistory));
   NS_ENSURE_TRUE(sHistory, NS_ERROR_FAILURE);
 
   // Get the current index at session History
   sHistory->GetIndex(&curIndex);
   nsCOMPtr<nsIHistoryEntry> prevEntry;
   nsCOMPtr<nsIURI>     uri;
 
   // Get the previous SH entry
@@ -169,17 +171,17 @@ nsHistory::GetPrevious(nsAString& aPrevi
 NS_IMETHODIMP
 nsHistory::GetNext(nsAString& aNext)
 {
   PRInt32 curIndex;
   nsCAutoString nextURL;
   nsCOMPtr<nsISHistory>  sHistory;
 
   // Get session History from docshell
-  GetSessionHistoryFromDocShell(mDocShell, getter_AddRefs(sHistory));
+  GetSessionHistoryFromDocShell(GetDocShell(), getter_AddRefs(sHistory));
   NS_ENSURE_TRUE(sHistory, NS_ERROR_FAILURE);
 
   // Get the current index at session History
   sHistory->GetIndex(&curIndex);
   nsCOMPtr<nsIHistoryEntry> nextEntry;
   nsCOMPtr<nsIURI>     uri;
 
   // Get the next SH entry
@@ -195,48 +197,48 @@ nsHistory::GetNext(nsAString& aNext)
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsHistory::Back()
 {
   nsCOMPtr<nsISHistory>  sHistory;
 
-  GetSessionHistoryFromDocShell(mDocShell, getter_AddRefs(sHistory));
+  GetSessionHistoryFromDocShell(GetDocShell(), getter_AddRefs(sHistory));
   NS_ENSURE_TRUE(sHistory, NS_ERROR_FAILURE);
 
   //QI SHistory to WebNavigation
   nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(sHistory));
   NS_ENSURE_TRUE(webNav, NS_ERROR_FAILURE);
   webNav->GoBack();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsHistory::Forward()
 {
   nsCOMPtr<nsISHistory>  sHistory;
 
-  GetSessionHistoryFromDocShell(mDocShell, getter_AddRefs(sHistory));
+  GetSessionHistoryFromDocShell(GetDocShell(), getter_AddRefs(sHistory));
   NS_ENSURE_TRUE(sHistory, NS_ERROR_FAILURE);
 
   //QI SHistory to WebNavigation
   nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(sHistory));
   NS_ENSURE_TRUE(webNav, NS_ERROR_FAILURE);
   webNav->GoForward();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsHistory::Go(PRInt32 aDelta)
 {
   if (aDelta == 0) {
-    nsCOMPtr<nsPIDOMWindow> window(do_GetInterface(mDocShell));
+    nsCOMPtr<nsPIDOMWindow> window(do_GetInterface(GetDocShell()));
 
     if (window && window->IsHandlingResizeEvent()) {
       // history.go(0) (aka location.reload()) was called on a window
       // that is handling a resize event. Sites do this since Netscape
       // 4.x needed it, but we don't, and it's a horrible experience
       // for nothing.  In stead of reloading the page, just clear
       // style data and reflow the page since some sites may use this
       // trick to work around gecko reflow bugs, and this should have
@@ -252,17 +254,17 @@ nsHistory::Go(PRInt32 aDelta)
       }
 
       return NS_OK;
     }
   }
 
   nsCOMPtr<nsISHistory> session_history;
 
-  GetSessionHistoryFromDocShell(mDocShell, getter_AddRefs(session_history));
+  GetSessionHistoryFromDocShell(GetDocShell(), getter_AddRefs(session_history));
   NS_ENSURE_TRUE(session_history, NS_ERROR_FAILURE);
 
   // QI SHistory to nsIWebNavigation
   nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(session_history));
   NS_ENSURE_TRUE(webnav, NS_ERROR_FAILURE);
 
   PRInt32 curIndex=-1;
   PRInt32 len = 0;
@@ -283,61 +285,75 @@ nsHistory::Go(PRInt32 aDelta)
 NS_IMETHODIMP
 nsHistory::PushState(nsIVariant *aData, const nsAString& aTitle,
                      const nsAString& aURL)
 {
   // Check that PushState hasn't been pref'ed off.
   if (!nsContentUtils::GetBoolPref(sAllowPushStatePrefStr, PR_FALSE))
     return NS_OK;
 
-  NS_ENSURE_TRUE(mDocShell, NS_ERROR_FAILURE);
+  nsCOMPtr<nsPIDOMWindow> win(do_QueryReferent(mInnerWindow));
+  if (!win)
+    return NS_ERROR_NOT_AVAILABLE;
+
+  if (!nsContentUtils::CanCallerAccess(win->GetOuterWindow()))
+    return NS_ERROR_DOM_SECURITY_ERR;
 
   // AddState might run scripts, so we need to hold a strong reference to the
   // docShell here to keep it from going away.
-  nsCOMPtr<nsIDocShell> docShell = mDocShell;
+  nsCOMPtr<nsIDocShell> docShell = win->GetDocShell();
+
+  NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
 
   // PR_FALSE tells the docshell to add a new history entry instead of
   // modifying the current one.
-  nsresult rv = mDocShell->AddState(aData, aTitle, aURL, PR_FALSE);
+  nsresult rv = docShell->AddState(aData, aTitle, aURL, PR_FALSE);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsHistory::ReplaceState(nsIVariant *aData, const nsAString& aTitle,
                         const nsAString& aURL)
 {
   // Check that ReplaceState hasn't been pref'ed off
   if (!nsContentUtils::GetBoolPref(sAllowReplaceStatePrefStr, PR_FALSE))
     return NS_OK;
 
-  NS_ENSURE_TRUE(mDocShell, NS_ERROR_FAILURE);
+  nsCOMPtr<nsPIDOMWindow> win(do_QueryReferent(mInnerWindow));
+  if (!win)
+    return NS_ERROR_NOT_AVAILABLE;
 
-  // As in PushState(), we need to keep a strong reference to the docShell
-  // here.
-  nsCOMPtr<nsIDocShell> docShell = mDocShell;
+  if (!nsContentUtils::CanCallerAccess(win->GetOuterWindow()))
+    return NS_ERROR_DOM_SECURITY_ERR;
+
+  // AddState might run scripts, so we need to hold a strong reference to the
+  // docShell here to keep it from going away.
+  nsCOMPtr<nsIDocShell> docShell = win->GetDocShell();
+
+  NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
 
   // PR_TRUE tells the docshell to modify the current SHEntry, rather than
   // create a new one.
-  return mDocShell->AddState(aData, aTitle, aURL, PR_TRUE);
+  return docShell->AddState(aData, aTitle, aURL, PR_TRUE);
 }
 
 NS_IMETHODIMP
 nsHistory::Item(PRUint32 aIndex, nsAString& aReturn)
 {
   aReturn.Truncate();
   if (!nsContentUtils::IsCallerTrustedForRead()) {
     return NS_ERROR_DOM_SECURITY_ERR;
   }
 
   nsresult rv = NS_OK;
   nsCOMPtr<nsISHistory>  session_history;
 
-  GetSessionHistoryFromDocShell(mDocShell, getter_AddRefs(session_history));
+  GetSessionHistoryFromDocShell(GetDocShell(), getter_AddRefs(session_history));
   NS_ENSURE_TRUE(session_history, NS_ERROR_FAILURE);
 
   nsCOMPtr<nsIHistoryEntry> sh_entry;
   nsCOMPtr<nsIURI> uri;
 
   rv = session_history->GetEntryAtIndex(aIndex, PR_FALSE,
                                         getter_AddRefs(sh_entry));
 
@@ -362,17 +378,17 @@ nsHistory::GetSessionHistoryFromDocShell
 
   NS_ENSURE_TRUE(aDocShell, NS_ERROR_FAILURE);
   /* The docshell we have may or may not be
    * the root docshell. So, get a handle to
    * SH from the root docshell
    */
   
   // QI mDocShell to nsIDocShellTreeItem
-  nsCOMPtr<nsIDocShellTreeItem> dsTreeItem(do_QueryInterface(mDocShell));
+  nsCOMPtr<nsIDocShellTreeItem> dsTreeItem(do_QueryInterface(aDocShell));
   NS_ENSURE_TRUE(dsTreeItem, NS_ERROR_FAILURE);
 
   // Get the root DocShell from it
   nsCOMPtr<nsIDocShellTreeItem> root;
   dsTreeItem->GetSameTypeRootTreeItem(getter_AddRefs(root));
   NS_ENSURE_TRUE(root, NS_ERROR_FAILURE);
   
   //QI root to nsIWebNavigation
diff --git a/dom/base/nsHistory.h b/dom/base/nsHistory.h
--- a/dom/base/nsHistory.h
+++ b/dom/base/nsHistory.h
@@ -1,9 +1,10 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=2 sw=2 et tw=79: */
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
@@ -37,35 +38,46 @@
 #ifndef nsHistory_h___
 #define nsHistory_h___
 
 #include "nsIDOMHistory.h"
 #include "nsISupports.h"
 #include "nscore.h"
 #include "nsIScriptContext.h"
 #include "nsISHistory.h"
+#include "nsIWeakReference.h"
+#include "nsPIDOMWindow.h"
 
 class nsIDocShell;
 
 // Script "History" object
 class nsHistory : public nsIDOMHistory
 {
 public:
-  nsHistory(nsIDocShell* aDocShell);
+  nsHistory(nsPIDOMWindow* aInnerWindow);
   virtual ~nsHistory();
 
   // nsISupports
   NS_DECL_ISUPPORTS
 
   // nsIDOMHistory
   NS_DECL_NSIDOMHISTORY
 
-  nsIDocShell *GetDocShell() { return mDocShell; }
-  void SetDocShell(nsIDocShell *aDocShell);
+  nsIDocShell *GetDocShell() {
+    nsCOMPtr<nsPIDOMWindow> win(do_QueryReferent(mInnerWindow));
+    if (!win)
+      return nsnull;
+    return win->GetDocShell();
+  }
+
+  void GetWindow(nsPIDOMWindow **aWindow) {
+    nsCOMPtr<nsPIDOMWindow> win(do_QueryReferent(mInnerWindow));
+    *aWindow = win.forget().get();
+  }
 
 protected:
   nsresult GetSessionHistoryFromDocShell(nsIDocShell * aDocShell,
                                          nsISHistory ** aReturn);
 
-  nsIDocShell* mDocShell;
+  nsCOMPtr<nsIWeakReference> mInnerWindow;
 };
 
 #endif /* nsHistory_h___ */
