Index: browser/base/content/browser.js
===================================================================
RCS file: /cvsroot/mozilla/browser/base/content/browser.js,v
retrieving revision 1.1026
diff -u -1 -0 -d -p -r1.1026 browser.js
--- browser/base/content/browser.js	15 Apr 2008 20:42:48 -0000	1.1026
+++ browser/base/content/browser.js	22 Apr 2008 12:48:05 -0000
@@ -6555,21 +6555,23 @@ IdentityHandler.prototype = {
 
       // Cache the override service the first time we need to check it
       if (!this._overrideService)
         this._overrideService = Components.classes["@mozilla.org/security/certoverride;1"]
                                           .getService(Components.interfaces.nsICertOverrideService);
 
       // Verifier is either the CA Org, for a normal cert, or a special string
       // for certs that are trusted because of a security exception.
       var tooltip = this._stringBundle.getFormattedString("identity.identified.verifier",
                                                           [iData.caOrg]);
-      if (this._overrideService.hasMatchingOverride(lookupHost, iData.cert, {}, {}))
+      if (this._overrideService.hasMatchingOverride(this._lastLocation.hostname, 
+                                                    this._lastLocation.port, 
+                                                    iData.cert, {}, {}))
         tooltip = this._stringBundle.getString("identity.identified.verified_by_you");
     }
     else if (newMode == this.IDENTITY_MODE_IDENTIFIED) {
       // If it's identified, then we can populate the dialog with credentials
       iData = this.getIdentityData();  
       tooltip = this._stringBundle.getFormattedString("identity.identified.verifier",
                                                       [iData.caOrg]);
       if (iData.country)
         icon_label = this._stringBundle.getFormattedString("identity.identified.title_with_country",
                                                            [iData.subjectOrg, iData.country]);
Index: security/manager/pki/resources/content/exceptionDialog.js
===================================================================
RCS file: /cvsroot/mozilla/security/manager/pki/resources/content/exceptionDialog.js,v
retrieving revision 1.9
diff -u -1 -0 -d -p -r1.9 exceptionDialog.js
--- security/manager/pki/resources/content/exceptionDialog.js	7 Apr 2008 20:46:50 -0000	1.9
+++ security/manager/pki/resources/content/exceptionDialog.js	22 Apr 2008 12:48:06 -0000
@@ -335,22 +335,23 @@ function addException() {
   var flags = 0;
   if(gSSLStatus.isUntrusted)
     flags |= overrideService.ERROR_UNTRUSTED;
   if(gSSLStatus.isDomainMismatch)
     flags |= overrideService.ERROR_MISMATCH;
   if(gSSLStatus.isNotValidAtThisTime)
     flags |= overrideService.ERROR_TIME;
   
   var permanentCheckbox = document.getElementById("permanent");
 
+  var uri = getURI();
   overrideService.rememberValidityOverride(
-    getURI().hostPort,
+    uri.asciiHost, uri.port,
     gCert,
     flags,
     !permanentCheckbox.checked);
   
   var args = window.arguments;
   if (args && args[0])
     args[0].exceptionAdded = true;
   
   gDialog.acceptDialog();
 }
Index: security/manager/ssl/public/nsICertOverrideService.idl
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/public/nsICertOverrideService.idl,v
retrieving revision 1.2
diff -u -1 -0 -d -p -r1.2 nsICertOverrideService.idl
--- security/manager/ssl/public/nsICertOverrideService.idl	19 Nov 2007 15:32:45 -0000	1.2
+++ security/manager/ssl/public/nsICertOverrideService.idl	22 Apr 2008 12:48:06 -0000
@@ -44,21 +44,21 @@ interface nsIX509Cert;
 
 %{C++
 #define NS_CERTOVERRIDE_CONTRACTID "@mozilla.org/security/certoverride;1"
 %}
 
 /**
  * This represents the global list of triples
  *   {host:port, cert-fingerprint, allowed-overrides} 
  * that the user wants to accept without further warnings. 
  */
-[scriptable, uuid(13ca097a-935c-4a62-9c91-7a9d803ae701)]
+[scriptable, uuid(31738d2a-77d3-4359-84c9-4be2f38fb8c5)]
 interface nsICertOverrideService : nsISupports {
 
   /**
    *  Override Untrusted
    */
   const short ERROR_UNTRUSTED = 1;
 
   /**
    *  Override hostname Mismatch
    */
@@ -69,70 +69,82 @@ interface nsICertOverrideService : nsISu
    */
   const short ERROR_TIME = 4;
 
   /**
    *  The given cert should always be accepted for the given hostname:port,
    *  regardless of errors verifying the cert.
    *  Host:Port is a primary key, only one entry per host:port can exist.
    *  The implementation will store a fingerprint of the cert.
    *  The implementation will decide which fingerprint alg is used.
    *
-   *  @param aHostNameWithPort The host:port this mapping belongs to
+   *  @param aHostName The host (punycode) this mapping belongs to
+   *  @param aPort The port this mapping belongs to, if it is -1 then it 
+   *          is internaly treated as 443
    *  @param aCert The cert that should always be accepted
    *  @param aOverrideBits The errors we want to be overriden
    */
-  void rememberValidityOverride(in AString aHostNameWithPort, 
+  void rememberValidityOverride(in ACString aHostName, 
+                                in PRInt32 aPort,
                                 in nsIX509Cert aCert,
                                 in PRUint32 aOverrideBits,
                                 in boolean aTemporary);
 
   /**
    *  The given cert should always be accepted for the given hostname:port,
    *  regardless of errors verifying the cert.
    *  Host:Port is a primary key, only one entry per host:port can exist.
    *  The implementation will store a fingerprint of the cert.
    *  The implementation will decide which fingerprint alg is used.
    *
-   *  @param aHostNameWithPort The host:port this mapping belongs to
+   *  @param aHostName The host (punycode) this mapping belongs to
+   *  @param aPort The port this mapping belongs to, if it is -1 then it 
+   *          is internaly treated as 443
    *  @param aCert The cert that should always be accepted
    *  @param aOverrideBits The errors that are currently overriden
    *  @return whether an override entry for aHostNameWithPort is currently on file
    *          that matches the given certificate
    */
-  boolean hasMatchingOverride(in AString aHostNameWithPort, 
+  boolean hasMatchingOverride(in ACString aHostName, 
+                              in PRInt32 aPort,
                               in nsIX509Cert aCert,
                               out PRUint32 aOverrideBits,
                               out boolean aIsTemporary);
 
   /**
    *  Retrieve the stored override for the given hostname:port.
    *
-   *  @param aHostNameWithPort The host:port whose entry should be tested
+   *  @param aHostName The host (punycode) whose entry should be tested
+   *  @param aPort The port whose entry should be tested, if it is -1 then it 
+   *          is internaly treated as 443
    *  @param aHashAlg On return value True, the fingerprint hash algorithm
    *                  as an OID value in dotted notation.
    *  @param aFingerprint On return value True, the stored fingerprint 
    *  @param aOverrideBits The errors that are currently overriden
    *  @return whether a matching override entry for aHostNameWithPort 
    *          and aFingerprint is currently on file
    */
-  boolean getValidityOverride(in AString aHostNameWithPort, 
+  boolean getValidityOverride(in ACString aHostName, 
+                              in PRInt32 aPort,
                               out ACString aHashAlg,
                               out ACString aFingerprint,
                               out PRUint32 aOverrideBits,
                               out boolean aIsTemporary);
 
   /**
    *  Remove a override for the given hostname:port.
    *
-   *  @param aHostNameWithPort The host:port whose entry should be cleared.
+   *  @param aHostName The host (punycode) whose entry should be cleared.
+   *  @param aPort The port whose entry should be cleared, if it is -1 then it 
+   *          is internaly treated as 443
    */
-  void clearValidityOverride(in AString aHostNameWithPort);
+  void clearValidityOverride(in ACString aHostName,
+                             in PRInt32 aPort);
 
   /**
    *  Obtain the full list of hostname:port for which overrides are known.
    *
    *  @param aCount The number of host:port entries returned
    *  @param aHostsWithPortsArray The array of host:port entries returned
    */
   void getAllOverrideHostsWithPorts(out PRUint32 aCount, 
                                     [array, size_is(aCount)] out wstring aHostsWithPortsArray);
 
Index: security/manager/ssl/src/nsCertOverrideService.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsCertOverrideService.cpp,v
retrieving revision 1.5
diff -u -1 -0 -d -p -r1.5 nsCertOverrideService.cpp
--- security/manager/ssl/src/nsCertOverrideService.cpp	22 Feb 2008 08:50:11 -0000	1.5
+++ security/manager/ssl/src/nsCertOverrideService.cpp	22 Apr 2008 12:48:07 -0000
@@ -259,30 +259,44 @@ nsCertOverrideService::Read()
     // string indexes, which can be lopped off into substrings. just for
     // purposes of obfuscation, it also checks that each token was found.
     // todo: use iterators?
     if ((algoIndex         = buffer.FindChar('\t', hostIndex)         + 1) == 0 ||
         (fingerprintIndex  = buffer.FindChar('\t', algoIndex)         + 1) == 0 ||
         (overrideBitsIndex = buffer.FindChar('\t', fingerprintIndex)  + 1) == 0 ||
         (dbKeyIndex        = buffer.FindChar('\t', overrideBitsIndex) + 1) == 0) {
       continue;
     }
 
-    const nsASingleFragmentCString &host = Substring(buffer, hostIndex, algoIndex - hostIndex - 1);
+    const nsASingleFragmentCString &tmp = Substring(buffer, hostIndex, algoIndex - hostIndex - 1);
     const nsASingleFragmentCString &algo_string = Substring(buffer, algoIndex, fingerprintIndex - algoIndex - 1);
     const nsASingleFragmentCString &fingerprint = Substring(buffer, fingerprintIndex, overrideBitsIndex - fingerprintIndex - 1);
     const nsASingleFragmentCString &bits_string = Substring(buffer, overrideBitsIndex, dbKeyIndex - overrideBitsIndex - 1);
     const nsASingleFragmentCString &db_key = Substring(buffer, dbKeyIndex, buffer.Length() - dbKeyIndex);
 
+    nsCAutoString host(tmp);
     nsCertOverride::OverrideBits bits;
     nsCertOverride::convertStringToBits(bits_string, bits);
 
-    AddEntryToList(host, 
+    PRInt32 port;
+    PRInt32 portIndex = host.RFindChar(':');
+    if (portIndex == kNotFound)
+      continue; // Ignore broken entries
+
+    PRInt32 portParseError;
+    nsCAutoString portString(Substring(host, portIndex+1));
+    port = portString.ToInteger(&portParseError);
+    if (portParseError)
+      continue; // Ignore broken entries
+
+    host.Truncate(portIndex);
+    
+    AddEntryToList(host, port, 
                    PR_FALSE, // not temporary
                    algo_string, fingerprint, bits, db_key);
   }
 
   return NS_OK;
 }
 
 PR_STATIC_CALLBACK(PLDHashOperator)
 WriteEntryCallback(nsCertOverrideEntry *aEntry,
                    void *aArg)
@@ -296,21 +310,21 @@ WriteEntryCallback(nsCertOverrideEntry *
   if (rawStreamPtr && aEntry)
   {
     const nsCertOverride &settings = aEntry->mSettings;
     if (settings.mIsTemporary)
       return PL_DHASH_NEXT;
 
     nsCAutoString bits_string;
     nsCertOverride::convertBitsToString(settings.mOverrideBits, 
                                             bits_string);
 
-    rawStreamPtr->Write(settings.mHostWithPortUTF8.get(), settings.mHostWithPortUTF8.Length(), &rv);
+    rawStreamPtr->Write(aEntry->mHostWithPort.get(), aEntry->mHostWithPort.Length(), &rv);
     rawStreamPtr->Write(kTab, sizeof(kTab) - 1, &rv);
     rawStreamPtr->Write(settings.mFingerprintAlgOID.get(), 
                         settings.mFingerprintAlgOID.Length(), &rv);
     rawStreamPtr->Write(kTab, sizeof(kTab) - 1, &rv);
     rawStreamPtr->Write(settings.mFingerprint.get(), 
                         settings.mFingerprint.Length(), &rv);
     rawStreamPtr->Write(kTab, sizeof(kTab) - 1, &rv);
     rawStreamPtr->Write(bits_string.get(), 
                         bits_string.Length(), &rv);
     rawStreamPtr->Write(kTab, sizeof(kTab) - 1, &rv);
@@ -445,27 +459,29 @@ GetCertFingerprintByDottedOidString(nsIX
 
   CERTCertificate* nsscert = cert2->GetCert();
   if (!nsscert)
     return NS_ERROR_FAILURE;
 
   CERTCertificateCleaner nsscertCleaner(nsscert);
   return GetCertFingerprintByDottedOidString(nsscert, dottedOid, fp);
 }
 
 NS_IMETHODIMP
-nsCertOverrideService::RememberValidityOverride(const nsAString & aHostNameWithPort, 
+nsCertOverrideService::RememberValidityOverride(const nsACString & aHostName, PRInt32 aPort, 
                                                 nsIX509Cert *aCert,
                                                 PRUint32 aOverrideBits, 
                                                 PRBool aTemporary)
 {
   NS_ENSURE_ARG_POINTER(aCert);
-  if (aHostNameWithPort.IsEmpty())
+  if (aHostName.IsEmpty())
+    return NS_ERROR_INVALID_ARG;
+  if (aPort < -1)
     return NS_ERROR_INVALID_ARG;
 
   nsCOMPtr<nsIX509Cert2> cert2 = do_QueryInterface(aCert);
   if (!cert2)
     return NS_ERROR_FAILURE;
 
   CERTCertificate* nsscert = cert2->GetCert();
   if (!nsscert)
     return NS_ERROR_FAILURE;
 
@@ -480,28 +496,20 @@ nsCertOverrideService::RememberValidityO
   if (!slot)
     return NS_ERROR_FAILURE;
 
   SECStatus srv = PK11_ImportCert(slot, nsscert, CK_INVALID_HANDLE, 
                                   const_cast<char*>(nickname.get()), PR_FALSE);
   PK11_FreeSlot(slot);
 
   if (srv != SECSuccess)
     return NS_ERROR_FAILURE;
 
-  nsCString myHostPort;
-  myHostPort = NS_ConvertUTF16toUTF8(aHostNameWithPort);
-
-  PRInt32 find_colon = myHostPort.FindChar(':');
-  if (find_colon == -1) {
-    myHostPort.AppendLiteral(":443");
-  }
-
   nsCAutoString fpStr;
   nsresult rv = GetCertFingerprintByOidTag(nsscert, 
                   mOidTagForStoringNewHashes, fpStr);
   if (NS_FAILED(rv))
     return rv;
 
   char *dbkey = NULL;
   rv = aCert->GetDbKey(&dbkey);
   if (NS_FAILED(rv) || !dbkey)
     return rv;
@@ -511,55 +519,58 @@ nsCertOverrideService::RememberValidityO
        *dbkey_walk;
       ++dbkey_walk) {
     char c = *dbkey_walk;
     if (c == '\r' || c == '\n') {
       *dbkey_walk = ' ';
     }
   }
 
   {
     nsAutoMonitor lock(monitor);
-    AddEntryToList(myHostPort,
+    AddEntryToList(aHostName, aPort,
                    aTemporary, 
                    mDottedOidForStoringNewHashes, fpStr, 
                    (nsCertOverride::OverrideBits)aOverrideBits, 
                    nsDependentCString(dbkey));
     Write();
   }
 
   PR_Free(dbkey);
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsCertOverrideService::HasMatchingOverride(const nsAString & aHostNameWithPort, 
+nsCertOverrideService::HasMatchingOverride(const nsACString & aHostName, PRInt32 aPort,
                                            nsIX509Cert *aCert, 
                                            PRUint32 *aOverrideBits,
                                            PRBool *aIsTemporary,
                                            PRBool *_retval)
 {
-  if (aHostNameWithPort.IsEmpty())
+  if (aHostName.IsEmpty())
+    return NS_ERROR_INVALID_ARG;
+  if (aPort < -1)
     return NS_ERROR_INVALID_ARG;
 
   NS_ENSURE_ARG_POINTER(aCert);
   NS_ENSURE_ARG_POINTER(aOverrideBits);
   NS_ENSURE_ARG_POINTER(aIsTemporary);
   NS_ENSURE_ARG_POINTER(_retval);
   *_retval = PR_FALSE;
   *aOverrideBits = nsCertOverride::ob_None;
 
-  NS_ConvertUTF16toUTF8 hp8(aHostNameWithPort);
+  nsCAutoString hostPort;
+  GetHostWithPort(aHostName, aPort, hostPort);
   nsCertOverride settings;
 
   {
     nsAutoMonitor lock(monitor);
-    nsCertOverrideEntry *entry = mSettingsTable.GetEntry(hp8.get());
+    nsCertOverrideEntry *entry = mSettingsTable.GetEntry(hostPort.get());
   
     if (!entry)
       return NS_OK;
   
     settings = entry->mSettings; // copy
   }
 
   *aOverrideBits = settings.mOverrideBits;
   *aIsTemporary = settings.mIsTemporary;
 
@@ -573,94 +584,100 @@ nsCertOverrideService::HasMatchingOverri
     rv = GetCertFingerprintByDottedOidString(aCert, settings.mFingerprintAlgOID, fpStr);
   }
   if (NS_FAILED(rv))
     return rv;
 
   *_retval = settings.mFingerprint.Equals(fpStr);
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsCertOverrideService::GetValidityOverride(const nsAString & aHostNameWithPort, 
+nsCertOverrideService::GetValidityOverride(const nsACString & aHostName, PRInt32 aPort,
                                            nsACString & aHashAlg, 
                                            nsACString & aFingerprint, 
                                            PRUint32 *aOverrideBits,
                                            PRBool *aIsTemporary,
                                            PRBool *_found)
 {
   NS_ENSURE_ARG_POINTER(_found);
   NS_ENSURE_ARG_POINTER(aIsTemporary);
   NS_ENSURE_ARG_POINTER(aOverrideBits);
   *_found = PR_FALSE;
   *aOverrideBits = nsCertOverride::ob_None;
 
-  NS_ConvertUTF16toUTF8 hp8(aHostNameWithPort);
+  nsCAutoString hostPort;
+  GetHostWithPort(aHostName, aPort, hostPort);
   nsCertOverride settings;
 
   {
     nsAutoMonitor lock(monitor);
-    nsCertOverrideEntry *entry = mSettingsTable.GetEntry(hp8.get());
+    nsCertOverrideEntry *entry = mSettingsTable.GetEntry(hostPort.get());
   
     if (entry) {
       *_found = PR_TRUE;
       settings = entry->mSettings; // copy
     }
   }
 
   if (*_found) {
     *aOverrideBits = settings.mOverrideBits;
     *aIsTemporary = settings.mIsTemporary;
     aFingerprint = settings.mFingerprint;
     aHashAlg = settings.mFingerprintAlgOID;
   }
 
   return NS_OK;
 }
 
 nsresult
-nsCertOverrideService::AddEntryToList(const nsACString &hostWithPortUTF8, 
+nsCertOverrideService::AddEntryToList(const nsACString &aHostName, PRInt32 aPort,
                                       const PRBool aIsTemporary,
                                       const nsACString &fingerprintAlgOID, 
                                       const nsACString &fingerprint,
                                       nsCertOverride::OverrideBits ob,
                                       const nsACString &dbKey)
 {
-  const nsPromiseFlatCString &flat = PromiseFlatCString(hostWithPortUTF8);
+  nsCAutoString hostPort;
+  GetHostWithPort(aHostName, aPort, hostPort);
 
   {
     nsAutoMonitor lock(monitor);
-    nsCertOverrideEntry *entry = mSettingsTable.PutEntry(flat.get());
+    nsCertOverrideEntry *entry = mSettingsTable.PutEntry(hostPort.get());
 
     if (!entry) {
       NS_ERROR("can't insert a null entry!");
       return NS_ERROR_OUT_OF_MEMORY;
     }
 
+    entry->mHostWithPort = hostPort;
+
     nsCertOverride &settings = entry->mSettings;
-    settings.mHostWithPortUTF8 = hostWithPortUTF8;
+    settings.mAsciiHost = aHostName;
+    settings.mPort = aPort;
     settings.mIsTemporary = aIsTemporary;
     settings.mFingerprintAlgOID = fingerprintAlgOID;
     settings.mFingerprint = fingerprint;
     settings.mOverrideBits = ob;
     settings.mDBKey = dbKey;
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsCertOverrideService::ClearValidityOverride(const nsAString & aHostNameWithPort)
+nsCertOverrideService::ClearValidityOverride(const nsACString & aHostName, PRInt32 aPort)
 {
-  NS_ConvertUTF16toUTF8 hp8(aHostNameWithPort);
+  nsCAutoString hostPort;
+  GetHostWithPort(aHostName, aPort, hostPort);
   {
     nsAutoMonitor lock(monitor);
-    mSettingsTable.RemoveEntry(hp8.get());
+    mSettingsTable.RemoveEntry(hostPort.get());
     Write();
   }
   SSL_ClearSessionCache();
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCertOverrideService::GetAllOverrideHostsWithPorts(PRUint32 *aCount, 
                                                         PRUnichar ***aHostsWithPortsArray)
 {
@@ -846,10 +863,22 @@ nsCertOverrideService::EnumerateCertOver
   capac.enumerator = enumerator;
   capac.mOidTagForStoringNewHashes = mOidTagForStoringNewHashes;
   capac.mDottedOidForStoringNewHashes = mDottedOidForStoringNewHashes;
 
   {
     nsAutoMonitor lock(monitor);
     mSettingsTable.EnumerateEntries(EnumerateCertOverridesCallback, &capac);
   }
   return NS_OK;
 }
+
+void
+nsCertOverrideService::GetHostWithPort(const nsACString & aHostName, PRInt32 aPort, nsACString& _retval)
+{
+  nsCAutoString hostPort(aHostName);
+  if (aPort == -1)
+    aPort = 443;
+  hostPort.AppendLiteral(":");
+  hostPort.AppendInt(aPort);
+  
+  _retval.Assign(hostPort);
+}
\ No newline at end of file
Index: security/manager/ssl/src/nsCertOverrideService.h
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsCertOverrideService.h,v
retrieving revision 1.3
diff -u -1 -0 -d -p -r1.3 nsCertOverrideService.h
--- security/manager/ssl/src/nsCertOverrideService.h	1 Feb 2008 06:04:56 -0000	1.3
+++ security/manager/ssl/src/nsCertOverrideService.h	22 Apr 2008 12:48:07 -0000
@@ -51,41 +51,44 @@
 #include "nsWeakReference.h"
 
 class nsCertOverride
 {
 public:
 
   enum OverrideBits { ob_None=0, ob_Untrusted=1, ob_Mismatch=2,
                       ob_Time_error=4 };
 
   nsCertOverride()
-  :mOverrideBits(ob_None)
+  :mPort(-1)
+  ,mOverrideBits(ob_None)
   {
   }
 
   nsCertOverride(const nsCertOverride &other)
   {
     this->operator=(other);
   }
 
   nsCertOverride &operator=(const nsCertOverride &other)
   {
-    mHostWithPortUTF8 = other.mHostWithPortUTF8;
+    mAsciiHost = other.mAsciiHost;
+    mPort = other.mPort;
     mIsTemporary = other.mIsTemporary;
     mFingerprintAlgOID = other.mFingerprintAlgOID;
     mFingerprint = other.mFingerprint;
     mOverrideBits = other.mOverrideBits;
     mDBKey = other.mDBKey;
     return *this;
   }
 
-  nsCString mHostWithPortUTF8;
+  nsCString mAsciiHost;
+  PRInt32 mPort;
   PRBool mIsTemporary; // true: session only, false: stored on disk
   nsCString mFingerprint;
   nsCString mFingerprintAlgOID;
   OverrideBits mOverrideBits;
   nsCString mDBKey;
 
   static void convertBitsToString(OverrideBits ob, nsACString &str);
   static void convertStringToBits(const nsACString &str, OverrideBits &ob);
 };
 
@@ -135,28 +138,29 @@ class nsCertOverrideEntry : public PLDHa
     static PLDHashNumber HashKey(KeyTypePointer aKey)
     {
       // PL_DHashStringKey doesn't use the table parameter, so we can safely
       // pass nsnull
       return PL_DHashStringKey(nsnull, aKey);
     }
 
     enum { ALLOW_MEMMOVE = PR_FALSE };
 
     // get methods
-    inline const nsCString &HostWithPort() const { return mSettings.mHostWithPortUTF8; }
+    inline const nsCString &HostWithPort() const { return mHostWithPort; }
 
     inline KeyTypePointer HostWithPortPtr() const
     {
-      return mSettings.mHostWithPortUTF8.get();
+      return mHostWithPort.get();
     }
 
     nsCertOverride mSettings;
+    nsCString mHostWithPort;
 };
 
 class nsCertOverrideService : public nsICertOverrideService
                             , public nsIObserver
                             , public nsSupportsWeakReference
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSICERTOVERRIDESERVICE
   NS_DECL_NSIOBSERVER
@@ -169,32 +173,37 @@ public:
   typedef void 
   (*PR_CALLBACK CertOverrideEnumerator)(const nsCertOverride &aSettings,
                                         void *aUserData);
 
   // aCert == null: return all overrides
   // aCert != null: return overrides that match the given cert
   nsresult EnumerateCertOverrides(nsIX509Cert *aCert,
                                   CertOverrideEnumerator enumerator,
                                   void *aUserData);
 
+    // Concates host name and the port number. If the port number is -1 then
+    // port 443 is automatically used. This method ensures there is always a port
+    // number separated with colon.
+    static void GetHostWithPort(const nsACString & aHostName, PRInt32 aPort, nsACString& _retval);
+
 protected:
     PRMonitor *monitor;
     nsCOMPtr<nsIFile> mSettingsFile;
     nsTHashtable<nsCertOverrideEntry> mSettingsTable;
 
     SECOidTag mOidTagForStoringNewHashes;
     nsCString mDottedOidForStoringNewHashes;
 
     void RemoveAllFromMemory();
     nsresult Read();
     nsresult Write();
-    nsresult AddEntryToList(const nsACString &hostWithPortUTF8,
+    nsresult AddEntryToList(const nsACString &host, PRInt32 port,
                             const PRBool aIsTemporary,
                             const nsACString &algo_oid, 
                             const nsACString &fingerprint,
                             nsCertOverride::OverrideBits ob,
                             const nsACString &dbKey);
 };
 
 #define NS_CERTOVERRIDE_CID { /* 67ba681d-5485-4fff-952c-2ee337ffdcd6 */ \
     0x67ba681d,                                                        \
     0x5485,                                                            \
Index: security/manager/ssl/src/nsCertTree.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsCertTree.cpp,v
retrieving revision 1.64
diff -u -1 -0 -d -p -r1.64 nsCertTree.cpp
--- security/manager/ssl/src/nsCertTree.cpp	30 Nov 2007 19:55:31 -0000	1.64
+++ security/manager/ssl/src/nsCertTree.cpp	22 Apr 2008 12:48:09 -0000
@@ -136,30 +136,32 @@ static PLDHashTableOps gMapOps = {
   PL_DHashFinalizeStub,
   CompareCacheInitEntry
 };
 
 NS_IMPL_ISUPPORTS0(nsCertAddonInfo)
 NS_IMPL_ISUPPORTS1(nsCertTreeDispInfo, nsICertTreeItem)
 
 nsCertTreeDispInfo::nsCertTreeDispInfo()
 :mAddonInfo(nsnull)
 ,mTypeOfEntry(direct_db)
+,mPort(-1)
 ,mOverrideBits(nsCertOverride::ob_None)
 ,mIsTemporary(PR_TRUE)
 {
 }
 
 nsCertTreeDispInfo::nsCertTreeDispInfo(nsCertTreeDispInfo &other)
 {
   mAddonInfo = other.mAddonInfo;
   mTypeOfEntry = other.mTypeOfEntry;
-  mHostWithPort = other.mHostWithPort;
+  mAsciiHost = other.mAsciiHost;
+  mPort = other.mPort;
   mOverrideBits = other.mOverrideBits;
   mIsTemporary = other.mIsTemporary;
 }
 
 nsCertTreeDispInfo::~nsCertTreeDispInfo()
 {
 }
 
 NS_IMETHODIMP
 nsCertTreeDispInfo::GetCert(nsIX509Cert **_cert)
@@ -171,21 +173,23 @@ nsCertTreeDispInfo::GetCert(nsIX509Cert 
   }
   else {
     *_cert = nsnull;
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCertTreeDispInfo::GetHostPort(nsAString &aHostPort)
 {
-  aHostPort = mHostWithPort;
+  nsCAutoString hostPort;
+  nsCertOverrideService::GetHostWithPort(mAsciiHost, mPort, hostPort);
+  aHostPort = NS_ConvertUTF8toUTF16(hostPort);
   return NS_OK;
 }
 
 NS_IMPL_ISUPPORTS2(nsCertTree, nsICertTree, nsITreeView)
 
 nsCertTree::nsCertTree() : mTreeArray(NULL)
 {
   mCompareCache.ops = nsnull;
   mNSSComponent = do_GetService(kNSSComponentCID);
   mOverrideService = do_GetService("@mozilla.org/security/certoverride;1");
@@ -382,45 +386,50 @@ MatchingCertOverridesCallback(const nsCe
     (nsCertAndArrayAndPositionAndCounterAndTracker*)aUserData;
   if (!cap)
     return;
 
   nsCertTreeDispInfo *certdi = new nsCertTreeDispInfo;
   if (certdi) {
     if (cap->certai)
       cap->certai->mUsageCount++;
     certdi->mAddonInfo = cap->certai;
     certdi->mTypeOfEntry = nsCertTreeDispInfo::host_port_override;
-    certdi->mHostWithPort = NS_ConvertUTF8toUTF16(aSettings.mHostWithPortUTF8);
+    certdi->mAsciiHost = aSettings.mAsciiHost;
+    certdi->mPort = aSettings.mPort;
     certdi->mOverrideBits = aSettings.mOverrideBits;
     certdi->mIsTemporary = aSettings.mIsTemporary;
     cap->array->InsertElementAt(cap->position, certdi);
     cap->position++;
     cap->counter++;
   }
 
   // this entry is now associated to a displayed cert, remove
   // it from the list of remaining entries
-  cap->tracker->RemoveEntry(aSettings.mHostWithPortUTF8);
+  nsCAutoString hostPort;
+  nsCertOverrideService::GetHostWithPort(aSettings.mAsciiHost, aSettings.mPort, hostPort);
+  cap->tracker->RemoveEntry(hostPort);
 }
 
 // Used to collect a list of the (unique) host:port keys
 // for all stored overrides.
 PR_STATIC_CALLBACK(void)
 CollectAllHostPortOverridesCallback(const nsCertOverride &aSettings,
                                     void *aUserData)
 {
   nsTHashtable<nsCStringHashKey> *collectorTable =
     (nsTHashtable<nsCStringHashKey> *)aUserData;
   if (!collectorTable)
     return;
 
-  collectorTable->PutEntry(aSettings.mHostWithPortUTF8);
+  nsCAutoString hostPort;
+  nsCertOverrideService::GetHostWithPort(aSettings.mAsciiHost, aSettings.mPort, hostPort);
+  collectorTable->PutEntry(hostPort);
 }
 
 struct nsArrayAndPositionAndCounterAndTracker
 {
   nsTArray< nsRefPtr<nsCertTreeDispInfo> > *array;
   int position;
   int counter;
   nsTHashtable<nsCStringHashKey> *tracker;
 };
 
@@ -428,31 +437,34 @@ struct nsArrayAndPositionAndCounterAndTr
 // no associated certificate was found in the NSS database.
 PR_STATIC_CALLBACK(void)
 AddRemaningHostPortOverridesCallback(const nsCertOverride &aSettings,
                                      void *aUserData)
 {
   nsArrayAndPositionAndCounterAndTracker *cap = 
     (nsArrayAndPositionAndCounterAndTracker*)aUserData;
   if (!cap)
     return;
 
-  if (!cap->tracker->GetEntry(aSettings.mHostWithPortUTF8))
+  nsCAutoString hostPort;
+  nsCertOverrideService::GetHostWithPort(aSettings.mAsciiHost, aSettings.mPort, hostPort);
+  if (!cap->tracker->GetEntry(hostPort))
     return;
 
   // This entry is not associated to any stored cert,
   // so we still need to display it.
 
   nsCertTreeDispInfo *certdi = new nsCertTreeDispInfo;
   if (certdi) {
     certdi->mAddonInfo = nsnull;
     certdi->mTypeOfEntry = nsCertTreeDispInfo::host_port_override;
-    certdi->mHostWithPort = NS_ConvertUTF8toUTF16(aSettings.mHostWithPortUTF8);
+    certdi->mAsciiHost = aSettings.mAsciiHost;
+    certdi->mPort = aSettings.mPort;
     certdi->mOverrideBits = aSettings.mOverrideBits;
     certdi->mIsTemporary = aSettings.mIsTemporary;
     cap->array->InsertElementAt(cap->position, certdi);
     cap->position++;
     cap->counter++;
   }
 }
 
 nsresult
 nsCertTree::GetCertsByTypeFromCertList(CERTCertList *aCertList,
@@ -602,21 +614,21 @@ nsCertTree::GetCertsByTypeFromCertList(C
         }
       }
       if (wantThisCert) {
         nsCertTreeDispInfo *certdi = new nsCertTreeDispInfo;
         if (!certdi)
           return NS_ERROR_OUT_OF_MEMORY;
 
         certdi->mAddonInfo = certai;
         certai->mUsageCount++;
         certdi->mTypeOfEntry = nsCertTreeDispInfo::direct_db;
-        // not necessary: certdi->mHostWithPort.Clear();
+        // not necessary: certdi->mAsciiHost.Clear(); certdi->mPort = -1;
         certdi->mOverrideBits = nsCertOverride::ob_None;
         certdi->mIsTemporary = PR_FALSE;
         mDispInfo.InsertElementAt(InsertPosition, certdi);
         ++count;
         ++InsertPosition;
       }
       if (addOverrides && cos) {
         nsCertAndArrayAndPositionAndCounterAndTracker cap;
         cap.certai = certai;
         cap.array = &mDispInfo;
@@ -791,21 +803,21 @@ nsCertTree::DeleteEntryObject(PRUint32 i
       PRInt32 certIndex = cIndex + index - idx;
 
       nsRefPtr<nsCertTreeDispInfo> certdi = mDispInfo.ElementAt(certIndex);
       nsCOMPtr<nsIX509Cert> cert = nsnull;
       if (certdi->mAddonInfo) {
         cert = certdi->mAddonInfo->mCert;
       }
       PRBool canRemoveEntry = PR_FALSE;
 
       if (certdi->mTypeOfEntry == nsCertTreeDispInfo::host_port_override) {
-        mOverrideService->ClearValidityOverride(certdi->mHostWithPort);
+        mOverrideService->ClearValidityOverride(certdi->mAsciiHost, certdi->mPort);
         if (certdi->mAddonInfo) {
           certdi->mAddonInfo->mUsageCount--;
           if (certdi->mAddonInfo->mUsageCount == 0) {
             // The certificate stored in the database is no longer
             // referenced by any other object displayed.
             // That means we no longer need to keep it around
             // and really can remove it.
             canRemoveEntry = PR_TRUE;
           }
         } 
@@ -1231,21 +1243,23 @@ nsCertTree::GetCellText(PRInt32 row, nsI
     // default to classic permanent-trust
     nsCertOverride::OverrideBits ob = nsCertOverride::ob_Untrusted;
     if (certdi->mTypeOfEntry == nsCertTreeDispInfo::host_port_override) {
       ob = certdi->mOverrideBits;
     }
     nsCAutoString temp;
     nsCertOverride::convertBitsToString(ob, temp);
     _retval = NS_ConvertUTF8toUTF16(temp);
   } else if (NS_LITERAL_STRING("sitecol").Equals(colID)) {
     if (certdi->mTypeOfEntry == nsCertTreeDispInfo::host_port_override) {
-      _retval = certdi->mHostWithPort;
+      nsCAutoString hostPort;
+      nsCertOverrideService::GetHostWithPort(certdi->mAsciiHost, certdi->mPort, hostPort);
+      _retval = NS_ConvertUTF8toUTF16(hostPort);
     }
     else {
       _retval = NS_LITERAL_STRING("*");
     }
   } else if (NS_LITERAL_STRING("lifetimecol").Equals(colID)) {
     const char *stringID = 
       (certdi->mIsTemporary) ? "CertExceptionTemporary" : "CertExceptionPermanent";
     rv = mNSSComponent->GetPIPNSSBundleString(stringID, _retval);
   } else if (NS_LITERAL_STRING("typecol").Equals(colID) && cert) {
     nsCOMPtr<nsIX509Cert2> pipCert = do_QueryInterface(cert);
Index: security/manager/ssl/src/nsCertTree.h
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsCertTree.h,v
retrieving revision 1.19
diff -u -1 -0 -d -p -r1.19 nsCertTree.h
--- security/manager/ssl/src/nsCertTree.h	19 Nov 2007 15:32:46 -0000	1.19
+++ security/manager/ssl/src/nsCertTree.h	22 Apr 2008 12:48:09 -0000
@@ -91,21 +91,22 @@ public:
   NS_DECL_NSICERTTREEITEM
 
   nsCertTreeDispInfo();
   nsCertTreeDispInfo(nsCertTreeDispInfo &other);
   virtual ~nsCertTreeDispInfo();
 
   nsRefPtr<nsCertAddonInfo> mAddonInfo;
   enum {
     direct_db, host_port_override
   } mTypeOfEntry;
-  nsString mHostWithPort;
+  nsCString mAsciiHost;
+  PRInt32 mPort;
   nsCertOverride::OverrideBits mOverrideBits;
   PRBool mIsTemporary;
 };
 
 class nsCertTree : public nsICertTree
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSICERTTREE
   NS_DECL_NSITREEVIEW
Index: security/manager/ssl/src/nsNSSIOLayer.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp,v
retrieving revision 1.159
diff -u -1 -0 -d -p -r1.159 nsNSSIOLayer.cpp
--- security/manager/ssl/src/nsNSSIOLayer.cpp	12 Apr 2008 04:47:24 -0000	1.159
+++ security/manager/ssl/src/nsNSSIOLayer.cpp	22 Apr 2008 12:48:13 -0000
@@ -2980,21 +2980,21 @@ nsNSSBadCertHandler(void *arg, PRFileDes
     do_GetService(NS_CERTOVERRIDE_CONTRACTID);
   // it is fine to continue without the nsICertOverrideService
 
   PRUint32 overrideBits = 0; 
 
   if (overrideService)
   {
     PRBool haveOverride;
     PRBool isTemporaryOverride; // we don't care
   
-    nsrv = overrideService->HasMatchingOverride(hostWithPortStringUTF16, 
+    nsrv = overrideService->HasMatchingOverride(hostString, port,
                                                 ix509, 
                                                 &overrideBits,
                                                 &isTemporaryOverride, 
                                                 &haveOverride);
     if (NS_SUCCEEDED(nsrv) && haveOverride) 
     {
       // remove the errors that are already overriden
       remaining_display_errors -= overrideBits;
     }
   }
