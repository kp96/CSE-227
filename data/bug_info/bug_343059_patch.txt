Index: mozilla/mailnews/base/resources/content/phishingDetector.js
===================================================================
RCS file: /cvsroot/mozilla/mailnews/base/resources/content/phishingDetector.js,v
retrieving revision 1.6
diff -u -p -1 -0 -r1.6 phishingDetector.js
--- mozilla/mailnews/base/resources/content/phishingDetector.js	13 Feb 2006 23:01:06 -0000	1.6
+++ mozilla/mailnews/base/resources/content/phishingDetector.js	13 Jul 2006 18:15:10 -0000
@@ -140,21 +140,21 @@ function misMatchedHostWithLinkText(aLin
   // so strip the spaces out (see bug 326082 for details).
   linkNodeText = linkNodeText.replace(/ /g, "");
 
   // only worry about http and https urls
   if (linkNodeText)
   {
     // does the link text look like a http url?
      if (linkNodeText.search(/(^http:|^https:)/) != -1)
      {
        var ioService = Components.classes["@mozilla.org/network/io-service;1"].getService(Components.interfaces.nsIIOService);
-       linkTextURL  = ioService.newURI(linkNodeText, null, null);
+       var linkTextURL  = ioService.newURI(linkNodeText, null, null);
        aLinkTextURL.value = linkTextURL;
        return aHrefURL.host != linkTextURL.host;
      }
   }
 
   return false;
 }
 
 // returns true if the hostName is an IP address
 // if the host name is an obscured IP address, returns the unobscured host
@@ -169,45 +169,44 @@ function hostNameIsIPAddress(aHostName, 
 
   // break the IP address down into individual components.
   var ipComponents = aHostName.split(".");
 
   // if we didn't find at least 4 parts to our IP address it either isn't a numerical IP
   // or it is encoded as a dword
   if (ipComponents.length < 4)
   {
     // Convert to a binary to test for possible DWORD.
     var binaryDword = parseInt(aHostName).toString(2);
-
     if (isNaN(binaryDword))
       return false;
 
     // convert the dword into its component IP parts.
     ipComponents =
     [
       (aHostName >> 24) & 255,
       (aHostName >> 16) & 255,
       (aHostName >>  8) & 255,
       (aHostName & 255)
     ];
   }
   else
   {
-    for (index = 0; index < ipComponents.length; index++)
+    for (index = 0; index < ipComponents.length; ++index)
     {
       // by leaving the radix parameter blank, we can handle IP addresses
       // where one component is hex, another is octal, etc.
       ipComponents[index] = parseInt(ipComponents[index]);
     }
   }
 
   // make sure each part of the IP address is in fact a number
-  for (index = 0; index < ipComponents.length; index++)
+  for (index = 0; index < ipComponents.length; ++index)
     if (isNaN(ipComponents[index])) // if any part of the IP address is not a number, then we can safely return
       return false;
 
   // only set aUnobscuredHostName if we are looking at an IPv4 host name
   var hostName = ipComponents.join(".");
   if (isIPv4HostName(hostName))
   {
     aUnobscuredHostName.value = hostName;
     return true;
   }
@@ -220,21 +219,21 @@ function isIPv4HostName(aHostName)
   var ipv4HostRegExp = new RegExp(/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/);  // IPv4
   // treat 0.0.0.0 as an invalid IP address
   return ipv4HostRegExp.test(aHostName) && aHostName != '0.0.0.0';
 }
 
 // returns true if the user confirms the URL is a scam
 function confirmSuspiciousURL(aPhishingType, aSuspiciousHostName)
 {
   var brandShortName = gBrandBundle.getString("brandShortName");
   var titleMsg = gMessengerBundle.getString("confirmPhishingTitle");
-  var dialogMsg = null;
+  var dialogMsg;
 
   switch (aPhishingType)
   {
     case kPhishingWithIPAddress:
     case kPhishingWithMismatchedHosts:
       dialogMsg = gMessengerBundle.getFormattedString("confirmPhishingUrl" + aPhishingType, [brandShortName, aSuspiciousHostName], 2);
       break;
     default:
       return false;
   }
