Index: mozilla/security/manager/locales/en-US/chrome/pipnss/pipnss.properties
===================================================================
RCS file: /cvsroot/mozilla/security/manager/locales/en-US/chrome/pipnss/pipnss.properties,v
retrieving revision 1.26
diff -u -8 -p -r1.26 pipnss.properties
--- mozilla/security/manager/locales/en-US/chrome/pipnss/pipnss.properties	3 Oct 2007 11:46:09 -0000	1.26
+++ mozilla/security/manager/locales/en-US/chrome/pipnss/pipnss.properties	15 Oct 2007 17:33:27 -0000
@@ -332,17 +332,24 @@ AVATemplate=%S = %S
 
 PSMERR_SSL_Disabled=Can't connect securely because the SSL protocol has been disabled.
 PSMERR_SSL2_Disabled=Can't connect securely because the site uses an older, insecure version of the SSL protocol.
 PSMERR_HostReusedIssuerSerial=You have received an invalid certificate.  Please contact the server administrator or email correspondent and give them the following information:\n\nYour certificate contains the same serial number as another certificate issued by the certificate authority.  Please get a new certificate containing a unique serial number.
 
 SSLConnectionErrorPrefix=An error occurred during a connection to %S.
 
 certErrorIntro=An error occurred during a connection to %S because it uses an invalid security certificate.
-certErrorUntrusted=The certificate is not trusted or its issuer certificate is invalid.
+
+certErrorTrust_SelfSigned=The certificate is not trusted because it is self signed.
+certErrorTrust_UnknownIssuer=The certificate is not trusted because the issuer certificate is unknown.
+certErrorTrust_CaInvalid=The certificate is not trusted because it was issued by an invalid CA certificate.
+certErrorTrust_Issuer=The certificate is not trusted because the issuer certificate is not trusted.
+certErrorTrust_ExpiredIssuer=The certificate is not trusted because the issuer certificate has expired.
+certErrorTrust_Untrusted=The certificate is not trusted.
+
 certErrorMismatch=The certificate is not valid for domain name %S.
 certErrorExpired=The certificate has expired on %S.
 certErrorNotYetValid=The certificate will not be valid until %S.
 
 CertInfoIssuedFor=Issued to:
 CertInfoIssuedBy=Issued by:
 CertInfoValid=Valid
 CertInfoFrom=from
Index: mozilla/security/manager/ssl/public/nsIX509Cert3.idl
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/public/nsIX509Cert3.idl,v
retrieving revision 1.3
diff -u -8 -p -r1.3 nsIX509Cert3.idl
--- mozilla/security/manager/ssl/public/nsIX509Cert3.idl	3 Oct 2007 11:46:12 -0000	1.3
+++ mozilla/security/manager/ssl/public/nsIX509Cert3.idl	15 Oct 2007 17:33:28 -0000
@@ -37,17 +37,17 @@
 
 #include "nsIX509Cert2.idl"
 
 interface nsICertVerificationListener;
 
 /**
  * Extending nsIX509Cert
  */
-[scriptable, uuid(1362ffab-a683-4504-8038-25ce63b45370)]
+[scriptable, uuid(aa67eb02-ccc8-4f55-84da-bcafff9265ae)]
 interface nsIX509Cert3 : nsIX509Cert2 {
 
   /**
    *  Constants for specifying the chain mode when exporting a certificate
    */
   const unsigned long CMS_CHAIN_MODE_CertOnly = 1;
   const unsigned long CMS_CHAIN_MODE_CertChain = 2;
   const unsigned long CMS_CHAIN_MODE_CertChainWithRoot = 3;
@@ -67,16 +67,18 @@ interface nsIX509Cert3 : nsIX509Cert2 {
    *  @param chainMode Whether to include the chain (with or without the root),
                        see CMS_CHAIN_MODE constants.
    *  @param length The number of bytes of the PKCS#7 data.
    *  @param data The bytes representing the PKCS#7 wrapped certificate.
    */
   void exportAsCMS(in unsigned long chainMode,
                    out unsigned long length,
                    [retval, array, size_is(length)] out octet data);
+
+  readonly attribute boolean isSelfSigned;
 };
 
 [scriptable, uuid(2fd0a785-9f2d-4327-8871-8c3e0783891d)]
 interface nsICertVerificationResult : nsISupports {
 
   /**
    *  This interface reflects a container of
    *  verification results. Call will not block.
Index: mozilla/security/manager/ssl/src/nsNSSCertificate.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSCertificate.cpp,v
retrieving revision 1.129
diff -u -8 -p -r1.129 nsNSSCertificate.cpp
--- mozilla/security/manager/ssl/src/nsNSSCertificate.cpp	1 Oct 2007 16:38:24 -0000	1.129
+++ mozilla/security/manager/ssl/src/nsNSSCertificate.cpp	15 Oct 2007 17:33:28 -0000
@@ -215,16 +215,29 @@ nsNSSCertificate::GetCertType(PRUint32 *
   if (mCertType == CERT_TYPE_NOT_YET_INITIALIZED) {
      // only determine cert type once and cache it
      mCertType = getCertType(mCert);
   }
   *aCertType = mCertType;
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsNSSCertificate::GetIsSelfSigned(PRBool *aIsSelfSigned)
+{
+  NS_ENSURE_ARG(aIsSelfSigned);
+
+  nsNSSShutDownPreventionLock locker;
+  if (isAlreadyShutDown())
+    return NS_ERROR_NOT_AVAILABLE;
+
+  *aIsSelfSigned = mCert->isRoot;
+  return NS_OK;
+}
+
 nsresult
 nsNSSCertificate::MarkForPermDeletion()
 {
   nsNSSShutDownPreventionLock locker;
   if (isAlreadyShutDown())
     return NS_ERROR_NOT_AVAILABLE;
 
   // make sure user is logged in to the token
Index: mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp,v
retrieving revision 1.135
diff -u -8 -p -r1.135 nsNSSIOLayer.cpp
--- mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp	11 Oct 2007 19:03:06 -0000	1.135
+++ mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp	15 Oct 2007 17:33:29 -0000
@@ -627,17 +627,20 @@ getErrorMessage(PRInt32 err, const nsStr
   if (NS_SUCCEEDED(rv))
     returnedMessage.Append(explanation);
 
   return NS_OK;
 }
 
 static nsresult
 getInvalidCertErrorMessage(PRUint32 multipleCollectedErrors, 
-                           PRInt32 errorCodeToReport, 
+                           PRErrorCode errorCodeToReport, 
+                           PRErrorCode errTrust, 
+                           PRErrorCode errMismatch, 
+                           PRErrorCode errExpired,
                            const nsString &host,
                            const nsString &hostWithPort,
                            nsIX509Cert* ix509,
                            nsINSSComponent *component,
                            nsString &returnedMessage)
 {
   NS_ENSURE_ARG_POINTER(component);
 
@@ -658,18 +661,49 @@ getInvalidCertErrorMessage(PRUint32 mult
       returnedMessage.Append(NS_LITERAL_STRING("\n"));
     }
   }
 
   if (multipleCollectedErrors & nsICertOverrideService::ERROR_UNTRUSTED)
   {
     params[0] = host.get();
 
+    const char *errorID = nsnull;
+    nsCOMPtr<nsIX509Cert3> cert3 = do_QueryInterface(ix509);
+    if (cert3) {
+      PRBool isSelfSigned;
+      if (NS_SUCCEEDED(cert3->GetIsSelfSigned(&isSelfSigned))
+          && isSelfSigned) {
+        errorID = "certErrorTrust_SelfSigned";
+      }
+    }
+
+    if (!errorID) {
+      switch (errTrust) {
+        case SEC_ERROR_UNKNOWN_ISSUER:
+          errorID = "certErrorTrust_UnknownIssuer";
+          break;
+        case SEC_ERROR_CA_CERT_INVALID:
+          errorID = "certErrorTrust_CaInvalid";
+          break;
+        case SEC_ERROR_UNTRUSTED_ISSUER:
+          errorID = "certErrorTrust_Issuer";
+          break;
+        case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
+          errorID = "certErrorTrust_ExpiredIssuer";
+          break;
+        case SEC_ERROR_UNTRUSTED_CERT:
+        default:
+          errorID = "certErrorTrust_Untrusted";
+          break;
+      }
+    }
+
     nsString formattedString;
-    rv = component->GetPIPNSSBundleString("certErrorUntrusted", 
+    rv = component->GetPIPNSSBundleString(errorID, 
                                           formattedString);
     if (NS_SUCCEEDED(rv))
     {
       returnedMessage.Append(formattedString);
       returnedMessage.Append(NS_LITERAL_STRING("\n"));
     }
   }
 
@@ -824,31 +858,36 @@ nsHandleSSLError(nsNSSSocketInfo *socket
   }
   return rv;
 }
 
 static nsresult
 nsHandleInvalidCertError(nsNSSSocketInfo *socketInfo, 
                          PRUint32 multipleCollectedErrors, 
                          const nsACString &host, 
-                         const nsACString &hostWithPort, 
-                         PRInt32 err,
+                         const nsACString &hostWithPort,
+                         PRErrorCode errorCodeToReport,
+                         PRErrorCode errTrust, 
+                         PRErrorCode errMismatch, 
+                         PRErrorCode errExpired,
                          nsIX509Cert* ix509)
 {
   nsresult rv;
   NS_DEFINE_CID(nssComponentCID, NS_NSSCOMPONENT_CID);
   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(nssComponentCID, &rv));
   if (NS_FAILED(rv))
     return rv;
 
   NS_ConvertASCIItoUTF16 hostU(host);
   NS_ConvertASCIItoUTF16 hostWithPortU(hostWithPort);
 
   nsString formattedString;
-  rv = getInvalidCertErrorMessage(multipleCollectedErrors, err, hostU, hostWithPortU, 
+  rv = getInvalidCertErrorMessage(multipleCollectedErrors, errorCodeToReport,
+                                  errTrust, errMismatch, errExpired,
+                                  hostU, hostWithPortU, 
                                   ix509, nssComponent, formattedString);
 
   // What mechanism is used to inform the user?
   // The highest priority has the "external error reporting" feature,
   // if set, we'll provide the strings to be used by the nsINSSErrorsService
 
   PRBool external = PR_FALSE;
   socketInfo->GetExternalErrorReporting(&external);
@@ -2321,21 +2360,19 @@ nsNSSBadCertHandler(void *arg, PRFileDes
 
   nsCOMPtr<nsIX509Cert> ix509 = static_cast<nsIX509Cert*>(nssCert.get());
 
   SECStatus srv;
   nsresult nsrv;
   PRUint32 collected_errors = 0;
   PRUint32 remaining_display_errors = 0;
 
-  // There may be multiple problems with a cert, but we can only report 
-  // a single error code to the caller. We'll use the first code we see.
-  // However, in our error string we'll use a string that mentions
-  // all of expired/not-yet-valid/domain-mismatch/untrusted.
-  PRErrorCode errorCodeToReport = SECSuccess;
+  PRErrorCode errorCodeTrust = SECSuccess;
+  PRErrorCode errorCodeMismatch = SECSuccess;
+  PRErrorCode errorCodeExpired = SECSuccess;
   
   char *hostname = SSL_RevealURL(sslSocket);
   charCleaner hostnameCleaner(hostname); 
   nsDependentCString hostString(hostname);
 
   PRInt32 port;
   infoObject->GetPort(&port);
 
@@ -2343,17 +2380,17 @@ nsNSSBadCertHandler(void *arg, PRFileDes
   hostWithPortString.AppendLiteral(":");
   hostWithPortString.AppendInt(port);
   
 
   // Check the name field against the desired hostname.
   if (hostname && hostname[0] &&
       CERT_VerifyCertName(peerCert, hostname) != SECSuccess) {
     collected_errors |= nsICertOverrideService::ERROR_MISMATCH;
-    errorCodeToReport = SSL_ERROR_BAD_CERT_DOMAIN;
+    errorCodeMismatch = SSL_ERROR_BAD_CERT_DOMAIN;
   }
 
   {
     PRArenaPool *log_arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     if (!log_arena)    
       return cancel_and_failure(infoObject);
 
     PRArenaPoolCleanerFalseParam log_arena_cleaner(log_arena);
@@ -2375,35 +2412,40 @@ nsNSSBadCertHandler(void *arg, PRFileDes
     // Either it is a failure, which is expected, and we'll process the
     //                         verify log below.
     // Or it is a success, then a domain mismatch is the only 
     //                     possible failure. 
 
     CERTVerifyLogNode *i_node;
     for (i_node = verify_log->head; i_node; i_node = i_node->next)
     {
-      if (errorCodeToReport == SECSuccess) {
-        errorCodeToReport = i_node->error;
-      }
-
       switch (i_node->error)
       {
         case SEC_ERROR_UNKNOWN_ISSUER:
         case SEC_ERROR_CA_CERT_INVALID:
         case SEC_ERROR_UNTRUSTED_ISSUER:
         case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
         case SEC_ERROR_UNTRUSTED_CERT:
           // We group all these errors as "cert not trusted"
           collected_errors |= nsICertOverrideService::ERROR_UNTRUSTED;
+          if (errorCodeTrust == SECSuccess) {
+            errorCodeTrust = i_node->error;
+          }
           break;
         case SSL_ERROR_BAD_CERT_DOMAIN:
           collected_errors |= nsICertOverrideService::ERROR_MISMATCH;
+          if (errorCodeMismatch == SECSuccess) {
+            errorCodeMismatch = i_node->error;
+          }
           break;
         case SEC_ERROR_EXPIRED_CERTIFICATE:
           collected_errors |= nsICertOverrideService::ERROR_TIME;
+          if (errorCodeExpired == SECSuccess) {
+            errorCodeExpired = i_node->error;
+          }
           break;
         default:
           // we are not willing to continue on any other error
           nsHandleSSLError(infoObject, i_node->error);
           return cancel_and_failure(infoObject);
       }
     }
   }
@@ -2482,23 +2524,35 @@ nsNSSBadCertHandler(void *arg, PRFileDes
       if (proxy_bcl) {
         nsIInterfaceRequestor *csi = static_cast<nsIInterfaceRequestor*>(infoObject);
         rv = proxy_bcl->NotifyCertProblem(csi, status, hostWithPortString, 
                                           &suppressMessage);
       }
     }
   }
 
+  // pick the error code to report by priority
+  PRErrorCode errorCodeToReport = SECSuccess;
+  if (remaining_display_errors & nsICertOverrideService::ERROR_UNTRUSTED)
+    errorCodeToReport = errorCodeTrust;
+  else if (remaining_display_errors & nsICertOverrideService::ERROR_MISMATCH)
+    errorCodeToReport = errorCodeMismatch;
+  else if (remaining_display_errors & nsICertOverrideService::ERROR_TIME)
+    errorCodeToReport = errorCodeExpired;
+
   PR_SetError(errorCodeToReport, 0);
   if (!suppressMessage) {
     nsHandleInvalidCertError(infoObject,
                              remaining_display_errors,
                              hostString,
                              hostWithPortString, 
-                             errorCodeToReport, 
+                             errorCodeToReport,
+                             errorCodeTrust,
+                             errorCodeMismatch,
+                             errorCodeExpired,
                              ix509);
   }
   return cancel_and_failure(infoObject);
 }
 
 static PRFileDesc*
 nsSSLIOLayerImportFD(PRFileDesc *fd,
                      nsNSSSocketInfo *infoObject,
