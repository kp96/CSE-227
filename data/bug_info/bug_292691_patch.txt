Index: docshell/base/nsDocShell.cpp
===================================================================
RCS file: /cvsroot/mozilla/docshell/base/nsDocShell.cpp,v
retrieving revision 1.584.6.29.2.4
diff -u -9 -p -r1.584.6.29.2.4 nsDocShell.cpp
--- docshell/base/nsDocShell.cpp	23 Feb 2005 01:03:32 -0000	1.584.6.29.2.4
+++ docshell/base/nsDocShell.cpp	9 May 2005 06:36:04 -0000
@@ -4694,18 +4694,41 @@ nsDocShell::CreateAboutBlankContentViewe
   /* mCreatingDocument should never be true at this point. However, it's
      a theoretical possibility. We want to know about it and make it stop,
      and this sounds like a job for an assertion. */
   NS_ASSERTION(!mCreatingDocument, "infinite(?) loop creating document averted");
   if (mCreatingDocument)
     return NS_ERROR_FAILURE;
 
   mCreatingDocument = PR_TRUE;
 
+  if (mContentViewer) {
+    // We've got a content viewer already. Make sure the user
+    // permits us to discard the current document and replace it
+    // with about:blank. And also ensure we fire the unload events
+    // in the current document.
+
+    PRBool okToUnload;
+    rv = mContentViewer->PermitUnload(&okToUnload);
+
+    if (NS_SUCCEEDED(rv) && !okToUnload) {
+      // The user chose not to unload the page, interrupt the load.
+      return NS_ERROR_FAILURE;
+    }
+
+    // Notify the current document that it is about to be unloaded!!
+    //
+    // It is important to fire the unload() notification *before* any state
+    // is changed within the DocShell - otherwise, javascript will get the
+    // wrong information :-(
+    //
+    (void) FireUnloadNotification();
+  }
+
   // one helper factory, please
   nsCOMPtr<nsICategoryManager> catMan(do_GetService(NS_CATEGORYMANAGER_CONTRACTID));
   if (!catMan)
     return NS_ERROR_FAILURE;
 
   nsXPIDLCString contractId;
   rv = catMan->GetCategoryEntry("Gecko-Content-Viewers", "text/html", getter_Copies(contractId));
   if (NS_FAILED(rv))
     return rv;
@@ -6644,18 +6667,36 @@ nsDocShell::LoadHistoryEntry(nsISHEntry 
     NS_ENSURE_TRUE(hEntry, NS_ERROR_FAILURE);
 
     NS_ENSURE_SUCCESS(hEntry->GetURI(getter_AddRefs(uri)), NS_ERROR_FAILURE);
     NS_ENSURE_SUCCESS(aEntry->GetReferrerURI(getter_AddRefs(referrerURI)),
                       NS_ERROR_FAILURE);
     NS_ENSURE_SUCCESS(aEntry->GetPostData(getter_AddRefs(postData)),
                       NS_ERROR_FAILURE);
     NS_ENSURE_SUCCESS(aEntry->GetContentType(contentType), NS_ERROR_FAILURE);
 
+    PRBool isJavaScript, isData;
+    if ((NS_SUCCEEDED(uri->SchemeIs("javascript", &isJavaScript)) &&
+         isJavaScript) ||
+        (NS_SUCCEEDED(uri->SchemeIs("data", &isData)) && isData)) {
+        // We're loading a javascript: or data: URL from session
+        // history. Replace the current document with about:blank to
+        // prevent anything from the current document from leaking
+        // into any JavaScript code in the URL.
+        rv = CreateAboutBlankContentViewer();
+
+        if (NS_FAILED(rv)) {
+            // The creation of the intermittent about:blank content
+            // viewer failed for some reason (potentially because the
+            // user prevented it). Interrupt the history load.
+            return NS_OK;
+        }
+    }
+
     /* If there is a valid postdata *and* the user pressed
      * reload or shift-reload, take user's permission before we  
      * repost the data to the server.
      */
     if ((aLoadType & LOAD_CMD_RELOAD) && postData) {
 
       nsCOMPtr<nsIPrompt> prompter;
       PRBool repost;
       nsCOMPtr<nsIStringBundle> stringBundle;
