Index: dom/src/base/nsJSEnvironment.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/base/nsJSEnvironment.cpp,v
retrieving revision 1.191
diff -u -9 -p -r1.191 nsJSEnvironment.cpp
--- dom/src/base/nsJSEnvironment.cpp	17 Apr 2003 20:20:57 -0000	1.191
+++ dom/src/base/nsJSEnvironment.cpp	8 May 2003 22:40:51 -0000
@@ -611,18 +611,73 @@ nsJSContext::EvaluateStringWithValue(con
 
   // Pop here, after JS_ValueToString and any other possible evaluation.
   if (NS_FAILED(stack->Pop(nsnull)))
     rv = NS_ERROR_FAILURE;
 
   return rv;
 
 }
 
+// Helper function to convert a jsval to an nsAString, and set
+// exception flags if the conversion fails.
+static nsresult
+JSValueToAString(JSContext *cx, jsval val, nsAString *result,
+                 PRBool *isUndefined)
+{
+  if (isUndefined) {
+    *isUndefined = JSVAL_IS_VOID(val);
+  }
+
+  if (!result) {
+    return NS_OK;
+  }
+
+  JSString* jsstring = ::JS_ValueToString(cx, val);
+  if (jsstring) {
+    result->Assign(NS_REINTERPRET_CAST(const PRUnichar*,
+                                       ::JS_GetStringChars(jsstring)),
+                   ::JS_GetStringLength(jsstring));
+  } else {
+    result->Truncate();
+
+    // We failed to convert val to a string. We're either OOM, or the
+    // security manager denied access to .toString(), or somesuch, on
+    // an object. Treat this case as if the result was undefined.
+
+    if (isUndefined) {
+      *isUndefined = PR_TRUE;
+    }
+
+    if (!::JS_IsExceptionPending(cx)) {
+      // JS_ValueToString() returned null w/o an exception
+      // pending. That means we're OOM.
+
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    // We've got a pending exception. Tell XPConnect's current native
+    // call context (if any) about this exception so that it doesn't
+    // keep going as if nothing happened.
+
+    nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID()));
+
+    if (xpc) {
+      nsCOMPtr<nsIXPCNativeCallContext> nccx;
+      xpc->GetCurrentNativeCallContext(getter_AddRefs(nccx));
+      if (nccx) {
+        nccx->SetExceptionWasThrown(PR_TRUE);
+      }
+    }
+  }
+
+  return NS_OK;
+}
+
 NS_IMETHODIMP
 nsJSContext::EvaluateString(const nsAString& aScript,
                             void *aScopeObject,
                             nsIPrincipal *aPrincipal,
                             const char *aURL,
                             PRUint32 aLineNo,
                             const char* aVersion,
                             nsAString& aRetValue,
                             PRBool* aIsUndefined)
@@ -714,30 +769,19 @@ nsJSContext::EvaluateString(const nsAStr
         ::JS_SetVersion(mContext, oldVersion);
     }
   }
 
   // Whew!  Finally done with these manually ref-counted things.
   JSPRINCIPALS_DROP(mContext, jsprin);
 
   // If all went well, convert val to a string (XXXbe unless undefined?).
   if (ok) {
-    if (aIsUndefined) {
-      *aIsUndefined = JSVAL_IS_VOID(val);
-    }
-
-    JSString* jsstring = ::JS_ValueToString(mContext, val);
-    if (jsstring) {
-      aRetValue.Assign(NS_REINTERPRET_CAST(const PRUnichar*,
-                                           ::JS_GetStringChars(jsstring)),
-                       ::JS_GetStringLength(jsstring));
-    } else {
-      rv = NS_ERROR_OUT_OF_MEMORY;
-    }
+    rv = JSValueToAString(mContext, val, &aRetValue, aIsUndefined);
   }
   else {
     if (aIsUndefined) {
       *aIsUndefined = PR_TRUE;
     }
 
     aRetValue.Truncate();
   }
 
@@ -863,32 +907,20 @@ nsJSContext::ExecuteScript(void* aScript
   mTerminationFunc = nsnull;
   ok = ::JS_ExecuteScript(mContext,
                           (JSObject*) aScopeObject,
                           (JSScript*) ::JS_GetPrivate(mContext,
                                                     (JSObject*)aScriptObject),
                           &val);
 
   if (ok) {
     // If all went well, convert val to a string (XXXbe unless undefined?).
-    if (aIsUndefined) {
-      *aIsUndefined = JSVAL_IS_VOID(val);
-    }
 
-    if (aRetValue) {
-      JSString* jsstring = ::JS_ValueToString(mContext, val);
-      if (jsstring) {
-        aRetValue->Assign(NS_REINTERPRET_CAST(const PRUnichar*,
-                                              ::JS_GetStringChars(jsstring)),
-                          ::JS_GetStringLength(jsstring));
-      } else {
-        rv = NS_ERROR_OUT_OF_MEMORY;
-      }
-    }
+    rv = JSValueToAString(mContext, val, aRetValue, aIsUndefined);
   } else {
     if (aIsUndefined) {
       *aIsUndefined = PR_TRUE;
     }
 
     if (aRetValue) {
       aRetValue->Truncate();
     }
   }
Index: dom/src/build/nsDOMFactory.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/build/nsDOMFactory.cpp,v
retrieving revision 1.77
diff -u -9 -p -r1.77 nsDOMFactory.cpp
--- dom/src/build/nsDOMFactory.cpp	12 Apr 2003 04:22:16 -0000	1.77
+++ dom/src/build/nsDOMFactory.cpp	8 May 2003 22:40:53 -0000
@@ -227,20 +227,20 @@ nsDOMSOFactory::GetExternalClassInfoInst
 NS_IMETHODIMP
 nsDOMSOFactory::Observe(nsISupports *aSubject, 
                         const char *aTopic,
                         const PRUnichar *someData)
 {
   if (!nsCRT::strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID)) {
 #ifdef MOZ_XUL
     // Flush the XUL cache since it holds JS roots, and we're about to
     // start the final GC.
-    static NS_DEFINE_CID(kXULPrototypeCacheCID, NS_XULPROTOTYPECACHE_CID);
-    nsCOMPtr<nsIXULPrototypeCache> cache(do_GetService(kXULPrototypeCacheCID));
+    nsCOMPtr<nsIXULPrototypeCache> cache =
+      do_GetService("@mozilla.org/xul/xul-prototype-cache;1");
 
     if (cache)
       cache->Flush();
 #endif
 
     nsCOMPtr<nsIThreadJSContextStack> stack =
       do_GetService("@mozilla.org/js/xpc/ContextStack;1");
 
     if (stack) {
Index: dom/src/jsurl/nsJSProtocolHandler.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/jsurl/nsJSProtocolHandler.cpp,v
retrieving revision 1.89
diff -u -9 -p -r1.89 nsJSProtocolHandler.cpp
--- dom/src/jsurl/nsJSProtocolHandler.cpp	15 Mar 2003 01:02:25 -0000	1.89
+++ dom/src/jsurl/nsJSProtocolHandler.cpp	8 May 2003 22:40:53 -0000
@@ -60,18 +61,19 @@
 #include "nsIStringStream.h"
 #include "nsIWindowMediator.h"
 #include "nsIDOMWindowInternal.h"
 #include "nsIDOMDocument.h"
 #include "nsIJSConsoleService.h"
 #include "nsIConsoleService.h"
 #include "nsXPIDLString.h"
 #include "prprf.h"
 #include "nsEscape.h"
+#include "nsIJSContextStack.h"
 
 static NS_DEFINE_CID(kSimpleURICID, NS_SIMPLEURI_CID);
 static NS_DEFINE_CID(kWindowMediatorCID, NS_WINDOWMEDIATOR_CID);
 
 
 
 class nsJSThunk : public nsIInputStream
 {
 public:
@@ -151,49 +154,75 @@ nsresult nsJSThunk::EvaluateScript(nsICh
     rv = globalOwner->GetScriptGlobalObject(getter_AddRefs(global));
 
     NS_ASSERTION(NS_SUCCEEDED(rv) && global,
                  "Unable to get an nsIScriptGlobalObject from the "
                  "ScriptGlobalObjectOwner!");
     if (NS_FAILED(rv) || !global) {
         return NS_ERROR_FAILURE;
     }
 
+    JSObject *globalJSObject = global->GetGlobalJSObject();
+
     nsCOMPtr<nsIDOMWindow> domWindow(do_QueryInterface(global, &rv));
     if (NS_FAILED(rv)) {
         return NS_ERROR_FAILURE;
     }
 
     // If mURI is just "javascript:", we bring up the JavaScript console
     // and return NS_ERROR_DOM_RETVAL_UNDEFINED.
     if (script.IsEmpty()) {
         rv = BringUpConsole(domWindow);
         if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
         return NS_ERROR_DOM_RETVAL_UNDEFINED;
     }
 
     // Now get the DOM Document.  Accessing the document will create one
     // if necessary.  So, basically, this call ensures that a document gets
     // created -- if necessary.
     nsCOMPtr<nsIDOMDocument> doc;
-
     rv = domWindow->GetDocument(getter_AddRefs(doc));
     NS_ASSERTION(doc, "No DOMDocument!");
     if (NS_FAILED(rv)) {
         return NS_ERROR_FAILURE;
     }
 
     nsCOMPtr<nsIScriptContext> scriptContext;
     rv = global->GetContext(getter_AddRefs(scriptContext));
     if (NS_FAILED(rv))
         return rv;
 
     if (!scriptContext) return NS_ERROR_FAILURE;
 
+    // Grab a context to evaluate the javascript: URL on. If the
+    // evaluation of a javascript: URL is caused by some running
+    // script, use the context of the running script. If no JS is
+    // running, use the context of the window where the javascript:
+    // URL is being evaluated.
+    nsCOMPtr<nsIScriptContext> evalContext;
+
+    nsCOMPtr<nsIJSContextStack> stack = 
+        do_GetService("@mozilla.org/js/xpc/ContextStack;1");
+    if (stack) {
+        JSContext *cx;
+        if (NS_SUCCEEDED(stack->Peek(&cx)) && cx &&
+            (::JS_GetOptions(cx) & JSOPTION_PRIVATE_IS_NSISUPPORTS)) {
+            nsISupports *supports =
+                NS_STATIC_CAST(nsISupports*, ::JS_GetContextPrivate(cx));
+
+            evalContext = do_QueryInterface(supports);
+        }
+    }
+
+    if (!evalContext) {
+        // No JS on the stack, use the window's context.
+        evalContext = scriptContext;
+    }
+
     // Unescape the script
     NS_UnescapeURL(script);
 
     // Get the url.
     nsCAutoString url;
     rv = mURI->GetSpec(url);
     if (NS_FAILED(rv)) return rv;
 
     // Get principal of code for execution
@@ -215,19 +244,19 @@ nsresult nsJSThunk::EvaluateScript(nsICh
             return NS_ERROR_FAILURE;
 
         //-- Don't run if the script principal is different from the
         //   principal of the context, with two exceptions: we allow
         //   the script to run if the script has the system principal
         //   or the context is about:blank.
         nsCOMPtr<nsIPrincipal> objectPrincipal;
         rv = securityManager->GetObjectPrincipal(
                                 (JSContext*)scriptContext->GetNativeContext(),
-                                global->GetGlobalJSObject(),
+                                globalJSObject,
                                 getter_AddRefs(objectPrincipal));
         if (NS_FAILED(rv))
             return rv;
 
         PRBool equals = PR_FALSE;
         if ((NS_FAILED(objectPrincipal->Equals(principal, &equals)) || !equals)) {
             // If the principals aren't equal
 
             nsCOMPtr<nsIPrincipal> systemPrincipal;
@@ -261,29 +290,27 @@ nsresult nsJSThunk::EvaluateScript(nsICh
                                                    getter_AddRefs(principal));
         if (NS_FAILED(rv) || !principal) {
             return NS_ERROR_FAILURE;
         }
     }
 
     // Finally, we have everything needed to evaluate the expression.
     nsString result;
     PRBool bIsUndefined;
-    {
-        NS_ConvertUTF8toUCS2 scriptString(script);
-        rv = scriptContext->EvaluateString(scriptString,
-                                           nsnull,      // obj
-                                           principal,
-                                           url.get(),   // url
-                                           1,           // line no
-                                           nsnull,
-                                           result,
-                                           &bIsUndefined);
-    }
+
+    rv = evalContext->EvaluateString(NS_ConvertUTF8toUCS2(script),
+                                     globalJSObject, // obj
+                                     principal,
+                                     url.get(),      // url
+                                     1,              // line no
+                                     nsnull,
+                                     result,
+                                     &bIsUndefined);
 
     if (NS_FAILED(rv)) {
         rv = NS_ERROR_MALFORMED_URI;
     }
     else if (bIsUndefined) {
         rv = NS_ERROR_DOM_RETVAL_UNDEFINED;
     }
     else {
         // NS_NewStringInputStream calls ToNewCString
Index: caps/src/nsScriptSecurityManager.cpp
===================================================================
RCS file: /cvsroot/mozilla/caps/src/nsScriptSecurityManager.cpp,v
retrieving revision 1.198
diff -u -9 -p -r1.198 nsScriptSecurityManager.cpp
--- caps/src/nsScriptSecurityManager.cpp	17 Apr 2003 20:21:00 -0000	1.198
+++ caps/src/nsScriptSecurityManager.cpp	8 May 2003 22:40:53 -0000
@@ -2041,19 +2041,19 @@ nsScriptSecurityManager::SavePrincipal(n
 
     nsCOMPtr<nsIPrefService> prefService(do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
     NS_ENSURE_SUCCESS(rv, rv);
     return prefService->SavePrefFile(nsnull);
 }
 
 ///////////////// Capabilities API /////////////////////
 NS_IMETHODIMP
 nsScriptSecurityManager::IsCapabilityEnabled(const char *capability,
-                                                 PRBool *result)
+                                             PRBool *result)
 {
     nsresult rv;
     JSStackFrame *fp = nsnull;
     JSContext *cx = GetCurrentJSContext();
     fp = cx ? JS_FrameIterator(cx, &fp) : nsnull;
     if (!fp)
     {
         // No script code on stack. Allow execution.
         *result = PR_TRUE;
@@ -2091,21 +2091,24 @@ nsScriptSecurityManager::IsCapabilityEna
         void *annotation = JS_GetFrameAnnotation(cx, fp);
         rv = principal->IsCapabilityEnabled(capability, annotation, result);
         if (NS_FAILED(rv)) return rv;
         if (*result)
             return NS_OK;
     } while ((fp = JS_FrameIterator(cx, &fp)) != nsnull);
 
     if (!previousPrincipal)
     {
-        // No principals on the stack, all native code.  Allow execution.
-        *result = PR_TRUE;
+        // No principals on the stack, all native code.  Allow
+        // execution if the subject principal is the system principal.
+
+        return SubjectPrincipalIsSystem(result);
     }
+
     return NS_OK;
 }
 
 PRBool
 nsScriptSecurityManager::CheckConfirmDialog(JSContext* cx, nsIPrincipal* aPrincipal,
                                             PRBool *checkValue)
 {
     nsresult rv;
     *checkValue = PR_FALSE;
