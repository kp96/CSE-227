Index: mozilla/security/manager/ssl/src/nsKeygenHandler.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsKeygenHandler.cpp,v
retrieving revision 1.44
diff -u -1 -0 -p -r1.44 nsKeygenHandler.cpp
--- mozilla/security/manager/ssl/src/nsKeygenHandler.cpp	10 Oct 2007 02:10:00 -0000	1.44
+++ mozilla/security/manager/ssl/src/nsKeygenHandler.cpp	10 Oct 2007 03:50:45 -0000
@@ -63,28 +63,20 @@ extern "C" {
 #include "nsCRT.h"
 #include "nsITokenDialogs.h"
 #include "nsIGenKeypairInfoDlg.h"
 #include "nsNSSShutDown.h"
 
 //These defines are taken from the PKCS#11 spec
 #define CKM_RSA_PKCS_KEY_PAIR_GEN     0x00000000
 #define CKM_DH_PKCS_KEY_PAIR_GEN      0x00000020
 #define CKM_DSA_KEY_PAIR_GEN          0x00000010
 
-//All possible key size choices.
-static SECKeySizeChoiceInfo SECKeySizeChoiceList[] = {
-    { nsnull, 2048 },
-    { nsnull, 1024 },
-    { nsnull, 0 }, 
-};
-
-
 DERTemplate CERTSubjectPublicKeyInfoTemplate[] = {
     { DER_SEQUENCE,
           0, nsnull, sizeof(CERTSubjectPublicKeyInfo) },
     { DER_INLINE,
           offsetof(CERTSubjectPublicKeyInfo,algorithm),
           SECAlgorithmIDTemplate, },
     { DER_BIT_STRING,
           offsetof(CERTSubjectPublicKeyInfo,subjectPublicKey), },
     { 0, }
 };
@@ -331,39 +323,32 @@ nsKeygenFormProcessor::Create(nsISupport
   if (NS_SUCCEEDED(rv)) {
     rv = formProc->QueryInterface(aIID, aResult);
   }
   return rv;
 }
 
 nsresult
 nsKeygenFormProcessor::Init()
 {
   nsresult rv;
-  nsAutoString str;
 
-  if (SECKeySizeChoiceList[0].name != NULL)
-    return NS_OK;
-
-  // Get the key strings //
   nsCOMPtr<nsINSSComponent> nssComponent;
   nssComponent = do_GetService(kNSSComponentCID, &rv);
   if (NS_FAILED(rv))
     return rv;
 
-  // XXXbz this leaks the strings through shutdown.  There's got to be
-  // a better way to do this!  Of course that would involve having SOME
-  // shutdown code somewhere here.
-  nssComponent->GetPIPNSSBundleString("HighGrade", str);
-  SECKeySizeChoiceList[0].name = ToNewUnicode(str);
+  // Init possible key size choices.
+  nssComponent->GetPIPNSSBundleString("HighGrade", mSECKeySizeChoiceList[0].name);
+  mSECKeySizeChoiceList[0].size = 2048;
 
-  nssComponent->GetPIPNSSBundleString("MediumGrade", str);
-  SECKeySizeChoiceList[1].name = ToNewUnicode(str);
+  nssComponent->GetPIPNSSBundleString("MediumGrade", mSECKeySizeChoiceList[1].name);
+  mSECKeySizeChoiceList[1].size = 1024;
 
   return NS_OK;
 }
 
 nsresult
 nsKeygenFormProcessor::GetSlot(PRUint32 aMechanism, PK11SlotInfo** aSlot)
 {
   return GetSlotWithMechanism(aMechanism,m_ctx,aSlot);
 }
 
@@ -535,32 +520,30 @@ nsKeygenFormProcessor::GetPublicKey(nsAS
     SECKEYPrivateKey *privateKey = nsnull;
     SECKEYPublicKey *publicKey = nsnull;
     CERTSubjectPublicKeyInfo *spkInfo = nsnull;
     PRArenaPool *arena = nsnull;
     SECStatus sec_rv = SECFailure;
     SECItem spkiItem;
     SECItem pkacItem;
     SECItem signedItem;
     CERTPublicKeyAndChallenge pkac;
     pkac.challenge.data = nsnull;
-    SECKeySizeChoiceInfo *choice = SECKeySizeChoiceList;
     nsIGeneratingKeypairInfoDialogs * dialogs;
     nsKeygenThread *KeygenRunnable = 0;
     nsCOMPtr<nsIKeygenThread> runnable;
 
     // Get the key size //
-    while (choice->name) {
-        if (aValue.Equals(choice->name)) {
-            keysize = choice->size;
+    for (size_t i = 0; i < number_of_key_size_choices; ++i) {
+        if (aValue.Equals(mSECKeySizeChoiceList[i].name)) {
+            keysize = mSECKeySizeChoiceList[i].size;
             break;
         }
-        choice++;
     }
     if (!keysize) {
         goto loser;
     }
 
     arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     if (!arena) {
         goto loser;
     }
 
@@ -579,21 +562,21 @@ nsKeygenFormProcessor::GetPublicKey(nsAS
         type = dsaKey;
         keyGenMechanism = CKM_DSA_KEY_PAIR_GEN;
         if (strcmp(keyparamsString, "null") == 0)
             goto loser;
         str = keyparamsString;
         do {
             end = strchr(str, ',');
             if (end != nsnull)
                 *end = '\0';
             primeBits = pqg_prime_bits(str);
-            if (choice->size == primeBits)
+            if (keysize == primeBits)
                 goto found_match;
             str = end + 1;
         } while (end != nsnull);
         goto loser;
 found_match:
         pqgParams = decode_pqg_params(str);
     } else if (aKeyType.LowerCaseEqualsLiteral("ec")) {
         keyparamsString = ToNewCString(aKeyParams);
         if (!keyparamsString) {
             rv = NS_ERROR_OUT_OF_MEMORY;
@@ -858,18 +841,19 @@ nsKeygenFormProcessor::ProcessValue(nsID
 
   return rv; 
 } 
 
 NS_METHOD nsKeygenFormProcessor::ProvideContent(const nsAString& aFormType, 
 						nsStringArray& aContent, 
 						nsAString& aAttribute) 
 { 
   if (Compare(aFormType, NS_LITERAL_STRING("SELECT"), 
     nsCaseInsensitiveStringComparator()) == 0) {
-    for (SECKeySizeChoiceInfo* choice = SECKeySizeChoiceList; choice && choice->name; ++choice) {
-      aContent.AppendString(nsDependentString(choice->name));
+
+    for (size_t i = 0; i < number_of_key_size_choices; ++i) {
+      aContent.AppendString(mSECKeySizeChoiceList[i].name);
     }
     aAttribute.AssignLiteral("-mozilla-keygen");
   }
   return NS_OK;
 } 
 
Index: mozilla/security/manager/ssl/src/nsKeygenHandler.h
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsKeygenHandler.h,v
retrieving revision 1.10
diff -u -1 -0 -p -r1.10 nsKeygenHandler.h
--- mozilla/security/manager/ssl/src/nsKeygenHandler.h	10 Oct 2007 02:10:00 -0000	1.10
+++ mozilla/security/manager/ssl/src/nsKeygenHandler.h	10 Oct 2007 03:50:45 -0000
@@ -35,25 +35,20 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef _NSKEYGENHANDLER_H_
 #define _NSKEYGENHANDLER_H_
 // Form Processor 
 #include "nsIFormProcessor.h" 
 
-typedef struct SECKeySizeChoiceInfoStr {
-    PRUnichar *name;
-    int size;
-} SECKeySizeChoiceInfo;
-
 nsresult GetSlotWithMechanism(PRUint32 mechanism,
                               nsIInterfaceRequestor *ctx,
                               PK11SlotInfo **retSlot);
 
 #define DEFAULT_RSA_KEYGEN_PE 65537L
 #define DEFAULT_RSA_KEYGEN_ALG SEC_OID_PKCS1_MD5_WITH_RSA_ENCRYPTION
 
 SECKEYECParams *decode_ec_params(char *curve);
 
 class nsKeygenFormProcessor : public nsIFormProcessor { 
@@ -74,13 +69,21 @@ public: 
   static NS_METHOD Create(nsISupports* aOuter, const nsIID& aIID, void* *aResult);
 
 protected:
   nsresult GetPublicKey(nsAString& aValue, nsAString& aChallenge, 
 			nsAFlatString& akeyType, nsAString& aOutPublicKey,
 			nsAString& aPqg);
   nsresult GetSlot(PRUint32 aMechanism, PK11SlotInfo** aSlot);
 private:
   nsCOMPtr<nsIInterfaceRequestor> m_ctx;
 
-}; 
+  typedef struct SECKeySizeChoiceInfoStr {
+      nsString name;
+      int size;
+  } SECKeySizeChoiceInfo;
+
+  enum { number_of_key_size_choices = 2 };
+
+  SECKeySizeChoiceInfo mSECKeySizeChoiceList[number_of_key_size_choices];
+};
 
 #endif //_NSKEYGENHANDLER_H_
