Index: mozilla/security/manager/ssl/src/nsNSSCallbacks.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSCallbacks.cpp,v
retrieving revision 1.48
diff -u -2 -5 -p -r1.48 nsNSSCallbacks.cpp
--- mozilla/security/manager/ssl/src/nsNSSCallbacks.cpp	30 Mar 2007 22:44:22 -0000	1.48
+++ mozilla/security/manager/ssl/src/nsNSSCallbacks.cpp	22 May 2007 22:34:59 -0000
@@ -790,101 +790,93 @@ PK11PasswordPrompt(PK11SlotInfo* slot, P
 void PR_CALLBACK HandshakeCallback(PRFileDesc* fd, void* client_data) {
   nsNSSShutDownPreventionLock locker;
   PRInt32 sslStatus;
   char* signer = nsnull;
   char* cipherName = nsnull;
   PRInt32 keyLength;
   nsresult rv;
   PRInt32 encryptBits;
 
   if (SECSuccess != SSL_SecurityStatus(fd, &sslStatus, &cipherName, &keyLength,
                                        &encryptBits, &signer, nsnull)) {
     return;
   }
 
   PRInt32 secStatus;
   if (sslStatus == SSL_SECURITY_STATUS_OFF)
     secStatus = nsIWebProgressListener::STATE_IS_BROKEN;
   else if (encryptBits >= 90)
     secStatus = (nsIWebProgressListener::STATE_IS_SECURE |
                  nsIWebProgressListener::STATE_SECURE_HIGH);
   else
     secStatus = (nsIWebProgressListener::STATE_IS_SECURE |
                  nsIWebProgressListener::STATE_SECURE_LOW);
 
   CERTCertificate *peerCert = SSL_PeerCertificate(fd);
-  char* caName = CERT_GetOrgName(&peerCert->issuer);
+  const char* caName = nsnull; // caName is a pointer only, no ownership
+  char* certOrgName = CERT_GetOrgName(&peerCert->issuer);
   CERT_DestroyCertificate(peerCert);
-  if (!caName) {
-    caName = signer;
-  }
+  caName = certOrgName ? certOrgName : signer;
 
+  const char* verisignName = "Verisign, Inc.";
   // If the CA name is RSA Data Security, then change the name to the real
   // name of the company i.e. VeriSign, Inc.
   if (nsCRT::strcmp((const char*)caName, "RSA Data Security, Inc.") == 0) {
-    // In this case, caName != signer since the logic implies signer
-    // would be at minimal "O=RSA Data Security, Inc" because caName
-    // is what comes after to O=.  So we're OK just freeing this memory
-    // without checking to see if it's equal to signer;
-    NS_ASSERTION(caName != signer, "caName was equal to caName when it shouldn't be");
-    PR_Free(caName);
-    caName = PL_strdup("Verisign, Inc.");
+    caName = verisignName;
   }
 
   nsAutoString shortDesc;
   const PRUnichar* formatStrings[1] = { ToNewUnicode(NS_ConvertUTF8toUTF16(caName)) };
   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
   if (NS_SUCCEEDED(rv)) {
     rv = nssComponent->PIPBundleFormatStringFromName("SignedBy",
                                                    formatStrings, 1,
                                                    shortDesc);
 
     nsMemory::Free(NS_CONST_CAST(PRUnichar*, formatStrings[0]));
 
     nsNSSSocketInfo* infoObject = (nsNSSSocketInfo*) fd->higher->secret;
     infoObject->SetSecurityState(secStatus);
     infoObject->SetShortSecurityDescription(shortDesc.get());
 
     /* Set the SSL Status information */
     nsCOMPtr<nsSSLStatus> status = new nsSSLStatus();
 
     CERTCertificate *serverCert = SSL_PeerCertificate(fd);
     if (serverCert) {
       status->mServerCert = new nsNSSCertificate(serverCert);
       CERT_DestroyCertificate(serverCert);
     }
 
     status->mKeyLength = keyLength;
     status->mSecretKeyLength = encryptBits;
     status->mCipherName.Adopt(cipherName);
 
     infoObject->SetSSLStatus(status);
   }
 
-  if (caName != signer) {
-    PR_Free(caName);
-  }
+  PR_FREEIF(certOrgName);
   PR_Free(signer);
 }
 
 SECStatus PR_CALLBACK AuthCertificateCallback(void* client_data, PRFileDesc* fd,
                                               PRBool checksig, PRBool isServer) {
   nsNSSShutDownPreventionLock locker;
 
   // first the default action
   SECStatus rv = SSL_AuthCertificate(CERT_GetDefaultCertDB(), fd, checksig, isServer);
 
   // We want to remember the CA certs in the temp db, so that the application can find the
   // complete chain at any time it might need it.
   // But we keep only those CA certs in the temp db, that we didn't already know.
   
   if (SECSuccess == rv) {
     CERTCertificate *serverCert = SSL_PeerCertificate(fd);
     if (serverCert) {
       CERTCertList *certList = CERT_GetCertChainFromCert(serverCert, PR_Now(), certUsageSSLCA);
 
       nsCOMPtr<nsINSSComponent> nssComponent;
       
       for (CERTCertListNode *node = CERT_LIST_HEAD(certList);
            !CERT_LIST_END(node, certList);
            node = CERT_LIST_NEXT(node)) {
 
