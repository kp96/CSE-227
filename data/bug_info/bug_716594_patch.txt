# HG changeset patch
# Parent 9a230265bad5fb7d2c4ead3c9e4173081d8e90a7
Bug 716594 - Switch nsBinaryInputStream::ReadBytes back to using the fallible allocator because it correctly checks for allocation errors and streams are untrusted input we should try to work with, r?dbaron

diff --git a/xpcom/io/nsBinaryStream.cpp b/xpcom/io/nsBinaryStream.cpp
--- a/xpcom/io/nsBinaryStream.cpp
+++ b/xpcom/io/nsBinaryStream.cpp
@@ -49,17 +49,16 @@
  *
  * @See nsIBinaryInputStream
  * @See nsIBinaryOutputStream
  */
 #include <string.h>
 #include "nsBinaryStream.h"
 #include "nsCRT.h"
 #include "nsIStreamBufferAccess.h"
-#include "nsMemory.h"
 #include "prlong.h"
 #include "nsString.h"
 #include "nsISerializable.h"
 #include "nsIClassInfo.h"
 #include "nsComponentManagerUtils.h"
 #include "nsIURI.h" // for NS_IURI_IID
 
 NS_IMPL_ISUPPORTS3(nsBinaryOutputStream, nsIObjectOutputStream, nsIBinaryOutputStream, nsIOutputStream)
@@ -215,26 +214,26 @@ nsBinaryOutputStream::WriteWStringZ(cons
 #ifdef IS_BIG_ENDIAN
     rv = WriteBytes(reinterpret_cast<const char*>(aString), byteCount);
 #else
     // XXX use WriteSegments here to avoid copy!
     PRUnichar *copy, temp[64];
     if (length <= 64) {
         copy = temp;
     } else {
-        copy = reinterpret_cast<PRUnichar*>(nsMemory::Alloc(byteCount));
+        copy = reinterpret_cast<PRUnichar*>(moz_malloc(byteCount));
         if (!copy)
             return NS_ERROR_OUT_OF_MEMORY;
     }
     NS_ASSERTION((PRUptrdiff(aString) & 0x1) == 0, "aString not properly aligned");
     for (PRUint32 i = 0; i < length; i++)
         copy[i] = NS_SWAP16(aString[i]);
     rv = WriteBytes(reinterpret_cast<const char*>(copy), byteCount);
     if (copy != temp)
-        nsMemory::Free(copy);
+        moz_free(copy);
 #endif
 
     return rv;
 }
 
 NS_IMETHODIMP
 nsBinaryOutputStream::WriteUtf8Z(const PRUnichar* aString)
 {
@@ -720,27 +719,27 @@ nsBinaryInputStream::ReadString(nsAStrin
 
 NS_IMETHODIMP
 nsBinaryInputStream::ReadBytes(PRUint32 aLength, char* *_rval)
 {
     nsresult rv;
     PRUint32 bytesRead;
     char* s;
 
-    s = reinterpret_cast<char*>(nsMemory::Alloc(aLength));
+    s = reinterpret_cast<char*>(moz_malloc(aLength));
     if (!s)
         return NS_ERROR_OUT_OF_MEMORY;
 
     rv = Read(s, aLength, &bytesRead);
     if (NS_FAILED(rv)) {
-        nsMemory::Free(s);
+        moz_free(s);
         return rv;
     }
     if (bytesRead != aLength) {
-        nsMemory::Free(s);
+        moz_free(s);
         return NS_ERROR_FAILURE;
     }
 
     *_rval = s;
     return NS_OK;
 }
 
 NS_IMETHODIMP
