Index: mail/base/content/phishingDetector.js
===================================================================
RCS file: /cvsroot/mozilla/mail/base/content/phishingDetector.js,v
retrieving revision 1.32
diff -u -p -9 -r1.32 phishingDetector.js
--- mail/base/content/phishingDetector.js	21 Aug 2007 18:19:15 -0000	1.32
+++ mail/base/content/phishingDetector.js	11 Jan 2008 21:13:38 -0000
@@ -73,23 +73,23 @@ var gPhishingDetector = {
       // Register tables
       // XXX: move table names to a pref that we originally will download
       // from the provider (need to workout protocol details)
       this.mPhishingWarden.registerWhiteTable("goog-white-exp");
       this.mPhishingWarden.registerBlackTable("goog-phish-sha128");
 
       // Download/update lists if we're in non-enhanced mode
       this.mPhishingWarden.maybeToggleUpdateChecking();  
     } catch (ex) { dump('unable to create the phishing warden: ' + ex + '\n');}
-    
+
     this.mCheckForIPAddresses = gPrefBranch.getBoolPref("mail.phishing.detection.ipaddresses");
     this.mCheckForMismatchedHosts = gPrefBranch.getBoolPref("mail.phishing.detection.mismatched_hosts");
   },
-  
+
   /**
    * Analyzes the urls contained in the currently loaded message in the message pane, looking for
    * phishing URLs.
    * Assumes the message has finished loading in the message pane (i.e. OnMsgParsed has fired).
    * 
    * @param aUrl nsIURI for the message being analyzed.
    *
    * @return asynchronously calls gMessageNotificationBar.setPhishingMsg if the message
    *         is identified as a scam.         
@@ -105,28 +105,28 @@ var gPhishingDetector = {
       folder = aUrl.folder;
       if (folder.server.type == 'nntp' || folder.server.type == 'rss')
         return;
     } catch (ex) {}
 
     // extract the link nodes in the message and analyze them, looking for suspicious URLs...
     var linkNodes = document.getElementById('messagepane').contentDocument.links;
     for (var index = 0; index < linkNodes.length; index++)
       this.analyzeUrl(linkNodes[index].href, gatherTextUnder(linkNodes[index]));
-      
+
     // extract the action urls associated with any form elements in the message and analyze them.
     var formNodes = document.getElementById('messagepane').contentDocument.getElementsByTagName("form");
     for (index = 0; index < formNodes.length; index++)
     {
       if (formNodes[index].action)
         this.analyzeUrl(formNodes[index].action);
     }
   },
-  
+
   /** 
    * Analyze the url contained in aLinkNode for phishing attacks. If a phishing URL is found,
    * 
    * @param aHref the url to be analyzed
    * @param aLinkText (optional) user visible link text associated with aHref in case
    *        we are dealing with a link node.
    * @return asynchronously calls gMessageNotificationBar.setPhishingMsg if the link node
    *         contains a phishing URL.
    */
@@ -145,19 +145,23 @@ var gPhishingDetector = {
     // only check for phishing urls if the url is an http or https link.
     // this prevents us from flagging imap and other internally handled urls
     if (hrefURL.schemeIs('http') || hrefURL.schemeIs('https'))
     {
       var linkTextURL = {};
       var unobscuredHostName = {};
       unobscuredHostName.value = hrefURL.host;
 
       // The link is not suspicious if the visible text is the same as the URL,
-      // even if the URL is an IP address.
+      // even if the URL is an IP address. URLs are commonly surrounded by
+      // < > or "" (RFC2396E) - so strip those from the link text before comparing.
+      if (aLinkText)
+        aLinkText = aLinkText.replace(/^<(.+)>$|^"(.+)"$/, "$1$2");
+
       var failsStaticTests = (aLinkText != aUrl) &&
          ((this.mCheckForIPAddresses && this.hostNameIsIPAddress(hrefURL.host, unobscuredHostName) &&
            !this.isLocalIPAddress(unobscuredHostName)) ||
           (this.mCheckForMismatchedHosts && aLinkText &&
            this.misMatchedHostWithLinkText(hrefURL, aLinkText, linkTextURL)));
 
       // Lookup the url against our local list. We want to do this even if the url fails our static
       // test checks because the url might be in the white list.
       if (this.mPhishingWarden)
@@ -181,43 +185,43 @@ var gPhishingDetector = {
     // for urls in the whitelist, do nothing
     // for all other urls, fall back to the static tests
     if (aMsgURI == GetLoadedMessage())
     {
       if (aLocalListStatus == 0 /* PROT_ListWarden.IN_BLACKLIST */ ||
           (aLocalListStatus == 2 /* PROT_ListWarden.PROT_ListWarden.NOT_FOUND */ && aFailsStaticTests))
         gMessageNotificationBar.setPhishingMsg();
     }
   },
-  
+
   /**
    * Looks up the report phishing url for the current phishing provider, appends aPhishingURL to the url,
    * and loads it in the default browser where the user can submit the url as a phish.
    * @param aPhishingURL the url we want to report back as a phishing attack
    */
    reportPhishingURL: function(aPhishingURL)
    {
      var appContext = Components.classes["@mozilla.org/phishingprotection/application;1"]
                        .getService().wrappedJSObject;
      var reportUrl = appContext.getReportPhishingURL();
      if (reportUrl)
      {
        reportUrl += "&url=" + encodeURIComponent(aPhishingURL);
        // now send the url to the default browser
-       
+
        var ioService = Components.classes["@mozilla.org/network/io-service;1"]
                        .getService(Components.interfaces.nsIIOService);
        var uri = ioService.newURI(reportUrl, null, null);
        var protocolSvc = Components.classes["@mozilla.org/uriloader/external-protocol-service;1"]
                          .getService(Components.interfaces.nsIExternalProtocolService);
        protocolSvc.loadUrl(uri);
      }
    },   
-  
+
   /**
    * Private helper method to determine if the link node contains a user visible
    * url with a host name that differs from the actual href the user would get taken to.
    * i.e. <a href="http://myevilsite.com">http://mozilla.org</a>
    * 
    * @return true if aHrefURL.host matches the host of the link node text. 
    * @return aLinkTextURL the nsIURI for the link node text
    */
   misMatchedHostWithLinkText: function(aHrefURL, aLinkNodeText, aLinkTextURL)
@@ -235,19 +239,19 @@ var gPhishingDetector = {
          var ioService = Components.classes["@mozilla.org/network/io-service;1"].getService(Components.interfaces.nsIIOService);
          aLinkTextURL.value = ioService.newURI(aLinkNodeText, null, null);
          // compare hosts, but ignore possible www. prefix
          return !(aHrefURL.host.replace(/^www\./, "") == aLinkTextURL.value.host.replace(/^www\./, ""));
        }
     }
 
     return false;
   },
-  
+
   /**
    * Private helper method to determine if aHostName is an obscured IP address 
    * @return unobscured host name (if there is one)
    * @return true if aHostName is an IP address
    */
   hostNameIsIPAddress: function(aHostName, aUnobscuredHostName)
   {
     // TODO: Add Support for IPv6
     var index;
@@ -293,44 +297,45 @@ var gPhishingDetector = {
 
     // only set aUnobscuredHostName if we are looking at an IPv4 host name
     if (this.isIPv4HostName(hostName))
     {
       aUnobscuredHostName.value = hostName;
       return true;
     }
     return false;
   },
-  
+
   /**
    * Private helper method.
    * @return true if aHostName is an IPv4 address
    */
   isIPv4HostName: function(aHostName)
   {
     var ipv4HostRegExp = new RegExp(/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/);  // IPv4
     // treat 0.0.0.0 as an invalid IP address
     return ipv4HostRegExp.test(aHostName) && aHostName != '0.0.0.0';
   },
-  
+
   /** 
    * Private helper method.
    * @return true if unobscuredHostName is a local IP address.
    */
   isLocalIPAddress: function(unobscuredHostName)
   {
     var ipComponents = unobscuredHostName.value.split(".");
 
     return ipComponents[0] == 10 ||
+           ipComponents[0] == 127 || // loopback address
            (ipComponents[0] == 192 && ipComponents[1] == 168) ||
            (ipComponents[0] == 169 && ipComponents[1] == 254) ||
            (ipComponents[0] == 172 && ipComponents[1] >= 16 && ipComponents[1] < 32);
   },
-  
+
   /** 
    * If the current message has been identified as an email scam, prompts the user with a warning
    * before allowing the link click to be processed. The warning prompt includes the unobscured host name
    * of the http(s) url the user clicked on.
    *
    * @param aUrl the url 
    * @return true if the link should be allowed to load
    */
   warnOnSuspiciousLinkClick: function(aUrl)
@@ -340,27 +345,27 @@ var gPhishingDetector = {
       return true;
 
     var ioService = Components.classes["@mozilla.org/network/io-service;1"]
                       .getService(Components.interfaces.nsIIOService);
     var hrefURL;
     // make sure relative link urls don't make us bail out
     try {
       hrefURL = ioService.newURI(aUrl, null, null);
     } catch(ex) { return false; }
-    
+
     // only prompt for http and https urls
     if (hrefURL.schemeIs('http') || hrefURL.schemeIs('https'))
     {
       // unobscure the host name in case it's an encoded ip address..
       var unobscuredHostName = {};
       unobscuredHostName.value = hrefURL.host;
       this.hostNameIsIPAddress(hrefURL.host, unobscuredHostName);
-      
+
       var brandShortName = gBrandBundle.getString("brandShortName");
       var titleMsg = gMessengerBundle.getString("confirmPhishingTitle");
       var dialogMsg = gMessengerBundle.getFormattedString("confirmPhishingUrl", 
                         [brandShortName, unobscuredHostName.value], 2);
 
       const nsIPS = Components.interfaces.nsIPromptService;
       var promptService = Components.classes["@mozilla.org/embedcomp/prompt-service;1"].getService(nsIPS);
       return !promptService.confirmEx(window, titleMsg, dialogMsg, nsIPS.STD_YES_NO_BUTTONS + nsIPS.BUTTON_POS_1_DEFAULT, 
                                      "", "", "", "", {}); /* the yes button is in position 0 */
