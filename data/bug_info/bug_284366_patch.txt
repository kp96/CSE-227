? !
? .mozconfig.db
? .mozconfig.opt
? error.log
? firefox-debug
? firefox-opt
? path
? smpatch
? smpatch.2
? security/manager/ssl/src/convertit
Index: dom/public/nsIDOMClassInfo.h
===================================================================
RCS file: /cvsroot/mozilla/dom/public/nsIDOMClassInfo.h,v
retrieving revision 1.40
diff -u -r1.40 nsIDOMClassInfo.h
--- dom/public/nsIDOMClassInfo.h	7 Feb 2004 12:39:14 -0000	1.40
+++ dom/public/nsIDOMClassInfo.h	13 May 2005 17:58:10 -0000
@@ -286,6 +286,9 @@
   eDOMClassInfo_SVGAnimatedString_id,
   eDOMClassInfo_SVGImageElement_id,
 #endif //MOZ_SVG
+
+  // New Event classes
+  eDOMClassInfo_SmartCardEvent_id,
   
   // This one better be the last one in this list
   eDOMClassInfoIDCount
Index: dom/public/idl/base/nsIDOMCrypto.idl
===================================================================
RCS file: /cvsroot/mozilla/dom/public/idl/base/nsIDOMCrypto.idl,v
retrieving revision 1.5.2.1
diff -u -r1.5.2.1 nsIDOMCrypto.idl
--- dom/public/idl/base/nsIDOMCrypto.idl	16 Apr 2004 01:09:34 -0000	1.5.2.1
+++ dom/public/idl/base/nsIDOMCrypto.idl	13 May 2005 17:58:10 -0000
@@ -39,10 +39,11 @@
 
 #include "domstubs.idl"
 
-[scriptable, uuid(33276f5d-3499-4ab9-acea-d85a9fceeccd)]
+[scriptable, uuid(d2b675a5-f05b-4172-bac2-24cc39ffd398)]
 interface nsIDOMCrypto : nsISupports
 {
   readonly attribute DOMString        version;
+  attribute boolean         enableSmartCardEvents;
 
   nsIDOMCRMFObject          generateCRMFRequest(/* ... */);
   DOMString                 importUserCertificates(in DOMString nickname,
Index: dom/public/idl/events/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/dom/public/idl/events/Makefile.in,v
retrieving revision 1.15
diff -u -r1.15 Makefile.in
--- dom/public/idl/events/Makefile.in	24 Apr 2003 21:32:05 -0000	1.15
+++ dom/public/idl/events/Makefile.in	13 May 2005 17:58:10 -0000
@@ -49,6 +49,7 @@
 	nsIDOMMutationEvent.idl			\
 	nsIDOMNSUIEvent.idl			\
 	nsIDOMPopupBlockedEvent.idl		\
+	nsIDOMSmartCardEvent.idl		\
 	$(NULL)
 
 include $(topsrcdir)/config/rules.mk
Index: dom/public/idl/events/nsIDOMSmartCardEvent.idl
===================================================================
RCS file: dom/public/idl/events/nsIDOMSmartCardEvent.idl
diff -N dom/public/idl/events/nsIDOMSmartCardEvent.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ dom/public/idl/events/nsIDOMSmartCardEvent.idl	13 May 2005 17:58:10 -0000
@@ -0,0 +1,46 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: NPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Netscape Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/NPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is 
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Bob Relyea <rrelyea@redhat.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the NPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the NPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMEvent.idl"
+
+[scriptable, uuid(52bdc7ca-a934-4a40-a2e2-ac83a70b4019)]
+interface nsIDOMSmartCardEvent : nsIDOMEvent
+{
+  readonly attribute DOMString   tokenName;
+  [noscript] void Init(in nsIDOMEvent event);
+};
Index: dom/src/base/nsDOMClassInfo.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/base/nsDOMClassInfo.cpp,v
retrieving revision 1.203.6.15.2.5
diff -u -r1.203.6.15.2.5 nsDOMClassInfo.cpp
--- dom/src/base/nsDOMClassInfo.cpp	14 Apr 2005 23:17:23 -0000	1.203.6.15.2.5
+++ dom/src/base/nsDOMClassInfo.cpp	13 May 2005 17:58:12 -0000
@@ -198,6 +198,7 @@
 #include "nsIDOMMouseEvent.h"
 #include "nsIDOMPopupBlockedEvent.h"
 #include "nsIDOMMutationEvent.h"
+#include "nsIDOMSmartCardEvent.h"
 #include "nsIDOMNSDocumentStyle.h"
 #include "nsIDOMDocumentRange.h"
 #include "nsIDOMDocumentTraversal.h"
@@ -878,6 +879,9 @@
   NS_DEFINE_CLASSINFO_DATA(SVGImageElement, nsElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)  
 #endif  
+
+  NS_DEFINE_CLASSINFO_DATA(SmartCardEvent, nsDOMGenericSH,
+                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
 };
 
 nsIXPConnect *nsDOMClassInfo::sXPConnect = nsnull;
@@ -1594,6 +1598,10 @@
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMNSUIEvent)
   DOM_CLASSINFO_MAP_END
 
+  DOM_CLASSINFO_MAP_BEGIN(SmartCardEvent, nsIDOMSmartCardEvent)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMSmartCardEvent)
+  DOM_CLASSINFO_MAP_END
+
   DOM_CLASSINFO_MAP_BEGIN(MutationEvent, nsIDOMMutationEvent)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMMutationEvent)
   DOM_CLASSINFO_MAP_END
Index: dom/src/base/nsGlobalWindow.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/base/nsGlobalWindow.cpp,v
retrieving revision 1.652.2.2.2.37.2.5
diff -u -r1.652.2.2.2.37.2.5 nsGlobalWindow.cpp
--- dom/src/base/nsGlobalWindow.cpp	6 Apr 2005 08:33:10 -0000	1.652.2.2.2.37.2.5
+++ dom/src/base/nsGlobalWindow.cpp	13 May 2005 17:58:14 -0000
@@ -509,6 +509,11 @@
 
     // Let go of the cached principal since we no longer need it.
     mDocumentPrincipal = nsnull;
+
+    // clear smartcard events, our document has gone away.
+    if (mCrypto) {
+	mCrypto->SetEnableSmartCardEvents(PR_FALSE);
+    }
   }
 
   if (mFirstDocumentLoad) {
Index: security/manager/pki/resources/content/certManager.js
===================================================================
RCS file: /cvsroot/mozilla/security/manager/pki/resources/content/certManager.js,v
retrieving revision 1.42
diff -u -r1.42 certManager.js
--- security/manager/pki/resources/content/certManager.js	16 Oct 2003 15:26:28 -0000	1.42
+++ security/manager/pki/resources/content/certManager.js	13 May 2005 17:58:30 -0000
@@ -48,6 +48,10 @@
 
 function LoadCerts()
 {
+  window.crypto.enableSmartCardEvents = true;
+  document.addEventListener("smartcard-insert", onSmartCardChange, false);
+  document.addEventListener("smartcard-remove", onSmartCardChange, false);
+
   certdb = Components.classes[nsX509CertDB].getService(nsIX509CertDB);
   var certcache = Components.classes[nsNSSCertCache].createInstance(nsINSSCertCache);
   
@@ -432,6 +436,23 @@
   }
 }
 
+function onSmartCardChange()
+{
+  var certcache = Components.classes[nsNSSCertCache].createInstance(nsINSSCertCache);
+  // We've change the state of the smart cards inserted or removed
+  // that means the available certs may have changed. Update the display
+  certcache.cacheAllCerts();
+  userTreeView.loadCertsFromCache(certcache, nsIX509Cert.USER_CERT);
+  userTreeView.selection.clearSelection();
+  caTreeView.loadCertsFromCache(certcache, nsIX509Cert.CA_CERT);
+  caTreeView.selection.clearSelection();
+  serverTreeView.loadCertsFromCache(certcache, nsIX509Cert.SERVER_CERT);
+  serverTreeView.selection.clearSelection();
+  emailTreeView.loadCertsFromCache(certcache, nsIX509Cert.EMAIL_CERT);
+  emailTreeView.selection.clearSelection();
+
+}
+
 function addEmailCert()
 {
   var bundle = srGetStrBundle("chrome://pippki/locale/pippki.properties");
Index: security/manager/pki/resources/content/device_manager.js
===================================================================
RCS file: /cvsroot/mozilla/security/manager/pki/resources/content/device_manager.js,v
retrieving revision 1.17
diff -u -r1.17 device_manager.js
--- security/manager/pki/resources/content/device_manager.js	16 Oct 2003 15:26:28 -0000	1.17
+++ security/manager/pki/resources/content/device_manager.js	13 May 2005 17:58:30 -0000
@@ -41,8 +41,18 @@
 {
   bundle = srGetStrBundle("chrome://pippki/locale/pippki.properties");
   secmoddb = Components.classes[nsPKCS11ModuleDB].getService(nsIPKCS11ModuleDB);
+  window.crypto.enableSmartCardEvents = true;
+  document.addEventListener("smartcard-insert", onSmartCardChange, false);
+  document.addEventListener("smartcard-remove", onSmartCardChange, false);
+
+  RefreshDeviceList();
+}
+
+function RefreshDeviceList()
+{
   var modules = secmoddb.listModules();
   var done = false;
+
   try {
     modules.isDone();
   } catch (e) { done = true; }
@@ -215,20 +225,33 @@
       info_list.removeChild(info_list.firstChild);
 }
 
+function ClearDeviceList()
+{
+  // Remove the existing listed modules so that refresh doesn't 
+  // display the module that just changed.
+  var device_list = document.getElementById("device_list");
+  while (device_list.firstChild)
+    device_list.removeChild(device_list.firstChild);
+}
+
+
 // show a list of info about a slot
 function showSlotInfo()
 {
+  var present = true;
   ClearInfoList();
   switch (selected_slot.status) {
    case nsIPKCS11Slot.SLOT_DISABLED:
      AddInfoRow(bundle.GetStringFromName("devinfo_status"), 
                 bundle.GetStringFromName("devinfo_stat_disabled"), 
                 "tok_status");
+     present = false;
      break;
    case nsIPKCS11Slot.SLOT_NOT_PRESENT:
      AddInfoRow(bundle.GetStringFromName("devinfo_status"), 
                 bundle.GetStringFromName("devinfo_stat_notpresent"), 
                 "tok_status");
+     present = false;
      break;
    case nsIPKCS11Slot.SLOT_UNINITIALIZED:
      AddInfoRow(bundle.GetStringFromName("devinfo_status"), 
@@ -259,6 +282,9 @@
              selected_slot.HWVersion, "slot_hwv");
   AddInfoRow(bundle.GetStringFromName("devinfo_fwversion"),
              selected_slot.FWVersion, "slot_fwv");
+  if (present) {
+     showTokenInfo();
+  }
 }
 
 function showModuleInfo()
@@ -338,10 +364,8 @@
 {
   window.open("load_device.xul", "loaddevice", 
               "chrome,centerscreen,modal");
-  var device_list = document.getElementById("device_list");
-  while (device_list.firstChild)
-    device_list.removeChild(device_list.firstChild);
-  LoadModules();
+  ClearDeviceList();
+  RefreshDeviceList();
 }
 
 function doUnload()
@@ -349,13 +373,23 @@
   getSelectedItem();
   if (selected_module) {
     pkcs11.deletemodule(selected_module.name);
-    var device_list = document.getElementById("device_list");
-    while (device_list.firstChild)
-      device_list.removeChild(device_list.firstChild);
-    LoadModules();
+    ClearDeviceList();
+    RefreshDeviceList();
   }
 }
 
+// handle card insertion and removal
+function onSmartCardChange()
+{
+  var tree = document.getElementById('device_tree');
+  var index = tree.currentIndex;
+  tree.currentIndex = 0;
+  ClearDeviceList();
+  RefreshDeviceList();
+  tree.currentIndex = index;
+  enableButtons();
+}
+
 function changePassword()
 {
   getSelectedItem();
@@ -395,8 +429,8 @@
 
 function showTokenInfo()
 {
-  ClearInfoList();
-  getSelectedToken();
+  //ClearInfoList();
+  var selected_token = selected_slot.getToken();
   AddInfoRow(bundle.GetStringFromName("devinfo_label"), 
              selected_token.tokenLabel, "tok_label");
   AddInfoRow(bundle.GetStringFromName("devinfo_manID"),
@@ -431,9 +465,7 @@
   secmoddb.toggleFIPSMode();
   //Remove the existing listed modules so that re-fresh doesn't 
   //display the module that just changed.
-  var device_list = document.getElementById("device_list");
-  while (device_list.firstChild)
-    device_list.removeChild(device_list.firstChild);
+  ClearDeviceList();
 
-  LoadModules();
+  RefreshDeviceList();
 }
Index: security/manager/ssl/src/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/Makefile.in,v
retrieving revision 1.59
diff -u -r1.59 Makefile.in
--- security/manager/ssl/src/Makefile.in	7 Jan 2004 13:36:51 -0000	1.59
+++ security/manager/ssl/src/Makefile.in	13 May 2005 17:58:30 -0000
@@ -82,6 +82,9 @@
   nsCRLManager.cpp \
   nsNSSShutDown.cpp \
   nsNTLMAuthModule.cpp \
+  nsNSSEvent.cpp \
+  nsSmartCardMonitor.cpp \
+  nsSmartCardEvent.cpp \
 	$(NULL)
 
 ifdef MOZ_XUL
Index: security/manager/ssl/src/nsCrypto.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsCrypto.cpp,v
retrieving revision 1.44.6.2
diff -u -r1.44.6.2 nsCrypto.cpp
--- security/manager/ssl/src/nsCrypto.cpp	11 Aug 2004 02:59:53 -0000	1.44.6.2
+++ security/manager/ssl/src/nsCrypto.cpp	13 May 2005 17:58:30 -0000
@@ -42,8 +42,6 @@
 #include "nsIScriptContext.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIXPConnect.h"
-#include "nsIEventQueueService.h"
-#include "nsIEventQueue.h"
 #include "nsIRunnable.h"
 #include "nsIWindowWatcher.h"
 #include "nsIPrompt.h"
@@ -127,17 +125,6 @@
   nsKeyGenType      keyGenType; /* What type of key gen are we doing.*/
 } nsKeyPairInfo;
 
-//
-// This is the class we'll use to run the keygen done code
-// as an nsIRunnable object;
-//
-struct CryptoRunnableEvent : PLEvent {
-  CryptoRunnableEvent(nsIRunnable* runnable);
-  ~CryptoRunnableEvent();
-
-   nsIRunnable* mRunnable;
-};
-
 
 //This class is just used to pass arguments
 //to the nsCryptoRunnable event.
@@ -215,34 +202,19 @@
 NS_IMPL_ADDREF(nsPkcs11)
 NS_IMPL_RELEASE(nsPkcs11)
 
-// QueryInterface implementation for nsCryptoRunnable
-NS_INTERFACE_MAP_BEGIN(nsCryptoRunnable)
-  NS_INTERFACE_MAP_ENTRY(nsIRunnable)
-  NS_INTERFACE_MAP_ENTRY(nsISupports)
-NS_INTERFACE_MAP_END
-
-NS_IMPL_ADDREF(nsCryptoRunnable)
-NS_IMPL_RELEASE(nsCryptoRunnable)
-
-// QueryInterface implementation for nsP12Runnable
-NS_INTERFACE_MAP_BEGIN(nsP12Runnable)
-  NS_INTERFACE_MAP_ENTRY(nsIRunnable)
-  NS_INTERFACE_MAP_ENTRY(nsISupports)
-NS_INTERFACE_MAP_END_THREADSAFE
-
-NS_IMPL_THREADSAFE_ADDREF(nsP12Runnable)
-NS_IMPL_THREADSAFE_RELEASE(nsP12Runnable)
+// ISupports implementation for nsCryptoRunnable
+NS_IMPL_ISUPPORTS1(nsCryptoRunnable, nsIRunnable);
 
-NS_INTERFACE_MAP_BEGIN(nsCryptoRunArgs)
-  NS_INTERFACE_MAP_ENTRY(nsISupports)
-NS_INTERFACE_MAP_END_THREADSAFE
+// ISupports implementation for nsP12Runnable
+NS_IMPL_ISUPPORTS1(nsP12Runnable, nsIRunnable);
 
-NS_IMPL_THREADSAFE_ADDREF(nsCryptoRunArgs)
-NS_IMPL_THREADSAFE_RELEASE(nsCryptoRunArgs)
+// ISupports implementation for nsCryptoRunArgs
+NS_IMPL_ISUPPORTS0(nsCryptoRunArgs);
 
 static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
 
-nsCrypto::nsCrypto()
+nsCrypto::nsCrypto() :
+  mEnableSmartCardEvents(PR_FALSE)
 {
 }
 
@@ -250,22 +222,31 @@
 {
 }
 
-//Grab the UI event queue so that we can post some events to it.
-nsIEventQueue* 
-nsCrypto::GetUIEventQueue()
+NS_IMETHODIMP
+nsCrypto::SetEnableSmartCardEvents(PRBool aEnable)
 {
   nsresult rv;
-  nsCOMPtr<nsIEventQueueService> service = 
-                        do_GetService(NS_EVENTQUEUESERVICE_CONTRACTID, &rv);
-  if (NS_FAILED(rv)) 
-    return nsnull;
-  
-  nsIEventQueue* result = nsnull;
-  rv = service->GetThreadEventQueue(NS_UI_THREAD, &result);
-  if (NS_FAILED(rv)) 
-    return nsnull;
-  
-  return result;
+
+  // this has the side effect of starting the nssComponent (and initializing
+  // NSS) even if it isn't already going. Starting the nssComponent is a 
+  // prerequisite for getting smartCard events.
+  if (aEnable) {
+    nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
+  }
+
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  mEnableSmartCardEvents = aEnable;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsCrypto::GetEnableSmartCardEvents(PRBool *aEnable)
+{
+  *aEnable = mEnableSmartCardEvents;
+  return NS_OK;
 }
 
 //These next few functions are based on implementation in
@@ -1406,6 +1387,7 @@
   nsFreeCertReqMessages(certReqMsgs,numRequests);
   return nsnull;;
 }
+
                                                  
 //The top level method which is a member of nsIDOMCrypto
 //for generate a base64 encoded CRMF request.
@@ -1621,41 +1603,11 @@
   if (!cryptoRunnable)
     return NS_ERROR_OUT_OF_MEMORY;
 
-  CryptoRunnableEvent *runnable = new CryptoRunnableEvent(cryptoRunnable);
-  if (!runnable) {
+  nsresult rv = nsNSSEventPostToUIEventQueue(cryptoRunnable);
+  if (NS_FAILED(rv))
     delete cryptoRunnable;
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-  nsCOMPtr<nsIEventQueue>uiQueue = dont_AddRef(GetUIEventQueue());
-  uiQueue->PostEvent(runnable);
-  return NS_OK;
-}
-
-//A wrapper for PLEvent that we can use to post
-//our nsIRunnable Events.
-static void PR_CALLBACK
-handleCryptoRunnableEvent(CryptoRunnableEvent* aEvent)
-{
-  aEvent->mRunnable->Run();
-}
-
-static void PR_CALLBACK
-destroyCryptoRunnableEvent(CryptoRunnableEvent* aEvent)
-{
-  delete aEvent;
-}
 
-CryptoRunnableEvent::CryptoRunnableEvent(nsIRunnable* runnable)
-  :  mRunnable(runnable)
-{
-  NS_ADDREF(mRunnable);
-  PL_InitEvent(this, nsnull, PLHandleEventProc(handleCryptoRunnableEvent),
-               PLDestroyEventProc(&destroyCryptoRunnableEvent));
-}
-
-CryptoRunnableEvent::~CryptoRunnableEvent()
-{
-  NS_RELEASE(mRunnable);
+  return rv;
 }
 
 
@@ -2025,7 +1977,6 @@
     // later.
     nsCOMPtr<nsIRunnable> p12Runnable = new nsP12Runnable(certArr, numResponses,
                                                           token);
-    CryptoRunnableEvent *runnable;
     if (!p12Runnable) {
       rv = NS_ERROR_FAILURE;
       goto loser;
@@ -2036,13 +1987,9 @@
     // memory on the way out.
     certArr = nsnull;
 
-    runnable = new CryptoRunnableEvent(p12Runnable);
-    if (!runnable) {
-      rv = NS_ERROR_FAILURE;
+    rv = nsNSSEventPostToUIEventQueue(p12Runnable);
+    if (NS_FAILED(rv))
       goto loser;
-    }
-    nsCOMPtr<nsIEventQueue>uiQueue = dont_AddRef(GetUIEventQueue());
-    uiQueue->PostEvent(runnable);
   }
 
  loser:
@@ -2605,6 +2552,11 @@
   PRInt32 modType;
   SECStatus srv = SECMOD_DeleteModule(modName, &modType);
   if (srv == SECSuccess) {
+    SECMODModule *module = SECMOD_FindModule(modName);
+    if (module) {
+      nssComponent->ShutdownSmartCardThread(module);
+      SECMOD_DestroyModule(module);
+    }
     if (modType == SECMOD_EXTERNAL) {
       nssComponent->GetPIPNSSBundleString("DelModuleExtSuccess", errorMessage);
       *aReturn = JS_OK_DEL_EXTERNAL_MOD;
@@ -2674,6 +2626,14 @@
   PRUint32 cipherFlags = SECMOD_PubCipherFlagstoInternal(aCipherFlags);
   SECStatus srv = SECMOD_AddNewModule(moduleName, fullPath, 
                                       mechFlags, cipherFlags);
+  if (srv == SECSuccess) {
+    SECMODModule *module = SECMOD_FindModule(moduleName);
+    if (module) {
+      nssComponent->LaunchSmartCardThread(module);
+      SECMOD_DestroyModule(module);
+    }
+  }
+
   nsMemory::Free(moduleName);
   nsMemory::Free(fullPath);
 
Index: security/manager/ssl/src/nsCrypto.h
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsCrypto.h,v
retrieving revision 1.7
diff -u -r1.7 nsCrypto.h
--- security/manager/ssl/src/nsCrypto.h	22 Aug 2003 03:06:49 -0000	1.7
+++ security/manager/ssl/src/nsCrypto.h	13 May 2005 17:58:30 -0000
@@ -26,9 +26,12 @@
 #include "nsIDOMCRMFObject.h"
 #include "nsIDOMCrypto.h"
 #include "nsIDOMPkcs11.h"
+#include "nsIRunnable.h"
 #include "nsString.h"
+#include "nsNSSEvent.h"
 #include "jsapi.h"
 #include "nsIPrincipal.h"
+#include "plevent.h"
 
 #define NS_CRYPTO_CLASSNAME "Crypto JavaScript Class"
 #define NS_CRYPTO_CID \
@@ -42,7 +45,6 @@
 
 class nsIPSMComponent;
 class nsIDOMScriptObjectFactory;
-class nsIEventQueue;
 
 
 class nsCRMFObject : public nsIDOMCRMFObject
@@ -73,8 +75,10 @@
   NS_DECL_ISUPPORTS
   NS_DECL_NSIDOMCRYPTO
 
+private:
   static nsIPrincipal* GetScriptPrincipal(JSContext *cx);
-  static nsIEventQueue* GetUIEventQueue();
+
+  PRBool mEnableSmartCardEvents;
 };
 
 class nsPkcs11 : public nsIDOMPkcs11
@@ -88,6 +92,17 @@
 
 };
 
+//
+// This is the class we'll use to post ui events
+//
+struct CryptoRunnableEvent : PLEvent {
+  CryptoRunnableEvent(nsIRunnable* runnable);
+  ~CryptoRunnableEvent();
+
+   nsIRunnable* mRunnable;
+};
+
+
 #endif //_nsCrypto_h_
 
 
Index: security/manager/ssl/src/nsNSSComponent.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSComponent.cpp,v
retrieving revision 1.114.2.1
diff -u -r1.114.2.1 nsNSSComponent.cpp
--- security/manager/ssl/src/nsNSSComponent.cpp	22 Apr 2004 19:48:30 -0000	1.114.2.1
+++ security/manager/ssl/src/nsNSSComponent.cpp	13 May 2005 17:58:31 -0000
@@ -28,6 +28,7 @@
 #include "nsNSSComponent.h"
 #include "nsNSSCallbacks.h"
 #include "nsNSSIOLayer.h"
+#include "nsNSSEvent.h"
 
 #include "nsNetUtil.h"
 #include "nsAppDirectoryServiceDefs.h"
@@ -35,6 +36,7 @@
 #include "nsIStreamListener.h"
 #include "nsIStringBundle.h"
 #include "nsIDirectoryService.h"
+#include "nsIDOMNode.h"
 #include "nsCURILoader.h"
 #include "nsDirectoryServiceDefs.h"
 #include "nsIProxyObjectManager.h"
@@ -43,13 +45,21 @@
 #include "nsIProfileChangeStatus.h"
 #include "nsNSSCertificate.h"
 #include "nsNSSHelper.h"
+#include "nsSmartCardMonitor.h"
 #include "prlog.h"
 #include "nsIPref.h"
 #include "nsIDateTimeFormat.h"
 #include "nsDateTimeFormatCID.h"
 #include "nsAutoLock.h"
-#include "nsIEventQueueService.h"
 #include "nsIEventQueue.h"
+#include "nsIDOMEvent.h"
+#include "nsIDOMDocument.h"
+#include "nsIDOMDocumentEvent.h"
+#include "nsIDOMWindow.h"
+#include "nsIDOMWindowCollection.h"
+#include "nsIDOMWindowInternal.h"
+#include "nsIDOMSmartCardEvent.h"
+#include "nsIDOMCrypto.h"
 #include "nsIRunnable.h"
 #include "plevent.h"
 #include "nsCRT.h"
@@ -71,6 +81,7 @@
 #include "nsITokenPasswordDialogs.h"
 #include "nsICRLManager.h"
 #include "nsNSSShutDown.h"
+#include "nsSmartCardEvent.h"
 
 #include "nss.h"
 #include "pk11func.h"
@@ -182,9 +193,10 @@
   nsCAutoString *urlString;
   nsIStreamListener *psmDownloader;
 };
-//Note that nsNSSComponent is a singleton object across all threads, and automatic downloads
-//are always scheduled sequentially - that is, once one crl download is complete, the next one
-//is scheduled
+
+// Note that nsNSSComponent is a singleton object across all threads, 
+// and automatic downloads are always scheduled sequentially - that is, 
+// once one crl download is complete, the next one is scheduled
 static void PR_CALLBACK HandleCRLImportPLEvent(CRLDownloadEvent *aEvent)
 {
   nsresult rv;
@@ -205,8 +217,43 @@
   delete aEvent;
 }
 
+//This class is used to run the callback code
+//passed to the event handlers for smart card notification
+class nsTokenEventRunnable : public nsIRunnable {
+public:
+  nsTokenEventRunnable(const nsAString &aType, const nsAString &aTokenName);
+  virtual ~nsTokenEventRunnable();
+
+  NS_IMETHOD Run ();
+  NS_DECL_ISUPPORTS
+private:
+  nsString mType;
+  nsString mTokenName;
+};
+
+// ISuuports implementation for nsTokenEventRunnable
+NS_IMPL_THREADSAFE_ISUPPORTS1(nsTokenEventRunnable, nsIRunnable);
+
+nsTokenEventRunnable::nsTokenEventRunnable(const nsAString &aType, 
+   const nsAString &aTokenName): mType(aType), mTokenName(aTokenName) { }
+
+nsTokenEventRunnable::~nsTokenEventRunnable() { }
+
+//Implementation that runs the callback passed to 
+//crypto.generateCRMFRequest as an event.
+NS_IMETHODIMP
+nsTokenEventRunnable::Run()
+{ 
+  nsresult rv;
+  nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
+  if (NS_FAILED(rv))
+    return rv;
+
+  return nssComponent->DispatchEvent(mType, mTokenName);
+}
+
 nsNSSComponent::nsNSSComponent()
-:mNSSInitialized(PR_FALSE)
+  :mNSSInitialized(PR_FALSE), mThreadList(nsnull)
 {
   mutex = PR_NewLock();
   
@@ -264,6 +311,160 @@
   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent::dtor finished\n"));
 }
 
+NS_IMETHODIMP
+nsNSSComponent::PostEvent(const nsAString &eventType, 
+                                                  const nsAString &tokenName)
+{
+  nsresult rv;
+  nsTokenEventRunnable *runnable = 
+                               new nsTokenEventRunnable(eventType, tokenName);
+  if (!runnable) {
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  rv = nsNSSEventPostToUIEventQueue(runnable);
+  if (NS_FAILED(rv))
+    delete runnable;
+
+  return rv;
+}
+
+
+NS_IMETHODIMP
+nsNSSComponent::DispatchEvent(const nsAString &eventType,
+                                                 const nsAString &tokenName)
+{
+  // 'Dispatch' the event to all the windows. 'DispatchEventToWindow()' will
+  // first check to see if a given window has requested crypto events.
+  nsresult rv;
+  nsCOMPtr<nsIWindowWatcher> windowWatcher =
+                            do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
+
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  nsCOMPtr<nsISimpleEnumerator> enumerator;
+  rv = windowWatcher->GetWindowEnumerator(getter_AddRefs(enumerator));
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  PRBool hasMoreWindows;
+
+  while (NS_SUCCEEDED(enumerator->HasMoreElements(&hasMoreWindows))
+         && hasMoreWindows) {
+    nsCOMPtr<nsISupports> supports;
+    enumerator->GetNext(getter_AddRefs(supports));
+    nsCOMPtr<nsIDOMWindow> domWin(do_QueryInterface(supports));
+    if (domWin) {
+      nsresult rv2 = DispatchEventToWindow(domWin, eventType, tokenName);
+      if (NS_FAILED(rv2)) {
+        // return the last failure, don't let a single failure prevent
+        // continued delivery of events.
+        rv = rv2;
+      }
+    }
+  }
+  return rv;
+}
+
+nsresult
+nsNSSComponent::DispatchEventToWindow(nsIDOMWindow *domWin,
+                      const nsAString &eventType, const nsAString &tokenName)
+{
+  // first walk the children and dispatch their events 
+  {
+    nsresult rv;
+    nsCOMPtr<nsIDOMWindowCollection> frames;
+    rv = domWin->GetFrames(getter_AddRefs(frames));
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+
+    PRUint32 length;
+    frames->GetLength(&length);
+    PRUint32 i;
+    for (i = 0; i < length; i++) {
+      nsCOMPtr<nsIDOMWindow> childWin;
+      frames->Item(i, getter_AddRefs(childWin));
+      DispatchEventToWindow(childWin, eventType, tokenName);
+    }
+  }
+
+  // check if we've enabled smart card events on this window
+  // NOTE: it's not an error to say that we aren't going to dispatch
+  // the event.
+  {
+    nsCOMPtr<nsIDOMWindowInternal> intWindow = do_QueryInterface(domWin);
+    if (!intWindow) {
+      return NS_OK; // nope, it's not an internal window
+    }
+
+    nsCOMPtr<nsIDOMCrypto> crypto;
+    intWindow->GetCrypto(getter_AddRefs(crypto));
+    if (!crypto) {
+      return NS_OK; // nope, it doesn't have a crypto property
+    }
+
+    PRBool boolrv;
+    crypto->GetEnableSmartCardEvents(&boolrv);
+    if (!boolrv) {
+      return NS_OK; // nope, it's not enabled.
+    }
+  }
+
+  // dispatch the event ...
+
+  nsresult rv;
+  // find the document
+  nsCOMPtr<nsIDOMDocument> doc;
+  rv = domWin->GetDocument(getter_AddRefs(doc));
+  if (doc == nsnull) {
+    return NS_FAILED(rv) ? rv : NS_ERROR_FAILURE;
+  }
+
+  // create the event
+  nsCOMPtr<nsIDOMDocumentEvent> docEvent = do_QueryInterface(doc, &rv);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  nsCOMPtr<nsIDOMEvent> event;
+  rv = docEvent->CreateEvent(NS_LITERAL_STRING("Events"), 
+                             getter_AddRefs(event));
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  event->InitEvent(eventType, false, true);
+
+  // create the Smart Card Event;
+  nsCOMPtr<nsIDOMSmartCardEvent> smartCardEvent = 
+                                          new nsSmartCardEvent(tokenName);
+  // init the smart card event, fail here if we can't complete the 
+  // initialization.
+  if (!smartCardEvent) {
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  rv = smartCardEvent->Init(event);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  // Send it 
+  nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(doc, &rv);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  PRBool boolrv;
+  rv = target->DispatchEvent(smartCardEvent, &boolrv);
+  return rv;
+}
+
+
 #ifdef XP_MAC
 #ifdef DEBUG
 #define LOADABLE_CERTS_MODULE NS_LITERAL_CSTRING("NSSckbiDebug.shlb")
@@ -333,6 +534,62 @@
 }
 
 void
+nsNSSComponent::LaunchSmartCardThreads()
+{
+  nsNSSShutDownPreventionLock locker;
+  {
+    SECMODModuleList *list = SECMOD_GetDefaultModuleList();
+    SECMODListLock *lock = SECMOD_GetDefaultModuleListLock();
+    SECMOD_GetReadLock(lock);
+
+    while (list) {
+      SECMODModule *module = list->module;
+      LaunchSmartCardThread(module);
+      list = list->next;
+    }
+    SECMOD_ReleaseReadLock(lock);
+  }
+}
+
+NS_IMETHODIMP
+nsNSSComponent::LaunchSmartCardThread(SECMODModule *module)
+{
+  SmartCardMonitoringThread *newThread;
+  if (SECMOD_HasRemovableSlots(module)) {
+    if (mThreadList == nsnull) {
+      mThreadList = new SmartCardThreadList();
+      if (!mThreadList) {
+        return NS_ERROR_OUT_OF_MEMORY;
+      }
+    }
+    newThread = new SmartCardMonitoringThread(module);
+    if (!newThread) {
+	return NS_ERROR_OUT_OF_MEMORY;
+    }
+    // newThread is adopted by the add.
+    return mThreadList->Add(newThread);
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNSSComponent::ShutdownSmartCardThread(SECMODModule *module)
+{
+  if (!mThreadList) {
+    return NS_OK;
+  }
+  mThreadList->Remove(module);
+  return NS_OK;
+}
+
+void
+nsNSSComponent::ShutdownSmartCardThreads()
+{
+  delete mThreadList;
+  mThreadList = nsnull;
+}
+
+void
 nsNSSComponent::InstallLoadableRoots()
 {
   nsNSSShutDownPreventionLock locker;
@@ -352,7 +609,7 @@
         PK11SlotInfo *slot = module->slots[i];
         if (PK11_IsPresent(slot)) {
           if (PK11_HasRootCerts(slot)) {
-            RootsModule = module;
+            RootsModule = SECMOD_ReferenceModule(module);
             break;
           }
         }
@@ -369,6 +626,7 @@
     CK_INFO info;
     if (SECSuccess != PK11_GetModInfo(RootsModule, &info)) {
       // Do not use this module
+      SECMOD_DestroyModule(RootsModule);
       RootsModule = nsnull;
     }
     else {
@@ -385,13 +643,16 @@
          ) {
         PRInt32 modType;
         SECMOD_DeleteModule(RootsModule->commonName, &modType);
+        SECMOD_DestroyModule(RootsModule);
 
         RootsModule = nsnull;
       }
     }
   }
 
-  if (!RootsModule) {
+  if (RootsModule) {
+    SECMOD_DestroyModule(RootsModule);
+  } else { /* !RootsModule */
     // Load roots module from our installation path
   
     nsresult rv;
@@ -598,9 +859,9 @@
   pref->GetIntPref("security.OCSP.enabled", &ocspEnabled);
   switch (ocspEnabled) {
   case 0:
-	  CERT_DisableOCSPChecking(CERT_GetDefaultCertDB());
-	  CERT_DisableOCSPDefaultResponder(CERT_GetDefaultCertDB());
-	  break;
+    CERT_DisableOCSPChecking(CERT_GetDefaultCertDB());
+    CERT_DisableOCSPDefaultResponder(CERT_GetDefaultCertDB());
+    break;
   case 1:
     CERT_EnableOCSPChecking(CERT_GetDefaultCertDB());
     break;
@@ -621,15 +882,13 @@
       nsMemory::Free(signingCA);
       nsMemory::Free(url);
     }
-	  break;
+    break;
   }
 }
 
 nsresult
 nsNSSComponent::PostCRLImportEvent(nsCAutoString *urlString, PSMContentDownloader *psmDownloader)
 {
-  nsresult rv;
-  
   //Create the event
   CRLDownloadEvent *event = new CRLDownloadEvent;
   PL_InitEvent(event, this, (PLHandleEventProc)HandleCRLImportPLEvent, (PLDestroyEventProc)DestroyCRLImportPLEvent);
@@ -637,17 +896,12 @@
   event->psmDownloader = (nsIStreamListener *)psmDownloader;
   
   //Get a handle to the ui event queue
-  nsCOMPtr<nsIEventQueueService> service = 
-                        do_GetService(NS_EVENTQUEUESERVICE_CONTRACTID, &rv);
-  if (NS_FAILED(rv)) 
-    return rv;
-  
-  nsIEventQueue* result = nsnull;
-  rv = service->GetThreadEventQueue(NS_UI_THREAD, &result);
-  if (NS_FAILED(rv)) 
-    return rv;
   
-  nsCOMPtr<nsIEventQueue>uiQueue = dont_AddRef(result);
+  nsCOMPtr<nsIEventQueue>uiQueue = nsNSSEventGetUIEventQueue();
+
+  if (!uiQueue) {
+    return NS_ERROR_FAILURE;
+  }
 
   //Post the event
   return uiQueue->PostEvent(event);
@@ -1189,6 +1443,8 @@
 
       InstallLoadableRoots();
 
+      LaunchSmartCardThreads();
+
       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NSS Initialization done\n"));
     }
   }
@@ -1235,6 +1491,7 @@
                                 (void*) this);
     }
 
+    ShutdownSmartCardThreads();
     SSL_ClearSessionCache();
     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("evaporating psm resources\n"));
     mShutdownObjectList->evaporateAllNSSResources();
Index: security/manager/ssl/src/nsNSSComponent.h
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSComponent.h,v
retrieving revision 1.33
diff -u -r1.33 nsNSSComponent.h
--- security/manager/ssl/src/nsNSSComponent.h	26 Feb 2004 04:07:23 -0000	1.33
+++ security/manager/ssl/src/nsNSSComponent.h	13 May 2005 17:58:31 -0000
@@ -34,11 +34,13 @@
 #include "nsIEntropyCollector.h"
 #include "nsString.h"
 #include "nsIStringBundle.h"
+#include "nsIDOMEventTarget.h"
 #include "nsIPref.h"
 #include "nsIObserver.h"
 #include "nsIObserverService.h"
 #include "nsWeakReference.h"
 #include "nsIScriptSecurityManager.h"
+#include "nsSmartCardMonitor.h"
 #include "nsITimer.h"
 #include "nsNetUtil.h"
 #include "nsHashtable.h"
@@ -125,11 +127,19 @@
   NS_IMETHOD DownloadCRLDirectly(nsAutoString, nsAutoString) = 0;
   
   NS_IMETHOD LogoutAuthenticatedPK11() = 0;
-  
+
+  NS_IMETHOD LaunchSmartCardThread(SECMODModule *module) = 0;
+
+  NS_IMETHOD ShutdownSmartCardThread(SECMODModule *module) = 0;
+
+  NS_IMETHOD PostEvent(const nsAString &eventType, const nsAString &token) = 0;
+
+  NS_IMETHOD DispatchEvent(const nsAString &eventType, const nsAString &token) = 0;
 };
 
 struct PRLock;
 class nsNSSShutDownList;
+class nsNSSDOMNode;
 
 // Implementation of the PSM component interface.
 class nsNSSComponent : public nsISignatureVerifier,
@@ -170,6 +180,11 @@
   NS_IMETHOD RememberCert(CERTCertificate *cert);
   static nsresult GetNSSCipherIDFromPrefString(const nsACString &aPrefString, PRUint16 &aCipherId);
 
+  NS_IMETHOD LaunchSmartCardThread(SECMODModule *module);
+  NS_IMETHOD ShutdownSmartCardThread(SECMODModule *module);
+  NS_IMETHOD PostEvent(const nsAString &eventType, const nsAString &token);
+  NS_IMETHOD DispatchEvent(const nsAString &eventType, const nsAString &token);
+
 private:
 
   nsresult InitializeNSS(PRBool showWarningBox);
@@ -188,6 +203,8 @@
   
   void ShowAlert(AlertIdentifier ai);
   void InstallLoadableRoots();
+  void LaunchSmartCardThreads();
+  void ShutdownSmartCardThreads();
   nsresult InitializePIPNSSBundle();
   nsresult ConfigureInternalPKCS11Token();
   nsresult RegisterPSMContentListener();
@@ -197,6 +214,7 @@
   nsresult DownloadCrlSilently();
   nsresult PostCRLImportEvent(nsCAutoString *urlString, PSMContentDownloader *psmDownloader);
   nsresult getParamsForNextCrlToDownload(nsAutoString *url, PRTime *time, nsAutoString *key);
+  nsresult DispatchEventToWindow(nsIDOMWindow *domWin, const nsAString &eventType, const nsAString &token);
   PRLock *mutex;
   
   nsCOMPtr<nsIScriptSecurityManager> mScriptSecurityManager;
@@ -215,6 +233,7 @@
   PRBool mUpdateTimerInitialized;
   static int mInstanceCount;
   nsNSSShutDownList *mShutdownObjectList;
+  SmartCardThreadList *mThreadList;
 };
 
 class PSMContentListener : public nsIURIContentListener,
Index: security/manager/ssl/src/nsNSSEvent.cpp
===================================================================
RCS file: security/manager/ssl/src/nsNSSEvent.cpp
diff -N security/manager/ssl/src/nsNSSEvent.cpp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ security/manager/ssl/src/nsNSSEvent.cpp	13 May 2005 17:58:31 -0000
@@ -0,0 +1,97 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ *
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Netscape
+ * Communications Corporation.  Portions created by Netscape are
+ * Copyright (C) 2001 Netscape Communications Corporation. All
+ * Rights Reserved.
+ *
+ * Contributor(s):
+ *  Javier Delgadillo <javi@netscape.com>
+ *  Bob Relyea        <rrelyea@redhat.com>
+ */
+#include "nsCOMPtr.h"
+#include "nsIServiceManager.h"
+#include "nsNSSEvent.h"
+#include "plevent.h"
+#include "nsIRunnable.h"
+#include "nsIEventQueueService.h"
+#include "nsIEventQueue.h"
+
+//
+// This is the class we'll use to post ui events
+//
+struct nsNSSEventRunnable : PLEvent {
+  nsNSSEventRunnable(nsIRunnable* runnable);
+  ~nsNSSEventRunnable();
+
+  nsCOMPtr<nsIRunnable> mRunnable;
+};
+
+//Grab the UI event queue so that we can post some events to it.
+already_AddRefed<nsIEventQueue>
+nsNSSEventGetUIEventQueue()
+{
+  nsresult rv;
+  nsCOMPtr<nsIEventQueueService> service = 
+                        do_GetService(NS_EVENTQUEUESERVICE_CONTRACTID, &rv);
+  if (NS_FAILED(rv)) 
+    return nsnull;
+  
+  nsIEventQueue* result = nsnull;
+  rv = service->GetThreadEventQueue(NS_UI_THREAD, &result);
+  if (NS_FAILED(rv)) 
+    return nsnull;
+  
+  return result;
+}
+
+// post something to it
+nsresult
+nsNSSEventPostToUIEventQueue(nsIRunnable *event)
+{
+  nsNSSEventRunnable *runnable = new nsNSSEventRunnable(event);
+  if (!runnable) {
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+  nsCOMPtr<nsIEventQueue>uiQueue = nsNSSEventGetUIEventQueue();
+  uiQueue->PostEvent(runnable);
+  return NS_OK;
+}
+
+//A wrapper for PLEvent that we can use to post
+//our nsIRunnable Events.
+static void PR_CALLBACK
+handleNSSEventRunnable(nsNSSEventRunnable* aEvent)
+{
+  aEvent->mRunnable->Run();
+}
+
+static void PR_CALLBACK
+destroyNSSEventRunnable(nsNSSEventRunnable* aEvent)
+{
+  delete aEvent;
+}
+
+nsNSSEventRunnable::nsNSSEventRunnable(nsIRunnable* runnable)
+  :  mRunnable(runnable)
+{
+  PL_InitEvent(this, nsnull, PLHandleEventProc(handleNSSEventRunnable),
+               PLDestroyEventProc(&destroyNSSEventRunnable));
+}
+
+nsNSSEventRunnable::~nsNSSEventRunnable()
+{
+}
+
Index: security/manager/ssl/src/nsNSSEvent.h
===================================================================
RCS file: security/manager/ssl/src/nsNSSEvent.h
diff -N security/manager/ssl/src/nsNSSEvent.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ security/manager/ssl/src/nsNSSEvent.h	13 May 2005 17:58:31 -0000
@@ -0,0 +1,54 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ *
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Netscape
+ * Communications Corporation.  Portions created by Netscape are
+ * Copyright (C) 1998 Netscape Communications Corporation. All
+ * Rights Reserved.
+ *
+ * Contributor(s):
+ *  Javier Delgadillo <javi@netscape.com>
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 or later (the
+ * "GPL"), in which case the provisions of the GPL are applicable 
+ * instead of those above.  If you wish to allow use of your 
+ * version of this file only under the terms of the GPL and not to
+ * allow others to use your version of this file under the MPL,
+ * indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by
+ * the GPL.  If you do not delete the provisions above, a recipient
+ * may use your version of this file under either the MPL or the
+ * GPL.
+ * Contributor(s):
+ *  Javier Delgadillo <javi@netscape.com>
+ *  Bob Relyea        <rrelyea@redhat.com>
+ */
+
+#ifndef NSS_EVENT_
+#define NSS_EVENT_
+
+#include "nsIRunnable.h"
+#include "nsIEventQueueService.h"
+#include "nsIEventQueue.h"
+
+
+//Grab the UI event queue so that we can post some events to it.
+already_AddRefed<nsIEventQueue> nsNSSEventGetUIEventQueue();
+
+// post something to it
+nsresult nsNSSEventPostToUIEventQueue(nsIRunnable *event);
+
+#endif
+
Index: security/manager/ssl/src/nsPK11TokenDB.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsPK11TokenDB.cpp,v
retrieving revision 1.18
diff -u -r1.18 nsPK11TokenDB.cpp
--- security/manager/ssl/src/nsPK11TokenDB.cpp	18 Jan 2003 14:02:58 -0000	1.18
+++ security/manager/ssl/src/nsPK11TokenDB.cpp	13 May 2005 17:58:31 -0000
@@ -45,8 +45,16 @@
 
   PK11_ReferenceSlot(slot);
   mSlot = slot;
-  
-  mTokenName = NS_ConvertUTF8toUCS2(PK11_GetTokenName(slot));
+  mSeries = PK11_GetSlotSeries(slot);
+
+  refreshTokenInfo();
+  mUIContext = new PipUIContext();
+}
+
+void  
+nsPK11Token::refreshTokenInfo()
+{
+  mTokenName = NS_ConvertUTF8toUTF16(PK11_GetTokenName(mSlot));
 
   SECStatus srv;
 
@@ -87,7 +95,6 @@
     mTokenSerialNum.Trim(" ", PR_FALSE, PR_TRUE);
   }
 
-  mUIContext = new PipUIContext();
 }
 
 nsPK11Token::~nsPK11Token()
@@ -119,6 +126,10 @@
 /* readonly attribute wstring tokenName; */
 NS_IMETHODIMP nsPK11Token::GetTokenName(PRUnichar * *aTokenName)
 {
+  // handle removals/insertions
+  if (mSeries != PK11_GetSlotSeries(mSlot)) {
+    refreshTokenInfo();
+  }
   *aTokenName = ToNewUnicode(mTokenName);
   if (!*aTokenName) return NS_ERROR_OUT_OF_MEMORY;
 
@@ -128,6 +139,10 @@
 /* readonly attribute wstring tokenDesc; */
 NS_IMETHODIMP nsPK11Token::GetTokenLabel(PRUnichar **aTokLabel)
 {
+  // handle removals/insertions
+  if (mSeries != PK11_GetSlotSeries(mSlot)) {
+    refreshTokenInfo();
+  }
   *aTokLabel = ToNewUnicode(mTokenLabel);
   if (!*aTokLabel) return NS_ERROR_OUT_OF_MEMORY;
   return NS_OK;
@@ -136,6 +151,10 @@
 /* readonly attribute wstring tokenManID; */
 NS_IMETHODIMP nsPK11Token::GetTokenManID(PRUnichar **aTokManID)
 {
+  // handle removals/insertions
+  if (mSeries != PK11_GetSlotSeries(mSlot)) {
+    refreshTokenInfo();
+  }
   *aTokManID = ToNewUnicode(mTokenManID);
   if (!*aTokManID) return NS_ERROR_OUT_OF_MEMORY;
   return NS_OK;
@@ -144,6 +163,10 @@
 /* readonly attribute wstring tokenHWVersion; */
 NS_IMETHODIMP nsPK11Token::GetTokenHWVersion(PRUnichar **aTokHWVersion)
 {
+  // handle removals/insertions
+  if (mSeries != PK11_GetSlotSeries(mSlot)) {
+    refreshTokenInfo();
+  }
   *aTokHWVersion = ToNewUnicode(mTokenHWVersion);
   if (!*aTokHWVersion) return NS_ERROR_OUT_OF_MEMORY;
   return NS_OK;
@@ -152,6 +175,10 @@
 /* readonly attribute wstring tokenFWVersion; */
 NS_IMETHODIMP nsPK11Token::GetTokenFWVersion(PRUnichar **aTokFWVersion)
 {
+  // handle removals/insertions
+  if (mSeries != PK11_GetSlotSeries(mSlot)) {
+    refreshTokenInfo();
+  }
   *aTokFWVersion = ToNewUnicode(mTokenFWVersion);
   if (!*aTokFWVersion) return NS_ERROR_OUT_OF_MEMORY;
   return NS_OK;
@@ -160,6 +187,10 @@
 /* readonly attribute wstring tokenSerialNumber; */
 NS_IMETHODIMP nsPK11Token::GetTokenSerialNumber(PRUnichar **aTokSerialNum)
 {
+  // handle removals/insertions
+  if (mSeries != PK11_GetSlotSeries(mSlot)) {
+    refreshTokenInfo();
+  }
   *aTokSerialNum = ToNewUnicode(mTokenSerialNum);
   if (!*aTokSerialNum) return NS_ERROR_OUT_OF_MEMORY;
   return NS_OK;
Index: security/manager/ssl/src/nsPK11TokenDB.h
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsPK11TokenDB.h,v
retrieving revision 1.4
diff -u -r1.4 nsPK11TokenDB.h
--- security/manager/ssl/src/nsPK11TokenDB.h	18 Jan 2003 14:02:58 -0000	1.4
+++ security/manager/ssl/src/nsPK11TokenDB.h	13 May 2005 17:58:31 -0000
@@ -47,11 +47,13 @@
 
 private:
   friend class nsPK11TokenDB;
+  void refreshTokenInfo();
 
   nsString mTokenName;
   nsString mTokenLabel, mTokenManID, mTokenHWVersion, mTokenFWVersion;
   nsString mTokenSerialNum;
   PK11SlotInfo *mSlot;
+  int mSeries;
   nsCOMPtr<nsIInterfaceRequestor> mUIContext;
   virtual void virtualDestroyNSSReference();
   void destructorSafeDestroyNSSReference();
Index: security/manager/ssl/src/nsPKCS11Slot.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsPKCS11Slot.cpp,v
retrieving revision 1.16
diff -u -r1.16 nsPKCS11Slot.cpp
--- security/manager/ssl/src/nsPKCS11Slot.cpp	27 Mar 2003 19:31:53 -0000	1.16
+++ security/manager/ssl/src/nsPKCS11Slot.cpp	13 May 2005 17:58:31 -0000
@@ -58,7 +58,13 @@
 
   PK11_ReferenceSlot(slot);
   mSlot = slot;
+  mSeries = PK11_GetSlotSeries(slot);
+  refreshSlotInfo();
+}
 
+void
+nsPKCS11Slot::refreshSlotInfo()
+{
   CK_SLOT_INFO slot_info;
   if (PK11_GetSlotInfo(mSlot, &slot_info) == SECSuccess) {
     // Set the Description field
@@ -76,10 +82,12 @@
     mSlotManID = NS_ConvertUTF8toUCS2(cManID);
     mSlotManID.Trim(" ", PR_FALSE, PR_TRUE);
     // Set the Hardware Version field
+    mSlotHWVersion = EmptyString();
     mSlotHWVersion.AppendInt(slot_info.hardwareVersion.major);
     mSlotHWVersion.Append(NS_LITERAL_STRING("."));
     mSlotHWVersion.AppendInt(slot_info.hardwareVersion.minor);
     // Set the Firmware Version field
+    mSlotFWVersion = EmptyString();
     mSlotFWVersion.AppendInt(slot_info.firmwareVersion.major);
     mSlotFWVersion.Append(NS_LITERAL_STRING("."));
     mSlotFWVersion.AppendInt(slot_info.firmwareVersion.minor);
@@ -125,7 +133,7 @@
   if (*csn) {
     *aName = ToNewUnicode(NS_ConvertUTF8toUCS2(csn));
   } else if (PK11_HasRootCerts(mSlot)) {
-    // This is a workaround to an NSS bug - the root certs module has
+    // This is a workaround to an Root Module bug - the root certs module has
     // no slot name.  Not bothering to localize, because this is a workaround
     // and for now all the slot names returned by NSS are char * anyway.
     *aName = ToNewUnicode(NS_LITERAL_STRING("Root Certificates"));
@@ -145,6 +153,10 @@
   if (isAlreadyShutDown())
     return NS_ERROR_NOT_AVAILABLE;
 
+  if (mSeries != PK11_GetSlotSeries(mSlot)) {
+    refreshSlotInfo();
+  }
+
   *aDesc = ToNewUnicode(mSlotDesc);
   if (!*aDesc) return NS_ERROR_OUT_OF_MEMORY;
   return NS_OK;
@@ -154,6 +166,9 @@
 NS_IMETHODIMP 
 nsPKCS11Slot::GetManID(PRUnichar **aManID)
 {
+  if (mSeries != PK11_GetSlotSeries(mSlot)) {
+    refreshSlotInfo();
+  }
   *aManID = ToNewUnicode(mSlotManID);
   if (!*aManID) return NS_ERROR_OUT_OF_MEMORY;
   return NS_OK;
@@ -163,6 +178,9 @@
 NS_IMETHODIMP 
 nsPKCS11Slot::GetHWVersion(PRUnichar **aHWVersion)
 {
+  if (mSeries != PK11_GetSlotSeries(mSlot)) {
+    refreshSlotInfo();
+  }
   *aHWVersion = ToNewUnicode(mSlotHWVersion);
   if (!*aHWVersion) return NS_ERROR_OUT_OF_MEMORY;
   return NS_OK;
@@ -172,6 +190,9 @@
 NS_IMETHODIMP 
 nsPKCS11Slot::GetFWVersion(PRUnichar **aFWVersion)
 {
+  if (mSeries != PK11_GetSlotSeries(mSlot)) {
+    refreshSlotInfo();
+  }
   *aFWVersion = ToNewUnicode(mSlotFWVersion);
   if (!*aFWVersion) return NS_ERROR_OUT_OF_MEMORY;
   return NS_OK;
@@ -201,6 +222,16 @@
   if (isAlreadyShutDown())
     return NS_ERROR_NOT_AVAILABLE;
 
+  if (!PK11_IsPresent(mSlot)) {
+    *aName = nsnull;
+    return NS_OK;
+  }
+
+  if (mSeries != PK11_GetSlotSeries(mSlot)) {
+    refreshSlotInfo();
+  }
+
+
   *aName = ToNewUnicode(NS_ConvertUTF8toUCS2(PK11_GetTokenName(mSlot)));
   if (!*aName) return NS_ERROR_OUT_OF_MEMORY;
   return NS_OK;
@@ -303,30 +334,35 @@
   if (isAlreadyShutDown())
     return NS_ERROR_NOT_AVAILABLE;
 
-  char *asciiname = NULL;
-  asciiname = ToNewUTF8String(nsDependentString(aName));
+  char *asciiname = ToNewUTF8String(nsDependentString(aName));
   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("Getting \"%s\"\n", asciiname));
-  PK11SlotInfo *slotinfo = SECMOD_FindSlot(mModule, asciiname);
-  if (!slotinfo) {
-    // XXX *sigh*  if token is present, SECMOD_FindSlot goes by token
-    // name (huh?)  reimplement it here for the fun of it.
-    for (int i=0; i<mModule->slotCount; i++) {
-      if (nsCRT::strcmp(asciiname, PK11_GetSlotName(mModule->slots[i])) == 0) {
-        slotinfo = PK11_ReferenceSlot(mModule->slots[i]);
-        break;
-      }
-    }
-    if (!slotinfo) {
-      // XXX another workaround - the builtin module has no name
-      if (nsCRT::strcmp(asciiname, "Root Certificates") == 0) {
-        slotinfo = PK11_ReferenceSlot(mModule->slots[0]);
-      } else {
-        // give up
-        nsMemory::Free(asciiname);
-        return NS_ERROR_FAILURE;
-      }
+  PK11SlotInfo *slotinfo = NULL;
+  PK11SlotList *slotList = PK11_FindSlotsByNames(mModule->dllName, 
+        asciiname /* slotName */, NULL /* token Name */, PR_FALSE);
+  if (!slotList) {
+    /* name must be the token name */
+    slotList = PK11_FindSlotsByNames(mModule->dllName, 
+        NULL /*slot Name */, asciiname /* token Name */, PR_FALSE);
+  }
+  if (slotList) {
+    /* should only be one */
+    if (slotList->head && slotList->head->slot) {
+      slotinfo =  PK11_ReferenceSlot(slotList->head->slot);
     }
+    PK11_FreeSlotList(slotList);
   }
+  if (!slotinfo) {
+    // workaround - the builtin module has no name
+    if (asciiname == nsnull) {
+      return NS_ERROR_FAILURE;
+    } else if (nsCRT::strcmp(asciiname, "Root Certificates") == 0) {
+      slotinfo = PK11_ReferenceSlot(mModule->slots[0]);
+    } else {
+      // give up
+      nsMemory::Free(asciiname);
+      return NS_ERROR_FAILURE;
+    }
+  } 
   nsMemory::Free(asciiname);
   nsCOMPtr<nsIPKCS11Slot> slot = new nsPKCS11Slot(slotinfo);
   PK11_FreeSlot(slotinfo);
@@ -351,12 +387,19 @@
   nsCOMPtr<nsISupportsArray> array;
   rv = NS_NewISupportsArray(getter_AddRefs(array));
   if (NS_FAILED(rv)) return rv;
+  /* applications which allow new slot creation (which Firefox now does
+   * since it uses the WaitForSlotEvent call) need to hold the
+   * ModuleList Read lock to prevent the slot array from changing out
+   * from under it. */
+  SECMODListLock *lock = SECMOD_GetDefaultModuleListLock();
+  SECMOD_GetReadLock(lock);
   for (i=0; i<mModule->slotCount; i++) {
     if (mModule->slots[i]) {
       nsCOMPtr<nsIPKCS11Slot> slot = new nsPKCS11Slot(mModule->slots[i]);
       array->AppendElement(slot);
     }
   }
+  SECMOD_ReleaseReadLock(lock);
   rv = array->Enumerate(_retval);
   return rv;
 }
@@ -466,6 +509,13 @@
     array->AppendElement(module);
     list = list->next;
   }
+  /* Get the modules in the database that didn't load */
+  list = SECMOD_GetDeadModuleList();
+  while (list) {
+    nsCOMPtr<nsIPKCS11Module> module = new nsPKCS11Module(list->module);
+    array->AppendElement(module);
+    list = list->next;
+  }
   SECMOD_ReleaseReadLock(lock);
   rv = array->Enumerate(_retval);
   return rv;
Index: security/manager/ssl/src/nsPKCS11Slot.h
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsPKCS11Slot.h,v
retrieving revision 1.4
diff -u -r1.4 nsPKCS11Slot.h
--- security/manager/ssl/src/nsPKCS11Slot.h	27 Mar 2003 19:31:53 -0000	1.4
+++ security/manager/ssl/src/nsPKCS11Slot.h	13 May 2005 17:58:31 -0000
@@ -47,9 +47,11 @@
 
   PK11SlotInfo *mSlot;
   nsString mSlotDesc, mSlotManID, mSlotHWVersion, mSlotFWVersion;
+  int mSeries;
 
   virtual void virtualDestroyNSSReference();
   void destructorSafeDestroyNSSReference();
+  void refreshSlotInfo();
 };
 
 class nsPKCS11Module : public nsIPKCS11Module,
Index: security/manager/ssl/src/nsSmartCardEvent.cpp
===================================================================
RCS file: security/manager/ssl/src/nsSmartCardEvent.cpp
diff -N security/manager/ssl/src/nsSmartCardEvent.cpp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ security/manager/ssl/src/nsSmartCardEvent.cpp	13 May 2005 17:58:31 -0000
@@ -0,0 +1,205 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: NPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Netscape Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/NPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is 
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the NPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the NPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSmartCardEvent.h"
+#include "nsIDOMSmartCardEvent.h"
+#include "nsIDOMClassInfo.h"
+#include "nsIDOMEvent.h"
+#include "nsXPCOM.h"
+
+// DOM event class to handle progress notifications
+nsSmartCardEvent::nsSmartCardEvent(const nsAString &aTokenName) 
+    : mTokenName(aTokenName), mInner(nsnull), mPrivate(nsnull)
+{
+}
+
+nsSmartCardEvent::~nsSmartCardEvent()
+{}
+
+//NS_DECL_DOM_CLASSINFO(SmartCardEvent)
+
+// QueryInterface implementation for nsXMLHttpRequest
+NS_INTERFACE_MAP_BEGIN(nsSmartCardEvent)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMSmartCardEvent)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSmartCardEvent)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMEvent)
+  NS_INTERFACE_MAP_ENTRY(nsIPrivateDOMEvent)
+  NS_INTERFACE_MAP_ENTRY_DOM_CLASSINFO(SmartCardEvent)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(nsSmartCardEvent)
+NS_IMPL_RELEASE(nsSmartCardEvent)
+
+//
+// Init must be called before we do anything with the event.
+//
+NS_IMETHODIMP nsSmartCardEvent::Init(nsIDOMEvent * aInner)
+{
+  nsresult rv;
+
+  NS_ASSERTION(aInner, "SmartCardEvent initialized with a null Event");
+  mInner = aInner;
+  mPrivate = do_QueryInterface(mInner, &rv);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+  return mPrivate->SetTrusted(PR_TRUE);
+}
+
+// nsSmartCard Specific methods
+NS_IMETHODIMP nsSmartCardEvent::GetTokenName(nsAString &aTokenName)
+{
+  aTokenName = mTokenName;
+  return NS_OK;
+}
+
+// nsIPrivateDOMEvent maps
+NS_IMETHODIMP nsSmartCardEvent::DuplicatePrivateData(void)
+{
+  NS_ASSERTION(mPrivate, "SmartCardEvent called without Init");
+  return mPrivate->DuplicatePrivateData();
+}
+
+NS_IMETHODIMP nsSmartCardEvent::SetTarget(nsIDOMEventTarget *aTarget)
+{
+  NS_ASSERTION(mPrivate, "SmartCardEvent called without Init");
+  return mPrivate->SetTarget(aTarget);
+}
+
+NS_IMETHODIMP nsSmartCardEvent::SetCurrentTarget(nsIDOMEventTarget *aTarget)
+{
+  NS_ASSERTION(mPrivate, "SmartCardEvent called without Init");
+  return mPrivate->SetCurrentTarget(aTarget);
+}
+
+NS_IMETHODIMP nsSmartCardEvent::SetOriginalTarget(nsIDOMEventTarget *aTarget)
+{
+  NS_ASSERTION(mPrivate, "SmartCardEvent called without Init");
+  return mPrivate->SetOriginalTarget(aTarget);
+}
+
+NS_IMETHODIMP nsSmartCardEvent::IsDispatchStopped(PRBool *aIsDispatchPrevented)
+{
+  NS_ASSERTION(mPrivate, "SmartCardEvent called without Init");
+  return mPrivate->IsDispatchStopped(aIsDispatchPrevented);
+}
+
+NS_IMETHODIMP nsSmartCardEvent::GetInternalNSEvent(nsEvent** aNSEvent)
+{
+  NS_ASSERTION(mPrivate, "SmartCardEvent called without Init");
+  return mPrivate->GetInternalNSEvent(aNSEvent);
+}
+
+NS_IMETHODIMP nsSmartCardEvent::HasOriginalTarget(PRBool *aResult)
+{
+  NS_ASSERTION(mPrivate, "SmartCardEvent called without Init");
+  return mPrivate->HasOriginalTarget(aResult);
+}
+
+NS_IMETHODIMP nsSmartCardEvent::IsTrustedEvent(PRBool *aResult)
+{
+  NS_ASSERTION(mPrivate, "SmartCardEvent called without Init");
+  return mPrivate->IsTrustedEvent(aResult);
+}
+
+NS_IMETHODIMP nsSmartCardEvent::SetTrusted(PRBool aResult)
+{
+  NS_ASSERTION(mPrivate, "SmartCardEvent called without Init");
+  return mPrivate->SetTrusted(aResult);
+}
+
+// IDOMEvent maps
+NS_IMETHODIMP nsSmartCardEvent::GetType(nsAString & aType)
+{
+  NS_ASSERTION(mInner, "SmartCardEvent called without Init");
+  return mInner->GetType(aType);
+}
+
+NS_IMETHODIMP nsSmartCardEvent::GetTarget(nsIDOMEventTarget * *aTarget)
+{
+  NS_ASSERTION(mInner, "SmartCardEvent called without Init");
+  return mInner->GetTarget(aTarget);
+}
+
+NS_IMETHODIMP nsSmartCardEvent::GetCurrentTarget(nsIDOMEventTarget * *aCurrentTarget)
+{
+  NS_ASSERTION(mInner, "SmartCardEvent called without Init");
+  return mInner->GetCurrentTarget(aCurrentTarget);
+}
+
+NS_IMETHODIMP nsSmartCardEvent::GetEventPhase(PRUint16 *aEventPhase)
+{
+  NS_ASSERTION(mInner, "SmartCardEvent called without Init");
+  return mInner->GetEventPhase(aEventPhase);
+}
+
+NS_IMETHODIMP nsSmartCardEvent::GetBubbles(PRBool *aBubbles)
+{
+  NS_ASSERTION(mInner, "SmartCardEvent called without Init");
+  return mInner->GetBubbles(aBubbles);
+}
+
+NS_IMETHODIMP nsSmartCardEvent::GetCancelable(PRBool *aCancelable)
+{
+  NS_ASSERTION(mInner, "SmartCardEvent called without Init");
+  return mInner->GetCancelable(aCancelable);
+}
+
+NS_IMETHODIMP nsSmartCardEvent::GetTimeStamp(DOMTimeStamp *aTimeStamp)
+{
+  NS_ASSERTION(mInner, "SmartCardEvent called without Init");
+  return mInner->GetTimeStamp(aTimeStamp);
+}
+
+NS_IMETHODIMP nsSmartCardEvent::StopPropagation()
+{
+  NS_ASSERTION(mInner, "SmartCardEvent called without Init");
+  return mInner->StopPropagation();
+}
+
+NS_IMETHODIMP nsSmartCardEvent::PreventDefault()
+{
+  NS_ASSERTION(mInner, "SmartCardEvent called without Init");
+  return mInner->PreventDefault();
+}
+
+NS_IMETHODIMP nsSmartCardEvent::InitEvent(const nsAString & eventTypeArg, PRBool canBubbleArg, PRBool cancelableArg)
+{
+  NS_ASSERTION(mInner, "SmartCardEvent called without Init");
+  return mInner->InitEvent(eventTypeArg, canBubbleArg, cancelableArg);
+}
Index: security/manager/ssl/src/nsSmartCardEvent.h
===================================================================
RCS file: security/manager/ssl/src/nsSmartCardEvent.h
diff -N security/manager/ssl/src/nsSmartCardEvent.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ security/manager/ssl/src/nsSmartCardEvent.h	13 May 2005 17:58:31 -0000
@@ -0,0 +1,84 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: NPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Netscape Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/NPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is 
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the NPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the NPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsSmartCardEvent_h_
+#define nsSmartCardEvent_h_
+
+#include "nsIDOMSmartCardEvent.h"
+#include "nsIDOMEvent.h"
+#include "nsIPrivateDOMEvent.h"
+#include "nsCOMPtr.h"
+#include "nsString.h"
+#include "nsXPCOM.h"
+
+// Expose SmartCard Specific paramenters to smart card events.
+class nsSmartCardEvent : public nsIDOMSmartCardEvent,
+                         public nsIPrivateDOMEvent
+{
+public:
+  nsSmartCardEvent(const nsAString &aTokenName);
+  virtual ~nsSmartCardEvent();
+
+  //nsresult Init(nsIDOMEvent *aInner);
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIDOMSMARTCARDEVENT
+
+  //NS_DECL_NSIPRIVATEDOMEEVENT
+  NS_IMETHOD DuplicatePrivateData();
+  NS_IMETHOD SetTarget(nsIDOMEventTarget *aTarget);
+  NS_IMETHOD SetCurrentTarget(nsIDOMEventTarget *aTarget);
+  NS_IMETHOD SetOriginalTarget(nsIDOMEventTarget *aTarget);
+  NS_IMETHOD GetInternalNSEvent(nsEvent** aNSEvent);
+  NS_IMETHOD IsDispatchStopped(PRBool *aIsDispatchPrevented);
+  NS_IMETHOD HasOriginalTarget(PRBool *aResult);
+  NS_IMETHOD IsTrustedEvent(PRBool *aResult);
+  NS_IMETHOD SetTrusted(PRBool aResult);
+
+  NS_DECL_NSIDOMEVENT
+
+protected:
+  nsCOMPtr<nsIDOMEvent> mInner;
+  nsCOMPtr<nsIPrivateDOMEvent> mPrivate;
+  nsString mTokenName;
+};
+
+#define SMARTCARDEVENT_INSERT "smartcard-insert"
+#define SMARTCARDEVENT_REMOVE "smartcard-remove"
+
+#endif
Index: security/manager/ssl/src/nsSmartCardMonitor.cpp
===================================================================
RCS file: security/manager/ssl/src/nsSmartCardMonitor.cpp
diff -N security/manager/ssl/src/nsSmartCardMonitor.cpp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ security/manager/ssl/src/nsSmartCardMonitor.cpp	13 May 2005 17:58:31 -0000
@@ -0,0 +1,358 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Contributed by Red Hat Inc.
+ *
+ * The Initial Developer of the Original Code is
+ * Red Hat, Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#include "nspr.h"
+
+#include "pk11func.h"
+#include "nsNSSComponent.h"
+#include "nsSmartCardMonitor.h"
+#include "nsSmartCardEvent.h"
+
+//
+// The SmartCard monitoring thread should start up for each module we load
+// that has removable tokens. This code calls an NSS function which waits
+// until there is a change in the token state. NSS uses the 
+// C_WaitForSlotEvent() call in PKCS #11 if the module implements the call,
+// otherwise NSS will poll the token in a loop with a delay of 'latency' 
+// between polls. Note that the C_WaitForSlotEvent() may wake up on any type
+// of token event, so it's necessary to filter these events down to just the
+// insertion and removal events we are looking for.
+//
+// Once the event is found, It is passed to nsNSSComponent for dispatching
+// on the UI thread, and forwarding to any interested listeners (including
+// javascript).
+//
+
+
+static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
+
+#include <assert.h>
+
+// self linking and removing double linked entry
+// adopts the thread it is passed.
+class SmartCardThreadEntry {
+public:
+ SmartCardThreadEntry *next;
+ SmartCardThreadEntry *prev;
+ SmartCardThreadEntry **head;
+ SmartCardMonitoringThread *thread;
+ SmartCardThreadEntry(SmartCardMonitoringThread *thread_,
+   SmartCardThreadEntry *next_, SmartCardThreadEntry *prev_,
+   SmartCardThreadEntry **head_) : 
+   next(next_), prev(prev_), head(head_), thread(thread_) { 
+    if (prev) { prev->next = this; } else { *head = this; }
+    if (next) { next->prev = this; }
+  }
+  ~SmartCardThreadEntry() {
+    if (prev) { prev->next = next; } else { *head = next; }
+    if (next) { next->prev = prev; }
+    // NOTE: automatically stops the thread
+    delete thread;
+  }
+};
+
+//
+// SmartCardThreadList is a class to help manage the running threads.
+// That way new threads could be started and old ones terminated as we
+// load and unload modules.
+//
+SmartCardThreadList::SmartCardThreadList() : head(0)
+{
+}
+
+SmartCardThreadList::~SmartCardThreadList()
+{
+  // the head is self linking and unlinking, the following
+  // loop removes all entries on the list.
+  // it will also stop the thread if it happens to be running
+  while (head) {
+    delete head;
+  }
+}
+
+void
+SmartCardThreadList::Remove(SECMODModule *aModule)
+{
+  SmartCardThreadEntry *current;
+  for (current = head; current; current=current->next) {
+    if (current->thread->GetModule() == aModule) {
+      // NOTE: automatically stops the thread and dequeues it from the list
+      delete current;
+      return;
+    }
+  }
+}
+
+// adopts the thread passwd to it. Starts the thread as well
+nsresult
+SmartCardThreadList::Add(SmartCardMonitoringThread *thread)
+{
+  SmartCardThreadEntry *current = new SmartCardThreadEntry(thread, head, nsnull,
+                                                           &head);
+  if (current) {  
+     // OK to forget current here, it's on the list
+    return thread->Start();
+  }
+  return NS_ERROR_OUT_OF_MEMORY;
+}
+
+
+// We really should have a Unity PL Hash function...
+static PR_CALLBACK PLHashNumber
+unity(const void *key) { return (PLHashNumber)key; }
+
+SmartCardMonitoringThread::SmartCardMonitoringThread(SECMODModule *module_)
+  : mThread(nsnull)
+{
+  mModule = SECMOD_ReferenceModule(module_);
+  // simple hash functions, most modules have less than 3 slots, so 10 buckets
+  // should be plenty
+  mHash = PL_NewHashTable(10, unity, PL_CompareValues, 
+                           PL_CompareStrings, nsnull, 0);
+}
+
+//
+// when we shutdown the thread, be sure to stop it first. If not, it just might
+// crash when the mModule it is looking at disappears.
+//
+SmartCardMonitoringThread::~SmartCardMonitoringThread()
+{
+  Stop();
+  SECMOD_DestroyModule(mModule);
+  if (mHash) {
+    PL_HashTableDestroy(mHash);
+  }
+}
+
+nsresult
+SmartCardMonitoringThread::Start()
+{
+  if (!mThread) {
+    mThread = PR_CreateThread(PR_SYSTEM_THREAD, LaunchExecute, this,
+                              PR_PRIORITY_NORMAL, PR_LOCAL_THREAD,
+                              PR_JOINABLE_THREAD, 0);
+  }
+  return mThread ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+//
+// Should only stop if we are through with the module.
+// CancelWait has the side effect of losing all the keys and
+// current operations on the module!. (See the comment in
+// SECMOD_CancelWait for why this is so..).
+//
+void SmartCardMonitoringThread::Stop()
+{
+  SECStatus rv;
+
+  rv = SECMOD_CancelWait(mModule);
+  if (rv != SECSuccess) {
+    // we didn't wake up the Wait, so don't try to join the thread 
+    // otherwise we will hang forever...
+    return;
+  }
+ 
+  // confused about the memory model here? NSPR owns the memory for
+  // threads. non-joinable threads are freed when the thread dies.
+  // joinable threads are freed after the call to PR_JoinThread.
+  // That means if SECMOD_CancelWait fails, we'll leak the mThread
+  // structure. this is considered preferable to hanging (which is
+  // what will happen if we try to join a thread that blocked).
+  if (mThread) {
+    PR_JoinThread(mThread);
+    mThread = 0; 
+  }
+}
+
+//
+// remember the name and series of a token in a particular slot.
+// This is important because the name is no longer available when
+// the token is removed. If listeners depended on this information,
+// They would be out of luck. It also is a handy way of making sure
+// we don't generate spurious insertion and removal events as the slot
+// cycles through various states.
+//
+void
+SmartCardMonitoringThread::SetTokenName(CK_SLOT_ID slotid, 
+                                       const char *tokenName, PRUint32 series)
+{
+  if (mHash) {
+    if (tokenName) {
+      int len = strlen(tokenName) + 1;
+      char *entry = (char *)malloc(len+sizeof(PRUint32));
+     
+      if (entry) {  
+        memcpy(entry,&series,sizeof(PRUint32));
+        memcpy(&entry[sizeof(PRUint32)],tokenName,len);
+
+        PL_HashTableAdd(mHash,(void *)slotid, entry); /* adopt */
+        return;
+      }
+    } 
+    // if tokenName was not provided, remove the old one (implicit delete)
+    PL_HashTableRemove(mHash,(void *)slotid);
+  }
+}
+
+// retrieve the name saved above
+const char *
+SmartCardMonitoringThread::GetTokenName(CK_SLOT_ID slotid)
+{
+  const char *tokenName = nsnull;
+  const char *entry;
+
+  if (mHash) {
+    entry = (const char *)PL_HashTableLookupConst(mHash,(void *)slotid);
+    if (entry) {
+      tokenName = &entry[sizeof(PRUint32)];
+    }
+  }
+  return tokenName;
+}
+
+// retrieve the series saved in SetTokenName above
+PRUint32
+SmartCardMonitoringThread::GetTokenSeries(CK_SLOT_ID slotid)
+{
+  PRUint32 series = 0;
+  const char *entry;
+
+  if (mHash) {
+    entry = (const char *)PL_HashTableLookupConst(mHash,(void *)slotid);
+    if (entry) {
+      memcpy(&series,entry,sizeof(PRUint32));
+    }
+  }
+  return series;
+}
+
+//
+// helper function to pass the event off to nsNSSComponent.
+//
+nsresult
+SmartCardMonitoringThread::SendEvent(const nsAString &eventType,
+                                     const char *tokenName)
+{
+  nsresult rv;
+  nsCOMPtr<nsINSSComponent> 
+                    nssComponent(do_GetService(kNSSComponentCID, &rv));
+  if (NS_FAILED(rv))
+    return rv;
+
+  // NSS returns actual UTF8, not ASCII
+  nssComponent->PostEvent(eventType, NS_ConvertUTF8toUTF16(tokenName));
+  return NS_OK;
+}
+
+//
+// This is the main loop.
+//
+void SmartCardMonitoringThread::Execute()
+{
+  PK11SlotInfo *slot;
+  const char *tokenName = nsnull;
+
+  //
+  // populate token names for already inserted tokens.
+  //
+  PK11SlotList *sl =
+            PK11_FindSlotsByNames(mModule->dllName, nsnull, nsnull, PR_TRUE);
+  PK11SlotListElement *sle;
+ 
+  if (sl) {
+    for (sle=PK11_GetFirstSafe(sl); sle; 
+                                      sle=PK11_GetNextSafe(sl,sle,PR_FALSE)) {
+      SetTokenName(PK11_GetSlotID(sle->slot), 
+                  PK11_GetTokenName(sle->slot), PK11_GetSlotSeries(sle->slot));
+    }
+    PK11_FreeSlotList(sl);
+  }
+
+  // loop starts..
+  do {
+    slot = SECMOD_WaitForAnyTokenEvent(mModule, 0, PR_SecondsToInterval(1)  );
+    if (slot == nsnull) {
+      break;
+    }
+
+    // now we have a potential insertion or removal event, see if the slot
+    // is present to determine which it is...
+    if (PK11_IsPresent(slot)) {
+      // insertion
+      CK_SLOT_ID slotID = PK11_GetSlotID(slot);
+      PRUint32 series = PK11_GetSlotSeries(slot);
+
+      // skip spurious insertion events...
+      if (series != GetTokenSeries(slotID)) {
+        // if there's a token name, then we have not yet issued a remove
+        // event for the previous token, do so now...
+        tokenName = GetTokenName(slotID);
+        if (tokenName) {
+          SendEvent(NS_LITERAL_STRING(SMARTCARDEVENT_REMOVE), tokenName);
+        }
+        tokenName = PK11_GetTokenName(slot);
+        // save the token name and series
+        SetTokenName(slotID, tokenName, series);
+        SendEvent(NS_LITERAL_STRING(SMARTCARDEVENT_INSERT), tokenName);
+      }
+    } else {
+      // retrieve token name 
+      CK_SLOT_ID slotID = PK11_GetSlotID(slot);
+      tokenName = GetTokenName(slotID);
+      // if there's not a token name, then the software isn't expecting
+      // a (or another) remove event.
+      if (tokenName) {
+        SendEvent(NS_LITERAL_STRING(SMARTCARDEVENT_REMOVE), tokenName);
+        // clear the token name (after we send it)
+        SetTokenName(slotID, nsnull, 0);
+      }
+    }
+    PK11_FreeSlot(slot);
+
+  } while (1);
+}
+
+// accessor to help searching active Monitoring threads
+const SECMODModule * SmartCardMonitoringThread::GetModule() 
+{
+  return mModule;
+}
+
+// C-like calling sequence to glue into PR_CreateThread.
+void SmartCardMonitoringThread::LaunchExecute(void *arg)
+{
+  ((SmartCardMonitoringThread*)arg)->Execute();
+}
+
Index: security/manager/ssl/src/nsSmartCardMonitor.h
===================================================================
RCS file: security/manager/ssl/src/nsSmartCardMonitor.h
diff -N security/manager/ssl/src/nsSmartCardMonitor.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ security/manager/ssl/src/nsSmartCardMonitor.h	13 May 2005 17:58:31 -0000
@@ -0,0 +1,94 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Contributed by Red Hat Inc.
+ *
+ * The Initial Developer of the Original Code is
+ * Red Hat, Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef _NSSMARTCARDMONITOR_
+#define _NSSMARTCARDMONITOR_
+
+#include "prthread.h"
+#include "secmod.h"
+#include "plhash.h"
+#include "pkcs11t.h"
+
+class SmartCardThreadEntry;
+class SmartCardMonitoringThread;
+
+//
+// manage a group of SmartCardMonitoringThreads
+//
+class SmartCardThreadList {
+public:
+  SmartCardThreadList();
+  ~SmartCardThreadList();
+  void Remove(SECMODModule *module);
+  nsresult Add(SmartCardMonitoringThread *thread);
+private:
+  SmartCardThreadEntry *head;
+};
+
+//
+// monitor a Module for token insertion and removal
+//
+// NOTE: this provides the application the ability to dynamically add slots
+// on the fly as necessary.
+//
+class SmartCardMonitoringThread
+{
+ public:
+  SmartCardMonitoringThread(SECMODModule *module);
+  ~SmartCardMonitoringThread();
+  
+  nsresult Start();
+  void Stop();
+  
+  void Execute();
+  void Interrupt();
+  
+  const SECMODModule *GetModule();
+
+ private:
+
+  static void LaunchExecute(void *arg);
+  void SetTokenName(CK_SLOT_ID slotid, const char *tokenName, PRUint32 series);
+  const char *GetTokenName(CK_SLOT_ID slotid);
+  PRUint32 GetTokenSeries(CK_SLOT_ID slotid);
+  nsresult SendEvent(const nsAString &type,const char *tokenName);
+  
+  
+  SECMODModule *mModule;
+  PLHashTable *mHash;
+  PRThread* mThread;
+};
+
+#endif
