# HG changeset patch
# User timeless@mozdev.org
# Date 1239069092 -10800
# Node ID d123b215d30f1222326e06ae13ac6f6ab18cba45
# Parent a285146675dc126245856dcdc324b4f0264d0740
Bug 468736 - PSM nsPSMBackgroundThread::requestExit is racy and not threadsafe

diff --git a/security/manager/ssl/src/nsCertVerificationThread.cpp b/security/manager/ssl/src/nsCertVerificationThread.cpp
--- a/security/manager/ssl/src/nsCertVerificationThread.cpp
+++ b/security/manager/ssl/src/nsCertVerificationThread.cpp
@@ -127,24 +127,25 @@ nsresult nsCertVerificationThread::addJo
 void nsCertVerificationThread::Run(void)
 {
   while (PR_TRUE) {
 
     nsBaseVerificationJob *job = nsnull;
 
     {
       MutexAutoLock threadLock(verification_thread_singleton->mMutex);
-      
-      while (!mExitRequested && (0 == verification_thread_singleton->mJobQ.GetSize())) {
+
+      while (!exitRequested(threadLock) &&
+             0 == verification_thread_singleton->mJobQ.GetSize()) {
         // no work to do ? let's wait a moment
 
         mCond.Wait();
       }
       
-      if (mExitRequested)
+      if (exitRequested(threadLock))
         break;
       
       job = static_cast<nsBaseVerificationJob*>(mJobQ.PopFront());
     }
 
     if (job)
     {
       job->Run();
@@ -155,16 +156,17 @@ void nsCertVerificationThread::Run(void)
   {
     MutexAutoLock threadLock(verification_thread_singleton->mMutex);
 
     while (verification_thread_singleton->mJobQ.GetSize()) {
       nsCertVerificationJob *job = 
         static_cast<nsCertVerificationJob*>(mJobQ.PopFront());
       delete job;
     }
+    postStoppedEventToMainThread(threadLock);
   }
 }
 
 nsCertVerificationResult::nsCertVerificationResult()
 : mRV(0),
   mVerified(0),
   mCount(0),
   mUsages(0)
diff --git a/security/manager/ssl/src/nsNSSCallbacks.cpp b/security/manager/ssl/src/nsNSSCallbacks.cpp
--- a/security/manager/ssl/src/nsNSSCallbacks.cpp
+++ b/security/manager/ssl/src/nsNSSCallbacks.cpp
@@ -431,17 +431,17 @@ nsNSSHttpRequestSession::internal_send_r
 
       waitCondition.Wait(wait_interval);
       
       if (!waitFlag)
         break;
 
       if (!request_canceled)
       {
-        PRBool wantExit = nsSSLThread::exitRequested();
+        PRBool wantExit = nsSSLThread::stoppedOrStopping();
         PRBool timeout = 
           (PRIntervalTime)(PR_IntervalNow() - start_time) > mTimeoutInterval;
 
         if (wantExit || timeout)
         {
           request_canceled = PR_TRUE;
 
           nsRefPtr<nsCancelHTTPDownloadEvent> cancelevent = new nsCancelHTTPDownloadEvent;
diff --git a/security/manager/ssl/src/nsNSSComponent.cpp b/security/manager/ssl/src/nsNSSComponent.cpp
--- a/security/manager/ssl/src/nsNSSComponent.cpp
+++ b/security/manager/ssl/src/nsNSSComponent.cpp
@@ -387,34 +387,62 @@ nsNSSComponent::nsNSSComponent()
 
   NS_ASSERTION( (0 == mInstanceCount), "nsNSSComponent is a singleton, but instantiated multiple times!");
   ++mInstanceCount;
   hashTableCerts = nsnull;
   mShutdownObjectList = nsNSSShutDownList::construct();
   mIsNetworkDown = PR_FALSE;
 }
 
-nsNSSComponent::~nsNSSComponent()
+void 
+nsNSSComponent::deleteBackgroundThreads()
 {
   if (mSSLThread)
   {
     mSSLThread->requestExit();
     delete mSSLThread;
     mSSLThread = nsnull;
   }
-  
   if (mCertVerificationThread)
   {
     mCertVerificationThread->requestExit();
     delete mCertVerificationThread;
     mCertVerificationThread = nsnull;
   }
-
+}
+
+void
+nsNSSComponent::createBackgroundThreads()
+{
+  NS_ASSERTION(mSSLThread == nsnull, "SSL thread already created.");
+  NS_ASSERTION(mCertVerificationThread == nsnull,
+               "Cert verification thread already created.");
+
+  mSSLThread = new nsSSLThread;
+  nsresult rv = mSSLThread->startThread();
+  if (NS_FAILED(rv)) {
+    delete mSSLThread;
+    mSSLThread = nsnull;
+    return;
+  }
+
+  mCertVerificationThread = new nsCertVerificationThread;
+  rv = mCertVerificationThread->startThread();
+  if (NS_FAILED(rv)) {
+    delete mCertVerificationThread;
+    mCertVerificationThread = nsnull;
+  }
+}
+
+nsNSSComponent::~nsNSSComponent()
+{
   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent::dtor\n"));
 
+  deleteBackgroundThreads();
+
   if (mUpdateTimerInitialized) {
     {
       MutexAutoLock lock(mCrlTimerLock);
       if (crlDownloadTimerOn) {
         mTimer->Cancel();
       }
       crlDownloadTimerOn = PR_FALSE;
     }
@@ -2002,23 +2030,17 @@ nsNSSComponent::Init()
   PRInt32 warnLevel = 1;
   mPrefBranch->GetIntPref("security.ssl.warn_missing_rfc5746", &warnLevel);
   nsSSLIOLayerHelpers::setWarnLevelMissingRFC5746(warnLevel);
   
   mClientAuthRememberService = new nsClientAuthRememberService;
   if (mClientAuthRememberService)
     mClientAuthRememberService->Init();
 
-  mSSLThread = new nsSSLThread();
-  if (mSSLThread)
-    mSSLThread->startThread();
-  mCertVerificationThread = new nsCertVerificationThread();
-  if (mCertVerificationThread)
-    mCertVerificationThread->startThread();
-
+  createBackgroundThreads();
   if (!mSSLThread || !mCertVerificationThread)
   {
     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NSS init, could not create threads\n"));
 
     DeregisterObservers();
     mPIPNSSBundle = nsnull;
     return NS_ERROR_OUT_OF_MEMORY;
   }
@@ -2620,24 +2642,19 @@ nsNSSComponent::DoProfileBeforeChange(ns
     }
   }
   mShutdownObjectList->allowUI();
 }
 
 void
 nsNSSComponent::DoProfileChangeNetRestore()
 {
-  delete mSSLThread;
-  mSSLThread = new nsSSLThread();
-  if (mSSLThread)
-    mSSLThread->startThread();
-  delete mCertVerificationThread;
-  mCertVerificationThread = new nsCertVerificationThread();
-  if (mCertVerificationThread)
-    mCertVerificationThread->startThread();
+  /* XXX this doesn't work well, since nothing expects null pointers */
+  deleteBackgroundThreads();
+  createBackgroundThreads();
   mIsNetworkDown = PR_FALSE;
 }
 
 NS_IMETHODIMP
 nsNSSComponent::GetClientAuthRememberService(nsClientAuthRememberService **cars)
 {
   NS_ENSURE_ARG_POINTER(cars);
   NS_IF_ADDREF(*cars = mClientAuthRememberService);
diff --git a/security/manager/ssl/src/nsNSSComponent.h b/security/manager/ssl/src/nsNSSComponent.h
--- a/security/manager/ssl/src/nsNSSComponent.h
+++ b/security/manager/ssl/src/nsNSSComponent.h
@@ -352,18 +352,22 @@ private:
   Mutex mCrlTimerLock;
   nsHashtable *crlsScheduledForDownload;
   PRBool crlDownloadTimerOn;
   PRBool mUpdateTimerInitialized;
   static int mInstanceCount;
   nsNSSShutDownList *mShutdownObjectList;
   SmartCardThreadList *mThreadList;
   PRBool mIsNetworkDown;
+
+  void deleteBackgroundThreads();
+  void createBackgroundThreads();
   nsSSLThread *mSSLThread;
   nsCertVerificationThread *mCertVerificationThread;
+
   nsNSSHttpInterface mHttpForNSS;
   nsRefPtr<nsClientAuthRememberService> mClientAuthRememberService;
   nsRefPtr<nsCERTValInParamWrapper> mDefaultCERTValInParam;
   nsRefPtr<nsCERTValInParamWrapper> mDefaultCERTValInParamLocalOnly;
 
   static PRStatus PR_CALLBACK IdentityInfoInit(void);
   PRCallOnceType mIdentityInfoCallOnce;
 
diff --git a/security/manager/ssl/src/nsNSSIOLayer.cpp b/security/manager/ssl/src/nsNSSIOLayer.cpp
--- a/security/manager/ssl/src/nsNSSIOLayer.cpp
+++ b/security/manager/ssl/src/nsNSSIOLayer.cpp
@@ -355,17 +355,17 @@ nsNSSSocketInfo::SetNotificationCallback
 }
 
 nsresult
 nsNSSSocketInfo::EnsureDocShellDependentStuffKnown()
 {
   if (mDocShellDependentStuffKnown)
     return NS_OK;
 
-  if (!mCallbacks || nsSSLThread::exitRequested())
+  if (!mCallbacks || nsSSLThread::stoppedOrStopping())
     return NS_ERROR_FAILURE;
 
   mDocShellDependentStuffKnown = PR_TRUE;
 
   nsCOMPtr<nsIInterfaceRequestor> proxiedCallbacks;
   NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
                        NS_GET_IID(nsIInterfaceRequestor),
                        static_cast<nsIInterfaceRequestor*>(mCallbacks),
@@ -562,17 +562,17 @@ NS_IMETHODIMP nsNSSSocketInfo::GetInterf
   nsresult rv;
   if (!mCallbacks) {
     nsCOMPtr<nsIInterfaceRequestor> ir = new PipUIContext();
     if (!ir)
       return NS_ERROR_OUT_OF_MEMORY;
 
     rv = ir->GetInterface(uuid, result);
   } else {
-    if (nsSSLThread::exitRequested())
+    if (nsSSLThread::stoppedOrStopping())
       return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIInterfaceRequestor> proxiedCallbacks;
     NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
                          NS_GET_IID(nsIInterfaceRequestor),
                          mCallbacks,
                          NS_PROXY_SYNC,
                          getter_AddRefs(proxiedCallbacks));
@@ -1408,17 +1408,17 @@ getInvalidCertErrorMessage(PRUint32 mult
 }
 
 static nsresult
 displayAlert(nsAFlatString &formattedString, nsNSSSocketInfo *infoObject)
 {
   // The interface requestor object may not be safe, so proxy the call to get
   // the nsIPrompt.
 
-  if (nsSSLThread::exitRequested())
+  if (nsSSLThread::stoppedOrStopping())
     return NS_ERROR_FAILURE;
 
   nsCOMPtr<nsIInterfaceRequestor> proxiedCallbacks;
   NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
                        NS_GET_IID(nsIInterfaceRequestor),
                        static_cast<nsIInterfaceRequestor*>(infoObject),
                        NS_PROXY_SYNC,
                        getter_AddRefs(proxiedCallbacks));
@@ -1445,17 +1445,17 @@ nsHandleSSLError(nsNSSSocketInfo *socket
 {
   if (socketInfo->GetCanceled()) {
     // If the socket has been flagged as canceled,
     // the code who did was responsible for showing
     // an error message (if desired).
     return NS_OK;
   }
 
-  if (nsSSLThread::exitRequested()) {
+  if (nsSSLThread::stoppedOrStopping()) {
     return NS_ERROR_FAILURE;
   }
 
   nsresult rv;
   NS_DEFINE_CID(nssComponentCID, NS_NSSCOMPONENT_CID);
   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(nssComponentCID, &rv));
   if (NS_FAILED(rv))
     return rv;
@@ -3349,17 +3349,17 @@ nsNSSBadCertHandler(void *arg, PRFileDes
   if (PR_GetError() == SEC_ERROR_REVOKED_CERTIFICATE)
     return SECFailure;
 
   nsNSSShutDownPreventionLock locker;
   nsNSSSocketInfo* infoObject = (nsNSSSocketInfo *)arg;
   if (!infoObject)
     return SECFailure;
 
-  if (nsSSLThread::exitRequested())
+  if (nsSSLThread::stoppedOrStopping())
     return cancel_and_failure(infoObject);
 
   CERTCertificate *peerCert = nsnull;
   CERTCertificateCleaner peerCertCleaner(peerCert);
   peerCert = SSL_PeerCertificate(sslSocket);
   if (!peerCert)
     return cancel_and_failure(infoObject);
 
diff --git a/security/manager/ssl/src/nsPSMBackgroundThread.cpp b/security/manager/ssl/src/nsPSMBackgroundThread.cpp
--- a/security/manager/ssl/src/nsPSMBackgroundThread.cpp
+++ b/security/manager/ssl/src/nsPSMBackgroundThread.cpp
@@ -31,30 +31,31 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsPSMBackgroundThread.h"
+#include "nsThreadUtils.h"
 
 using namespace mozilla;
 
 void PR_CALLBACK nsPSMBackgroundThread::nsThreadRunner(void *arg)
 {
   nsPSMBackgroundThread *self = static_cast<nsPSMBackgroundThread *>(arg);
   self->Run();
 }
 
 nsPSMBackgroundThread::nsPSMBackgroundThread()
 : mThreadHandle(nsnull),
   mMutex("nsPSMBackgroundThread.mMutex"),
   mCond(mMutex, "nsPSMBackgroundThread.mCond"),
-  mExitRequested(PR_FALSE)
+  mExitState(ePSMThreadRunning)
 {
 }
 
 nsresult nsPSMBackgroundThread::startThread()
 {
   mThreadHandle = PR_CreateThread(PR_USER_THREAD, nsThreadRunner, static_cast<void*>(this), 
     PR_PRIORITY_NORMAL, PR_LOCAL_THREAD, PR_JOINABLE_THREAD, 0);
 
@@ -65,26 +66,55 @@ nsresult nsPSMBackgroundThread::startThr
 
   return NS_OK;
 }
 
 nsPSMBackgroundThread::~nsPSMBackgroundThread()
 {
 }
 
+PRBool
+nsPSMBackgroundThread::exitRequested(const MutexAutoLock & /*proofOfLock*/) const
+{
+  return exitRequestedNoLock();
+}
+
+nsresult
+nsPSMBackgroundThread::postStoppedEventToMainThread(
+    MutexAutoLock const & /*proofOfLock*/)
+{
+  NS_ASSERTION(PR_GetCurrentThread() == mThreadHandle,
+               "Background thread stopped from another thread");
+
+  mExitState = ePSMThreadStopped;
+  // requestExit is waiting for an event, so give it one.
+  return NS_DispatchToMainThread(new nsRunnable());
+}
+
 void nsPSMBackgroundThread::requestExit()
 {
+  NS_ASSERTION(NS_IsMainThread(),
+               "nsPSMBackgroundThread::requestExit called off main thread.");
+
   if (!mThreadHandle)
     return;
 
   {
     MutexAutoLock threadLock(mMutex);
-
-    if (mExitRequested)
-      return;
-
-    mExitRequested = PR_TRUE;
-    mCond.NotifyAll();
+    if (mExitState < ePSMThreadStopRequested) {
+      mExitState = ePSMThreadStopRequested;
+      mCond.NotifyAll();
+    }
+  }
+  
+  nsCOMPtr<nsIThread> mainThread = do_GetCurrentThread();
+  for (;;) {
+    {
+      MutexAutoLock threadLock(mMutex);
+      if (mExitState == ePSMThreadStopped)
+        break;
+    }
+    NS_ProcessPendingEvents(mainThread, PR_MillisecondsToInterval(50));
   }
 
   PR_JoinThread(mThreadHandle);
   mThreadHandle = nsnull;
 }
diff --git a/security/manager/ssl/src/nsPSMBackgroundThread.h b/security/manager/ssl/src/nsPSMBackgroundThread.h
--- a/security/manager/ssl/src/nsPSMBackgroundThread.h
+++ b/security/manager/ssl/src/nsPSMBackgroundThread.h
@@ -37,37 +37,47 @@
 
 #ifndef _NSPSMBACKGROUNDTHREAD_H_
 #define _NSPSMBACKGROUNDTHREAD_H_
 
 #include "nspr.h"
 #include "nscore.h"
 #include "mozilla/CondVar.h"
 #include "mozilla/Mutex.h"
+#include "nsNSSComponent.h"
 
 class nsPSMBackgroundThread
 {
 protected:
   static void PR_CALLBACK nsThreadRunner(void *arg);
   virtual void Run(void) = 0;
 
   // used to join the thread
   PRThread *mThreadHandle;
 
   // Shared mutex used for condition variables,
-  // and to protect access to mExitRequested.
+  // and to protect access to mExitState.
   // Derived classes may use it to protect additional
   // resources.
   mozilla::Mutex mMutex;
 
-  // Used to signal the thread's Run loop
+  // Used to signal the thread's Run loop when a job is added 
+  // and/or exit is requested.
   mozilla::CondVar mCond;
 
-  // Has termination of the SSL thread been requested?
-  PRBool mExitRequested;
+  PRBool exitRequested(::mozilla::MutexAutoLock const & proofOfLock) const;
+  PRBool exitRequestedNoLock() const { return mExitState != ePSMThreadRunning; }
+  nsresult postStoppedEventToMainThread(::mozilla::MutexAutoLock const & proofOfLock);
+
+private:
+  enum {
+    ePSMThreadRunning = 0,
+    ePSMThreadStopRequested = 1,
+    ePSMThreadStopped = 2
+  } mExitState;
 
 public:
   nsPSMBackgroundThread();
   virtual ~nsPSMBackgroundThread();
 
   nsresult startThread();
   void requestExit();
 };
diff --git a/security/manager/ssl/src/nsSSLThread.cpp b/security/manager/ssl/src/nsSSLThread.cpp
--- a/security/manager/ssl/src/nsSSLThread.cpp
+++ b/security/manager/ssl/src/nsSSLThread.cpp
@@ -505,17 +505,17 @@ PRInt32 nsSSLThread::requestRead(nsNSSSo
   PRBool this_socket_is_busy = PR_FALSE;
   PRBool some_other_socket_is_busy = PR_FALSE;
   nsSSLSocketThreadData::ssl_state my_ssl_state = nsSSLSocketThreadData::ssl_invalid;
   PRFileDesc *blockingFD = nsnull;
 
   {
     MutexAutoLock threadLock(ssl_thread_singleton->mMutex);
 
-    if (ssl_thread_singleton->mExitRequested) {
+    if (ssl_thread_singleton->exitRequested(threadLock)) {
       PR_SetError(PR_UNKNOWN_ERROR, 0);
       return -1;
     }
 
     if (getRealFDIfBlockingSocket_locked(si, blockingFD) == PR_FAILURE) {
       return -1;
     }
 
@@ -732,17 +732,17 @@ PRInt32 nsSSLThread::requestWrite(nsNSSS
   PRBool this_socket_is_busy = PR_FALSE;
   PRBool some_other_socket_is_busy = PR_FALSE;
   nsSSLSocketThreadData::ssl_state my_ssl_state = nsSSLSocketThreadData::ssl_invalid;
   PRFileDesc *blockingFD = nsnull;
   
   {
     MutexAutoLock threadLock(ssl_thread_singleton->mMutex);
     
-    if (ssl_thread_singleton->mExitRequested) {
+    if (ssl_thread_singleton->exitRequested(threadLock)) {
       PR_SetError(PR_UNKNOWN_ERROR, 0);
       return -1;
     }
 
     if (getRealFDIfBlockingSocket_locked(si, blockingFD) == PR_FAILURE) {
       return -1;
     }
 
@@ -953,17 +953,17 @@ void nsSSLThread::Run(void)
           mBusySocket = nsnull;
         }
       
         socketToDestroy = mSocketScheduledToBeDestroyed;
         mSocketScheduledToBeDestroyed = nsnull;
         continue; // go back and finally destroy it, before doing anything else
       }
 
-      if (mExitRequested)
+      if (exitRequested(threadLock))
         break;
 
       PRBool pending_work = PR_FALSE;
 
       do
       {
         if (mBusySocket
             &&
@@ -976,22 +976,23 @@ void nsSSLThread::Run(void)
 
         if (!pending_work)
         {
           // no work to do ? let's wait a moment
 
           mCond.Wait();
         }
         
-      } while (!pending_work && !mExitRequested && !mSocketScheduledToBeDestroyed);
+      } while (!pending_work && !exitRequested(threadLock) &&
+               !mSocketScheduledToBeDestroyed);
       
       if (mSocketScheduledToBeDestroyed)
         continue;
       
-      if (mExitRequested)
+      if (exitRequested(threadLock))
         break;
       
       if (!pending_work)
         continue;
       
       busy_socket_ssl_state = mBusySocket->mThreadData->mSSLState;
     }
 
@@ -1129,22 +1130,21 @@ void nsSSLThread::Run(void)
     if (!nsSSLIOLayerHelpers::mPollableEventCurrentlySet)
     {
       nsSSLIOLayerHelpers::mPollableEventCurrentlySet = PR_TRUE;
       if (nsSSLIOLayerHelpers::mSharedPollableEvent)
       {
         PR_SetPollableEvent(nsSSLIOLayerHelpers::mSharedPollableEvent);
       }
     }
+    postStoppedEventToMainThread(threadLock);
   }
 }
 
-PRBool nsSSLThread::exitRequested()
+PRBool nsSSLThread::stoppedOrStopping()
 {
   if (!ssl_thread_singleton)
     return PR_FALSE;
 
-  // no lock
-
-  return ssl_thread_singleton->mExitRequested;
+  return ssl_thread_singleton->exitRequestedNoLock();
 }
 
 nsSSLThread *nsSSLThread::ssl_thread_singleton = nsnull;
diff --git a/security/manager/ssl/src/nsSSLThread.h b/security/manager/ssl/src/nsSSLThread.h
--- a/security/manager/ssl/src/nsSSLThread.h
+++ b/security/manager/ssl/src/nsSSLThread.h
@@ -147,12 +147,12 @@ public:
   static PRStatus requestSetsocketoption(nsNSSSocketInfo *si, 
                                          const PRSocketOptionData *data);
 
   static PRStatus requestConnectcontinue(nsNSSSocketInfo *si, 
                                          PRInt16 out_flags);
 
   static nsresult requestActivateSSL(nsNSSSocketInfo *si);
   
-  static PRBool exitRequested();
+  static PRBool stoppedOrStopping();
 };
 
 #endif //_NSSSLTHREAD_H_
