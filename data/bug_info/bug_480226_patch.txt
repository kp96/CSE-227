Fix const warnings in security/manager/ssl/

diff --git a/security/manager/ssl/src/nsCrypto.cpp b/security/manager/ssl/src/nsCrypto.cpp
--- a/security/manager/ssl/src/nsCrypto.cpp
+++ b/security/manager/ssl/src/nsCrypto.cpp
@@ -2258,17 +2258,16 @@ nsCertListCount(CERTCertList *certList)
 NS_IMETHODIMP
 nsCrypto::ImportUserCertificates(const nsAString& aNickname, 
                                  const nsAString& aCmmfResponse, 
                                  PRBool aDoForcedBackup, 
                                  nsAString& aReturn)
 {
   nsNSSShutDownPreventionLock locker;
   char *nickname=nsnull, *cmmfResponse=nsnull;
-  char *retString=nsnull;
   CMMFCertRepContent *certRepContent = nsnull;
   int numResponses = 0;
   nsIX509Cert **certArr = nsnull;
   int i;
   CMMFCertResponse *currResponse;
   CMMFPKIStatus reqStatus;
   CERTCertificate *currCert;
   PK11SlotInfo *slot;
@@ -2377,18 +2376,16 @@ nsCrypto::ImportUserCertificates(const n
 
     PK11_FreeSlot(slot);
     CMMF_DestroyCertResponse(currResponse);
   }
   //Let the loser: label take care of freeing up our reference to
   //nickname (This way we don't free it twice and avoid crashing.
   //That would be a good thing.
 
-  retString = "";
-
   //Import the root chain into the cert db.
   caPubs = CMMF_CertRepContentGetCAPubs(certRepContent);
   if (caPubs) {
     PRInt32 numCAs = nsCertListCount(caPubs);
     
     NS_ASSERTION(numCAs > 0, "Invalid number of CA's");
     if (numCAs > 0) {
       CERTCertListNode *node;
@@ -2435,17 +2432,17 @@ nsCrypto::ImportUserCertificates(const n
 
  loser:
   if (certArr) {
     for (i=0; i<numResponses; i++) {
       NS_IF_RELEASE(certArr[i]);
     }
     delete []certArr;
   }
-  aReturn.Assign(NS_ConvertASCIItoUTF16(retString));
+  aReturn.Assign(EmptyString());
   if (nickname) {
     NS_Free(nickname);
   }
   if (cmmfResponse) {
     NS_Free(cmmfResponse);
   }
   if (certRepContent) {
     CMMF_DestroyCertRepContent(certRepContent);
diff --git a/security/manager/ssl/src/nsKeygenHandler.cpp b/security/manager/ssl/src/nsKeygenHandler.cpp
--- a/security/manager/ssl/src/nsKeygenHandler.cpp
+++ b/security/manager/ssl/src/nsKeygenHandler.cpp
@@ -165,17 +165,17 @@ pqg_prime_bits(char *str)
 
 done:
     if (params)
         PK11_PQG_DestroyParams(params);
     return primeBits;
 }
 
 typedef struct curveNameTagPairStr {
-    char *curveName;
+    const char *curveName;
     SECOidTag curveOidTag;
 } CurveNameTagPair;
 
 static CurveNameTagPair nameTagPair[] =
 { 
   { "prime192v1", SEC_OID_ANSIX962_EC_PRIME192V1 },
   { "prime192v2", SEC_OID_ANSIX962_EC_PRIME192V2 },
   { "prime192v3", SEC_OID_ANSIX962_EC_PRIME192V3 },
@@ -253,17 +253,17 @@ static CurveNameTagPair nameTagPair[] =
   { "sect571k1", SEC_OID_SECG_EC_SECT571K1},
   { "nistk571", SEC_OID_SECG_EC_SECT571K1},
   { "sect571r1", SEC_OID_SECG_EC_SECT571R1},
   { "nistb571", SEC_OID_SECG_EC_SECT571R1},
 
 };
 
 SECKEYECParams * 
-decode_ec_params(char *curve)
+decode_ec_params(const char *curve)
 {
     SECKEYECParams *ecparams;
     SECOidData *oidData = NULL;
     SECOidTag curveOidTag = SEC_OID_UNKNOWN; /* default */
     int i, numCurves;
 
     if (curve && *curve) {
         numCurves = sizeof(nameTagPair)/sizeof(CurveNameTagPair);
diff --git a/security/manager/ssl/src/nsKeygenHandler.h b/security/manager/ssl/src/nsKeygenHandler.h
--- a/security/manager/ssl/src/nsKeygenHandler.h
+++ b/security/manager/ssl/src/nsKeygenHandler.h
@@ -46,17 +46,17 @@
 
 nsresult GetSlotWithMechanism(PRUint32 mechanism,
                               nsIInterfaceRequestor *ctx,
                               PK11SlotInfo **retSlot);
 
 #define DEFAULT_RSA_KEYGEN_PE 65537L
 #define DEFAULT_RSA_KEYGEN_ALG SEC_OID_PKCS1_MD5_WITH_RSA_ENCRYPTION
 
-SECKEYECParams *decode_ec_params(char *curve);
+SECKEYECParams *decode_ec_params(const char *curve);
 
 class nsKeygenFormProcessor : public nsIFormProcessor { 
 public: 
   nsKeygenFormProcessor(); 
   virtual ~nsKeygenFormProcessor();
   nsresult Init();
 
   NS_IMETHOD ProcessValue(nsIDOMHTMLElement *aElement, 
