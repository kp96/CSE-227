? mozilla/security/manager/ssl/src/nsSSLThread.cpp-good
Index: mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp,v
retrieving revision 1.97.2.13
diff -u -r1.97.2.13 nsNSSIOLayer.cpp
--- mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp	7 Sep 2006 18:39:48 -0000	1.97.2.13
+++ mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp	10 Oct 2006 16:35:01 -0000
@@ -69,6 +69,7 @@
 #include "nsSSLThread.h"
 #include "nsNSSShutDown.h"
 #include "nsNSSCertHelper.h"
+#include "nsNSSCleaner.h"
 
 #include "ssl.h"
 #include "secerr.h"
@@ -89,6 +90,8 @@
                        //we always write out to our own
                        //file.
 
+NSSCleanupAutoPtrClass(CERTCertificate, CERT_DestroyCertificate)
+
 /* SSM_UserCertChoice: enum for cert choice info */
 typedef enum {ASK, AUTO} SSM_UserCertChoice;
 
@@ -2096,6 +2099,26 @@
 	return ret;
 }
 
+static PRBool hasExplicitKeyUsageNonRepudiation(CERTCertificate *cert)
+{
+  /* There is no extension, v1 or v2 certificate */
+  if (!cert->extensions)
+    return PR_FALSE;
+
+  SECStatus srv;
+  SECItem keyUsageItem;
+  keyUsageItem.data = NULL;
+
+  srv = CERT_FindKeyUsageExtension(cert, &keyUsageItem);
+  if (srv == SECFailure)
+    return PR_FALSE;
+
+  unsigned char keyUsage = keyUsageItem.data[0];
+  PORT_Free (keyUsageItem.data);
+
+  return (keyUsage & KU_NON_REPUDIATION);
+}
+
 /*
  * Function: SECStatus SSM_SSLGetClientAuthData()
  * Purpose: this callback function is used to pull client certificate
@@ -2179,7 +2202,7 @@
 
     /* find all user certs that are valid and for SSL */
     certList = CERT_FindUserCertsByUsage(CERT_GetDefaultCertDB(), 
-                                         certUsageSSLClient, PR_TRUE,
+                                         certUsageSSLClient, PR_FALSE,
                                          PR_TRUE, wincx);
     if (certList == NULL) {
       goto noCert;
@@ -2198,6 +2221,9 @@
       goto noCert;
     }
 
+    CERTCertificate* low_prio_nonrep_cert = NULL;
+    CERTCertificateCleaner low_prio_cleaner(low_prio_nonrep_cert);
+
     /* loop through the list until we find a cert with a key */
     while (!CERT_LIST_END(node, certList)) {
       /* if the certificate has restriction and we do not satisfy it
@@ -2213,9 +2239,16 @@
 
       privKey = PK11_FindKeyByAnyCert(node->cert, wincx);
       if (privKey != NULL) {
-          /* this is a good cert to present */
+        if (hasExplicitKeyUsageNonRepudiation(node->cert)) {
+          // Not a prefered cert
+          if (!low_prio_nonrep_cert) // did not yet find a low prio cert
+            low_prio_nonrep_cert = CERT_DupCertificate(node->cert);
+        }
+        else {
+          // this is a good cert to present
           cert = CERT_DupCertificate(node->cert);
           break;
+        }
       }
       keyError = PR_GetError();
       if (keyError == SEC_ERROR_BAD_PASSWORD) {
@@ -2226,6 +2259,11 @@
       node = CERT_LIST_NEXT(node);
     }
 
+    if (!cert && low_prio_nonrep_cert) {
+      cert = low_prio_nonrep_cert;
+      low_prio_nonrep_cert = NULL; // take it away from the cleaner
+    }
+
     if (cert == NULL) {
         goto noCert;
     }
@@ -2341,6 +2379,9 @@
       if (NS_FAILED(tempCert->FormatUIStrings(i_nickname, nickWithSerial, details)))
         continue;
 
+      if (hasExplicitKeyUsageNonRepudiation(node->cert))
+        nickWithSerial.Append(NS_LITERAL_STRING(" [NR]"));
+
       certNicknameList[CertsToUse] = ToNewUnicode(nickWithSerial);
       if (!certNicknameList[CertsToUse])
         continue;
