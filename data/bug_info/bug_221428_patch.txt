Index: netwerk/base/public/nsURIHashKey.h
===================================================================
RCS file: /cvsroot/mozilla/netwerk/base/public/nsURIHashKey.h,v
retrieving revision 1.6
diff -u -p -d -8 -r1.6 nsURIHashKey.h
--- netwerk/base/public/nsURIHashKey.h	27 Mar 2007 15:35:01 -0000	1.6
+++ netwerk/base/public/nsURIHashKey.h	28 Mar 2007 16:10:20 -0000
@@ -72,13 +72,13 @@ public:
     static PLDHashNumber HashKey(const nsIURI* aKey) {
         nsCAutoString spec;
         NS_CONST_CAST(nsIURI*,aKey)->GetSpec(spec);
         return nsCRT::HashCode(spec.get());
     }
     
     enum { ALLOW_MEMMOVE = PR_TRUE };
 
-private:
+protected:
     nsCOMPtr<nsIURI> mKey;
 };
 
 #endif // nsURIHashKey_h__
Index: layout/style/nsICSSStyleSheet.h
===================================================================
RCS file: /cvsroot/mozilla/layout/style/nsICSSStyleSheet.h,v
retrieving revision 3.39
diff -u -p -d -8 -r3.39 nsICSSStyleSheet.h
--- layout/style/nsICSSStyleSheet.h	25 Mar 2006 05:47:30 -0000	3.39
+++ layout/style/nsICSSStyleSheet.h	4 Feb 2007 06:14:42 -0000
@@ -45,21 +45,23 @@
 
 class nsICSSRule;
 class nsIDOMNode;
 class nsXMLNameSpaceMap;
 class nsCSSRuleProcessor;
 class nsMediaList;
 class nsICSSGroupRule;
 class nsICSSImportRule;
+class nsIPrincipal;
 
 // IID for the nsICSSStyleSheet interface
-// 446df065-af5e-46b8-b32f-289bf5906876
+// 36541c18-e735-48ef-8622-3a481275b757
 #define NS_ICSS_STYLE_SHEET_IID     \
-{0x446df065, 0xaf5e, 0x46b8, {0xb3, 0x2f, 0x28, 0x9b, 0xf5, 0x90, 0x68, 0x76}}
+{ 0x36541c18, 0xe735, 0x48ef, \
+ { 0x86, 0x22, 0x3a, 0x48, 0x12, 0x75, 0xb7, 0x57 } }
 
 class nsICSSStyleSheet : public nsIStyleSheet {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICSS_STYLE_SHEET_IID)
 
   NS_IMETHOD  ContainsStyleSheet(nsIURI* aURL, PRBool& aContains, nsIStyleSheet** aTheChild=nsnull) = 0;
 
   NS_IMETHOD  AppendStyleSheet(nsICSSStyleSheet* aSheet) = 0;
@@ -81,16 +83,27 @@ public:
   NS_IMETHOD  GetStyleSheetAt(PRInt32 aIndex, nsICSSStyleSheet*& aSheet) const = 0;
 
   /**
    * SetURIs must be called on all sheets before parsing into them.
    * SetURIs may only be called while the sheet is 1) incomplete and 2)
    * has no rules in it
    */
   NS_IMETHOD  SetURIs(nsIURI* aSheetURI, nsIURI* aBaseURI) = 0;
+
+  /**
+   * SetPrincipal should be called on all sheets before parsing into them.
+   * This can only be called once with a non-null principal.  Calling this with
+   * a null pointer is allowed and is treated as a no-op.
+   */
+  virtual NS_HIDDEN_(void) SetPrincipal(nsIPrincipal* aPrincipal) = 0;
+
+  // Principal() never returns a null pointer.
+  virtual NS_HIDDEN_(nsIPrincipal*) Principal() const = 0;
+  
   NS_IMETHOD  SetTitle(const nsAString& aTitle) = 0;
   NS_IMETHOD  SetMedia(nsMediaList* aMedia) = 0;
   NS_IMETHOD  SetOwningNode(nsIDOMNode* aOwningNode) = 0;
 
   NS_IMETHOD  SetOwnerRule(nsICSSImportRule* aOwnerRule) = 0;
   NS_IMETHOD  GetOwnerRule(nsICSSImportRule** aOwnerRule) = 0;
   
   // get namespace map for sheet
Index: layout/style/nsCSSStyleSheet.h
===================================================================
RCS file: /cvsroot/mozilla/layout/style/nsCSSStyleSheet.h,v
retrieving revision 1.9
diff -u -p -d -8 -r1.9 nsCSSStyleSheet.h
--- layout/style/nsCSSStyleSheet.h	25 Mar 2006 05:47:30 -0000	1.9
+++ layout/style/nsCSSStyleSheet.h	4 Feb 2007 06:14:42 -0000
@@ -70,19 +70,24 @@ public:
   virtual void AddSheet(nsICSSStyleSheet* aParentSheet);
   virtual void RemoveSheet(nsICSSStyleSheet* aParentSheet);
 
   virtual void RebuildNameSpaces();
 
   nsAutoVoidArray        mSheets;
   nsCOMPtr<nsIURI>       mSheetURI; // for error reports, etc.
   nsCOMPtr<nsIURI>       mBaseURI; // for resolving relative URIs
+  nsCOMPtr<nsIPrincipal> mPrincipal;
   nsCOMArray<nsICSSRule> mOrderedRules;
   nsAutoPtr<nsXMLNameSpaceMap> mNameSpaceMap;
-  PRPackedBool           mComplete;
+  PRBool                 mComplete;
+
+#ifdef DEBUG
+  PRBool                 mPrincipalSet;
+#endif
 };
 
 
 // -------------------------------
 // CSS Style Sheet
 //
 
 class CSSImportsCollectionImpl;
@@ -127,16 +132,18 @@ public:
   NS_IMETHOD StyleRuleCount(PRInt32& aCount) const;
   NS_IMETHOD GetStyleRuleAt(PRInt32 aIndex, nsICSSRule*& aRule) const;
   NS_IMETHOD DeleteRuleFromGroup(nsICSSGroupRule* aGroup, PRUint32 aIndex);
   NS_IMETHOD InsertRuleIntoGroup(const nsAString& aRule, nsICSSGroupRule* aGroup, PRUint32 aIndex, PRUint32* _retval);
   NS_IMETHOD ReplaceRuleInGroup(nsICSSGroupRule* aGroup, nsICSSRule* aOld, nsICSSRule* aNew);
   NS_IMETHOD StyleSheetCount(PRInt32& aCount) const;
   NS_IMETHOD GetStyleSheetAt(PRInt32 aIndex, nsICSSStyleSheet*& aSheet) const;
   NS_IMETHOD SetURIs(nsIURI* aSheetURI, nsIURI* aBaseURI);
+  virtual NS_HIDDEN_(void) SetPrincipal(nsIPrincipal* aPrincipal);
+  virtual NS_HIDDEN_(nsIPrincipal*) Principal() const;
   NS_IMETHOD SetTitle(const nsAString& aTitle);
   NS_IMETHOD SetMedia(nsMediaList* aMedia);
   NS_IMETHOD SetOwningNode(nsIDOMNode* aOwningNode);
   NS_IMETHOD SetOwnerRule(nsICSSImportRule* aOwnerRule);
   NS_IMETHOD GetOwnerRule(nsICSSImportRule** aOwnerRule);
   virtual NS_HIDDEN_(nsXMLNameSpaceMap*) GetNameSpaceMap() const;
   NS_IMETHOD Clone(nsICSSStyleSheet* aCloneParent,
                    nsICSSImportRule* aCloneOwnerRule,
@@ -195,11 +202,12 @@ protected:
   PRPackedBool          mDirty; // has been modified 
 
   nsCSSStyleSheetInner* mInner;
 
   nsAutoVoidArray*      mRuleProcessors;
 
   friend class nsMediaList;
   friend PRBool CascadeSheetRulesInto(nsICSSStyleSheet* aSheet, void* aData);
+  friend nsresult NS_NewCSSStyleSheet(nsICSSStyleSheet** aInstancePtrResult);
 };
 
 #endif /* !defined(nsCSSStyleSheet_h_) */
Index: layout/style/nsCSSStyleSheet.cpp
===================================================================
RCS file: /cvsroot/mozilla/layout/style/nsCSSStyleSheet.cpp,v
retrieving revision 3.370
diff -u -p -d -8 -r3.370 nsCSSStyleSheet.cpp
--- layout/style/nsCSSStyleSheet.cpp	30 Jan 2007 00:06:40 -0000	3.370
+++ layout/style/nsCSSStyleSheet.cpp	1 Mar 2007 06:56:50 -0000
@@ -491,39 +491,48 @@ static PRBool SetStyleSheetReference(nsI
     aRule->SetStyleSheet((nsICSSStyleSheet*)aSheet);
   }
   return PR_TRUE;
 }
 
 nsCSSStyleSheetInner::nsCSSStyleSheetInner(nsICSSStyleSheet* aParentSheet)
   : mSheets(),
     mComplete(PR_FALSE)
+#ifdef DEBUG
+    , mPrincipalSet(PR_FALSE)
+#endif
 {
   MOZ_COUNT_CTOR(nsCSSStyleSheetInner);
   mSheets.AppendElement(aParentSheet);
+
+  mPrincipal = do_CreateInstance("@mozilla.org/nullprincipal;1");
 }
 
 static PRBool
 CloneRuleInto(nsICSSRule* aRule, void* aArray)
 {
   nsICSSRule* clone = nsnull;
   aRule->Clone(clone);
   if (clone) {
     NS_STATIC_CAST(nsCOMArray<nsICSSRule>*, aArray)->AppendObject(clone);
     NS_RELEASE(clone);
   }
   return PR_TRUE;
 }
 
 nsCSSStyleSheetInner::nsCSSStyleSheetInner(nsCSSStyleSheetInner& aCopy,
-                                       nsICSSStyleSheet* aParentSheet)
+                                           nsICSSStyleSheet* aParentSheet)
   : mSheets(),
     mSheetURI(aCopy.mSheetURI),
     mBaseURI(aCopy.mBaseURI),
+    mPrincipal(aCopy.mPrincipal),
     mComplete(aCopy.mComplete)
+#ifdef DEBUG
+    , mPrincipalSet(aCopy.mPrincipalSet)
+#endif
 {
   MOZ_COUNT_CTOR(nsCSSStyleSheetInner);
   mSheets.AppendElement(aParentSheet);
   aCopy.mOrderedRules.EnumerateForwards(CloneRuleInto, &mOrderedRules);
   mOrderedRules.EnumerateForwards(SetStyleSheetReference, aParentSheet);
   RebuildNameSpaces();
 }
 
@@ -624,20 +633,20 @@ nsCSSStyleSheet::nsCSSStyleSheet()
     mDirty(PR_FALSE),
     mRuleProcessors(nsnull)
 {
 
   mInner = new nsCSSStyleSheetInner(this);
 }
 
 nsCSSStyleSheet::nsCSSStyleSheet(const nsCSSStyleSheet& aCopy,
-                                     nsICSSStyleSheet* aParentToUse,
-                                     nsICSSImportRule* aOwnerRuleToUse,
-                                     nsIDocument* aDocumentToUse,
-                                     nsIDOMNode* aOwningNodeToUse)
+                                 nsICSSStyleSheet* aParentToUse,
+                                 nsICSSImportRule* aOwnerRuleToUse,
+                                 nsIDocument* aDocumentToUse,
+                                 nsIDOMNode* aOwningNodeToUse)
   : nsICSSStyleSheet(),
     mRefCnt(0),
     mTitle(aCopy.mTitle), 
     mMedia(nsnull),
     mFirstChild(nsnull), 
     mNext(nsnull),
     mParent(aParentToUse),
     mOwnerRule(aOwnerRuleToUse),
@@ -761,39 +770,54 @@ nsCSSStyleSheet::DropRuleProcessor(nsCSS
 }
 
 
 NS_IMETHODIMP
 nsCSSStyleSheet::SetURIs(nsIURI* aSheetURI, nsIURI* aBaseURI)
 {
   NS_PRECONDITION(aSheetURI && aBaseURI, "null ptr");
 
-  if (! mInner) {
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-
   NS_ASSERTION(mInner->mOrderedRules.Count() == 0 && !mInner->mComplete,
                "Can't call SetURL on sheets that are complete or have rules");
 
   mInner->mSheetURI = aSheetURI;
   mInner->mBaseURI = aBaseURI;
   return NS_OK;
 }
 
+void
+nsCSSStyleSheet::SetPrincipal(nsIPrincipal* aPrincipal)
+{
+  NS_PRECONDITION(!mInner->mPrincipalSet,
+                  "Should have an inner whose principal has not yet been set");
+  if (aPrincipal) {
+    mInner->mPrincipal = aPrincipal;
+#ifdef DEBUG
+    mInner->mPrincipalSet = PR_TRUE;
+#endif
+  }
+}
+
+nsIPrincipal*
+nsCSSStyleSheet::Principal() const
+{
+  return mInner->mPrincipal;
+}
+
 NS_IMETHODIMP
 nsCSSStyleSheet::GetSheetURI(nsIURI** aSheetURI) const
 {
-  NS_IF_ADDREF(*aSheetURI = (mInner ? mInner->mSheetURI.get() : nsnull));
+  NS_IF_ADDREF(*aSheetURI = mInner->mSheetURI.get());
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::GetBaseURI(nsIURI** aBaseURI) const
 {
-  NS_IF_ADDREF(*aBaseURI = (mInner ? mInner->mBaseURI.get() : nsnull));
+  NS_IF_ADDREF(*aBaseURI = mInner->mBaseURI.get());
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::SetTitle(const nsAString& aTitle)
 {
   mTitle = aTitle;
   return NS_OK;
@@ -829,48 +853,46 @@ nsCSSStyleSheet::HasRules() const
   PRInt32 count;
   StyleRuleCount(count);
   return count != 0;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::GetApplicable(PRBool& aApplicable) const
 {
-  aApplicable = !mDisabled && mInner && mInner->mComplete;
+  aApplicable = !mDisabled && mInner->mComplete;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::SetEnabled(PRBool aEnabled)
 {
   // Internal method, so callers must handle BeginUpdate/EndUpdate
   PRBool oldDisabled = mDisabled;
   mDisabled = !aEnabled;
 
-  if (mDocument && mInner && mInner->mComplete && oldDisabled != mDisabled) {
+  if (mDocument && mInner->mComplete && oldDisabled != mDisabled) {
     ClearRuleCascades();
 
     mDocument->SetStyleSheetApplicableState(this, !mDisabled);
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::GetComplete(PRBool& aComplete) const
 {
-  aComplete = mInner && mInner->mComplete;
+  aComplete = mInner->mComplete;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::SetComplete()
 {
-  if (!mInner)
-    return NS_ERROR_UNEXPECTED;
   NS_ASSERTION(!mDirty, "Can't set a dirty sheet complete!");
   mInner->mComplete = PR_TRUE;
   if (mDocument && !mDisabled) {
     // Let the document know
     mDocument->BeginUpdate(UPDATE_STYLE);
     mDocument->SetStyleSheetApplicableState(this, PR_TRUE);
     mDocument->EndUpdate(UPDATE_STYLE);
   }
@@ -926,17 +948,17 @@ nsCSSStyleSheet::GetOwnerRule(nsICSSImpo
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::ContainsStyleSheet(nsIURI* aURL, PRBool& aContains, nsIStyleSheet** aTheChild /*=nsnull*/)
 {
   NS_PRECONDITION(nsnull != aURL, "null arg");
 
-  if (!mInner || !mInner->mSheetURI) {
+  if (!mInner->mSheetURI) {
     // We're not yet far enough along in our load to know what our URL is (we
     // may still get redirected and such).  Assert (caller should really not be
     // calling this on us at this stage) and return.
     NS_ERROR("ContainsStyleSheet called on a sheet that's still loading");
     aContains = PR_FALSE;
     return NS_OK;
   }
   
@@ -1079,18 +1101,17 @@ nsCSSStyleSheet::AppendStyleRule(nsICSSR
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::ReplaceStyleRule(nsICSSRule* aOld, nsICSSRule* aNew)
 {
   NS_PRECONDITION(mInner->mOrderedRules.Count() != 0, "can't have old rule");
-  NS_PRECONDITION(mInner && mInner->mComplete,
-                  "No replacing in an incomplete sheet!");
+  NS_PRECONDITION(mInner->mComplete, "No replacing in an incomplete sheet!");
 
   if (NS_SUCCEEDED(WillDirty())) {
     PRInt32 index = mInner->mOrderedRules.IndexOf(aOld);
     NS_ENSURE_TRUE(index != -1, NS_ERROR_UNEXPECTED);
     mInner->mOrderedRules.ReplaceObjectAt(aNew, index);
 
     aNew->SetStyleSheet(this);
     aOld->SetStyleSheet(nsnull);
@@ -1104,49 +1125,38 @@ nsCSSStyleSheet::ReplaceStyleRule(nsICSS
 #endif
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::StyleRuleCount(PRInt32& aCount) const
 {
-  aCount = 0;
-  if (mInner) {
-    aCount = mInner->mOrderedRules.Count();
-  }
+  aCount = mInner->mOrderedRules.Count();
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::GetStyleRuleAt(PRInt32 aIndex, nsICSSRule*& aRule) const
 {
   // Important: If this function is ever made scriptable, we must add
   // a security check here. See GetCSSRules below for an example.
-  nsresult result = NS_ERROR_ILLEGAL_VALUE;
-
-  if (mInner) {
-    NS_IF_ADDREF(aRule = mInner->mOrderedRules.SafeObjectAt(aIndex));
-    if (nsnull != aRule) {
-      result = NS_OK;
-    }
-  }
-  else {
-    aRule = nsnull;
+  aRule = mInner->mOrderedRules.SafeObjectAt(aIndex);
+  if (aRule) {
+    NS_ADDREF(aRule);
+    return NS_OK;
   }
-  return result;
+
+  return NS_ERROR_ILLEGAL_VALUE;
 }
 
 nsXMLNameSpaceMap*
 nsCSSStyleSheet::GetNameSpaceMap() const
 {
-  if (mInner)
-    return mInner->mNameSpaceMap;
-
-  return nsnull;
+  return mInner->mNameSpaceMap;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::StyleSheetCount(PRInt32& aCount) const
 {
   // XXX Far from an ideal way to do this, but the hope is that
   // it won't be done too often. If it is, we might want to 
   // consider storing the children in an array.
@@ -1181,19 +1191,16 @@ nsCSSStyleSheet::GetStyleSheetAt(PRInt32
   }
 
   return NS_OK;
 }
 
 nsresult  
 nsCSSStyleSheet::EnsureUniqueInner()
 {
-  if (! mInner) {
-    return NS_ERROR_NOT_INITIALIZED;
-  }
   if (1 < mInner->mSheets.Count()) {
     nsCSSStyleSheetInner* clone = mInner->CloneFor(this);
     if (clone) {
       mInner->RemoveSheet(this);
       mInner = clone;
     }
     else {
       return NS_ERROR_OUT_OF_MEMORY;
@@ -1244,21 +1251,16 @@ struct ListEnumData {
 void nsCSSStyleSheet::List(FILE* out, PRInt32 aIndent) const
 {
 
   PRInt32 index;
 
   // Indent
   for (index = aIndent; --index >= 0; ) fputs("  ", out);
 
-  if (! mInner) {
-    fputs("CSS Style Sheet - without inner data storage - ERROR\n", out);
-    return;
-  }
-
   fputs("CSS Style Sheet: ", out);
   nsCAutoString urlSpec;
   nsresult rv = mInner->mSheetURI->GetSpec(urlSpec);
   if (NS_SUCCEEDED(rv) && !urlSpec.IsEmpty()) {
     fputs(urlSpec.get(), out);
   }
 
   if (mMedia) {
@@ -1299,17 +1301,17 @@ nsCSSStyleSheet::ClearRuleCascades()
     nsCSSStyleSheet* parent = (nsCSSStyleSheet*)mParent;
     parent->ClearRuleCascades();
   }
 }
 
 nsresult
 nsCSSStyleSheet::WillDirty()
 {
-  if (mInner && !mInner->mComplete) {
+  if (!mInner->mComplete) {
     // Do nothing
     return NS_OK;
   }
   
   return EnsureUniqueInner();
 }
 
 void
@@ -1383,17 +1385,17 @@ nsCSSStyleSheet::GetParentStyleSheet(nsI
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::GetHref(nsAString& aHref)
 {
   nsCAutoString str;
 
   // XXXldb The DOM spec says that this should be null for inline style sheets.
-  if (mInner && mInner->mSheetURI) {
+  if (mInner->mSheetURI) {
     mInner->mSheetURI->GetSpec(str);
   }
 
   CopyUTF8toUTF16(str, aHref);
 
   return NS_OK;
 }
 
@@ -1445,38 +1447,38 @@ nsCSSStyleSheet::GetCssRules(nsIDOMCSSRu
 {
   // No doing this on incomplete sheets!
   PRBool complete;
   GetComplete(complete);
   if (!complete) {
     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
   }
   
-  //-- Security check: Only scripts from the same origin as the
-  //   style sheet can access rule collections
+  //-- Security check: Only scripts whose principal subsumes that of the
+  //   style sheet can access rule collections.
 
-  // Get JSContext from stack
-  nsCOMPtr<nsIJSContextStack> stack =
-    do_GetService("@mozilla.org/js/xpc/ContextStack;1");
-  NS_ENSURE_TRUE(stack, NS_ERROR_FAILURE);
+  // Get the security manager and do the subsumes check
+  nsIScriptSecurityManager *securityManager =
+    nsContentUtils::GetSecurityManager();
 
-  JSContext *cx = nsnull;
-  nsresult rv = NS_OK;
+  nsCOMPtr<nsIPrincipal> subjectPrincipal;
+  securityManager->GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
 
-  rv = stack->Peek(&cx);
-  NS_ENSURE_SUCCESS(rv, rv);
-  if (!cx)
-    return NS_ERROR_FAILURE;
+  nsresult rv = NS_OK;
+  if (subjectPrincipal) {
+    PRBool subsumes;
+    rv = subjectPrincipal->Subsumes(mInner->mPrincipal, &subsumes);
+    if (NS_SUCCEEDED(rv) && !subsumes &&
+        !nsContentUtils::IsCallerTrustedForRead()) {
+      rv = NS_ERROR_DOM_SECURITY_ERR;
+    }
 
-  // Get the security manager and do the same-origin check
-  nsIScriptSecurityManager *securityManager =
-    nsContentUtils::GetSecurityManager();
-  rv = securityManager->CheckSameOrigin(cx, mInner->mSheetURI);
-  if (NS_FAILED(rv)) {
-    return rv;
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
   }
 
   // OK, security check passed, so get the rule collection
   if (nsnull == mRuleCollection) {
     mRuleCollection = new CSSRuleListImpl(this);
     if (nsnull == mRuleCollection) {
       return NS_ERROR_OUT_OF_MEMORY;
     }
@@ -1489,17 +1491,16 @@ nsCSSStyleSheet::GetCssRules(nsIDOMCSSRu
   return NS_OK;
 }
 
 NS_IMETHODIMP    
 nsCSSStyleSheet::InsertRule(const nsAString& aRule, 
                             PRUint32 aIndex, 
                             PRUint32* aReturn)
 {
-  NS_ENSURE_TRUE(mInner, NS_ERROR_FAILURE);
   // No doing this if the sheet is not complete!
   PRBool complete;
   GetComplete(complete);
   if (!complete) {
     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
   }
 
   if (aRule.IsEmpty()) {
@@ -1667,51 +1668,48 @@ nsCSSStyleSheet::DeleteRule(PRUint32 aIn
   // No doing this if the sheet is not complete!
   PRBool complete;
   GetComplete(complete);
   if (!complete) {
     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
   }
 
   // XXX TBI: handle @rule types
-  if (mInner) {
-    mozAutoDocUpdate updateBatch(mDocument, UPDATE_STYLE, PR_TRUE);
+  mozAutoDocUpdate updateBatch(mDocument, UPDATE_STYLE, PR_TRUE);
     
-    result = WillDirty();
+  result = WillDirty();
 
-    if (NS_SUCCEEDED(result)) {
-      if (aIndex >= PRUint32(mInner->mOrderedRules.Count()))
-        return NS_ERROR_DOM_INDEX_SIZE_ERR;
+  if (NS_SUCCEEDED(result)) {
+    if (aIndex >= PRUint32(mInner->mOrderedRules.Count()))
+      return NS_ERROR_DOM_INDEX_SIZE_ERR;
 
-      NS_ASSERTION(PRUint32(mInner->mOrderedRules.Count()) <= PR_INT32_MAX,
-                   "Too many style rules!");
+    NS_ASSERTION(PRUint32(mInner->mOrderedRules.Count()) <= PR_INT32_MAX,
+                 "Too many style rules!");
 
-      // Hold a strong ref to the rule so it doesn't die when we RemoveObjectAt
-      nsCOMPtr<nsICSSRule> rule = mInner->mOrderedRules.ObjectAt(aIndex);
-      if (rule) {
-        mInner->mOrderedRules.RemoveObjectAt(aIndex);
-        rule->SetStyleSheet(nsnull);
-        DidDirty();
+    // Hold a strong ref to the rule so it doesn't die when we RemoveObjectAt
+    nsCOMPtr<nsICSSRule> rule = mInner->mOrderedRules.ObjectAt(aIndex);
+    if (rule) {
+      mInner->mOrderedRules.RemoveObjectAt(aIndex);
+      rule->SetStyleSheet(nsnull);
+      DidDirty();
 
-        if (mDocument) {
-          mDocument->StyleRuleRemoved(this, rule);
-        }
+      if (mDocument) {
+        mDocument->StyleRuleRemoved(this, rule);
       }
     }
   }
 
   return result;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::DeleteRuleFromGroup(nsICSSGroupRule* aGroup, PRUint32 aIndex)
 {
   NS_ENSURE_ARG_POINTER(aGroup);
-  NS_ASSERTION(mInner && mInner->mComplete,
-               "No deleting from an incomplete sheet!");
+  NS_ASSERTION(mInner->mComplete, "No deleting from an incomplete sheet!");
   nsresult result;
   nsCOMPtr<nsICSSRule> rule;
   result = aGroup->GetStyleRuleAt(aIndex, *getter_AddRefs(rule));
   NS_ENSURE_SUCCESS(result, result);
   
   // check that the rule actually belongs to this sheet!
   nsCOMPtr<nsIStyleSheet> ruleSheet;
   rule->GetStyleSheet(*getter_AddRefs(ruleSheet));
@@ -1740,18 +1738,17 @@ nsCSSStyleSheet::DeleteRuleFromGroup(nsI
 
 NS_IMETHODIMP
 nsCSSStyleSheet::InsertRuleIntoGroup(const nsAString & aRule,
                                      nsICSSGroupRule* aGroup,
                                      PRUint32 aIndex,
                                      PRUint32* _retval)
 {
   nsresult result;
-  NS_ASSERTION(mInner && mInner->mComplete,
-               "No inserting into an incomplete sheet!");
+  NS_ASSERTION(mInner->mComplete, "No inserting into an incomplete sheet!");
   // check that the group actually belongs to this sheet!
   nsCOMPtr<nsIStyleSheet> groupSheet;
   aGroup->GetStyleSheet(*getter_AddRefs(groupSheet));
   if (this != groupSheet) {
     return NS_ERROR_INVALID_ARG;
   }
 
   if (aRule.IsEmpty()) {
@@ -1826,18 +1823,17 @@ nsCSSStyleSheet::InsertRuleIntoGroup(con
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::ReplaceRuleInGroup(nsICSSGroupRule* aGroup,
                                       nsICSSRule* aOld, nsICSSRule* aNew)
 {
   nsresult result;
-  NS_PRECONDITION(mInner && mInner->mComplete,
-                  "No replacing in an incomplete sheet!");
+  NS_PRECONDITION(mInner->mComplete, "No replacing in an incomplete sheet!");
 #ifdef DEBUG
   {
     nsCOMPtr<nsIStyleSheet> groupSheet;
     aGroup->GetStyleSheet(*getter_AddRefs(groupSheet));
     NS_ASSERTION(this == groupSheet, "group doesn't belong to this sheet");
   }
 #endif
   result = WillDirty();
@@ -1878,18 +1874,25 @@ nsCSSStyleSheet::StyleSheetLoaded(nsICSS
   }
 
   return NS_OK;
 }
 
 nsresult
 NS_NewCSSStyleSheet(nsICSSStyleSheet** aInstancePtrResult)
 {
+  *aInstancePtrResult = nsnull;
   nsCSSStyleSheet  *it = new nsCSSStyleSheet();
 
-  if (nsnull == it) {
+  if (!it) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   NS_ADDREF(it);
+
+  if (!it->mInner || !it->mInner->mPrincipal) {
+    NS_RELEASE(it);
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+  
   *aInstancePtrResult = it;
   return NS_OK;
 }
Index: layout/style/nsCSSLoader.h
===================================================================
RCS file: /cvsroot/mozilla/layout/style/nsCSSLoader.h,v
retrieving revision 3.26
diff -u -p -d -8 -r3.26 nsCSSLoader.h
--- layout/style/nsCSSLoader.h	20 Apr 2007 22:59:16 -0000	3.26
+++ layout/style/nsCSSLoader.h	21 Apr 2007 04:11:02 -0000
@@ -66,16 +66,17 @@ class nsMediaList;
 #include "nsCOMPtr.h"
 #include "nsCOMArray.h"
 #include "nsString.h"
 #include "nsURIHashKey.h"
 #include "nsInterfaceHashtable.h"
 #include "nsDataHashtable.h"
 #include "nsAutoPtr.h"
 #include "nsTArray.h"
+#include "nsIPrincipal.h"
 
 /**
  * OVERALL ARCHITECTURE
  *
  * The CSS Loader gets requests to load various sorts of style sheets:
  * inline style from <style> elements, linked style, @import-ed child
  * sheets, non-document sheets.  The loader handles the following tasks:
  *
@@ -111,24 +112,26 @@ public:
   virtual ~SheetLoadData(void);
   // Data for loading a sheet linked from a document
   SheetLoadData(CSSLoaderImpl* aLoader,
                 const nsSubstring& aTitle,
                 nsIURI* aURI,
                 nsICSSStyleSheet* aSheet,
                 nsIStyleSheetLinkingElement* aOwningElement,
                 PRBool aIsAlternate,
-                nsICSSLoaderObserver* aObserver);                 
+                nsICSSLoaderObserver* aObserver,
+                nsIPrincipal* aLoaderPrincipal);
 
   // Data for loading a sheet linked from an @import rule
   SheetLoadData(CSSLoaderImpl* aLoader,
                 nsIURI* aURI,
                 nsICSSStyleSheet* aSheet,
                 SheetLoadData* aParentData,
-                nsICSSLoaderObserver* aObserver);                 
+                nsICSSLoaderObserver* aObserver,
+                nsIPrincipal* aLoaderPrincipal);
 
   // Data for loading a non-document sheet
   SheetLoadData(CSSLoaderImpl* aLoader,
                 nsIURI* aURI,
                 nsICSSStyleSheet* aSheet,
                 PRBool aSyncLoad,
                 PRBool aAllowUnsafeRules,
                 nsICSSLoaderObserver* aObserver);
@@ -204,18 +207,78 @@ public:
   PRPackedBool               mAllowUnsafeRules : 1;
   
   // This is the element that imported the sheet.  Needed to get the
   // charset set on it.
   nsCOMPtr<nsIStyleSheetLinkingElement> mOwningElement;
 
   // The observer that wishes to be notified of load completion
   nsCOMPtr<nsICSSLoaderObserver>        mObserver;
+
+  // The principal that identifies who started loading us.
+  nsCOMPtr<nsIPrincipal> mLoaderPrincipal;
 };
 
+class nsURIAndPrincipalHashKey : public nsURIHashKey
+{
+public:
+  typedef nsURIAndPrincipalHashKey* KeyType;
+  typedef const nsURIAndPrincipalHashKey* KeyTypePointer;
+
+  nsURIAndPrincipalHashKey(const nsURIAndPrincipalHashKey* aKey)
+    : nsURIHashKey(aKey->mKey), mPrincipal(aKey->mPrincipal)
+  {
+    MOZ_COUNT_CTOR(nsURIAndPrincipalHashKey);
+  }
+  nsURIAndPrincipalHashKey(nsIURI* aURI, nsIPrincipal* aPrincipal)
+    : nsURIHashKey(aURI), mPrincipal(aPrincipal)
+  {
+    MOZ_COUNT_CTOR(nsURIAndPrincipalHashKey);
+  }
+  nsURIAndPrincipalHashKey(const nsURIAndPrincipalHashKey& toCopy)
+    : nsURIHashKey(toCopy), mPrincipal(toCopy.mPrincipal)
+  {
+    MOZ_COUNT_CTOR(nsURIAndPrincipalHashKey);
+  }
+  ~nsURIAndPrincipalHashKey()
+  {
+    MOZ_COUNT_DTOR(nsURIAndPrincipalHashKey);
+  }
+ 
+  nsURIAndPrincipalHashKey* GetKey() const {
+    return NS_CONST_CAST(nsURIAndPrincipalHashKey*, this);
+  }
+  const nsURIAndPrincipalHashKey* GetKeyPointer() const { return this; }
+ 
+  PRBool KeyEquals(const nsURIAndPrincipalHashKey* aKey) const {
+    if (!nsURIHashKey::KeyEquals(aKey->mKey)) {
+      return PR_FALSE;
+    }
+
+    if (!mPrincipal != !aKey->mPrincipal) {
+      // One or the other has a principal, but not both... not equal
+      return PR_FALSE;
+    }
+       
+    PRBool eq;
+    return !mPrincipal ||
+      NS_SUCCEEDED(mPrincipal->Equals(aKey->mPrincipal, &eq)) && eq;
+  }
+ 
+  static const nsURIAndPrincipalHashKey*
+  KeyToPointer(nsURIAndPrincipalHashKey* aKey) { return aKey; }
+  static PLDHashNumber HashKey(const nsURIAndPrincipalHashKey* aKey) {
+    return nsURIHashKey::HashKey(aKey->mKey);
+  }
+     
+  enum { ALLOW_MEMMOVE = PR_TRUE };
+ 
+protected:
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+};
 
 /***********************************************************************
  * Enum that describes the state of the sheet returned by CreateSheet. *
  ***********************************************************************/
 enum StyleSheetState {
   eSheetStateUnknown = 0,
   eSheetNeedsParser,
   eSheetPending,
@@ -300,24 +363,27 @@ public:
   // local helper methods (some are public for access from statics)
 
   // IsAlternate can change our currently selected style set if none
   // is selected and aHasAlternateRel is false.
   PRBool IsAlternate(const nsAString& aTitle, PRBool aHasAlternateRel);
 
 private:
   nsresult CheckLoadAllowed(nsIURI* aSourceURI,
+                            nsIPrincipal* aSourcePrincipal,
                             nsIURI* aTargetURI,
                             nsISupports* aContext);
 
 
   // For inline style, the aURI param is null, but the aLinkingContent
-  // must be non-null then.
+  // must be non-null then.  The loader principal must never be null
+  // if aURI is not null.
   nsresult CreateSheet(nsIURI* aURI,
                        nsIContent* aLinkingContent,
+                       nsIPrincipal* aLoaderPrincipal,
                        PRBool aSyncLoad,
                        StyleSheetState& aSheetState,
                        nsICSSStyleSheet** aSheet);
 
   // Pass in either a media string or the nsMediaList from the
   // CSSParser.  Don't pass both.
   // If aIsAlternate is non-null, this method will set *aIsAlternate to
   // correspond to the sheet's enabled state (which it will set no matter what)
@@ -396,19 +462,22 @@ private:
   PRPackedBool            mSyncCallback;
 #endif
 
   PRPackedBool      mCaseSensitive; // is document CSS case sensitive
   PRPackedBool      mEnabled; // is enabled to load new styles
   nsCompatibility   mCompatMode;
   nsString          mPreferredSheet;  // title of preferred sheet
 
-  nsInterfaceHashtable<nsURIHashKey,nsICSSStyleSheet> mCompleteSheets;
-  nsDataHashtable<nsURIHashKey,SheetLoadData*> mLoadingDatas; // weak refs
-  nsDataHashtable<nsURIHashKey,SheetLoadData*> mPendingDatas; // weak refs
+  nsInterfaceHashtable<nsURIAndPrincipalHashKey,
+                       nsICSSStyleSheet> mCompleteSheets;
+  nsDataHashtable<nsURIAndPrincipalHashKey,
+                  SheetLoadData*> mLoadingDatas; // weak refs
+  nsDataHashtable<nsURIAndPrincipalHashKey,
+                  SheetLoadData*> mPendingDatas; // weak refs
   
   // We're not likely to have many levels of @import...  But likely to have
   // some.  Allocate some storage, what the hell.
   nsAutoVoidArray   mParsingDatas;
 
   // The array of posted stylesheet loaded events (SheetLoadDatas) we have.
   // Note that these are rare.
   LoadDataArray mPostedEvents;
Index: layout/style/nsCSSLoader.cpp
===================================================================
RCS file: /cvsroot/mozilla/layout/style/nsCSSLoader.cpp,v
retrieving revision 3.225
diff -u -p -d -8 -r3.225 nsCSSLoader.cpp
--- layout/style/nsCSSLoader.cpp	20 Apr 2007 22:59:16 -0000	3.225
+++ layout/style/nsCSSLoader.cpp	21 Apr 2007 04:34:26 -0000
@@ -142,61 +142,65 @@ static const char* const gStateStrings[]
 NS_IMPL_ISUPPORTS2(SheetLoadData, nsIUnicharStreamLoaderObserver, nsIRunnable)
 
 SheetLoadData::SheetLoadData(CSSLoaderImpl* aLoader,
                              const nsSubstring& aTitle,
                              nsIURI* aURI,
                              nsICSSStyleSheet* aSheet,
                              nsIStyleSheetLinkingElement* aOwningElement,
                              PRBool aIsAlternate,
-                             nsICSSLoaderObserver* aObserver)
+                             nsICSSLoaderObserver* aObserver,
+                             nsIPrincipal* aLoaderPrincipal)
   : mLoader(aLoader),
     mTitle(aTitle),
     mURI(aURI),
     mLineNumber(1),
     mSheet(aSheet),
     mNext(nsnull),
     mParentData(nsnull),
     mPendingChildren(0),
     mSyncLoad(PR_FALSE),
     mIsNonDocumentSheet(PR_FALSE),
     mIsLoading(PR_FALSE),
     mIsCancelled(PR_FALSE),
     mMustNotify(PR_FALSE),
     mWasAlternate(aIsAlternate),
     mAllowUnsafeRules(PR_FALSE),
     mOwningElement(aOwningElement),
-    mObserver(aObserver)
+    mObserver(aObserver),
+    mLoaderPrincipal(aLoaderPrincipal)
 {
 
   NS_PRECONDITION(mLoader, "Must have a loader!");
   NS_ADDREF(mLoader);
 }
 
 SheetLoadData::SheetLoadData(CSSLoaderImpl* aLoader,
                              nsIURI* aURI,
                              nsICSSStyleSheet* aSheet,
                              SheetLoadData* aParentData,
-                             nsICSSLoaderObserver* aObserver)
+                             nsICSSLoaderObserver* aObserver,
+                             nsIPrincipal* aLoaderPrincipal)
   : mLoader(aLoader),
     mURI(aURI),
     mLineNumber(1),
     mSheet(aSheet),
     mNext(nsnull),
     mParentData(aParentData),
     mPendingChildren(0),
     mSyncLoad(PR_FALSE),
     mIsNonDocumentSheet(PR_FALSE),
     mIsLoading(PR_FALSE),
     mIsCancelled(PR_FALSE),
     mMustNotify(PR_FALSE),
     mWasAlternate(PR_FALSE),
     mAllowUnsafeRules(PR_FALSE),
     mOwningElement(nsnull),
-    mObserver(aObserver)
+    mObserver(aObserver),
+    mLoaderPrincipal(aLoaderPrincipal)
 {
 
   NS_PRECONDITION(mLoader, "Must have a loader!");
   NS_ADDREF(mLoader);
   if (mParentData) {
     NS_ADDREF(mParentData);
     mSyncLoad = mParentData->mSyncLoad;
     mIsNonDocumentSheet = mParentData->mIsNonDocumentSheet;
@@ -221,17 +225,18 @@ SheetLoadData::SheetLoadData(CSSLoaderIm
     mSyncLoad(aSyncLoad),
     mIsNonDocumentSheet(PR_TRUE),
     mIsLoading(PR_FALSE),
     mIsCancelled(PR_FALSE),
     mMustNotify(PR_FALSE),
     mWasAlternate(PR_FALSE),
     mAllowUnsafeRules(aAllowUnsafeRules),
     mOwningElement(nsnull),
-    mObserver(aObserver)
+    mObserver(aObserver),
+    mLoaderPrincipal(nsnull)
 {
 
   NS_PRECONDITION(mLoader, "Must have a loader!");
   NS_ADDREF(mLoader);
 }
 
 SheetLoadData::~SheetLoadData()
 {
@@ -295,17 +300,19 @@ CSSLoaderImpl::Init(nsIDocument* aDocume
   nsCOMPtr<nsIDOMNSDocumentStyle> domDoc(do_QueryInterface(mDocument));
   if (domDoc) {
     domDoc->GetPreferredStyleSheetSet(mPreferredSheet);
   }
   return NS_OK;
 }
 
 PR_STATIC_CALLBACK(PLDHashOperator)
-StartAlternateLoads(nsIURI *aKey, SheetLoadData* &aData, void* aClosure)
+StartAlternateLoads(nsURIAndPrincipalHashKey *aKey,
+                    SheetLoadData* &aData,
+                    void* aClosure)
 {
   NS_STATIC_CAST(CSSLoaderImpl*,aClosure)->LoadSheet(aData, eSheetNeedsParser);
   return PL_DHASH_REMOVE;
 }
 
 NS_IMETHODIMP
 CSSLoaderImpl::DropDocumentReference(void)
 {
@@ -328,17 +335,19 @@ CSSLoaderImpl::SetCaseSensitive(PRBool a
 NS_IMETHODIMP
 CSSLoaderImpl::SetCompatibilityMode(nsCompatibility aCompatMode)
 {
   mCompatMode = aCompatMode;
   return NS_OK;
 }
 
 PR_STATIC_CALLBACK(PLDHashOperator)
-StartNonAlternates(nsIURI *aKey, SheetLoadData* &aData, void* aClosure)
+StartNonAlternates(nsURIAndPrincipalHashKey *aKey,
+                   SheetLoadData* &aData,
+                   void* aClosure)
 {
   NS_PRECONDITION(aData, "Must have a data");
   NS_PRECONDITION(aClosure, "Must have a loader");
   
   CSSLoaderImpl* loader = NS_STATIC_CAST(CSSLoaderImpl*, aClosure);
   // Note that we don't want to affect what the selected style set is,
   // so use PR_TRUE for aHasAlternateRel.
   if (loader->IsAlternate(aData->mTitle, PR_TRUE)) {
@@ -748,34 +757,64 @@ SheetLoadData::OnStreamComplete(nsIUnich
   
   if (!mLoader->mDocument && !mIsNonDocumentSheet) {
     // Sorry, we don't care about this load anymore
     LOG_WARN(("  No document and not non-document sheet; dropping load"));
     mLoader->SheetComplete(this, NS_BINDING_ABORTED);
     return NS_OK;
   }
   
+  if (NS_FAILED(aStatus)) {
+    LOG_WARN(("  Load failed: status 0x%x", aStatus));
+    mLoader->SheetComplete(this, aStatus);
+    return NS_OK;
+  }
+
   nsCOMPtr<nsIChannel> channel;
   nsresult result = aLoader->GetChannel(getter_AddRefs(channel));
-  if (NS_FAILED(result))
-    channel = nsnull;
+  if (NS_FAILED(result)) {
+    LOG_WARN(("  No channel from loader"));
+    mLoader->SheetComplete(this, result);
+    return NS_OK;
+  }
   
   nsCOMPtr<nsIURI> channelURI;
-  if (channel) {
-    // If the channel's original URI is "chrome:", we want that, since
-    // the observer code in nsXULPrototypeCache depends on chrome stylesheets
-    // having a chrome URI.  (Whether or not chrome stylesheets come through
-    // this codepath seems nondeterministic.)
-    // Otherwise we want the potentially-HTTP-redirected URI.
-    channel->GetOriginalURI(getter_AddRefs(channelURI));
-    PRBool isChrome;
-    if (NS_FAILED(channelURI->SchemeIs("chrome", &isChrome)) || !isChrome)
-      channel->GetURI(getter_AddRefs(channelURI));
+  // If the channel's original URI is "chrome:", we want that, since
+  // the observer code in nsXULPrototypeCache depends on chrome stylesheets
+  // having a chrome URI.  (Whether or not chrome stylesheets come through
+  // this codepath seems nondeterministic.)
+  // Otherwise we want the potentially-HTTP-redirected URI.
+  channel->GetOriginalURI(getter_AddRefs(channelURI));
+  PRBool isChrome;
+  if (NS_FAILED(channelURI->SchemeIs("chrome", &isChrome)) || !isChrome) {
+    channel->GetURI(getter_AddRefs(channelURI));
+  }
+
+  if (!channelURI) {
+    NS_ERROR("Someone just violated the nsIRequest contract");
+    LOG_WARN(("  Channel without a URI.  Bad!"));
+    mLoader->SheetComplete(this, NS_ERROR_UNEXPECTED);
+    return NS_OK;
+  }
+
+  nsCOMPtr<nsIPrincipal> principal;
+  nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
+  result = NS_ERROR_NOT_AVAILABLE;
+  if (secMan) {  // Could be null if we already shut down
+    result = secMan->GetChannelPrincipal(channel, getter_AddRefs(principal));
+  }
+
+  if (NS_FAILED(result)) {
+    LOG_WARN(("  Couldn't get principal"));
+    mLoader->SheetComplete(this, result);
+    return NS_OK;
   }
   
+  mSheet->SetPrincipal(principal);
+  
 #ifdef MOZ_TIMELINE
   NS_TIMELINE_OUTDENT();
   NS_TIMELINE_MARK_CHANNEL("SheetLoadData::OnStreamComplete(%s)", channel);
 #endif // MOZ_TIMELINE
   
   // If it's an HTTP channel, we want to make sure this is not an
   // error document we got.
   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
@@ -796,19 +835,17 @@ SheetLoadData::OnStreamComplete(nsIUnich
     }
     
     PRBool validType = contentType.EqualsLiteral("text/css") ||
       contentType.EqualsLiteral(UNKNOWN_CONTENT_TYPE) ||
       contentType.IsEmpty();
                                           
     if (!validType) {
       nsCAutoString spec;
-      if (channelURI) {
-        channelURI->GetSpec(spec);
-      }
+      channelURI->GetSpec(spec);
 
       const nsAFlatString& specUTF16 = NS_ConvertUTF8toUTF16(spec);
       const nsAFlatString& ctypeUTF16 = NS_ConvertASCIItoUTF16(contentType);
       const PRUnichar *strings[] = { specUTF16.get(), ctypeUTF16.get() };
 
       const char *errorMessage;
       PRUint32 errorFlag;
 
@@ -826,33 +863,25 @@ SheetLoadData::OnStreamComplete(nsIUnich
       nsContentUtils::ReportToConsole(nsContentUtils::eCSS_PROPERTIES,
                                       errorMessage,
                                       strings, NS_ARRAY_LENGTH(strings),
                                       referrer, EmptyString(), 0, 0, errorFlag,
                                       "CSS Loader");
     }
   }
   
-  if (NS_FAILED(aStatus)) {
-    LOG_WARN(("  Load failed: status 0x%x", aStatus));
-    mLoader->SheetComplete(this, aStatus);
-    return NS_OK;
-  }
-
   if (!aDataStream) {
     LOG_WARN(("  No data stream; bailing"));
     mLoader->SheetComplete(this, NS_ERROR_NOT_AVAILABLE);
     return NS_OK;
   }    
 
-  if (channelURI) {
-    // Enough to set the URI on mSheet, since any sibling datas we have share
-    // the same mInner as mSheet and will thus get the same URI.
-    mSheet->SetURIs(channelURI, channelURI);
-  }
+  // Enough to set the URI on mSheet, since any sibling datas we have share
+  // the same mInner as mSheet and will thus get the same URI.
+  mSheet->SetURIs(channelURI, channelURI);
   
   PRBool completed;
   return mLoader->ParseSheet(aDataStream, this, completed);
 }
 
 #ifdef MOZ_XUL
 static PRBool IsChromeURI(nsIURI* aURI)
 {
@@ -886,31 +915,35 @@ CSSLoaderImpl::IsAlternate(const nsAStri
   return !aTitle.Equals(mPreferredSheet);
 }
 
 /**
  * CheckLoadAllowed will return success if the load is allowed,
  * failure otherwise. 
  *
  * @param aSourceURI the uri of the document or parent sheet loading the sheet
+ * @param aSourcePrincipal the principal of the node or document or parent
+ *                         sheet loading the sheet
  * @param aTargetURI the uri of the sheet to be loaded
  * @param aContext the node owning the sheet.  This is the element or document
  *                 owning the stylesheet (possibly indirectly, for child sheets)
  */
 nsresult
 CSSLoaderImpl::CheckLoadAllowed(nsIURI* aSourceURI,
+                                nsIPrincipal* aSourcePrincipal,
                                 nsIURI* aTargetURI,
                                 nsISupports* aContext)
 {
   LOG(("CSSLoaderImpl::CheckLoadAllowed"));
   
   // Check with the security manager
   nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
-  nsresult rv = secMan->CheckLoadURI(aSourceURI, aTargetURI,
-                                     nsIScriptSecurityManager::ALLOW_CHROME);
+  nsresult rv =
+    secMan->CheckLoadURIWithPrincipal(aSourcePrincipal, aTargetURI,
+                                      nsIScriptSecurityManager::ALLOW_CHROME);
   if (NS_FAILED(rv)) { // failure is normal here; don't warn
     return rv;
   }
 
   LOG(("  Passed security check"));
 
   // Check with content policy
 
@@ -939,16 +972,17 @@ CSSLoaderImpl::CheckLoadAllowed(nsIURI* 
  * that uri in various caches and clone it if we find it.  Cloned
  * sheets will have the title/media/enabled state of the sheet they
  * are clones off; make sure to call PrepareSheet() on the result of
  * CreateSheet().
  */
 nsresult
 CSSLoaderImpl::CreateSheet(nsIURI* aURI,
                            nsIContent* aLinkingContent,
+                           nsIPrincipal* aLoaderPrincipal,
                            PRBool aSyncLoad,
                            StyleSheetState& aSheetState,
                            nsICSSStyleSheet** aSheet)
 {
   LOG(("CSSLoaderImpl::CreateSheet"));
   NS_PRECONDITION(aSheet, "Null out param!");
 
   NS_ENSURE_TRUE((mCompleteSheets.IsInitialized() || mCompleteSheets.Init()) &&
@@ -973,38 +1007,60 @@ CSSLoaderImpl::CreateSheet(nsIURI* aURI,
           sheet = cache->GetStyleSheet(aURI);
           LOG(("  From XUL cache: %p", sheet.get()));
         }
       }
     }
 #endif
 
     if (!sheet) {
-      // Then complete sheets
-      mCompleteSheets.Get(aURI, getter_AddRefs(sheet));
+      // Then complete sheets.
+      nsURIAndPrincipalHashKey key(aURI, aLoaderPrincipal);
+      
+      mCompleteSheets.Get(&key, getter_AddRefs(sheet));
       LOG(("  From completed: %p", sheet.get()));
     
       // Then loading sheets
       if (!sheet && !aSyncLoad) {
         aSheetState = eSheetLoading;
         SheetLoadData* loadData = nsnull;
-        mLoadingDatas.Get(aURI, &loadData);
+        mLoadingDatas.Get(&key, &loadData);
         if (loadData) {
           sheet = loadData->mSheet;
           LOG(("  From loading: %p", sheet.get()));
+
+#ifdef DEBUG
+          PRBool debugEqual;
+          NS_ASSERTION((!aLoaderPrincipal && !loadData->mLoaderPrincipal) ||
+                       (aLoaderPrincipal && loadData->mLoaderPrincipal &&
+                        NS_SUCCEEDED(aLoaderPrincipal->
+                                       Equals(loadData->mLoaderPrincipal,
+                                              &debugEqual)) && debugEqual),
+                       "Principals should be the same");
+#endif
         }
 
         // Then alternate sheets
         if (!sheet) {
           aSheetState = eSheetPending;
           SheetLoadData* loadData = nsnull;
-          mPendingDatas.Get(aURI, &loadData);
+          mPendingDatas.Get(&key, &loadData);
           if (loadData) {
             sheet = loadData->mSheet;
             LOG(("  From pending: %p", sheet.get()));
+
+#ifdef DEBUG
+            PRBool debugEqual;
+            NS_ASSERTION((!aLoaderPrincipal && !loadData->mLoaderPrincipal) ||
+                         (aLoaderPrincipal && loadData->mLoaderPrincipal &&
+                          NS_SUCCEEDED(aLoaderPrincipal->
+                                         Equals(loadData->mLoaderPrincipal,
+                                                &debugEqual)) && debugEqual),
+                         "Principals should be the same");
+#endif
           }
         }
       }
     }
 
     if (sheet) {
       // We can use this cached sheet if it's either incomplete or unmodified
       PRBool modified = PR_TRUE;
@@ -1238,23 +1294,40 @@ CSSLoaderImpl::LoadSheet(SheetLoadData* 
   if (aLoadData->mSyncLoad) {
     LOG(("  Synchronous load"));
     NS_ASSERTION(!aLoadData->mObserver, "Observer for a sync load?");
     NS_ASSERTION(aSheetState == eSheetNeedsParser,
                  "Sync loads can't reuse existing async loads");
 
     // Just load it
     nsCOMPtr<nsIInputStream> stream;
-    rv = NS_OpenURI(getter_AddRefs(stream), aLoadData->mURI);
+    nsCOMPtr<nsIChannel> channel;
+    rv = NS_OpenURI(getter_AddRefs(stream), aLoadData->mURI, nsnull,
+                    nsnull, nsnull, nsIRequest::LOAD_NORMAL,
+                    getter_AddRefs(channel));
     if (NS_FAILED(rv)) {
       LOG_ERROR(("  Failed to open URI synchronously"));
       SheetComplete(aLoadData, rv);
       return rv;
     }
 
+    NS_ASSERTION(channel, "NS_OpenURI lied?");
+    
+    // Get the principal for this channel
+    nsCOMPtr<nsIPrincipal> principal;
+    rv = nsContentUtils::GetSecurityManager()->
+      GetChannelPrincipal(channel, getter_AddRefs(principal));
+    if (NS_FAILED(rv)) {
+      LOG_ERROR(("  Failed to get a principal for the sheet"));
+      SheetComplete(aLoadData, rv);
+      return rv;
+    }
+
+    aLoadData->mSheet->SetPrincipal(principal);
+
     nsCOMPtr<nsIConverterInputStream> converterStream = 
       do_CreateInstance("@mozilla.org/intl/converter-input-stream;1", &rv);
     
     if (NS_FAILED(rv)) {
       LOG_ERROR(("  Failed to create converter stream"));
       SheetComplete(aLoadData, rv);
       return rv;
     }
@@ -1278,43 +1351,44 @@ CSSLoaderImpl::LoadSheet(SheetLoadData* 
     PRBool completed;
     rv = ParseSheet(converterStream, aLoadData, completed);
     NS_ASSERTION(completed, "sync load did not complete");
     return rv;
   }
 
   SheetLoadData* existingData = nsnull;
 
+  nsURIAndPrincipalHashKey key(aLoadData->mURI, aLoadData->mLoaderPrincipal);
   if (aSheetState == eSheetLoading) {
-    mLoadingDatas.Get(aLoadData->mURI, &existingData);
+    mLoadingDatas.Get(&key, &existingData);
     NS_ASSERTION(existingData, "CreateSheet lied about the state");
   }
   else if (aSheetState == eSheetPending){
-    mPendingDatas.Get(aLoadData->mURI, &existingData);
+    mPendingDatas.Get(&key, &existingData);
     NS_ASSERTION(existingData, "CreateSheet lied about the state");
   }
   
   if (existingData) {
     LOG(("  Glomming on to existing load"));
     SheetLoadData* data = existingData;
     while (data->mNext) {
       data = data->mNext;
     }
     data->mNext = aLoadData; // transfer ownership
     if (aSheetState == eSheetPending && !aLoadData->mWasAlternate) {
       // Kick the load off; someone cares about it right away
 
 #ifdef DEBUG
       SheetLoadData* removedData;
-      NS_ASSERTION(mPendingDatas.Get(aLoadData->mURI, &removedData) &&
+      NS_ASSERTION(mPendingDatas.Get(&key, &removedData) &&
                    removedData == existingData,
                    "Bad pending table.");
 #endif
 
-      mPendingDatas.Remove(aLoadData->mURI);
+      mPendingDatas.Remove(&key);
 
       LOG(("  Forcing load of pending data"));
       return LoadSheet(existingData, eSheetNeedsParser);
     }
     // All done here; once the load completes we'll be marked complete
     // automatically
     return NS_OK;
   }
@@ -1355,16 +1429,26 @@ CSSLoaderImpl::LoadSheet(SheetLoadData* 
     if (referrerURI)
       httpChannel->SetReferrer(referrerURI);
   }
 
   // Now tell the channel we expect text/css data back....  We do
   // this before opening it, so it's only treated as a hint.
   channel->SetContentType(NS_LITERAL_CSTRING("text/css"));
 
+  if (aLoadData->mLoaderPrincipal) {
+    PRBool inherit;
+    rv = NS_URIChainHasFlags(aLoadData->mURI,
+                             nsIProtocolHandler::URI_INHERITS_SECURITY_CONTEXT,
+                             &inherit);
+    if (NS_SUCCEEDED(rv) && inherit) {
+      channel->SetOwner(aLoadData->mLoaderPrincipal);
+    }
+  }
+
   // We don't have to hold on to the stream loader.  The ownership
   // model is: Necko owns the stream loader, which owns the load data,
   // which owns us
   nsCOMPtr<nsIUnicharStreamLoader> streamLoader;
   rv = NS_NewUnicharStreamLoader(getter_AddRefs(streamLoader),
                                  aLoadData);
 
   if (NS_SUCCEEDED(rv))
@@ -1375,17 +1459,17 @@ CSSLoaderImpl::LoadSheet(SheetLoadData* 
 #endif
 
   if (NS_FAILED(rv)) {
     LOG_ERROR(("  Failed to create stream loader"));
     SheetComplete(aLoadData, rv);
     return rv;
   }
 
-  if (!mLoadingDatas.Put(aLoadData->mURI, aLoadData)) {
+  if (!mLoadingDatas.Put(&key, aLoadData)) {
     LOG_ERROR(("  Failed to put data in loading table"));
     aLoadData->mIsCancelled = PR_TRUE;
     channel->Cancel(NS_ERROR_OUT_OF_MEMORY);
     SheetComplete(aLoadData, NS_ERROR_OUT_OF_MEMORY);
     return NS_ERROR_OUT_OF_MEMORY;
   }
   
   aLoadData->mIsLoading = PR_TRUE;
@@ -1495,24 +1579,26 @@ CSSLoaderImpl::DoSheetComplete(SheetLoad
 
   LOG(("Load completed, status: 0x%x", aStatus));
 
   // Twiddle the hashtables
   if (aLoadData->mURI) {
     LOG_URI("  Finished loading: '%s'", aLoadData->mURI);
     // Remove the data from the list of loading datas
     if (aLoadData->mIsLoading) {
+      nsURIAndPrincipalHashKey key(aLoadData->mURI,
+                                   aLoadData->mLoaderPrincipal);
 #ifdef DEBUG
       SheetLoadData *loadingData;
-      NS_ASSERTION(mLoadingDatas.Get(aLoadData->mURI, &loadingData) &&
+      NS_ASSERTION(mLoadingDatas.Get(&key, &loadingData) &&
                    loadingData == aLoadData,
                    "Bad loading table");
 #endif
 
-      mLoadingDatas.Remove(aLoadData->mURI);
+      mLoadingDatas.Remove(&key);
       aLoadData->mIsLoading = PR_FALSE;
     }
   }
   
   // Go through and deal with the whole linked list.
   SheetLoadData* data = aLoadData;
   while (data) {
 
@@ -1554,17 +1640,19 @@ CSSLoaderImpl::DoSheetComplete(SheetLoad
         if (!cache->GetStyleSheet(aLoadData->mURI)) {
           LOG(("  Putting sheet in XUL prototype cache"));
           cache->PutStyleSheet(aLoadData->mSheet);
         }
       }
     }
     else {
 #endif
-      mCompleteSheets.Put(aLoadData->mURI, aLoadData->mSheet);
+      nsURIAndPrincipalHashKey key(aLoadData->mURI,
+                                   aLoadData->mLoaderPrincipal);
+      mCompleteSheets.Put(&key, aLoadData->mSheet);
 #ifdef MOZ_XUL
     }
 #endif
   }
 
   NS_RELEASE(aLoadData);  // this will release parents and siblings and all that
 }
 
@@ -1589,42 +1677,48 @@ CSSLoaderImpl::LoadInlineStyle(nsIConten
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_INITIALIZED);
 
   nsCOMPtr<nsIStyleSheetLinkingElement> owningElement(do_QueryInterface(aElement));
   NS_ASSERTION(owningElement, "Element is not a style linking element!");
   
+
+  // Since we're not planning to load a URI, no need to hand a principal to the
+  // load data or to CreateSheet().
   StyleSheetState state;
   nsCOMPtr<nsICSSStyleSheet> sheet;
-  nsresult rv = CreateSheet(nsnull, aElement, PR_FALSE, state,
+  nsresult rv = CreateSheet(nsnull, aElement, nsnull, PR_FALSE, state,
                             getter_AddRefs(sheet));
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ASSERTION(state == eSheetNeedsParser,
                "Inline sheets should not be cached");
 
   rv = PrepareSheet(sheet, aTitle, aMedia, nsnull, PR_FALSE,
                     aIsAlternate);
   NS_ENSURE_SUCCESS(rv, rv);
   
   LOG(("  Sheet is alternate: %d", *aIsAlternate));
   
   rv = InsertSheetInDoc(sheet, aElement, mDocument);
   NS_ENSURE_SUCCESS(rv, rv);
   
   SheetLoadData* data = new SheetLoadData(this, aTitle, nsnull, sheet,
                                           owningElement, *aIsAlternate,
-                                          aObserver);
+                                          aObserver, nsnull);
 
   if (!data) {
     sheet->SetComplete();
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
+  // We never actually load this, so just set its principal directly
+  sheet->SetPrincipal(aElement->NodePrincipal());
+
   NS_ADDREF(data);
   data->mLineNumber = aLineNumber;
   // Parse completion releases the load data
   rv = ParseSheet(aStream, data, *aCompleted);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // If aCompleted is true, |data| may well be deleted by now.
   if (!*aCompleted) {
@@ -1657,28 +1751,31 @@ CSSLoaderImpl::LoadStyleLink(nsIContent*
   }
   
   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_INITIALIZED);
 
   // Check whether we should even load
   nsIURI *docURI = mDocument->GetDocumentURI();
   if (!docURI) return NS_ERROR_FAILURE;
 
+  nsIPrincipal* principal =
+    aElement ? aElement->NodePrincipal() : mDocument->NodePrincipal();
+
   nsISupports* context = aElement;
   if (!context) {
     context = mDocument;
   }
-  nsresult rv = CheckLoadAllowed(docURI, aURL, context);
+  nsresult rv = CheckLoadAllowed(docURI, principal, aURL, context);
   if (NS_FAILED(rv)) return rv;
 
   LOG(("  Passed load check"));
   
   StyleSheetState state;
   nsCOMPtr<nsICSSStyleSheet> sheet;
-  rv = CreateSheet(aURL, aElement, PR_FALSE, state,
+  rv = CreateSheet(aURL, aElement, principal, PR_FALSE, state,
                    getter_AddRefs(sheet));
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = PrepareSheet(sheet, aTitle, aMedia, nsnull, aHasAlternateRel,
                     aIsAlternate);
   NS_ENSURE_SUCCESS(rv, rv);
 
   LOG(("  Sheet is alternate: %d", *aIsAlternate));
@@ -1697,29 +1794,30 @@ CSSLoaderImpl::LoadStyleLink(nsIContent*
     return NS_OK;
   }
 
   nsCOMPtr<nsIStyleSheetLinkingElement> owningElement(do_QueryInterface(aElement));
 
   // Now we need to actually load it
   SheetLoadData* data = new SheetLoadData(this, aTitle, aURL, sheet,
                                           owningElement, *aIsAlternate,
-                                          aObserver);
+                                          aObserver, principal);
   if (!data) {
     sheet->SetComplete();
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   NS_ADDREF(data);
 
   // If we have to parse and it's an alternate non-inline, defer it
   if (aURL && state == eSheetNeedsParser && mLoadingDatas.Count() != 0 &&
       *aIsAlternate) {
     LOG(("  Deferring alternate sheet load"));
-    if (!mPendingDatas.Put(aURL, data)) {
+    nsURIAndPrincipalHashKey key(data->mURI, data->mLoaderPrincipal);
+    if (!mPendingDatas.Put(&key, data)) {
       return NS_ERROR_OUT_OF_MEMORY;
     }
 
     data->mMustNotify = PR_TRUE;
     return NS_OK;
   }
 
   // Load completion will free the data
@@ -1733,16 +1831,17 @@ CSSLoaderImpl::LoadStyleLink(nsIContent*
 NS_IMETHODIMP
 CSSLoaderImpl::LoadChildSheet(nsICSSStyleSheet* aParentSheet,
                               nsIURI* aURL, 
                               nsMediaList* aMedia,
                               nsICSSImportRule* aParentRule)
 {
   LOG(("CSSLoaderImpl::LoadChildSheet"));
   NS_PRECONDITION(aURL, "Must have a URI to load");
+  NS_PRECONDITION(aParentSheet, "Must have a parent sheet");
 
   if (!mEnabled) {
     LOG_WARN(("  Not enabled"));
     return NS_ERROR_NOT_AVAILABLE;
   }
   
   LOG_URI("  Child uri: '%s'", aURL);
 
@@ -1770,18 +1869,19 @@ CSSLoaderImpl::LoadChildSheet(nsICSSStyl
 
     topSheet->GetOwnerNode(getter_AddRefs(owningNode));
   }
 
   nsISupports* context = owningNode;
   if (!context) {
     context = mDocument;
   }
-  
-  rv = CheckLoadAllowed(sheetURI, aURL, context);
+
+  nsIPrincipal* principal = aParentSheet->Principal();
+  rv = CheckLoadAllowed(sheetURI, principal, aURL, context);
   if (NS_FAILED(rv)) return rv;
 
   LOG(("  Passed load check"));
   
   SheetLoadData* parentData = nsnull;
   nsCOMPtr<nsICSSLoaderObserver> observer;
 
   PRInt32 count = mParsingDatas.Count();
@@ -1810,17 +1910,17 @@ CSSLoaderImpl::LoadChildSheet(nsICSSStyl
     // we finish, if it can be, if we do the load asynchronously.
     observer = do_QueryInterface(aParentSheet);
   }
 
   // Now that we know it's safe to load this (passes security check and not a
   // loop) do so
   nsCOMPtr<nsICSSStyleSheet> sheet;
   StyleSheetState state;
-  rv = CreateSheet(aURL, nsnull,
+  rv = CreateSheet(aURL, nsnull, principal,
                    parentData ? parentData->mSyncLoad : PR_FALSE,
                    state, getter_AddRefs(sheet));
   NS_ENSURE_SUCCESS(rv, rv);
 
   const nsSubstring& empty = EmptyString();
   rv = PrepareSheet(sheet, empty, empty, aMedia);
   NS_ENSURE_SUCCESS(rv, rv);
   
@@ -1832,17 +1932,17 @@ CSSLoaderImpl::LoadChildSheet(nsICSSStyl
     // We're completely done.  No need to notify, even, since the
     // @import rule addition/modification will trigger the right style
     // changes automatically.
     return NS_OK;
   }
 
   
   SheetLoadData* data = new SheetLoadData(this, aURL, sheet, parentData,
-                                          observer);
+                                          observer, principal);
 
   if (!data) {
     sheet->SetComplete();
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   NS_ADDREF(data);
   PRBool syncLoad = data->mSyncLoad;
@@ -1902,17 +2002,17 @@ CSSLoaderImpl::InternalLoadNonDocumentSh
     LOG_WARN(("  Not enabled"));
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   StyleSheetState state;
   nsCOMPtr<nsICSSStyleSheet> sheet;
   PRBool syncLoad = (aObserver == nsnull);
   
-  nsresult rv = CreateSheet(aURL, nsnull, syncLoad, state,
+  nsresult rv = CreateSheet(aURL, nsnull, nsnull, syncLoad, state,
                             getter_AddRefs(sheet));
   NS_ENSURE_SUCCESS(rv, rv);
 
   const nsSubstring& empty = EmptyString();
   rv = PrepareSheet(sheet, empty, empty, nsnull);
   NS_ENSURE_SUCCESS(rv, rv);
   
   if (state == eSheetComplete) {
@@ -1959,17 +2059,18 @@ CSSLoaderImpl::PostLoadEvent(nsIURI* aUR
   NS_PRECONDITION(aObserver, "Must have observer");
 
   nsRefPtr<SheetLoadData> evt =
     new SheetLoadData(this, EmptyString(), // title doesn't matter here
                       aURI,
                       aSheet,
                       nsnull,  // owning element doesn't matter here
                       aWasAlternate,
-                      aObserver);
+                      aObserver,
+                      nsnull);
   NS_ENSURE_TRUE(evt, NS_ERROR_OUT_OF_MEMORY);
 
   if (!mPostedEvents.AppendElement(evt)) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   nsresult rv = NS_DispatchToCurrentThread(evt);
   if (NS_FAILED(rv)) {
@@ -2024,88 +2125,104 @@ nsresult NS_NewCSSLoader(nsICSSLoader** 
   CSSLoaderImpl* it = new CSSLoaderImpl();
 
   NS_ENSURE_TRUE(it, NS_ERROR_OUT_OF_MEMORY);
 
   return CallQueryInterface(it, aLoader);
 }
 
 PR_STATIC_CALLBACK(PLDHashOperator)
-StopLoadingSheetCallback(nsIURI* aKey, SheetLoadData*& aData, void* aClosure)
+StopLoadingSheetCallback(nsURIAndPrincipalHashKey* aKey,
+                         SheetLoadData*& aData,
+                         void* aClosure)
 {
   NS_PRECONDITION(aData, "Must have a data!");
   NS_PRECONDITION(aClosure, "Must have a loader");
 
   aData->mIsLoading = PR_FALSE; // we will handle the removal right here
   aData->mIsCancelled = PR_TRUE;
   
   NS_STATIC_CAST(CSSLoaderImpl*,aClosure)->SheetComplete(aData,
                                                          NS_BINDING_ABORTED);
 
   return PL_DHASH_REMOVE;
 }
 
 NS_IMETHODIMP
 CSSLoaderImpl::Stop()
 {
-  if (mLoadingDatas.IsInitialized() && mLoadingDatas.Count() > 0) {
-    mLoadingDatas.Enumerate(StopLoadingSheetCallback, this);
-  }
+  // Do the pending datas first, since finishing up all the loading
+  // datas will try to start pending loads.
   if (mPendingDatas.IsInitialized() && mPendingDatas.Count() > 0) {
     mPendingDatas.Enumerate(StopLoadingSheetCallback, this);
   }
+  if (mLoadingDatas.IsInitialized() && mLoadingDatas.Count() > 0) {
+    mLoadingDatas.Enumerate(StopLoadingSheetCallback, this);
+  }
   for (PRUint32 i = 0; i < mPostedEvents.Length(); ++i) {
     SheetLoadData* data = mPostedEvents[i];
     data->mIsCancelled = PR_TRUE;
     // SheetComplete() calls Release(), so give this an extra ref.
     NS_ADDREF(data);
     data->mLoader->SheetComplete(data, NS_BINDING_ABORTED);
   }
   mPostedEvents.Clear();
   return NS_OK;
 }
 
+PR_STATIC_CALLBACK(PLDHashOperator)
+StopLoadingSheetByURICallback(nsURIAndPrincipalHashKey* aKey,
+                              SheetLoadData*& aData,
+                              void* aClosure)
+{
+  NS_PRECONDITION(aData, "Must have a data!");
+  NS_PRECONDITION(aClosure, "Must have a loader");
+
+  PRBool equal;
+  if (NS_SUCCEEDED(aData->mURI->Equals(NS_STATIC_CAST(nsIURI*, aClosure),
+                                       &equal)) &&
+      equal) {
+    aData->mIsLoading = PR_FALSE; // we will handle the removal right here
+    aData->mIsCancelled = PR_TRUE;
+
+    aData->mLoader->SheetComplete(aData, NS_BINDING_ABORTED);
+
+    return PL_DHASH_REMOVE;
+  }
+
+  return PL_DHASH_NEXT;
+}
+
 NS_IMETHODIMP
 CSSLoaderImpl::StopLoadingSheet(nsIURI* aURL)
 {
   NS_ENSURE_TRUE(aURL, NS_ERROR_NULL_POINTER);
 
-  SheetLoadData* loadData = nsnull;
-  if (mLoadingDatas.IsInitialized()) {
-    mLoadingDatas.Get(aURL, &loadData);
+  // Do the pending datas first, since finishing up all the loading
+  // datas will try to start pending loads.
+  if (mPendingDatas.IsInitialized() && mPendingDatas.Count() > 0) {
+    mPendingDatas.Enumerate(StopLoadingSheetByURICallback, aURL);
   }
-  if (!loadData && mPendingDatas.IsInitialized()) {
-    mPendingDatas.Get(aURL, &loadData);
-    if (loadData) {
-      // have to remove from mPendingDatas ourselves, since
-      // SheetComplete won't do that.
-      mPendingDatas.Remove(aURL);
-    }
+  if (mLoadingDatas.IsInitialized() && mLoadingDatas.Count() > 0) {
+    mLoadingDatas.Enumerate(StopLoadingSheetByURICallback, aURL);
   }
-    
-  if (!loadData) {
-    for (PRUint32 i = 0; i < mPostedEvents.Length(); ++i) {
-      SheetLoadData* curData = mPostedEvents[i];
-      PRBool equal;
-      if (curData->mURI && NS_SUCCEEDED(curData->mURI->Equals(aURL, &equal)) &&
-          equal) {
-        loadData = curData;
-        // SheetComplete() calls Release(), so give it an extra ref.
-        NS_ADDREF(curData);
-        mPostedEvents.RemoveElementAt(i);
-        break;
-      }
+
+  for (PRUint32 i = 0; i < mPostedEvents.Length(); ++i) {
+    SheetLoadData* curData = mPostedEvents[i-1];
+    PRBool equal;
+    if (curData->mURI && NS_SUCCEEDED(curData->mURI->Equals(aURL, &equal)) &&
+        equal) {
+      curData->mIsCancelled = PR_TRUE;
+      // SheetComplete() calls Release(), so give it an extra ref.
+      NS_ADDREF(curData);
+      SheetComplete(curData, NS_BINDING_ABORTED);
     }
   }
+  mPostedEvents.Clear();
           
-  if (loadData) {
-    loadData->mIsCancelled = PR_TRUE;
-    SheetComplete(loadData, NS_BINDING_ABORTED);
-  }
-           
   return NS_OK;
 }
 
 NS_IMETHODIMP
 CSSLoaderImpl::GetEnabled(PRBool *aEnabled)
 {
   NS_ENSURE_ARG_POINTER(aEnabled);
   *aEnabled = mEnabled;
Index: layout/style/test/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/layout/style/test/Makefile.in,v
retrieving revision 1.13
diff -u -p -d -8 -r1.13 Makefile.in
--- layout/style/test/Makefile.in	25 Apr 2007 23:27:36 -0000	1.13
+++ layout/style/test/Makefile.in	28 Apr 2007 04:27:37 -0000
@@ -61,17 +61,18 @@ HOST_SIMPLE_PROGRAMS	= $(addprefix host_
 
 include $(topsrcdir)/config/rules.mk
 
 css_properties.js: host_ListCSSProperties$(HOST_BIN_SUFFIX) css_properties_like_longhand.js Makefile
 	$(RM) $@
 	./host_ListCSSProperties$(HOST_BIN_SUFFIX) > $@
 	cat $(srcdir)/css_properties_like_longhand.js >> $@
 
-_TEST_FILES = 	test_bug302186.html \
+_TEST_FILES = 	test_bug221428.html \
+		test_bug302186.html \
 		test_bug319381.html \
 		test_bug365932.html \
 		test_bug372770.html \
 		test_bug373293.html \
 		test_inherit_storage.html \
 		test_inherit_computation.html \
 		test_initial_storage.html \
 		test_initial_computation.html \
Index: layout/style/test/test_bug221428.html
===================================================================
RCS file: layout/style/test/test_bug221428.html
diff -N layout/style/test/test_bug221428.html
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ layout/style/test/test_bug221428.html	1 Mar 2007 08:02:49 -0000
@@ -0,0 +1,69 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=221428
+-->
+<head>
+  <title>Test for Bug 221428</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>        
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+  <link rel="stylesheet" href="data:text/css,body { color: green; }">
+  <style>
+    @import url("data:text/css,body { border: 1px solid transparent; }");
+    body { color: black; }
+  </style>
+  <script>
+    var executed = false;
+  </script>
+  <link rel="stylesheet" href="javascript:executed = true;">
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=221428">Mozilla Bug 221428</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 221428 **/
+
+var exceptionThrown = false;
+try {
+  is(document.styleSheets[1].cssRules[0].cssText, "body { color: green; }",
+     "Should get the color: green rule back");
+} catch (e) {
+  exceptionThrown = true;
+}
+
+ok(!exceptionThrown, "Should be able to access data: <link> stylesheet");
+
+exceptionThrown = false;
+try {
+  is(document.styleSheets[2].cssRules[1].cssText, "body { color: black; }",
+     "Should get the color: black rule back");
+} catch (e) {
+  exceptionThrown = true;
+}
+ok(!exceptionThrown, "Should be able to access <style> stylesheet");
+
+exceptionThrown = false;
+try {
+  is(document.styleSheets[2].cssRules[0].styleSheet.cssRules[0].cssText,
+     "body { border: 1px solid transparent; }",
+     "Should get the 'border: 1px solid transparent' rule back");
+} catch (e) {
+  exceptionThrown = true;
+}
+ok(!exceptionThrown, "Should be able to access data: @import stylesheet");
+
+ok(!executed,
+   "Shouldn't be executing stylesheet-link javascript: URIs against " +
+   "the page context");
+
+</script>
+</pre>
+</body>
+</html>
+
