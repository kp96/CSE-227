# HG changeset patch
# Parent 4038ffaa5d820b7ee60db411517f6d3179e17f4f
# User Atul Aggarwal <atulagrwl@gmail.com>
# Date 1329845998 -19800
Bug 703178 - Fixing Wunused-but-set-variable warning in security/manager/ssl/src. r=kaie

diff --git a/security/manager/ssl/src/nsCMSSecureMessage.cpp b/security/manager/ssl/src/nsCMSSecureMessage.cpp
--- a/security/manager/ssl/src/nsCMSSecureMessage.cpp
+++ b/security/manager/ssl/src/nsCMSSecureMessage.cpp
@@ -168,17 +168,16 @@ SendMessage(const char *msg, const char 
   nsresult rv = NS_OK;
   CERTCertificate *cert = 0;
   NSSCMSMessage *cmsMsg = 0;
   unsigned char *certDER = 0;
   PRInt32 derLen;
   NSSCMSEnvelopedData *env;
   NSSCMSContentInfo *cinfo;
   NSSCMSRecipientInfo *rcpt;
-  SECItem item;
   SECItem output;
   PLArenaPool *arena = PORT_NewArena(1024);
   SECStatus s;
   nsCOMPtr<nsIInterfaceRequestor> ctx = new PipUIContext();
 
   /* Step 0. Create a CMS Message */
   cmsMsg = NSS_CMSMessage_Create(NULL);
   if (!cmsMsg) {
@@ -213,18 +212,16 @@ SendMessage(const char *msg, const char 
   env = NSS_CMSEnvelopedData_Create(cmsMsg, SEC_OID_DES_EDE3_CBC, 0);
   if (!env) {
     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSSecureMessage::SendMessage - can't create envelope data\n"));
     rv = NS_ERROR_FAILURE;
     goto done;
   }
 
   cinfo = NSS_CMSEnvelopedData_GetContentInfo(env);
-  item.data = (unsigned char *)msg;
-  item.len = strlen(msg);  /* XPCOM equiv?? */
   s = NSS_CMSContentInfo_SetContent_Data(cmsMsg, cinfo, 0, false);
   if (s != SECSuccess) {
     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSSecureMessage::SendMessage - can't set content data\n"));
     rv = NS_ERROR_FAILURE;
     goto done;
   }
 
   rcpt = NSS_CMSRecipientInfo_Create(cmsMsg, cert);
diff --git a/security/manager/ssl/src/nsKeygenHandler.cpp b/security/manager/ssl/src/nsKeygenHandler.cpp
--- a/security/manager/ssl/src/nsKeygenHandler.cpp
+++ b/security/manager/ssl/src/nsKeygenHandler.cpp
@@ -504,17 +504,16 @@ nsresult
 nsKeygenFormProcessor::GetPublicKey(nsAString& aValue, nsAString& aChallenge, 
 				    nsAFlatString& aKeyType,
 				    nsAString& aOutPublicKey, nsAString& aKeyParams)
 {
     nsNSSShutDownPreventionLock locker;
     nsresult rv = NS_ERROR_FAILURE;
     char *keystring = nsnull;
     char *keyparamsString = nsnull, *str = nsnull;
-    KeyType type;
     PRUint32 keyGenMechanism;
     PRInt32 primeBits;
     PK11SlotInfo *slot = nsnull;
     PK11RSAGenParams rsaParams;
     SECOidTag algTag;
     int keysize = 0;
     void *params;
     SECKEYPrivateKey *privateKey = nsnull;
@@ -544,27 +543,25 @@ nsKeygenFormProcessor::GetPublicKey(nsAS
 
     arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     if (!arena) {
         goto loser;
     }
 
     // Set the keygen mechanism
     if (aKeyType.IsEmpty() || aKeyType.LowerCaseEqualsLiteral("rsa")) {
-        type = rsaKey;
         keyGenMechanism = CKM_RSA_PKCS_KEY_PAIR_GEN;
     } else if (aKeyType.LowerCaseEqualsLiteral("dsa")) {
         char * end;
         keyparamsString = ToNewCString(aKeyParams);
         if (!keyparamsString) {
             rv = NS_ERROR_OUT_OF_MEMORY;
             goto loser;
         }
 
-        type = dsaKey;
         keyGenMechanism = CKM_DSA_KEY_PAIR_GEN;
         if (strcmp(keyparamsString, "null") == 0)
             goto loser;
         str = keyparamsString;
         bool found_match = false;
         do {
             end = strchr(str, ',');
             if (end != nsnull)
@@ -581,17 +578,16 @@ nsKeygenFormProcessor::GetPublicKey(nsAS
         }
     } else if (aKeyType.LowerCaseEqualsLiteral("ec")) {
         keyparamsString = ToNewCString(aKeyParams);
         if (!keyparamsString) {
             rv = NS_ERROR_OUT_OF_MEMORY;
             goto loser;
         }
 
-        type = ecKey;
         keyGenMechanism = CKM_EC_KEY_PAIR_GEN;
         /* ecParams are initialized later */
     } else {
         goto loser;
     }
 
     // Get the slot
     rv = GetSlot(keyGenMechanism, &slot);
diff --git a/security/manager/ssl/src/nsNSSCertTrust.cpp b/security/manager/ssl/src/nsNSSCertTrust.cpp
--- a/security/manager/ssl/src/nsNSSCertTrust.cpp
+++ b/security/manager/ssl/src/nsNSSCertTrust.cpp
@@ -95,17 +95,17 @@ nsNSSCertTrust::~nsNSSCertTrust()
 
 void
 nsNSSCertTrust::SetSSLTrust(bool peer, bool tPeer,
                             bool ca,   bool tCA, bool tClientCA,
                             bool user, bool warn)
 {
   mTrust.sslFlags = 0;
   if (peer || tPeer)
-    addTrust(&mTrust.sslFlags, CERTDB_VALID_PEER);
+    addTrust(&mTrust.sslFlags, CERTDB_TERMINAL_RECORD);
   if (tPeer)
     addTrust(&mTrust.sslFlags, CERTDB_TRUSTED);
   if (ca || tCA)
     addTrust(&mTrust.sslFlags, CERTDB_VALID_CA);
   if (tClientCA)
     addTrust(&mTrust.sslFlags, CERTDB_TRUSTED_CLIENT_CA);
   if (tCA)
     addTrust(&mTrust.sslFlags, CERTDB_TRUSTED_CA);
@@ -117,17 +117,17 @@ nsNSSCertTrust::SetSSLTrust(bool peer, b
 
 void
 nsNSSCertTrust::SetEmailTrust(bool peer, bool tPeer,
                               bool ca,   bool tCA, bool tClientCA,
                               bool user, bool warn)
 {
   mTrust.emailFlags = 0;
   if (peer || tPeer)
-    addTrust(&mTrust.emailFlags, CERTDB_VALID_PEER);
+    addTrust(&mTrust.emailFlags, CERTDB_TERMINAL_RECORD);
   if (tPeer)
     addTrust(&mTrust.emailFlags, CERTDB_TRUSTED);
   if (ca || tCA)
     addTrust(&mTrust.emailFlags, CERTDB_VALID_CA);
   if (tClientCA)
     addTrust(&mTrust.emailFlags, CERTDB_TRUSTED_CLIENT_CA);
   if (tCA)
     addTrust(&mTrust.emailFlags, CERTDB_TRUSTED_CA);
@@ -139,17 +139,17 @@ nsNSSCertTrust::SetEmailTrust(bool peer,
 
 void
 nsNSSCertTrust::SetObjSignTrust(bool peer, bool tPeer,
                                 bool ca,   bool tCA, bool tClientCA,
                                 bool user, bool warn)
 {
   mTrust.objectSigningFlags = 0;
   if (peer || tPeer)
-    addTrust(&mTrust.objectSigningFlags, CERTDB_VALID_PEER);
+    addTrust(&mTrust.objectSigningFlags, CERTDB_TERMINAL_RECORD);
   if (tPeer)
     addTrust(&mTrust.objectSigningFlags, CERTDB_TRUSTED);
   if (ca || tCA)
     addTrust(&mTrust.objectSigningFlags, CERTDB_VALID_CA);
   if (tClientCA)
     addTrust(&mTrust.objectSigningFlags, CERTDB_TRUSTED_CLIENT_CA);
   if (tCA)
     addTrust(&mTrust.objectSigningFlags, CERTDB_TRUSTED_CA);
@@ -281,21 +281,21 @@ nsNSSCertTrust::HasCA(bool checkSSL,
   return true;
 }
 
 bool
 nsNSSCertTrust::HasPeer(bool checkSSL, 
                         bool checkEmail,  
                         bool checkObjSign)
 {
-  if (checkSSL && !hasTrust(mTrust.sslFlags, CERTDB_VALID_PEER))
+  if (checkSSL && !hasTrust(mTrust.sslFlags, CERTDB_TERMINAL_RECORD))
     return false;
-  if (checkEmail && !hasTrust(mTrust.emailFlags, CERTDB_VALID_PEER))
+  if (checkEmail && !hasTrust(mTrust.emailFlags, CERTDB_TERMINAL_RECORD))
     return false;
-  if (checkObjSign && !hasTrust(mTrust.objectSigningFlags, CERTDB_VALID_PEER))
+  if (checkObjSign && !hasTrust(mTrust.objectSigningFlags, CERTDB_TERMINAL_RECORD))
     return false;
   return true;
 }
 
 bool
 nsNSSCertTrust::HasAnyUser()
 {
   if (hasTrust(mTrust.sslFlags, CERTDB_USER) ||
diff --git a/security/manager/ssl/src/nsNSSCertificateDB.cpp b/security/manager/ssl/src/nsNSSCertificateDB.cpp
--- a/security/manager/ssl/src/nsNSSCertificateDB.cpp
+++ b/security/manager/ssl/src/nsNSSCertificateDB.cpp
@@ -137,32 +137,32 @@ nsNSSCertificateDB::FindCertByNickname(n
 NS_IMETHODIMP 
 nsNSSCertificateDB::FindCertByDBKey(const char *aDBkey, nsISupports *aToken,
                                    nsIX509Cert **_cert)
 {
   nsNSSShutDownPreventionLock locker;
   SECItem keyItem = {siBuffer, nsnull, 0};
   SECItem *dummy;
   CERTIssuerAndSN issuerSN;
-  unsigned long moduleID,slotID;
+  //unsigned long moduleID,slotID;
   *_cert = nsnull; 
   if (!aDBkey || !*aDBkey)
     return NS_ERROR_INVALID_ARG;
 
   dummy = NSSBase64_DecodeBuffer(nsnull, &keyItem, aDBkey,
                                  (PRUint32)PL_strlen(aDBkey)); 
   if (!dummy || keyItem.len < NS_NSS_LONG*4) {
     PR_FREEIF(keyItem.data);
     return NS_ERROR_INVALID_ARG;
   }
 
   CERTCertificate *cert;
   // someday maybe we can speed up the search using the moduleID and slotID
-  moduleID = NS_NSS_GET_LONG(keyItem.data);
-  slotID = NS_NSS_GET_LONG(&keyItem.data[NS_NSS_LONG]);
+  // moduleID = NS_NSS_GET_LONG(keyItem.data);
+  // slotID = NS_NSS_GET_LONG(&keyItem.data[NS_NSS_LONG]);
 
   // build the issuer/SN structure
   issuerSN.serialNumber.len = NS_NSS_GET_LONG(&keyItem.data[NS_NSS_LONG*2]);
   issuerSN.derIssuer.len = NS_NSS_GET_LONG(&keyItem.data[NS_NSS_LONG*3]);
   if (issuerSN.serialNumber.len == 0 || issuerSN.derIssuer.len == 0
       || issuerSN.serialNumber.len + issuerSN.derIssuer.len
          != keyItem.len - NS_NSS_LONG*4) {
     PR_FREEIF(keyItem.data);
@@ -1249,17 +1249,16 @@ GetOCSPResponders (CERTCertificate *aCer
                    void            *aArg)
 {
   nsIMutableArray *array = static_cast<nsIMutableArray*>(aArg);
   PRUnichar* nn = nsnull;
   PRUnichar* url = nsnull;
   char *serviceURL = nsnull;
   char *nickname = nsnull;
   PRUint32 i, count;
-  nsresult rv;
 
   // Are we interested in this cert //
   if (!nsOCSPResponder::IncludeCert(aCert)) {
     return SECSuccess;
   }
 
   // Get the AIA and nickname //
   serviceURL = CERT_GetOCSPAuthorityInfoAccessLocation(aCert);
@@ -1271,17 +1270,17 @@ GetOCSPResponders (CERTCertificate *aCer
   nickname = aCert->nickname;
   nn = ToNewUnicode(NS_ConvertUTF8toUTF16(nickname));
 
   nsCOMPtr<nsIOCSPResponder> new_entry = new nsOCSPResponder(nn, url);
   nsMemory::Free(nn);
   nsMemory::Free(url);
 
   // Sort the items according to nickname //
-  rv = array->GetLength(&count);
+  array->GetLength(&count);
   for (i=0; i < count; ++i) {
     nsCOMPtr<nsIOCSPResponder> entry = do_QueryElementAt(array, i);
     if (nsOCSPResponder::CompareEntries(new_entry, entry) < 0) {
       array->InsertElementAt(new_entry, i, false);
       break;
     }
   }
   if (i == count) {
@@ -1335,17 +1334,16 @@ loser:
  */
 void
 nsNSSCertificateDB::getCertNames(CERTCertList *certList,
                                  PRUint32      type, 
                                  PRUint32     *_count,
                                  PRUnichar  ***_certNames)
 {
   nsNSSShutDownPreventionLock locker;
-  nsresult rv;
   CERTCertListNode *node;
   PRUint32 numcerts = 0, i=0;
   PRUnichar **tmpArray = NULL;
   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("List of certs %d:\n", type));
   for (node = CERT_LIST_HEAD(certList);
        !CERT_LIST_END(node, certList);
        node = CERT_LIST_NEXT(node)) {
     if (getCertType(node->cert) == type) {
@@ -1359,17 +1357,17 @@ nsNSSCertificateDB::getCertNames(CERTCer
   for (node = CERT_LIST_HEAD(certList);
        !CERT_LIST_END(node, certList);
        node = CERT_LIST_NEXT(node)) {
     if (getCertType(node->cert) == type) {
       nsNSSCertificate pipCert(node->cert);
       char *dbkey = NULL;
       char *namestr = NULL;
       nsAutoString certstr;
-      rv = pipCert.GetDbKey(&dbkey);
+      pipCert.GetDbKey(&dbkey);
       nsAutoString keystr = NS_ConvertASCIItoUTF16(dbkey);
       PR_FREEIF(dbkey);
       if (type == nsIX509Cert::EMAIL_CERT) {
         namestr = node->cert->emailAddr;
       } else {
         namestr = node->cert->nickname;
         if (namestr) {
           char *sc = strchr(namestr, ':');
diff --git a/security/manager/ssl/src/nsNSSComponent.cpp b/security/manager/ssl/src/nsNSSComponent.cpp
--- a/security/manager/ssl/src/nsNSSComponent.cpp
+++ b/security/manager/ssl/src/nsNSSComponent.cpp
@@ -1360,26 +1360,24 @@ nsresult nsNSSComponent::getParamsForNex
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 nsNSSComponent::Notify(nsITimer *timer)
 {
-  nsresult rv;
-
   //Timer has fired. So set the flag accordingly
   {
     MutexAutoLock lock(mCrlTimerLock);
     crlDownloadTimerOn = false;
   }
 
   //First, handle this download
-  rv = DownloadCrlSilently();
+  DownloadCrlSilently();
 
   //Dont Worry if successful or not
   //Set the next timer
   DefineNextTimer();
   return NS_OK;
 }
 
 nsresult
@@ -2275,21 +2273,19 @@ nsNSSComponent::Observe(nsISupports *aSu
   }
   else if (nsCRT::strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID) == 0) {
 
     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent: XPCom shutdown observed\n"));
 
     // Cleanup code that requires services, it's too late in destructor.
 
     if (mPSMContentListener) {
-      nsresult rv = NS_ERROR_FAILURE;
-
       nsCOMPtr<nsIURILoader> dispatcher(do_GetService(NS_URI_LOADER_CONTRACTID));
       if (dispatcher) {
-        rv = dispatcher->UnRegisterContentListener(mPSMContentListener);
+        dispatcher->UnRegisterContentListener(mPSMContentListener);
       }
       mPSMContentListener = nsnull;
     }
 
     nsCOMPtr<nsIEntropyCollector> ec
         = do_GetService(NS_ENTROPYCOLLECTOR_CONTRACTID);
 
     if (ec) {
