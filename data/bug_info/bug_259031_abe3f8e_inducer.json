{"bug_id":259031,"commitHash":"abe3f8e","commit_info":{"sha":"abe3f8e6c511bf086b1fe05912fa3c7503b3947e","commit":{"author":{"name":"kaie%kuix.de","email":"kaie%kuix.de","date":"2005-12-02T22:29:14Z"},"committer":{"name":"kaie%kuix.de","email":"kaie%kuix.de","date":"2005-12-02T22:29:14Z"},"message":"Bug 259031, Add support for displaying certificate extensions\nPatch provided by Martin v. Loewis\nr=rrelyea r=kengert sr=shaver","tree":{"sha":"05ad0ec17ddc15249d89bbdc987c8ebc5cca32e3","url":"https://api.github.com/repos/mozilla/gecko-dev/git/trees/05ad0ec17ddc15249d89bbdc987c8ebc5cca32e3"},"url":"https://api.github.com/repos/mozilla/gecko-dev/git/commits/abe3f8e6c511bf086b1fe05912fa3c7503b3947e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/mozilla/gecko-dev/commits/abe3f8e6c511bf086b1fe05912fa3c7503b3947e","html_url":"https://github.com/mozilla/gecko-dev/commit/abe3f8e6c511bf086b1fe05912fa3c7503b3947e","comments_url":"https://api.github.com/repos/mozilla/gecko-dev/commits/abe3f8e6c511bf086b1fe05912fa3c7503b3947e/comments","author":null,"committer":null,"parents":[{"sha":"e6c12ea90c540345b19c63520931006d1b0183e1","url":"https://api.github.com/repos/mozilla/gecko-dev/commits/e6c12ea90c540345b19c63520931006d1b0183e1","html_url":"https://github.com/mozilla/gecko-dev/commit/e6c12ea90c540345b19c63520931006d1b0183e1"}],"stats":{"total":923,"additions":895,"deletions":28},"files":[{"sha":"b0d4d618f7c4759b612ea445e17894268e860d8d","filename":"security/manager/locales/en-US/chrome/pipnss/pipnss.properties","status":"modified","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/mozilla/gecko-dev/blob/abe3f8e6c511bf086b1fe05912fa3c7503b3947e/security/manager/locales/en-US/chrome/pipnss/pipnss.properties","raw_url":"https://github.com/mozilla/gecko-dev/raw/abe3f8e6c511bf086b1fe05912fa3c7503b3947e/security/manager/locales/en-US/chrome/pipnss/pipnss.properties","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/security/manager/locales/en-US/chrome/pipnss/pipnss.properties?ref=abe3f8e6c511bf086b1fe05912fa3c7503b3947e","patch":"@@ -175,6 +175,46 @@ CertDumpNonCritical=Not Critical\n CertDumpSigAlg=Certificate Signature Algorithm\n CertDumpCertSig=Certificate Signature Value\n CertDumpExtensionFailure=Error: Unable to process extension\n+CertDumpIsCA=Is a Certificate Authority\n+CertDumpIsNotCA=Is not a Certificate Authority\n+CertDumpPathLen=Maximum number of intermediate CAs: %S\n+CertDumpEKU_1_3_6_1_5_5_7_3_1=TLS Web Server Authentication\n+CertDumpEKU_1_3_6_1_5_5_7_3_2=TLS Web Client Authentication\n+CertDumpEKU_1_3_6_1_5_5_7_3_3=Signing of downloadable executable code\n+CertDumpEKU_1_3_6_1_5_5_7_3_4=E-mail protection\n+CertDumpEKU_1_3_6_1_5_5_7_3_8=Time Stamping\n+CertDumpEKU_1_3_6_1_4_1_311_2_1_21=Microsoft Individual Code Signing (authenticode)\n+CertDumpEKU_1_3_6_1_4_1_311_2_1_22=Microsoft Commercial Code Signing (authenticode)\n+CertDumpEKU_1_3_6_1_4_1_311_10_3_1=Microsoft Trust List Signing\n+CertDumpEKU_1_3_6_1_4_1_311_10_3_2=Microsoft Timestamp Signing\n+CertDumpEKU_1_3_6_1_4_1_311_10_3_3=Microsoft Strong Crypto Approved\n+CertDumpMSCerttype=Microsoft CA Certificate Type\n+CertDumpEKU_1_3_6_1_4_1_311_10_3_4=Microsoft Encrypting Filesystem\n+CertDumpEKU_1_3_6_1_4_1_311_10_3_4_1=Microsoft Encrypting Filesystem Recovery Agent\n+CertDumpMSNTPrincipal=Microsoft NT User Principal Name\n+CertDumpMSCAVersion=Microsoft CA Version\n+CertDumpMSDomainGUID=Microsoft Domain GUID\n+CertDumpEKU_2_16_840_1_113730_4_1=Netscape Strong Crypto Approved\n+CertDumpRFC822Name=E-Mail Address\n+CertDumpDNSName=DNS Name\n+CertDumpX400Address=X.400 Address\n+CertDumpDirectoryName=X.500 Name\n+CertDumpEDIPartyName=EDI Party Name\n+CertDumpURI=URI\n+CertDumpIPAddress=IP Address\n+CertDumpRegisterID=Registered OID\n+CertDumpKeyID=Key ID\n+CertDumpVerisignNotices=Verisign User Notices\n+CertDumpUnused=Unused\n+CertDumpKeyCompromise=Key Compromise\n+CertDumpCACompromise=CA Compromise\n+CertDumpAffiliationChanged=Affiliation Changed\n+CertDumpSuperseded=Superseded\n+CertDumpCessation=Cessation of Operation\n+CertDumpHold=Certificate Hold\n+CertDumpCAIssuers=Authority Issuer Path\n+CertDumpCPSPointer=Certification Practice Statement pointer\n+CertDumpUserNotice=User Notice\n VerifySSLClient_p=Client\n VerifySSLServer_p=Server\n VerifySSLStepUp_p=Step-up"},{"sha":"cf12d212d5b2bf0bfa7775b89c912e72764466b8","filename":"security/manager/ssl/src/nsNSSCertHelper.cpp","status":"modified","additions":855,"deletions":28,"changes":883,"blob_url":"https://github.com/mozilla/gecko-dev/blob/abe3f8e6c511bf086b1fe05912fa3c7503b3947e/security/manager/ssl/src/nsNSSCertHelper.cpp","raw_url":"https://github.com/mozilla/gecko-dev/raw/abe3f8e6c511bf086b1fe05912fa3c7503b3947e/security/manager/ssl/src/nsNSSCertHelper.cpp","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/security/manager/ssl/src/nsNSSCertHelper.cpp?ref=abe3f8e6c511bf086b1fe05912fa3c7503b3947e","patch":"@@ -22,6 +22,7 @@\n  *   Ian McGreer <mcgreer@netscape.com>\n  *   Javier Delgadillo <javi@netscape.com>\n  *   John Gardiner Myers <jgmyers@speakeasy.net>\n+ *   Martin v. Loewis <martin@v.loewis.de>\n  *\n  * Alternatively, the contents of this file may be used under the terms of\n  * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n@@ -55,6 +56,43 @@\n static NS_DEFINE_CID(kDateTimeFormatCID, NS_DATETIMEFORMAT_CID);\n static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);\n \n+/* Object Identifier constants */\n+#define CONST_OID static const unsigned char\n+#define MICROSOFT_OID 0x2b, 0x6, 0x1, 0x4, 0x1, 0x82, 0x37\n+CONST_OID msCertExtCerttype[]      = { MICROSOFT_OID, 20, 2};\n+CONST_OID msNTPrincipalName[]      = { MICROSOFT_OID, 20, 2, 3 };\n+CONST_OID msCertsrvCAVersion[]     = { MICROSOFT_OID, 21, 1 };\n+CONST_OID msNTDSReplication[]      = { MICROSOFT_OID, 25, 1 };\n+\n+#define OI(x) { siDEROID, (unsigned char *)x, sizeof x }\n+#define OD(oid,desc,mech,ext) {OI(oid), SEC_OID_UNKNOWN, desc, mech, ext}\n+#define SEC_OID(tag) more_oids[tag].offset\n+\n+static SECOidData more_oids[] = {\n+    /* Microsoft OIDs */\n+    #define MS_CERT_EXT_CERTTYPE 0\n+    OD( msCertExtCerttype,\n+        \"Microsoft Certificate Type\", \n+        CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION ),\n+\n+    #define MS_NT_PRINCIPAL_NAME 1\n+    OD( msNTPrincipalName,\n+        \"Microsoft NT User Principal Name\", \n+        CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION ),\n+\n+    #define MS_CERTSERV_CA_VERSION 2\n+    OD( msCertsrvCAVersion,\n+        \"Microsoft CA Version\", \n+        CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION ),\n+\n+    #define MS_NTDS_REPLICATION 3\n+    OD( msNTDSReplication,\n+        \"Microsoft Domain GUID\", \n+        CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION ),\n+};\n+\n+static const unsigned int numOids = (sizeof more_oids) / (sizeof more_oids[0]);\n+\n static nsresult\n GetIntValue(SECItem *versionItem, \n             unsigned long *version)\n@@ -158,7 +196,8 @@ ProcessSerialNumberDER(SECItem         *serialItem,\n \n static nsresult\n GetDefaultOIDFormat(SECItem *oid,\n-                    nsAString &outString)\n+                    nsAString &outString,\n+\t\t    char separator)\n {\n   char buf[300];\n   unsigned int len;\n@@ -167,7 +206,7 @@ GetDefaultOIDFormat(SECItem *oid,\n   unsigned long val  = oid->data[0];\n   unsigned int  i    = val % 40;\n   val /= 40;\n-  written = PR_snprintf(buf, 300, \"%lu %u \", val, i);\n+  written = PR_snprintf(buf, 300, \"%lu%c%u\", val, separator, i);\n   if (written < 0)\n     return NS_ERROR_FAILURE;\t\n   len = written;\n@@ -186,7 +225,8 @@ GetDefaultOIDFormat(SECItem *oid,\n     val = (val << 7) | (j & 0x7f);\n     if (j & 0x80)\n       continue;\n-    written = PR_snprintf(&buf[len], sizeof(buf)-len, \"%lu \", val);\n+    written = PR_snprintf(&buf[len], sizeof(buf)-len, \"%c%lu\", \n+\t\t\t  separator, val);\n     if (written < 0)\n       return NS_ERROR_FAILURE;\n \n@@ -342,14 +382,23 @@ GetOIDText(SECItem *oid, nsINSSComponent *nssComponent, nsAString &text)\n   case SEC_OID_PKCS9_EMAIL_ADDRESS:\n     bundlekey = \"CertDumpPK9Email\";\n     break;\n-  default: ;\n+  default: \n+    if (oidTag == SEC_OID(MS_CERT_EXT_CERTTYPE)) {\n+      bundlekey = \"CertDumpMSCerttype\";\n+      break;\n+    }\n+    if (oidTag == SEC_OID(MS_CERTSERV_CA_VERSION)) {\n+      bundlekey = \"CertDumpMSCAVersion\";\n+      break;\n+    }\n+    /* fallthrough */\n   }\n \n   if (bundlekey) {\n     rv = nssComponent->GetPIPNSSBundleString(bundlekey, text);\n   } else {\n     nsAutoString text2;\n-    rv = GetDefaultOIDFormat(oid, text2);\n+    rv = GetDefaultOIDFormat(oid, text2, ' ');\n     if (NS_FAILED(rv))\n       return rv;\n \n@@ -494,22 +543,129 @@ ProcessKeyUsageExtension(SECItem *extData, nsAString &text,\n }\n \n static nsresult\n-ProcessName(CERTName *name, nsINSSComponent *nssComponent, PRUnichar **value)\n+ProcessBasicConstraints(SECItem  *extData, \n+                        nsAString &text,\n+                        nsINSSComponent *nssComponent)\n {\n-  CERTRDN** rdns;\n-  CERTRDN** rdn;\n+  nsAutoString local;\n+  CERTBasicConstraints value;\n+  SECStatus rv;\n+  nsresult rv2;\n+\n+  rv = CERT_DecodeBasicConstraintValue (&value, extData);\n+  if (rv != SECSuccess) {\n+    NS_ASSERTION(0,\"Could not decode basic constraints\");\n+    return NS_ERROR_FAILURE;\n+  }\n+  if (value.isCA)\n+    rv2 = nssComponent->GetPIPNSSBundleString(\"CertDumpIsCA\", local);\n+  else\n+    rv2 = nssComponent->GetPIPNSSBundleString(\"CertDumpIsNotCA\", local);\n+  if (NS_FAILED(rv2))\n+    return rv2;\n+  text.Append(local.get());\n+  if (value.pathLenConstraint >= 0) {\n+    nsAutoString depth;\n+    depth.AppendInt(value.pathLenConstraint);\n+    const PRUnichar *params[1] = {depth.get()};\n+    rv2 = nssComponent->PIPBundleFormatStringFromName(\"CertDumpPathLen\",\n+                                                      params, 1, local);\n+    if (NS_FAILED(rv2))\n+      return rv2;\n+    text.Append(NS_LITERAL_STRING(SEPARATOR).get());\n+    text.Append(local.get());\n+  }\n+  return NS_OK;\n+}\n+\n+static nsresult\n+ProcessExtKeyUsage(SECItem  *extData, \n+                   nsAString &text,\n+                   nsINSSComponent *nssComponent)\n+{\n+  nsAutoString local;\n+  CERTOidSequence *extKeyUsage = NULL;\n+  SECItem **oids;\n+  SECItem *oid;\n+  nsresult rv;\n+  \n+  extKeyUsage = CERT_DecodeOidSequence(extData);\n+  if (extKeyUsage == NULL)\n+    return NS_ERROR_FAILURE;\n+\n+  oids = extKeyUsage->oids;\n+  while (oids != NULL && *oids != NULL) {\n+    // For each OID, try to find a bundle string\n+    // of the form CertDumpEKU_<underlined-OID>\n+    nsAutoString oidname;\n+    oid = *oids;\n+    rv = GetDefaultOIDFormat(oid, oidname, '_');\n+    if (NS_FAILED(rv))\n+      return rv;\n+    nsAutoString bundlekey = NS_LITERAL_STRING(\"CertDumpEKU_\")+ oidname;\n+    NS_ConvertUTF16toUTF8 bk_ascii(bundlekey);\n+    \n+    rv = nssComponent->GetPIPNSSBundleString(bk_ascii.get(), local);\n+    if (NS_FAILED(rv))\n+      // If there is no bundle string, just display the OID itself\n+      rv = GetDefaultOIDFormat(oid, local, ' ');\n+    if (NS_FAILED(rv))\n+      return rv;\n+\n+    text.Append(local.get());\n+    text.Append(NS_LITERAL_STRING(SEPARATOR).get());\n+    oids++;\n+  }\n+\n+  CERT_DestroyOidSequence(extKeyUsage);\n+  return NS_OK;\n+}\n+\n+static nsresult\n+ProcessRDN(CERTRDN* rdn, nsAString &finalString, nsINSSComponent *nssComponent)\n+{\n+  nsresult rv;\n   CERTAVA** avas;\n   CERTAVA* ava;\n   SECItem *decodeItem = nsnull;\n+  nsString avavalue;\n+  nsString type;\n+  nsAutoString temp;\n+  const PRUnichar *params[2];\n+\n+  avas = rdn->avas;\n+  while ((ava = *avas++) != 0) {\n+    rv = GetOIDText(&ava->type, nssComponent, type);\n+    if (NS_FAILED(rv))\n+      return rv;\n+    \n+    //This function returns a string in UTF8 format.\n+    decodeItem = CERT_DecodeAVAValue(&ava->value);\n+    if(!decodeItem) {\n+      return NS_ERROR_FAILURE;\n+    }\n+    avavalue = NS_ConvertUTF8toUTF16((char*)decodeItem->data, decodeItem->len);\n+    \n+    SECITEM_FreeItem(decodeItem, PR_TRUE);\n+    params[0] = type.get();\n+    params[1] = avavalue.get();\n+    nssComponent->PIPBundleFormatStringFromName(\"AVATemplate\",\n+                                                  params, 2, temp);\n+    finalString += temp + NS_LITERAL_STRING(\"\\n\");\n+  }\n+  return NS_OK;\n+}\n+\n+static nsresult\n+ProcessName(CERTName *name, nsINSSComponent *nssComponent, PRUnichar **value)\n+{\n+  CERTRDN** rdns;\n+  CERTRDN** rdn;\n   nsString finalString;\n \n   rdns = name->rdns;\n \n-  nsString type;\n   nsresult rv;\n-  const PRUnichar *params[2];\n-  nsString avavalue;\n-  nsAutoString temp;\n   CERTRDN **lastRdn;\n   lastRdn = rdns;\n \n@@ -534,28 +690,630 @@ ProcessName(CERTName *name, nsINSSComponent *nssComponent, PRUnichar **value)\n    * value portion of the AVA and could cause trouble when parsing.\n    */\n   for (rdn = lastRdn; rdn >= rdns; rdn--) {\n-    avas = (*rdn)->avas;\n-    while ((ava = *avas++) != 0) {\n-      rv = GetOIDText(&ava->type, nssComponent, type);\n+    rv = ProcessRDN(*rdn, finalString, nssComponent);\n+    if (NS_FAILED(rv))\n+      return rv;\n+  }\n+  *value = ToNewUnicode(finalString);    \n+  return NS_OK;\n+}\n+\n+static nsresult\n+ProcessIA5String(SECItem  *extData, \n+\t\t nsAString &text,\n+\t\t nsINSSComponent *nssComponent)\n+{\n+  SECItem item;\n+  nsAutoString local;\n+  if (SECSuccess != SEC_ASN1DecodeItem(nsnull, &item, \n+\t\t\t\t       SEC_IA5StringTemplate,\n+\t\t\t\t       extData))\n+    return NS_ERROR_FAILURE;\n+  local.AssignASCII((char*)item.data, item.len);\n+  nsMemory::Free(item.data);\n+  text.Append(local);\n+  return NS_OK;\n+}\n+\n+static nsresult\n+AppendBMPtoUTF16(PRArenaPool *arena,\n+\t\t unsigned char* data, unsigned int len,\n+\t\t nsAString& text)\n+{\n+  unsigned int   utf8ValLen;\n+  unsigned char *utf8Val;\n+\n+  if (len % 2 != 0)\n+    return NS_ERROR_FAILURE;\n+\n+  /* XXX instead of converting to and from UTF-8, it would\n+     be sufficient to just swap bytes, or do nothing */\n+  utf8ValLen = len * 3 + 1;\n+  utf8Val = (unsigned char*)PORT_ArenaZAlloc(arena, utf8ValLen);\n+  if (!PORT_UCS2_UTF8Conversion(PR_FALSE, data, len,\n+\t\t\t\tutf8Val, utf8ValLen, &utf8ValLen))\n+    return NS_ERROR_FAILURE;\n+  AppendUTF8toUTF16((char*)utf8Val, text);\n+  return NS_OK;\n+}\n+\n+static nsresult\n+ProcessBMPString(SECItem  *extData, \n+\t\t nsAString &text,\n+\t\t nsINSSComponent *nssComponent)\n+{\n+  SECItem item;\n+  PRArenaPool *arena;\n+  nsresult rv = NS_ERROR_FAILURE;\n+  \n+  arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);\n+  if (!arena)\n+    return NS_ERROR_FAILURE;\n+\n+  if (SECSuccess == SEC_ASN1DecodeItem(arena, &item, \n+\t\t\t\t       SEC_BMPStringTemplate,\n+\t\t\t\t       extData))\n+    rv = AppendBMPtoUTF16(arena, item.data, item.len, text);\n+  PORT_FreeArena(arena, PR_FALSE);\n+  return rv;\n+}\n+\n+static nsresult\n+ProcessGeneralName(PRArenaPool *arena,\n+\t\t   CERTGeneralName *current,\n+\t\t   nsAString &text,\n+\t\t   nsINSSComponent *nssComponent)\n+{\n+  nsAutoString key;\n+  nsXPIDLString value;\n+  nsresult rv = NS_OK;\n+\n+  switch (current->type) {\n+  case certOtherName: {\n+    SECOidTag oidTag = SECOID_FindOIDTag(&current->name.OthName.oid);\n+    if (oidTag == SEC_OID(MS_NT_PRINCIPAL_NAME)) {\n+\t/* The type of this name is apparently nowhere explicitly\n+\t   documented. However, in the generated templates, it is always\n+\t   UTF-8. So try to decode this as UTF-8; if that fails, dump the\n+\t   raw data. */\n+\tSECItem decoded;\n+\tnssComponent->GetPIPNSSBundleString(\"CertDumpMSNTPrincipal\", key);\n+\tif (SEC_ASN1DecodeItem(arena, &decoded, \n+\t\t\t       SEC_ASN1_GET(SEC_UTF8StringTemplate), \n+\t\t\t       &current->name.OthName.name) == SECSuccess) {\n+\t  AppendUTF8toUTF16(nsCAutoString((char*)decoded.data, decoded.len),\n+\t\t\t    value);\n+\t} else {\n+\t  ProcessRawBytes(&current->name.OthName.name, value);\n+\t}\n+\tbreak;\n+    } else if (oidTag == SEC_OID(MS_NTDS_REPLICATION)) {\n+\t/* This should be a 16-byte GUID */\n+\tSECItem guid;\n+\tnssComponent->GetPIPNSSBundleString(\"CertDumpMSDomainGUID\", key);\n+\tif (SEC_ASN1DecodeItem(arena, &guid,\n+\t\t\t       SEC_ASN1_GET(SEC_OctetStringTemplate),\n+\t\t\t       &current->name.OthName.name) == SECSuccess\n+\t    && guid.len == 16) {\n+\t  char buf[40];\n+\t  unsigned char *d = guid.data;\n+\t  PR_snprintf(buf, sizeof(buf), \n+\t\t      \"{%.2x%.2x%.2x%.2x-%.2x%.2x-%.2x%.2x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}\",\n+\t\t      d[3], d[2], d[1], d[0], d[5], d[4], d[7], d[6],\n+\t\t      d[8], d[9], d[10], d[11], d[12], d[13], d[14], d[15]);\n+\t  value.AssignASCII(buf);\n+\t} else {\n+\t  ProcessRawBytes(&current->name.OthName.name, value);\n+\t}\n+    } else {\n+      rv = GetDefaultOIDFormat(&current->name.OthName.oid, key, ' ');\n       if (NS_FAILED(rv))\n-        return rv;\n+\tgoto finish;\n+      ProcessRawBytes(&current->name.OthName.name, value);\n+    }\n+    break;\n+  }\n+  case certRFC822Name:\n+    nssComponent->GetPIPNSSBundleString(\"CertDumpRFC822Name\", key);\n+    value.AssignASCII((char*)current->name.other.data, current->name.other.len);\n+    break;\n+  case certDNSName:\n+    nssComponent->GetPIPNSSBundleString(\"CertDumpDNSName\", key);\n+    value.AssignASCII((char*)current->name.other.data, current->name.other.len);\n+    break;\n+  case certX400Address:\n+    nssComponent->GetPIPNSSBundleString(\"CertDumpX400Address\", key);\n+    ProcessRawBytes(&current->name.other, value);\n+    break;\n+  case certDirectoryName:\n+    nssComponent->GetPIPNSSBundleString(\"CertDumpDirectoryName\", key);\n+    rv = ProcessName(&current->name.directoryName, nssComponent, \n+\t\t     getter_Copies(value));\n+    if (NS_FAILED(rv))\n+      goto finish;\n+    break;\n+  case certEDIPartyName:\n+    nssComponent->GetPIPNSSBundleString(\"CertDumpEDIPartyName\", key);\n+    ProcessRawBytes(&current->name.other, value);\n+    break;\n+  case certURI:\n+    nssComponent->GetPIPNSSBundleString(\"CertDumpURI\", key);\n+    value.AssignASCII((char*)current->name.other.data, current->name.other.len);\n+    break;\n+  case certIPAddress:\n+    {\n+      char buf[INET6_ADDRSTRLEN];\n+      nssComponent->GetPIPNSSBundleString(\"CertDumpIPAddress\", key);\n+      if (current->name.other.len == 4)\n+\tinet_ntop(AF_INET, current->name.other.data, buf, sizeof(buf));\n+      else if (current->name.other.len == 16)\n+\tinet_ntop(AF_INET6, current->name.other.data, buf, sizeof(buf));\n+      else\n+\tstrcpy(buf, \"Invalid IP address\");\n+      value.AssignASCII(buf);\n+      break;\n+    }\n+  case certRegisterID:\n+    nssComponent->GetPIPNSSBundleString(\"CertDumpRegisterID\", key);\n+    rv = GetDefaultOIDFormat(&current->name.other, value, '.');\n+    if (NS_FAILED(rv))\n+      goto finish;\n+    break;\n+  }\n+  text.Append(key);\n+  text.Append(NS_LITERAL_STRING(\": \"));\n+  text.Append(value);\n+  text.Append(NS_LITERAL_STRING(SEPARATOR));\n+ finish:\n+    return rv;\n+}\n+\n+static nsresult\n+ProcessGeneralNames(PRArenaPool *arena,\n+\t\t    CERTGeneralName *nameList,\n+\t\t    nsAString &text,\n+\t\t    nsINSSComponent *nssComponent)\n+{\n+  CERTGeneralName *current = nameList;\n+  nsresult rv;\n+\n+  do {\n+    rv = ProcessGeneralName(arena, current, text, nssComponent);\n+    if (NS_FAILED(rv))\n+      break;\n+    current = CERT_GetNextGeneralName(current);\n+  } while (current != nameList);\n+  return rv;\n+}\n+\n+static nsresult\n+ProcessAltName(SECItem  *extData, \n+\t       nsAString &text,\n+\t       nsINSSComponent *nssComponent)\n+{\n+  nsresult rv = NS_OK;\n+  PRArenaPool *arena;\n+  CERTGeneralName *nameList;\n+\n+  arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);\n+  if (!arena)\n+    return NS_ERROR_FAILURE;\n+\n+  nameList = CERT_DecodeAltNameExtension(arena, extData);\n+  if (!nameList)\n+    goto finish;\n+\n+  rv = ProcessGeneralNames(arena, nameList, text, nssComponent);\n+\n+ finish:\n+  PORT_FreeArena(arena, PR_FALSE);\n+  return rv;\n+}\n+\n+static nsresult\n+ProcessSubjectKeyId(SECItem  *extData, \n+\t\t    nsAString &text,\n+\t\t    nsINSSComponent *nssComponent)\n+{\n+  PRArenaPool *arena;\n+  nsresult rv = NS_OK;\n+  SECItem decoded;\n+  nsAutoString local;\n+\n+  arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);\n+  if (!arena)\n+    return NS_ERROR_FAILURE;\n \n-      //This function returns a string in UTF8 format.\n-      decodeItem = CERT_DecodeAVAValue(&ava->value);\n-      if(!decodeItem) {\n-         return NS_ERROR_FAILURE;\n+  if (SEC_QuickDERDecodeItem(arena, &decoded, \n+\t\t\t     SEC_OctetStringTemplate, \n+\t\t\t     extData) != SECSuccess) {\n+    rv = NS_ERROR_FAILURE;\n+    goto finish;\n+  }\n+  \n+  nssComponent->GetPIPNSSBundleString(\"CertDumpKeyID\", local);\n+  text.Append(local);\n+  text.Append(NS_LITERAL_STRING(\": \"));\n+  ProcessRawBytes(&decoded, text);\n+\n+ finish:\n+  PORT_FreeArena(arena, PR_FALSE);\n+  return rv;\n+}\n+\n+static nsresult\n+ProcessAuthKeyId(SECItem  *extData, \n+\t\t nsAString &text,\n+\t\t nsINSSComponent *nssComponent)\n+{\n+  CERTAuthKeyID *ret;\n+  PRArenaPool *arena;\n+  nsresult rv = NS_OK;\n+  nsAutoString local;\n+\n+  arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);\n+  if (!arena)\n+    return NS_ERROR_FAILURE;\n+\n+  ret = CERT_DecodeAuthKeyID (arena, extData);\n+\n+  if (ret->keyID.len > 0) {\n+    nssComponent->GetPIPNSSBundleString(\"CertDumpKeyID\", local);\n+    text.Append(local);\n+    text.Append(NS_LITERAL_STRING(\": \"));\n+    ProcessRawBytes(&ret->keyID, text);\n+    text.Append(NS_LITERAL_STRING(SEPARATOR));\n+  }\n+\n+  if (ret->authCertIssuer) {\n+    nssComponent->GetPIPNSSBundleString(\"CertDumpIssuer\", local);\n+    text.Append(local);\n+    text.Append(NS_LITERAL_STRING(\": \"));\n+    rv = ProcessGeneralNames(arena, ret->authCertIssuer, text, nssComponent);\n+    if (NS_FAILED(rv))\n+      goto finish;\n+  }\n+\n+  if (ret->authCertSerialNumber.len > 0) {\n+    nssComponent->GetPIPNSSBundleString(\"CertDumpSerialNo\", local);\n+    text.Append(local);\n+    text.Append(NS_LITERAL_STRING(\": \"));\n+    ProcessRawBytes(&ret->authCertSerialNumber, text);\n+  }\n+\n+ finish:\n+  PORT_FreeArena(arena, PR_FALSE);\n+  return rv;\n+}\n+\n+enum DisplayTextForm { VisibleForm, BMPForm, UTF8Form };\n+\n+struct DisplayText {\n+  DisplayTextForm variant;\n+  SECItem value;\n+};\n+\n+const SEC_ASN1Template DisplayTextTemplate[] = {\n+    { SEC_ASN1_CHOICE,\n+      offsetof(DisplayText, variant), NULL,\n+      sizeof(DisplayText) },\n+    { SEC_ASN1_VISIBLE_STRING, \n+      offsetof(DisplayText, value), NULL, VisibleForm },\n+    { SEC_ASN1_BMP_STRING, \n+      offsetof(DisplayText, value), NULL, BMPForm },\n+    { SEC_ASN1_UTF8_STRING, \n+      offsetof(DisplayText, value), NULL, UTF8Form },\n+    { 0 }\n+};\n+\n+static nsresult\n+ProcessUserNotice(SECItem *der_notice,\n+\t\t  nsAString &text,\n+\t\t  nsINSSComponent *nssComponent)\n+{\n+  nsresult rv = NS_OK;\n+  CERTUserNotice *notice = NULL;\n+  SECItem **itemList;\n+  DisplayText display;\n+  PRArenaPool *arena;\n+  char *buf;\n+\n+  arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);\n+  if (!arena)\n+    return NS_ERROR_FAILURE;\n+\n+  notice = CERT_DecodeUserNotice(der_notice);\n+  /* XXX: currently, polcyxtn.c assumes that organization\n+     is an IA5String, whereas it really ought to be a\n+     choice of VisibleString, BMPString, and UTF8String.\n+     So if decoding of the user notice fails, it is most likely\n+     that the organization was encoded in an unexpected way.\n+     Make this function return \"something\" in this case,\n+     instead letting the decode for the entire certificate\n+     fail.\n+  */\n+  if (notice == NULL) {\n+    text.Append(NS_LITERAL_STRING(\"<implementation limitation>\"));\n+    goto finish;\n+  }\n+\n+  if (notice->noticeReference.organization.len != 0) {\n+    rv = ProcessIA5String(&notice->noticeReference.organization,\n+\t\t\t  text, nssComponent);\n+    if (NS_FAILED(rv))\n+      goto finish;\n+\n+    itemList = notice->noticeReference.noticeNumbers;\n+    while (*itemList) {\n+      unsigned long number;\n+      char buffer[60];\n+      if (SEC_ASN1DecodeInteger(*itemList, &number) != SECSuccess) {\n+\trv = NS_ERROR_FAILURE;\n+\tgoto finish;\n       }\n-      avavalue = NS_ConvertUTF8toUTF16((char*)decodeItem->data, decodeItem->len);\n+      PR_snprintf(buffer, sizeof(buffer), \"%d \", number);\n+      AppendASCIItoUTF16(buffer, text);\n+      itemList++;\n+    }\n+  }\n+  if (notice->displayText.len != 0) {\n+    if (SEC_QuickDERDecodeItem(arena, &display,\n+\t\t\t       DisplayTextTemplate,\n+\t\t\t       &notice->displayText) != SECSuccess) {\n+      rv = NS_ERROR_FAILURE;\n+      goto finish;\n+    }\n+    switch (display.variant) {\n+    case VisibleForm:\n+      /* Need to null-terminate string before appending it. */\n+      buf = (char*)PORT_ArenaAlloc(arena, display.value.len+1);\n+      PORT_Memcpy(buf, display.value.data, display.value.len);\n+      buf[display.value.len] = '\\0';\n+      text.AppendASCII(buf);\n+      break;\n+    case BMPForm:\n+      AppendBMPtoUTF16(arena, display.value.data, display.value.len,\n+\t\t       text);\n+      break;\n+    case UTF8Form:\n+      buf = (char*)PORT_ArenaAlloc(arena, display.value.len+1);\n+      PORT_Memcpy(buf, display.value.data, display.value.len);\n+      buf[display.value.len] = '\\0';\n+      AppendUTF8toUTF16(buf, text);\n+      break;\n+    }\n+  }\n+ finish:\n+  if (notice)\n+    CERT_DestroyUserNotice(notice);\n+  PORT_FreeArena(arena, PR_FALSE);\n+  return rv;\n+}\n \n-      SECITEM_FreeItem(decodeItem, PR_TRUE);\n-      params[0] = type.get();\n-      params[1] = avavalue.get();\n-      nssComponent->PIPBundleFormatStringFromName(\"AVATemplate\",\n-                                                  params, 2, temp);\n-      finalString += temp + NS_LITERAL_STRING(\"\\n\");\n+static nsresult\n+ProcessCertificatePolicies(SECItem  *extData, \n+\t\t\t   nsAString &text,\n+\t\t\t   nsINSSComponent *nssComponent)\n+{\n+  CERTCertificatePolicies *policies;\n+  CERTPolicyInfo **policyInfos, *policyInfo;\n+  CERTPolicyQualifier **policyQualifiers, *policyQualifier;\n+  nsAutoString local;\n+  nsresult rv = NS_OK;\n+\n+  policies = CERT_DecodeCertificatePoliciesExtension(extData);\n+  if ( policies == NULL )\n+    return NS_ERROR_FAILURE;\n+\n+  policyInfos = policies->policyInfos;\n+  while (*policyInfos != NULL ) {\n+    policyInfo = *policyInfos++;\n+    switch (policyInfo->oid) {\n+    case SEC_OID_VERISIGN_USER_NOTICES:\n+      nssComponent->GetPIPNSSBundleString(\"CertDumpVerisignNotices\", local);\n+      text.Append(local);\n+      break;\n+    default:\n+      GetDefaultOIDFormat(&policyInfo->policyID, local, '.');\n+      text.Append(local);\n     }\n+    if (policyInfo->policyQualifiers) {\n+      /* Add all qualifiers on separate lines, indented */\n+      policyQualifiers = policyInfo->policyQualifiers;\n+      text.Append(NS_LITERAL_STRING(\":\"));\n+      text.Append(NS_LITERAL_STRING(SEPARATOR));\n+      while (*policyQualifiers != NULL) {\n+\ttext.Append(NS_LITERAL_STRING(\"  \"));\n+\tpolicyQualifier = *policyQualifiers++;\n+\tswitch(policyQualifier->oid) {\n+\tcase SEC_OID_PKIX_CPS_POINTER_QUALIFIER:\n+\t  nssComponent->GetPIPNSSBundleString(\"CertDumpCPSPointer\", local);\n+\t  text.Append(local);\n+\t  text.Append(NS_LITERAL_STRING(\":\"));\n+\t  text.Append(NS_LITERAL_STRING(SEPARATOR));\n+\t  text.Append(NS_LITERAL_STRING(\"    \"));\n+\t  /* The CPS pointer ought to be the cPSuri alternative\n+\t     of the Qualifier choice. */\n+\t  rv = ProcessIA5String(&policyQualifier->qualifierValue,\n+\t\t\t\ttext, nssComponent);\n+\t  if (NS_FAILED(rv))\n+\t    goto finish;\n+\t  break;\n+\tcase SEC_OID_PKIX_USER_NOTICE_QUALIFIER:\n+\t  nssComponent->GetPIPNSSBundleString(\"CertDumpUserNotice\", local);\n+\t  text.Append(local);\n+\t  text.Append(NS_LITERAL_STRING(\": \"));\n+\t  rv = ProcessUserNotice(&policyQualifier->qualifierValue,\n+\t\t\t\t text, nssComponent);\n+\t  break;\n+\tdefault:\n+\t  GetDefaultOIDFormat(&policyQualifier->qualifierID, local, '.');\n+\t  text.Append(local);\n+\t  text.Append(NS_LITERAL_STRING(\": \"));\n+\t  ProcessRawBytes(&policyQualifier->qualifierValue, text);\n+\t}\n+\ttext.Append(NS_LITERAL_STRING(SEPARATOR));\n+      } /* while policyQualifiers */\n+    } /* if policyQualifiers */\n+    text.Append(NS_LITERAL_STRING(SEPARATOR));\n   }\n-  *value = ToNewUnicode(finalString);    \n+\n+ finish:\n+  CERT_DestroyCertificatePoliciesExtension(policies);\n+  return rv;\n+}\n+\n+static nsresult\n+ProcessCrlDistPoints(SECItem  *extData, \n+\t\t     nsAString &text,\n+\t\t     nsINSSComponent *nssComponent)\n+{\n+  CERTCrlDistributionPoints *crldp;\n+  CRLDistributionPoint **points, *point;\n+  PRArenaPool *arena;\n+  nsresult rv = NS_OK;\n+  nsAutoString local;\n+  int reasons, comma;\n+\n+  arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);\n+  if (!arena)\n+    return NS_ERROR_FAILURE;\n+\n+  crldp = CERT_DecodeCRLDistributionPoints(arena, extData);\n+  if (!crldp || !crldp->distPoints) {\n+    rv = NS_ERROR_FAILURE;\n+    goto finish;\n+  }\n+\n+  for(points = crldp->distPoints; *points; points++) {\n+    point = *points;\n+    switch (point->distPointType) {\n+    case generalName:\n+      rv = ProcessGeneralName(arena, point->distPoint.fullName,\n+\t\t\t      text, nssComponent);\n+      if (NS_FAILED(rv))\n+\tgoto finish;\n+      break;\n+    case relativeDistinguishedName:\n+      rv = ProcessRDN(&point->distPoint.relativeName, \n+\t\t      text, nssComponent);\n+      if (NS_FAILED(rv))\n+\tgoto finish;\n+      break;\n+    }\n+    if (point->reasons.len) { \n+      reasons = point->reasons.data[0];\n+      text.Append(NS_LITERAL_STRING(\" \"));\n+      comma = 0;\n+      if (reasons & RF_UNUSED) {\n+\tnssComponent->GetPIPNSSBundleString(\"CertDumpUnused\", local);\n+\ttext.Append(local); comma = 1;\n+      }\n+      if (reasons & RF_KEY_COMPROMISE) {\n+\tif (comma) text.Append(NS_LITERAL_STRING(\", \"));\n+\tnssComponent->GetPIPNSSBundleString(\"CertDumpKeyCompromise\", local);\n+\ttext.Append(local); comma = 1;\n+      }\n+      if (reasons & RF_CA_COMPROMISE) {\n+\tif (comma) text.Append(NS_LITERAL_STRING(\", \"));\n+\tnssComponent->GetPIPNSSBundleString(\"CertDumpCACompromise\", local);\n+\ttext.Append(local); comma = 1;\n+      }\n+      if (reasons & RF_AFFILIATION_CHANGED) {\n+\tif (comma) text.Append(NS_LITERAL_STRING(\", \"));\n+\tnssComponent->GetPIPNSSBundleString(\"CertDumpAffiliationChanged\", local);\n+\ttext.Append(local); comma = 1;\n+      }\n+      if (reasons & RF_SUPERSEDED) {\n+\tif (comma) text.Append(NS_LITERAL_STRING(\", \"));\n+\tnssComponent->GetPIPNSSBundleString(\"CertDumpSuperseded\", local);\n+\ttext.Append(local); comma = 1;\n+      }\n+      if (reasons & RF_CESSATION_OF_OPERATION) {\n+\tif (comma) text.Append(NS_LITERAL_STRING(\", \"));\n+\tnssComponent->GetPIPNSSBundleString(\"CertDumpCessation\", local);\n+\ttext.Append(local); comma = 1;\n+      }\n+      if (reasons & RF_CERTIFICATE_HOLD) {\n+\tif (comma) text.Append(NS_LITERAL_STRING(\", \"));\n+\tnssComponent->GetPIPNSSBundleString(\"CertDumpHold\", local);\n+\ttext.Append(local); comma = 1;\n+      }\n+    }\n+    if (point->crlIssuer) {\n+      nssComponent->GetPIPNSSBundleString(\"CertDumpIssuer\", local);\n+      text.Append(local);\n+      text.Append(NS_LITERAL_STRING(\": \"));\n+      rv = ProcessGeneralNames(arena, point->crlIssuer,\n+\t\t\t       text, nssComponent);\n+      if (NS_FAILED(rv))\n+\tgoto finish;\n+    }\n+    text.Append(NS_LITERAL_STRING(SEPARATOR));\n+  }\n+  \n+ finish:\n+  PORT_FreeArena(arena, PR_FALSE);\n+  return NS_OK;\n+}\n+\n+static nsresult\n+ProcessAuthInfoAccess(SECItem  *extData, \n+\t\t      nsAString &text,\n+\t\t      nsINSSComponent *nssComponent)\n+{\n+  CERTAuthInfoAccess **aia, *desc;\n+  PRArenaPool *arena;\n+  nsresult rv = NS_OK;\n+  nsAutoString local;\n+\n+  arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);\n+  if (!arena)\n+    return NS_ERROR_FAILURE;\n+\n+  aia = CERT_DecodeAuthInfoAccessExtension(arena, extData);\n+  if (aia == NULL)\n+    goto finish;\n+\n+  while (*aia != NULL) {\n+    desc = *aia++;\n+    switch (SECOID_FindOIDTag(&desc->method)) {\n+    case SEC_OID_PKIX_CA_ISSUERS:\n+      nssComponent->GetPIPNSSBundleString(\"CertDumpCAIssuers\", text);\n+      break;\n+    default:\n+      rv = GetDefaultOIDFormat(&desc->method, text, '.');\n+      if (NS_FAILED(rv))\n+\tgoto finish;\n+    }\n+    text.Append(local);\n+    text.Append(NS_LITERAL_STRING(\": \"));\n+    rv = ProcessGeneralName(arena, desc->location, text, nssComponent);\n+    if (NS_FAILED(rv))\n+      goto finish;\n+    text.Append(NS_LITERAL_STRING(SEPARATOR));\n+  }\n+\n+ finish:\n+  PORT_FreeArena(arena, PR_FALSE);\n+  return rv;\n+}\n+\n+static nsresult\n+ProcessMSCAVersion(SECItem  *extData, \n+\t\t   nsAString &text,\n+\t\t   nsINSSComponent *nssComponent)\n+{\n+  unsigned long version;\n+  nsresult rv;\n+  char buf[50];\n+\n+  rv = GetIntValue(extData, &version);\n+  if (NS_FAILED(rv))\n+    return rv;\n+\n+  PR_snprintf(buf, sizeof(buf), \"0x%x\", version);\n+  text.AppendASCII(buf);\n   return NS_OK;\n }\n \n@@ -571,7 +1329,52 @@ ProcessExtensionData(SECOidTag oidTag, SECItem *extData,\n   case SEC_OID_X509_KEY_USAGE:\n     rv = ProcessKeyUsageExtension(extData, text, nssComponent);\n     break;\n+  case SEC_OID_X509_BASIC_CONSTRAINTS:\n+    rv = ProcessBasicConstraints(extData, text, nssComponent);\n+    break;\n+  case SEC_OID_X509_EXT_KEY_USAGE:\n+    rv = ProcessExtKeyUsage(extData, text, nssComponent);\n+    break;\n+  case SEC_OID_X509_ISSUER_ALT_NAME:\n+  case SEC_OID_X509_SUBJECT_ALT_NAME:\n+    rv = ProcessAltName(extData, text, nssComponent);\n+    break;\n+  case SEC_OID_X509_SUBJECT_KEY_ID:\n+    rv = ProcessSubjectKeyId(extData, text, nssComponent);\n+    break;\n+  case SEC_OID_X509_AUTH_KEY_ID:\n+    rv = ProcessAuthKeyId(extData, text, nssComponent);\n+    break;\n+  case SEC_OID_X509_CERTIFICATE_POLICIES:\n+    rv = ProcessCertificatePolicies(extData, text, nssComponent);\n+    break;\n+  case SEC_OID_X509_CRL_DIST_POINTS:\n+    rv = ProcessCrlDistPoints(extData, text, nssComponent);\n+    break;\n+  case SEC_OID_X509_AUTH_INFO_ACCESS:\n+    rv = ProcessAuthInfoAccess(extData, text, nssComponent);\n+    break;\n+  case SEC_OID_NS_CERT_EXT_BASE_URL:\n+  case SEC_OID_NS_CERT_EXT_REVOCATION_URL:\n+  case SEC_OID_NS_CERT_EXT_CA_REVOCATION_URL:\n+  case SEC_OID_NS_CERT_EXT_CA_CERT_URL:\n+  case SEC_OID_NS_CERT_EXT_CERT_RENEWAL_URL:\n+  case SEC_OID_NS_CERT_EXT_CA_POLICY_URL:\n+  case SEC_OID_NS_CERT_EXT_HOMEPAGE_URL:\n+  case SEC_OID_NS_CERT_EXT_COMMENT:\n+  case SEC_OID_NS_CERT_EXT_SSL_SERVER_NAME:\n+  case SEC_OID_NS_CERT_EXT_LOST_PASSWORD_URL:\n+    rv = ProcessIA5String(extData, text, nssComponent);\n+    break;\n   default:\n+    if (oidTag == SEC_OID(MS_CERT_EXT_CERTTYPE)) {\n+      rv = ProcessBMPString(extData, text, nssComponent);\n+      break;\n+    }\n+    if (oidTag == SEC_OID(MS_CERTSERV_CA_VERSION)) {\n+      rv = ProcessMSCAVersion(extData, text, nssComponent);\n+      break;\n+    }\n     rv = ProcessRawBytes(extData, text);\n     break; \n   }\n@@ -768,6 +1571,27 @@ ProcessExtensions(CERTCertExtension **extensions,\n   return NS_OK;\n }\n \n+static bool registered;\n+static SECStatus RegisterDynamicOids()\n+{\n+  unsigned int i;\n+  SECStatus rv = SECSuccess;\n+\n+  if (registered)\n+    return rv;\n+\n+  for (i = 0; i < numOids; i++) {\n+    SECOidTag tag = SECOID_AddEntry(&more_oids[i]);\n+    if (tag == SEC_OID_UNKNOWN) {\n+      rv = SECFailure;\n+      continue;\n+    }\n+    more_oids[i].offset = tag;\n+  }\n+  registered = true;\n+  return rv;\n+}\n+\n nsresult\n nsNSSCertificate::CreateTBSCertificateASN1Struct(nsIASN1Sequence **retSequence,\n                                                  nsINSSComponent *nssComponent)\n@@ -776,6 +1600,9 @@ nsNSSCertificate::CreateTBSCertificateASN1Struct(nsIASN1Sequence **retSequence,\n   if (isAlreadyShutDown())\n     return NS_ERROR_NOT_AVAILABLE;\n \n+  if (RegisterDynamicOids() != SECSuccess)\n+    return NS_ERROR_FAILURE;\n+\n   //\n   //   TBSCertificate  ::=  SEQUENCE  {\n   //        version         [0]  EXPLICIT Version DEFAULT v1,"}]},"blames":["d4192852","d03c5bdd","3634d4d9","b2f4a8b1","31db9b54","2c3a905f","ec415449","10b8ef3a","d03c5bdd"]}