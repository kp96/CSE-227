diff --git a/security/manager/ssl/src/nsCertOverrideService.cpp b/security/manager/ssl/src/nsCertOverrideService.cpp
--- a/security/manager/ssl/src/nsCertOverrideService.cpp
+++ b/security/manager/ssl/src/nsCertOverrideService.cpp
@@ -212,16 +212,38 @@ nsCertOverrideService::Observe(nsISuppor
 
 void
 nsCertOverrideService::RemoveAllFromMemory()
 {
   nsAutoMonitor lock(monitor);
   mSettingsTable.Clear();
 }
 
+PR_STATIC_CALLBACK(PLDHashOperator)
+RemoveTemporariesCallback(nsCertOverrideEntry *aEntry,
+                          void *aArg)
+{
+  if (aEntry && aEntry->mSettings.mIsTemporary) {
+    aEntry->mSettings.mCert = nsnull;
+    return PL_DHASH_REMOVE;
+  }
+
+  return PL_DHASH_NEXT;
+}
+
+void
+nsCertOverrideService::RemoveAllTemporaryOverrides()
+{
+  {
+    nsAutoMonitor lock(monitor);
+    mSettingsTable.EnumerateEntries(RemoveTemporariesCallback, nsnull);
+    // no need to write, as temporaries are never written to disk
+  }
+}
+
 nsresult
 nsCertOverrideService::Read()
 {
   nsAutoMonitor lock(monitor);
 
   nsresult rv;
   nsCOMPtr<nsIInputStream> fileInputStream;
   rv = NS_NewLocalFileInputStream(getter_AddRefs(fileInputStream), mSettingsFile);
@@ -285,16 +307,17 @@ nsCertOverrideService::Read()
     nsCAutoString portString(Substring(host, portIndex+1));
     port = portString.ToInteger(&portParseError);
     if (portParseError)
       continue; // Ignore broken entries
 
     host.Truncate(portIndex);
     
     AddEntryToList(host, port, 
+                   nsnull, // don't have the cert
                    PR_FALSE, // not temporary
                    algo_string, fingerprint, bits, db_key);
   }
 
   return NS_OK;
 }
 
 PR_STATIC_CALLBACK(PLDHashOperator)
@@ -484,17 +507,17 @@ nsCertOverrideService::RememberValidityO
   CERTCertificate* nsscert = cert2->GetCert();
   if (!nsscert)
     return NS_ERROR_FAILURE;
 
   CERTCertificateCleaner nsscertCleaner(nsscert);
 
   nsCAutoString nickname;
   nickname = nsNSSCertificate::defaultServerNickname(nsscert);
-  if (!nickname.IsEmpty())
+  if (!aTemporary && !nickname.IsEmpty())
   {
     PK11SlotInfo *slot = PK11_GetInternalKeySlot();
     if (!slot)
       return NS_ERROR_FAILURE;
   
     SECStatus srv = PK11_ImportCert(slot, nsscert, CK_INVALID_HANDLE, 
                                     const_cast<char*>(nickname.get()), PR_FALSE);
     PK11_FreeSlot(slot);
@@ -522,16 +545,18 @@ nsCertOverrideService::RememberValidityO
     if (c == '\r' || c == '\n') {
       *dbkey_walk = ' ';
     }
   }
 
   {
     nsAutoMonitor lock(monitor);
     AddEntryToList(aHostName, aPort,
+                   aTemporary ? aCert : nsnull,
+                     // keep a reference to the cert for temporary overrides
                    aTemporary, 
                    mDottedOidForStoringNewHashes, fpStr, 
                    (nsCertOverride::OverrideBits)aOverrideBits, 
                    nsDependentCString(dbkey));
     Write();
   }
 
   PR_Free(dbkey);
@@ -625,16 +650,17 @@ nsCertOverrideService::GetValidityOverri
     aHashAlg = settings.mFingerprintAlgOID;
   }
 
   return NS_OK;
 }
 
 nsresult
 nsCertOverrideService::AddEntryToList(const nsACString &aHostName, PRInt32 aPort,
+                                      nsIX509Cert *aCert,
                                       const PRBool aIsTemporary,
                                       const nsACString &fingerprintAlgOID, 
                                       const nsACString &fingerprint,
                                       nsCertOverride::OverrideBits ob,
                                       const nsACString &dbKey)
 {
   nsCAutoString hostPort;
   GetHostWithPort(aHostName, aPort, hostPort);
@@ -653,16 +679,17 @@ nsCertOverrideService::AddEntryToList(co
     nsCertOverride &settings = entry->mSettings;
     settings.mAsciiHost = aHostName;
     settings.mPort = aPort;
     settings.mIsTemporary = aIsTemporary;
     settings.mFingerprintAlgOID = fingerprintAlgOID;
     settings.mFingerprint = fingerprint;
     settings.mOverrideBits = ob;
     settings.mDBKey = dbKey;
+    settings.mCert = aCert;
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCertOverrideService::ClearValidityOverride(const nsACString & aHostName, PRInt32 aPort)
 {
diff --git a/security/manager/ssl/src/nsCertOverrideService.h b/security/manager/ssl/src/nsCertOverrideService.h
--- a/security/manager/ssl/src/nsCertOverrideService.h
+++ b/security/manager/ssl/src/nsCertOverrideService.h
@@ -72,26 +72,28 @@ public:
   {
     mAsciiHost = other.mAsciiHost;
     mPort = other.mPort;
     mIsTemporary = other.mIsTemporary;
     mFingerprintAlgOID = other.mFingerprintAlgOID;
     mFingerprint = other.mFingerprint;
     mOverrideBits = other.mOverrideBits;
     mDBKey = other.mDBKey;
+    mCert = other.mCert;
     return *this;
   }
 
   nsCString mAsciiHost;
   PRInt32 mPort;
   PRBool mIsTemporary; // true: session only, false: stored on disk
   nsCString mFingerprint;
   nsCString mFingerprintAlgOID;
   OverrideBits mOverrideBits;
   nsCString mDBKey;
+  nsCOMPtr <nsIX509Cert> mCert;
 
   static void convertBitsToString(OverrideBits ob, nsACString &str);
   static void convertStringToBits(const nsACString &str, OverrideBits &ob);
 };
 
 
 // hash entry class
 class nsCertOverrideEntry : public PLDHashEntryHdr
@@ -165,16 +167,17 @@ public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSICERTOVERRIDESERVICE
   NS_DECL_NSIOBSERVER
 
   nsCertOverrideService();
   ~nsCertOverrideService();
 
   nsresult Init();
+  void RemoveAllTemporaryOverrides();
 
   typedef void 
   (*PR_CALLBACK CertOverrideEnumerator)(const nsCertOverride &aSettings,
                                         void *aUserData);
 
   // aCert == null: return all overrides
   // aCert != null: return overrides that match the given cert
   nsresult EnumerateCertOverrides(nsIX509Cert *aCert,
@@ -193,16 +196,17 @@ protected:
 
     SECOidTag mOidTagForStoringNewHashes;
     nsCString mDottedOidForStoringNewHashes;
 
     void RemoveAllFromMemory();
     nsresult Read();
     nsresult Write();
     nsresult AddEntryToList(const nsACString &host, PRInt32 port,
+                            nsIX509Cert *aCert,
                             const PRBool aIsTemporary,
                             const nsACString &algo_oid, 
                             const nsACString &fingerprint,
                             nsCertOverride::OverrideBits ob,
                             const nsACString &dbKey);
 };
 
 #define NS_CERTOVERRIDE_CID { /* 67ba681d-5485-4fff-952c-2ee337ffdcd6 */ \
diff --git a/security/manager/ssl/src/nsCertTree.cpp b/security/manager/ssl/src/nsCertTree.cpp
--- a/security/manager/ssl/src/nsCertTree.cpp
+++ b/security/manager/ssl/src/nsCertTree.cpp
@@ -152,26 +152,33 @@ nsCertTreeDispInfo::nsCertTreeDispInfo(n
 nsCertTreeDispInfo::nsCertTreeDispInfo(nsCertTreeDispInfo &other)
 {
   mAddonInfo = other.mAddonInfo;
   mTypeOfEntry = other.mTypeOfEntry;
   mAsciiHost = other.mAsciiHost;
   mPort = other.mPort;
   mOverrideBits = other.mOverrideBits;
   mIsTemporary = other.mIsTemporary;
+  mCert = other.mCert;
 }
 
 nsCertTreeDispInfo::~nsCertTreeDispInfo()
 {
 }
 
 NS_IMETHODIMP
 nsCertTreeDispInfo::GetCert(nsIX509Cert **_cert)
 {
   NS_ENSURE_ARG(_cert);
+  if (mCert) {
+    // we may already have the cert for temporary overrides
+    *_cert = mCert;
+    NS_IF_ADDREF(*_cert);
+    return NS_OK;
+  }
   if (mAddonInfo) {
     *_cert = mAddonInfo->mCert.get();
     NS_IF_ADDREF(*_cert);
   }
   else {
     *_cert = nsnull;
   }
   return NS_OK;
@@ -301,20 +308,22 @@ nsCertTree::GetCertAtIndex(PRInt32 index
 nsCertTree::GetCertAtIndex(PRInt32 index, PRInt32 *outAbsoluteCertOffset)
 {
   nsRefPtr<nsCertTreeDispInfo> certdi =
     GetDispInfoAtIndex(index, outAbsoluteCertOffset);
   if (!certdi)
     return nsnull;
 
   nsIX509Cert *rawPtr = nsnull;
-  if (certdi->mAddonInfo) {
+  if (certdi->mCert) {
+    rawPtr = certdi->mCert;
+  } else if (certdi->mAddonInfo) {
     rawPtr = certdi->mAddonInfo->mCert;
-    NS_IF_ADDREF(rawPtr);
   }
+  NS_IF_ADDREF(rawPtr);
   return rawPtr;
 }
 
 //  If the row at index is a cert, return that cert.  Otherwise, return null.
 already_AddRefed<nsCertTreeDispInfo>
 nsCertTree::GetDispInfoAtIndex(PRInt32 index, 
                                PRInt32 *outAbsoluteCertOffset)
 {
@@ -392,16 +401,17 @@ MatchingCertOverridesCallback(const nsCe
     if (cap->certai)
       cap->certai->mUsageCount++;
     certdi->mAddonInfo = cap->certai;
     certdi->mTypeOfEntry = nsCertTreeDispInfo::host_port_override;
     certdi->mAsciiHost = aSettings.mAsciiHost;
     certdi->mPort = aSettings.mPort;
     certdi->mOverrideBits = aSettings.mOverrideBits;
     certdi->mIsTemporary = aSettings.mIsTemporary;
+    certdi->mCert = aSettings.mCert;
     cap->array->InsertElementAt(cap->position, certdi);
     cap->position++;
     cap->counter++;
   }
 
   // this entry is now associated to a displayed cert, remove
   // it from the list of remaining entries
   nsCAutoString hostPort;
@@ -455,16 +465,17 @@ AddRemaningHostPortOverridesCallback(con
   nsCertTreeDispInfo *certdi = new nsCertTreeDispInfo;
   if (certdi) {
     certdi->mAddonInfo = nsnull;
     certdi->mTypeOfEntry = nsCertTreeDispInfo::host_port_override;
     certdi->mAsciiHost = aSettings.mAsciiHost;
     certdi->mPort = aSettings.mPort;
     certdi->mOverrideBits = aSettings.mOverrideBits;
     certdi->mIsTemporary = aSettings.mIsTemporary;
+    certdi->mCert = aSettings.mCert;
     cap->array->InsertElementAt(cap->position, certdi);
     cap->position++;
     cap->counter++;
   }
 }
 
 nsresult
 nsCertTree::GetCertsByTypeFromCertList(CERTCertList *aCertList,
@@ -1127,18 +1138,18 @@ nsCertTree::GetCellText(PRInt32 row, nsI
   }
 
   PRInt32 absoluteCertOffset;
   nsRefPtr<nsCertTreeDispInfo> certdi = 
     GetDispInfoAtIndex(row, &absoluteCertOffset);
   if (!certdi)
     return NS_ERROR_FAILURE;
 
-  nsCOMPtr<nsIX509Cert> cert = nsnull;
-  if (certdi->mAddonInfo) {
+  nsCOMPtr<nsIX509Cert> cert = certdi->mCert;
+  if (!cert && certdi->mAddonInfo) {
     cert = certdi->mAddonInfo->mCert;
   }
 
   PRInt32 colIndex;
   col->GetIndex(&colIndex);
   PRUint32 arrayIndex=absoluteCertOffset+colIndex*(mNumRows-mNumOrgs);
   PRUint32 arrayLength=0;
   if (mCellText) {
diff --git a/security/manager/ssl/src/nsCertTree.h b/security/manager/ssl/src/nsCertTree.h
--- a/security/manager/ssl/src/nsCertTree.h
+++ b/security/manager/ssl/src/nsCertTree.h
@@ -97,16 +97,17 @@ public:
   nsRefPtr<nsCertAddonInfo> mAddonInfo;
   enum {
     direct_db, host_port_override
   } mTypeOfEntry;
   nsCString mAsciiHost;
   PRInt32 mPort;
   nsCertOverride::OverrideBits mOverrideBits;
   PRBool mIsTemporary;
+  nsCOMPtr<nsIX509Cert> mCert;
 };
 
 class nsCertTree : public nsICertTree
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSICERTTREE
   NS_DECL_NSITREEVIEW
diff --git a/security/manager/ssl/src/nsNSSComponent.cpp b/security/manager/ssl/src/nsNSSComponent.cpp
--- a/security/manager/ssl/src/nsNSSComponent.cpp
+++ b/security/manager/ssl/src/nsNSSComponent.cpp
@@ -80,16 +80,17 @@
 #include "nsIDOMWindowCollection.h"
 #include "nsIDOMWindowInternal.h"
 #include "nsIDOMSmartCardEvent.h"
 #include "nsIDOMCrypto.h"
 #include "nsThreadUtils.h"
 #include "nsAutoPtr.h"
 #include "nsCRT.h"
 #include "nsCRLInfo.h"
+#include "nsCertOverrideService.h"
 
 #include "nsIWindowWatcher.h"
 #include "nsIPrompt.h"
 #include "nsProxiedService.h"
 #include "nsIPrincipal.h"
 #include "nsReadableUtils.h"
 #include "nsIDateTimeFormat.h"
 #include "prtypes.h"
@@ -2136,16 +2137,26 @@ void nsNSSComponent::ShowAlert(AlertIden
         proxyPrompt->Alert(nsnull, message.get());
       }
     }
   }
 }
 
 nsresult nsNSSComponent::LogoutAuthenticatedPK11()
 {
+  nsCOMPtr<nsICertOverrideService> icos = 
+    do_GetService("@mozilla.org/security/certoverride;1");
+    
+  nsCertOverrideService *cos = 
+    reinterpret_cast<nsCertOverrideService*>(icos.get());
+
+  if (cos) {
+    cos->RemoveAllTemporaryOverrides();
+  }
+
   return mShutdownObjectList->doPK11Logout();
 }
 
 nsresult
 nsNSSComponent::RegisterObservers()
 {
   // Happens once during init only, no mutex protection.
 
