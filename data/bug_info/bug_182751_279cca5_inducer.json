{"bug_id":182751,"commitHash":"279cca5","commit_info":{"sha":"279cca576cc5ca71163ed6917f250e0df7986135","commit":{"author":{"name":"smontagu%netscape.com","email":"smontagu%netscape.com","date":"2003-03-08T00:25:54Z"},"committer":{"name":"smontagu%netscape.com","email":"smontagu%netscape.com","date":"2003-03-08T00:25:54Z"},"message":"Make the UTF-8 decoder reject all non-shortest forms and surrogate characters, plus general code cleanup. Bug 182751, r=ftang, sr=heikki.","tree":{"sha":"353ef3d6d5acab9fa8ad934e70a6c96b11dc9ae3","url":"https://api.github.com/repos/mozilla/gecko-dev/git/trees/353ef3d6d5acab9fa8ad934e70a6c96b11dc9ae3"},"url":"https://api.github.com/repos/mozilla/gecko-dev/git/commits/279cca576cc5ca71163ed6917f250e0df7986135","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/mozilla/gecko-dev/commits/279cca576cc5ca71163ed6917f250e0df7986135","html_url":"https://github.com/mozilla/gecko-dev/commit/279cca576cc5ca71163ed6917f250e0df7986135","comments_url":"https://api.github.com/repos/mozilla/gecko-dev/commits/279cca576cc5ca71163ed6917f250e0df7986135/comments","author":null,"committer":null,"parents":[{"sha":"dadc4b116065bfa1d0a40a445ec2502a2af1885e","url":"https://api.github.com/repos/mozilla/gecko-dev/commits/dadc4b116065bfa1d0a40a445ec2502a2af1885e","html_url":"https://github.com/mozilla/gecko-dev/commit/dadc4b116065bfa1d0a40a445ec2502a2af1885e"}],"stats":{"total":292,"additions":156,"deletions":136},"files":[{"sha":"5f4536b029802285dd803839d70795d94edd6b40","filename":"intl/uconv/src/nsUTF8ToUnicode.cpp","status":"modified","additions":156,"deletions":136,"changes":292,"blob_url":"https://github.com/mozilla/gecko-dev/blob/279cca576cc5ca71163ed6917f250e0df7986135/intl/uconv/src/nsUTF8ToUnicode.cpp","raw_url":"https://github.com/mozilla/gecko-dev/raw/279cca576cc5ca71163ed6917f250e0df7986135/intl/uconv/src/nsUTF8ToUnicode.cpp","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/intl/uconv/src/nsUTF8ToUnicode.cpp?ref=279cca576cc5ca71163ed6917f250e0df7986135","patch":"@@ -14,7 +14,7 @@\n  *\n  * The Original Code is Mozilla Communicator client code.\n  *\n- * The Initial Developer of the Original Code is \n+ * The Initial Developer of the Original Code is\n  * Netscape Communications Corporation.\n  * Portions created by the Initial Developer are Copyright (C) 1998\n  * the Initial Developer. All Rights Reserved.\n@@ -39,9 +39,11 @@\n #include \"nsUCSupport.h\"\n #include \"nsUTF8ToUnicode.h\"\n \n-NS_IMETHODIMP NS_NewUTF8ToUnicode(nsISupports* aOuter, \n-                                            const nsIID& aIID,\n-                                            void** aResult)\n+#define UNICODE_BYTE_ORDER_MARK    0xFEFF\n+\n+NS_IMETHODIMP NS_NewUTF8ToUnicode(nsISupports* aOuter,\n+                                  const nsIID& aIID,\n+                                  void** aResult)\n {\n   if (!aResult) {\n     return NS_ERROR_NULL_POINTER;\n@@ -66,18 +68,17 @@ NS_IMETHODIMP NS_NewUTF8ToUnicode(nsISupports* aOuter,\n //----------------------------------------------------------------------\n // Class nsUTF8ToUnicode [implementation]\n \n-nsUTF8ToUnicode::nsUTF8ToUnicode() \n+nsUTF8ToUnicode::nsUTF8ToUnicode()\n : nsBasicDecoderSupport()\n-\n {\n-\tReset();\n+  Reset();\n }\n \n //----------------------------------------------------------------------\n // Subclassing of nsTableDecoderSupport class [implementation]\n \n-NS_IMETHODIMP nsUTF8ToUnicode::GetMaxLength(const char * aSrc, \n-                                            PRInt32 aSrcLength, \n+NS_IMETHODIMP nsUTF8ToUnicode::GetMaxLength(const char * aSrc,\n+                                            PRInt32 aSrcLength,\n                                             PRInt32 * aDestLength)\n {\n   *aDestLength = aSrcLength;\n@@ -88,139 +89,158 @@ NS_IMETHODIMP nsUTF8ToUnicode::GetMaxLength(const char * aSrc,\n //----------------------------------------------------------------------\n // Subclassing of nsBasicDecoderSupport class [implementation]\n \n- NS_IMETHODIMP nsUTF8ToUnicode::Reset()\n+NS_IMETHODIMP nsUTF8ToUnicode::Reset()\n {\n \n-\tmState = 0;\t\t\t// cached expected number of bytes per UTF8 character sequence\n-\tmUcs4  = 0;\t\t\t// cached Unicode character\n-  mBytes = 1;\n-\treturn NS_OK;\n+  mState = 0;     // cached expected number of octets after the current octet\n+                  // until the beginning of the next UTF8 character sequence\n+  mUcs4  = 0;     // cached Unicode character\n+  mBytes = 1;     // cached expected number of octets in the current sequence\n+  return NS_OK;\n \n }\n \n //----------------------------------------------------------------------\n // Subclassing of nsBasicDecoderSupport class [implementation]\n \n- \n- NS_IMETHODIMP nsUTF8ToUnicode::Convert(const char * aSrc, \n-                                                    PRInt32 * aSrcLength, \n-                                                    PRUnichar * aDest, \n-                                                    PRInt32 * aDestLength)\n- {\n-   \n-   PRUint32 aSrcLen   = (PRUint32) (*aSrcLength);\n-   PRUint32 aDestLen = (PRUint32) (*aDestLength);\n-   \n-   const char *in, *inend;\n-   inend = aSrc + aSrcLen;\n-   \n-   PRUnichar *out, *outend;\n-   outend = aDest + aDestLen;\n-\n-   nsresult res;\t// conversion result\n-\n-   for(in=aSrc,out=aDest,res=NS_OK;((in < inend) && (out < outend)); in++)\n-   {\n-      if(0 == mState) {\n-         if( 0 == (0x80 & (*in))) {\n-             // ASCII\n-             *out++ = (PRUnichar)*in;\n-        mBytes =1;\n-         } else if( 0xC0 == (0xE0 & (*in))) {\n-             // 2 bytes UTF8\n-             mUcs4 = (PRUint32)(*in);\n-             mUcs4 = (mUcs4 << 6) & 0x000007C0L;\n-             mState=1;\n-        mBytes =2;\n-         } else if( 0xE0 == (0xF0 & (*in))) {\n-\t\t\t // 3 bytes UTF8\n-             mUcs4 = (PRUint32)(*in);\n-             mUcs4 = (mUcs4 << 12) & 0x0000F000L;\n-             mState=2;\n-        mBytes =3;\n-         } else if( 0xF0 == (0xF8 & (*in))) {\n-\t\t\t // 4 bytes UTF8\n-             mUcs4 = (PRUint32)(*in);\n-             mUcs4 = (mUcs4 << 18) & 0x001F0000L;\n-             mState=3;\n-        mBytes =4;\n-         } else if( 0xF8 == (0xFC & (*in))) {\n-\t\t\t // 5 bytes UTF8\n-             mUcs4 = (PRUint32)(*in);\n-             mUcs4 = (mUcs4 << 24) & 0x03000000L;\n-             mState=4;\n-        mBytes =5;\n-         } else if( 0xFC == (0xFE & (*in))) {\n-\t\t\t // 6 bytes UTF8\n-             mUcs4 = (PRUint32)(*in);\n-             mUcs4 = (mUcs4 << 30) & 0x40000000L;\n-             mState=5;\n-        mBytes =6;\n-         } else {\n-\t\t\t //NS_ASSERTION(0, \"The input string is not in utf8\");\n-\t  \t\t //unexpected octet, put in a replacement char, \n-\t\t\t //flush and refill the buffer, reset state\n-\t\t\t res = NS_ERROR_UNEXPECTED;\n-\t\t\t break;\n-         }\n-\t } else {\n-      if(0x80 == (0xC0 & (*in))) {\n-             PRUint32 tmp = (*in);\n-        PRUint32 shift = (mState-1) * 6;\n-             tmp = (tmp << shift ) & ( 0x0000003FL << shift);\n-             mUcs4 |= tmp;\n-        if(0 == --mState) {\n-                 if(mUcs4 >= 0x00010000) {\n-                    if(mUcs4 >= 0x00110000) {\n-                      *out++ = 0xFFFD;\n-                    } else {\n-                      mUcs4 -= 0x00010000;\n-                      *out++ = 0xD800 | (0x000003FF & (mUcs4 >> 10));\n-                      *out++ = 0xDC00 | (0x000003FF & mUcs4);\n-                    }\n-                 } else {\n-            // from Unicode 3.1, non-shortest form is illegal \n-            if(((2==mBytes) && (mUcs4 < 0x0080)) ||\n-               ((3==mBytes) && (mUcs4 < 0x0800)) ||\n-               ((4==mBytes) && (mUcs4 < 0x1000)) ||\n-                (5==mBytes) ||\n-                (6==mBytes)) \n-            {\n-              res = NS_ERROR_UNEXPECTED;\n-              break;\n-            } \n-\n-                    if( 0xfeff != mUcs4 ) // ignore BOM\n-            {  \n-                      *out++ = mUcs4;\n-                 }\n+\n+NS_IMETHODIMP nsUTF8ToUnicode::Convert(const char * aSrc,\n+                                       PRInt32 * aSrcLength,\n+                                       PRUnichar * aDest,\n+                                       PRInt32 * aDestLength)\n+{\n+  PRUint32 aSrcLen   = (PRUint32) (*aSrcLength);\n+  PRUint32 aDestLen = (PRUint32) (*aDestLength);\n+\n+  const char *in, *inend;\n+  inend = aSrc + aSrcLen;\n+\n+  PRUnichar *out, *outend;\n+  outend = aDest + aDestLen;\n+\n+  nsresult res = NS_OK; // conversion result\n+\n+  for (in = aSrc, out = aDest; ((in < inend) && (out < outend)); ++in) {\n+    if (0 == mState) {\n+      // When mState is zero we expect either a US-ASCII character or a\n+      // multi-octet sequence.\n+      if (0 == (0x80 & (*in))) {\n+        // US-ASCII, pass straight through.\n+        *out++ = (PRUnichar)*in;\n+        mBytes = 1;\n+      } else if (0xC0 == (0xE0 & (*in))) {\n+        // First octet of 2 octet sequence\n+        mUcs4 = (PRUint32)(*in);\n+        mUcs4 = (mUcs4 & 0x1F) << 6;\n+        mState = 1;\n+        mBytes = 2;\n+      } else if (0xE0 == (0xF0 & (*in))) {\n+        // First octet of 3 octet sequence\n+        mUcs4 = (PRUint32)(*in);\n+        mUcs4 = (mUcs4 & 0x0F) << 12;\n+        mState = 2;\n+        mBytes = 3;\n+      } else if (0xF0 == (0xF8 & (*in))) {\n+        // First octet of 4 octet sequence\n+        mUcs4 = (PRUint32)(*in);\n+        mUcs4 = (mUcs4 & 0x07) << 18;\n+        mState = 3;\n+        mBytes = 4;\n+      } else if (0xF8 == (0xFC & (*in))) {\n+        /* First octet of 5 octet sequence.\n+         *\n+         * This is illegal because the encoded codepoint must be either\n+         * (a) not the shortest form or\n+         * (b) outside the Unicode range of 0-0x10FFFF.\n+         * Rather than trying to resynchronize, we will carry on until the end\n+         * of the sequence and let the later error handling code catch it.\n+         */\n+        mUcs4 = (PRUint32)(*in);\n+        mUcs4 = (mUcs4 & 0x03) << 24;\n+        mState = 4;\n+        mBytes = 5;\n+      } else if (0xFC == (0xFE & (*in))) {\n+        // First octet of 6 octet sequence, see comments for 5 octet sequence.\n+        mUcs4 = (PRUint32)(*in);\n+        mUcs4 = (mUcs4 & 1) << 30;\n+        mState = 5;\n+        mBytes = 6;\n+      } else {\n+        /* Current octet is neither in the US-ASCII range nor a legal first\n+         * octet of a multi-octet sequence.\n+         *\n+         * Return an error condition. Caller is responsible for flushing and\n+         * refilling the buffer and resetting state.\n+         */\n+        res = NS_ERROR_UNEXPECTED;\n+        break;\n+      }\n+    } else {\n+      // When mState is non-zero, we expect a continuation of the multi-octet\n+      // sequence\n+      if (0x80 == (0xC0 & (*in))) {\n+        // Legal continuation.\n+        PRUint32 shift = (mState - 1) * 6;\n+        PRUint32 tmp = *in;\n+        tmp = (tmp & 0x0000003FL) << shift;\n+        mUcs4 |= tmp;\n+\n+        if (0 == --mState) {\n+          /* End of the multi-octet sequence. mUcs4 now contains the final\n+           * Unicode codepoint to be output\n+           *\n+           * Check for illegal sequences and codepoints.\n+           */\n+\n+          // From Unicode 3.1, non-shortest form is illegal\n+          if (((2 == mBytes) && (mUcs4 < 0x0080)) ||\n+              ((3 == mBytes) && (mUcs4 < 0x0800)) ||\n+              ((4 == mBytes) && (mUcs4 < 0x10000)) ||\n+              (4 < mBytes) ||\n+              // From Unicode 3.2, surrogate characters are illegal\n+              ((mUcs4 & 0xFFFFF800) == 0xD800) ||\n+              // Codepoints outside the Unicode range are illegal\n+              (mUcs4 > 0x10FFFF)) {\n+            res = NS_ERROR_UNEXPECTED;\n+            break;\n+          }\n+          if (mUcs4 > 0xFFFF) {\n+            // mUcs4 is in the range 0x10000 - 0x10FFFF. Output a UTF-16 pair\n+            mUcs4 -= 0x00010000;\n+            *out++ = 0xD800 | (0x000003FF & (mUcs4 >> 10));\n+            *out++ = 0xDC00 | (0x000003FF & mUcs4);\n+          } else if (UNICODE_BYTE_ORDER_MARK != mUcs4) {\n+            // BOM is legal but we don't want to output it\n+            *out++ = mUcs4;\n           }\n-\t\t\t\t //initialize UTF8 cache\n-\t\t\t\t Reset();\n-             }\n-         } else {\n-\t\t\t //NS_ASSERTION(0, \"The input string is not in utf8\");\n-\t  \t\t //unexpected octet, put in a replacement char, \n-\t\t\t //flush and refill the buffer, reset state\n-                         in--;\n-\t\t\t res = NS_ERROR_UNEXPECTED;\n-\t\t\t break;\n-         }\n-     }\n-   }\n-\n-   //output not finished, output buffer too short\n-   if((NS_OK == res) && (in < inend) && (out >= outend)) \n-       res = NS_OK_UDEC_MOREOUTPUT;\n-\n-   //last USC4 is incomplete, make sure the caller \n-   //returns with properly aligned continuation of the buffer\n-   if ((NS_OK == res) && (mState != 0))\n-       res = NS_OK_UDEC_MOREINPUT;\n-\n-   *aSrcLength = in - aSrc;\n-   *aDestLength  = out - aDest;\n-   \n-   return(res);\n-\n- }\n+          //initialize UTF8 cache\n+          Reset();\n+        }\n+      } else {\n+        /* ((0xC0 & (*in) != 0x80) && (mState != 0))\n+         * \n+         * Incomplete multi-octet sequence. Unconsume this\n+         * octet and return an error condition. Caller is responsible\n+         * for flushing and refilling the buffer and resetting state.\n+         */\n+        in--;\n+        res = NS_ERROR_UNEXPECTED;\n+        break;\n+      }\n+    }\n+  }\n+\n+  // output not finished, output buffer too short\n+  if ((NS_OK == res) && (in < inend) && (out >= outend))\n+    res = NS_OK_UDEC_MOREOUTPUT;\n+\n+  // last UCS4 is incomplete, make sure the caller\n+  // returns with properly aligned continuation of the buffer\n+  if ((NS_OK == res) && (mState != 0))\n+    res = NS_OK_UDEC_MOREINPUT;\n+\n+  *aSrcLength = in - aSrc;\n+  *aDestLength = out - aDest;\n+\n+  return(res);\n+}"}]},"blames":["f6972dcc","1c6c9ed7","398c1288","9939444f"]}