diff --git a/security/manager/ssl/src/nsCrypto.cpp b/security/manager/ssl/src/nsCrypto.cpp
--- a/security/manager/ssl/src/nsCrypto.cpp
+++ b/security/manager/ssl/src/nsCrypto.cpp
@@ -639,207 +639,280 @@ nsConvertToActualKeyGenParams(PRUint32 k
 }
 
 //We need to choose which PKCS11 slot we're going to generate
 //the key on.  Calls the default implementation provided by
 //nsKeygenHandler.cpp
 static PK11SlotInfo*
 nsGetSlotForKeyGen(nsKeyGenType keyGenType, nsIInterfaceRequestor *ctx)
 {
   nsNSSShutDownPreventionLock locker;
   PRUint32 mechanism = cryptojs_convert_to_mechanism(keyGenType);
   PK11SlotInfo *slot = nsnull;
   nsresult rv = GetSlotWithMechanism(mechanism,ctx, &slot);
   if (NS_FAILED(rv)) {
     if (slot)
       PK11_FreeSlot(slot);
     slot = nsnull;
   }
   return slot;
 }
 
 //Free the parameters that were passed into PK11_GenerateKeyPair
 //depending on the mechanism type used.
 static void
 nsFreeKeyGenParams(CK_MECHANISM_TYPE keyGenMechanism, void *params)
 {
   switch (keyGenMechanism) {
   case CKM_RSA_PKCS_KEY_PAIR_GEN:
     nsMemory::Free(params);
     break;
   case CKM_EC_KEY_PAIR_GEN:
     SECITEM_FreeItem(reinterpret_cast<SECItem*>(params), true);
     break;
   case CKM_DSA_KEY_PAIR_GEN:
     PK11_PQG_DestroyParams(static_cast<PQGParams*>(params));
     break;
   }
 }
 
 //Function that is used to generate a single key pair.
 //Once all the arguments have been parsed and processed, this
 //function gets called and takes care of actually generating
 //the key pair passing the appopriate parameters to the NSS
 //functions.
 static nsresult
 cryptojs_generateOneKeyPair(JSContext *cx, nsKeyPairInfo *keyPairInfo, 
                             PRInt32 keySize, char *params, 
                             nsIInterfaceRequestor *uiCxt,
                             PK11SlotInfo *slot, bool willEscrow)
                             
 {
+  const PK11AttrFlags sensitiveFlags = (PK11_ATTR_SENSITIVE | PK11_ATTR_PRIVATE);
+  const PK11AttrFlags temporarySessionFlags = PK11_ATTR_SESSION;
+  const PK11AttrFlags permanentTokenFlags = PK11_ATTR_TOKEN;
+  const PK11AttrFlags extractableFlags = PK11_ATTR_EXTRACTABLE;
+  
   nsIGeneratingKeypairInfoDialogs * dialogs;
   nsKeygenThread *KeygenRunnable = 0;
   nsCOMPtr<nsIKeygenThread> runnable;
 
   PRUint32 mechanism = cryptojs_convert_to_mechanism(keyPairInfo->keyGenType);
   void *keyGenParams = nsConvertToActualKeyGenParams(mechanism, params, 
                                                      (params) ? strlen(params):0, 
                                                      keySize, keyPairInfo);
 
-  if (!keyGenParams) {
+  if (!keyGenParams || !slot) {
     return NS_ERROR_INVALID_ARG;
   }
 
   // Make sure the token has password already set on it before trying
   // to generate the key.
 
   nsresult rv = setPassword(slot, uiCxt);
   if (NS_FAILED(rv))
     return rv;
 
   if (PK11_Authenticate(slot, true, uiCxt) != SECSuccess)
     return NS_ERROR_FAILURE;
  
-
   // Smart cards will not let you extract a private key once 
   // it is on the smart card.  If we've been told to escrow
-  // a private key that will ultimately wind up on a smart card,
-  // then we'll generate the private key on the internal slot
-  // as a temporary key, then move it to the destination slot. 
+  // a private key that will be stored on a smart card,
+  // then we'll use the following strategy to ensure we can escrow it.
+  // We'll attempt to generate the key on our internal token,
+  // because this is expected to avoid some problems.
+  // If it works, we'll escrow, move the key to the smartcard, done.
+  // If it didn't work (or the internal key doesn't support the desired
+  // mechanism), then we'll attempt to generate the key on
+  // the destination token, with the EXTRACTABLE flag set.
+  // If it works, we'll extract, escrow, done.
+  // If it failed, then we're unable to escrow and return failure.
   // NOTE: We call PK11_GetInternalSlot instead of PK11_GetInternalKeySlot
   //       so that the key has zero chance of being store in the
   //       user's key3.db file.  Which the slot returned by
   //       PK11_GetInternalKeySlot has access to and PK11_GetInternalSlot
   //       does not.
   PK11SlotInfo *intSlot = nsnull;
   PK11SlotInfoCleaner siCleaner(intSlot);
   
-  PK11SlotInfo *origSlot = nsnull;
-  bool isPerm;
-
   if (willEscrow && !PK11_IsInternal(slot)) {
     intSlot = PK11_GetInternalSlot();
     NS_ASSERTION(intSlot,"Couldn't get the internal slot");
-    isPerm = false;
-    origSlot = slot;
-    slot = intSlot;
-  } else {
-    isPerm = true;
+    
+    if (!PK11_DoesMechanism(intSlot, mechanism)) {
+      // Set to null, and the subsequent code will not attempt to use it.
+      PK11_FreeSlot(intSlot);
+      intSlot = nsnull;
+    }
   }
 
   rv = getNSSDialogs((void**)&dialogs,
                      NS_GET_IID(nsIGeneratingKeypairInfoDialogs),
                      NS_GENERATINGKEYPAIRINFODIALOGS_CONTRACTID);
 
   if (NS_SUCCEEDED(rv)) {
     KeygenRunnable = new nsKeygenThread();
     if (KeygenRunnable) {
       NS_ADDREF(KeygenRunnable);
     }
   }
-
+  
+  // "firstAttemptSlot" and "secondAttemptSlot" are alternative names
+  // for better code readability, we don't increase the reference counts.
+  
+  PK11SlotInfo *firstAttemptSlot = NULL;
+  PK11AttrFlags firstAttemptFlags = 0;
+
+  PK11SlotInfo *secondAttemptSlot = slot;
+  PK11AttrFlags secondAttemptFlags = sensitiveFlags | permanentTokenFlags;
+  
+  if (willEscrow) {
+    secondAttemptFlags |= extractableFlags;
+  }
+  
+  if (!intSlot || PK11_IsInternal(slot)) {
+    // if we cannot use the internal slot, then there is only one attempt
+    // if the destination slot is the internal slot, then there is only one attempt
+    firstAttemptSlot = secondAttemptSlot;
+    firstAttemptFlags = secondAttemptFlags;
+    secondAttemptSlot = NULL;
+    secondAttemptFlags = 0;
+  }
+  else {
+    firstAttemptSlot = intSlot;
+    firstAttemptFlags = sensitiveFlags | temporarySessionFlags;
+    
+    // We always need the extractable flag on the first attempt,
+    // because we want to move the key to another slot - ### is this correct?
+    firstAttemptFlags |= extractableFlags;
+  }
+
+  bool mustMoveKey = false;
+  
   if (NS_FAILED(rv) || !KeygenRunnable) {
+    /* execute key generation on this thread */
     rv = NS_OK;
-    keyPairInfo->privKey = PK11_GenerateKeyPair(slot, mechanism, keyGenParams,
-                                                &keyPairInfo->pubKey, isPerm, 
-                                                isPerm, uiCxt);
+    
+    keyPairInfo->privKey = 
+      PK11_GenerateKeyPairWithFlags(firstAttemptSlot, mechanism,
+                                    keyGenParams, &keyPairInfo->pubKey,
+                                    firstAttemptFlags, uiCxt);
+    
+    if (keyPairInfo->privKey) {
+      // success on first attempt
+      if (secondAttemptSlot) {
+        mustMoveKey = true;
+      }
+    }
+    else {
+      keyPairInfo->privKey = 
+        PK11_GenerateKeyPairWithFlags(secondAttemptSlot, mechanism,
+                                      keyGenParams, &keyPairInfo->pubKey,
+                                      secondAttemptFlags, uiCxt);
+    }
+    
   } else {
-    KeygenRunnable->SetParams( slot, mechanism, keyGenParams, isPerm, isPerm, uiCxt );
+    /* execute key generation on separate thread */
+    KeygenRunnable->SetParams( firstAttemptSlot, firstAttemptFlags,
+                               secondAttemptSlot, secondAttemptFlags,
+                               mechanism, keyGenParams, uiCxt );
 
     runnable = do_QueryInterface(KeygenRunnable);
 
     if (runnable) {
       {
         nsPSMUITracker tracker;
         if (tracker.isUIForbidden()) {
           rv = NS_ERROR_NOT_AVAILABLE;
         }
         else {
           rv = dialogs->DisplayGeneratingKeypairInfo(uiCxt, runnable);
           // We call join on the thread, 
           // so we can be sure that no simultaneous access to the passed parameters will happen.
           KeygenRunnable->Join();
         }
       }
 
       NS_RELEASE(dialogs);
       if (NS_SUCCEEDED(rv)) {
-        rv = KeygenRunnable->GetParams(&keyPairInfo->privKey, &keyPairInfo->pubKey);
+        PK11SlotInfo *used_slot = NULL;
+        rv = KeygenRunnable->ConsumeResult(&used_slot, 
+                                           &keyPairInfo->privKey, &keyPairInfo->pubKey);
+
+        if (NS_SUCCEEDED(rv)) {
+          if ((used_slot == firstAttemptSlot) && (secondAttemptSlot != NULL)) {
+            mustMoveKey = true;
+          }
+        
+          PK11_FreeSlot(used_slot);
+        }
       }
     }
   }
 
+  firstAttemptSlot = NULL;
+  secondAttemptSlot = NULL;
+  
   nsFreeKeyGenParams(mechanism, keyGenParams);
 
   if (KeygenRunnable) {
     NS_RELEASE(KeygenRunnable);
   }
 
   if (!keyPairInfo->privKey || !keyPairInfo->pubKey) {
     return NS_ERROR_FAILURE;
   }
  
-
   //If we generated the key pair on the internal slot because the
   // keys were going to be escrowed, move the keys over right now.
-  if (willEscrow && intSlot) {
-    SECKEYPrivateKey *newPrivKey = PK11_LoadPrivKey(origSlot, 
+  if (mustMoveKey) {
+    SECKEYPrivateKey *newPrivKey = PK11_LoadPrivKey(slot, 
                                                     keyPairInfo->privKey,
                                                     keyPairInfo->pubKey,
                                                     true, true);
     SECKEYPrivateKeyCleaner pkCleaner(newPrivKey);
 
     if (!newPrivKey)
       return NS_ERROR_FAILURE;
 
     // The private key is stored on the selected slot now, and the copy we
     // ultimately use for escrowing when the time comes lives 
     // in the internal slot.  We will delete it from that slot
     // after the requests are made.  This call only gives up
     // our reference to the key object and does not actually 
     // physically remove it from the card itself.
     // The actual delete calls are being made in the destructors
     // of the cleaner helper instances.
   }  
 
   return NS_OK;
 }
 
 /*
  * FUNCTION: cryptojs_ReadArgsAndGenerateKey
  * -------------------------------------
  * INPUTS:
  *  cx
  *    The JSContext associated with the execution of the corresponging
  *    crypto.generateCRMFRequest call
  *  argv
  *    A pointer to an array of JavaScript parameters passed to the
  *    method crypto.generateCRMFRequest.  The array should have the
  *    3 arguments keySize, "keyParams", and "keyGenAlg" mentioned in
  *    the definition of crypto.generateCRMFRequest at the following
  *    document http://docs.iplanet.com/docs/manuals/psm/11/cmcjavascriptapi.html 
  *  keyGenType
  *    A structure used to store the information about the newly created
  *    key pair.
  *  uiCxt
  *    An interface requestor that would be used to get an nsIPrompt
  *    if we need to ask the user for a password.
  *  slotToUse
  *    The PKCS11 slot to use for generating the key pair. If nsnull, then
  *    this function should select a slot that can do the key generation 
  *    from the keytype associted with the keyPairInfo, and pass it back to
  *    the caller so that subsequence key generations can use the same slot. 
  *  willEscrow
  *    If true, then that means we will try to escrow the generated
  *    private key when building the CRMF request.  If false, then
  *    we will not try to escrow the private key.
  *
diff --git a/security/manager/ssl/src/nsKeygenHandler.cpp b/security/manager/ssl/src/nsKeygenHandler.cpp
--- a/security/manager/ssl/src/nsKeygenHandler.cpp
+++ b/security/manager/ssl/src/nsKeygenHandler.cpp
@@ -483,100 +483,103 @@ GetSlotWithMechanism(PRUint32 aMechanism
             slotElement = PK11_GetNextSafe(slotList, slotElement, false);
         }
         if(!(*aSlot)) {
             rv = NS_ERROR_FAILURE;
             goto loser;
         }
       }
 
       // Get a reference to the slot //
       PK11_ReferenceSlot(*aSlot);
 loser:
       if (slotList) {
           PK11_FreeSlotList(slotList);
       }
       if (tokenNameList) {
           NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(numSlots, tokenNameList);
       }
       return rv;
 }
 
 nsresult
 nsKeygenFormProcessor::GetPublicKey(nsAString& aValue, nsAString& aChallenge, 
 				    nsAFlatString& aKeyType,
 				    nsAString& aOutPublicKey, nsAString& aKeyParams)
 {
     nsNSSShutDownPreventionLock locker;
     nsresult rv = NS_ERROR_FAILURE;
     char *keystring = nsnull;
     char *keyparamsString = nsnull, *str = nsnull;
     KeyType type;
     PRUint32 keyGenMechanism;
     PRInt32 primeBits;
     PK11SlotInfo *slot = nsnull;
     PK11RSAGenParams rsaParams;
     SECOidTag algTag;
     int keysize = 0;
     void *params;
     SECKEYPrivateKey *privateKey = nsnull;
     SECKEYPublicKey *publicKey = nsnull;
     CERTSubjectPublicKeyInfo *spkInfo = nsnull;
     PRArenaPool *arena = nsnull;
     SECStatus sec_rv = SECFailure;
     SECItem spkiItem;
     SECItem pkacItem;
     SECItem signedItem;
     CERTPublicKeyAndChallenge pkac;
     pkac.challenge.data = nsnull;
     nsIGeneratingKeypairInfoDialogs * dialogs;
     nsKeygenThread *KeygenRunnable = 0;
     nsCOMPtr<nsIKeygenThread> runnable;
+    
+    // permanent and sensitive flags for keygen
+    PK11AttrFlags attrFlags = PK11_ATTR_TOKEN | PK11_ATTR_SENSITIVE | PK11_ATTR_PRIVATE;
 
     // Get the key size //
     for (size_t i = 0; i < number_of_key_size_choices; ++i) {
         if (aValue.Equals(mSECKeySizeChoiceList[i].name)) {
             keysize = mSECKeySizeChoiceList[i].size;
             break;
         }
     }
     if (!keysize) {
         goto loser;
     }
 
     arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     if (!arena) {
         goto loser;
     }
 
     // Set the keygen mechanism
     if (aKeyType.IsEmpty() || aKeyType.LowerCaseEqualsLiteral("rsa")) {
         type = rsaKey;
         keyGenMechanism = CKM_RSA_PKCS_KEY_PAIR_GEN;
     } else if (aKeyType.LowerCaseEqualsLiteral("dsa")) {
         char * end;
         keyparamsString = ToNewCString(aKeyParams);
         if (!keyparamsString) {
             rv = NS_ERROR_OUT_OF_MEMORY;
             goto loser;
         }
 
         type = dsaKey;
         keyGenMechanism = CKM_DSA_KEY_PAIR_GEN;
         if (strcmp(keyparamsString, "null") == 0)
             goto loser;
         str = keyparamsString;
         bool found_match = false;
         do {
             end = strchr(str, ',');
             if (end != nsnull)
                 *end = '\0';
             primeBits = pqg_prime_bits(str);
             if (keysize == primeBits) {
                 found_match = true;
                 break;
             }
             str = end + 1;
         } while (end != nsnull);
         if (!found_match) {
             goto loser;
         }
     } else if (aKeyType.LowerCaseEqualsLiteral("ec")) {
@@ -628,124 +631,129 @@ nsKeygenFormProcessor::GetPublicKey(nsAS
              */
             if ((params = decode_ec_params(keyparamsString)) == nsnull) {
                 /* The keyparams attribute did not specify a valid
                  * curve name so use a curve based on the keysize.
                  * NOTE: Here keysize is used only as an indication of
                  * High/Medium/Low strength; elliptic curve
                  * cryptography uses smaller keys than RSA to provide
                  * equivalent security.
                  */
                 switch (keysize) {
                 case 2048:
                     params = decode_ec_params("secp384r1");
                     break;
                 case 1024:
                 case 512:
                     params = decode_ec_params("secp256r1");
                     break;
                 } 
             }
             /* XXX The signature algorithm ought to choose the hashing
              * algorithm based on key size once ECDSA variations based
              * on SHA256 SHA384 and SHA512 are standardized.
              */
             algTag = SEC_OID_ANSIX962_ECDSA_SIGNATURE_WITH_SHA1_DIGEST;
             break;
       default:
           goto loser;
       }
 
     /* Make sure token is initialized. */
     rv = setPassword(slot, m_ctx);
     if (NS_FAILED(rv))
         goto loser;
 
     sec_rv = PK11_Authenticate(slot, true, m_ctx);
     if (sec_rv != SECSuccess) {
         goto loser;
     }
 
     rv = getNSSDialogs((void**)&dialogs,
                        NS_GET_IID(nsIGeneratingKeypairInfoDialogs),
                        NS_GENERATINGKEYPAIRINFODIALOGS_CONTRACTID);
 
     if (NS_SUCCEEDED(rv)) {
         KeygenRunnable = new nsKeygenThread();
         NS_IF_ADDREF(KeygenRunnable);
     }
 
     if (NS_FAILED(rv) || !KeygenRunnable) {
         rv = NS_OK;
-        privateKey = PK11_GenerateKeyPair(slot, keyGenMechanism, params,
-                                          &publicKey, true, true, m_ctx);
+        privateKey = PK11_GenerateKeyPairWithFlags(slot, keyGenMechanism, params,
+                                                   &publicKey, attrFlags, m_ctx);
     } else {
-        KeygenRunnable->SetParams( slot, keyGenMechanism, params, true, true, m_ctx );
+        KeygenRunnable->SetParams( slot, attrFlags, nsnull, 0,
+                                   keyGenMechanism, params, m_ctx );
 
         runnable = do_QueryInterface(KeygenRunnable);
         
         if (runnable) {
             {
               nsPSMUITracker tracker;
               if (tracker.isUIForbidden()) {
                 rv = NS_ERROR_NOT_AVAILABLE;
               }
               else {
                 rv = dialogs->DisplayGeneratingKeypairInfo(m_ctx, runnable);
                 // We call join on the thread, 
                 // so we can be sure that no simultaneous access to the passed parameters will happen.
                 KeygenRunnable->Join();
               }
             }
 
             NS_RELEASE(dialogs);
             if (NS_SUCCEEDED(rv)) {
-                rv = KeygenRunnable->GetParams(&privateKey, &publicKey);
+                PK11SlotInfo *used_slot = nsnull;
+                rv = KeygenRunnable->ConsumeResult(&used_slot, &privateKey, &publicKey);
+                if (NS_SUCCEEDED(rv) && used_slot) {
+                  PK11_FreeSlot(used_slot);
+                }
             }
         }
     }
     
     if (NS_FAILED(rv) || !privateKey) {
         goto loser;
     }
     // just in case we'll need to authenticate to the db -jp //
     privateKey->wincx = m_ctx;
 
     /*
      * Create a subject public key info from the public key.
      */
     spkInfo = SECKEY_CreateSubjectPublicKeyInfo(publicKey);
     if ( !spkInfo ) {
         goto loser;
     }
     
     /*
      * Now DER encode the whole subjectPublicKeyInfo.
      */
     sec_rv=DER_Encode(arena, &spkiItem, CERTSubjectPublicKeyInfoTemplate, spkInfo);
     if (sec_rv != SECSuccess) {
         goto loser;
     }
 
     /*
      * set up the PublicKeyAndChallenge data structure, then DER encode it
      */
     pkac.spki = spkiItem;
     pkac.challenge.len = aChallenge.Length();
     pkac.challenge.data = (unsigned char *)ToNewCString(aChallenge);
     if (!pkac.challenge.data) {
         rv = NS_ERROR_OUT_OF_MEMORY;
         goto loser;
     }
     
     sec_rv = DER_Encode(arena, &pkacItem, CERTPublicKeyAndChallengeTemplate, &pkac);
     if ( sec_rv != SECSuccess ) {
         goto loser;
     }
 
     /*
      * now sign the DER encoded PublicKeyAndChallenge
      */
     sec_rv = SEC_DerSignData(arena, &signedItem, pkacItem.data, pkacItem.len,
 			 privateKey, algTag);
     if ( sec_rv != SECSuccess ) {
         goto loser;
     }
diff --git a/security/manager/ssl/src/nsKeygenThread.cpp b/security/manager/ssl/src/nsKeygenThread.cpp
--- a/security/manager/ssl/src/nsKeygenThread.cpp
+++ b/security/manager/ssl/src/nsKeygenThread.cpp
@@ -12,244 +12,273 @@
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "pk11func.h"
 #include "nsCOMPtr.h"
 #include "nsThreadUtils.h"
 #include "nsKeygenThread.h"
 #include "nsIObserver.h"
 #include "nsNSSShutDown.h"
 #include "PSMRunnable.h"
 
 using namespace mozilla;
 using namespace mozilla::psm;
 
 NS_IMPL_THREADSAFE_ISUPPORTS1(nsKeygenThread, nsIKeygenThread)
 
 
 nsKeygenThread::nsKeygenThread()
 :mutex("nsKeygenThread.mutex"),
  iAmRunning(false),
  keygenReady(false),
  statusDialogClosed(false),
  alreadyReceivedParams(false),
  privateKey(nsnull),
  publicKey(nsnull),
  slot(nsnull),
+ flags(0),
+ altSlot(nsnull),
+ altFlags(0),
+ usedSlot(nsnull),
  keyGenMechanism(0),
  params(nsnull),
- isPerm(false),
- isSensitive(false),
  wincx(nsnull),
  threadHandle(nsnull)
 {
 }
 
 nsKeygenThread::~nsKeygenThread()
 {
+  // clean up in the unlikely case that nobody consumed our results
+  
+  if (privateKey)
+    SECKEY_DestroyPrivateKey(privateKey);
+    
+  if (publicKey)
+    SECKEY_DestroyPublicKey(publicKey);
+    
+  if (usedSlot)
+    PK11_FreeSlot(usedSlot);
 }
 
 void nsKeygenThread::SetParams(
     PK11SlotInfo *a_slot,
+    PK11AttrFlags a_flags,
+    PK11SlotInfo *a_alternative_slot,
+    PK11AttrFlags a_alternative_flags,
     PRUint32 a_keyGenMechanism,
     void *a_params,
-    bool a_isPerm,
-    bool a_isSensitive,
     void *a_wincx )
 {
   nsNSSShutDownPreventionLock locker;
   MutexAutoLock lock(mutex);
  
     if (!alreadyReceivedParams) {
       alreadyReceivedParams = true;
-      if (a_slot) {
-        slot = PK11_ReferenceSlot(a_slot);
-      }
-      else {
-        slot = nsnull;
-      }
+      slot = (a_slot) ? PK11_ReferenceSlot(a_slot) : nsnull;
+      flags = a_flags;
+      altSlot = (a_alternative_slot) ? PK11_ReferenceSlot(a_alternative_slot) : nsnull;
+      altFlags = a_alternative_flags;
       keyGenMechanism = a_keyGenMechanism;
       params = a_params;
-      isPerm = a_isPerm;
-      isSensitive = a_isSensitive;
       wincx = a_wincx;
     }
 }
 
-nsresult nsKeygenThread::GetParams(
+nsresult nsKeygenThread::ConsumeResult(
+    PK11SlotInfo **a_used_slot,
     SECKEYPrivateKey **a_privateKey,
     SECKEYPublicKey **a_publicKey)
 {
-  if (!a_privateKey || !a_publicKey) {
+  if (!a_used_slot || !a_privateKey || !a_publicKey) {
     return NS_ERROR_FAILURE;
   }
 
   nsresult rv;
 
   MutexAutoLock lock(mutex);
   
     // GetParams must not be called until thread creator called
     // Join on this thread.
     NS_ASSERTION(keygenReady, "logic error in nsKeygenThread::GetParams");
 
     if (keygenReady) {
       *a_privateKey = privateKey;
       *a_publicKey = publicKey;
+      *a_used_slot = usedSlot;
 
       privateKey = 0;
       publicKey = 0;
+      usedSlot = 0;
       
       rv = NS_OK;
     }
     else {
       rv = NS_ERROR_FAILURE;
     }
   
   return rv;
 }
 
 static void PR_CALLBACK nsKeygenThreadRunner(void *arg)
 {
   nsKeygenThread *self = static_cast<nsKeygenThread *>(arg);
   self->Run();
 }
 
 nsresult nsKeygenThread::StartKeyGeneration(nsIObserver* aObserver)
 {
   if (!NS_IsMainThread()) {
     NS_ERROR("nsKeygenThread::StartKeyGeneration called off the main thread");
     return NS_ERROR_NOT_SAME_THREAD;
   }
   
   if (!aObserver)
     return NS_OK;
 
   MutexAutoLock lock(mutex);
 
     if (iAmRunning || keygenReady) {
       return NS_OK;
     }
 
     // We must AddRef aObserver only here on the main thread, because it
     // probably does not implement a thread-safe AddRef.
     mNotifyObserver = new NotifyObserverRunnable(aObserver, "keygen-finished");
 
     iAmRunning = true;
 
     threadHandle = PR_CreateThread(PR_USER_THREAD, nsKeygenThreadRunner, static_cast<void*>(this), 
       PR_PRIORITY_NORMAL, PR_LOCAL_THREAD, PR_JOINABLE_THREAD, 0);
 
     // bool thread_started_ok = (threadHandle != nsnull);
     // we might want to return "thread started ok" to caller in the future
     NS_ASSERTION(threadHandle, "Could not create nsKeygenThreadRunner thread\n");
   
   return NS_OK;
 }
 
 nsresult nsKeygenThread::UserCanceled(bool *threadAlreadyClosedDialog)
 {
   if (!threadAlreadyClosedDialog)
     return NS_OK;
 
   *threadAlreadyClosedDialog = false;
 
   MutexAutoLock lock(mutex);
   
     if (keygenReady)
       *threadAlreadyClosedDialog = statusDialogClosed;
 
     // User somehow closed the dialog, but we will not cancel.
     // Bad luck, we told him not do, and user still has to wait.
     // However, we remember that it's closed and will not close
     // it again to avoid problems.
     statusDialogClosed = true;
 
   return NS_OK;
 }
 
 void nsKeygenThread::Run(void)
 {
   nsNSSShutDownPreventionLock locker;
   bool canGenerate = false;
 
   {
     MutexAutoLock lock(mutex);
     if (alreadyReceivedParams) {
       canGenerate = true;
       keygenReady = false;
     }
   }
 
-  if (canGenerate)
-    privateKey = PK11_GenerateKeyPair(slot, keyGenMechanism,
-                                         params, &publicKey,
-                                         isPerm, isSensitive, wincx);
+  if (canGenerate) {
+    privateKey = PK11_GenerateKeyPairWithFlags(slot, keyGenMechanism,
+                                               params, &publicKey,
+                                               flags, wincx);
+
+    if (privateKey) {
+      usedSlot = PK11_ReferenceSlot(slot);
+    }
+    else if (altSlot) {
+      privateKey = PK11_GenerateKeyPairWithFlags(altSlot, keyGenMechanism,
+                                                 params, &publicKey,
+                                                 altFlags, wincx);
+      if (privateKey) {
+        usedSlot = PK11_ReferenceSlot(altSlot);
+      }
+    }
+  }
   
   // This call gave us ownership over privateKey and publicKey.
   // But as the params structure is owner by our caller,
   // we effectively transferred ownership to the caller.
   // As long as key generation can't be canceled, we don't need 
   // to care for cleaning this up.
 
   nsCOMPtr<nsIRunnable> notifyObserver;
   {
     MutexAutoLock lock(mutex);
 
     keygenReady = true;
     iAmRunning = false;
 
     // forget our parameters
     if (slot) {
       PK11_FreeSlot(slot);
       slot = 0;
     }
+    if (altSlot) {
+      PK11_FreeSlot(altSlot);
+      altSlot = 0;
+    }
     keyGenMechanism = 0;
     params = 0;
     wincx = 0;
 
     if (!statusDialogClosed && mNotifyObserver)
       notifyObserver = mNotifyObserver;
 
     mNotifyObserver = nsnull;
   }
 
   if (notifyObserver) {
     nsresult rv = NS_DispatchToMainThread(notifyObserver);
     NS_ASSERTION(NS_SUCCEEDED(rv),
 		 "failed to dispatch keygen thread observer to main thread");
   }
 }
 
 void nsKeygenThread::Join()
 {
   if (!threadHandle)
     return;
   
   PR_JoinThread(threadHandle);
   threadHandle = nsnull;
 
   return;
 }
diff --git a/security/manager/ssl/src/nsKeygenThread.h b/security/manager/ssl/src/nsKeygenThread.h
--- a/security/manager/ssl/src/nsKeygenThread.h
+++ b/security/manager/ssl/src/nsKeygenThread.h
@@ -16,83 +16,87 @@
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef _NSKEYGENTHREAD_H_
 #define _NSKEYGENTHREAD_H_
 
 #include "keyhi.h"
 #include "nspr.h"
 
 #include "mozilla/Mutex.h"
 #include "nsIKeygenThread.h"
 #include "nsCOMPtr.h"
 
 class nsIRunnable;
 
 class nsKeygenThread : public nsIKeygenThread
 {
 private:
   mozilla::Mutex mutex;
   
   nsCOMPtr<nsIRunnable> mNotifyObserver;
 
   bool iAmRunning;
   bool keygenReady;
   bool statusDialogClosed;
   bool alreadyReceivedParams;
 
   SECKEYPrivateKey *privateKey;
   SECKEYPublicKey *publicKey;
   PK11SlotInfo *slot;
+  PK11AttrFlags flags;
+  PK11SlotInfo *altSlot;
+  PK11AttrFlags altFlags;
+  PK11SlotInfo *usedSlot;
   PRUint32 keyGenMechanism;
   void *params;
-  bool isPerm;
-  bool isSensitive;
   void *wincx;
 
   PRThread *threadHandle;
   
 public:
   nsKeygenThread();
   virtual ~nsKeygenThread();
   
   NS_DECL_NSIKEYGENTHREAD
   NS_DECL_ISUPPORTS
 
   void SetParams(
     PK11SlotInfo *a_slot,
+    PK11AttrFlags a_flags,
+    PK11SlotInfo *a_alternative_slot,
+    PK11AttrFlags a_alternative_flags,
     PRUint32 a_keyGenMechanism,
     void *a_params,
-    bool a_isPerm,
-    bool a_isSensitive,
     void *a_wincx );
 
-  nsresult GetParams(
+  nsresult ConsumeResult(
+    PK11SlotInfo **a_used_slot,
     SECKEYPrivateKey **a_privateKey,
     SECKEYPublicKey **a_publicKey);
   
   void Join(void);
 
   void Run(void);
 };
 
 #endif //_NSKEYGENTHREAD_H_
