diff --git a/modules/libpr0n/src/imgRequest.cpp b/modules/libpr0n/src/imgRequest.cpp
--- a/modules/libpr0n/src/imgRequest.cpp
+++ b/modules/libpr0n/src/imgRequest.cpp
@@ -314,20 +314,30 @@ nsresult imgRequest::GetPrincipal(nsIPri
   LOG_FUNC(gImgLog, "imgRequest::GetPrincipal");
 
   if (mPrincipal) {
     NS_ADDREF(*aPrincipal = mPrincipal);
     return NS_OK;
   }
 
   return NS_ERROR_FAILURE;
 }
 
+nsresult imgRequest::GetSecurityInfo(nsISupports **aSecurityInfo)
+{
+  LOG_FUNC(gImgLog, "imgRequest::GetSecurityInfo");
+
+  // Missing security info means this is not a security load
+  // i.e. it is not an error when security info is missing
+  NS_IF_ADDREF(*aSecurityInfo = mSecurityInfo);
+  return NS_OK;
+}
+
 void imgRequest::RemoveFromCache()
 {
   LOG_SCOPE(gImgLog, "imgRequest::RemoveFromCache");
 
   if (mCacheEntry) {
     mCacheEntry->Doom();
     mCacheEntry = nsnull;
   }
 }
 
@@ -589,20 +599,24 @@ NS_IMETHODIMP imgRequest::OnStartRequest
 
   nsCOMPtr<nsIMultiPartChannel> mpchan(do_QueryInterface(aRequest));
   if (mpchan)
       mIsMultiPartChannel = PR_TRUE;
 
   /* set our state variables to their initial values, but advance mState
      to onStartRequest. */
   mImageStatus = imgIRequest::STATUS_NONE;
   mState = onStartRequest;
 
+  nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
+  if (channel)
+    channel->GetSecurityInfo(getter_AddRefs(mSecurityInfo));
+
   /* set our loading flag to true */
   mLoading = PR_TRUE;
 
   /* notify our kids */
   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mObservers);
   while (iter.HasMore()) {
     iter.GetNext()->OnStartRequest(aRequest, ctxt);
   }
 
   /* Get our principal */
diff --git a/modules/libpr0n/src/imgRequest.h b/modules/libpr0n/src/imgRequest.h
--- a/modules/libpr0n/src/imgRequest.h
+++ b/modules/libpr0n/src/imgRequest.h
@@ -116,20 +116,21 @@ private:
 
   inline void SetLoadId(void *aLoadId) {
     mLoadId = aLoadId;
     mLoadTime = PR_Now();
   }
   inline PRUint32 GetImageStatus() const { return mImageStatus; }
   inline nsresult GetResultFromImageStatus(PRUint32 aStatus) const;
   void Cancel(nsresult aStatus);
   nsresult GetURI(nsIURI **aURI);
   nsresult GetPrincipal(nsIPrincipal **aPrincipal);
+  nsresult GetSecurityInfo(nsISupports **aSecurityInfo);
   void RemoveFromCache();
   inline const char *GetMimeType() const {
     return mContentType.get();
   }
   inline nsIProperties *Properties() {
     return mProperties;
   }
 
   // Return true if at least one of our proxies, excluding
   // aProxyToIgnore, has an observer.  aProxyToIgnore may be null.
@@ -150,20 +151,21 @@ public:
   NS_DECL_NSISTREAMLISTENER
   NS_DECL_NSIREQUESTOBSERVER
 
 private:
   nsCOMPtr<nsIRequest> mRequest;
   nsCOMPtr<nsIURI> mURI;
   nsCOMPtr<nsIPrincipal> mPrincipal;
   nsCOMPtr<imgIContainer> mImage;
   nsCOMPtr<imgIDecoder> mDecoder;
   nsCOMPtr<nsIProperties> mProperties;
+  nsCOMPtr<nsISupports> mSecurityInfo;
 
   nsTObserverArray<imgRequestProxy*> mObservers;
 
   PRPackedBool mLoading;
   PRPackedBool mProcessing;
   PRPackedBool mHadLastPart;
   PRUint32 mNetworkStatus;
   PRUint32 mImageStatus;
   PRUint32 mState;
   nsCString mContentType;
diff --git a/modules/libpr0n/src/imgRequestProxy.cpp b/modules/libpr0n/src/imgRequestProxy.cpp
--- a/modules/libpr0n/src/imgRequestProxy.cpp
+++ b/modules/libpr0n/src/imgRequestProxy.cpp
@@ -48,22 +48,22 @@
 #include "nsXPIDLString.h"
 #include "nsReadableUtils.h"
 #include "nsCRT.h"
 
 #include "ImageErrors.h"
 #include "ImageLogging.h"
 
 #include "nspr.h"
 
 
-NS_IMPL_ISUPPORTS3(imgRequestProxy, imgIRequest, nsIRequest,
-                   nsISupportsPriority)
+NS_IMPL_ISUPPORTS4(imgRequestProxy, imgIRequest, nsIRequest,
+                   nsISupportsPriority, nsISecurityInfoProvider)
 
 imgRequestProxy::imgRequestProxy() :
   mOwner(nsnull),
   mListener(nsnull),
   mLoadFlags(nsIRequest::LOAD_NORMAL),
   mCanceled(PR_FALSE),
   mIsInLoadGroup(PR_FALSE),
   mListenerIsStrongRef(PR_FALSE)
 {
   /* member initializers and constructor code */
@@ -376,20 +376,31 @@ NS_IMETHODIMP imgRequestProxy::SetPriori
   return NS_OK;
 }
 
 NS_IMETHODIMP imgRequestProxy::AdjustPriority(PRInt32 priority)
 {
   NS_ENSURE_STATE(mOwner && !mCanceled);
   mOwner->AdjustPriority(this, priority);
   return NS_OK;
 }
 
+/** nsISecurityInfoProvider methods **/
+
+NS_IMETHODIMP imgRequestProxy::GetSecurityInfo(nsISupports** _retval)
+{
+  if (mOwner)
+    return mOwner->GetSecurityInfo(_retval);
+
+  *_retval = nsnull;
+  return NS_OK;
+}
+
 /** imgIContainerObserver methods **/
 
 void imgRequestProxy::FrameChanged(imgIContainer *container, gfxIImageFrame *newframe, nsIntRect * dirtyRect)
 {
   LOG_FUNC(gImgLog, "imgRequestProxy::FrameChanged");
 
   if (mListener) {
     // Hold a ref to the listener while we call it, just in case.
     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
     mListener->FrameChanged(container, newframe, dirtyRect);
diff --git a/modules/libpr0n/src/imgRequestProxy.h b/modules/libpr0n/src/imgRequestProxy.h
--- a/modules/libpr0n/src/imgRequestProxy.h
+++ b/modules/libpr0n/src/imgRequestProxy.h
@@ -32,47 +32,49 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "imgIRequest.h"
 #include "imgIDecoderObserver.h"
+#include "nsISecurityInfoProvider.h"
 
 #include "imgIContainer.h"
 #include "imgIDecoder.h"
 #include "nsIRequestObserver.h"
 #include "nsIChannel.h"
 #include "nsILoadGroup.h"
 #include "nsISupportsPriority.h"
 #include "nsCOMPtr.h"
 #include "nsAutoPtr.h"
 
 #include "imgRequest.h"
 
 #define NS_IMGREQUESTPROXY_CID \
 { /* 20557898-1dd2-11b2-8f65-9c462ee2bc95 */         \
      0x20557898,                                     \
      0x1dd2,                                         \
      0x11b2,                                         \
     {0x8f, 0x65, 0x9c, 0x46, 0x2e, 0xe2, 0xbc, 0x95} \
 }
 
-class imgRequestProxy : public imgIRequest, public nsISupportsPriority
+class imgRequestProxy : public imgIRequest, public nsISupportsPriority, public nsISecurityInfoProvider
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_IMGIREQUEST
   NS_DECL_NSIREQUEST
   NS_DECL_NSISUPPORTSPRIORITY
+  NS_DECL_NSISECURITYINFOPROVIDER
 
   imgRequestProxy();
   virtual ~imgRequestProxy();
 
   // Callers to Init or ChangeOwner are required to call
   // NotifyProxyListener on the request after (although not immediately
   // after) doing so.
   nsresult Init(imgRequest *request, nsILoadGroup *aLoadGroup, imgIDecoderObserver *aObserver);
   nsresult ChangeOwner(imgRequest *aNewOwner); // this will change mOwner.  Do not call this if the previous
                                                // owner has already sent notifications out!
diff --git a/netwerk/base/public/Makefile.in b/netwerk/base/public/Makefile.in
--- a/netwerk/base/public/Makefile.in
+++ b/netwerk/base/public/Makefile.in
@@ -96,20 +96,21 @@ XPIDLSRCS	= \
 		nsIProtocolProxyCallback.idl \
 		nsIProxiedProtocolHandler.idl \
 		nsIProxyAutoConfig.idl \
 		nsIProxyInfo.idl \
 		nsITransport.idl \
 		nsISocketTransport.idl \
 		nsISocketTransportService.idl \
 		nsIServerSocket.idl \
 		nsIResumableChannel.idl \
 		nsIRequestObserverProxy.idl \
+		nsISecurityInfoProvider.idl \
 		nsIStreamListenerTee.idl \
 		nsISimpleStreamListener.idl \
 		nsIStreamTransportService.idl \
 		nsIStreamLoader.idl \
 		nsISyncStreamListener.idl \
 		nsISystemProxySettings.idl \
 		nsIUnicharStreamLoader.idl \
 		nsIStandardURL.idl \
 		nsINestedURI.idl \
 		nsIURLParser.idl \
diff --git a/netwerk/base/public/nsISecurityInfoProvider.idl b/netwerk/base/public/nsISecurityInfoProvider.idl
new file mode 100644
--- /dev/null
+++ b/netwerk/base/public/nsISecurityInfoProvider.idl
@@ -0,0 +1,44 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is mozilla.org
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): 
+ *    Honza Bambas <honzab@firemni.cz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+ 
+#include "nsISupports.idl"
+
+[scriptable, uuid(9E03B4C6-8B79-41a8-A3E5-C41F9E015598)]
+interface nsISecurityInfoProvider : nsISupports
+{
+  readonly attribute nsISupports securityInfo;
+};
diff --git a/security/manager/boot/src/Makefile.in b/security/manager/boot/src/Makefile.in
--- a/security/manager/boot/src/Makefile.in
+++ b/security/manager/boot/src/Makefile.in
@@ -69,20 +69,21 @@ REQUIRES	= nspr \
 		  uriloader \
 		  dom \
 		  intl \
 		  docshell \
 		  widget \
 		  layout \
 		  content \
 		  caps \
 		  pref \
 		  pipnss \
+		  imglib2 \
 		  $(NULL)
 
 include $(topsrcdir)/config/rules.mk
 
 INCLUDES	+= \
 		-I$(DIST)/public/nss \
 		$(NULL)
 
 EXTRA_DSO_LDOPTS += \
 		$(MOZ_COMPONENT_LIBS) \
diff --git a/security/manager/boot/src/nsSecureBrowserUIImpl.cpp b/security/manager/boot/src/nsSecureBrowserUIImpl.cpp
--- a/security/manager/boot/src/nsSecureBrowserUIImpl.cpp
+++ b/security/manager/boot/src/nsSecureBrowserUIImpl.cpp
@@ -71,21 +71,23 @@
 #include "nsIFileChannel.h"
 #include "nsIWyciwygChannel.h"
 #include "nsIFTPChannel.h"
 #include "nsITransportSecurityInfo.h"
 #include "nsIIdentityInfo.h"
 #include "nsIURI.h"
 #include "nsISecurityEventSink.h"
 #include "nsIPrompt.h"
 #include "nsIFormSubmitObserver.h"
 #include "nsISecurityWarningDialogs.h"
+#include "nsISecurityInfoProvider.h"
 #include "nsIProxyObjectManager.h"
+#include "imgIRequest.h"
 #include "nsThreadUtils.h"
 #include "nsNetUtil.h"
 #include "nsCRT.h"
 #include "nsAutoLock.h"
 
 #define SECURITY_STRING_BUNDLE_URL "chrome://pipnss/locale/security.properties"
 
 #define IS_SECURE(state) ((state & 0xFFFF) == STATE_IS_SECURE)
 
 #if defined(PR_LOGGING)
@@ -262,20 +264,38 @@ nsSecureBrowserUIImpl::Init(nsIDOMWindow
 
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSecureBrowserUIImpl::GetState(PRUint32* aState)
 {
   nsAutoMonitor lock(mMonitor);
   return MapInternalToExternalState(aState, mNotifiedSecurityState, mNotifiedToplevelIsEV);
+}
+
+// static
+already_AddRefed<nsISupports> 
+nsSecureBrowserUIImpl::ExtractSecurityInfo(nsIRequest* aRequest)
+{
+  nsISupports *retval = nsnull; 
+  nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
+  if (channel)
+    channel->GetSecurityInfo(&retval);
+  
+  if (!retval) {
+    nsCOMPtr<nsISecurityInfoProvider> provider(do_QueryInterface(aRequest));
+    if (provider)
+      provider->GetSecurityInfo(&retval);
+  }
+
+  return retval;
 }
 
 nsresult
 nsSecureBrowserUIImpl::MapInternalToExternalState(PRUint32* aState, lockIconState lock, PRBool ev)
 {
   NS_ENSURE_ARG(aState);
 
   switch (lock)
   {
     case lis_broken_security:
@@ -731,27 +751,25 @@ nsSecureBrowserUIImpl::OnStateChange(nsI
 #ifdef PR_LOGGING
   if (PR_LOG_TEST(gSecureDocLog, PR_LOG_DEBUG)) {
     nsXPIDLCString reqname;
     aRequest->GetName(reqname);
     PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
            ("SecureUI:%p: %p %p OnStateChange %x %s\n", this, aWebProgress,
             aRequest, aProgressStateFlags, reqname.get()));
   }
 #endif
 
-  nsCOMPtr<nsISupports> securityInfo;
+  nsCOMPtr<nsISupports> securityInfo(ExtractSecurityInfo(aRequest));
+
   nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
-
   if (channel)
   {
-    channel->GetSecurityInfo(getter_AddRefs(securityInfo));
-
     nsCOMPtr<nsIURI> uri;
     channel->GetURI(getter_AddRefs(uri));
     if (uri)
     {
       PRBool vs;
       if (NS_SUCCEEDED(uri->SchemeIs("javascript", &vs)) && vs)
       {
         // We ignore the progress events for javascript URLs.
         // If a document loading gets triggered, we will see more events.
         return NS_OK;
@@ -782,35 +800,45 @@ nsSecureBrowserUIImpl::OnStateChange(nsI
       isToplevelProgress
       &&
       loadFlags & nsIChannel::LOAD_DOCUMENT_URI)
   {
     PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
            ("SecureUI:%p: OnStateChange: SOMETHING STOPS FOR TOPMOST DOCUMENT\n", this));
   }
 #endif
 
   PRBool isSubDocumentRelevant = PR_TRUE;
+  PRBool isImageRequest = PR_FALSE;
 
   // We are only interested in requests that load in the browser window...
   nsCOMPtr<nsIHttpChannel> httpRequest(do_QueryInterface(aRequest));
   if (!httpRequest) {
-    nsCOMPtr<nsIFileChannel> fileRequest(do_QueryInterface(aRequest));
-    if (!fileRequest) {
-      nsCOMPtr<nsIWyciwygChannel> wyciwygRequest(do_QueryInterface(aRequest));
-      if (!wyciwygRequest) {
-        nsCOMPtr<nsIFTPChannel> ftpRequest(do_QueryInterface(aRequest));
-        if (!ftpRequest) {
-          PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
-                 ("SecureUI:%p: OnStateChange: not relevant for sub content\n", this));
-          isSubDocumentRelevant = PR_FALSE;
+    nsCOMPtr<imgIRequest> imgRequest(do_QueryInterface(aRequest));
+    if (!imgRequest) {
+      nsCOMPtr<nsIFileChannel> fileRequest(do_QueryInterface(aRequest));
+      if (!fileRequest) {
+        nsCOMPtr<nsIWyciwygChannel> wyciwygRequest(do_QueryInterface(aRequest));
+        if (!wyciwygRequest) {
+          nsCOMPtr<nsIFTPChannel> ftpRequest(do_QueryInterface(aRequest));
+          if (!ftpRequest) {
+              PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
+                     ("SecureUI:%p: OnStateChange: not relevant for sub content\n", this));
+              isSubDocumentRelevant = PR_FALSE;
+          }
         }
       }
+    } else { // !imgRequest
+        // Remember this is an image request. Because image loads doesn't
+        // support any TRANSFERRING notifications but only START and
+        // STOP we must simply predict there were a content transferred.
+        // See bug 432685 for details.
+        isImageRequest = PR_TRUE;
     }
   }
 
 #if defined(DEBUG)
   nsCString info2;
   PRUint32 testFlags = loadFlags;
 
   if (testFlags & nsIChannel::LOAD_DOCUMENT_URI)
   {
     testFlags -= nsIChannel::LOAD_DOCUMENT_URI;
@@ -932,39 +960,49 @@ nsSecureBrowserUIImpl::OnStateChange(nsI
   }
 #endif
 
   if (aProgressStateFlags & STATE_TRANSFERRING
       &&
       aProgressStateFlags & STATE_IS_REQUEST)
   {
     // The listing of a request in mTransferringRequests
     // means, there has already been data transfered.
 
-    nsAutoMonitor lock(mMonitor);
-    PL_DHashTableOperate(&mTransferringRequests, aRequest, PL_DHASH_ADD);
+    if (!isImageRequest) 
+    {
+      nsAutoMonitor lock(mMonitor);
+      PL_DHashTableOperate(&mTransferringRequests, aRequest, PL_DHASH_ADD);
+    }
     
     return NS_OK;
   }
 
   PRBool requestHasTransferedData = PR_FALSE;
 
   if (aProgressStateFlags & STATE_STOP
       &&
       aProgressStateFlags & STATE_IS_REQUEST)
   {
-    nsAutoMonitor lock(mMonitor);
-    PLDHashEntryHdr *entry = PL_DHashTableOperate(&mTransferringRequests, aRequest, PL_DHASH_LOOKUP);
-    if (PL_DHASH_ENTRY_IS_BUSY(entry))
+    if (isImageRequest) 
     {
-      PL_DHashTableOperate(&mTransferringRequests, aRequest, PL_DHASH_REMOVE);
+      requestHasTransferedData = PR_TRUE;
+    }
+    else
+    {
+      nsAutoMonitor lock(mMonitor);
+      PLDHashEntryHdr *entry = PL_DHashTableOperate(&mTransferringRequests, aRequest, PL_DHASH_LOOKUP);
+      if (PL_DHASH_ENTRY_IS_BUSY(entry))
+      {
+        PL_DHashTableOperate(&mTransferringRequests, aRequest, PL_DHASH_REMOVE);
 
-      requestHasTransferedData = PR_TRUE;
+        requestHasTransferedData = PR_TRUE;
+      }
     }
   }
 
   PRBool allowSecurityStateChange = PR_TRUE;
   if (loadFlags & nsIChannel::LOAD_RETARGETED_DOCUMENT_URI)
   {
     // The original consumer (this) is no longer the target of the load.
     // Ignore any events with this flag, do not allow them to update
     // our secure UI state.
     allowSecurityStateChange = PR_FALSE;
@@ -1443,24 +1481,21 @@ nsSecureBrowserUIImpl::OnLocationChange(
   // only concern with doing this here is that a page may transition from being
   // reported as completely secure to being reported as partially secure
   // (mixed).  This may be confusing for users, and it may bother users who
   // like seeing security dialogs.  However, it seems prudent given that page
   // loading may never end in some edge cases (perhaps by a site with malicious
   // intent).
 
   nsCOMPtr<nsIDOMWindow> windowForProgress;
   aWebProgress->GetDOMWindow(getter_AddRefs(windowForProgress));
 
-  nsCOMPtr<nsISupports> securityInfo;
-  nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
-  if (channel)
-    channel->GetSecurityInfo(getter_AddRefs(securityInfo));
+  nsCOMPtr<nsISupports> securityInfo(ExtractSecurityInfo(aRequest));
 
   if (windowForProgress.get() == window.get()) {
     // For toplevel channels, update the security state right away.
     return EvaluateAndUpdateSecurityState(aRequest, securityInfo);
   }
 
   // For channels in subdocuments we only update our subrequest state members.
   UpdateSubrequestMembers(securityInfo);
 
   // Care for the following scenario:
diff --git a/security/manager/boot/src/nsSecureBrowserUIImpl.h b/security/manager/boot/src/nsSecureBrowserUIImpl.h
--- a/security/manager/boot/src/nsSecureBrowserUIImpl.h
+++ b/security/manager/boot/src/nsSecureBrowserUIImpl.h
@@ -119,20 +119,21 @@ protected:
   PRPackedBool mNewToplevelSecurityStateKnown;
   PRPackedBool mIsViewSource;
 
   nsXPIDLString mInfoTooltip;
   PRInt32 mDocumentRequestsInProgress;
   PRInt32 mSubRequestsHighSecurity;
   PRInt32 mSubRequestsLowSecurity;
   PRInt32 mSubRequestsBrokenSecurity;
   PRInt32 mSubRequestsNoSecurity;
 
+  static already_AddRefed<nsISupports> ExtractSecurityInfo(nsIRequest* aRequest);
   static nsresult MapInternalToExternalState(PRUint32* aState, lockIconState lock, PRBool ev);
   nsresult UpdateSecurityState(nsIRequest* aRequest);
   void UpdateMyFlags(PRBool &showWarning, lockIconState &warnSecurityState);
   nsresult TellTheWorld(PRBool showWarning, 
                         lockIconState warnSecurityState, 
                         nsIRequest* aRequest);
 
   nsresult EvaluateAndUpdateSecurityState(nsIRequest* aRequest, nsISupports *info);
   void UpdateSubrequestMembers(nsISupports *securityInfo);
 
