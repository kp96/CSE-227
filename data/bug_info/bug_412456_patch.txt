Index: mozilla/security/manager/boot/src/nsSecureBrowserUIImpl.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/boot/src/nsSecureBrowserUIImpl.cpp,v
retrieving revision 1.68
diff -u -u -1 -5 -p -r1.68 nsSecureBrowserUIImpl.cpp
--- mozilla/security/manager/boot/src/nsSecureBrowserUIImpl.cpp	22 Feb 2008 01:04:05 -0000	1.68
+++ mozilla/security/manager/boot/src/nsSecureBrowserUIImpl.cpp	29 Feb 2008 19:14:52 -0000
@@ -70,30 +70,31 @@
 #include "nsIHttpChannel.h"
 #include "nsIFileChannel.h"
 #include "nsIWyciwygChannel.h"
 #include "nsIFTPChannel.h"
 #include "nsITransportSecurityInfo.h"
 #include "nsIIdentityInfo.h"
 #include "nsIURI.h"
 #include "nsISecurityEventSink.h"
 #include "nsIPrompt.h"
 #include "nsIFormSubmitObserver.h"
 #include "nsISecurityWarningDialogs.h"
 #include "nsIProxyObjectManager.h"
 #include "nsThreadUtils.h"
 #include "nsNetUtil.h"
 #include "nsCRT.h"
+#include "nsAutoLock.h"
 
 #define SECURITY_STRING_BUNDLE_URL "chrome://pipnss/locale/security.properties"
 
 #define IS_SECURE(state) ((state & 0xFFFF) == STATE_IS_SECURE)
 
 #if defined(PR_LOGGING)
 //
 // Log module for nsSecureBroswerUI logging...
 //
 // To enable logging (see prlog.h for full details):
 //
 //    set NSPR_LOG_MODULES=nsSecureBroswerUI:5
 //    set NSPR_LOG_FILE=nspr.log
 //
 // this enables PR_LOG_DEBUG level information and places all output in
@@ -128,57 +129,60 @@ static PLDHashTableOps gMapOps = {
   PL_DHashFreeTable,
   PL_DHashVoidPtrKeyStub,
   RequestMapMatchEntry,
   PL_DHashMoveEntryStub,
   PL_DHashClearEntryStub,
   PL_DHashFinalizeStub,
   RequestMapInitEntry
 };
 
 
 nsSecureBrowserUIImpl::nsSecureBrowserUIImpl()
   : mNotifiedSecurityState(lis_no_security),
     mNotifiedToplevelIsEV(PR_FALSE),
     mIsViewSource(PR_FALSE)
 {
+  mMonitor = PR_NewMonitor();
   mTransferringRequests.ops = nsnull;
   mNewToplevelSecurityState = STATE_IS_INSECURE;
   mNewToplevelIsEV = PR_FALSE;
   mNewToplevelSecurityStateKnown = PR_TRUE;
   ResetStateTracking();
   
 #if defined(PR_LOGGING)
   if (!gSecureDocLog)
     gSecureDocLog = PR_NewLogModule("nsSecureBrowserUI");
 #endif /* PR_LOGGING */
 }
 
 nsSecureBrowserUIImpl::~nsSecureBrowserUIImpl()
 {
   if (mTransferringRequests.ops) {
     PL_DHashTableFinish(&mTransferringRequests);
     mTransferringRequests.ops = nsnull;
   }
+  if (mMonitor)
+    PR_DestroyMonitor(mMonitor);
 }
 
-NS_IMPL_ISUPPORTS6(nsSecureBrowserUIImpl,
-                   nsISecureBrowserUI,
-                   nsIWebProgressListener,
-                   nsIFormSubmitObserver,
-                   nsIObserver,
-                   nsISupportsWeakReference,
-                   nsISSLStatusProvider)
+NS_IMPL_THREADSAFE_ISUPPORTS6(nsSecureBrowserUIImpl,
+                              nsISecureBrowserUI,
+                              nsIWebProgressListener,
+                              nsIFormSubmitObserver,
+                              nsIObserver,
+                              nsISupportsWeakReference,
+                              nsISSLStatusProvider)
 
 
 NS_IMETHODIMP
 nsSecureBrowserUIImpl::Init(nsIDOMWindow *window)
 {
   PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
          ("SecureUI:%p: Init: mWindow: %p, window: %p\n", this, mWindow.get(),
           window));
 
   if (!window) {
     NS_WARNING("Null window passed to nsSecureBrowserUIImpl::Init()");
     return NS_ERROR_INVALID_ARG;
   }
 
   if (mWindow) {
@@ -223,30 +227,31 @@ nsSecureBrowserUIImpl::Init(nsIDOMWindow
   if (!wp) return NS_ERROR_FAILURE;
   /* end GetWebProgress */
   
   wp->AddProgressListener(static_cast<nsIWebProgressListener*>(this),
                           nsIWebProgress::NOTIFY_STATE_ALL | 
                           nsIWebProgress::NOTIFY_LOCATION  |
                           nsIWebProgress::NOTIFY_SECURITY);
 
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSecureBrowserUIImpl::GetState(PRUint32* aState)
 {
+  nsAutoMonitor lock(mMonitor);
   return MapInternalToExternalState(aState, mNotifiedSecurityState, mNotifiedToplevelIsEV);
 }
 
 nsresult
 nsSecureBrowserUIImpl::MapInternalToExternalState(PRUint32* aState, lockIconState lock, PRBool ev)
 {
   NS_ENSURE_ARG(aState);
 
   switch (lock)
   {
     case lis_broken_security:
       *aState = STATE_IS_BROKEN;
       break;
 
     case lis_mixed_security:
@@ -264,38 +269,47 @@ nsSecureBrowserUIImpl::MapInternalToExte
     default:
     case lis_no_security:
       *aState = STATE_IS_INSECURE;
       break;
   }
 
   if (ev && (*aState & STATE_IS_SECURE))
     *aState |= nsIWebProgressListener::STATE_IDENTITY_EV_TOPLEVEL;
   
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSecureBrowserUIImpl::GetTooltipText(nsAString& aText)
 {
-  if (mNotifiedSecurityState == lis_mixed_security)
+  lockIconState state;
+  nsXPIDLString tooltip;
+
+  {
+    nsAutoMonitor lock(mMonitor);
+    state = mNotifiedSecurityState;
+    tooltip = mInfoTooltip;
+  }
+
+  if (state == lis_mixed_security)
   {
     GetBundleString(NS_LITERAL_STRING("SecurityButtonMixedContentTooltipText").get(),
                     aText);
   }
-  else if (!mInfoTooltip.IsEmpty())
+  else if (!tooltip.IsEmpty())
   {
-    aText = mInfoTooltip;
+    aText = tooltip;
   }
   else
   {
     GetBundleString(NS_LITERAL_STRING("SecurityButtonTooltipText").get(),
                     aText);
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSecureBrowserUIImpl::Observe(nsISupports*, const char*,
                                const PRUnichar*)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
@@ -379,133 +393,169 @@ nsSecureBrowserUIImpl::Notify(nsIDOMHTML
       !formURL)
   {
     formURL = document->GetDocumentURI();
   }
 
   nsCOMPtr<nsIDOMWindow> postingWindow =
     do_QueryInterface(document->GetWindow());
   // We can't find this document's window, cancel it.
   if (!postingWindow)
   {
     NS_WARNING("If you see this and can explain why it should be allowed, note in Bug 332324");
     *cancelSubmit = PR_TRUE;
     return NS_OK;
   }
 
+  nsCOMPtr<nsIDOMWindow> testWindow;
+  {
+    nsAutoMonitor lock(mMonitor);
+    testWindow = mWindow;
+  }
+
   PRBool isChild;
-  IsChildOfDomWindow(mWindow, postingWindow, &isChild);
+  IsChildOfDomWindow(testWindow, postingWindow, &isChild);
   
   // This notify call is not for our window, ignore it.
   if (!isChild)
     return NS_OK;
   
   PRBool okayToPost;
   nsresult res = CheckPost(formURL, actionURL, &okayToPost);
   
   if (NS_SUCCEEDED(res) && !okayToPost)
     *cancelSubmit = PR_TRUE;
   
   return res;
 }
 
 //  nsIWebProgressListener
 NS_IMETHODIMP 
 nsSecureBrowserUIImpl::OnProgressChange(nsIWebProgress* aWebProgress,
                                         nsIRequest* aRequest,
                                         PRInt32 aCurSelfProgress,
                                         PRInt32 aMaxSelfProgress,
                                         PRInt32 aCurTotalProgress,
                                         PRInt32 aMaxTotalProgress)
 {
   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
   return NS_OK;
 }
 
 void nsSecureBrowserUIImpl::ResetStateTracking()
 {
+  nsAutoMonitor lock(mMonitor);
+
   mInfoTooltip.Truncate();
   mDocumentRequestsInProgress = 0;
   mSubRequestsHighSecurity = 0;
   mSubRequestsLowSecurity = 0;
   mSubRequestsBrokenSecurity = 0;
   mSubRequestsNoSecurity = 0;
   if (mTransferringRequests.ops) {
     PL_DHashTableFinish(&mTransferringRequests);
     mTransferringRequests.ops = nsnull;
   }
   PL_DHashTableInit(&mTransferringRequests, &gMapOps, nsnull,
                     sizeof(RequestHashEntry), 16);
 }
 
 nsresult
 nsSecureBrowserUIImpl::EvaluateAndUpdateSecurityState(nsIRequest *aRequest)
 {
   nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
 
-  mNewToplevelSecurityState = nsIWebProgressListener::STATE_IS_INSECURE;
-  mNewToplevelIsEV = PR_FALSE;
+  /* I explicitly ignore the camelCase variable naming style here,
+     I want to make it clear these are temp variables that relate to the 
+     member variables with the same suffix.*/
+
+  PRUint32 temp_NewToplevelSecurityState = nsIWebProgressListener::STATE_IS_INSECURE;
+  PRBool temp_NewToplevelIsEV = PR_FALSE;
+
+  PRBool updateStatus = PR_FALSE;
+  nsCOMPtr<nsISupports> temp_SSLStatus;
+
+  PRBool updateTooltip = PR_FALSE;
+  nsXPIDLString temp_InfoTooltip;
 
   if (channel) {
-    mNewToplevelSecurityState = GetSecurityStateFromChannel(channel);
+    temp_NewToplevelSecurityState = GetSecurityStateFromChannel(channel);
 
     PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
            ("SecureUI:%p: OnStateChange: remember mNewToplevelSecurityState => %x\n", this,
-            mNewToplevelSecurityState));
+            temp_NewToplevelSecurityState));
 
     // Get SSL Status information if possible
     nsCOMPtr<nsISupports> info;
     channel->GetSecurityInfo(getter_AddRefs(info));
     nsCOMPtr<nsISSLStatusProvider> sp = do_QueryInterface(info);
     if (sp) {
       // Ignore result
-      sp->GetSSLStatus(getter_AddRefs(mSSLStatus));
+      updateStatus = PR_TRUE;
+      sp->GetSSLStatus(getter_AddRefs(temp_SSLStatus));
     }
 
     if (info) {
       nsCOMPtr<nsITransportSecurityInfo> secInfo(do_QueryInterface(info));
       if (secInfo) {
-        secInfo->GetShortSecurityDescription(getter_Copies(mInfoTooltip));
+        updateTooltip = PR_TRUE;
+        secInfo->GetShortSecurityDescription(getter_Copies(temp_InfoTooltip));
       }
 
       nsCOMPtr<nsIIdentityInfo> idinfo = do_QueryInterface(info);
       if (idinfo) {
         PRBool aTemp;
-        if (NS_SUCCEEDED(idinfo->GetIsExtendedValidation(&aTemp)))
-          mNewToplevelIsEV = aTemp;
+        if (NS_SUCCEEDED(idinfo->GetIsExtendedValidation(&aTemp))) {
+          temp_NewToplevelIsEV = aTemp;
+        }
       }
     }
   }
 
-  // assume mNewToplevelSecurityState was set in this scope!
+  // assume temp_NewToplevelSecurityState was set in this scope!
   // see code that is directly above
 
-  mNewToplevelSecurityStateKnown = PR_TRUE;
+  {
+    nsAutoMonitor lock(mMonitor);
+    mNewToplevelSecurityStateKnown = PR_TRUE;
+    mNewToplevelSecurityState = temp_NewToplevelSecurityState;
+    mNewToplevelIsEV = temp_NewToplevelIsEV;
+    if (updateStatus) {
+      mSSLStatus = temp_SSLStatus;
+    }
+    if (updateTooltip) {
+      mInfoTooltip = temp_InfoTooltip;
+    }
+  }
+
   return UpdateSecurityState(aRequest);
 }
 
 void
 nsSecureBrowserUIImpl::UpdateSubrequestMembers(nsIRequest *aRequest)
 {
   // For wyciwyg channels in subdocuments we only update our
   // subrequest state members.
   PRUint32 reqState = nsIWebProgressListener::STATE_IS_INSECURE;
   nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
 
   if (channel) {
     reqState = GetSecurityStateFromChannel(channel);
   }
 
+  // the code above this line should run without a lock
+  nsAutoMonitor lock(mMonitor);
+
   if (reqState & STATE_IS_SECURE) {
     if (reqState & STATE_SECURE_LOW || reqState & STATE_SECURE_MED) {
       PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
              ("SecureUI:%p: OnStateChange: subreq LOW\n", this));
       ++mSubRequestsLowSecurity;
     } else {
       PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
              ("SecureUI:%p: OnStateChange: subreq HIGH\n", this));
       ++mSubRequestsHighSecurity;
     }
   } else if (reqState & STATE_IS_BROKEN) {
     PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
            ("SecureUI:%p: OnStateChange: subreq BROKEN\n", this));
     ++mSubRequestsBrokenSecurity;
   } else {
@@ -604,57 +654,66 @@ nsSecureBrowserUIImpl::OnStateChange(nsI
     But this can't really be used. Because in case that document causes a http 302 redirect, 
     the real top level frameset will no longer have that bit.
     
     But we need some way to distinguish top level frames from inner frames.
     
     I saw that the web progress we get delivered has a reference to the toplevel DOM window.
     
     I suggest, we look at all incoming requests.
     If a request is NOT for the toplevel DOM window, we will always treat it as a subdocument request,
     regardless of whether the load flags indicate a top level document.
   */
 
   nsCOMPtr<nsIDOMWindow> windowForProgress;
   aWebProgress->GetDOMWindow(getter_AddRefs(windowForProgress));
 
-  const PRBool isToplevelProgress = (windowForProgress.get() == mWindow.get());
+  nsCOMPtr<nsIDOMWindow> myWindow;
+  PRBool isViewSource;
+
+  {
+    nsAutoMonitor lock(mMonitor);
+    myWindow = mWindow;
+    isViewSource = mIsViewSource;
+  }
+
+  const PRBool isToplevelProgress = (windowForProgress.get() == myWindow.get());
   
 #ifdef PR_LOGGING
   if (windowForProgress)
   {
     if (isToplevelProgress)
     {
       PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
              ("SecureUI:%p: OnStateChange: progress: for toplevel\n", this));
     }
     else
     {
       PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
              ("SecureUI:%p: OnStateChange: progress: for something else\n", this));
     }
   }
   else
   {
       PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
              ("SecureUI:%p: OnStateChange: progress: no window known\n", this));
   }
 #endif
 
   PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
          ("SecureUI:%p: OnStateChange\n", this));
 
-  if (mIsViewSource)
+  if (isViewSource)
     return NS_OK;
 
   if (!aRequest)
   {
     PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
            ("SecureUI:%p: OnStateChange with null request\n", this));
     return NS_ERROR_NULL_POINTER;
   }
 
 #ifdef PR_LOGGING
   if (PR_LOG_TEST(gSecureDocLog, PR_LOG_DEBUG)) {
     nsXPIDLCString reqname;
     aRequest->GetName(reqname);
     PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
            ("SecureUI:%p: %p %p OnStateChange %x %s\n", this, aWebProgress,
@@ -843,66 +902,68 @@ nsSecureBrowserUIImpl::OnStateChange(nsI
   {
     PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
            ("SecureUI:%p: OnStateChange: seeing STOP with security state: %d\n", this,
             GetSecurityStateFromChannel(channel)
             ));
   }
 #endif
 
   if (aProgressStateFlags & STATE_TRANSFERRING
       &&
       aProgressStateFlags & STATE_IS_REQUEST)
   {
     // The listing of a request in mTransferringRequests
     // means, there has already been data transfered.
 
+    nsAutoMonitor lock(mMonitor);
     PL_DHashTableOperate(&mTransferringRequests, aRequest, PL_DHASH_ADD);
-    
     return NS_OK;
   }
 
   PRBool requestHasTransferedData = PR_FALSE;
 
   if (aProgressStateFlags & STATE_STOP
       &&
       aProgressStateFlags & STATE_IS_REQUEST)
   {
+    nsAutoMonitor lock(mMonitor);
     PLDHashEntryHdr *entry = PL_DHashTableOperate(&mTransferringRequests, aRequest, PL_DHASH_LOOKUP);
     if (PL_DHASH_ENTRY_IS_BUSY(entry))
     {
       PL_DHashTableOperate(&mTransferringRequests, aRequest, PL_DHASH_REMOVE);
 
       requestHasTransferedData = PR_TRUE;
     }
   }
 
   if (loadFlags & nsIChannel::LOAD_RETARGETED_DOCUMENT_URI)
   {
     // The original consumer (this) is no longer the target of the load.
     // Ignore any events with this flag, do not allow them to update
     // our secure UI state.
     return NS_OK;
   }
 
   if (aProgressStateFlags & STATE_START
       &&
       aProgressStateFlags & STATE_IS_REQUEST
       &&
       isToplevelProgress
       &&
       loadFlags & nsIChannel::LOAD_DOCUMENT_URI)
   {
+    nsAutoMonitor lock(mMonitor);
     if (!mDocumentRequestsInProgress)
     {
       PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
              ("SecureUI:%p: OnStateChange: start for toplevel document\n", this
               ));
 
       ResetStateTracking();
       mNewToplevelSecurityStateKnown = PR_FALSE;
     }
 
     // By using a counter, this code also works when the toplevel
     // document get's redirected, but the STOP request for the 
     // previous toplevel document has not yet have been received.
 
     PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
@@ -910,47 +971,60 @@ nsSecureBrowserUIImpl::OnStateChange(nsI
             ));
 
     ++mDocumentRequestsInProgress;
     
     return NS_OK;
   }
 
   if (aProgressStateFlags & STATE_STOP
       &&
       aProgressStateFlags & STATE_IS_REQUEST
       &&
       isToplevelProgress
       &&
       loadFlags & nsIChannel::LOAD_DOCUMENT_URI)
   {
-    if (mDocumentRequestsInProgress <= 0)
+    PRInt32 temp_DocumentRequestsInProgress;
+    nsCOMPtr<nsISecurityEventSink> temp_ToplevelEventSink;
+
+    {
+      nsAutoMonitor lock(mMonitor);
+      temp_DocumentRequestsInProgress = mDocumentRequestsInProgress;
+      temp_ToplevelEventSink = mToplevelEventSink;
+    }
+
+    if (temp_DocumentRequestsInProgress <= 0)
     {
       // Ignore stop requests unless a document load is in progress
       // Unfortunately on application start, see some stops without having seen any starts...
       return NS_OK;
     }
 
     PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
            ("SecureUI:%p: OnStateChange: --mDocumentRequestsInProgress\n", this
             ));
 
-    if (!mToplevelEventSink && channel)
+    if (!temp_ToplevelEventSink && channel)
     {
-      ObtainEventSink(channel);
+      ObtainEventSink(channel, temp_ToplevelEventSink);
     }
 
-    --mDocumentRequestsInProgress;
+    {
+      nsAutoMonitor lock(mMonitor);
+      mToplevelEventSink = temp_ToplevelEventSink;
+      --mDocumentRequestsInProgress;
+    }
 
     if (requestHasTransferedData) {
       // Data has been transferred for the single toplevel
       // request. Evaluate the security state.
 
       return EvaluateAndUpdateSecurityState(aRequest);
     }
     
     return NS_OK;
   }
   
   if (aProgressStateFlags & STATE_STOP
       &&
       aProgressStateFlags & STATE_IS_REQUEST)
   {
@@ -963,52 +1037,71 @@ nsSecureBrowserUIImpl::OnStateChange(nsI
 
     if (requestHasTransferedData)
     {  
       UpdateSubrequestMembers(aRequest);
       
       // Care for the following scenario:
       // A new top level document load might have already started,
       // but the security state of the new top level document might not yet been known.
       // 
       // At this point, we are learning about the security state of a sub-document.
       // We must not update the security state based on the sub content,
       // if the new top level state is not yet known.
       //
       // We skip updating the security state in this case.
 
-      if (mNewToplevelSecurityStateKnown)
+      PRBool temp_NewToplevelSecurityStateKnown;
+      {
+        nsAutoMonitor lock(mMonitor);
+        temp_NewToplevelSecurityStateKnown = mNewToplevelSecurityStateKnown;
+      }
+
+      if (temp_NewToplevelSecurityStateKnown)
         return UpdateSecurityState(aRequest);
     }
 
     return NS_OK;
   }
 
   return NS_OK;
 }
 
-void nsSecureBrowserUIImpl::ObtainEventSink(nsIChannel *channel)
+// I'm keeping this as a separate function, in order to simplify the review
+// for bug 412456. We should inline this in a follow up patch.
+void nsSecureBrowserUIImpl::ObtainEventSink(nsIChannel *channel, 
+                                            nsCOMPtr<nsISecurityEventSink> &sink)
 {
-  if (!mToplevelEventSink)
-    NS_QueryNotificationCallbacks(channel, mToplevelEventSink);
+  if (!sink)
+    NS_QueryNotificationCallbacks(channel, sink);
 }
 
 nsresult nsSecureBrowserUIImpl::UpdateSecurityState(nsIRequest* aRequest)
 {
-  lockIconState newSecurityState;
-
-  PRBool showWarning = PR_FALSE;
   lockIconState warnSecurityState = lis_no_security;
+  PRBool showWarning = PR_FALSE;
+
+  UpdateMyFlags(showWarning, warnSecurityState);
+  return TellTheWorld(showWarning, warnSecurityState, aRequest);
+}
+
+// must not fail, by definition, only trivial assignments
+// or string operations are allowed
+void nsSecureBrowserUIImpl::UpdateMyFlags(PRBool &showWarning, lockIconState &warnSecurityState)
+{
+  nsAutoMonitor lock(mMonitor);
+
+  lockIconState newSecurityState;
 
   if (mNewToplevelSecurityState & STATE_IS_SECURE)
   {
     if (mNewToplevelSecurityState & STATE_SECURE_LOW
         ||
         mNewToplevelSecurityState & STATE_SECURE_MED)
     {
       if (mSubRequestsBrokenSecurity
           ||
           mSubRequestsNoSecurity)
       {
         newSecurityState = lis_mixed_security;
       }
       else
       {
@@ -1115,41 +1208,59 @@ nsresult nsSecureBrowserUIImpl::UpdateSe
     if (showWarning)
     {
       warnSecurityState = newSecurityState;
     }
     
     mNotifiedSecurityState = newSecurityState;
 
     if (lis_no_security == newSecurityState)
     {
       mSSLStatus = nsnull;
       mInfoTooltip.Truncate();
     }
   }
 
   mNotifiedToplevelIsEV = mNewToplevelIsEV;
+}
+
+nsresult nsSecureBrowserUIImpl::TellTheWorld(PRBool &showWarning, 
+                                             lockIconState &warnSecurityState, 
+                                             nsIRequest* aRequest)
+{
+  nsCOMPtr<nsISecurityEventSink> temp_ToplevelEventSink;
+  lockIconState temp_NotifiedSecurityState;
+  PRBool temp_NotifiedToplevelIsEV;
+
+  {
+    nsAutoMonitor lock(mMonitor);
+    temp_ToplevelEventSink = mToplevelEventSink;
+    temp_NotifiedSecurityState = mNotifiedSecurityState;
+    temp_NotifiedToplevelIsEV = mNotifiedToplevelIsEV;
+  }
 
-  if (mToplevelEventSink)
+  if (temp_ToplevelEventSink)
   {
     PRUint32 newState = STATE_IS_INSECURE;
-    MapInternalToExternalState(&newState, mNotifiedSecurityState, mNotifiedToplevelIsEV);
+    MapInternalToExternalState(&newState, 
+                               temp_NotifiedSecurityState, 
+                               temp_NotifiedToplevelIsEV);
 
     PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
            ("SecureUI:%p: UpdateSecurityState: calling OnSecurityChange\n", this
             ));
 
-    mToplevelEventSink->OnSecurityChange(aRequest, newState);
+    temp_ToplevelEventSink->OnSecurityChange(aRequest, newState);
   }
   else
   {
     PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
            ("SecureUI:%p: UpdateSecurityState: NO mToplevelEventSink!\n", this
             ));
 
   }
 
   if (showWarning)
   {
     switch (warnSecurityState)
     {
       case lis_no_security:
       case lis_broken_security:
@@ -1166,83 +1277,101 @@ nsresult nsSecureBrowserUIImpl::UpdateSe
 
       case lis_high_security:
         ConfirmEnteringSecure();
         break;
     }
   }
 
   return NS_OK; 
 }
 
 NS_IMETHODIMP
 nsSecureBrowserUIImpl::OnLocationChange(nsIWebProgress* aWebProgress,
                                         nsIRequest* aRequest,
                                         nsIURI* aLocation)
 {
+  PRBool updateIsViewSource = PR_FALSE;
+  PRBool temp_IsViewSource = PR_FALSE;
+  nsCOMPtr<nsIDOMWindow> myWindow;
+
   if (aLocation)
   {
     PRBool vs;
 
     nsresult rv = aLocation->SchemeIs("view-source", &vs);
     NS_ENSURE_SUCCESS(rv, rv);
 
     if (vs) {
       PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
              ("SecureUI:%p: OnLocationChange: view-source\n", this));
     }
 
-    mIsViewSource = vs;
+    updateIsViewSource = PR_TRUE;
+    temp_IsViewSource = vs;
   }
 
-  mCurrentURI = aLocation;
+  {
+    nsAutoMonitor lock(mMonitor);
+    if (updateIsViewSource) {
+      mIsViewSource = temp_IsViewSource;
+    }
+    mCurrentURI = aLocation;
+    myWindow = mWindow;
+  }
 
   // If the location change does not have a corresponding request, then we
   // assume that it does not impact the security state.
   if (!aRequest)
     return NS_OK;
 
   // The location bar has changed, so we must update the security state.  The
   // only concern with doing this here is that a page may transition from being
   // reported as completely secure to being reported as partially secure
   // (mixed).  This may be confusing for users, and it may bother users who
   // like seeing security dialogs.  However, it seems prudent given that page
   // loading may never end in some edge cases (perhaps by a site with malicious
   // intent).
 
   nsCOMPtr<nsIDOMWindow> windowForProgress;
   aWebProgress->GetDOMWindow(getter_AddRefs(windowForProgress));
 
-  if (windowForProgress.get() == mWindow.get()) {
+  if (windowForProgress.get() == myWindow.get()) {
     // For toplevel channels, update the security state right away.
     return EvaluateAndUpdateSecurityState(aRequest);
   }
 
   // For channels in subdocuments we only update our subrequest state members.
   UpdateSubrequestMembers(aRequest);
 
   // Care for the following scenario:
 
   // A new toplevel document load might have already started, but the security
   // state of the new toplevel document might not yet be known.
   // 
   // At this point, we are learning about the security state of a sub-document.
   // We must not update the security state based on the sub content, if the new
   // top level state is not yet known.
   //
   // We skip updating the security state in this case.
 
-  if (mNewToplevelSecurityStateKnown)
+  PRBool temp_NewToplevelSecurityStateKnown;
+  {
+    nsAutoMonitor lock(mMonitor);
+    temp_NewToplevelSecurityStateKnown = mNewToplevelSecurityStateKnown;
+  }
+
+  if (temp_NewToplevelSecurityStateKnown)
     return UpdateSecurityState(aRequest);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSecureBrowserUIImpl::OnStatusChange(nsIWebProgress* aWebProgress,
                                       nsIRequest* aRequest,
                                       nsresult aStatus,
                                       const PRUnichar* aMessage)
 {
   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
   return NS_OK;
 }
 
@@ -1265,30 +1394,31 @@ nsSecureBrowserUIImpl::OnSecurityChange(
     PR_LOG(gSecureDocLog, PR_LOG_DEBUG,
            ("SecureUI:%p: OnSecurityChange: (%x) %s\n", this,
             state, temp.get()));
   }
 #endif
 
   return NS_OK;
 }
 
 // nsISSLStatusProvider methods
 NS_IMETHODIMP
 nsSecureBrowserUIImpl::GetSSLStatus(nsISupports** _result)
 {
   NS_ENSURE_ARG_POINTER(_result);
 
+  nsAutoMonitor lock(mMonitor);
   *_result = mSSLStatus;
   NS_IF_ADDREF(*_result);
 
   return NS_OK;
 }
 
 nsresult
 nsSecureBrowserUIImpl::IsURLHTTPS(nsIURI* aURL, PRBool* value)
 {
   *value = PR_FALSE;
 
   if (!aURL)
     return NS_OK;
 
   return aURL->SchemeIs("https", value);
@@ -1297,34 +1427,41 @@ nsSecureBrowserUIImpl::IsURLHTTPS(nsIURI
 nsresult
 nsSecureBrowserUIImpl::IsURLJavaScript(nsIURI* aURL, PRBool* value)
 {
   *value = PR_FALSE;
 
   if (!aURL)
     return NS_OK;
 
   return aURL->SchemeIs("javascript", value);
 }
 
 void
 nsSecureBrowserUIImpl::GetBundleString(const PRUnichar* name,
                                        nsAString &outString)
 {
-  if (mStringBundle && name) {
+  nsCOMPtr<nsIStringBundle> temp_StringBundle;
+
+  {
+    nsAutoMonitor lock(mMonitor);
+    temp_StringBundle = mStringBundle;
+  }
+
+  if (temp_StringBundle && name) {
     PRUnichar *ptrv = nsnull;
-    if (NS_SUCCEEDED(mStringBundle->GetStringFromName(name,
-                                                      &ptrv)))
+    if (NS_SUCCEEDED(temp_StringBundle->GetStringFromName(name,
+                                                          &ptrv)))
       outString = ptrv;
     else
       outString.SetLength(0);
 
     nsMemory::Free(ptrv);
 
   } else {
     outString.SetLength(0);
   }
 }
 
 nsresult
 nsSecureBrowserUIImpl::CheckPost(nsIURI *formURL, nsIURI *actionURL, PRBool *okayToPost)
 {
   PRBool formSecure, actionSecure, actionJavaScript;
Index: mozilla/security/manager/boot/src/nsSecureBrowserUIImpl.h
===================================================================
RCS file: /cvsroot/mozilla/security/manager/boot/src/nsSecureBrowserUIImpl.h,v
retrieving revision 1.21
diff -u -u -1 -5 -p -r1.21 nsSecureBrowserUIImpl.h
--- mozilla/security/manager/boot/src/nsSecureBrowserUIImpl.h	22 Feb 2008 01:04:05 -0000	1.21
+++ mozilla/security/manager/boot/src/nsSecureBrowserUIImpl.h	29 Feb 2008 19:14:52 -0000
@@ -47,30 +47,31 @@
 #include "nsString.h"
 #include "nsIObserver.h"
 #include "nsIDOMElement.h"
 #include "nsIDOMWindow.h"
 #include "nsIDOMHTMLFormElement.h"
 #include "nsIStringBundle.h"
 #include "nsISecureBrowserUI.h"
 #include "nsIDocShell.h"
 #include "nsIWebProgressListener.h"
 #include "nsIFormSubmitObserver.h"
 #include "nsIURI.h"
 #include "nsISecurityEventSink.h"
 #include "nsWeakReference.h"
 #include "nsISSLStatusProvider.h"
 #include "pldhash.h"
+#include "prmon.h"
 
 class nsITransportSecurityInfo;
 class nsISecurityWarningDialogs;
 class nsIChannel;
 
 #define NS_SECURE_BROWSER_UI_CID \
 { 0xcc75499a, 0x1dd1, 0x11b2, {0x8a, 0x82, 0xca, 0x41, 0x0a, 0xc9, 0x07, 0xb8}}
 
 
 class nsSecureBrowserUIImpl : public nsISecureBrowserUI,
                               public nsIWebProgressListener,
                               public nsIFormSubmitObserver,
                               public nsIObserver,
                               public nsSupportsWeakReference,
                               public nsISSLStatusProvider
@@ -80,30 +81,31 @@ public:
   nsSecureBrowserUIImpl();
   virtual ~nsSecureBrowserUIImpl();
   
   NS_DECL_ISUPPORTS
   NS_DECL_NSIWEBPROGRESSLISTENER
   NS_DECL_NSISECUREBROWSERUI
   
   // nsIObserver
   NS_DECL_NSIOBSERVER
   NS_DECL_NSISSLSTATUSPROVIDER
 
   NS_IMETHOD Notify(nsIDOMHTMLFormElement* formNode, nsIDOMWindowInternal* window,
                     nsIURI *actionURL, PRBool* cancelSubmit);
   
 protected:
+  PRMonitor *mMonitor;
   
   nsCOMPtr<nsIDOMWindow> mWindow;
   nsCOMPtr<nsIStringBundle> mStringBundle;
   nsCOMPtr<nsIURI> mCurrentURI;
   nsCOMPtr<nsISecurityEventSink> mToplevelEventSink;
   
   enum lockIconState {
     lis_no_security,
     lis_broken_security,
     lis_mixed_security,
     lis_low_security,
     lis_high_security
   };
 
   lockIconState mNotifiedSecurityState;
@@ -111,36 +113,42 @@ protected:
 
   void ResetStateTracking();
   PRUint32 mNewToplevelSecurityState;
   PRPackedBool mNewToplevelIsEV;
   PRPackedBool mNewToplevelSecurityStateKnown;
   PRPackedBool mIsViewSource;
 
   nsXPIDLString mInfoTooltip;
   PRInt32 mDocumentRequestsInProgress;
   PRInt32 mSubRequestsInProgress;
   PRInt32 mSubRequestsHighSecurity;
   PRInt32 mSubRequestsLowSecurity;
   PRInt32 mSubRequestsBrokenSecurity;
   PRInt32 mSubRequestsNoSecurity;
 
-  nsresult MapInternalToExternalState(PRUint32* aState, lockIconState lock, PRBool ev);
+  static nsresult MapInternalToExternalState(PRUint32* aState, lockIconState lock, PRBool ev);
   nsresult UpdateSecurityState(nsIRequest* aRequest);
+  void UpdateMyFlags(PRBool &showWarning, lockIconState &warnSecurityState);
+  nsresult TellTheWorld(PRBool &showWarning, 
+                        lockIconState &warnSecurityState, 
+                        nsIRequest* aRequest);
+
   nsresult EvaluateAndUpdateSecurityState(nsIRequest *aRequest);
   void UpdateSubrequestMembers(nsIRequest *aRequest);
 
-  void ObtainEventSink(nsIChannel *channel);
+  void ObtainEventSink(nsIChannel *channel, 
+                       nsCOMPtr<nsISecurityEventSink> &sink);
   
   nsCOMPtr<nsISupports> mSSLStatus;
 
   void GetBundleString(const PRUnichar* name, nsAString &outString);
   
   nsresult CheckPost(nsIURI *formURI, nsIURI *actionURL, PRBool *okayToPost);
   nsresult IsURLHTTPS(nsIURI* aURL, PRBool *value);
   nsresult IsURLJavaScript(nsIURI* aURL, PRBool *value);
 
   PRBool ConfirmEnteringSecure();
   PRBool ConfirmEnteringWeak();
   PRBool ConfirmLeavingSecure();
   PRBool ConfirmMixedMode();
   PRBool ConfirmPostToInsecure();
   PRBool ConfirmPostToInsecureFromSecure();
