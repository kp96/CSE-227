Index: mozilla/security/manager/ssl/src/nsCrypto.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsCrypto.cpp,v
retrieving revision 1.44
diff -u -u -r1.44 nsCrypto.cpp
--- mozilla/security/manager/ssl/src/nsCrypto.cpp	6 Mar 2004 17:22:13 -0000	1.44
+++ mozilla/security/manager/ssl/src/nsCrypto.cpp	27 Jul 2004 20:28:12 -0000
@@ -2003,7 +2003,7 @@
            node = CERT_LIST_NEXT(node), i++) {
         derCerts[i] = node->cert->derCert;
       }
-      CERT_ImportCAChain(derCerts, numCAs, certUsageUserCertImport);
+      nsNSSCertificateDB::ImportValidCACerts(numCAs, derCerts, ctx);
       nsMemory::Free(derCerts);
     }
     
Index: mozilla/security/manager/ssl/src/nsNSSCertificateDB.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSCertificateDB.cpp,v
retrieving revision 1.11
diff -u -u -r1.11 nsNSSCertificateDB.cpp
--- mozilla/security/manager/ssl/src/nsNSSCertificateDB.cpp	26 Feb 2004 04:07:23 -0000	1.11
+++ mozilla/security/manager/ssl/src/nsNSSCertificateDB.cpp	27 Jul 2004 20:28:12 -0000
@@ -73,6 +73,7 @@
 #include "nsNSSCleaner.h"
 NSSCleanupAutoPtrClass(CERTCertificate, CERT_DestroyCertificate)
 NSSCleanupAutoPtrClass(CERTCertList, CERT_DestroyCertList)
+NSSCleanupAutoPtrClass(CERTCertificateList, CERT_DestroyCertificateList)
 
 static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
 
@@ -345,7 +346,7 @@
                                       nsnull, PR_FALSE, PR_TRUE);
   }
   if (!tmpCert) {
-    NS_ASSERTION(0,"Couldn't create cert from DER blob\n");
+    NS_ERROR("Couldn't create cert from DER blob\n");
     return NS_ERROR_FAILURE;
   }
 
@@ -387,15 +388,23 @@
   if (srv != SECSuccess)
     return NS_ERROR_FAILURE;
 
-  // Now it's time to add the rest of the certs we just downloaded.
-  // Since we didn't prompt the user about any of these certs, we
-  // won't set any trust bits for them.
-  nsNSSCertTrust defaultTrust;
-  defaultTrust.SetValidCA();
-  defaultTrust.AddCATrust(0,0,0);
+  // Import additional delivered certificates that can be verified.
+
+  // build a CertList for filtering
+  CERTCertList *certList = CERT_NewCertList();
+  if (certList == NULL) {
+    return NS_ERROR_FAILURE;
+  }
+
+  CERTCertListCleaner listCleaner(certList);
+
+  // get all remaining certs into temp store
+
   for (PRUint32 i=0; i<numCerts; i++) {
-    if (i == selCertIndex)
+    if (i == selCertIndex) {
+      // we already processed that one
       continue;
+    }
 
     certToShow = do_QueryElementAt(x509Certs, i);
     certToShow->GetRawDER(&der.len, (PRUint8 **)&der.data);
@@ -407,13 +416,11 @@
       NS_ASSERTION(0, "Couldn't create temp cert from DER blob\n");
       continue;  // Let's try to import the rest of 'em
     }
-    nickname.Adopt(CERT_MakeCANickname(tmpCert2));
-    CERT_AddTempCertToPerm(tmpCert2, NS_CONST_CAST(char*,nickname.get()), 
-                           defaultTrust.GetTrust());
-    CERT_DestroyCertificate(tmpCert2);
+    
+    CERT_AddCertToListTail(certList, tmpCert2);
   }
-  
-  return NS_OK;  
+
+  return ImportValidCACertsInList(certList, ctx);
 }
 
 /*
@@ -484,8 +491,13 @@
   nsNSSShutDownPreventionLock locker;
   SECStatus srv = SECFailure;
   nsresult nsrv = NS_OK;
-  CERTCertificate * cert;
-  SECItem **rawCerts;
+  CERTCertDBHandle *certdb;
+  CERTCertificate **certArray = NULL;
+  CERTCertList *certList = NULL;
+  CERTCertListNode *node;
+  PRTime now;
+  SECCertUsage certusage;
+  SECItem **rawArray;
   int numcerts;
   int i;
  
@@ -498,35 +510,100 @@
     PORT_FreeArena(arena, PR_FALSE);
     return NS_ERROR_FAILURE;
   }
-  cert = CERT_NewTempCertificate(CERT_GetDefaultCertDB(), certCollection->rawCerts,
-                          (char *)NULL, PR_FALSE, PR_TRUE);
-  if (!cert) {
+
+  certdb = CERT_GetDefaultCertDB();
+  certusage = certUsageEmailRecipient;
+
+  numcerts = certCollection->numcerts;
+
+  rawArray = (SECItem **) PORT_Alloc(sizeof(SECItem *) * numcerts);
+  if ( !rawArray ) {
     nsrv = NS_ERROR_FAILURE;
     goto loser;
   }
-  numcerts = certCollection->numcerts;
-  rawCerts = (SECItem **) PORT_Alloc(sizeof(SECItem *) * numcerts);
-  if ( !rawCerts ) {
+
+  for (i=0; i < numcerts; i++) {
+    rawArray[i] = &certCollection->rawCerts[i];
+  }
+
+  srv = CERT_ImportCerts(certdb, certusage, numcerts, rawArray, 
+                         &certArray, PR_FALSE, PR_FALSE, NULL);
+
+  PORT_Free(rawArray);
+  rawArray = NULL;
+
+  if (srv != SECSuccess) {
     nsrv = NS_ERROR_FAILURE;
     goto loser;
   }
 
-  for ( i = 0; i < numcerts; i++ ) {
-    rawCerts[i] = &certCollection->rawCerts[i];
+  // build a CertList for filtering
+  certList = CERT_NewCertList();
+  if (certList == NULL) {
+    nsrv = NS_ERROR_FAILURE;
+    goto loser;
   }
- 
-  srv = CERT_ImportCerts(CERT_GetDefaultCertDB(), certUsageEmailSigner,
-             numcerts, rawCerts, NULL, PR_TRUE, PR_FALSE,
-             NULL);
-  if ( srv != SECSuccess ) {
+  for (i=0; i < numcerts; i++) {
+    CERTCertificate *cert = certArray[i];
+    if (cert)
+      cert = CERT_DupCertificate(cert);
+    if (cert)
+      CERT_AddCertToListTail(certList, cert);
+  }
+
+  /* filter out the certs we don't want */
+  srv = CERT_FilterCertListByUsage(certList, certusage, PR_FALSE);
+  if (srv != SECSuccess) {
     nsrv = NS_ERROR_FAILURE;
     goto loser;
   }
-  srv = CERT_SaveSMimeProfile(cert, NULL, NULL);
-  PORT_Free(rawCerts);
+
+  /* go down the remaining list of certs and verify that they have
+   * valid chains, then import them.
+   */
+  now = PR_Now();
+  for (node = CERT_LIST_HEAD(certList);
+       !CERT_LIST_END(node,certList);
+       node = CERT_LIST_NEXT(node)) {
+    if (CERT_VerifyCert(certdb, node->cert, 
+        PR_TRUE, certusage, now, ctx, NULL) != SECSuccess) {
+      continue;
+    }
+
+    CERTCertificateList *certChain = CERT_CertChainFromCert(node->cert, certusage, PR_FALSE);
+    if (!certChain) {
+      continue;
+    }
+
+    CERTCertificateListCleaner chainCleaner(certChain);
+
+    /*
+     * CertChain returns an array of SECItems, import expects an array of
+     * SECItem pointers. Create the SECItem Pointers from the array of
+     * SECItems.
+     */
+    rawArray = (SECItem **) PORT_Alloc(certChain->len * sizeof(SECItem *));
+    if (!rawArray) {
+      continue;
+    }
+    for (i=0; i < certChain->len; i++) {
+      rawArray[i] = &certChain->certs[i];
+    }
+    CERT_ImportCerts(certdb, certusage, certChain->len, 
+                            rawArray,  NULL, PR_TRUE, PR_FALSE, NULL);
+
+    CERT_SaveSMimeProfile(node->cert, NULL, NULL);
+
+    PORT_Free(rawArray);
+  }
+
 loser:
-  if (cert)
-    CERT_DestroyCertificate(cert);
+  if (certArray) {
+    CERT_DestroyCertArray(certArray, numcerts);
+  }
+  if (certList) {
+    CERT_DestroyCertList(certList);
+  }
   if (arena) 
     PORT_FreeArena(arena, PR_TRUE);
   return nsrv;
@@ -598,6 +675,109 @@
   return nsrv;
 }
 
+nsresult
+nsNSSCertificateDB::ImportValidCACerts(int numCACerts, SECItem *CACerts, nsIInterfaceRequestor *ctx)
+{
+  CERTCertList *certList = NULL;
+  SECItem **rawArray;
+
+  // build a CertList for filtering
+  certList = CERT_NewCertList();
+  if (certList == NULL) {
+    return NS_ERROR_FAILURE;
+  }
+
+  CERTCertListCleaner listCleaner(certList);
+
+  // get all certs into temp store
+  SECStatus srv = SECFailure;
+  CERTCertificate **certArray = NULL;
+
+  rawArray = (SECItem **) PORT_Alloc(sizeof(SECItem *) * numCACerts);
+  if ( !rawArray ) {
+    return NS_ERROR_FAILURE;
+  }
+
+  for (int i=0; i < numCACerts; i++) {
+    rawArray[i] = &CACerts[i];
+  }
+
+  srv = CERT_ImportCerts(CERT_GetDefaultCertDB(), certUsageAnyCA, numCACerts, rawArray, 
+                         &certArray, PR_FALSE, PR_TRUE, NULL);
+
+  PORT_Free(rawArray);
+  rawArray = NULL;
+
+  if (srv != SECSuccess) {
+    return NS_ERROR_FAILURE;
+  }
+
+  for (int i2=0; i2 < numCACerts; i2++) {
+    CERTCertificate *cacert = certArray[i2];
+    if (cacert)
+      cacert = CERT_DupCertificate(cacert);
+    if (cacert)
+      CERT_AddCertToListTail(certList, cacert);
+  }
+
+  CERT_DestroyCertArray(certArray, numCACerts);
+
+  return ImportValidCACertsInList(certList, ctx);
+}
+
+nsresult
+nsNSSCertificateDB::ImportValidCACertsInList(CERTCertList *certList, nsIInterfaceRequestor *ctx)
+{
+  SECItem **rawArray;
+
+  /* filter out the certs we don't want */
+  SECStatus srv = CERT_FilterCertListByUsage(certList, certUsageAnyCA, PR_TRUE);
+  if (srv != SECSuccess) {
+    return NS_ERROR_FAILURE;
+  }
+
+  /* go down the remaining list of certs and verify that they have
+   * valid chains, if yes, then import.
+   */
+  PRTime now = PR_Now();
+  CERTCertListNode *node;
+  for (node = CERT_LIST_HEAD(certList);
+       !CERT_LIST_END(node,certList);
+       node = CERT_LIST_NEXT(node)) {
+    if (CERT_VerifyCert(CERT_GetDefaultCertDB(), node->cert, 
+        PR_TRUE, certUsageVerifyCA, now, ctx, NULL) != SECSuccess) {
+      continue;
+    }
+
+    CERTCertificateList *certChain = CERT_CertChainFromCert(node->cert, certUsageAnyCA, PR_FALSE);
+    if (!certChain) {
+      continue;
+    }
+
+    CERTCertificateListCleaner chainCleaner(certChain);
+
+    /*
+     * CertChain returns an array of SECItems, import expects an array of
+     * SECItem pointers. Create the SECItem Pointers from the array of
+     * SECItems.
+     */
+    rawArray = (SECItem **) PORT_Alloc(certChain->len * sizeof(SECItem *));
+    if (!rawArray) {
+      continue;
+    }
+    for (int i=0; i < certChain->len; i++) {
+      rawArray[i] = &certChain->certs[i];
+    }
+    CERT_ImportCerts(CERT_GetDefaultCertDB(), certUsageAnyCA, certChain->len, 
+                            rawArray,  NULL, PR_TRUE, PR_TRUE, NULL);
+
+    PORT_Free(rawArray);
+  }
+  
+  return NS_OK;
+}
+
+
 NS_IMETHODIMP 
 nsNSSCertificateDB::ImportUserCertificate(PRUint8 *data, PRUint32 length, nsIInterfaceRequestor *ctx)
 {
@@ -650,13 +830,13 @@
     goto loser;
   }
   PK11_FreeSlot(slot);
-  numCACerts = collectArgs->numcerts - 1;
 
+  rv = NS_OK;
+
+  numCACerts = collectArgs->numcerts - 1;
   if (numCACerts) {
     CACerts = collectArgs->rawCerts+1;
-    if ( ! CERT_ImportCAChain(CACerts, numCACerts, certUsageUserCertImport) ) {
-      rv = NS_OK;
-    }
+    rv = ImportValidCACerts(numCACerts, CACerts, ctx);
   }
   
 loser:
Index: mozilla/security/manager/ssl/src/nsNSSCertificateDB.h
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSCertificateDB.h,v
retrieving revision 1.4
diff -u -u -r1.4 nsNSSCertificateDB.h
--- mozilla/security/manager/ssl/src/nsNSSCertificateDB.h	20 Oct 2003 15:00:17 -0000	1.4
+++ mozilla/security/manager/ssl/src/nsNSSCertificateDB.h	27 Jul 2004 20:28:12 -0000
@@ -58,8 +58,14 @@
   static char *
   default_nickname(CERTCertificate *cert, nsIInterfaceRequestor* ctx);
 
+  static nsresult 
+  ImportValidCACerts(int numCACerts, SECItem *CACerts, nsIInterfaceRequestor *ctx);
+
 private:
 
+  static nsresult
+  ImportValidCACertsInList(CERTCertList *certList, nsIInterfaceRequestor *ctx);
+
   void getCertNames(CERTCertList *certList,
                     PRUint32      type, 
                     PRUint32     *_count,
Index: mozilla/security/nss/lib/certdb/certdb.c
===================================================================
RCS file: /cvsroot/mozilla/security/nss/lib/certdb/certdb.c,v
retrieving revision 1.61.4.1
diff -u -u -r1.61.4.1 certdb.c
--- mozilla/security/nss/lib/certdb/certdb.c	4 Jun 2004 14:51:10 -0000	1.61.4.1
+++ mozilla/security/nss/lib/certdb/certdb.c	27 Jul 2004 20:28:16 -0000
@@ -1136,6 +1136,7 @@
 	    requiredCertType = NS_CERT_TYPE_OBJECT_SIGNING_CA;
 	    break;
 	  case certUsageAnyCA:
+	  case certUsageVerifyCA:
 	  case certUsageStatusResponder:
 	    requiredKeyUsage = KU_KEY_CERT_SIGN;
 	    requiredCertType = NS_CERT_TYPE_OBJECT_SIGNING_CA |
