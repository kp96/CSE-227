Index: security/manager/boot/src/nsEntropyCollector.cpp
===================================================================
RCS file: /cvs/mozilla/security/manager/boot/src/nsEntropyCollector.cpp,v
retrieving revision 1.3
diff -p -u -1 -2 -r1.3 nsEntropyCollector.cpp
--- security/manager/boot/src/nsEntropyCollector.cpp	8 Jan 2003 22:45:14 -0000	1.3
+++ security/manager/boot/src/nsEntropyCollector.cpp	31 Jul 2006 23:17:54 -0000
@@ -35,24 +35,30 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "prlog.h"
 #include "nsEntropyCollector.h"
 #include "nsMemory.h"
 
 nsEntropyCollector::nsEntropyCollector()
 :mBytesCollected(0), mWritePointer(mEntropyCache)
 {
+  // We could use the uninitialized memory in mEntropyCache as initial
+  // random data, but that means (if any entropy is collected before NSS
+  // initialization and then forwarded) that we'll get warnings from
+  // tools like valgrind for every later operation that depends on the
+  // entropy.
+  memset(mEntropyCache, 0, sizeof(mEntropyCache));
 }
 
 nsEntropyCollector::~nsEntropyCollector()
 {
 }
 
 NS_IMPL_THREADSAFE_ISUPPORTS2(nsEntropyCollector,
                               nsIEntropyCollector,
                               nsIBufEntropyCollector)
 
 NS_IMETHODIMP
 nsEntropyCollector::RandomUpdate(void *new_entropy, PRInt32 bufLen)
@@ -75,25 +81,24 @@ nsEntropyCollector::RandomUpdate(void *n
       // this loop will iterate at most twice.
       while (bytes_wanted > 0) {
 
         // how many bytes to end of cyclic buffer?
         const PRInt32 space_to_end = PastEndPointer - mWritePointer;
 
         // how many bytes can we copy, not reaching the end of the buffer?
         const PRInt32 this_time = PR_MIN(space_to_end, bytes_wanted);
 
         // copy at most to the end of the cyclic buffer
         for (PRInt32 i = 0; i < this_time; ++i) {
 
-          // accept the fact that we use our buffer's random uninitialized content
           unsigned int old = *mWritePointer;
 
           // combine new and old value already stored in buffer
           // this logic comes from PSM 1
           *mWritePointer++ = ((old << 1) | (old >> 7)) ^ *InputPointer++;
         }
 
         PR_ASSERT(mWritePointer <= PastEndPointer);
         PR_ASSERT(mWritePointer >= mEntropyCache);
 
         // have we arrived at the end of the buffer?
         if (PastEndPointer == mWritePointer) {
