{"bug_id":119646,"commitHash":"4756b71","commit_info":{"sha":"4756b7169cc8c42ad32ab030c3137ddfd702d119","commit":{"author":{"name":"mstoltz%netscape.com","email":"mstoltz%netscape.com","date":"2002-02-13T04:20:46Z"},"committer":{"name":"mstoltz%netscape.com","email":"mstoltz%netscape.com","date":"2002-02-13T04:20:46Z"},"message":"Bug 119646 - Rewrite of the security manager policy database for improved\nperformance. r=jst, sr=jband.","tree":{"sha":"2ad786a97694fa241a5c5e1f25cfddb9681f1f8a","url":"https://api.github.com/repos/mozilla/gecko-dev/git/trees/2ad786a97694fa241a5c5e1f25cfddb9681f1f8a"},"url":"https://api.github.com/repos/mozilla/gecko-dev/git/commits/4756b7169cc8c42ad32ab030c3137ddfd702d119","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/mozilla/gecko-dev/commits/4756b7169cc8c42ad32ab030c3137ddfd702d119","html_url":"https://github.com/mozilla/gecko-dev/commit/4756b7169cc8c42ad32ab030c3137ddfd702d119","comments_url":"https://api.github.com/repos/mozilla/gecko-dev/commits/4756b7169cc8c42ad32ab030c3137ddfd702d119/comments","author":null,"committer":null,"parents":[{"sha":"8f9d5fb950157c13582341dff45367ccbfd32f8b","url":"https://api.github.com/repos/mozilla/gecko-dev/commits/8f9d5fb950157c13582341dff45367ccbfd32f8b","html_url":"https://github.com/mozilla/gecko-dev/commit/8f9d5fb950157c13582341dff45367ccbfd32f8b"}],"stats":{"total":1745,"additions":1104,"deletions":641},"files":[{"sha":"521281c3095bb41320f496ec59b9fc660ed5f572","filename":"caps/idl/nsIScriptSecurityManager.idl","status":"modified","additions":8,"deletions":2,"changes":10,"blob_url":"https://github.com/mozilla/gecko-dev/blob/4756b7169cc8c42ad32ab030c3137ddfd702d119/caps/idl/nsIScriptSecurityManager.idl","raw_url":"https://github.com/mozilla/gecko-dev/raw/4756b7169cc8c42ad32ab030c3137ddfd702d119/caps/idl/nsIScriptSecurityManager.idl","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/caps/idl/nsIScriptSecurityManager.idl?ref=4756b7169cc8c42ad32ab030c3137ddfd702d119","patch":"@@ -51,7 +51,7 @@ interface nsIScriptSecurityManager : nsIXPCSecurityManager\n     [noscript] void checkPropertyAccess(in JSContextPtr aJSContext,\n                                         in JSObjectPtr aJSObject,\n                                         in string aClassName,\n-                                        in string aProperty,\n+                                        in JSVal aProperty,\n                                         in PRUint32 aAction);\n \n     /**\n@@ -60,7 +60,7 @@ interface nsIScriptSecurityManager : nsIXPCSecurityManager\n     [noscript] void checkConnect(in JSContextPtr aJSContext,\n                                  in nsIURI aTargetURI,\n                                  in string aClassName,\n-                                 in string aPropertyName);\n+                                 in string aProperty);\n \n     /**\n      * Check that the script currently running in context \"cx\" can load \"uri\".\n@@ -197,6 +197,12 @@ interface nsIScriptSecurityManager : nsIXPCSecurityManager\n      */\n     [noscript] nsIPrincipal getObjectPrincipal(in JSContextPtr cx,\n                                                in JSObjectPtr obj);\n+\n+    /**\n+     * Forget all currently stored security policies and reread from prefs.\n+     * This must be called after any capability.policy prefs have changed.\n+     */ \n+    void reloadSecurityPolicies();\n };\n \n %{C++"},{"sha":"0da0a2358950ecd4800b706ed75adc8e71c2a6d1","filename":"caps/include/nsScriptSecurityManager.h","status":"modified","additions":203,"deletions":25,"changes":228,"blob_url":"https://github.com/mozilla/gecko-dev/blob/4756b7169cc8c42ad32ab030c3137ddfd702d119/caps/include/nsScriptSecurityManager.h","raw_url":"https://github.com/mozilla/gecko-dev/raw/4756b7169cc8c42ad32ab030c3137ddfd702d119/caps/include/nsScriptSecurityManager.h","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/caps/include/nsScriptSecurityManager.h?ref=4756b7169cc8c42ad32ab030c3137ddfd702d119","patch":"@@ -20,7 +20,8 @@\n  * the Initial Developer. All Rights Reserved.\n  *\n  * Contributor(s):\n- *\n+ *  Norris Boyd  <nboyd@atg.com>\n+ *  Mitch Stoltz <mstoltz@netscape.com>\n  *\n  * Alternatively, the contents of this file may be used under the terms of\n  * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n@@ -50,12 +51,13 @@\n #include \"nsISecurityPref.h\"\n #include \"nsIJSContextStack.h\"\n #include \"nsIObserver.h\"\n-#include \"nsWeakPtr.h\"\n+#include \"pldhash.h\"\n \n class nsIDocShell;\n class nsString;\n class nsIClassInfo;\n class nsSystemPrincipal;\n+struct ClassPolicy;\n \n /////////////////////\n // nsIPrincipalKey //\n@@ -92,15 +94,172 @@ class nsIPrincipalKey : public nsHashKey {\n     nsIPrincipal* mKey;\n };\n \n+////////////////////\n+// Policy Storage //\n+////////////////////\n+\n+// Property Policy\n+union SecurityLevel\n+{\n+    long     level;\n+    char*    capability;\n+};\n+\n+// Security levels\n+// These values all have the low bit set (except UNDEFINED_ACCESS)\n+// to distinguish them from pointer values, because no pointer\n+// to allocated memory ever has the low bit set. A SecurityLevel\n+// contains either one of these constants or a pointer to a string\n+// representing the name of a capability.\n+\n+#define SCRIPT_SECURITY_UNDEFINED_ACCESS 0\n+#define SCRIPT_SECURITY_ACCESS_IS_SET_BIT 1\n+#define SCRIPT_SECURITY_NO_ACCESS \\\n+  ((1 << 0) | SCRIPT_SECURITY_ACCESS_IS_SET_BIT)\n+#define SCRIPT_SECURITY_SAME_ORIGIN_ACCESS \\\n+  ((1 << 1) | SCRIPT_SECURITY_ACCESS_IS_SET_BIT)\n+#define SCRIPT_SECURITY_ALL_ACCESS \\\n+  ((1 << 2) | SCRIPT_SECURITY_ACCESS_IS_SET_BIT)\n+\n+#define SECURITY_ACCESS_LEVEL_FLAG(_sl) \\\n+           ((_sl.level == 0) || \\\n+            (_sl.level & SCRIPT_SECURITY_ACCESS_IS_SET_BIT))\n+\n+\n+struct PropertyPolicy : public PLDHashEntryHdr\n+{\n+    jsval          key;  // property name as jsval\n+    SecurityLevel  mGet;\n+    SecurityLevel  mSet;\n+};\n+\n+PR_STATIC_CALLBACK(void)\n+InitPropertyPolicyEntry(PLDHashTable *table,\n+                     PLDHashEntryHdr *entry,\n+                     const void *key)\n+{\n+    PropertyPolicy* pp = (PropertyPolicy*)entry;\n+    pp->key = (jsval)key;\n+    pp->mGet.level = SCRIPT_SECURITY_UNDEFINED_ACCESS;\n+    pp->mSet.level = SCRIPT_SECURITY_UNDEFINED_ACCESS;\n+}\n+\n+PR_STATIC_CALLBACK(void)\n+ClearPropertyPolicyEntry(PLDHashTable *table, PLDHashEntryHdr *entry)\n+{\n+    PropertyPolicy* pp = (PropertyPolicy*)entry;\n+    pp->key = JSVAL_VOID;\n+}\n+\n+// Class Policy\n+#define NO_POLICY_FOR_CLASS (ClassPolicy*)1\n+\n+struct ClassPolicy : public PLDHashEntryHdr\n+{\n+    char*  key;\n+    PLDHashTable mPolicy;\n+    ClassPolicy* mDefault;\n+    ClassPolicy* mWildcard;\n+};\n+\n+PR_STATIC_CALLBACK(PRBool)\n+MatchClassPolicyKey(PLDHashTable *table,\n+                    const PLDHashEntryHdr *entry,\n+                    const void *key)\n+{\n+    ClassPolicy* cp = (ClassPolicy *)entry;\n+    return (cp->key == (char*)key) || (PL_strcmp(cp->key, (char*)key) == 0);\n+}\n+\n+PR_STATIC_CALLBACK(void)\n+ClearClassPolicyEntry(PLDHashTable *table, PLDHashEntryHdr *entry)\n+{\n+    ClassPolicy* cp = (ClassPolicy *)entry;\n+    if (cp->key)\n+    {\n+        PL_strfree(cp->key);\n+        cp->key = nsnull;\n+    }\n+    PL_DHashTableFinish(&cp->mPolicy);\n+}\n+\n+PR_STATIC_CALLBACK(void)\n+InitClassPolicyEntry(PLDHashTable *table,\n+                     PLDHashEntryHdr *entry,\n+                     const void *key)\n+{\n+    static PLDHashTableOps classPolicyOps =\n+    {\n+        PL_DHashAllocTable,\n+        PL_DHashFreeTable,\n+        PL_DHashGetKeyStub,\n+        PL_DHashVoidPtrKeyStub,\n+        PL_DHashMatchEntryStub,\n+        PL_DHashMoveEntryStub,\n+        ClearPropertyPolicyEntry,\n+        PL_DHashFinalizeStub,\n+        InitPropertyPolicyEntry\n+    };\n+\n+    ClassPolicy* cp = (ClassPolicy*)entry;\n+    cp->key = PL_strdup((const char*)key);\n+    PL_DHashTableInit(&cp->mPolicy, &classPolicyOps, nsnull,\n+                      sizeof(PropertyPolicy), 16);\n+}\n+\n+// Domain Policy\n+class DomainPolicy : public PLDHashTable\n+{\n+public:\n+    DomainPolicy() : mRefCount(0)\n+    {\n+        static PLDHashTableOps domainPolicyOps =\n+        {\n+            PL_DHashAllocTable,\n+            PL_DHashFreeTable,\n+            PL_DHashGetKeyStub,\n+            PL_DHashStringKey,\n+            MatchClassPolicyKey,\n+            PL_DHashMoveEntryStub,\n+            ClearClassPolicyEntry,\n+            PL_DHashFinalizeStub,\n+            InitClassPolicyEntry\n+        };\n+\n+        PL_DHashTableInit(this, &domainPolicyOps, nsnull,\n+                          sizeof(ClassPolicy), 16);\n+    }\n+\n+    void Hold()\n+    {\n+        mRefCount++;\n+    }\n+\n+    void Drop()\n+    {\n+        if (--mRefCount == 0)\n+            delete this;\n+    }\n+\n+private:\n+    PRUint32 mRefCount;\n+};\n+\n+/////////////////////////////\n+// nsScriptSecurityManager //\n+/////////////////////////////\n #define NS_SCRIPTSECURITYMANAGER_CID \\\n { 0x7ee2a4c0, 0x4b93, 0x17d3, \\\n { 0xba, 0x18, 0x00, 0x60, 0xb0, 0xf1, 0x99, 0xa2 }}\n \n-class nsScriptSecurityManager : public nsIScriptSecurityManager, public nsIObserver\n+class nsScriptSecurityManager : public nsIScriptSecurityManager,\n+                                public nsIObserver\n {\n public:\n     nsScriptSecurityManager();\n     virtual ~nsScriptSecurityManager();\n+\n+    static void Shutdown();\n     \n     NS_DEFINE_STATIC_CID_ACCESSOR(NS_SCRIPTSECURITYMANAGER_CID)\n         \n@@ -115,11 +274,19 @@ class nsScriptSecurityManager : public nsIScriptSecurityManager, public nsIObser\n     static nsSystemPrincipal*\n     SystemPrincipalSingletonConstructor();\n \n-    JSContext* GetCurrentContextQuick();\n+    JSContext* GetCurrentJSContext();\n+\n+    JSContext* GetSafeJSContext();\n \n private:\n \n-    static PRBool IsDOMClass(nsIClassInfo* aClassInfo);\n+    static JSBool\n+    CheckJSFunctionCallerAccess(JSContext *cx, JSObject *obj,\n+                                jsval id, JSAccessMode mode,\n+                                jsval *vp);\n+\n+    static PRBool\n+    IsDOMClass(nsIClassInfo* aClassInfo);\n \n     nsresult\n     GetBaseURIScheme(nsIURI* aURI, char** aScheme);\n@@ -131,12 +298,13 @@ class nsScriptSecurityManager : public nsIScriptSecurityManager, public nsIObser\n     GetRootDocShell(JSContext* cx, nsIDocShell **result);\n \n     nsresult\n-    CheckPropertyAccessImpl(PRUint32 aAction, nsIXPCNativeCallContext* aCallContext,\n-                            JSContext* aJSContext, JSObject* aJSObject,\n+    CheckPropertyAccessImpl(PRUint32 aAction,\n+                            nsIXPCNativeCallContext* aCallContext,\n+                            JSContext* cx, JSObject* aJSObject,\n                             nsISupports* aObj, nsIURI* aTargetURI,\n                             nsIClassInfo* aClassInfo,\n-                            jsval aName, const char* aClassName, \n-                            const char* aProperty, void** aPolicy);\n+                            const char* aClassName, jsval aProperty,\n+                            void** aCachedClassPolicy);\n \n     nsresult\n     CheckSameOrigin(JSContext* aCx, nsIPrincipal* aSubject, \n@@ -148,18 +316,13 @@ class nsScriptSecurityManager : public nsIScriptSecurityManager, public nsIObser\n                      const char* aClassName, const char* aProperty,\n                      PRUint32 aAction, nsCString &capability, void** aPolicy);\n \n-    static nsresult\n-    TryToGetPref(nsISecurityPref* aSecurityPref,\n-                 nsCString &aPrefName,\n-                 const char* aClassName,\n-                 const char* aPropertyName,\n-                 PRInt32 aClassPolicy,\n-                 PRUint32 aAction, char** result);\n-\n     nsresult\n-    GetPolicy(nsIPrincipal* principal,\n-              const char* aClassName, const char* aPropertyName,\n-              PRInt32 aClassPolicy, PRUint32 aAction, char** result);\n+    GetClassPolicy(nsIPrincipal* principal, const char* aClassName,\n+                   ClassPolicy** result);\n+\n+    SecurityLevel\n+    GetPropertyPolicy(jsval aProperty, ClassPolicy* aClassPolicy,\n+                      PRUint32 aAction);\n \n     nsresult\n     CreateCodebasePrincipal(nsIURI* aURI, nsIPrincipal** result);\n@@ -196,29 +359,44 @@ class nsScriptSecurityManager : public nsIScriptSecurityManager, public nsIObser\n     PrincipalPrefNames(const char* pref, char** grantedPref, char** deniedPref);\n \n     nsresult\n-    InitPolicies(PRUint32 prefCount, const char** prefNames,\n-                 nsISecurityPref* securityPref);\n+    InitPolicies();\n+\n+    nsresult\n+    InitDomainPolicy(JSContext* cx,const char* aPolicyName,\n+                     DomainPolicy* aDomainPolicy);\n \n     nsresult\n     InitPrincipals(PRUint32 prefCount, const char** prefNames,\n                    nsISecurityPref* securityPref);\n \n+#ifdef DEBUG_mstoltz\n+    void\n+    PrintPolicyDB();\n+#endif\n+\n+    // JS strings we need to clean up on shutdown\n+    static jsval sCallerID;\n+    static jsval sEnabledID;\n+\n     inline void\n     JSEnabledPrefChanged(nsISecurityPref* aSecurityPref);\n \n     static const char* sJSEnabledPrefName;\n     static const char* sJSMailEnabledPrefName;\n \n     nsObjectHashtable* mOriginToPolicyMap;\n-    nsHashtable* mClassPolicies;\n-    nsWeakPtr mPrefBranchWeakRef;\n+    DomainPolicy* mDefaultPolicy;\n+    nsObjectHashtable* mCapabilities;\n+\n+    nsCOMPtr<nsIPrefBranch> mPrefBranch;\n+    nsCOMPtr<nsISecurityPref> mSecurityPref;\n     nsIPrincipal* mSystemPrincipal;\n     nsCOMPtr<nsIPrincipal> mSystemCertificate;\n     nsSupportsHashtable* mPrincipals;\n     PRBool mIsJavaScriptEnabled;\n     PRBool mIsMailJavaScriptEnabled;\n     PRBool mIsWritingPrefs;\n-    nsCOMPtr<nsIJSContextStack> mThreadJSContextStack;\n+    nsCOMPtr<nsIThreadJSContextStack> mJSContextStack;\n     PRBool mNameSetRegistered;\n };\n "},{"sha":"c5992c9e6aba00a4987e8f4365b51f16889550a0","filename":"caps/src/makefile.win","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/mozilla/gecko-dev/blob/4756b7169cc8c42ad32ab030c3137ddfd702d119/caps/src/makefile.win","raw_url":"https://github.com/mozilla/gecko-dev/raw/4756b7169cc8c42ad32ab030c3137ddfd702d119/caps/src/makefile.win","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/caps/src/makefile.win?ref=4756b7169cc8c42ad32ab030c3137ddfd702d119","patch":"@@ -57,6 +57,7 @@ REQUIRES\t= xpcom \\\n \t\t  intl \\\n \t\t  docshell \\\n \t\t  windowwatcher \\\n+\t\t  embedding \\\n \t\t  $(NULL)\n \n #//------------------------------------------------------------------------"},{"sha":"6999e3052589f8b02ed437ea781137ee4366f9bd","filename":"caps/src/nsScriptSecurityManager.cpp","status":"modified","additions":824,"deletions":575,"changes":1399,"blob_url":"https://github.com/mozilla/gecko-dev/blob/4756b7169cc8c42ad32ab030c3137ddfd702d119/caps/src/nsScriptSecurityManager.cpp","raw_url":"https://github.com/mozilla/gecko-dev/raw/4756b7169cc8c42ad32ab030c3137ddfd702d119/caps/src/nsScriptSecurityManager.cpp","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/caps/src/nsScriptSecurityManager.cpp?ref=4756b7169cc8c42ad32ab030c3137ddfd702d119","patch":"@@ -38,7 +38,6 @@\n  * the terms of any one of the NPL, the GPL or the LGPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n-#include \"nscore.h\"\n #include \"nsScriptSecurityManager.h\"\n #include \"nsIServiceManager.h\"\n #include \"nsIScriptObjectPrincipal.h\"\n@@ -51,9 +50,7 @@\n #include \"nsCodebasePrincipal.h\"\n #include \"nsCertificatePrincipal.h\"\n #include \"nsAggregatePrincipal.h\"\n-#include \"nsCRT.h\"\n #include \"nsXPIDLString.h\"\n-#include \"nsReadableUtils.h\"\n #include \"nsIJSContextStack.h\"\n #include \"nsDOMError.h\"\n #include \"nsDOMCID.h\"\n@@ -81,6 +78,7 @@\n #include \"nsISecurityCheckedComponent.h\"\n #include \"nsIPrefBranchInternal.h\"\n #include \"nsIJSRuntimeService.h\"\n+#include \"nsIObserverService.h\"\n \n static NS_DEFINE_IID(kIIOServiceIID, NS_IIOSERVICE_IID);\n static NS_DEFINE_CID(kIOServiceCID, NS_IOSERVICE_CID);\n@@ -89,26 +87,15 @@ static NS_DEFINE_IID(kStringBundleServiceCID, NS_STRINGBUNDLESERVICE_CID);\n static NS_DEFINE_CID(kCScriptNameSetRegistryCID,\n                      NS_SCRIPT_NAMESET_REGISTRY_CID);\n static NS_DEFINE_CID(kZipReaderCID, NS_ZIPREADER_CID);\n+static NS_DEFINE_IID(kObserverServiceIID, NS_IOBSERVERSERVICE_IID);\n \n-//-- All values of this enum except the first map to odd numbers so they can be\n-//   stored in a void* without being confused for a pointer value (which is always even).\n-enum {\n-    SCRIPT_SECURITY_UNDEFINED_ACCESS = 0,\n-    SCRIPT_SECURITY_CAPABILITY_ONLY = 1,\n-    SCRIPT_SECURITY_SAME_ORIGIN_ACCESS = 3,\n-    SCRIPT_SECURITY_ALL_ACCESS = 5,\n-    SCRIPT_SECURITY_NO_ACCESS = 7\n-};\n-\n-#define  CLASS_HAS_DEFAULT_POLICY 1 << 0\n-#define  CLASS_HAS_SITE_POLICY    1 << 1\n-#define  CLASS_HAS_ACCESSTYPE     1 << 2\n-\n-\n+///////////////////////////\n+// Convenience Functions //\n+///////////////////////////\n // Result of this function should not be freed.\n static const PRUnichar *\n-JSValIDToString(JSContext *aJSContext, const jsval idval) {\n-    JSString *str = JS_ValueToString(aJSContext, idval);\n+JSValIDToString(JSContext *cx, const jsval idval) {\n+    JSString *str = JS_ValueToString(cx, idval);\n     if(!str)\n         return nsnull;\n     return NS_REINTERPRET_CAST(PRUnichar*, JS_GetStringChars(str));\n@@ -118,30 +105,147 @@ JSValIDToString(JSContext *aJSContext, const jsval idval) {\n // Uses cached JSContextStack service instead of calling through\n // to the service manager.\n JSContext *\n-nsScriptSecurityManager::GetCurrentContextQuick()\n+nsScriptSecurityManager::GetCurrentJSContext()\n {\n     // Get JSContext from stack.\n-    nsresult rv;\n-    if (!mThreadJSContextStack) {\n-        mThreadJSContextStack = do_GetService(\"@mozilla.org/js/xpc/ContextStack;1\", &rv);\n+    if (!mJSContextStack)\n+    {\n+        mJSContextStack = do_GetService(\"@mozilla.org/js/xpc/ContextStack;1\");\n+        if (!mJSContextStack)\n+            return nsnull;\n     }\n-    if (!mThreadJSContextStack)\n+    JSContext *cx;\n+    if (NS_FAILED(mJSContextStack->Peek(&cx)))\n         return nsnull;\n+    return cx;\n+}\n+\n+JSContext *\n+nsScriptSecurityManager::GetSafeJSContext()\n+{\n+    // Get JSContext from stack.\n+    if (!mJSContextStack) {\n+        mJSContextStack = do_GetService(\"@mozilla.org/js/xpc/ContextStack;1\");\n+    }\n+\n     JSContext *cx;\n-    if (NS_FAILED(mThreadJSContextStack->Peek(&cx)))\n+    if (NS_FAILED(mJSContextStack->GetSafeJSContext(&cx)))\n         return nsnull;\n     return cx;\n }\n \n+\n+class ClassNameHolder\n+{\n+public:\n+    ClassNameHolder(const char* aClassName, nsIClassInfo* aClassInfo) : \n+      mClassName((char*)aClassName), mClassInfo(aClassInfo), mMustFree(PR_FALSE)\n+    {\n+    }\n+\n+    ~ClassNameHolder()\n+    {\n+        if (mMustFree)\n+            nsMemory::Free(mClassName);\n+    }\n+\n+    char* get()\n+    {\n+        if (mClassName)\n+            return mClassName;\n+\n+        if (mClassInfo)\n+            mClassInfo->GetClassDescription(&mClassName);\n+        if (mClassName)\n+            mMustFree = PR_TRUE;\n+        else\n+            mClassName = \"UnnamedClass\";\n+\n+        return mClassName;\n+    }\n+\n+private:\n+    char* mClassName;\n+    nsCOMPtr<nsIClassInfo> mClassInfo;\n+    PRBool mMustFree;\n+};\n+\n+////////////////////\n+// Policy Storage //\n+////////////////////\n+\n+// Table of security levels\n+PR_STATIC_CALLBACK(PRBool)\n+DeleteCapability(nsHashKey *aKey, void *aData, void* closure)\n+{\n+    nsMemory::Free(aData);\n+    return PR_TRUE;\n+}\n+\n+//-- Per-Domain Policy - applies to one or more protocols or hosts\n+struct DomainEntry\n+{\n+    DomainEntry(const char* aOrigin,\n+                DomainPolicy* aDomainPolicy) : mOrigin(aOrigin),\n+                                               mDomainPolicy(aDomainPolicy),\n+                                               mNext(nsnull)\n+    {\n+        mDomainPolicy->Hold();\n+    }\n+\n+    ~DomainEntry()\n+    {\n+        mDomainPolicy->Drop();\n+    }\n+\n+    PRBool Matches(const char *anOrigin)\n+    {\n+        int len = nsCRT::strlen(anOrigin);\n+        int thisLen = mOrigin.Length();\n+        if (len < thisLen)\n+            return PR_FALSE;\n+        if (mOrigin.RFindChar(':', thisLen-1, 1) != -1)\n+        //-- Policy applies to all URLs of this scheme, compare scheme only\n+            return mOrigin.EqualsWithConversion(anOrigin, PR_TRUE, thisLen);\n+\n+        //-- Policy applies to a particular host; compare domains\n+        if (!mOrigin.Equals(anOrigin + (len - thisLen)))\n+            return PR_FALSE;\n+        if (len == thisLen)\n+            return PR_TRUE;\n+        char charBefore = anOrigin[len-thisLen-1];\n+        return (charBefore == '.' || charBefore == ':' || charBefore == '/');\n+    }\n+\n+    nsCString         mOrigin;\n+    DomainPolicy*     mDomainPolicy;\n+    DomainEntry*      mNext;\n+#ifdef DEBUG\n+    nsCString         mPolicyName_DEBUG;\n+#endif\n+};\n+\n+PR_STATIC_CALLBACK(PRBool)\n+DeleteDomainEntry(nsHashKey *aKey, void *aData, void* closure)\n+{\n+    DomainEntry *entry = (DomainEntry*) aData;\n+    do\n+    {\n+        DomainEntry *next = entry->mNext;\n+        delete entry;\n+        entry = next;\n+    } while (entry);\n+    return PR_TRUE;\n+}\n+\n /////////////////////////////\n // nsScriptSecurityManager //\n /////////////////////////////\n \n ////////////////////////////////////\n // Methods implementing ISupports //\n ////////////////////////////////////\n-\n-NS_IMPL_THREADSAFE_ISUPPORTS3(nsScriptSecurityManager,\n+NS_IMPL_ISUPPORTS3(nsScriptSecurityManager,\n                    nsIScriptSecurityManager,\n                    nsIXPCSecurityManager,\n                    nsIObserver)\n@@ -151,9 +255,10 @@ NS_IMPL_THREADSAFE_ISUPPORTS3(nsScriptSecurityManager,\n ///////////////////////////////////////////////////\n \n ///////////////// Security Checks /////////////////\n-static JSBool JS_DLL_CALLBACK\n-CheckJSFunctionCallerAccess(JSContext *cx, JSObject *obj, jsval id,\n-                            JSAccessMode mode, jsval *vp)\n+JSBool JS_DLL_CALLBACK\n+nsScriptSecurityManager::CheckJSFunctionCallerAccess(JSContext *cx, JSObject *obj,\n+                                                     jsval id, JSAccessMode mode,\n+                                                     jsval *vp)\n {\n     // Currently, this function will be called only when function.caller\n     // is accessed. If that changes, we will need to change this function.\n@@ -177,7 +282,7 @@ CheckJSFunctionCallerAccess(JSContext *cx, JSObject *obj, jsval id,\n     JSObject* target = JSVAL_TO_OBJECT(*vp);\n \n     // Do the same-origin check - this sets a JS exception if the check fails\n-    rv = ssm->CheckPropertyAccess(cx, target, \"Function\", \"caller\",\n+    rv = ssm->CheckPropertyAccess(cx, target, \"Function\", sCallerID,\n                                   nsIXPCSecurityManager::ACCESS_GET_PROPERTY);\n \n     if (NS_FAILED(rv))\n@@ -187,50 +292,54 @@ CheckJSFunctionCallerAccess(JSContext *cx, JSObject *obj, jsval id,\n }\n \n NS_IMETHODIMP\n-nsScriptSecurityManager::CheckPropertyAccess(JSContext* aJSContext,\n+nsScriptSecurityManager::CheckPropertyAccess(JSContext* cx,\n                                              JSObject* aJSObject,\n                                              const char* aClassName,\n-                                             const char* aPropertyName,\n+                                             jsval aProperty,\n                                              PRUint32 aAction)\n {\n-    return CheckPropertyAccessImpl(aAction, nsnull, aJSContext, aJSObject,\n-                                   nsnull, nsnull, nsnull, nsnull,\n-                                   aClassName, aPropertyName, nsnull);\n+    return CheckPropertyAccessImpl(aAction, nsnull, cx, aJSObject,\n+                                   nsnull, nsnull, nsnull,\n+                                   aClassName, aProperty, nsnull);\n }\n \n NS_IMETHODIMP\n-nsScriptSecurityManager::CheckConnect(JSContext* aJSContext,\n+nsScriptSecurityManager::CheckConnect(JSContext* cx,\n                                       nsIURI* aTargetURI,\n                                       const char* aClassName,\n                                       const char* aPropertyName)\n {\n     // Get a context if necessary\n-    if (!aJSContext)\n+    if (!cx)\n     {\n-        aJSContext = GetCurrentContextQuick();\n-        if (!aJSContext)\n+        cx = GetCurrentJSContext();\n+        if (!cx)\n             return NS_OK; // No JS context, so allow the load\n     }\n \n-    nsresult rv = CheckLoadURIFromScript(aJSContext, aTargetURI);\n+    nsresult rv = CheckLoadURIFromScript(cx, aTargetURI);\n     if (NS_FAILED(rv)) return rv;\n \n+    JSString* propertyName = ::JS_InternString(cx, aPropertyName);\n+    if (!propertyName)\n+        return NS_ERROR_OUT_OF_MEMORY;\n+\n     return CheckPropertyAccessImpl(nsIXPCSecurityManager::ACCESS_CALL_METHOD, nsnull,\n-                                   aJSContext, nsnull, nsnull, aTargetURI,\n-                                   nsnull, nsnull, aClassName, aPropertyName, nsnull);\n+                                   cx, nsnull, nsnull, aTargetURI,\n+                                   nsnull, aClassName, STRING_TO_JSVAL(propertyName), nsnull);\n }\n \n nsresult\n nsScriptSecurityManager::CheckPropertyAccessImpl(PRUint32 aAction,\n                                                  nsIXPCNativeCallContext* aCallContext,\n-                                                 JSContext* aJSContext, JSObject* aJSObject,\n+                                                 JSContext* cx, JSObject* aJSObject,\n                                                  nsISupports* aObj, nsIURI* aTargetURI,\n                                                  nsIClassInfo* aClassInfo,\n-                                                 jsval aName, const char* aClassName,\n-                                                 const char* aProperty, void** aPolicy)\n+                                                 const char* aClassName, jsval aProperty,\n+                                                 void** aCachedClassPolicy)\n {\n     nsCOMPtr<nsIPrincipal> subjectPrincipal;\n-    if (NS_FAILED(GetSubjectPrincipal(aJSContext, getter_AddRefs(subjectPrincipal))))\n+    if (NS_FAILED(GetSubjectPrincipal(cx, getter_AddRefs(subjectPrincipal))))\n         return NS_ERROR_FAILURE;\n \n     PRBool equals;\n@@ -239,123 +348,137 @@ nsScriptSecurityManager::CheckPropertyAccessImpl(PRUint32 aAction,\n         // We have native code or the system principal: just allow access\n         return NS_OK;\n \n-    static const char unknownClassName[] = \"UnknownClass\";\n+    nsresult rv;\n+    ClassNameHolder className(aClassName, aClassInfo);\n #ifdef DEBUG_mstoltz\n-    if (aProperty)\n-          printf(\"### CheckPropertyAccess(%s.%s, %i) \", aClassName, aProperty, aAction);\n-    else\n+    nsCAutoString propertyName;\n+    propertyName.AssignWithConversion((PRUnichar*)JSValIDToString(cx, aProperty));\n+    printf(\"### CanAccess(%s.%s, %i) \", className.get(), \n+           propertyName.get(), aAction);\n+#endif\n+\n+    //-- Initialize policies if necessary\n+    if (!mDefaultPolicy)\n     {\n-        nsXPIDLCString classNameStr;\n-        const char* className;\n-        if (aClassInfo)\n-            aClassInfo->GetClassDescription(getter_Copies(classNameStr));\n-        className = classNameStr.get();\n-        if(!className)\n-            className = unknownClassName;\n-        nsCAutoString propertyStr(className);\n-        propertyStr += '.';\n-        propertyStr.AppendWithConversion((PRUnichar*)JSValIDToString(aJSContext, aName));\n-\n-        char* property;\n-        property = ToNewCString(propertyStr);\n-        printf(\"### CanAccess(%s, %i) \", property, aAction);\n-        PR_FREEIF(property);\n+        rv = InitPolicies();\n+        if (NS_FAILED(rv))\n+            return rv;\n     }\n-#endif\n \n-    //-- Look up the policy for this property/method\n-    PRInt32 secLevel;\n-    nsCAutoString capability;\n-    if (aPolicy && *aPolicy)\n+    //-- Look up the policy for this class\n+    ClassPolicy* cpolicy = aCachedClassPolicy ? \n+                           NS_REINTERPRET_CAST(ClassPolicy*, *aCachedClassPolicy) : nsnull;\n+    if (!cpolicy)\n     {\n+        //-- No cached policy for this class, need to look it up\n #ifdef DEBUG_mstoltz\n-        printf(\"Cached \");\n+        printf(\"Miss! \");\n #endif\n-        secLevel = NS_PTR_TO_INT32(*aPolicy);\n-    }\n-    else\n-    {\n-        nsXPIDLCString classNameStr;\n-        const char* className;\n-\n-        nsCAutoString propertyName(aProperty);\n-        if (aClassName)\n-            className = aClassName;\n+    \trv = GetClassPolicy(subjectPrincipal, className.get(), &cpolicy);\n+        if (NS_FAILED(rv))\n+            return rv;\n+        if (aCachedClassPolicy)\n+            *aCachedClassPolicy = cpolicy;\n+    }\n+\n+    SecurityLevel securityLevel = GetPropertyPolicy(aProperty, cpolicy, aAction);\n+\n+    // If the class policy we have is a wildcard policy, then we may\n+    // still need to try the default for this class\n+    if (cpolicy != NO_POLICY_FOR_CLASS &&\n+        cpolicy->key[0] == '*' && cpolicy->key[1] == '\\0' &&\n+        securityLevel.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)\n+    {\n+        cpolicy = \n+          NS_REINTERPRET_CAST(ClassPolicy*,\n+                              PL_DHashTableOperate(mDefaultPolicy,\n+                                                   className.get(),\n+                                                   PL_DHASH_LOOKUP));\n+        if (PL_DHASH_ENTRY_IS_LIVE(cpolicy))\n+            securityLevel = GetPropertyPolicy(aProperty, cpolicy, aAction);\n+    }\n+\n+    if (securityLevel.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)\n+    {   \n+        // No policy found for this property so use the default of last resort.\n+        // If we were called from somewhere other than XPConnect\n+        // (no XPC call context), assume this is a DOM class. Otherwise,\n+        // ask the ClassInfo.\n+        if (!aCallContext || IsDOMClass(aClassInfo))\n+            securityLevel.level = SCRIPT_SECURITY_SAME_ORIGIN_ACCESS;\n         else\n-        //-- Get className and propertyName from aClassInfo and aName, repectively\n-        {\n-            if(aClassInfo)\n-                aClassInfo->GetClassDescription(getter_Copies(classNameStr));\n-            className = classNameStr.get();\n-\n-            if (!className)\n-                className = unknownClassName;\n-            propertyName.AssignWithConversion((PRUnichar*)JSValIDToString(aJSContext, aName));\n-        }\n-\n-        // if (aProperty), we were called from CheckPropertyAccess or checkConnect,\n-        // so we can assume this is a DOM class. Otherwise, we ask the ClassInfo.\n-        secLevel = GetSecurityLevel(subjectPrincipal,\n-                                    (aProperty || IsDOMClass(aClassInfo)),\n-                                    className, propertyName.get(), aAction, capability, aPolicy);\n+            securityLevel.level = SCRIPT_SECURITY_NO_ACCESS;\n     }\n \n-    nsresult rv;\n-    switch (secLevel)\n+    if (SECURITY_ACCESS_LEVEL_FLAG(securityLevel))\n+    // This flag means securityLevel is allAccess, noAccess, or sameOrigin\n     {\n-    case SCRIPT_SECURITY_ALL_ACCESS:\n+        switch (securityLevel.level)\n+        {\n+        case SCRIPT_SECURITY_NO_ACCESS:\n #ifdef DEBUG_mstoltz\n-        printf(\"Level: AllAccess \");\n+            printf(\"noAccess \");\n #endif\n-        rv = NS_OK;\n-        break;\n-    case SCRIPT_SECURITY_SAME_ORIGIN_ACCESS:\n-        {\n+            rv = NS_ERROR_DOM_SECURITY_ERR;\n+            break;\n+\n+        case SCRIPT_SECURITY_ALL_ACCESS:\n #ifdef DEBUG_mstoltz\n-            printf(\"Level: SameOrigin \");\n+            printf(\"allAccess \");\n #endif\n-            nsCOMPtr<nsIPrincipal> objectPrincipal;\n-            if(aJSObject)\n-            {\n-                if (NS_FAILED(GetObjectPrincipal(aJSContext,\n-                                                 NS_REINTERPRET_CAST(JSObject*, aJSObject),\n-                                                 getter_AddRefs(objectPrincipal))))\n-                    return NS_ERROR_FAILURE;\n-            }\n-            else if(aTargetURI)\n+            rv = NS_OK;\n+            break;\n+\n+        case SCRIPT_SECURITY_SAME_ORIGIN_ACCESS:\n             {\n-                if (NS_FAILED(GetCodebasePrincipal(aTargetURI, getter_AddRefs(objectPrincipal))))\n+#ifdef DEBUG_mstoltz\n+                printf(\"sameOrigin \");\n+#endif\n+                nsCOMPtr<nsIPrincipal> objectPrincipal;\n+                if(aJSObject)\n+                {\n+                    if (NS_FAILED(\n+                          GetObjectPrincipal(\n+                            cx,\n+                            NS_REINTERPRET_CAST(JSObject*, aJSObject),\n+                            getter_AddRefs(objectPrincipal))))\n+                        return NS_ERROR_FAILURE;\n+                }\n+                else if(aTargetURI)\n+                {\n+                    if (NS_FAILED(GetCodebasePrincipal(\n+                          aTargetURI, getter_AddRefs(objectPrincipal))))\n+                        return NS_ERROR_FAILURE;\n+                }\n+                else\n+                {\n+                    NS_ERROR(\"CheckPropertyAccessImpl called without a target object or URL\");\n                     return NS_ERROR_FAILURE;\n-            }\n-            else\n-            {\n-                rv = NS_ERROR_DOM_SECURITY_ERR;\n+                }\n+                rv = CheckSameOrigin(\n+                       cx, subjectPrincipal, objectPrincipal,\n+                       aAction == nsIXPCSecurityManager::ACCESS_SET_PROPERTY);\n                 break;\n             }\n-            rv = CheckSameOrigin(aJSContext, subjectPrincipal, objectPrincipal,\n-                                 aAction == nsIXPCSecurityManager::ACCESS_SET_PROPERTY);\n-\n-            break;\n-        }\n-    case SCRIPT_SECURITY_CAPABILITY_ONLY:\n-        {\n+        default:\n #ifdef DEBUG_mstoltz\n-            printf(\"Level: Capability \");\n+                printf(\"ERROR \");\n #endif\n-            PRBool capabilityEnabled = PR_FALSE;\n-            rv = IsCapabilityEnabled(capability.get(), &capabilityEnabled);\n-            if (NS_FAILED(rv) || !capabilityEnabled)\n-                rv = NS_ERROR_DOM_SECURITY_ERR;\n-            else\n-                rv = NS_OK;\n-            break;\n+            NS_ERROR(\"Bad Security Level Value\");\n+            return NS_ERROR_FAILURE;\n         }\n-    default:\n-        // Default is no access\n+    }\n+    else // if SECURITY_ACCESS_LEVEL_FLAG is false, securityLevel is a capability\n+    {\n #ifdef DEBUG_mstoltz\n-        printf(\"Level: NoAccess (%i)\",secLevel);\n+        printf(\"Cap:%s \", securityLevel.capability);\n #endif\n-        rv = NS_ERROR_DOM_SECURITY_ERR;\n+        PRBool capabilityEnabled = PR_FALSE;\n+        rv = IsCapabilityEnabled(securityLevel.capability, &capabilityEnabled);\n+        if (NS_FAILED(rv) || !capabilityEnabled)\n+            rv = NS_ERROR_DOM_SECURITY_ERR;\n+        else\n+            rv = NS_OK;\n     }\n \n     if NS_SUCCEEDED(rv)\n@@ -379,7 +502,7 @@ nsScriptSecurityManager::CheckPropertyAccessImpl(PRUint32 aAction,\n         const nsIID* objIID;\n         rv = aCallContext->GetCalleeWrapper(getter_AddRefs(wrapper));\n         if (NS_SUCCEEDED(rv))\n-            rv = wrapper->FindInterfaceWithMember(aName, getter_AddRefs(interfaceInfo));\n+            rv = wrapper->FindInterfaceWithMember(aProperty, getter_AddRefs(interfaceInfo));\n         if (NS_SUCCEEDED(rv))\n             rv = interfaceInfo->GetIIDShared(&objIID);\n         if (NS_SUCCEEDED(rv))\n@@ -388,17 +511,17 @@ nsScriptSecurityManager::CheckPropertyAccessImpl(PRUint32 aAction,\n             {\n             case nsIXPCSecurityManager::ACCESS_GET_PROPERTY:\n                 checkedComponent->CanGetProperty(objIID,\n-                                                 JSValIDToString(aJSContext, aName),\n+                                                 JSValIDToString(cx, aProperty),\n                                                  getter_Copies(objectSecurityLevel));\n                 break;\n             case nsIXPCSecurityManager::ACCESS_SET_PROPERTY:\n                 checkedComponent->CanSetProperty(objIID,\n-                                                 JSValIDToString(aJSContext, aName),\n+                                                 JSValIDToString(cx, aProperty),\n                                                  getter_Copies(objectSecurityLevel));\n                 break;\n             case nsIXPCSecurityManager::ACCESS_CALL_METHOD:\n                 checkedComponent->CanCallMethod(objIID,\n-                                                JSValIDToString(aJSContext, aName),\n+                                                JSValIDToString(cx, aProperty),\n                                                 getter_Copies(objectSecurityLevel));\n             }\n         }\n@@ -413,6 +536,7 @@ nsScriptSecurityManager::CheckPropertyAccessImpl(PRUint32 aAction,\n \n     if (NS_FAILED(rv)) //-- Security tests failed, access is denied, report error\n     {\n+        //XXX Clean up string usage here too\n         nsCAutoString errorMsg(\"Permission denied to \");\n         switch(aAction)\n         {\n@@ -425,42 +549,22 @@ nsScriptSecurityManager::CheckPropertyAccessImpl(PRUint32 aAction,\n         case nsIXPCSecurityManager::ACCESS_CALL_METHOD:\n             errorMsg += \"call method \";\n         }\n-\n-        if (aProperty)\n+        errorMsg += className.get();\n+        errorMsg += '.';\n+        errorMsg.AppendWithConversion((PRUnichar*)JSValIDToString(cx, aProperty));\n+\n+        JS_SetPendingException(cx,\n+                               STRING_TO_JSVAL(JS_NewStringCopyZ(cx, errorMsg.get())));\n+        nsCOMPtr<nsIXPConnect> xpc = do_GetService(nsIXPConnect::GetCID());\n+        if (xpc)\n         {\n-            errorMsg += aClassName;\n-            errorMsg += '.';\n-            errorMsg += aProperty;\n-        }\n-        else\n-        {\n-            nsXPIDLCString className;\n-            if (aClassInfo)\n-                aClassInfo->GetClassDescription(getter_Copies(className));\n-            if(className)\n-                errorMsg += className;\n-            else\n-                errorMsg += unknownClassName;\n-            errorMsg += '.';\n-            errorMsg.AppendWithConversion(JSValIDToString(aJSContext, aName));\n-        }\n-\n-        JS_SetPendingException(aJSContext,\n-                               STRING_TO_JSVAL(JS_NewStringCopyZ(aJSContext, errorMsg.get())));\n-        //-- if (aProperty) we were called from somewhere other than xpconnect, so we need to\n-        //   tell xpconnect that an exception was thrown.\n-        if (aProperty)\n-        {\n-            nsCOMPtr<nsIXPConnect> xpc = do_GetService(nsIXPConnect::GetCID());\n-            if (xpc)\n-            {\n-                nsCOMPtr<nsIXPCNativeCallContext> xpcCallContext;\n-                xpc->GetCurrentNativeCallContext(getter_AddRefs(xpcCallContext));\n-                if (xpcCallContext)\n-                    xpcCallContext->SetExceptionWasThrown(PR_TRUE);\n-            }\n+            nsCOMPtr<nsIXPCNativeCallContext> xpcCallContext;\n+            xpc->GetCurrentNativeCallContext(getter_AddRefs(xpcCallContext));\n+            if (xpcCallContext)\n+                xpcCallContext->SetExceptionWasThrown(PR_TRUE);\n         }\n     }\n+\n     return rv;\n }\n \n@@ -521,161 +625,28 @@ nsScriptSecurityManager::IsDOMClass(nsIClassInfo* aClassInfo)\n     return NS_SUCCEEDED(rv) && (classFlags & nsIClassInfo::DOM_OBJECT);\n }\n \n-PRInt32\n-nsScriptSecurityManager::GetSecurityLevel(nsIPrincipal *principal,\n-                                          PRBool aIsDOM,\n-                                          const char* aClassName,\n-                                          const char* aPropertyName,\n-                                          PRUint32 aAction,\n-                                          nsCString &aCapability,\n-                                          void** aPolicy)\n-{\n-    nsresult rv = NS_ERROR_FAILURE;\n-    PRInt32 secLevel = SCRIPT_SECURITY_NO_ACCESS;\n-\n-    nsXPIDLCString propertyPolicy;\n-    PRInt32 classPolicy = 0;\n-    if(mClassPolicies)\n-    {\n-        nsCStringKey classKey(aClassName);\n-        classPolicy = NS_PTR_TO_INT32(mClassPolicies->Get(&classKey));\n-        if (classPolicy != 0)\n-        {\n-            //-- Look up the security policy for this property\n-            rv = GetPolicy(principal, aClassName, aPropertyName,\n-                           classPolicy, aAction, getter_Copies(propertyPolicy));\n-        }\n-        if (NS_FAILED(rv))\n-        { //-- Look for a wildcard policy for this property\n-            nsCAutoString wildcardName(\"*.\");\n-            wildcardName += aPropertyName;\n-            nsCStringKey wildcardKey(wildcardName);\n-            PRInt32 wcPolicy = NS_PTR_TO_INT32(mClassPolicies->Get(&wildcardKey));\n-            if (wcPolicy != 0)\n-            {\n-                //-- Look up the security policy for this property\n-                rv = GetPolicy(principal, \"*\", aPropertyName,\n-                               wcPolicy, aAction, getter_Copies(propertyPolicy));\n-            }\n-        }\n-    }\n-    if (NS_SUCCEEDED(rv) && propertyPolicy)\n-    {\n-        if (PL_strcmp(propertyPolicy, \"sameOrigin\") == 0)\n-            secLevel = SCRIPT_SECURITY_SAME_ORIGIN_ACCESS;\n-        else if (PL_strcmp(propertyPolicy, \"allAccess\") == 0)\n-            secLevel = SCRIPT_SECURITY_ALL_ACCESS;\n-        else if (PL_strcmp(propertyPolicy, \"noAccess\") == 0)\n-            secLevel = SCRIPT_SECURITY_NO_ACCESS;\n-        else\n-        {\n-            // string should be the name of a capability\n-            aCapability = propertyPolicy;\n-            secLevel = SCRIPT_SECURITY_CAPABILITY_ONLY;\n-        }\n-    }\n-    else\n-    {\n-        //-- No policy for this property.\n-        //   Use the default policy: sameOrigin for DOM, noAccess for everything else\n-        if(aIsDOM)\n-            secLevel = SCRIPT_SECURITY_SAME_ORIGIN_ACCESS;\n-        if ((classPolicy == 0) && aPolicy)\n-        {\n-            //-- If there's no stored policy for this property,\n-            //   we can annotate the class's aPolicy field and avoid checking\n-            //   policy prefs next time.\n-            *aPolicy = (void*)secLevel;\n-        }\n-    }\n-    return secLevel;\n-}\n-\n-struct nsDomainEntry\n-{\n-    nsDomainEntry(const char *anOrigin, const char *aPolicy,\n-                  int aPolicyLength)\n-        : mNext(nsnull), mOrigin(anOrigin), mPolicy(aPolicy, aPolicyLength)\n-    { }\n-    PRBool Matches(const char *anOrigin)\n-    {\n-        int len = nsCRT::strlen(anOrigin);\n-        int thisLen = mOrigin.Length();\n-        if (len < thisLen)\n-            return PR_FALSE;\n-        if (mOrigin.RFindChar(':', thisLen-1, 1) != -1)\n-        //-- Policy applies to all URLs of this scheme, compare scheme only\n-            return mOrigin.EqualsWithConversion(anOrigin, PR_TRUE, thisLen);\n-\n-        //-- Policy applies to a particular host; compare scheme://host.domain\n-        if (!mOrigin.Equals(anOrigin + (len - thisLen)))\n-            return PR_FALSE;\n-        if (len == thisLen)\n-            return PR_TRUE;\n-        char charBefore = anOrigin[len-thisLen-1];\n-        return (charBefore == '.' || charBefore == ':' || charBefore == '/');\n-    }\n-    nsDomainEntry *mNext;\n-    nsCString mOrigin;\n-    nsCString mPolicy;\n-};\n-\n-nsresult\n-nsScriptSecurityManager::TryToGetPref(nsISecurityPref* aSecurityPref,\n-                                      nsCString &aPrefName,\n-                                      const char* aClassName,\n-                                      const char* aPropertyName,\n-                                      PRInt32 aClassPolicy,\n-                                      PRUint32 aAction, char** result)\n-{\n-    //-- Add the class and property names to the pref\n-    aPrefName += aClassName;\n-    aPrefName += '.';\n-    aPrefName += aPropertyName;\n-\n-    //-- Try to look up the pref\n-    if (NS_SUCCEEDED(aSecurityPref->SecurityGetCharPref(aPrefName.get(), result)))\n-        return NS_OK;\n-\n-    //-- If appropriate, try adding .get or .set and looking up again\n-    if (aClassPolicy & CLASS_HAS_ACCESSTYPE)\n-    {\n-        aPrefName +=\n-            (aAction == nsIXPCSecurityManager::ACCESS_SET_PROPERTY ? \".set\" : \".get\");\n-        return aSecurityPref->SecurityGetCharPref(aPrefName.get(), result);\n-    }\n-\n-    //-- Couldn't find a pref\n-    return NS_ERROR_FAILURE;\n-}\n-\n nsresult\n-nsScriptSecurityManager::GetPolicy(nsIPrincipal* principal,\n-                                   const char* aClassName, const char* aPropertyName,\n-                                   PRInt32 aClassPolicy, PRUint32 aAction, char** result)\n+nsScriptSecurityManager::GetClassPolicy(nsIPrincipal* principal, const char* aClassName,\n+                                        ClassPolicy** result)\n {\n     nsresult rv;\n     *result = nsnull;\n-\n-    nsCOMPtr<nsISecurityPref> securityPref(do_QueryReferent(mPrefBranchWeakRef));\n-    if (!securityPref)\n-        return NS_ERROR_FAILURE;\n-\n-    if ((aClassPolicy & CLASS_HAS_SITE_POLICY) && mOriginToPolicyMap)\n-    {   //-- Look up the name of the relevant per-site policy\n+    DomainPolicy* dpolicy = nsnull;\n+    if (mOriginToPolicyMap)\n+    {   //-- Look up the relevant domain policy, if any\n         nsCOMPtr<nsICodebasePrincipal> codebase(do_QueryInterface(principal));\n         if (!codebase)\n             return NS_ERROR_FAILURE;\n \n         nsXPIDLCString origin;\n         if (NS_FAILED(rv = codebase->GetOrigin(getter_Copies(origin))))\n             return rv;\n-\n-        const char *s = origin;\n+ \n+        const char *start = origin;\n         const char *nextToLastDot = nsnull;\n         const char *lastDot = nsnull;\n         const char *colon = nsnull;\n-        const char *p = s;\n+        const char *p = start;\n         while (*p)\n         {\n             if (*p == '.')\n@@ -688,54 +659,115 @@ nsScriptSecurityManager::GetPolicy(nsIPrincipal* principal,\n             p++;\n         }\n \n-        nsCStringKey key(nextToLastDot ? nextToLastDot+1 : s);\n-        nsDomainEntry *de = (nsDomainEntry *) mOriginToPolicyMap->Get(&key);\n+        nsCStringKey key(nextToLastDot ? nextToLastDot+1 : start);\n+        DomainEntry *de = (DomainEntry*) mOriginToPolicyMap->Get(&key);\n         if (!de)\n         {\n-            nsCAutoString scheme(s, colon-s+1);\n+            nsCAutoString scheme(start, colon-start+1);\n             nsCStringKey schemeKey(scheme);\n-            de = (nsDomainEntry *) mOriginToPolicyMap->Get(&schemeKey);\n+            de = (DomainEntry*) mOriginToPolicyMap->Get(&schemeKey);\n         }\n \n-        nsCString *policy = nsnull;\n         while (de)\n         {\n-            if (de->Matches(s))\n+            if (de->Matches(start))\n             {\n-                policy = &de->mPolicy;\n+                dpolicy = de->mDomainPolicy;\n                 break;\n             }\n             de = de->mNext;\n         }\n+    }\n \n-        if (policy)\n-        {\n-            //-- build the pref name and look it up\n-            //-- the form is \"capability.policy.policyname.class.property\"\n-            nsCAutoString prefName(\"capability.policy.\");\n-            prefName += *policy;\n-            prefName += '.';\n-            rv = TryToGetPref(securityPref, prefName, aClassName, aPropertyName,\n-                              aClassPolicy, aAction, result);\n-            if (NS_SUCCEEDED(rv))\n-                return NS_OK;\n-        }\n+    ClassPolicy* wildcardPolicy = nsnull;\n+    if (dpolicy)\n+    {\n+        //-- Now get the class policy\n+        *result = \n+          NS_REINTERPRET_CAST(ClassPolicy*,\n+            PL_DHashTableOperate(dpolicy,\n+                                 aClassName,\n+                                 PL_DHASH_LOOKUP));\n+\n+        //-- and the wildcard policy (class \"*\" for this domain)\n+        wildcardPolicy = \n+          NS_REINTERPRET_CAST(ClassPolicy*,\n+            PL_DHashTableOperate(dpolicy,\n+                                 \"*\",\n+                                 PL_DHASH_LOOKUP));\n     }\n-    //-- Now try looking up a default policy, if one exists\n-    //-- the form is \"capability.policy.default.class.property\"\n-    if (aClassPolicy & CLASS_HAS_DEFAULT_POLICY)\n+\n+    //-- and the default policy for this class\n+    ClassPolicy* defaultClassPolicy = \n+          NS_REINTERPRET_CAST(ClassPolicy*,\n+            PL_DHashTableOperate(mDefaultPolicy,\n+                                 aClassName,\n+                                 PL_DHASH_LOOKUP));\n+\n+    if (*result && PL_DHASH_ENTRY_IS_LIVE(*result))\n     {\n-        nsCAutoString prefName(\"capability.policy.default.\");\n-        rv = TryToGetPref(securityPref, prefName, aClassName, aPropertyName,\n-                          aClassPolicy, aAction, result);\n-        if (NS_SUCCEEDED(rv))\n-            return NS_OK;\n+        if (PL_DHASH_ENTRY_IS_LIVE(wildcardPolicy))\n+            (*result)->mWildcard = wildcardPolicy;\n+        if (PL_DHASH_ENTRY_IS_LIVE(defaultClassPolicy))\n+            (*result)->mDefault  = defaultClassPolicy;\n+    }\n+    else\n+    {\n+        if (wildcardPolicy && PL_DHASH_ENTRY_IS_LIVE(wildcardPolicy))\n+            *result = wildcardPolicy;\n+        else if (PL_DHASH_ENTRY_IS_LIVE(defaultClassPolicy))\n+            *result = defaultClassPolicy;\n+        else\n+            *result = NO_POLICY_FOR_CLASS;\n     }\n \n-    //-- Couldn't find a policy\n-    return NS_ERROR_FAILURE;\n+    return NS_OK;\n+}\n+\n+SecurityLevel\n+nsScriptSecurityManager::GetPropertyPolicy(jsval aProperty, ClassPolicy* aClassPolicy,\n+                                           PRUint32 aAction)\n+{\n+    //-- Look up the policy for this property/method\n+    PropertyPolicy* ppolicy = nsnull;\n+    if (aClassPolicy && aClassPolicy != NO_POLICY_FOR_CLASS)\n+    {\n+        ppolicy = \n+          (PropertyPolicy*) PL_DHashTableOperate(&aClassPolicy->mPolicy,\n+                                                 NS_REINTERPRET_CAST(void*, aProperty),\n+                                                 PL_DHASH_LOOKUP);\n+        if (!PL_DHASH_ENTRY_IS_LIVE(ppolicy))\n+        {   // No domain policy for this property, look for a wildcard policy\n+            if (aClassPolicy->mWildcard)\n+            {\n+                ppolicy = NS_REINTERPRET_CAST(PropertyPolicy*,\n+                  PL_DHashTableOperate(&aClassPolicy->mWildcard->mPolicy,\n+                                       NS_REINTERPRET_CAST(void*, aProperty),\n+                                       PL_DHASH_LOOKUP));\n+            }\n+            if (!PL_DHASH_ENTRY_IS_LIVE(ppolicy) && aClassPolicy->mDefault)\n+            {   // Now look for a default policy\n+                ppolicy = NS_REINTERPRET_CAST(PropertyPolicy*,\n+                  PL_DHashTableOperate(&aClassPolicy->mDefault->mPolicy,\n+                                       NS_REINTERPRET_CAST(void*, aProperty),\n+                                       PL_DHASH_LOOKUP));\n+            }\n+        }\n+        if (PL_DHASH_ENTRY_IS_LIVE(ppolicy))\n+        {\n+            // Get the correct security level from the property policy\n+            if (aAction == nsIXPCSecurityManager::ACCESS_SET_PROPERTY)\n+                return ppolicy->mSet;\n+            return ppolicy->mGet;\n+        }\n+    }\n+\n+    SecurityLevel nopolicy;\n+    nopolicy.level = SCRIPT_SECURITY_UNDEFINED_ACCESS;\n+    return nopolicy;\n }\n \n+\n NS_IMETHODIMP\n nsScriptSecurityManager::CheckLoadURIFromScript(JSContext *cx, nsIURI *aURI)\n {\n@@ -931,11 +963,7 @@ nsScriptSecurityManager::CheckLoadURI(nsIURI *aSourceURI, nsIURI *aTargetURI,\n             case PrefControlled:\n                 // Allow access if pref is false\n                 {\n-                    nsCOMPtr<nsISecurityPref> securityPref =\n-                                   do_QueryReferent(mPrefBranchWeakRef);\n-                    if (!securityPref)\n-                        return NS_ERROR_FAILURE;\n-                    securityPref->SecurityGetBoolPref(\"security.checkloaduri\", &doCheck);\n+                    mSecurityPref->SecurityGetBoolPref(\"security.checkloaduri\", &doCheck);\n                     return doCheck ? ReportErrorToConsole(aTargetURI) : NS_OK;\n                 }\n             case ChromeProtocol:\n@@ -1097,10 +1125,10 @@ nsScriptSecurityManager::GetRootDocShell(JSContext *cx, nsIDocShell **result)\n \n NS_IMETHODIMP\n nsScriptSecurityManager::CanExecuteScripts(JSContext* cx,\n-                                           nsIPrincipal *principal,\n+                                           nsIPrincipal *aPrincipal,\n                                            PRBool *result)\n {\n-    if (principal == mSystemPrincipal)\n+    if (aPrincipal == mSystemPrincipal)\n     {\n         // Even if JavaScript is disabled, we must still execute system scripts\n         *result = PR_TRUE;\n@@ -1113,7 +1141,7 @@ nsScriptSecurityManager::CanExecuteScripts(JSContext* cx,\n     nsresult rv;\n     if (!mIsJavaScriptEnabled)\n     {\n-        nsCOMPtr<nsICodebasePrincipal> codebase(do_QueryInterface(principal));\n+        nsCOMPtr<nsICodebasePrincipal> codebase(do_QueryInterface(aPrincipal));\n         if (codebase)\n         {\n             nsXPIDLCString origin;\n@@ -1155,18 +1183,28 @@ nsScriptSecurityManager::CanExecuteScripts(JSContext* cx,\n \n     //-- Check for a per-site policy\n     static const char jsPrefGroupName[] = \"javascript\";\n-    nsCStringKey jsKey(jsPrefGroupName);\n-    PRInt32 classPolicy = mClassPolicies ? NS_PTR_TO_INT32(mClassPolicies->Get(&jsKey)) : 0;\n-    if(classPolicy)\n-    {\n-        nsXPIDLCString policy;\n-        rv = GetPolicy(principal, jsPrefGroupName, \"enabled\", classPolicy, 0,\n-                       getter_Copies(policy));\n-        if (NS_SUCCEEDED(rv) && (PL_strcmp(\"noAccess\", policy) == 0))\n-        {\n-            *result = PR_FALSE;\n-            return NS_OK;\n-        }\n+\n+    // Initialize policies if necessary\n+    if (!mDefaultPolicy)\n+    {\n+        rv = InitPolicies();\n+        if (NS_FAILED(rv))\n+            return rv;\n+    }\n+\n+    ClassPolicy* cpolicy;\n+    SecurityLevel secLevel;\n+    rv = GetClassPolicy(aPrincipal, jsPrefGroupName, &cpolicy);\n+\n+    if (NS_SUCCEEDED(rv))\n+    {\n+        secLevel = GetPropertyPolicy(sEnabledID, cpolicy,\n+                                     nsIXPCSecurityManager::ACCESS_GET_PROPERTY);\n+    }\n+    if (NS_FAILED(rv) || secLevel.level == SCRIPT_SECURITY_NO_ACCESS)\n+    {\n+        *result = PR_FALSE;\n+        return rv;\n     }\n \n     //-- Nobody vetoed, so allow the JS to run.\n@@ -1178,7 +1216,7 @@ nsScriptSecurityManager::CanExecuteScripts(JSContext* cx,\n NS_IMETHODIMP\n nsScriptSecurityManager::GetSubjectPrincipal(nsIPrincipal **result)\n {\n-    JSContext *cx = GetCurrentContextQuick();\n+    JSContext *cx = GetCurrentJSContext();\n     if (!cx)\n     {\n         *result = nsnull;\n@@ -1505,24 +1543,21 @@ nsScriptSecurityManager::SavePrincipal(nsIPrincipal* aToSave)\n                              getter_Copies(deniedPrefName)  );\n     if (NS_FAILED(rv)) return NS_ERROR_FAILURE;\n \n-    nsCOMPtr<nsISecurityPref> securityPref(do_QueryReferent(mPrefBranchWeakRef));\n-    if (!securityPref)\n-        return NS_ERROR_FAILURE;\n     mIsWritingPrefs = PR_TRUE;\n     if (grantedList)\n-        securityPref->SecuritySetCharPref(grantedPrefName, grantedList);\n+        mSecurityPref->SecuritySetCharPref(grantedPrefName, grantedList);\n     else\n-        securityPref->SecurityClearUserPref(grantedPrefName);\n+        mSecurityPref->SecurityClearUserPref(grantedPrefName);\n \n     if (deniedList)\n-        securityPref->SecuritySetCharPref(deniedPrefName, deniedList);\n+        mSecurityPref->SecuritySetCharPref(deniedPrefName, deniedList);\n     else\n-        securityPref->SecurityClearUserPref(deniedPrefName);\n+        mSecurityPref->SecurityClearUserPref(deniedPrefName);\n \n     if (grantedList || deniedList)\n-        securityPref->SecuritySetCharPref(idPrefName, id);\n+        mSecurityPref->SecuritySetCharPref(idPrefName, id);\n     else\n-        securityPref->SecurityClearUserPref(idPrefName);\n+        mSecurityPref->SecurityClearUserPref(idPrefName);\n \n     mIsWritingPrefs = PR_FALSE;\n \n@@ -1538,7 +1573,7 @@ nsScriptSecurityManager::IsCapabilityEnabled(const char *capability,\n {\n     nsresult rv;\n     JSStackFrame *fp = nsnull;\n-    JSContext *cx = GetCurrentContextQuick();\n+    JSContext *cx = GetCurrentJSContext();\n     fp = cx ? JS_FrameIterator(cx, &fp) : nsnull;\n     if (!fp)\n     {\n@@ -1730,7 +1765,7 @@ nsScriptSecurityManager::RequestCapability(nsIPrincipal* aPrincipal,\n             return NS_ERROR_FAILURE;\n         PRUnichar *message = nsTextFormatter::smprintf(query.get(), source);\n         Recycle(source);\n-        JSContext *cx = GetCurrentContextQuick();\n+        JSContext *cx = GetCurrentJSContext();\n         if (CheckConfirmDialog(cx, message, check.get(), &remember))\n             *canEnable = nsIPrincipal::ENABLE_GRANTED;\n         else\n@@ -1751,7 +1786,7 @@ nsScriptSecurityManager::RequestCapability(nsIPrincipal* aPrincipal,\n NS_IMETHODIMP\n nsScriptSecurityManager::EnableCapability(const char *capability)\n {\n-    JSContext *cx = GetCurrentContextQuick();\n+    JSContext *cx = GetCurrentJSContext();\n     JSStackFrame *fp;\n \n     //-- Error checks for capability string length (200)\n@@ -1792,7 +1827,7 @@ nsScriptSecurityManager::EnableCapability(const char *capability)\n NS_IMETHODIMP\n nsScriptSecurityManager::RevertCapability(const char *capability)\n {\n-    JSContext *cx = GetCurrentContextQuick();\n+    JSContext *cx = GetCurrentJSContext();\n     JSStackFrame *fp;\n     nsCOMPtr<nsIPrincipal> principal;\n     if (NS_FAILED(GetPrincipalAndFrame(cx, getter_AddRefs(principal), &fp)))\n@@ -1806,7 +1841,7 @@ nsScriptSecurityManager::RevertCapability(const char *capability)\n NS_IMETHODIMP\n nsScriptSecurityManager::DisableCapability(const char *capability)\n {\n-    JSContext *cx = GetCurrentContextQuick();\n+    JSContext *cx = GetCurrentJSContext();\n     JSStackFrame *fp;\n     nsCOMPtr<nsIPrincipal> principal;\n     if (NS_FAILED(GetPrincipalAndFrame(cx, getter_AddRefs(principal), &fp)))\n@@ -1871,7 +1906,7 @@ nsScriptSecurityManager::SetCanEnableCapability(const char* certificateID,\n     }\n     if (!isEqual)\n     {\n-        JSContext* cx = GetCurrentContextQuick();\n+        JSContext* cx = GetCurrentJSContext();\n         if (!cx) return NS_ERROR_FAILURE;\n         static const char msg1[] = \"Only code signed by the system certificate may call SetCanEnableCapability or Invalidate\";\n         static const char msg2[] = \"Attempt to call SetCanEnableCapability or Invalidate when no system certificate has been established\";\n@@ -1894,7 +1929,7 @@ nsScriptSecurityManager::SetCanEnableCapability(const char* certificateID,\n ////////////////////////////////////////////////\n \n NS_IMETHODIMP\n-nsScriptSecurityManager::CanCreateWrapper(JSContext *aJSContext,\n+nsScriptSecurityManager::CanCreateWrapper(JSContext *cx,\n                                           const nsIID &aIID,\n                                           nsISupports *aObj,\n                                           nsIClassInfo *aClassInfo,\n@@ -1928,7 +1963,6 @@ nsScriptSecurityManager::CanCreateWrapper(JSContext *aJSContext,\n     {\n         //-- Access denied, report an error\n         nsCAutoString errorMsg(\"Permission denied to create wrapper for object \");\n-        // XXX get class name\n         nsXPIDLCString className;\n         if (aClassInfo)\n         {\n@@ -1939,14 +1973,14 @@ nsScriptSecurityManager::CanCreateWrapper(JSContext *aJSContext,\n                 errorMsg += className;\n             }\n         }\n-        JS_SetPendingException(aJSContext,\n-                               STRING_TO_JSVAL(JS_NewStringCopyZ(aJSContext, errorMsg.get())));\n+        JS_SetPendingException(cx,\n+                               STRING_TO_JSVAL(JS_NewStringCopyZ(cx, errorMsg.get())));\n     }\n     return rv;\n }\n \n NS_IMETHODIMP\n-nsScriptSecurityManager::CanCreateInstance(JSContext *aJSContext,\n+nsScriptSecurityManager::CanCreateInstance(JSContext *cx,\n                                            const nsCID &aCID)\n {\n     nsresult rv = CheckXPCPermissions(nsnull, nsnull);\n@@ -1957,14 +1991,14 @@ nsScriptSecurityManager::CanCreateInstance(JSContext *aJSContext,\n         nsXPIDLCString cidStr;\n         cidStr += aCID.ToString();\n         errorMsg.Append(cidStr);\n-        JS_SetPendingException(aJSContext,\n-                               STRING_TO_JSVAL(JS_NewStringCopyZ(aJSContext, errorMsg.get())));\n+        JS_SetPendingException(cx,\n+                               STRING_TO_JSVAL(JS_NewStringCopyZ(cx, errorMsg.get())));\n     }\n     return rv;\n }\n \n NS_IMETHODIMP\n-nsScriptSecurityManager::CanGetService(JSContext *aJSContext,\n+nsScriptSecurityManager::CanGetService(JSContext *cx,\n                                        const nsCID &aCID)\n {\n #if 0\n@@ -1981,26 +2015,26 @@ nsScriptSecurityManager::CanGetService(JSContext *aJSContext,\n         nsXPIDLCString cidStr;\n         cidStr += aCID.ToString();\n         errorMsg.Append(cidStr);\n-        JS_SetPendingException(aJSContext,\n-                               STRING_TO_JSVAL(JS_NewStringCopyZ(aJSContext, errorMsg.get())));\n+        JS_SetPendingException(cx,\n+                               STRING_TO_JSVAL(JS_NewStringCopyZ(cx, errorMsg.get())));\n     }\n     return rv;\n }\n \n-/* void CanAccess (in PRUint32 aAction, in nsIXPCNativeCallContext aCallContext, in JSContextPtr aJSContext, in JSObjectPtr aJSObject, in nsISupports aObj, in nsIClassInfo aClassInfo, in JSVal aName, inout voidPtr aPolicy); */\n+\n NS_IMETHODIMP\n nsScriptSecurityManager::CanAccess(PRUint32 aAction,\n                                    nsIXPCNativeCallContext* aCallContext,\n-                                   JSContext* aJSContext,\n+                                   JSContext* cx,\n                                    JSObject* aJSObject,\n                                    nsISupports* aObj,\n                                    nsIClassInfo* aClassInfo,\n-                                   jsval aName,\n+                                   jsval aPropertyName,\n                                    void** aPolicy)\n {\n-    return CheckPropertyAccessImpl(aAction, aCallContext, aJSContext,\n+    return CheckPropertyAccessImpl(aAction, aCallContext, cx,\n                                    aJSObject, aObj, nsnull, aClassInfo,\n-                                   aName, nsnull, nsnull, aPolicy);\n+                                   nsnull, aPropertyName, aPolicy);\n }\n \n nsresult\n@@ -2038,10 +2072,7 @@ nsScriptSecurityManager::CheckXPCPermissions(nsISupports* aObj,\n             static PRBool allowPluginAccess = PR_FALSE;\n             if (!prefSet)\n             {\n-                nsCOMPtr<nsISecurityPref> securityPref(do_QueryReferent(mPrefBranchWeakRef));\n-                if (!securityPref)\n-                    return NS_ERROR_FAILURE;\n-                rv = securityPref->SecurityGetBoolPref(\"security.xpconnect.plugin.unrestricted\",\n+                rv = mSecurityPref->SecurityGetBoolPref(\"security.xpconnect.plugin.unrestricted\",\n                                                        &allowPluginAccess);\n                 prefSet = PR_TRUE;\n             }\n@@ -2058,44 +2089,34 @@ nsScriptSecurityManager::CheckXPCPermissions(nsISupports* aObj,\n // Method implementing nsIObserver //\n /////////////////////////////////////\n static const char sPrincipalPrefix[] = \"capability.principal\";\n-static const char sPolicyPrefix[] = \"capability.policy\";\n+static const char sProfileChangeMsg[] = \"profile-after-change\";\n \n NS_IMETHODIMP\n-nsScriptSecurityManager::Observe(nsISupports* aObject, const char* aAction,\n-                                 const PRUnichar* aPrefName)\n+nsScriptSecurityManager::Observe(nsISupports* aObject, const char* aTopic,\n+                                 const PRUnichar* aMessage)\n {\n     nsresult rv = NS_OK;\n-    nsCAutoString prefNameStr;\n-    prefNameStr.AssignWithConversion(aPrefName);\n-    char* prefName = ToNewCString(prefNameStr);\n-    if (!prefName)\n-        return NS_ERROR_OUT_OF_MEMORY;\n-    nsCOMPtr<nsISecurityPref> securityPref(do_QueryReferent(mPrefBranchWeakRef));\n-    if (!securityPref)\n-        return NS_ERROR_FAILURE;\n+    NS_ConvertUCS2toUTF8 messageStr(aMessage);\n+    const char *message = messageStr.get();\n \n     static const char jsPrefix[] = \"javascript.\";\n-    if(PL_strncmp(prefName, jsPrefix, sizeof(jsPrefix)-1) == 0)\n-        JSEnabledPrefChanged(securityPref);\n-    else if((PL_strncmp(prefName, sPrincipalPrefix, sizeof(sPrincipalPrefix)-1) == 0) &&\n+    if(PL_strncmp(message, jsPrefix, sizeof(jsPrefix)-1) == 0)\n+        JSEnabledPrefChanged(mSecurityPref);\n+    else if((PL_strncmp(message, sPrincipalPrefix, sizeof(sPrincipalPrefix)-1) == 0) &&\n             !mIsWritingPrefs)\n     {\n         static const char id[] = \"id\";\n-        char* lastDot = PL_strrchr(prefName, '.');\n+        char* lastDot = PL_strrchr(message, '.');\n         //-- This check makes sure the string copy below doesn't overwrite its bounds\n         if(PL_strlen(lastDot) >= sizeof(id))\n         {\n             PL_strcpy(lastDot + 1, id);\n-            const char** idPrefArray = (const char**)&prefName;\n-            rv = InitPrincipals(1, idPrefArray, securityPref);\n+            const char** idPrefArray = (const char**)&message;\n+            rv = InitPrincipals(1, idPrefArray, mSecurityPref);\n         }\n     }\n-    else if((PL_strncmp(prefName, sPolicyPrefix, sizeof(sPolicyPrefix)-1) == 0))\n-    {\n-        const char** prefArray = (const char**)&prefName;\n-        rv = InitPolicies(1, prefArray, securityPref);\n-    }\n-    PR_Free(prefName);\n+    else if((PL_strcmp(aTopic, sProfileChangeMsg) == 0))\n+        rv = InitPolicies();\n     return rv;\n }\n \n@@ -2104,17 +2125,25 @@ nsScriptSecurityManager::Observe(nsISupports* aObject, const char* aAction,\n /////////////////////////////////////////////\n nsScriptSecurityManager::nsScriptSecurityManager(void)\n     : mOriginToPolicyMap(nsnull),\n-      mClassPolicies(nsnull),\n+      mDefaultPolicy(nsnull),\n+      mCapabilities(nsnull),\n       mSystemPrincipal(nsnull), mPrincipals(nsnull),\n       mIsJavaScriptEnabled(PR_FALSE),\n       mIsMailJavaScriptEnabled(PR_FALSE),\n       mIsWritingPrefs(PR_FALSE),\n       mNameSetRegistered(PR_FALSE)\n \n {\n+    NS_ASSERTION(sizeof(long) == sizeof(void*), \"long and void* have different lengths on this platform. This may cause a security failure.\");\n     NS_INIT_REFCNT();\n+\n+    JSContext* cx = GetSafeJSContext();\n+    if (sCallerID == JSVAL_VOID)\n+        sCallerID = STRING_TO_JSVAL(::JS_InternString(cx, \"caller\"));\n+    if (sEnabledID == JSVAL_VOID)\n+        sEnabledID = STRING_TO_JSVAL(::JS_InternString(cx, \"enabled\"));\n+\n     InitPrefs();\n-    mThreadJSContextStack = do_GetService(\"@mozilla.org/js/xpc/ContextStack;1\");\n \n     //-- Register security check callback in the JS engine\n     //   Currently this is used to control access to function.caller\n@@ -2136,12 +2165,23 @@ nsScriptSecurityManager::nsScriptSecurityManager(void)\n     NS_ASSERTION(!oldCallback, \"Someone already set a JS CheckObjectAccess callback\");\n }\n \n+jsval nsScriptSecurityManager::sCallerID   = JSVAL_VOID;\n+jsval nsScriptSecurityManager::sEnabledID   = JSVAL_VOID;\n+\n nsScriptSecurityManager::~nsScriptSecurityManager(void)\n {\n     delete mOriginToPolicyMap;\n-    delete mClassPolicies;\n+    delete mDefaultPolicy;\n     NS_IF_RELEASE(mSystemPrincipal);\n     delete mPrincipals;\n+    delete mCapabilities;\n+}\n+\n+void\n+nsScriptSecurityManager::Shutdown()\n+{\n+    sCallerID = JSVAL_VOID;\n+    sEnabledID = JSVAL_VOID;\n }\n \n static nsScriptSecurityManager *ssecMan = NULL;\n@@ -2192,155 +2232,279 @@ nsScriptSecurityManager::SystemPrincipalSingletonConstructor()\n     return NS_STATIC_CAST(nsSystemPrincipal*, sysprin);\n }\n \n+NS_IMETHODIMP\n+nsScriptSecurityManager::ReloadSecurityPolicies()\n+{\n+    nsresult rv;\n+    nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));\n+    if (NS_FAILED(rv)) return rv;\n \n-const char* nsScriptSecurityManager::sJSEnabledPrefName = \"javascript.enabled\";\n-const char* nsScriptSecurityManager::sJSMailEnabledPrefName = \"javascript.allow.mailnews\";\n+    rv = xpc->ClearAllWrappedNativeSecurityPolicies();\n+    if (NS_FAILED(rv)) return rv;\n \n-PR_STATIC_CALLBACK(PRBool)\n-DeleteEntry(nsHashKey *aKey, void *aData, void* closure)\n-{\n-    nsDomainEntry *entry = (nsDomainEntry *) aData;\n-    do\n-    {\n-        nsDomainEntry *next = entry->mNext;\n-        delete entry;\n-        entry = next;\n-    } while (entry);\n-    return PR_TRUE;\n+    return InitPolicies();\n }\n \n+static NS_NAMED_LITERAL_CSTRING(policyPrefPrefix, \"capability.policy.\");\n+\n nsresult\n-nsScriptSecurityManager::InitPolicies(PRUint32 aPrefCount, const char** aPrefNames,\n-                                      nsISecurityPref* aSecurityPref)\n+nsScriptSecurityManager::InitPolicies()\n {\n-    for (PRUint32 c = 0; c < aPrefCount; c++)\n+    nsresult rv;\n+    //-- Reset mOriginToPolicyMap\n+    delete mOriginToPolicyMap;\n+    mOriginToPolicyMap =\n+      new nsObjectHashtable(nsnull, nsnull, DeleteDomainEntry, nsnull);\n+\n+    //-- Reset and initialize the default policy\n+    delete mDefaultPolicy;\n+    mDefaultPolicy =\n+      new DomainPolicy();\n+    if (!mOriginToPolicyMap || !mDefaultPolicy)\n+        return NS_ERROR_OUT_OF_MEMORY;\n+\n+    //-- Initialize the table of security levels\n+    if (!mCapabilities)\n     {\n-        unsigned count = 0;\n-        const char *dots[5];\n-        const char *p;\n-        for (p=aPrefNames[c]; *p; p++)\n-        {\n-            if (*p == '.')\n-            {\n-                dots[count++] = p;\n-                if (count == sizeof(dots)/sizeof(dots[0]))\n-                    break;\n-            }\n-        }\n-        if (count < sizeof(dots)/sizeof(dots[0]))\n-            dots[count] = p;\n-        if (count < 3)\n+        mCapabilities = \n+          new nsObjectHashtable(nsnull, nsnull, DeleteCapability, nsnull);\n+        if (!mCapabilities)\n+            return NS_ERROR_OUT_OF_MEMORY;\n+    }\n+\n+    // Get a JS context - we need it to create internalized strings later.\n+    JSContext* cx = GetSafeJSContext();\n+    NS_ASSERTION(cx, \"failed to get JS context\");\n+    rv = InitDomainPolicy(cx, \"default\", mDefaultPolicy);\n+    NS_ENSURE_SUCCESS(rv, rv);\n+\n+    nsXPIDLCString policyNames;\n+    rv = mSecurityPref->SecurityGetCharPref(\"capability.policy.policynames\",\n+                                            getter_Copies(policyNames));\n+\n+    nsXPIDLCString defaultPolicyNames;\n+    rv = mSecurityPref->SecurityGetCharPref(\"capability.policy.default_policynames\",\n+                                            getter_Copies(defaultPolicyNames));\n+    policyNames += NS_LITERAL_CSTRING(\" \") + defaultPolicyNames;\n+\n+    //-- Initialize domain policies\n+    char* policyCurrent = (char*)policyNames.get();\n+    PRBool morePolicies = PR_TRUE;\n+    while (morePolicies)\n+    {\n+        while(*policyCurrent == ' ' || *policyCurrent == ',')\n+            policyCurrent++;\n+        if (*policyCurrent == '\\0')\n+            break;\n+        char* nameBegin = policyCurrent;\n+\n+        while(*policyCurrent != '\\0' && *policyCurrent != ' ' && *policyCurrent != ',')\n+            policyCurrent++;\n+\n+        morePolicies = (*policyCurrent != '\\0');\n+        *policyCurrent = '\\0';\n+        policyCurrent++;\n+        \n+        //XXX use better concatenation?\n+        nsCAutoString sitesPrefName(policyPrefPrefix +\n+\t\t\t\t    nsDependentCString(nameBegin) +\n+\t\t\t\t    NS_LITERAL_CSTRING(\".sites\"));\n+        nsXPIDLCString domainList;\n+        rv = mSecurityPref->SecurityGetCharPref(sitesPrefName.get(),\n+                                                getter_Copies(domainList));\n+        if (NS_FAILED(rv))\n             continue;\n-        const char *policyName = dots[1] + 1;\n-        int policyLength = dots[2] - policyName;\n-        PRBool isDefault = PL_strncmp(\"default\", policyName, policyLength) == 0;\n-        if (!isDefault && count == 3)\n+\n+        DomainPolicy* domainPolicy = new DomainPolicy();\n+        if (!domainPolicy)\n+            return NS_ERROR_OUT_OF_MEMORY;\n+\n+        //-- Parse list of sites and create an entry in mOriginToPolicyMap for each\n+        char* domainStart = (char*)domainList.get();\n+        char* domainCurrent = domainStart;\n+        char* lastDot = nsnull;\n+        char* nextToLastDot = nsnull;\n+        PRBool moreDomains = PR_TRUE;\n+        while (moreDomains)\n         {\n-            // capability.policy.<policyname>.sites\n-            const char *sitesName = dots[2] + 1;\n-            int sitesLength = dots[3] - sitesName;\n-            if (PL_strncmp(\"sites\", sitesName, sitesLength) == 0)\n+            if (*domainCurrent == ' ' || *domainCurrent == '\\0')\n             {\n-                if (!mOriginToPolicyMap)\n-                {\n-                    mOriginToPolicyMap =\n-                        new nsObjectHashtable(nsnull, nsnull, DeleteEntry, nsnull);\n-                    if (!mOriginToPolicyMap)\n-                        return NS_ERROR_OUT_OF_MEMORY;\n-                }\n-                char *s;\n-                if (NS_FAILED(aSecurityPref->SecurityGetCharPref(aPrefNames[c], &s)))\n-                    return NS_ERROR_FAILURE;\n-                char *q=s;\n-                char *r=s;\n-                char *lastDot = nsnull;\n-                char *nextToLastDot = nsnull;\n-                PRBool working = PR_TRUE;\n-                while (working)\n+                moreDomains = (*domainCurrent != '\\0');\n+                *domainCurrent = '\\0';\n+                nsCStringKey key(nextToLastDot ? nextToLastDot+1 : domainStart);\n+                DomainEntry *newEntry = new DomainEntry(domainStart, domainPolicy);\n+                if (!newEntry)\n+                    return NS_ERROR_OUT_OF_MEMORY;\n+#ifdef DEBUG\n+                newEntry->mPolicyName_DEBUG = nameBegin;\n+#endif\n+                DomainEntry *existingEntry = (DomainEntry *)\n+                    mOriginToPolicyMap->Get(&key);\n+                if (!existingEntry)\n+                    mOriginToPolicyMap->Put(&key, newEntry);\n+                else\n                 {\n-                    if (*r == ' ' || *r == '\\0')\n+                    if (existingEntry->Matches(domainStart))\n                     {\n-                        working = (*r != '\\0');\n-                        *r = '\\0';\n-                        nsCStringKey key(nextToLastDot ? nextToLastDot+1 : q);\n-                        nsDomainEntry *value = new nsDomainEntry(q, policyName,\n-                                                                 policyLength);\n-                        if (!value)\n-                            break;\n-                        nsDomainEntry *de = (nsDomainEntry *)\n-                            mOriginToPolicyMap->Get(&key);\n-                        if (!de)\n-                            mOriginToPolicyMap->Put(&key, value);\n-                        else\n+                        newEntry->mNext = existingEntry;\n+                        mOriginToPolicyMap->Put(&key, newEntry);\n+                    }\n+                    else\n+                    {\n+                        while (existingEntry->mNext)\n                         {\n-                            if (de->Matches(q))\n+                            if (existingEntry->mNext->Matches(domainStart))\n                             {\n-                                value->mNext = de;\n-                                mOriginToPolicyMap->Put(&key, value);\n-                            }\n-                            else\n-                            {\n-                                while (de->mNext)\n-                                {\n-                                    if (de->mNext->Matches(q))\n-                                    {\n-                                        value->mNext = de->mNext;\n-                                        de->mNext = value;\n-                                        break;\n-                                    }\n-                                    de = de->mNext;\n-                                }\n-                                if (!de->mNext)\n-                                    de->mNext = value;\n+                                newEntry->mNext = existingEntry->mNext;\n+                                existingEntry->mNext = newEntry;\n+                                break;\n                             }\n+                            existingEntry = existingEntry->mNext;\n                         }\n-                        q = r + 1;\n-                        lastDot = nextToLastDot = nsnull;\n-                    }\n-                    else if (*r == '.')\n-                    {\n-                        nextToLastDot = lastDot;\n-                        lastDot = r;\n+                        if (!existingEntry->mNext)\n+                            existingEntry->mNext = newEntry;\n                     }\n-                    r++;\n                 }\n-                PR_Free(s);\n+                domainStart = domainCurrent + 1;\n+                lastDot = nextToLastDot = nsnull;\n+            }\n+            else if (*domainCurrent == '.')\n+            {\n+                nextToLastDot = lastDot;\n+                lastDot = domainCurrent;\n             }\n+            domainCurrent++;\n         }\n-        else if (count > 3)\n-        {   // capability.policy.<policyname>.<class>.<property>[.(get|set)]\n-            // Store a notation for this class name in the classes hashtable.\n-            // The stored value contains several bits of information.\n-            if (!(mClassPolicies))\n-                mClassPolicies = new nsHashtable(31);\n-\n-            // In most cases, we hash on the class name at dots[2]+1,\n-            // unless the class name is '*' (wildcard), in which case we hash on\n-            // '*.propertyname'\n-            // Shoving nulls into the pref name string is unorthodox\n-            // but it saves a malloc & copy - hash keys require null-terminated strings\n-            if (!( (dots[2][1] == '*') && (dots[2][2] == '.') ))\n-                *(char*)dots[3] = '\\0';\n-            else if (count > 4)\n+\n+        rv = InitDomainPolicy(cx, nameBegin, domainPolicy);\n+        NS_ENSURE_SUCCESS(rv, rv);\n+    }\n+\n+#ifdef DEBUG_mstoltz\n+    PrintPolicyDB();\n+#endif\n+    return NS_OK;\n+}\n+\n+\n+nsresult\n+nsScriptSecurityManager::InitDomainPolicy(JSContext* cx,\n+                                          const char* aPolicyName,\n+                                          DomainPolicy* aDomainPolicy)\n+{\n+    nsresult rv;\n+    nsCAutoString policyPrefix(policyPrefPrefix +\n+\t\t\t       nsDependentCString(aPolicyName) +\n+\t\t\t       NS_LITERAL_CSTRING(\".\"));\n+    PRUint32 prefixLength = policyPrefix.Length() - 1; // subtract the '.'\n+\n+    // XXX fix string use here.\n+    PRUint32 prefCount;\n+    char** prefNames;\n+    rv = mPrefBranch->GetChildList(policyPrefix.get(),\n+\t\t\t\t   &prefCount, &prefNames);\n+    if (NS_FAILED(rv)) return rv;\n+    if (prefCount == 0)\n+        return NS_OK;\n+\n+    //-- Populate the policy\n+    PRUint32 currentPref = 0;\n+    for (; currentPref < prefCount; currentPref++)\n+    {\n+        // Get the class name\n+        const char* start = prefNames[currentPref] + prefixLength +1;\n+        char* end = PL_strchr(start, '.');\n+        if (!end) // malformed pref, bail on this one\n+            continue;\n+        static const char sitesStr[] = \"sites\";\n+\n+\t// We dealt with \"sites\" in InitPolicies(), so no need to do\n+\t// that again...\n+        if (PL_strncmp(start, sitesStr, sizeof(sitesStr)-1) == 0)\n+            continue;\n+\n+        // Get the pref value\n+        nsXPIDLCString prefValue;\n+        rv = mSecurityPref->SecurityGetCharPref(prefNames[currentPref],\n+                                                getter_Copies(prefValue));\n+        if (NS_FAILED(rv) || !prefValue)\n+            continue;\n+\n+        SecurityLevel secLevel;\n+        if (PL_strcasecmp(prefValue, \"noAccess\") == 0)\n+            secLevel.level = SCRIPT_SECURITY_NO_ACCESS;\n+        else if (PL_strcasecmp(prefValue, \"allAccess\") == 0)\n+            secLevel.level = SCRIPT_SECURITY_ALL_ACCESS;\n+        else if (PL_strcasecmp(prefValue, \"sameOrigin\") == 0)\n+            secLevel.level = SCRIPT_SECURITY_SAME_ORIGIN_ACCESS;\n+        else \n+        {  //-- pref value is the name of a capability\n+            nsCStringKey secLevelKey(prefValue);\n+            secLevel.capability =\n+                NS_REINTERPRET_CAST(char*, mCapabilities->Get(&secLevelKey));\n+            if (!secLevel.capability)\n             {\n-                // There's a .get or .set at the end\n-                *(char*)dots[4] = '\\0';\n+                secLevel.capability = nsCRT::strdup(prefValue);\n+                if (!secLevel.capability)\n+                    break;\n+                mCapabilities->Put(&secLevelKey, \n+                                   secLevel.capability);\n             }\n+        }\n+\n+        *end = '\\0';\n+        // Find or store this class in the classes table\n+        ClassPolicy* cpolicy = \n+          NS_REINTERPRET_CAST(ClassPolicy*,\n+                              PL_DHashTableOperate(aDomainPolicy,\n+                                                   start,\n+                                                   PL_DHASH_ADD));\n+\n+        if (!cpolicy)\n+            break;\n \n-            nsCStringKey classNameKey(dots[2] + 1);\n-            PRInt32 classPolicy = NS_PTR_TO_INT32(mClassPolicies->Get(&classNameKey));\n-            if (isDefault)\n-                classPolicy |= CLASS_HAS_DEFAULT_POLICY;\n+        // Get the property name\n+        start = end + 1;\n+        end = PL_strchr(start, '.');\n+        if (end)\n+            *end = '\\0';\n+\n+        JSString* propertyKey = ::JS_InternString(cx, start);\n+        if (!propertyKey)\n+            return NS_ERROR_OUT_OF_MEMORY;\n+\n+        // Store this property in the class policy\n+        PropertyPolicy* ppolicy = \n+          (PropertyPolicy*) PL_DHashTableOperate(&cpolicy->mPolicy,\n+                                                 (void*)STRING_TO_JSVAL(propertyKey),\n+                                                 PL_DHASH_ADD);\n+        if (!ppolicy)\n+            break;\n+\n+        if (end) // The pref specifies an access mode\n+        {\n+            start = end + 1;\n+            if (PL_strcasecmp(start, \"set\") == 0)\n+                ppolicy->mSet = secLevel;\n             else\n-                classPolicy |= CLASS_HAS_SITE_POLICY;\n-            if (count > 4)\n-                classPolicy |= CLASS_HAS_ACCESSTYPE;\n-            mClassPolicies->Put(&classNameKey, NS_INT32_TO_PTR(classPolicy));\n+                ppolicy->mGet = secLevel;\n+        }\n+        else\n+        {\n+            if (ppolicy->mGet.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)\n+                ppolicy->mGet = secLevel;\n+            if (ppolicy->mSet.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)\n+                ppolicy->mSet = secLevel;\n         }\n     }\n+\n+    NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(prefCount, prefNames);\n+    if (currentPref < prefCount) // Loop exited early because of out-of-memory error\n+        return NS_ERROR_OUT_OF_MEMORY;\n     return NS_OK;\n }\n \n+\n nsresult\n nsScriptSecurityManager::PrincipalPrefNames(const char* pref,\n                                             char** grantedPref, char** deniedPref)\n@@ -2396,7 +2560,7 @@ nsScriptSecurityManager::InitPrincipals(PRUint32 aPrefCount, const char** aPrefN\n             continue;\n \n         nsXPIDLCString id;\n-        if (NS_FAILED(aSecurityPref->SecurityGetCharPref(aPrefNames[c], getter_Copies(id))))\n+        if (NS_FAILED(mSecurityPref->SecurityGetCharPref(aPrefNames[c], getter_Copies(id))))\n             return NS_ERROR_FAILURE;\n \n         nsXPIDLCString grantedPrefName;\n@@ -2410,17 +2574,17 @@ nsScriptSecurityManager::InitPrincipals(PRUint32 aPrefCount, const char** aPrefN\n             continue;\n \n         char* grantedList = nsnull;\n-        aSecurityPref->SecurityGetCharPref(grantedPrefName, &grantedList);\n+        mSecurityPref->SecurityGetCharPref(grantedPrefName, &grantedList);\n         char* deniedList = nsnull;\n-        aSecurityPref->SecurityGetCharPref(deniedPrefName, &deniedList);\n+        mSecurityPref->SecurityGetCharPref(deniedPrefName, &deniedList);\n \n         //-- Delete prefs if their value is the empty string\n         if ((!id || id[0] == '\\0') ||\n             ((!grantedList || grantedList[0] == '\\0') && (!deniedList || deniedList[0] == '\\0')))\n         {\n-            aSecurityPref->SecurityClearUserPref(aPrefNames[c]);\n-            aSecurityPref->SecurityClearUserPref(grantedPrefName);\n-            aSecurityPref->SecurityClearUserPref(deniedPrefName);\n+            mSecurityPref->SecurityClearUserPref(aPrefNames[c]);\n+            mSecurityPref->SecurityClearUserPref(grantedPrefName);\n+            mSecurityPref->SecurityClearUserPref(deniedPrefName);\n             PR_FREEIF(grantedList);\n             PR_FREEIF(deniedList);\n             continue;\n@@ -2475,16 +2639,18 @@ nsScriptSecurityManager::InitPrincipals(PRUint32 aPrefCount, const char** aPrefN\n     return NS_OK;\n }\n \n+const char* nsScriptSecurityManager::sJSEnabledPrefName = \"javascript.enabled\";\n+const char* nsScriptSecurityManager::sJSMailEnabledPrefName = \"javascript.allow.mailnews\";\n \n inline void\n nsScriptSecurityManager::JSEnabledPrefChanged(nsISecurityPref* aSecurityPref)\n {\n-    if (NS_FAILED(aSecurityPref->SecurityGetBoolPref(sJSEnabledPrefName,\n+    if (NS_FAILED(mSecurityPref->SecurityGetBoolPref(sJSEnabledPrefName,\n                                                      &mIsJavaScriptEnabled)))\n         // Default to enabled.\n         mIsJavaScriptEnabled = PR_TRUE;\n \n-    if (NS_FAILED(aSecurityPref->SecurityGetBoolPref(sJSMailEnabledPrefName,\n+    if (NS_FAILED(mSecurityPref->SecurityGetBoolPref(sJSMailEnabledPrefName,\n                                                      &mIsMailJavaScriptEnabled)))\n         // Default to enabled.\n         mIsMailJavaScriptEnabled = PR_TRUE;\n@@ -2496,38 +2662,36 @@ nsScriptSecurityManager::InitPrefs()\n     nsresult rv;\n     nsCOMPtr<nsIPrefService> prefService(do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));\n     NS_ENSURE_SUCCESS(rv, rv);\n-    nsCOMPtr<nsIPrefBranch> prefBranch;\n-    rv = prefService->GetBranch(nsnull, getter_AddRefs(prefBranch));\n+    rv = prefService->GetBranch(nsnull, getter_AddRefs(mPrefBranch));\n+    NS_ENSURE_SUCCESS(rv, rv);\n+    nsCOMPtr<nsIPrefBranchInternal> prefBranchInternal(do_QueryInterface(mPrefBranch, &rv));\n     NS_ENSURE_SUCCESS(rv, rv);\n-    mPrefBranchWeakRef = getter_AddRefs(NS_GetWeakReference(prefBranch));\n-    nsCOMPtr<nsIPrefBranchInternal> prefBranchInternal(do_QueryInterface(prefBranch, &rv));\n+    mSecurityPref = do_QueryInterface(mPrefBranch, &rv);\n     NS_ENSURE_SUCCESS(rv, rv);\n-    nsCOMPtr<nsISecurityPref> securityPref(do_QueryInterface(prefBranch));\n \n     // Set the initial value of the \"javascript.enabled\" prefs\n-    JSEnabledPrefChanged(securityPref);\n-    // set observer callbacks in case the value of the pref changes\n+    JSEnabledPrefChanged(mSecurityPref);\n+    // set observer callbacks in case the value of the prefs change\n     prefBranchInternal->AddObserver(sJSEnabledPrefName, this, PR_FALSE);\n     prefBranchInternal->AddObserver(sJSMailEnabledPrefName, this, PR_FALSE);\n     PRUint32 prefCount;\n     char** prefNames;\n \n-    //-- Initialize the policy database from prefs\n-    rv = prefBranch->GetChildList(sPolicyPrefix, &prefCount, &prefNames);\n-    if (NS_SUCCEEDED(rv) && prefCount > 0)\n-    {\n-        rv = InitPolicies(prefCount, (const char**)prefNames, securityPref);\n-        NS_ENSURE_SUCCESS(rv, rv);\n-        NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(prefCount, prefNames);\n-    }\n     //-- Set a callback for policy changes\n-    prefBranchInternal->AddObserver(sPolicyPrefix, this, PR_FALSE);\n+    // Registering the security manager as an observer to the\n+    // profile-after-change topic. We will build up the policy table\n+    // after the initial profile loads and after profile switches.\n+    nsCOMPtr<nsIObserverService> observerService\n+        (do_GetService(\"@mozilla.org/observer-service;1\", &rv));\n+    NS_ENSURE_SUCCESS(rv, rv);\n+    rv = observerService->AddObserver(this, sProfileChangeMsg, PR_FALSE);\n+    NS_ENSURE_SUCCESS(rv, rv);\n \n     //-- Initialize the principals database from prefs\n-    rv = prefBranch->GetChildList(sPrincipalPrefix, &prefCount, &prefNames);\n+    rv = mPrefBranch->GetChildList(sPrincipalPrefix, &prefCount, &prefNames);\n     if (NS_SUCCEEDED(rv) && prefCount > 0)\n     {\n-        rv = InitPrincipals(prefCount, (const char**)prefNames, securityPref);\n+        rv = InitPrincipals(prefCount, (const char**)prefNames, mSecurityPref);\n         NS_ENSURE_SUCCESS(rv, rv);\n         NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(prefCount, prefNames);\n     }\n@@ -2536,3 +2700,88 @@ nsScriptSecurityManager::InitPrefs()\n \n     return NS_OK;\n }\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// The following code prints the contents of the policy DB to the console.\n+#ifdef DEBUG_mstoltz\n+\n+//typedef PLDHashOperator\n+//(* PR_CALLBACK PLDHashEnumerator)(PLDHashTable *table, PLDHashEntryHdr *hdr,\n+//                                      PRUint32 number, void *arg);\n+PR_STATIC_CALLBACK(PLDHashOperator)\n+PrintPropertyPolicy(PLDHashTable *table, PLDHashEntryHdr *entry,\n+                    PRUint32 number, void *arg)\n+{\n+    PropertyPolicy* pp = (PropertyPolicy*)entry;\n+    nsCAutoString prop(\"        \");\n+    JSContext* cx = (JSContext*)arg;\n+    prop.AppendInt((PRUint32)pp->key);\n+    prop += ' ';\n+    prop.AppendWithConversion((PRUnichar*)JSValIDToString(cx, pp->key));\n+    prop += \": Get=\";\n+    if (SECURITY_ACCESS_LEVEL_FLAG(pp->mGet))\n+        prop.AppendInt(pp->mGet.level);\n+    else\n+        prop += pp->mGet.capability;\n+\n+    prop += \" Set=\";\n+    if (SECURITY_ACCESS_LEVEL_FLAG(pp->mSet))\n+        prop.AppendInt(pp->mSet.level);\n+    else\n+        prop += pp->mSet.capability;\n+        \n+    printf(\"%s.\\n\", prop.get());\n+    return PL_DHASH_NEXT;\n+}\n+\n+PR_STATIC_CALLBACK(PLDHashOperator)\n+PrintClassPolicy(PLDHashTable *table, PLDHashEntryHdr *entry,\n+                 PRUint32 number, void *arg)\n+{\n+    ClassPolicy* cp = (ClassPolicy*)entry;\n+    printf(\"    %s\\n\", cp->key);\n+\n+    PL_DHashTableEnumerate(&cp->mPolicy, PrintPropertyPolicy, arg);\n+    return PL_DHASH_NEXT;\n+}\n+\n+// typedef PRBool\n+// (*PR_CALLBACK nsHashtableEnumFunc)(nsHashKey *aKey, void *aData, void* aClosure);\n+PR_STATIC_CALLBACK(PRBool)\n+PrintDomainPolicy(nsHashKey *aKey, void *aData, void* aClosure)\n+{\n+    DomainEntry* de = (DomainEntry*)aData;\n+    printf(\"----------------------------\\n\");\n+    printf(\"Domain: %s Policy Name: %s.\\n\", de->mOrigin.get(),\n+           de->mPolicyName_DEBUG.get());\n+    PL_DHashTableEnumerate(de->mDomainPolicy, PrintClassPolicy, aClosure);\n+    return PR_TRUE;\n+}\n+\n+PR_STATIC_CALLBACK(PRBool)\n+PrintCapability(nsHashKey *aKey, void *aData, void* aClosure)\n+{\n+    char* cap = (char*)aData;\n+    printf(\"    %s.\\n\", cap);\n+    return PR_TRUE;\n+}\n+\n+void\n+nsScriptSecurityManager::PrintPolicyDB()\n+{\n+    printf(\"############## Security Policies ###############\\n\");\n+    if(mOriginToPolicyMap)\n+    {\n+        JSContext* cx = GetCurrentJSContext();\n+        printf(\"----------------------------\\n\");\n+        printf(\"Domain: Default.\\n\");\n+        PL_DHashTableEnumerate(mDefaultPolicy, PrintClassPolicy, (void*)cx);\n+        mOriginToPolicyMap->Enumerate(PrintDomainPolicy, (void*)cx);\n+    }\n+    printf(\"############ End Security Policies #############\\n\\n\");\n+    printf(\"############## Capabilities ###############\\n\");\n+    mCapabilities->Enumerate(PrintCapability);\n+    printf(\"############## End Capabilities ###############\\n\");\n+}\n+#endif\n+"},{"sha":"d2bb41526647b11101b311766a4a13eba1c092c4","filename":"caps/src/nsSecurityManagerFactory.cpp","status":"modified","additions":15,"deletions":2,"changes":17,"blob_url":"https://github.com/mozilla/gecko-dev/blob/4756b7169cc8c42ad32ab030c3137ddfd702d119/caps/src/nsSecurityManagerFactory.cpp","raw_url":"https://github.com/mozilla/gecko-dev/raw/4756b7169cc8c42ad32ab030c3137ddfd702d119/caps/src/nsSecurityManagerFactory.cpp","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/caps/src/nsSecurityManagerFactory.cpp?ref=4756b7169cc8c42ad32ab030c3137ddfd702d119","patch":"@@ -364,11 +364,17 @@ RegisterSecurityNameSet(nsIComponentManager *aCompMgr,\n                                   PR_TRUE, PR_TRUE, getter_Copies(previous));\n     NS_ENSURE_SUCCESS(rv, rv);\n \n+    rv = catman->AddCategoryEntry(\"app-startup\", \"service\",\n+                                  NS_SCRIPTSECURITYMANAGER_CONTRACTID,\n+                                  PR_TRUE, PR_TRUE,\n+                                  getter_Copies(previous));\n+    NS_ENSURE_SUCCESS(rv, rv);\n+\n     return rv;\n }\n \n \n-static const nsModuleComponentInfo components[] =\n+static const nsModuleComponentInfo capsComponentInfo[] =\n {\n     { NS_SCRIPTSECURITYMANAGER_CLASSNAME, \n       NS_SCRIPTSECURITYMANAGER_CID, \n@@ -451,5 +457,12 @@ static const nsModuleComponentInfo components[] =\n };\n \n \n-NS_IMPL_NSGETMODULE(nsSecurityManagerModule, components);\n+void PR_CALLBACK\n+CapsModuleDtor(nsIModule* thisModules)\n+{\n+    nsScriptSecurityManager::Shutdown();\n+}\n+\n+NS_IMPL_NSGETMODULE_WITH_DTOR(nsSecurityManagerModule, capsComponentInfo,\n+                              CapsModuleDtor);\n "},{"sha":"cf1361e69876dd18e8ef0bbc83695ef8b73c87b6","filename":"content/build/Makefile.in","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/mozilla/gecko-dev/blob/4756b7169cc8c42ad32ab030c3137ddfd702d119/content/build/Makefile.in","raw_url":"https://github.com/mozilla/gecko-dev/raw/4756b7169cc8c42ad32ab030c3137ddfd702d119/content/build/Makefile.in","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/content/build/Makefile.in?ref=4756b7169cc8c42ad32ab030c3137ddfd702d119","patch":"@@ -61,7 +61,8 @@ REQUIRES\t= xpcom \\\n \t\t  xuldoc \\\n \t\t  xultmpl \\\n \t\t  timer \\\n-      webbrwsr \\\n+\t\t  webbrwsr \\\n+\t\t  caps \\\n \t\t  $(NULL)\n \n CPPSRCS\t\t= \\"},{"sha":"cdafab09a4e1f12e30a4c4431c1062fc38b937b9","filename":"content/build/makefile.win","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/mozilla/gecko-dev/blob/4756b7169cc8c42ad32ab030c3137ddfd702d119/content/build/makefile.win","raw_url":"https://github.com/mozilla/gecko-dev/raw/4756b7169cc8c42ad32ab030c3137ddfd702d119/content/build/makefile.win","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/content/build/makefile.win?ref=4756b7169cc8c42ad32ab030c3137ddfd702d119","patch":"@@ -53,6 +53,7 @@ REQUIRES\t= xpcom \\\n \t\t  gfx \\\n \t\t  layout_xul \\\n \t\t  content_xul \\\n+\t\t  caps \\\n \t\t  $(NULL)\n \n LCFLAGS = \\"},{"sha":"9645ce6a114e4395d10c63be95b087d5fe59d915","filename":"content/build/nsContentModule.cpp","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/mozilla/gecko-dev/blob/4756b7169cc8c42ad32ab030c3137ddfd702d119/content/build/nsContentModule.cpp","raw_url":"https://github.com/mozilla/gecko-dev/raw/4756b7169cc8c42ad32ab030c3137ddfd702d119/content/build/nsContentModule.cpp","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/content/build/nsContentModule.cpp?ref=4756b7169cc8c42ad32ab030c3137ddfd702d119","patch":"@@ -49,6 +49,7 @@\n #include \"nsDOMCID.h\"\n #include \"nsCSSOMFactory.h\"\n #include \"nsEventStateManager.h\"\n+#include \"nsEventListenerManager.h\"\n #include \"nsGenericElement.h\"\n #include \"nsGenericDOMDataNode.h\"\n #include \"nsHTMLAtoms.h\"\n@@ -225,6 +226,7 @@ Shutdown(nsIModule* aSelf)\n   nsRange::Shutdown();\n   nsGenericElement::Shutdown();\n   nsGenericDOMDataNode::Shutdown();\n+  nsEventListenerManager::Shutdown();\n \n   // Release all of our atoms\n   nsColorNames::ReleaseTable();"},{"sha":"604512d671ac85a5fae52ecfe3e63a01a1b986c0","filename":"content/events/src/nsEventListenerManager.cpp","status":"modified","additions":13,"deletions":1,"changes":14,"blob_url":"https://github.com/mozilla/gecko-dev/blob/4756b7169cc8c42ad32ab030c3137ddfd702d119/content/events/src/nsEventListenerManager.cpp","raw_url":"https://github.com/mozilla/gecko-dev/raw/4756b7169cc8c42ad32ab030c3137ddfd702d119/content/events/src/nsEventListenerManager.cpp","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/content/events/src/nsEventListenerManager.cpp?ref=4756b7169cc8c42ad32ab030c3137ddfd702d119","patch":"@@ -180,6 +180,11 @@ nsresult nsEventListenerManager::RemoveAllListeners(PRBool aScriptOnly)\n   return NS_OK;\n }\n \n+void nsEventListenerManager::Shutdown()\n+{\n+    sAddListenerID = JSVAL_VOID;\n+}\n+\n NS_IMPL_ADDREF(nsEventListenerManager)\n NS_IMPL_RELEASE(nsEventListenerManager)\n \n@@ -951,6 +956,9 @@ nsEventListenerManager::RemoveScriptEventListener(nsIAtom *aName)\n   return result;\n }\n \n+jsval\n+nsEventListenerManager::sAddListenerID = JSVAL_VOID;\n+\n NS_IMETHODIMP\n nsEventListenerManager::RegisterScriptEventListener(nsIScriptContext *aContext,\n                                                     nsISupports *aObject, \n@@ -992,8 +1000,12 @@ nsEventListenerManager::RegisterScriptEventListener(nsIScriptContext *aContext,\n \n   nsCOMPtr<nsIClassInfo> classInfo = do_QueryInterface(aObject);\n \n+  if (sAddListenerID == JSVAL_VOID) {\n+    sAddListenerID = STRING_TO_JSVAL(::JS_InternString(cx, \"addEventListener\"));\n+  }\n+\n   if (NS_FAILED(rv = securityManager->CheckPropertyAccess(cx, jsobj,\n-                \"EventTarget\",\"addEventListener\",\n+                \"EventTarget\", sAddListenerID,\n                 nsIXPCSecurityManager::ACCESS_SET_PROPERTY))) {\n       // XXX set pending exception on the native call context?\n     return rv;"},{"sha":"6e64b0e415001a18fa5887808e135ac315be22f8","filename":"content/events/src/nsEventListenerManager.h","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/mozilla/gecko-dev/blob/4756b7169cc8c42ad32ab030c3137ddfd702d119/content/events/src/nsEventListenerManager.h","raw_url":"https://github.com/mozilla/gecko-dev/raw/4756b7169cc8c42ad32ab030c3137ddfd702d119/content/events/src/nsEventListenerManager.h","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/content/events/src/nsEventListenerManager.h?ref=4756b7169cc8c42ad32ab030c3137ddfd702d119","patch":"@@ -178,6 +178,8 @@ class nsEventListenerManager : public nsIEventListenerManager,\n   NS_IMETHOD GetListenerManager(nsIEventListenerManager** aInstancePtrResult);\n   NS_IMETHOD HandleEvent(nsIDOMEvent *aEvent);\n \n+  static void Shutdown();\n+\n protected:\n   nsresult HandleEventSubType(nsListenerStruct* aListenerStruct,\n                               nsIDOMEvent* aDOMEvent,\n@@ -217,6 +219,8 @@ class nsEventListenerManager : public nsIEventListenerManager,\n \n   nsCOMPtr<nsIPrincipal> mPrincipal;\n   nsISupports* mTarget;  //WEAK\n+\n+  static jsval sAddListenerID;\n };\n \n "},{"sha":"3f4757a303213b2db420fe550013ad09b5530f21","filename":"dom/src/base/nsDOMClassInfo.cpp","status":"modified","additions":12,"deletions":32,"changes":44,"blob_url":"https://github.com/mozilla/gecko-dev/blob/4756b7169cc8c42ad32ab030c3137ddfd702d119/dom/src/base/nsDOMClassInfo.cpp","raw_url":"https://github.com/mozilla/gecko-dev/raw/4756b7169cc8c42ad32ab030c3137ddfd702d119/dom/src/base/nsDOMClassInfo.cpp","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/dom/src/base/nsDOMClassInfo.cpp?ref=4756b7169cc8c42ad32ab030c3137ddfd702d119","patch":"@@ -871,6 +871,8 @@ JSString *nsDOMClassInfo::sOnresize_id        = nsnull;\n JSString *nsDOMClassInfo::sOnscroll_id        = nsnull;\n JSString *nsDOMClassInfo::sScrollIntoView_id  = nsnull;\n JSString *nsDOMClassInfo::sOpen_id            = nsnull;\n+JSString *nsDOMClassInfo::sItem_id            = nsnull;\n+JSString *nsDOMClassInfo::sEnumerate_id       = nsnull;\n \n const JSClass *nsDOMClassInfo::sObjectClass   = nsnull;\n \n@@ -940,6 +942,8 @@ nsDOMClassInfo::DefineStaticJSStrings(JSContext *cx)\n   sOnscroll_id       = ::JS_InternString(cx, \"onscroll\");\n   sScrollIntoView_id = ::JS_InternString(cx, \"scrollIntoView\");\n   sOpen_id           = ::JS_InternString(cx, \"open\");\n+  sItem_id           = ::JS_InternString(cx, \"item\");\n+  sEnumerate_id      = ::JS_InternString(cx, \"enumerateProperties\");\n \n   return NS_OK;\n }\n@@ -2391,7 +2395,7 @@ nsDOMClassInfo::Enumerate(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\n   // Ask the security manager if it's OK to enumerate\n   nsresult rv =\n     sSecMan->CheckPropertyAccess(cx, obj, sClassInfoData[mID].mName,\n-                                 \"enumerateProperties\",\n+                                 STRING_TO_JSVAL(sEnumerate_id),\n                                  nsIXPCSecurityManager::ACCESS_GET_PROPERTY);\n \n   if (NS_FAILED(rv)) {\n@@ -2441,45 +2445,20 @@ nsDOMClassInfo::Finalize(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\n   return NS_ERROR_UNEXPECTED;\n }\n \n-// Result of this function should not be freed.\n-static inline const PRUnichar *\n-JSValIDToString(JSContext *aJSContext, const jsval idval)\n-{\n-  JSString *str = JS_ValueToString(aJSContext, idval);\n-\n-  if(!str) {\n-    NS_ERROR(\"JS_ValueToString() returned null!\");\n-\n-    return nsnull;\n-  }\n-\n-  return NS_REINTERPRET_CAST(const PRUnichar*, JS_GetStringChars(str));\n-}\n-\n NS_IMETHODIMP\n nsDOMClassInfo::CheckAccess(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\n                             JSObject *obj, jsval id, PRUint32 mode,\n                             jsval *vp, PRBool *_retval)\n {\n   if ((mode == JSACC_WATCH || mode == JSACC_PROTO || mode == JSACC_PARENT) &&\n       sSecMan) {\n-    JSString *str = ::JS_ValueToString(cx, id);\n-\n-    if (!str)\n-      return NS_ERROR_UNEXPECTED;\n \n     JSObject *real_obj = nsnull;\n     nsresult rv = wrapper->GetJSObject(&real_obj);\n     NS_ENSURE_SUCCESS(rv, rv);\n \n-    NS_ConvertUCS2toUTF8\n-      prop_name(NS_REINTERPRET_CAST(const PRUnichar *,\n-                                    ::JS_GetStringChars(str)),\n-                ::JS_GetStringLength(str));\n-\n     rv =\n-      sSecMan->CheckPropertyAccess(cx, real_obj, sClassInfoData[mID].mName,\n-                                   prop_name.get(),\n+      sSecMan->CheckPropertyAccess(cx, real_obj, sClassInfoData[mID].mName, id,\n                                    nsIXPCSecurityManager::ACCESS_GET_PROPERTY);\n \n     if (NS_FAILED(rv)) {\n@@ -2629,6 +2608,8 @@ nsDOMClassInfo::ShutDown()\n   sOnscroll_id        = jsnullstring;\n   sScrollIntoView_id  = jsnullstring;\n   sOpen_id            = jsnullstring;\n+  sItem_id            = jsnullstring;\n+  sEnumerate_id       = jsnullstring;\n \n   NS_IF_RELEASE(sXPConnect);\n   NS_IF_RELEASE(sSecMan);\n@@ -2754,11 +2735,9 @@ nsWindowSH::doCheckPropertyAccess(JSContext *cx, JSObject *obj, jsval id,\n \n   JSObject *global = sgo->GetGlobalJSObject();\n \n-  NS_ConvertUCS2toUTF8 prop_name(JSValIDToString(cx, id));\n-\n   return sSecMan->CheckPropertyAccess(cx, global,\n                                       sClassInfoData[mID].mName,\n-                                      prop_name.get(), accessMode);\n+                                      id, accessMode);\n }\n \n NS_IMETHODIMP\n@@ -2943,7 +2922,7 @@ nsWindowSH::AddProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\n   }\n \n   nsresult rv = doCheckPropertyAccess(cx, obj, id, wrapper,\n-                               nsIXPCSecurityManager::ACCESS_SET_PROPERTY);\n+                                      nsIXPCSecurityManager::ACCESS_SET_PROPERTY);\n \n   if (NS_FAILED(rv)) {\n     // Security check failed. The security manager set a JS\n@@ -5231,7 +5210,8 @@ nsHistorySH::GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\n   }\n \n   nsresult rv =\n-    sSecMan->CheckPropertyAccess(cx, obj, sClassInfoData[mID].mName, \"item\",\n+    sSecMan->CheckPropertyAccess(cx, obj, sClassInfoData[mID].mName,\n+                                 STRING_TO_JSVAL(sItem_id),\n                                  nsIXPCSecurityManager::ACCESS_CALL_METHOD);\n \n   if (NS_FAILED(rv)) {"},{"sha":"047041f7343a1ee03f0dde5a3c7c1a7faac11216","filename":"dom/src/base/nsDOMClassInfo.h","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/mozilla/gecko-dev/blob/4756b7169cc8c42ad32ab030c3137ddfd702d119/dom/src/base/nsDOMClassInfo.h","raw_url":"https://github.com/mozilla/gecko-dev/raw/4756b7169cc8c42ad32ab030c3137ddfd702d119/dom/src/base/nsDOMClassInfo.h","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/dom/src/base/nsDOMClassInfo.h?ref=4756b7169cc8c42ad32ab030c3137ddfd702d119","patch":"@@ -185,6 +185,9 @@ class nsDOMClassInfo : public nsIXPCScriptable,\n   static JSString *sOnscroll_id;\n   static JSString *sScrollIntoView_id;\n   static JSString *sOpen_id;\n+  static JSString *sItem_id;\n+  static JSString *sEnumerate_id;\n+\n \n   static const JSClass *sObjectClass;\n };"},{"sha":"85bafcbb77a9b0062e6cb4f5ec3f02a02e30db25","filename":"dom/src/base/nsGlobalWindow.cpp","status":"modified","additions":11,"deletions":3,"changes":14,"blob_url":"https://github.com/mozilla/gecko-dev/blob/4756b7169cc8c42ad32ab030c3137ddfd702d119/dom/src/base/nsGlobalWindow.cpp","raw_url":"https://github.com/mozilla/gecko-dev/raw/4756b7169cc8c42ad32ab030c3137ddfd702d119/dom/src/base/nsGlobalWindow.cpp","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/dom/src/base/nsGlobalWindow.cpp?ref=4756b7169cc8c42ad32ab030c3137ddfd702d119","patch":"@@ -4620,6 +4620,7 @@ NavigatorImpl::~NavigatorImpl()\n {\n   NS_IF_RELEASE(mMimeTypes);\n   NS_IF_RELEASE(mPlugins);\n+  sPrefInternal_id = JSVAL_VOID;\n }\n \n //*****************************************************************************\n@@ -4949,6 +4950,9 @@ NavigatorImpl::TaintEnabled(PRBool *aReturn)\n   return NS_OK;\n }\n \n+jsval\n+NavigatorImpl::sPrefInternal_id = JSVAL_VOID;\n+\n NS_IMETHODIMP\n NavigatorImpl::Preference()\n {\n@@ -4985,16 +4989,20 @@ NavigatorImpl::Preference()\n   NS_ENSURE_SUCCESS(rv, rv);\n \n   //--Check to see if the caller is allowed to access prefs\n-  nsCOMPtr<nsIScriptSecurityManager> secMan =\n+  if (sPrefInternal_id = JSVAL_VOID)\n+    sPrefInternal_id = STRING_TO_JSVAL(::JS_InternString(cx, \"preferenceinternal\"));\n+\n+  nsCOMPtr<nsIScriptSecurityManager> secMan = \n       do_GetService(\"@mozilla.org/scriptsecuritymanager;1\", &rv);\n   NS_ENSURE_SUCCESS(rv, rv);\n   PRUint32 action;\n   if (argc == 1)\n       action = nsIXPCSecurityManager::ACCESS_GET_PROPERTY;\n   else\n       action = nsIXPCSecurityManager::ACCESS_SET_PROPERTY;\n-  rv = secMan->CheckPropertyAccess(cx, nsnull,\n-                                   \"Navigator\", \"preferenceinternal\", action);\n+\n+  rv = secMan->CheckPropertyAccess(cx, nsnull, \n+                                   \"Navigator\", sPrefInternal_id, action);\n   if (NS_FAILED(rv))\n   {\n       return NS_OK;"},{"sha":"23340e4cae600ba87e7efee6568bb81754a33058","filename":"dom/src/base/nsGlobalWindow.h","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/mozilla/gecko-dev/blob/4756b7169cc8c42ad32ab030c3137ddfd702d119/dom/src/base/nsGlobalWindow.h","raw_url":"https://github.com/mozilla/gecko-dev/raw/4756b7169cc8c42ad32ab030c3137ddfd702d119/dom/src/base/nsGlobalWindow.h","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/dom/src/base/nsGlobalWindow.h?ref=4756b7169cc8c42ad32ab030c3137ddfd702d119","patch":"@@ -373,6 +373,8 @@ class NavigatorImpl : public nsIDOMNavigator,\n   MimeTypeArrayImpl* mMimeTypes;\n   PluginArrayImpl* mPlugins;\n   nsIDocShell* mDocShell; // weak reference\n+\n+  static jsval       sPrefInternal_id;\n };\n \n class nsIURI;"},{"sha":"3a87667174f7c33c5b674633548b8d4d6fcfc2fe","filename":"modules/libpref/src/init/all.js","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/mozilla/gecko-dev/blob/4756b7169cc8c42ad32ab030c3137ddfd702d119/modules/libpref/src/init/all.js","raw_url":"https://github.com/mozilla/gecko-dev/raw/4756b7169cc8c42ad32ab030c3137ddfd702d119/modules/libpref/src/init/all.js","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/modules/libpref/src/init/all.js?ref=4756b7169cc8c42ad32ab030c3137ddfd702d119","patch":"@@ -237,6 +237,9 @@ pref(\"print.print_edge_bottom\", 0); // 1/100 of an inch\n // Editing these may create a security risk - be sure you know what you're doing\n //pref(\"capability.policy.default.barprop.visible.set\", \"UniversalBrowserWrite\");\n \n+pref(\"capability.policy.default_policynames\", \"mailnews\");\n+pref(\"capability.policy.policynames\", \"\");\n+\n pref(\"capability.policy.default.DOMException.code\", \"allAccess\");\n pref(\"capability.policy.default.DOMException.message\", \"allAccess\");\n pref(\"capability.policy.default.DOMException.name\", \"allAccess\");"}]},"blames":["8c0cd58b","f7460d02","d6438773","0865f1cd","f3d9b0ca","11248436","142ac52e","f7460d02","b65db40d","e5e279fe","51950011","2b6e6516","49c0102c","7d053b70","d1a7bfa8","b00270be","11248436d","1b252b2e3","f7460d026","aa4fec2b6","5014545a0","7d053b70b","2d8e12375","9acf60477","d21c5596f","e5c170a04","7cd400a26","eef6de843","2b4b436f5","dbd7fed5b","9bb975256","e5e279fe3","eb23e7629","727f312b3","25276e6b9","99fc30ce4","33c811017","8c0cd58b3","519500116","f4de90c79","880f5907b","ddb2282b6","8507a58ec","d89d87531","59c995612","0865f1cda","5b4b0169a","3f22e806a","a488d900b","4e73efe1f","d64387736","f1137e89e","2b6e6516d","786f23476","ec9d253f5","9d35ed31a","1b5e7659c","c8128a576","5a6317b8a","e0fc50a6d","e2560fe87","e91f8a147","8256c128d","24778bda7","8986a0ad1","5567200a7","49c0102cd","01d4c02b0","51842ef45","dbd7fed5","f7460d02","49c0102c","38e1d06d","dc401872","2ecc969e","de35f432","d1a7bfa8","de35f432","de8d58f0","8e721c4e","9abf7984","362692e3","797497c5","26b7f822","696b13b9","a0d1b311","f7460d02","8507a58e","872a6695","696b13b9","dd88339f","26b7f822","d9f3df81","51842ef4","a743e2b3","ea706038","d0755aca","c3ef8e1f","7ad971a0","f489a29b","da57450d","030da7b1","cc8dda0f","0760bc34","ea706038","d0755aca","c3ef8e1f","7ad971a0","a7912724","d4694632","840c8350","052759e5","ea706038","f0e8255e","4d99bea1","742e999c","2c65aece","729c07b2","35447f56","b1f46023"]}