Index: caps/include/nsScriptSecurityManager.h
===================================================================
RCS file: /cvsroot/mozilla/caps/include/nsScriptSecurityManager.h,v
retrieving revision 1.69
diff -p -u -1 -0 -r1.69 nsScriptSecurityManager.h
--- caps/include/nsScriptSecurityManager.h	26 Jun 2003 03:26:59 -0000	1.69
+++ caps/include/nsScriptSecurityManager.h	1 Jul 2003 00:40:34 -0000
@@ -38,68 +38,73 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef _NS_SCRIPT_SECURITY_MANAGER_H_
 #define _NS_SCRIPT_SECURITY_MANAGER_H_
 
 #include "nsIScriptSecurityManager.h"
 #include "nsIPrincipal.h"
 #include "jsapi.h"
 #include "jsdbgapi.h"
 #include "nsIXPCSecurityManager.h"
+#include "nsInterfaceHashtable.h"
 #include "nsHashtable.h"
 #include "nsCOMPtr.h"
 #include "nsIPrefService.h"
 #include "nsISecurityPref.h"
 #include "nsIJSContextStack.h"
 #include "nsIObserver.h"
 #include "pldhash.h"
 #include "plstr.h"
 
 class nsIDocShell;
 class nsString;
 class nsIClassInfo;
 class nsSystemPrincipal;
 struct ClassPolicy;
 
 /////////////////////
 // nsIPrincipalKey //
 /////////////////////
 
-class nsIPrincipalKey : public nsHashKey {
+class NS_COM nsIPrincipalKey : public PLDHashEntryHdr {
 public:
-    nsIPrincipalKey(nsIPrincipal* key) {
-        mKey = key;
-        NS_IF_ADDREF(mKey);
-    }
-    
-    ~nsIPrincipalKey(void) {
-        NS_IF_RELEASE(mKey);
-    }
+    typedef nsIPrincipal* KeyType;
+    typedef nsIPrincipal* KeyTypePointer;
     
-    PRUint32 HashCode(void) const {
-        PRUint32 hash;
-        mKey->HashValue(&hash);
-        return hash;
-    }
+    nsIPrincipalKey(const nsIPrincipal* key) :
+        mKey(NS_CONST_CAST(nsIPrincipal*, key)) { }
+
+    nsIPrincipalKey(const nsIPrincipalKey& toCopy) :
+        mKey(toCopy.mKey) { } 
     
-    PRBool Equals(const nsHashKey* aKey) const {
+    ~nsIPrincipalKey() { }
+
+    KeyType GetKey() const { return mKey; }
+    KeyTypePointer GetKeyPointer() const { return mKey; }
+
+    PRBool KeyEquals(KeyTypePointer aKey) const {
         PRBool eq;
-        mKey->Equals(((nsIPrincipalKey*) aKey)->mKey, &eq);
+        mKey->Equals(aKey, &eq);
         return eq;
     }
-    
-    nsHashKey *Clone(void) const {
-        return new nsIPrincipalKey(mKey);
+
+    static KeyTypePointer KeyToPointer(KeyType aKey) { return aKey; }
+    static PLDHashNumber HashKey(KeyTypePointer aKey) {
+        PRUint32 hash;
+        aKey->HashValue(&hash);
+        return PLDHashNumber(hash);
     }
 
-protected:
-    nsIPrincipal* mKey;
+    enum { ALLOW_MEMMOVE = PR_TRUE };
+
+private:
+    nsCOMPtr<nsIPrincipal> mKey;
 };
 
 ////////////////////
 // Policy Storage //
 ////////////////////
 
 // Property Policy
 union SecurityLevel
 {
     long     level;
@@ -412,21 +417,21 @@ private:
     static const char* sJSMailEnabledPrefName;
 
     nsObjectHashtable* mOriginToPolicyMap;
     DomainPolicy* mDefaultPolicy;
     nsObjectHashtable* mCapabilities;
 
     nsCOMPtr<nsIPrefBranch> mPrefBranch;
     nsCOMPtr<nsISecurityPref> mSecurityPref;
     nsIPrincipal* mSystemPrincipal;
     nsCOMPtr<nsIPrincipal> mSystemCertificate;
-    nsSupportsHashtable* mPrincipals;
+    nsInterfaceHashtable<nsIPrincipalKey, nsIPrincipal>* mPrincipals;
     PRBool mIsJavaScriptEnabled;
     PRBool mIsMailJavaScriptEnabled;
     PRBool mIsWritingPrefs;
     nsCOMPtr<nsIThreadJSContextStack> mJSContextStack;
     PRBool mNameSetRegistered;
     PRBool mPolicyPrefsChanged;
 #ifdef XPC_IDISPATCH_SUPPORT    
     PRBool mXPCDefaultGrantAll;
     static const char* sXPCDefaultGrantAllName;
 #endif
Index: caps/src/nsScriptSecurityManager.cpp
===================================================================
RCS file: /cvsroot/mozilla/caps/src/nsScriptSecurityManager.cpp,v
retrieving revision 1.210
diff -p -u -1 -0 -r1.210 nsScriptSecurityManager.cpp
--- caps/src/nsScriptSecurityManager.cpp	27 Jun 2003 03:10:49 -0000	1.210
+++ caps/src/nsScriptSecurityManager.cpp	1 Jul 2003 00:40:40 -0000
@@ -1680,22 +1680,22 @@ nsScriptSecurityManager::GetCertificateP
         NS_RELEASE(certificate);
         return NS_ERROR_FAILURE;
     }
     nsCOMPtr<nsIPrincipal> principal(do_QueryInterface((nsBasePrincipal*)certificate, &rv));
     NS_RELEASE(certificate);
     if (NS_FAILED(rv)) return rv;
 
     if (mPrincipals)
     {
         // Check to see if we already have this principal.
-        nsIPrincipalKey key(principal);
-        nsCOMPtr<nsIPrincipal> fromTable = (nsIPrincipal *) mPrincipals->Get(&key);
+        nsCOMPtr<nsIPrincipal> fromTable;
+        mPrincipals->Get(principal, getter_AddRefs(fromTable));
         if (fromTable)
             principal = fromTable;
     }
 
     //-- Bundle this certificate principal into an aggregate principal
     nsAggregatePrincipal* agg = new nsAggregatePrincipal();
     if (!agg) return NS_ERROR_OUT_OF_MEMORY;
     rv = agg->SetCertificate(principal);
     if (NS_FAILED(rv)) return rv;
     principal = do_QueryInterface((nsBasePrincipal*)agg, &rv);
@@ -1729,38 +1729,37 @@ nsScriptSecurityManager::GetCodebasePrin
                                               nsIPrincipal **result)
 {
     nsresult rv;
     nsCOMPtr<nsIPrincipal> principal;
     rv = CreateCodebasePrincipal(aURI, getter_AddRefs(principal));
     if (NS_FAILED(rv)) return rv;
 
     if (mPrincipals)
     {
         //-- Check to see if we already have this principal.
-        nsIPrincipalKey key(principal);
-        nsCOMPtr<nsIPrincipal> fromTable = (nsIPrincipal *) mPrincipals->Get(&key);
+        nsCOMPtr<nsIPrincipal> fromTable;
+        mPrincipals->Get(principal, getter_AddRefs(fromTable));
         if (fromTable)
             principal = fromTable;
         else //-- Check to see if we have a more general principal
         {
             nsCOMPtr<nsICodebasePrincipal> codebasePrin(do_QueryInterface(principal));
             nsXPIDLCString originUrl;
             rv = codebasePrin->GetOrigin(getter_Copies(originUrl));
             if (NS_FAILED(rv)) return rv;
             nsCOMPtr<nsIURI> newURI;
             rv = NS_NewURI(getter_AddRefs(newURI), originUrl, nsnull);
             if (NS_FAILED(rv)) return rv;
             nsCOMPtr<nsIPrincipal> principal2;
             rv = CreateCodebasePrincipal(newURI, getter_AddRefs(principal2));
             if (NS_FAILED(rv)) return rv;
-             nsIPrincipalKey key2(principal2);
-                fromTable = (nsIPrincipal *) mPrincipals->Get(&key2);
+            mPrincipals->Get(principal2, getter_AddRefs(fromTable));
             if (fromTable)
                 principal = fromTable;
         }		
     }
 
     //-- Bundle this codebase principal into an aggregate principal
     nsAggregatePrincipal* agg = new nsAggregatePrincipal();
     if (!agg) return NS_ERROR_OUT_OF_MEMORY;
     rv = agg->SetCodebase(principal);
     if (NS_FAILED(rv)) return rv;
@@ -1993,26 +1992,31 @@ nsScriptSecurityManager::SavePrincipal(n
     nsresult rv;
     nsCOMPtr<nsIPrincipal> persistent = aToSave;
     nsCOMPtr<nsIAggregatePrincipal> aggregate(do_QueryInterface(aToSave, &rv));
     if (NS_SUCCEEDED(rv))
         if (NS_FAILED(aggregate->GetPrimaryChild(getter_AddRefs(persistent))))
             return NS_ERROR_FAILURE;
 
     //-- Save to mPrincipals
     if (!mPrincipals)
     {
-        mPrincipals = new nsSupportsHashtable(31);
+        mPrincipals = new nsInterfaceHashtable<nsIPrincipalKey, nsIPrincipal>();
         if (!mPrincipals)
             return NS_ERROR_OUT_OF_MEMORY;
+        PRBool inited = mPrincipals->Init(31);
+        if (!inited) {
+            delete mPrincipals;
+            mPrincipals = nsnull;
+            return NS_ERROR_OUT_OF_MEMORY;
+        }
     }
-    nsIPrincipalKey key(persistent);
-    mPrincipals->Put(&key, persistent);
+    mPrincipals->Put(persistent, persistent);
 
     //-- Save to prefs
     nsXPIDLCString idPrefName;
     nsXPIDLCString id;
     nsXPIDLCString grantedList;
     nsXPIDLCString deniedList;
     rv = persistent->GetPreferences(getter_Copies(idPrefName),
                                     getter_Copies(id),
                                     getter_Copies(grantedList),
                                     getter_Copies(deniedList));
@@ -3131,26 +3135,31 @@ nsScriptSecurityManager::InitPrincipals(
                 NS_RELEASE(codebase);
             }
         }
         PR_FREEIF(grantedList);
         PR_FREEIF(deniedList);
 
         if (principal)
         {
             if (!mPrincipals)
             {
-                mPrincipals = new nsSupportsHashtable(31);
+                mPrincipals = new nsInterfaceHashtable<nsIPrincipalKey, nsIPrincipal>();
                 if (!mPrincipals)
                     return NS_ERROR_OUT_OF_MEMORY;
+                PRBool inited = mPrincipals->Init(31);
+                if (!inited) {
+                    delete mPrincipals;
+                    mPrincipals = nsnull;
+                    return NS_ERROR_OUT_OF_MEMORY;
+                }
             }
-            nsIPrincipalKey key(principal);
-            mPrincipals->Put(&key, principal);
+            mPrincipals->Put(principal, principal);
         }
     }
     return NS_OK;
 }
 
 const char* nsScriptSecurityManager::sJSEnabledPrefName = "javascript.enabled";
 const char* nsScriptSecurityManager::sJSMailEnabledPrefName = "javascript.allow.mailnews";
 #ifdef XPC_IDISPATCH_SUPPORT
 const char* nsScriptSecurityManager::sXPCDefaultGrantAllName =
                 "security.classID.allowByDefault";
