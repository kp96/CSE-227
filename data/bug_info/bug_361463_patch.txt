Index: src/formfill/KeychainItem.h
===================================================================
RCS file: /cvsroot/mozilla/camino/src/formfill/KeychainItem.h,v
retrieving revision 1.1.2.2
diff -u -8 -r1.1.2.2 KeychainItem.h
--- src/formfill/KeychainItem.h	27 Dec 2006 18:40:31 -0000	1.1.2.2
+++ src/formfill/KeychainItem.h	9 Feb 2007 15:45:54 -0000
@@ -43,16 +43,17 @@
 {
  @private
   SecKeychainItemRef mKeychainItemRef; // strong
   BOOL mDataLoaded;
   NSString* mUsername;                 // strong
   NSString* mPassword;                 // strong
   NSString* mHost;                     // strong
   NSString* mComment;                  // strong
+  NSArray* mSecurityDomains;           // strong
   SecProtocolType mPort;
   SecProtocolType mProtocol;
   SecAuthenticationType mAuthenticationType;
   OSType mCreator;
 }
 
 // Returns the first keychain item matching the given criteria.
 + (KeychainItem*)keychainItemForHost:(NSString*)host
@@ -86,12 +87,14 @@
 - (SecProtocolType)protocol;
 - (void)setProtocol:(SecProtocolType)protocol;
 - (SecAuthenticationType)authenticationType;
 - (void)setAuthenticationType:(SecAuthenticationType)authType;
 - (OSType)creator;
 - (void)setCreator:(OSType)creator;
 - (NSString*)comment;
 - (void)setComment:(NSString*)comment;
+- (void)setSecurityDomains:(NSArray*)securityDomains;
+- (NSArray*)securityDomains;
 
 - (void)removeFromKeychain;
 
 @end
Index: src/formfill/KeychainItem.m
===================================================================
RCS file: /cvsroot/mozilla/camino/src/formfill/KeychainItem.m,v
retrieving revision 1.1.2.3
diff -u -8 -r1.1.2.3 KeychainItem.m
--- src/formfill/KeychainItem.m	29 Jan 2007 17:33:16 -0000	1.1.2.3
+++ src/formfill/KeychainItem.m	9 Feb 2007 15:45:54 -0000
@@ -40,16 +40,18 @@
 
 @interface KeychainItem(Private)
 - (KeychainItem*)initWithRef:(SecKeychainItemRef)ref;
 - (void)loadKeychainData;
 - (BOOL)setAttributeType:(SecKeychainAttrType)type toString:(NSString*)value;
 - (BOOL)setAttributeType:(SecKeychainAttrType)type toValue:(void*)valuePtr withLength:(UInt32)length;
 @end
 
+NSString* const kSecurityDomainSeparator = @";";
+
 @implementation KeychainItem
 
 + (KeychainItem*)keychainItemForHost:(NSString*)host
                                 port:(UInt16)port
                             protocol:(SecProtocolType)protocol
                   authenticationType:(SecAuthenticationType)authType
 {
   SecKeychainItemRef itemRef;
@@ -166,32 +168,34 @@
 - (void)dealloc
 {
   if (mKeychainItemRef)
     CFRelease(mKeychainItemRef);
   [mUsername release];
   [mPassword release];
   [mHost release];
   [mComment release];
+  [mSecurityDomains release];
   [super dealloc];
 }
 
 - (void)loadKeychainData
 {
   if (!mKeychainItemRef)
     return;
   SecKeychainAttributeInfo attrInfo;
-  UInt32 tags[7];
+  UInt32 tags[8];
   tags[0] = kSecAccountItemAttr;
   tags[1] = kSecServerItemAttr;
   tags[2] = kSecPortItemAttr;
   tags[3] = kSecProtocolItemAttr;
   tags[4] = kSecAuthenticationTypeItemAttr;
-  tags[5] = kSecCreatorItemAttr;
-  tags[6] = kSecCommentItemAttr;
+  tags[5] = kSecSecurityDomainItemAttr;
+  tags[6] = kSecCreatorItemAttr;
+  tags[7] = kSecCommentItemAttr;
   attrInfo.count = sizeof(tags)/sizeof(UInt32);
   attrInfo.tag = tags;
   attrInfo.format = NULL;
 
   SecKeychainAttributeList *attrList;
   UInt32 passwordLength;
   char* passwordData;
   OSStatus result = SecKeychainItemCopyAttributesAndData(mKeychainItemRef, &attrInfo, NULL, &attrList,
@@ -200,23 +204,26 @@
   [mUsername autorelease];
   mUsername = nil;
   [mPassword autorelease];
   mPassword = nil;
   [mHost autorelease];
   mHost = nil;
   [mComment autorelease];
   mComment = nil;
+  [mSecurityDomains autorelease];
+  mSecurityDomains = nil;
 
   if (result != noErr) {
     NSLog(@"Couldn't load keychain data");
     mUsername = [[NSString alloc] init];
     mPassword = [[NSString alloc] init];
     mHost = [[NSString alloc] init];
     mComment = [[NSString alloc] init];
+    mSecurityDomains = [[NSArray alloc] init];
     return;
   }
 
   for (unsigned int i = 0; i < attrList->count; i++) {
     SecKeychainAttribute attr = attrList->attr[i];
     if (attr.tag == kSecAccountItemAttr)
       mUsername = [[NSString alloc] initWithBytes:(char*)(attr.data) length:attr.length encoding:NSUTF8StringEncoding];
     else if (attr.tag == kSecServerItemAttr)
@@ -226,16 +233,23 @@
     else if (attr.tag == kSecPortItemAttr)
       mPort = *((UInt16*)(attr.data));
     else if (attr.tag == kSecProtocolItemAttr)
       mProtocol = *((SecProtocolType*)(attr.data));
     else if (attr.tag == kSecAuthenticationTypeItemAttr)
       mAuthenticationType = *((SecAuthenticationType*)(attr.data));
     else if (attr.tag == kSecCreatorItemAttr)
       mCreator = attr.data ? *((OSType*)(attr.data)) : 0;
+    else if (attr.tag == kSecSecurityDomainItemAttr) {
+      NSString* domainsString = [[[NSString alloc] initWithBytes:(char*)(attr.data) length:attr.length encoding:NSUTF8StringEncoding] autorelease];
+      if ([domainsString isEqualToString:@""])
+        mSecurityDomains = [[NSArray alloc] init];
+      else
+        mSecurityDomains = [[domainsString componentsSeparatedByString:kSecurityDomainSeparator] retain];
+    }
   }
   mPassword = [[NSString alloc] initWithBytes:passwordData length:passwordLength encoding:NSUTF8StringEncoding];
   SecKeychainItemFreeAttributesAndData(attrList, (void*)passwordData);
   mDataLoaded = YES;
 }
 
 - (NSString*)username
 {
@@ -364,16 +378,36 @@
     [mComment autorelease];
     mComment = [comment copy];
   }
   else {
     NSLog(@"Couldn't update keychain item comment");
   }
 }
 
+ - (void)setSecurityDomains:(NSArray*)securityDomains
+{
+  NSString* domainsString = [securityDomains componentsJoinedByString:kSecurityDomainSeparator];
+  if([self setAttributeType:kSecSecurityDomainItemAttr toString:domainsString]) {
+    [mSecurityDomains autorelease];
+    mSecurityDomains = [securityDomains retain];
+  }
+  else {
+    NSLog(@"Couldn't update keychain item security domains");
+  }
+}
+ 
+- (NSArray*)securityDomains
+{
+  if (!mDataLoaded)
+    [self loadKeychainData];
+  return mSecurityDomains;
+}
+ 
+
 - (BOOL)setAttributeType:(SecKeychainAttrType)type toString:(NSString*)value {
   const char* cString = [value UTF8String];
   UInt32 length = cString ? strlen(cString) : 0;
   return [self setAttributeType:type toValue:(void*)cString withLength:length];
 }
 
 - (BOOL)setAttributeType:(SecKeychainAttrType)type toValue:(void*)valuePtr withLength:(UInt32)length
 {
Index: src/formfill/KeychainService.h
===================================================================
RCS file: /cvsroot/mozilla/camino/src/formfill/KeychainService.h,v
retrieving revision 1.1.2.3
diff -u -8 -r1.1.2.3 KeychainService.h
--- src/formfill/KeychainService.h	27 Dec 2006 18:40:35 -0000	1.1.2.3
+++ src/formfill/KeychainService.h	9 Feb 2007 15:45:54 -0000
@@ -53,41 +53,44 @@
 
 enum KeychainPromptResult { kSave, kDontRemember, kNeverRemember } ;
 
 @class CHBrowserView;
 @class KeychainItem;
 
 @interface KeychainService : NSObject
 {
-  IBOutlet id confirmStorePasswordPanel;
-  IBOutlet id confirmChangePasswordPanel;
+  IBOutlet id mConfirmStorePasswordPanel;
+  IBOutlet id mConfirmChangePasswordPanel;
+  IBOutlet id mConfirmFillPasswordPanel;
 
   BOOL mFormPasswordFillIsEnabled;
 
   nsIObserver* mFormSubmitObserver;
 }
 
 + (KeychainService*)instance;
 - (void)shutdown:(id)sender;
 
 - (IBAction)hitButtonOK:(id)sender;
 - (IBAction)hitButtonCancel:(id)sender;
 - (IBAction)hitButtonOther:(id)sender;
 
 - (KeychainPromptResult)confirmStorePassword:(NSWindow*)parent;
-- (BOOL)confirmChangedPassword:(NSWindow*)parent;
+- (BOOL)confirmChangePassword:(NSWindow*)parent;
+- (BOOL)confirmFillPassword:(NSWindow*)parent;
 
 - (KeychainItem*)findKeychainEntryForHost:(NSString*)host
                                      port:(PRInt32)port
                                    scheme:(NSString*)scheme
                                    isForm:(BOOL)isForm;
 - (void)storeUsername:(NSString*)username
              password:(NSString*)password
               forHost:(NSString*)host
+       securityDomain:(NSString*)host
                  port:(PRInt32)port
                scheme:(NSString*)scheme
                isForm:(BOOL)isForm;
 - (void)updateKeychainEntry:(KeychainItem*)keychainItem
                withUsername:(NSString*)username
                    password:(NSString*)password
                      scheme:(NSString*)scheme
                      isForm:(BOOL)isForm;
@@ -159,23 +162,16 @@
   KeychainFormSubmitObserver();
   virtual ~KeychainFormSubmitObserver();
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIOBSERVER
 
   // NS_DECL_NSIFORMSUBMITOBSERVER
   NS_IMETHOD Notify(nsIContent* formNode, nsIDOMWindowInternal* window, nsIURI* actionURL, PRBool* cancelSubmit);
-
-private:
-
-  static KeychainPromptResult CheckStorePasswordYN(nsIDOMWindowInternal*);
-  static BOOL CheckChangeDataYN(nsIDOMWindowInternal*);
-  
-  static NSWindow* GetNSWindow(nsIDOMWindowInternal* inWindow);
 };
 
 //
 // Keychain browser listener to auto fill username/passwords.
 //
 @interface KeychainBrowserListener : NSObject<CHBrowserListener>
 {
   CHBrowserView* mBrowserView;
Index: src/formfill/KeychainService.mm
===================================================================
RCS file: /cvsroot/mozilla/camino/src/formfill/KeychainService.mm,v
retrieving revision 1.1.2.4
diff -u -8 -r1.1.2.4 KeychainService.mm
--- src/formfill/KeychainService.mm	27 Dec 2006 18:40:37 -0000	1.1.2.4
+++ src/formfill/KeychainService.mm	9 Feb 2007 15:45:55 -0000
@@ -86,16 +86,19 @@
 // from CHBrowserService.h
 extern NSString* const XPCOMShutDownNotificationName;
 
 
 nsresult
 FindUsernamePasswordFields(nsIDOMHTMLFormElement* inFormElement, nsIDOMHTMLInputElement** outUsername,
                            nsIDOMHTMLInputElement** outPassword, PRBool inStopWhenFound);
 
+NSWindow*
+GetNSWindow(nsIDOMWindow* inWindow);
+
 @interface KeychainService(Private)
 - (KeychainItem*)findLegacyKeychainEntryForHost:(NSString*)host port:(PRInt32)port;
 @end
 
 @implementation KeychainService
 
 static KeychainService *sInstance = nil;
 static const char* const gUseKeychainPref = "chimera.store_passwords_with_keychain";
@@ -255,32 +258,35 @@
     [item setAuthenticationType:kSecAuthenticationTypeHTTPDigest];
   }
   return item;
 }
 
 - (void)storeUsername:(NSString*)username
              password:(NSString*)password
               forHost:(NSString*)host
+       securityDomain:(NSString*)securityDomain
                  port:(PRInt32)port
                scheme:(NSString*)scheme
                isForm:(BOOL)isForm
 {
   if (port == -1)
     port = kAnyPort;
   SecProtocolType protocol = [scheme isEqualToString:@"https"] ? kSecProtocolTypeHTTPS : kSecProtocolTypeHTTP;
   SecAuthenticationType authType = isForm ? kSecAuthenticationTypeHTMLForm : kSecAuthenticationTypeDefault;
 
   KeychainItem* newItem = [KeychainItem addKeychainItemForHost:host
                                                           port:(UInt16)port
                                                       protocol:protocol
                                             authenticationType:authType
                                                   withUsername:username
                                                       password:password];
   [newItem setCreator:kCaminoKeychainCreatorCode];
+  if (securityDomain)
+    [newItem setSecurityDomains:[NSArray arrayWithObject:securityDomain]];
 }
 
 // Stores changes to a site's stored account. Because we don't handle multiple accounts, we want to
 // allow users to store an acccount in Camino that isn't the one we pick up from Safari, so for
 // password updates we update the existing item, but for username updates we make a new item if
 // the one we were using wasn't Camino-created.
 - (void)updateKeychainEntry:(KeychainItem*)keychainItem
                withUsername:(NSString*)username
@@ -367,43 +373,57 @@
 // confirmStorePassword:
 //
 // Puts up a dialog when the keychain doesn't yet have an entry from
 // this site asking to store it, forget it this once, or mark the site
 // on a deny list so we never ask again.
 //
 - (KeychainPromptResult)confirmStorePassword:(NSWindow*)parent
 {
-  int result = [NSApp runModalForWindow:confirmStorePasswordPanel relativeToWindow:parent];
-  [confirmStorePasswordPanel close];
+  int result = [NSApp runModalForWindow:mConfirmStorePasswordPanel relativeToWindow:parent];
+  [mConfirmStorePasswordPanel close];
   
   KeychainPromptResult keychainAction = kDontRemember;
   switch (result) {
     case NSAlertDefaultReturn:    keychainAction = kSave;          break;
     default:
     case NSAlertAlternateReturn:  keychainAction = kDontRemember;  break;
     case NSAlertOtherReturn:      keychainAction = kNeverRemember; break;
   }
 
   return keychainAction;
 }
 
 //
-// confirmChangedPassword:
+// confirmChangePassword:
 //
 // The password stored in the keychain differs from what the user typed
 // in. Ask what they want to do to resolve the issue.
 //
-- (BOOL)confirmChangedPassword:(NSWindow*)parent
+- (BOOL)confirmChangePassword:(NSWindow*)parent
 {
-  int result = [NSApp runModalForWindow:confirmChangePasswordPanel relativeToWindow:parent];
-  [confirmChangePasswordPanel close];
+  int result = [NSApp runModalForWindow:mConfirmChangePasswordPanel relativeToWindow:parent];
+  [mConfirmChangePasswordPanel close];
   return (result == NSAlertDefaultReturn);
 }
 
+//
+// confirmFillPassword:
+//
+// The password stored in the keychain has an action domain that
+// doesn't match the stored value; ask the user whether to fill.
+//
+- (BOOL)confirmFillPassword:(NSWindow*)parent
+{
+  int result = [NSApp runModalForWindow:mConfirmFillPasswordPanel relativeToWindow:parent];
+  [mConfirmFillPasswordPanel close];
+  // Default is not to fill
+  return (result != NSAlertDefaultReturn);
+}
+
 
 - (void)addHostToDenyList:(NSString*)host
 {
   [[KeychainDenyList instance] addHost:host];
 }
 
 - (BOOL)isHostInDenyList:(NSString*)host
 {
@@ -632,17 +652,17 @@
 
   KeychainService* keychain = [KeychainService instance];
   KeychainItem* existingEntry = [keychain findKeychainEntryForHost:(NSString*)host port:port scheme:scheme isForm:NO];
 
   // Update, store or remove the user/password depending on the user
   // choice and whether or not we found the username/password in the
   // keychain.
   if (checked && !existingEntry)
-    [keychain storeUsername:username password:password forHost:(NSString*)host port:port scheme:scheme isForm:NO];
+    [keychain storeUsername:username password:password forHost:(NSString*)host securityDomain:nil port:port scheme:scheme isForm:NO];
   else if (checked && existingEntry && (![[existingEntry username] isEqualToString:username] ||
                                         ![[existingEntry password] isEqualToString:password]))
     [keychain updateKeychainEntry:existingEntry withUsername:username password:password scheme:scheme isForm:NO];
   else if (!checked && existingEntry)
     [existingEntry removeFromKeychain];
 }
 
 //
@@ -793,32 +813,44 @@
       return NS_OK;
 
     nsCAutoString schemeCAString;
     docURL->GetScheme(schemeCAString);
     NSString* scheme = [NSString stringWithCString:schemeCAString.get()];
     PRInt32 port = -1;
     docURL->GetPort(&port);
 
+    nsAutoString action;
+    formNode->GetAction(action);
+    NSString* actionHost = [[NSURL URLWithString:[NSString stringWith_nsAString:action]] host];
+    // Forms without an action specified submit to the page
+    if (!actionHost)
+      actionHost = host;
+
     //
     // If there's already an entry in the keychain, check if the username
     // and password match. If not, ask the user what they want to do and replace
     // it as necessary. If there's no entry, ask if they want to remember it
     // and then put it into the keychain
     //
     KeychainItem* existingEntry = [keychain findKeychainEntryForHost:host port:port scheme:scheme isForm:YES];
     if (existingEntry) {
       if (!([[existingEntry username] isEqualToString:username] && [[existingEntry password] isEqualToString:password]))
-        if (CheckChangeDataYN(window))
+        if ([keychain confirmChangePassword:GetNSWindow(window)])
           [keychain updateKeychainEntry:existingEntry withUsername:username password:password scheme:scheme isForm:YES];
+      // If the password doesn't have an action host associated with it,
+      // add the host for the first form it is submitted to.
+      if ([[existingEntry securityDomains] count] == 0) {
+        [existingEntry setSecurityDomains:[NSArray arrayWithObject:actionHost]];
+      }
     }
     else {
-      switch (CheckStorePasswordYN(window)) {
+      switch ([keychain confirmStorePassword:GetNSWindow(window)]) {
         case kSave:
-          [keychain storeUsername:username password:password forHost:host port:port scheme:scheme isForm:YES];
+          [keychain storeUsername:username password:password forHost:host securityDomain:actionHost port:port scheme:scheme isForm:YES];
           break;
 
         case kNeverRemember:
           // tell the keychain we never want to be prompted about this host again
           [keychain addHostToDenyList:host];
           break;
 
         case kDontRemember:
@@ -827,38 +859,16 @@
       }
     }
   }
 
   return NS_OK;
 }
 
 
-NSWindow*
-KeychainFormSubmitObserver::GetNSWindow(nsIDOMWindowInternal* inWindow)
-{
-  CHBrowserView* browserView = [CHBrowserView browserViewFromDOMWindow:inWindow];
-  return [browserView getNativeWindow];
-}
-
-KeychainPromptResult
-KeychainFormSubmitObserver::CheckStorePasswordYN(nsIDOMWindowInternal* window)
-{
-  NSWindow* nswindow = GetNSWindow(window);
-  return [[KeychainService instance] confirmStorePassword:nswindow];
-}
-
-
-BOOL
-KeychainFormSubmitObserver::CheckChangeDataYN(nsIDOMWindowInternal* window)
-{
-  NSWindow* nswindow = GetNSWindow(window);
-  return [[KeychainService instance] confirmChangedPassword:nswindow];
-}
-
 @implementation KeychainBrowserListener
 
 - (id)initWithBrowser:(CHBrowserView*)aBrowser
 {
   if ((self = [super init])) {
     mBrowserView = aBrowser;
   }
   return self;
@@ -895,16 +905,17 @@
   if (!htmldoc)
     return;
 
   nsCOMPtr<nsIDOMHTMLCollection> forms;
   nsresult rv = htmldoc->GetForms(getter_AddRefs(forms));
   if (NS_FAILED(rv) || !forms)
     return;
 
+  BOOL silentlyDenySuspiciousForms = NO;
   PRUint32 numForms;
   forms->GetLength(&numForms);
 
   //
   // Seek out username and password element in all forms. If found in
   // a form, check the keychain to see if the username password are
   // stored and prefill the elements.
   //
@@ -939,16 +950,41 @@
       nsCAutoString schemeCAString;
       docURL->GetScheme(schemeCAString);
       NSString *scheme = [NSString stringWithCString:schemeCAString.get()];
       PRInt32 port = -1;
       docURL->GetPort(&port);
 
       KeychainItem* keychainEntry = [keychain findKeychainEntryForHost:host port:port scheme:scheme isForm:YES];
       if (keychainEntry) {
+        // To help prevent password stealing on sites that allow user-created HTML (but not JS),
+        // only fill if the form's action host is one that has been authorized by the user.
+        // If the keychain entry doesn't have any authorized hosts, either because it pre-dates
+        // this code or because it's a non-Camino entry, fill any form.
+        nsAutoString action;
+        formElement->GetAction(action);
+        NSString* actionHost = [[NSURL URLWithString:[NSString stringWith_nsAString:action]] host];
+        if (!actionHost)
+          actionHost = host;
+        NSArray* allowedActionHosts = [keychainEntry securityDomains];
+        if ([allowedActionHosts count] > 0 && ![allowedActionHosts containsObject:actionHost]) {
+          // The form has an un-authorized action domain. If we haven't
+          // asked the user about this page, ask. If we have and they said
+          // no, don't ask (to prevent a malicious page from throwing
+          // dialogs until the user tries the other button).
+          if (silentlyDenySuspiciousForms)
+            continue;
+          if (![keychain confirmFillPassword:GetNSWindow(inDOMWindow)]) {
+            silentlyDenySuspiciousForms = YES;
+            continue;
+          }
+          // Remember the approval
+          [keychainEntry setSecurityDomains:[allowedActionHosts arrayByAddingObject:actionHost]];
+        }
+
         nsAutoString user, pwd;
         [[keychainEntry username] assignTo_nsAString:user];
         [[keychainEntry password] assignTo_nsAString:pwd];
 
         // if the server specifies a value attribute (bug 169760), only autofill
         // the password if what we have in keychain matches what the server supplies,
         // otherwise don't. Don't bother checking the password field for a value; i can't
         // imagine the server ever prefilling a password
@@ -1037,16 +1073,28 @@
 
 - (void)onFeedDetected:(NSString*)inFeedURI feedTitle:(NSString*)inFeedTitle;
 {
 }
 
 @end
 
 //
+// GetNSWindow
+//
+// Finds the native window for the given DOM window
+//
+NSWindow*
+GetNSWindow(nsIDOMWindow* inWindow)
+{
+  CHBrowserView* browserView = [CHBrowserView browserViewFromDOMWindow:inWindow];
+  return [browserView getNativeWindow];
+}
+
+//
 // FindUsernamePasswordFields
 //
 // Searches the form for the first username and password fields. If
 // none are found, the out params will be nsnull. |inStopWhenFound|
 // determines how we proceed once we find things. When true, we bail
 // as soon as we find both a username and password field. If false, we
 // continue searching the form for a 2nd password field (such as in a
 // "change your password" form). If we find one, null out
