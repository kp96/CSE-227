Fix for bug 499910.

diff --git a/content/base/src/nsContentSink.cpp b/content/base/src/nsContentSink.cpp
--- a/content/base/src/nsContentSink.cpp
+++ b/content/base/src/nsContentSink.cpp
@@ -443,10 +443,21 @@ nsContentSink::ProcessHTTPHeaders(nsICha
   
   nsresult rv = httpchannel->GetResponseHeader(NS_LITERAL_CSTRING("link"),
                                                linkHeader);
   if (NS_SUCCEEDED(rv) && !linkHeader.IsEmpty()) {
-    ProcessHeaderData(nsGkAtoms::link,
-                      NS_ConvertASCIItoUTF16(linkHeader));
+    mDocument->SetHeaderData(nsGkAtoms::link,
+                             NS_ConvertASCIItoUTF16(linkHeader));
+
+    NS_ASSERTION(!mProcessLinkHeaderEvent.get(),
+                 "Already dispatched an event?");
+
+    mProcessLinkHeaderEvent =
+      new nsNonOwningRunnableMethod<nsContentSink>(this,
+                                           &nsContentSink::DoProcessLinkHeader);
+    rv = NS_DispatchToCurrentThread(mProcessLinkHeaderEvent.get());
+    if (NS_FAILED(rv)) {
+      mProcessLinkHeaderEvent.Forget();
+    }
   }
   
   return NS_OK;
 }
@@ -539,8 +550,16 @@ nsContentSink::ProcessHeaderData(nsIAtom
   return rv;
 }
 
 
+void
+nsContentSink::DoProcessLinkHeader()
+{
+  nsAutoString value;
+  mDocument->GetHeaderData(nsGkAtoms::link, value);
+  ProcessLinkHeader(nsnull, value);
+}
+
 static const PRUnichar kSemiCh = PRUnichar(';');
 static const PRUnichar kCommaCh = PRUnichar(',');
 static const PRUnichar kEqualsCh = PRUnichar('=');
 static const PRUnichar kLessThanCh = PRUnichar('<');
@@ -1716,8 +1735,14 @@ nsContentSink::WillBuildModelImpl()
     mBeginLoadTime = PR_IntervalToMicroseconds(PR_IntervalNow());
   }
 
   mScrolledToRefAlready = PR_FALSE;
+
+  if (mProcessLinkHeaderEvent.get()) {
+    mProcessLinkHeaderEvent.Revoke();
+
+    DoProcessLinkHeader();
+  }
 }
 
 void
 nsContentSink::ContinueInterruptedParsingIfEnabled()
diff --git a/content/base/src/nsContentSink.h b/content/base/src/nsContentSink.h
--- a/content/base/src/nsContentSink.h
+++ b/content/base/src/nsContentSink.h
@@ -63,8 +63,9 @@
 #include "prlog.h"
 #include "nsIRequest.h"
 #include "nsTimer.h"
 #include "nsCycleCollectionParticipant.h"
+#include "nsThreadUtils.h"
 
 class nsIDocument;
 class nsIURI;
 class nsIChannel;
@@ -280,8 +281,10 @@ protected:
   // Later on we might want to make this more involved somehow
   // (e.g. stop waiting after some timeout or whatnot).
   PRBool WaitForPendingSheets() { return mPendingSheetCount > 0; }
 
+  void DoProcessLinkHeader();
+
 private:
   // People shouldn't be allocating this class directly.  All subclasses should
   // be allocated using a zeroing operator new.
   void* operator new(size_t sz) CPP_THROW_NEW;  // Not to be implemented
@@ -390,8 +393,11 @@ protected:
   PRUint32 mUpdatesInNotification;
 
   PRUint32 mPendingSheetCount;
 
+  nsRevocableEventPtr<nsNonOwningRunnableMethod<nsContentSink> >
+    mProcessLinkHeaderEvent;
+
   // Measures content model creation time for current document
   MOZ_TIMER_DECLARE(mWatch)
 };
 
diff --git a/content/base/src/nsDocument.cpp b/content/base/src/nsDocument.cpp
--- a/content/base/src/nsDocument.cpp
+++ b/content/base/src/nsDocument.cpp
@@ -3534,10 +3534,11 @@ nsDocument::SetScriptGlobalObject(nsIScr
     // Go back to using the docshell for the layout history state
     mLayoutHistoryState = nsnull;
     mScopeObject = do_GetWeakReference(aScriptGlobalObject);
 
-    // If we already have a wrapper at this point, it might have the wrong
-    // parent and scope, so reparent it.
+#ifdef DEBUG
+    // We really shouldn't have a wrapper here but if we do we need to make sure
+    // it has the correct parent.
     nsIXPConnectWrappedNative *wrapper =
       static_cast<nsIXPConnectWrappedNative*>(GetWrapper());
     if (wrapper) {
       JSObject *obj = nsnull;
@@ -3553,16 +3554,14 @@ nsDocument::SetScriptGlobalObject(nsIScr
             NS_ASSERTION(cx, "Uhoh, no context, this is bad!");
           }
         }
         if (cx) {
-          nsCOMPtr<nsIXPConnectJSObjectHolder> newWrapper;
-          nsContentUtils::XPConnect()->
-            ReparentWrappedNativeIfFound(cx, JS_GetGlobalForObject(cx, obj),
-                                         newScope, wrapper->Native(),
-                                         getter_AddRefs(newWrapper));
-        }
-      }
-    }
+          NS_ASSERTION(JS_GetGlobalForObject(cx, obj) == newScope,
+                       "Wrong scope, this is really bad!");
+        }
+      }
+    }
+#endif
 
     if (mAllowDNSPrefetch) {
       nsCOMPtr<nsIDocShell> docShell = do_QueryReferent(mDocumentContainer);
       if (docShell) {
