Index: src/security/BrowserSecurityDialogs.mm
===================================================================
RCS file: /cvsroot/mozilla/camino/src/security/BrowserSecurityDialogs.mm,v
retrieving revision 1.8
diff -u -8 -r1.8 BrowserSecurityDialogs.mm
--- src/security/BrowserSecurityDialogs.mm	2 Jun 2009 03:44:49 -0000	1.8
+++ src/security/BrowserSecurityDialogs.mm	11 Oct 2009 15:14:45 -0000
@@ -266,16 +266,22 @@
       if (isInvalidTime)
         mCertFailureFlags |= CHCertificateOverrideFlagInvalidTime;
 
       nsCOMPtr<nsIX509Cert> cert;
       certStatus->GetServerCert(getter_AddRefs(cert));
       if (cert) {
         CertificateItem* certItem = [CertificateItem certificateItemWithCert:cert];
         [certItem setDomainIsMismatched:isDomainMismatch];
+        // Partially work around bug 453075, so the certificate failure message
+        // matches what we are telling the user in the dialog text.
+        if (isUntrusted)
+          [certItem setFallbackProblemMessageKey:@"InvalidStateCertNotTrusted"];
+        else if (isInvalidTime)
+          [certItem setFallbackProblemMessageKey:@"InvalidStateExpired"];
         [self setCertificateItem:certItem];
         return certItem;
       }
     }
   }
   return nil;
 }
 
Index: src/security/CertificateItem.h
===================================================================
RCS file: /cvsroot/mozilla/camino/src/security/CertificateItem.h,v
retrieving revision 1.4
diff -u -8 -r1.4 CertificateItem.h
--- src/security/CertificateItem.h	2 Jun 2009 03:44:49 -0000	1.4
+++ src/security/CertificateItem.h	11 Oct 2009 15:14:45 -0000
@@ -60,16 +60,17 @@
   nsIX509Cert*    mCert;    // owned
 
   NSDictionary*   mASN1InfoDict;    // owned. this is a nested set of dictionaries
                                     // keyed by nsIASN1Object display names
   
   unsigned long   mVerification;    // we cache this because it's slow to obtain
   BOOL            mGotVerification;
   BOOL            mDomainIsMismatched;
+  NSString*       mFallbackProblemMessageKey;  // owned
 }
 
 + (CertificateItem*)certificateItemWithCert:(nsIX509Cert*)inCert;
 - (id)initWithCert:(nsIX509Cert*)inCert;
 
 - (nsIX509Cert*)cert;   // does not addref
 - (BOOL)isSameCertAs:(nsIX509Cert*)inCert;
 - (BOOL)isEqualTo:(id)object;
@@ -139,16 +140,21 @@
 // inUsageMask is flags in nsIX509CertDB
 - (void)setTrustedFor:(unsigned int)inUsageMask asType:(unsigned int)inType;
 - (void)setTrustedForSSL:(BOOL)inTrustSSL forEmail:(BOOL)inForEmail forObjSigning:(BOOL)inForObjSigning asType:(unsigned int)inType;
 
 // Indicates that we are using this certificate in the context of a domain it
 // isn't valid for, so it should not be considered valid.
 - (void)setDomainIsMismatched:(BOOL)isMismatched;
 
+// This is a hack to work around our inability to get correct certificate
+// problem decisions (bug 453075), for the cert override dialog case. It should
+// be removed when that bug is fixed.
+- (void)setFallbackProblemMessageKey:(NSString*)problemKey;
+
 @end
 
 
 class CertificateItemManagerObjects;
 
 // an object that manages CertificateItems.
 @interface CertificateItemManager : NSObject
 {
Index: src/security/CertificateItem.mm
===================================================================
RCS file: /cvsroot/mozilla/camino/src/security/CertificateItem.mm,v
retrieving revision 1.13
diff -u -8 -r1.13 CertificateItem.mm
--- src/security/CertificateItem.mm	2 Jun 2009 03:44:49 -0000	1.13
+++ src/security/CertificateItem.mm	11 Oct 2009 15:14:45 -0000
@@ -108,16 +108,17 @@
   return self;
 }
 
 - (void)dealloc
 {
   [[NSNotificationCenter defaultCenter] removeObserver:self];
   [mASN1InfoDict release];
   NS_RELEASE(mCert);
+  [mFallbackProblemMessageKey release];
   [super dealloc];
 }
 
 - (nsIX509Cert*)cert
 {
   return mCert;
 }
 
@@ -563,17 +564,22 @@
     case nsIX509Cert::VERIFIED_OK:
       if (mDomainIsMismatched)
         stateKey = @"InvalidStateMismatchedDomain";
       else
         stateKey = @"ValidStateOK";
       break;
     default:
     case nsIX509Cert::USAGE_NOT_ALLOWED:
-    case nsIX509Cert::NOT_VERIFIED_UNKNOWN: stateKey = @"InvalidStateVerifyFailed";       break;
+    case nsIX509Cert::NOT_VERIFIED_UNKNOWN:
+      if (mFallbackProblemMessageKey)
+        stateKey = mFallbackProblemMessageKey;
+      else
+        stateKey = @"InvalidStateVerifyFailed";
+      break;
     case nsIX509Cert::CERT_REVOKED:         stateKey = @"InvalidStateRevoked";            break;
     case nsIX509Cert::CERT_NOT_TRUSTED:     stateKey = @"InvalidStateCertNotTrusted";     break;
     case nsIX509Cert::ISSUER_NOT_TRUSTED:
       // if the issuer is us
       if ([self isRootCACert])
         stateKey = @"InvalidStateIsUntrustedRootCert";
       else
         stateKey = @"InvalidStateIssuerNotTrusted";
@@ -680,16 +686,22 @@
   [self setTrustedFor:usageMask asType:inType];
 }
 
 - (void)setDomainIsMismatched:(BOOL)isMismatched
 {
   mDomainIsMismatched = isMismatched;
 }
 
+- (void)setFallbackProblemMessageKey:(NSString*)problemKey
+{
+  [mFallbackProblemMessageKey autorelease];
+  mFallbackProblemMessageKey = [problemKey copy];
+}
+
 
 - (NSDictionary*)traverseSequence:(nsIASN1Sequence*)inSequence
 {
   if (!inSequence) return nil;
 
   NSMutableDictionary* infoDict = [NSMutableDictionary dictionary];
 
   nsCOMPtr<nsIMutableArray> objectsArray;
