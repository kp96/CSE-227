From: Honza Bambas <honzab.moz@firemni.cz>

Bug 517938 - Added logging to ssltunnel to figure this bug out, no review, just no-affect test changes

diff --git a/testing/mochitest/ssltunnel/ssltunnel.cpp b/testing/mochitest/ssltunnel/ssltunnel.cpp
--- a/testing/mochitest/ssltunnel/ssltunnel.cpp
+++ b/testing/mochitest/ssltunnel/ssltunnel.cpp
@@ -350,20 +350,21 @@ void HandleConnection(void* data)
   AutoFD other_sock(PR_NewTCPSocket());
   bool client_done = false;
   bool client_error = false;
   bool connect_accepted = !do_http_proxy;
   bool ssl_updated = !do_http_proxy;
   bool expect_request_start = do_http_proxy;
   string certificateToUse;
   client_auth_option clientAuth;
   string fullHost;
 
+  printf("SSLTUNNEL(%p): incoming connection csock(0)=%p, ssock(1)=%p\n", data, ci->client_sock, (PRFileDesc*)other_sock);
   if (other_sock) 
   {
     PRInt32 numberOfSockets = 1;
 
     relayBuffer buffers[2];
 
     if (!do_http_proxy)
     {
       if (!ConfigureSSLServerSocket(ci->client_sock, ci->server_info, certificateToUse, caNone))
         client_error = true;
@@ -377,80 +378,106 @@ void HandleConnection(void* data)
     { 
       {ci->client_sock, PR_POLL_READ, 0},
       {other_sock, PR_POLL_READ, 0}
     };
     PRBool socketErrorState[2] = {PR_FALSE, PR_FALSE};
 
     while (!((client_error||client_done) && buffers[0].empty() && buffers[1].empty()))
     {
       sockets[0].in_flags |= PR_POLL_EXCEPT;
       sockets[1].in_flags |= PR_POLL_EXCEPT;
+      printf("SSLTUNNEL(%p): polling flags csock(0)=%c%c, ssock(1)=%c%c\n", data, 
+		sockets[0].in_flags & PR_POLL_READ  ? 'R' : '-', 
+		sockets[0].in_flags & PR_POLL_WRITE ? 'W' : '-',
+		sockets[1].in_flags & PR_POLL_READ  ? 'R' : '-', 
+		sockets[1].in_flags & PR_POLL_WRITE ? 'W' : '-');
       PRInt32 pollStatus = PR_Poll(sockets, numberOfSockets, PR_MillisecondsToInterval(1000));
       if (pollStatus < 0)
       {
+        printf("SSLTUNNEL(%p): pollStatus=%d, exiting\n", data, pollStatus);
         client_error = true;
         break;
       }
 
       if (pollStatus == 0)
+      {
         // timeout
+        printf("SSLTUNNEL(%p): poll timeout, looping\n", data);
         continue;
+      }
 
       for (PRInt32 s = 0; s < numberOfSockets; ++s)
       {
         PRInt32 s2 = s == 1 ? 0 : 1;
         PRInt16 out_flags = sockets[s].out_flags;
         PRInt16 &in_flags = sockets[s].in_flags;
         PRInt16 &in_flags2 = sockets[s2].in_flags;
         sockets[s].out_flags = 0;
 
+        printf("SSLTUNNEL(%p): %csock(%d)=%p out_flags=%d", data, s==0?'c':'s', s, sockets[s].fd, out_flags);
         if (out_flags & (PR_POLL_EXCEPT | PR_POLL_ERR | PR_POLL_HUP))
         {
+          printf(" :exception\n");
           client_error = true;
           socketErrorState[s] = PR_TRUE;
           // We got a fatal error state on the socket. Clear the output buffer
           // for this socket to break the main loop, we will never more be able
           // to send those data anyway.
           buffers[s2].bufferhead = buffers[s2].buffertail = buffers[s2].buffer;
           continue;
         } // PR_POLL_EXCEPT, PR_POLL_ERR, PR_POLL_HUP handling
 
+        if (out_flags & PR_POLL_READ && !buffers[s].free())
+        {
+           printf(" no place in read buffer but got read flag, dropping it now!");
+	   in_flags &= ~PR_POLL_READ;
+        }
+
         if (out_flags & PR_POLL_READ && buffers[s].free())
         {
+          printf(" :reading");
           PRInt32 bytesRead = PR_Recv(sockets[s].fd, buffers[s].buffertail, 
               buffers[s].free(), 0, PR_INTERVAL_NO_TIMEOUT);
 
           if (bytesRead == 0)
           {
+            printf(" socket gracefully closed");
             client_done = true;
             in_flags &= ~PR_POLL_READ;
           }
           else if (bytesRead < 0)
           {
             if (PR_GetError() != PR_WOULD_BLOCK_ERROR)
             {
+              printf(" error=%d", PR_GetError());
               // We are in error state, indicate that the connection was 
               // not closed gracefully
               client_error = true;
               socketErrorState[s] = PR_TRUE;
               // Wipe out our send buffer, we cannot send it anyway.
               buffers[s2].bufferhead = buffers[s2].buffertail = buffers[s2].buffer;
             }
+            else
+              printf(" would block");
           }
           else
           {
             // If the other socket is in error state (unable to send/receive)
             // throw this data away and continue loop
             if (socketErrorState[s2])
+            {
+              printf(" have read but other socket is in error state\n");
               continue;
+            }
 
             buffers[s].buffertail += bytesRead;
+            printf(", read %d bytes", bytesRead);
 
             // We have to accept and handle the initial CONNECT request here
             PRInt32 response;
             if (!connect_accepted && ReadConnectRequest(ci->server_info, buffers[s],
                 &response, certificateToUse, &clientAuth, fullHost))
             {
               // Clean the request as it would be read
               buffers[s].bufferhead = buffers[s].buffertail = buffers[s].buffer;
 
               // Store response to the oposite buffer
@@ -460,90 +487,113 @@ void HandleConnection(void* data)
                 sprintf(buffers[s2].buffer, "HTTP/1.1 %d ERROR\r\nConnection: close\r\n\r\n", response);
                 buffers[s2].buffertail = buffers[s2].buffer + strlen(buffers[s2].buffer);
                 break;
               }
 
               strcpy(buffers[s2].buffer, "HTTP/1.1 200 Connected\r\nConnection: keep-alive\r\n\r\n");
               buffers[s2].buffertail = buffers[s2].buffer + strlen(buffers[s2].buffer);
 
               if (!ConnectSocket(other_sock, &remote_addr, connect_timeout))
               {
+                printf(" could not open connection to the real server\n");
                 client_error = true;
                 break;
               }
 
+              printf(" accepted CONNECT request, connected to the server, sending OK to the client\n");
               // Send the response to the client socket
               in_flags |= PR_POLL_WRITE;
               connect_accepted = true;
               break;
             } // end of CONNECT handling
 
-            if (!buffers[s].free()) // Do not poll for read when the buffer is full
+            if (!buffers[s].free())
+            {
+              // Do not poll for read when the buffer is full
+              printf(" no place in our read buffer, stop reading");
               in_flags &= ~PR_POLL_READ;
+            }
 
             if (ssl_updated)
             {
               if (s == 0 && expect_request_start)
                 expect_request_start = !AdjustRequestURI(buffers[s], &fullHost);
 
               in_flags2 |= PR_POLL_WRITE;
+              printf(" telling the other socket to write");
             }
+            else
+              printf(" we have something for the other socket to write, but ssl has not been administered on it");
           }
         } // PR_POLL_READ handling
 
         if (out_flags & PR_POLL_WRITE)
         {
+          printf(" :writting");
           PRInt32 bytesWrite = PR_Send(sockets[s].fd, buffers[s2].bufferhead, 
               buffers[s2].present(), 0, PR_INTERVAL_NO_TIMEOUT);
 
           if (bytesWrite < 0)
           {
             if (PR_GetError() != PR_WOULD_BLOCK_ERROR) {
+              printf(" error=%d", PR_GetError());
               client_error = true;
               socketErrorState[s] = PR_TRUE;
               // We got a fatal error while writting the buffer. Clear it to break
               // the main loop, we will never more be able to send it.
               buffers[s2].bufferhead = buffers[s2].buffertail = buffers[s2].buffer;
             }
+            else
+              printf(" would block");
           }
           else
           {
+            printf(", writen %d bytes", bytesWrite);
             buffers[s2].bufferhead += bytesWrite;
             if (buffers[s2].present())
-              in_flags |= PR_POLL_WRITE;              
+            {
+              printf(" still have to write %d bytes", (int)buffers[s2].present());
+              in_flags |= PR_POLL_WRITE;
+            }              
             else
             {
               if (!ssl_updated)
               {
+                printf(" proxy response sent to the client");
                 // Proxy response has just been writen, update to ssl
                 ssl_updated = true;
                 if (!ConfigureSSLServerSocket(ci->client_sock, ci->server_info, certificateToUse, clientAuth))
                 {
+                  printf(" but failed to config server socket\n");
                   client_error = true;
                   break;
                 }
 
+                printf(" client socket updated to SSL");
                 numberOfSockets = 2;
               } // sslUpdate
 
-              in_flags &= ~PR_POLL_WRITE;              
+              printf(" dropping our write flag and setting other socket read flag");
+              in_flags &= ~PR_POLL_WRITE;
               in_flags2 |= PR_POLL_READ;
               buffers[s2].compact();
             }
           }
         } // PR_POLL_WRITE handling
+        printf("\n"); // end the log
       } // for...
     } // while, poll
   }
   else
     client_error = true;
 
+  printf("SSLTUNNEL(%p): exiting root function for csock=%p, ssock=%p\n", data, ci->client_sock, (PRFileDesc*)other_sock);
   if (!client_error)
     PR_Shutdown(ci->client_sock, PR_SHUTDOWN_SEND);
   PR_Close(ci->client_sock);
 
   delete ci;
 }
 
 /*
  * Start listening for SSL connections on a specified port, handing
  * them off to client threads after accepting the connection.
