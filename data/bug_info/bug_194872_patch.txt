Index: idl/nsIAggregatePrincipal.idl
===================================================================
RCS file: /m/pub/mozilla/caps/idl/nsIAggregatePrincipal.idl,v
retrieving revision 1.9
diff -u -p -5 -r1.9 nsIAggregatePrincipal.idl
--- idl/nsIAggregatePrincipal.idl	12 Jun 2003 20:18:28 -0000	1.9
+++ idl/nsIAggregatePrincipal.idl	19 Jun 2003 00:12:19 -0000
@@ -53,6 +53,7 @@ interface nsIAggregatePrincipal : nsISup
     attribute boolean domainChanged;
     readonly attribute nsIPrincipal originalCodebase;
     readonly attribute nsIPrincipal primaryChild;
 
     void intersect(in nsIPrincipal other);
+    attribute voidPtr cachedSecurityPolicy;
 };
Index: include/nsAggregatePrincipal.h
===================================================================
RCS file: /m/pub/mozilla/caps/include/nsAggregatePrincipal.h,v
retrieving revision 1.13
diff -u -p -5 -r1.13 nsAggregatePrincipal.h
--- include/nsAggregatePrincipal.h	12 Jun 2003 20:18:30 -0000	1.13
+++ include/nsAggregatePrincipal.h	19 Jun 2003 00:12:19 -0000
@@ -107,9 +107,10 @@ public:
 
 protected:
     nsCOMPtr<nsIPrincipal> mCertificate;
     nsCOMPtr<nsIPrincipal> mCodebase;
     nsCOMPtr<nsIPrincipal> mOriginalCodebase;
+    void* mCachedSecurityPolicy;
     PRPackedBool mDomainChanged;
 };
 
 #endif // _NS_AGGREGATE_PRINCIPAL_H_
Index: include/nsScriptSecurityManager.h
===================================================================
RCS file: /m/pub/mozilla/caps/include/nsScriptSecurityManager.h,v
retrieving revision 1.66
diff -u -p -5 -r1.66 nsScriptSecurityManager.h
--- include/nsScriptSecurityManager.h	28 May 2003 23:22:34 -0000	1.66
+++ include/nsScriptSecurityManager.h	19 Jun 2003 00:12:19 -0000
@@ -157,12 +157,10 @@ ClearPropertyPolicyEntry(PLDHashTable *t
 
 struct ClassPolicy : public PLDHashEntryHdr
 {
     char*  key;
     PLDHashTable* mPolicy;
-    ClassPolicy*  mDefault;
-    ClassPolicy*  mWildcard;
 };
 
 PR_STATIC_CALLBACK(PRBool)
 MatchClassPolicyKey(PLDHashTable *table,
                     const PLDHashEntryHdr *entry,
@@ -211,11 +209,13 @@ InitClassPolicyEntry(PLDHashTable *table
 
 // Domain Policy
 class DomainPolicy : public PLDHashTable
 {
 public:
-    DomainPolicy() : mRefCount(0)
+    DomainPolicy() : mWildcardPolicy(nsnull),
+                     mRefCount(0)
+                     
     {
         static PLDHashTableOps domainPolicyOps =
         {
             PL_DHashAllocTable,
             PL_DHashFreeTable,
@@ -246,10 +246,12 @@ public:
     {
         if (--mRefCount == 0)
             delete this;
     }
 
+    ClassPolicy* mWildcardPolicy;
+
 private:
     PRUint32 mRefCount;
 };
 
 /////////////////////////////
@@ -323,24 +325,17 @@ private:
     nsresult
     CheckSameOriginDOMProp(nsIPrincipal* aSubject, 
                            nsIPrincipal* aObject,
                            PRUint32 aAction,
                            PRBool aIsCheckConnect);
-    
-    PRInt32 
-    GetSecurityLevel(nsIPrincipal *principal,
-                     PRBool aIsDOM,
-                     const char* aClassName, const char* aProperty,
-                     PRUint32 aAction, nsCString &capability, void** aPolicy);
 
     nsresult
-    GetClassPolicy(nsIPrincipal* principal, const char* aClassName,
-                   ClassPolicy** result);
-
-    SecurityLevel
-    GetPropertyPolicy(jsval aProperty, ClassPolicy* aClassPolicy,
-                      PRUint32 aAction);
+    LookupPolicy(nsIPrincipal* principal,
+                 char* aClassName, jsval aProperty,
+                 PRUint32 aAction,
+                 ClassPolicy** aCachedClassPolicy,
+                 SecurityLevel* result);
 
     nsresult
     CreateCodebasePrincipal(nsIURI* aURI, nsIPrincipal** result);
 
     nsresult
Index: src/nsAggregatePrincipal.cpp
===================================================================
RCS file: /m/pub/mozilla/caps/src/nsAggregatePrincipal.cpp,v
retrieving revision 1.21
diff -u -p -5 -r1.21 nsAggregatePrincipal.cpp
--- src/nsAggregatePrincipal.cpp	12 Jun 2003 20:18:31 -0000	1.21
+++ src/nsAggregatePrincipal.cpp	19 Jun 2003 00:12:19 -0000
@@ -176,10 +176,12 @@ nsAggregatePrincipal::SetCertificate(nsI
         if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
         mCertificate = underlying.get();
     }
     else
         mCertificate = aCertificate;
+    // New certificate, so forget cached security policy
+    mCachedSecurityPolicy = nsnull;
     return NS_OK;
 }
 
 NS_IMETHODIMP 
 nsAggregatePrincipal::SetCodebase(nsIPrincipal* aCodebase)
@@ -206,10 +208,16 @@ nsAggregatePrincipal::SetCodebase(nsIPri
     mCodebase = newCodebase;
 
     //-- If this is the first codebase set, remember it.
     if (!mOriginalCodebase)
         mOriginalCodebase = newCodebase;
+    else
+    {
+        mDomainChanged = PR_TRUE;
+        // Codebase has changed, forget cached security policy
+        mCachedSecurityPolicy = nsnull;
+    }
 
     return NS_OK;
 }
 
 NS_IMETHODIMP 
@@ -270,10 +278,25 @@ nsAggregatePrincipal::GetDomainChanged(P
 {
     *aDomainChanged = mDomainChanged;
     return NS_OK;
 }
 
+NS_IMETHODIMP 
+nsAggregatePrincipal::GetCachedSecurityPolicy(void** aCachedSecurityPolicy)
+{
+    *aCachedSecurityPolicy = mCachedSecurityPolicy;
+    return NS_OK;
+}
+
+NS_IMETHODIMP 
+nsAggregatePrincipal::SetCachedSecurityPolicy(void* aCachedSecurityPolicy)
+{
+    mCachedSecurityPolicy = aCachedSecurityPolicy;
+    return NS_OK;
+}
+
+
 ///////////////////////////////////////
 // Methods implementing nsIPrincipal //
 ///////////////////////////////////////
 NS_IMETHODIMP 
 nsAggregatePrincipal::ToString(char **result)
@@ -444,11 +467,12 @@ nsAggregatePrincipal::Write(nsIObjectOut
 
 /////////////////////////////////////////////
 // Constructor, Destructor, initialization //
 /////////////////////////////////////////////
 
-nsAggregatePrincipal::nsAggregatePrincipal() : mDomainChanged(PR_FALSE)
+nsAggregatePrincipal::nsAggregatePrincipal() : mCachedSecurityPolicy(nsnull),
+                                               mDomainChanged(PR_FALSE)
 {
 }
 
 nsAggregatePrincipal::~nsAggregatePrincipal()
 {
Index: src/nsScriptSecurityManager.cpp
===================================================================
RCS file: /m/pub/mozilla/caps/src/nsScriptSecurityManager.cpp,v
retrieving revision 1.205
diff -u -p -5 -r1.205 nsScriptSecurityManager.cpp
--- src/nsScriptSecurityManager.cpp	12 Jun 2003 20:18:32 -0000	1.205
+++ src/nsScriptSecurityManager.cpp	19 Jun 2003 00:12:19 -0000
@@ -103,15 +103,23 @@ JSValIDToString(JSContext *cx, const jsv
 // Helper class to get stuff from the ClassInfo and not waste extra time with
 // virtual method calls for things it has already gotten
 class ClassInfoData
 {
 public:
-    ClassInfoData(nsIClassInfo *aClassInfo)
-        : mClassInfo(aClassInfo), mDidGetFlags(PR_FALSE)
+    ClassInfoData(nsIClassInfo *aClassInfo, const char* aName)
+        : mClassInfo(aClassInfo), mDidGetFlags(PR_FALSE),
+          mName((char*) aName), mMustFreeName(PR_FALSE)
     {
     }
 
+
+    ~ClassInfoData()
+    {
+        if (mMustFreeName)
+            nsMemory::Free(mName);
+    }
+
     PRUint32 GetFlags()
     {
         if (!mDidGetFlags) {
             if (mClassInfo) {
                 mDidGetFlags = PR_TRUE;
@@ -134,14 +142,30 @@ public:
     PRBool IsContentNode()
     {
         return GetFlags() & nsIClassInfo::CONTENT_NODE;
     }
 
+    char* GetName()
+    {
+        if (!mName)
+        {
+            if (mClassInfo)
+                mClassInfo->GetClassDescription(&mName);
+            if (mName)
+                mMustFreeName = PR_TRUE;
+            else
+                mName = NS_REINTERPRET_CAST(char*,"UnnamedClass");
+        }
+        return mName;
+    }
+
 private:
     nsIClassInfo *mClassInfo; // WEAK
     PRBool mDidGetFlags;
     PRUint32 mFlags;
+    char* mName;
+    PRBool mMustFreeName;
 };
  
 JSContext *
 nsScriptSecurityManager::GetCurrentJSContext()
 {
@@ -172,46 +196,10 @@ nsScriptSecurityManager::GetSafeJSContex
     if (NS_FAILED(mJSContextStack->GetSafeJSContext(&cx)))
         return nsnull;
     return cx;
 }
 
-
-class ClassNameHolder
-{
-public:
-    ClassNameHolder(const char* aClassName, nsIClassInfo* aClassInfo) : 
-      mClassName((char*)aClassName), mClassInfo(aClassInfo), mMustFree(PR_FALSE)
-    {
-    }
-
-    ~ClassNameHolder()
-    {
-        if (mMustFree)
-            nsMemory::Free(mClassName);
-    }
-
-    char* get()
-    {
-        if (mClassName)
-            return mClassName;
-
-        if (mClassInfo)
-            mClassInfo->GetClassDescription(&mClassName);
-        if (mClassName)
-            mMustFree = PR_TRUE;
-        else
-            mClassName = "UnnamedClass";
-
-        return mClassName;
-    }
-
-private:
-    char* mClassName;
-    nsCOMPtr<nsIClassInfo> mClassInfo;
-    PRBool mMustFree;
-};
-
 /* Static function for comparing two URIs - for security purposes,
  * two URIs are equivalent if their scheme, host, and port are equal.
  */
 /*static*/ nsresult
 nsScriptSecurityManager::SecurityCompareURIs(nsIURI* aSourceURI,
@@ -613,62 +601,26 @@ nsScriptSecurityManager::CheckPropertyAc
         NS_SUCCEEDED(subjectPrincipal->Equals(mSystemPrincipal, &equals)) && equals)
         // We have native code or the system principal: just allow access
         return NS_OK;
 
     nsresult rv;
-    ClassNameHolder className(aClassName, aClassInfo);
+    // Hold the class info data here so we don't have to go back to virtual
+    // methods all the time
+    ClassInfoData classInfoData(aClassInfo, aClassName);
 #ifdef DEBUG_mstoltz
     nsCAutoString propertyName;
     propertyName.AssignWithConversion((PRUnichar*)JSValIDToString(cx, aProperty));
-    printf("### CanAccess(%s.%s, %i) ", className.get(), 
+    printf("### CanAccess(%s.%s, %i) ", classInfoData.GetName(), 
            propertyName.get(), aAction);
 #endif
 
-    //-- Initialize policies if necessary
-    if (mPolicyPrefsChanged)
-    {
-        rv = InitPolicies();
-        if (NS_FAILED(rv))
-            return rv;
-    }
-
-    //-- Look up the policy for this class
-    ClassPolicy* cpolicy = aCachedClassPolicy ? 
-                           NS_REINTERPRET_CAST(ClassPolicy*, *aCachedClassPolicy) : nsnull;
-    if (!cpolicy)
-    {
-        //-- No cached policy for this class, need to look it up
-#ifdef DEBUG_mstoltz
-        printf("Miss! ");
-#endif
-    	rv = GetClassPolicy(subjectPrincipal, className.get(), &cpolicy);
-        if (NS_FAILED(rv))
-            return rv;
-        if (aCachedClassPolicy)
-            *aCachedClassPolicy = cpolicy;
-    }
-
-    SecurityLevel securityLevel = GetPropertyPolicy(aProperty, cpolicy, aAction);
-
-    // If the class policy we have is a wildcard policy, then we may
-    // still need to try the default for this class
-    if (cpolicy != NO_POLICY_FOR_CLASS &&
-        cpolicy->key[0] == '*' && cpolicy->key[1] == '\0' &&
-        securityLevel.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)
-    {
-        cpolicy = 
-          NS_REINTERPRET_CAST(ClassPolicy*,
-                              PL_DHashTableOperate(mDefaultPolicy,
-                                                   className.get(),
-                                                   PL_DHASH_LOOKUP));
-        if (PL_DHASH_ENTRY_IS_LIVE(cpolicy))
-            securityLevel = GetPropertyPolicy(aProperty, cpolicy, aAction);
-    }
-
-    // Hold the class info data here so we don't have to go back to virtual
-    // methods all the time
-    ClassInfoData classInfoData(aClassInfo);
+    //-- Look up the security policy for this class and subject domain
+    SecurityLevel securityLevel;
+    rv = LookupPolicy(subjectPrincipal, classInfoData.GetName(), aProperty, aAction, 
+                      (ClassPolicy**)aCachedClassPolicy, &securityLevel);
+    if (NS_FAILED(rv))
+        return rv;
 
     if (securityLevel.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)
     {   
         // No policy found for this property so use the default of last resort.
         // If we were called from somewhere other than XPConnect
@@ -827,11 +779,11 @@ nsScriptSecurityManager::CheckPropertyAc
             errorMsg += "set property ";
             break;
         case nsIXPCSecurityManager::ACCESS_CALL_METHOD:
             errorMsg += "call method ";
         }
-        errorMsg += className.get();
+        errorMsg += classInfoData.GetName();
         errorMsg += '.';
         errorMsg.AppendWithConversion((PRUnichar*)JSValIDToString(cx, aProperty));
 
         JS_SetPendingException(cx,
                                STRING_TO_JSVAL(JS_NewStringCopyZ(cx, errorMsg.get())));
@@ -924,20 +876,41 @@ nsScriptSecurityManager::CheckSameOrigin
     */
     return NS_ERROR_DOM_PROP_ACCESS_DENIED;
 }
 
 nsresult
-nsScriptSecurityManager::GetClassPolicy(nsIPrincipal* principal,
-                                        const char* aClassName,
-                                        ClassPolicy** result)
+nsScriptSecurityManager::LookupPolicy(nsIPrincipal* aPrincipal,
+                                     char* aClassName, jsval aProperty,
+                                     PRUint32 aAction,
+                                     ClassPolicy** aCachedClassPolicy,
+                                     SecurityLevel* result)
 {
     nsresult rv;
-    *result = nsnull;
+    result->level = SCRIPT_SECURITY_UNDEFINED_ACCESS;
+
+    //-- Initialize policies if necessary
+    if (mPolicyPrefsChanged)
+    {
+        rv = InitPolicies();
+        if (NS_FAILED(rv))
+            return rv;
+    }
+
     DomainPolicy* dpolicy = nsnull;
-    if (mOriginToPolicyMap)
-    {   //-- Look up the relevant domain policy, if any
-        nsCOMPtr<nsICodebasePrincipal> codebase(do_QueryInterface(principal));
+    nsCOMPtr<nsIAggregatePrincipal> agg(do_QueryInterface(aPrincipal));
+    NS_ASSERTION(agg, "Subject principal not an aggregate - this shouldn't happen");
+    if (agg)
+        agg->GetCachedSecurityPolicy((void**)&dpolicy);
+
+    if (!dpolicy && mOriginToPolicyMap)
+    {
+        //-- Look up the relevant domain policy, if any
+#ifdef DEBUG_mstoltz
+        printf("DomainLookup ");
+#endif
+
+        nsCOMPtr<nsICodebasePrincipal> codebase(do_QueryInterface(aPrincipal));
         if (!codebase)
             return NS_ERROR_FAILURE;
 
         nsXPIDLCString origin;
         if (NS_FAILED(rv = codebase->GetOrigin(getter_Copies(origin))))
@@ -976,98 +949,93 @@ nsScriptSecurityManager::GetClassPolicy(
                 dpolicy = de->mDomainPolicy;
                 break;
             }
             de = de->mNext;
         }
-    }
 
-    ClassPolicy* wildcardPolicy = nsnull;
-    if (dpolicy)
-    {
-        //-- Now get the class policy
-        *result = 
-          NS_REINTERPRET_CAST(ClassPolicy*,
-            PL_DHashTableOperate(dpolicy,
-                                 aClassName,
-                                 PL_DHASH_LOOKUP));
+        if (!dpolicy)
+            dpolicy = mDefaultPolicy;
 
-        //-- and the wildcard policy (class "*" for this domain)
-        wildcardPolicy = 
-          NS_REINTERPRET_CAST(ClassPolicy*,
-            PL_DHashTableOperate(dpolicy,
-                                 "*",
-                                 PL_DHASH_LOOKUP));
+        agg->SetCachedSecurityPolicy((void*)dpolicy);
     }
 
-    //-- and the default policy for this class
-    ClassPolicy* defaultClassPolicy = 
-          NS_REINTERPRET_CAST(ClassPolicy*,
-            PL_DHashTableOperate(mDefaultPolicy,
-                                 aClassName,
-                                 PL_DHASH_LOOKUP));
-
-    if (*result && PL_DHASH_ENTRY_IS_LIVE(*result))
-    {
-        if (PL_DHASH_ENTRY_IS_LIVE(wildcardPolicy))
-            (*result)->mWildcard = wildcardPolicy;
-        if (PL_DHASH_ENTRY_IS_LIVE(defaultClassPolicy))
-            (*result)->mDefault  = defaultClassPolicy;
-    }
-    else
+    ClassPolicy* cpolicy = nsnull;
+
+    if ((dpolicy == mDefaultPolicy) && aCachedClassPolicy)
     {
-        if (wildcardPolicy && PL_DHASH_ENTRY_IS_LIVE(wildcardPolicy))
-            *result = wildcardPolicy;
-        else if (PL_DHASH_ENTRY_IS_LIVE(defaultClassPolicy))
-            *result = defaultClassPolicy;
-        else
-            *result = NO_POLICY_FOR_CLASS;
+        // No per-domain policy for this principal (the more common case)
+        // so look for a cached class policy from the object wrapper
+        cpolicy = *aCachedClassPolicy;
     }
 
-    return NS_OK;
-}
+    if (!cpolicy)
+    { //-- No cached policy for this class, need to look it up
+#ifdef DEBUG_mstoltz
+        printf("ClassLookup ");
+#endif
 
-SecurityLevel
-nsScriptSecurityManager::GetPropertyPolicy(jsval aProperty, ClassPolicy* aClassPolicy,
-                                           PRUint32 aAction)
-{
-    //-- Look up the policy for this property/method
+        cpolicy = NS_REINTERPRET_CAST(ClassPolicy*,
+                                      PL_DHashTableOperate(dpolicy,
+                                                           aClassName,
+                                                           PL_DHASH_LOOKUP));
+
+        if (!PL_DHASH_ENTRY_IS_LIVE(cpolicy))
+            cpolicy = NO_POLICY_FOR_CLASS;
+
+        if ((dpolicy == mDefaultPolicy) && aCachedClassPolicy)
+            *aCachedClassPolicy = cpolicy;
+    }
     PropertyPolicy* ppolicy = nsnull;
-    if (aClassPolicy && aClassPolicy != NO_POLICY_FOR_CLASS)
+    if (cpolicy != NO_POLICY_FOR_CLASS)
     {
         ppolicy = 
-          (PropertyPolicy*) PL_DHashTableOperate(aClassPolicy->mPolicy,
-                                                 NS_REINTERPRET_CAST(void*, aProperty),
-                                                 PL_DHASH_LOOKUP);
-        if (!PL_DHASH_ENTRY_IS_LIVE(ppolicy))
-        {   // No domain policy for this property, look for a wildcard policy
-            if (aClassPolicy->mWildcard)
-            {
-                ppolicy = NS_REINTERPRET_CAST(PropertyPolicy*,
-                  PL_DHashTableOperate(aClassPolicy->mWildcard->mPolicy,
-                                       NS_REINTERPRET_CAST(void*, aProperty),
-                                       PL_DHASH_LOOKUP));
-            }
-            if (!PL_DHASH_ENTRY_IS_LIVE(ppolicy) && aClassPolicy->mDefault)
-            {   // Now look for a default policy
-                ppolicy = NS_REINTERPRET_CAST(PropertyPolicy*,
-                  PL_DHashTableOperate(aClassPolicy->mDefault->mPolicy,
-                                       NS_REINTERPRET_CAST(void*, aProperty),
-                                       PL_DHASH_LOOKUP));
-            }
+                (PropertyPolicy*) PL_DHashTableOperate(cpolicy->mPolicy,
+                                                       (void*)aProperty,
+                                                       PL_DHASH_LOOKUP);
+    }
+    else
+    {
+        // If there's no per-domain policy and no default policy, we're done
+        if (dpolicy == mDefaultPolicy)
+            return NS_OK;
+
+        // This class is not present in the domain policy, check its wildcard policy
+        if (dpolicy->mWildcardPolicy)
+        {
+            ppolicy = 
+                (PropertyPolicy*) PL_DHashTableOperate(dpolicy->mWildcardPolicy->mPolicy,
+                                                       (void*)aProperty, PL_DHASH_LOOKUP);
         }
-        if (PL_DHASH_ENTRY_IS_LIVE(ppolicy))
+
+        // If there's no wildcard policy, check the default policy for this class
+        if (!ppolicy || !PL_DHASH_ENTRY_IS_LIVE(ppolicy))
         {
-            // Get the correct security level from the property policy
-            if (aAction == nsIXPCSecurityManager::ACCESS_SET_PROPERTY)
-                return ppolicy->mSet;
-            return ppolicy->mGet;
+            cpolicy = NS_REINTERPRET_CAST(ClassPolicy*,
+                                          PL_DHashTableOperate(mDefaultPolicy,
+                                                               aClassName,
+                                                               PL_DHASH_LOOKUP));
+
+            if (PL_DHASH_ENTRY_IS_LIVE(cpolicy))
+            {
+                ppolicy = 
+                    (PropertyPolicy*) PL_DHashTableOperate(cpolicy->mPolicy,
+                                                           (void*)aProperty,
+                                                           PL_DHASH_LOOKUP);
+            }
         }
     }
 
-    SecurityLevel nopolicy;
-    nopolicy.level = SCRIPT_SECURITY_UNDEFINED_ACCESS;
-    return nopolicy;
+    if (!ppolicy || !PL_DHASH_ENTRY_IS_LIVE(ppolicy))
+        return NS_OK;
+
+    // Get the correct security level from the property policy
+    if (aAction == nsIXPCSecurityManager::ACCESS_SET_PROPERTY)
+        *result = ppolicy->mSet;
+    else
+        *result = ppolicy->mGet;
+
+    return NS_OK;
 }
 
 
 NS_IMETHODIMP
 nsScriptSecurityManager::CheckLoadURIFromScript(JSContext *cx, nsIURI *aURI)
@@ -1595,27 +1563,14 @@ nsScriptSecurityManager::CanExecuteScrip
         return NS_OK; // Do not run scripts
 
     //-- Check for a per-site policy
     static const char jsPrefGroupName[] = "javascript";
 
-    //-- Initialize policies if necessary
-    if (mPolicyPrefsChanged)
-    {
-        rv = InitPolicies();
-        if (NS_FAILED(rv))
-            return rv;
-    }
-
-    ClassPolicy* cpolicy;
     SecurityLevel secLevel;
-    rv = GetClassPolicy(aPrincipal, jsPrefGroupName, &cpolicy);
-
-    if (NS_SUCCEEDED(rv))
-    {
-        secLevel = GetPropertyPolicy(sEnabledID, cpolicy,
-                                     nsIXPCSecurityManager::ACCESS_GET_PROPERTY);
-    }
+    rv = LookupPolicy(aPrincipal, (char*)jsPrefGroupName, sEnabledID,
+                      nsIXPCSecurityManager::ACCESS_GET_PROPERTY, 
+                      nsnull, &secLevel);
     if (NS_FAILED(rv) || secLevel.level == SCRIPT_SECURITY_NO_ACCESS)
     {
         *result = PR_FALSE;
         return rv;
     }
@@ -2384,11 +2339,11 @@ nsScriptSecurityManager::CanCreateWrappe
     char* iidStr = aIID.ToString();
     printf("### CanCreateWrapper(%s) ", iidStr);
     PR_FREEIF(iidStr);
 #endif
 // XXX Special case for nsIXPCException ?
-    if (ClassInfoData(aClassInfo).IsDOMClass())
+    if (ClassInfoData(aClassInfo, nsnull).IsDOMClass())
     {
 #if 0
         printf("DOM class - GRANTED.\n");
 #endif
         return NS_OK;
@@ -2443,27 +2398,20 @@ nsScriptSecurityManager::CheckComponentP
 
 #ifdef DEBUG_mstoltz
     printf("### CheckComponentPermissions(ClassID.%s) ",cid.get());
 #endif
 
-    //-- Initialize policies if necessary
-    if (mPolicyPrefsChanged)
-    {
-        rv = InitPolicies();
-        if (NS_FAILED(rv))
-            return rv;
-    }
+    // Look up the policy for this class.
+    // while this isn't a property we'll treat it as such, using ACCESS_CALL_METHOD
+    jsval cidVal = STRING_TO_JSVAL(::JS_InternString(cx, cid.get()));
 
-    //-- Look up the policy for this class
-    ClassPolicy* cpolicy = nsnull;
-    rv = GetClassPolicy(subjectPrincipal, "ClassID", &cpolicy);
+    SecurityLevel securityLevel;
+    rv = LookupPolicy(subjectPrincipal, "ClassID", cidVal,
+                      nsIXPCSecurityManager::ACCESS_CALL_METHOD, 
+                      nsnull, &securityLevel);
     if (NS_FAILED(rv))
         return rv;
-    jsval cidVal = STRING_TO_JSVAL(::JS_InternString(cx, cid.get()));
-    // While this isn't a property we'll treat it as such, ussing ACCESS_CALL_METHOD
-    SecurityLevel securityLevel = GetPropertyPolicy(cidVal, cpolicy,
-        nsIXPCSecurityManager::ACCESS_CALL_METHOD);
 
     // If there's no policy stored, use the "security.classID.allowByDefault" pref 
     if (securityLevel.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)
         securityLevel.level = mXPCDefaultGrantAll ? SCRIPT_SECURITY_ALL_ACCESS :
                                                     SCRIPT_SECURITY_NO_ACCESS;
@@ -2986,10 +2934,15 @@ nsScriptSecurityManager::InitDomainPolic
                                                    start,
                                                    PL_DHASH_ADD));
 
         if (!cpolicy)
             break;
+
+        // If this is the wildcard class (class '*'), save it in mWildcardPolicy
+        // (we leave it stored in the hashtable too to take care of the cleanup)
+        if ((*start == '*') && (end == start + 1))
+            aDomainPolicy->mWildcardPolicy = cpolicy;
 
         // Get the property name
         start = end + 1;
         end = PL_strchr(start, '.');
         if (end)
