* * *
client auth merge+r1 comments
* * *
ssltunnel comment fix
* * *

diff --git a/build/pgo/automation.py.in b/build/pgo/automation.py.in
--- a/build/pgo/automation.py.in
+++ b/build/pgo/automation.py.in
@@ -303,20 +303,21 @@ user_pref("browser.shell.checkDefaultBro
 user_pref("browser.shell.checkDefaultBrowser", false);
 user_pref("shell.checkDefaultClient", false);
 user_pref("browser.warnOnQuit", false);
 user_pref("accessibility.typeaheadfind.autostart", false);
 user_pref("javascript.options.showInConsole", true);
 user_pref("layout.debug.enable_data_xbl", true);
 user_pref("browser.EULA.override", true);
 user_pref("javascript.options.jit.content", true);
 user_pref("gfx.color_management.force_srgb", true);
 user_pref("network.manage-offline-status", false);
+user_pref("security.default_personal_cert", "Select Automatically"); // Need to client auth test be w/o any dialogs
 
 user_pref("camino.warn_when_closing", false); // Camino-only, harmless to others
 """
   prefs.append(part)
 
   locations = readLocations()
 
   # Grant God-power to all the privileged servers on which tests run.
   privileged = filter(lambda loc: "privileged" in loc.options, locations)
   for (i, l) in itertools.izip(itertools.count(1), privileged):
@@ -390,47 +391,61 @@ def fillCertificateDB(profileDir):
 
   # Create head of the ssltunnel configuration file
   sslTunnelConfigPath = os.path.join(CERTS_DIR, "ssltunnel.cfg")
   sslTunnelConfig = open(sslTunnelConfigPath, "w")
   
   sslTunnelConfig.write("httpproxy:1\n")
   sslTunnelConfig.write("certdbdir:%s\n" % CERTS_DIR)
   sslTunnelConfig.write("forward:127.0.0.1:8888\n")
   sslTunnelConfig.write("listen:*:4443:pgo server certificate\n")
 
-  # Generate automatic certificate and bond custom certificates
+  # Configure automatic certificate and bind custom certificates, client authentication
   locations = readLocations()
   locations.pop(0)
   for loc in locations:
     if loc.scheme == "https" and "nocert" not in loc.options:
       customCertRE = re.compile("^cert=(?P<nickname>[0-9a-zA-Z_ ]+)")
+      clientAuthRE = re.compile("^clientauth=(?P<clientauth>[a-z]+)")
       for option in loc.options:
         match = customCertRE.match(option)
         if match:
           customcert = match.group("nickname");
-          sslTunnelConfig.write("listen:%s:%s:4443:%s\n" % (loc.host, loc.port, customcert))
-          break
+          sslTunnelConfig.write("listen:%s:%s:4443:%s\n" %
+              (loc.host, loc.port, customcert))
+
+        match = clientAuthRE.match(option)
+        if match:
+          clientauth = match.group("clientauth");
+          sslTunnelConfig.write("clientauth:%s:%s:4443:%s\n" %
+              (loc.host, loc.port, clientauth))
 
   sslTunnelConfig.close()
 
   # Pre-create the certification database for the profile
   certutil = DIST_BIN + "/certutil" + BIN_SUFFIX
+  pk12util = DIST_BIN + "/pk12util" + BIN_SUFFIX
+
   status = Process(certutil, ["-N", "-d", profileDir, "-f", pwfilePath], environment()).wait()
   if status != 0:
     return status
 
-  # Walk the cert directory and add custom CAs as trusted
+  # Walk the cert directory and add custom CAs and client certs
   files = os.listdir(CERTS_DIR)
   for item in files:
     root, ext = os.path.splitext(item)
     if ext == ".ca":
-      Process(certutil, ["-A", "-i", os.path.join(CERTS_DIR, item), "-d", profileDir, "-f", pwfilePath, "-n", root, "-t", "CT,,"], environment())
+      Process(certutil, ["-A", "-i", os.path.join(CERTS_DIR, item),
+        "-d", profileDir, "-f", pwfilePath, "-n", root, "-t", "CT,,"],
+        environment()).wait()
+    if ext == ".client":
+      Process(pk12util, ["-i", os.path.join(CERTS_DIR, item), "-w", pwfilePath,
+        "-d", profileDir], environment()).wait()
 
   os.unlink(pwfilePath)
   return 0
 
 def environment(env = None):
   if env == None:
     env = dict(os.environ)
 
   if UNIXISH:
     ldLibraryPath = os.path.join(SCRIPT_DIR, DIST_BIN)
diff --git a/build/pgo/certs/Makefile.in b/build/pgo/certs/Makefile.in
--- a/build/pgo/certs/Makefile.in
+++ b/build/pgo/certs/Makefile.in
@@ -39,26 +39,36 @@ DEPTH		= ../../..
 DEPTH		= ../../..
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 _PROFILE_DIR = $(DEPTH)/_profile/pgo
 _CERTS_DIR = $(_PROFILE_DIR)/certs
 
-# Extension of files must be '.ca'
+# Following files will be added as trusted Certificate Authorities
+# to the PGO profile.
+# Extension of those files MUST BE '.ca'.
 _CERT_AUTHORITIES = \
     pgoca.ca \
+    $(NULL)
+
+
+# Following files will be added as user/client certificates
+# to the PGO profile to be used for client authentication.
+# Extension of those files MUST BE '.client'.
+_CLIENT_CERTS = \
+    mochitest.client \
     $(NULL)
 
 _SERV_FILES = \
     pgoca.p12 \
     cert8.db \
     key3.db \
     secmod.db \
     $(NULL)
 
 include $(topsrcdir)/config/rules.mk
 
-libs:: $(_SERV_FILES) $(_CERT_AUTHORITIES)
+libs:: $(_SERV_FILES) $(_CERT_AUTHORITIES) $(_CLIENT_CERTS)
 	$(INSTALL) $^ $(_CERTS_DIR)
diff --git a/build/pgo/server-locations.txt b/build/pgo/server-locations.txt
--- a/build/pgo/server-locations.txt
+++ b/build/pgo/server-locations.txt
@@ -95,29 +95,34 @@ http://sub1.test2.example.org:8000   pri
 http://sub1.test2.example.org:8000   privileged
 http://sub2.test1.example.org:8000   privileged
 http://sub2.test2.example.org:8000   privileged
 http://example.com:80                privileged
 http://test1.example.com:80          privileged
 http://test2.example.com:80          privileged
 http://sub1.test1.example.com:80     privileged
 http://sub1.test2.example.com:80     privileged
 http://sub2.test1.example.com:80     privileged
 http://sub2.test2.example.com:80     privileged
+http://nocert.example.com:80         privileged
+http://requestclientcert.example.com:80         privileged
+http://requireclientcert.example.com:80         privileged
 
 https://example.com:443                privileged
 https://test1.example.com:443          privileged
 https://test2.example.com:443          privileged
 https://sub1.test1.example.com:443     privileged
 https://sub1.test2.example.com:443     privileged
 https://sub2.test1.example.com:443     privileged
 https://sub2.test2.example.com:443     privileged
 https://nocert.example.com:443         privileged,nocert
+https://requestclientcert.example.com:443         privileged,clientauth=request
+https://requireclientcert.example.com:443         privileged,clientauth=require
 
 #
 # These are subdomains of <Ã¤lt.example.org>.
 #
 http://sub1.xn--lt-uia.example.org:8000   privileged
 http://sub2.xn--lt-uia.example.org:80     privileged
 http://xn--exmple-cua.test:80             privileged
 http://sub1.xn--exmple-cua.test:80        privileged
 
 https://xn--hxajbheg2az3al.xn--jxalpdlp:443        privileged
diff --git a/testing/mochitest/runtests.py.in b/testing/mochitest/runtests.py.in
--- a/testing/mochitest/runtests.py.in
+++ b/testing/mochitest/runtests.py.in
@@ -460,21 +460,21 @@ def maybeForceLeakThreshold(options):
   threshold can be successfully forced for the particular Mochitest type
   and platform in use.
   """
   if options.leakThreshold == INFINITY:
     if options.chrome:
       # We don't leak running the --chrome tests.
       options.leakThreshold = 0
     elif options.browserChrome:
       # We still leak a nondeterministic amount running browser-chrome tests.
       # But we are close to 0 (bug), so start to prevent/detect regressions. (Bug 460548)
-      options.leakThreshold = 72500
+      options.leakThreshold = 74500
     elif options.a11y:
       # We don't leak running the --a11y tests.
       options.leakThreshold = 0
     else:
       # Normal Mochitests: no leaks.
       options.leakThreshold = 0
 
 def makeTestConfig(options):
   "Creates a test configuration file for customizing test execution."
   def boolString(b):
diff --git a/testing/mochitest/ssltunnel/ssltunnel.cpp b/testing/mochitest/ssltunnel/ssltunnel.cpp
--- a/testing/mochitest/ssltunnel/ssltunnel.cpp
+++ b/testing/mochitest/ssltunnel/ssltunnel.cpp
@@ -48,25 +48,32 @@
 #include "nss.h"
 #include "pk11func.h"
 #include "key.h"
 #include "keyt.h"
 #include "ssl.h"
 #include "plhash.h"
 
 using std::string;
 using std::vector;
 
+enum client_auth_option {
+  caNone = 0,
+  caRequire = 1,
+  caRequest = 2
+};
+
 // Structs for passing data into jobs on the thread pool
 typedef struct {
   PRInt32 listen_port;
   string cert_nickname;
   PLHashTable* host_cert_table;
+  PLHashTable* host_clientauth_table;
 } server_info_t;
 
 typedef struct {
   PRFileDesc* client_sock;
   PRNetAddr client_addr;
   server_info_t* server_info;
 } connection_info_t;
 
 // A couple of stack classes for managing NSS/NSPR resources
 class AutoCert {
@@ -116,63 +123,81 @@ const PRInt32 BUF_SIZE = 4096;
 // global data
 string nssconfigdir;
 vector<server_info_t> servers;
 PRNetAddr remote_addr;
 PRThreadPool* threads = NULL;
 PRLock* shutdown_lock = NULL;
 PRCondVar* shutdown_condvar = NULL;
 // Not really used, unless something fails to start
 bool shutdown_server = false;
 bool do_http_proxy = false;
-bool any_host_cert_mapping = false;
+bool any_host_spec_config = false;
+
+PR_CALLBACK PRIntn ClientAuthValueComparator(const void *v1, const void *v2)
+{
+  int a = *static_cast<const client_auth_option*>(v1) -
+          *static_cast<const client_auth_option*>(v2);
+  if (a == 0)
+    return 0;
+  if (a > 0)
+    return 1;
+  else // (a < 0)
+    return -1;
+}
 
 /*
  * Signal the main thread that the application should shut down.
  */
 void SignalShutdown()
 {
   PR_Lock(shutdown_lock);
   PR_NotifyCondVar(shutdown_condvar);
   PR_Unlock(shutdown_lock);
 }
 
 bool ReadConnectRequest(server_info_t* server_info, 
-    char* bufferhead, char* buffertail, PRInt32* result, string* certificate)
+    char* bufferhead, char* buffertail, PRInt32* result, string* certificate, client_auth_option* clientauth)
 {
   if (buffertail - bufferhead < 4)
     return false;
   if (strncmp(buffertail-4, "\r\n\r\n", 4))
     return false;
 
   *result = 400;
 
   char* token;
   token = strtok(bufferhead, " ");
   if (!token) 
     return true;
   if (strcmp(token, "CONNECT")) 
     return true;
 
   token = strtok(NULL, " ");
   void* c = PL_HashTableLookup(server_info->host_cert_table, token);
   if (c)
     *certificate = (char*)c;
 
+  c = PL_HashTableLookup(server_info->host_clientauth_table, token);
+  if (c)
+    *clientauth = *static_cast<client_auth_option*>(c);
+  else
+    *clientauth = caNone;
+
   token = strtok(NULL, "/");
   if (strcmp(token, "HTTP"))
     return true;
 
   *result = 200;
   return true;
 }
 
-bool ConfigureSSLServerSocket(PRFileDesc* socket, server_info_t* si, string &certificate)
+bool ConfigureSSLServerSocket(PRFileDesc* socket, server_info_t* si, string &certificate, client_auth_option clientAuth)
 {
   const char* certnick = certificate.empty() ?
       si->cert_nickname.c_str() : certificate.c_str();
 
   AutoCert cert(PK11_FindCertFromNickname(
       certnick, NULL));
   if (!cert) {
     fprintf(stderr, "Failed to find cert %s\n", si->cert_nickname.c_str());
     return false;
   }
@@ -192,20 +217,27 @@ bool ConfigureSSLServerSocket(PRFileDesc
   SSLKEAType certKEA = NSS_FindCertKEAType(cert);
   if (SSL_ConfigSecureServer(ssl_socket, cert, privKey, certKEA)
       != SECSuccess) {
     fprintf(stderr, "Error configuring SSL server socket\n");
     return false;
   }
 
   SSL_OptionSet(ssl_socket, SSL_SECURITY, PR_TRUE);
   SSL_OptionSet(ssl_socket, SSL_HANDSHAKE_AS_CLIENT, PR_FALSE);
   SSL_OptionSet(ssl_socket, SSL_HANDSHAKE_AS_SERVER, PR_TRUE);
+
+  if (clientAuth != caNone)
+  {
+    SSL_OptionSet(ssl_socket, SSL_REQUEST_CERTIFICATE, PR_TRUE);
+    SSL_OptionSet(ssl_socket, SSL_REQUIRE_CERTIFICATE, clientAuth == caRequire);
+  }
+
   SSL_ResetHandshake(ssl_socket, PR_TRUE);
 
   return true;
 }
 
 bool ConnectSocket(PRFileDesc *fd, const PRNetAddr *addr, PRIntervalTime timeout)
 {
   PRStatus stat = PR_Connect(fd, addr, timeout);
   if (stat != PR_SUCCESS)
     return false;
@@ -229,20 +261,21 @@ void HandleConnection(void* data)
 {
   connection_info_t* ci = static_cast<connection_info_t*>(data);
   PRIntervalTime connect_timeout = PR_SecondsToInterval(2);
 
   AutoFD other_sock(PR_NewTCPSocket());
   bool client_done = false;
   bool client_error = false;
   bool connect_accepted = !do_http_proxy;
   bool ssl_updated = !do_http_proxy;
   string certificateToUse;
+  client_auth_option clientAuth;
 
   if (other_sock) 
   {
     PRInt32 numberOfSockets = 1;
 
     struct relayBuffer
     {
       char *buffer, *bufferhead, *buffertail, *bufferend;
       relayBuffer() 
       { 
@@ -268,21 +301,21 @@ void HandleConnection(void* data)
       }
       void compact() 
       { 
         if (buffertail == bufferhead) 
           buffertail = bufferhead = buffer;
       }
     } buffers[2];
 
     if (!do_http_proxy)
     {
-      if (!ConfigureSSLServerSocket(ci->client_sock, ci->server_info, certificateToUse))
+      if (!ConfigureSSLServerSocket(ci->client_sock, ci->server_info, certificateToUse, caNone))
         client_error = true;
       else if (!ConnectSocket(other_sock, &remote_addr, connect_timeout))
         client_error = true;
       else
         numberOfSockets = 2;
     }
 
     PRPollDesc sockets[2] = 
     { 
       {ci->client_sock, PR_POLL_READ, 0},
@@ -333,21 +366,21 @@ void HandleConnection(void* data)
             if (PR_GetError() != PR_WOULD_BLOCK_ERROR)
               client_error = true;
           }
           else
           {
             buffers[s].buffertail += bytesRead;
 
             // We have to accept and handle the initial CONNECT request here
             PRInt32 response;
             if (!connect_accepted && ReadConnectRequest(ci->server_info, buffers[s].bufferhead, buffers[s].buffertail, 
-                &response, &certificateToUse))
+                &response, &certificateToUse, &clientAuth))
             {
               // Clean the request as it would be read
               buffers[s].bufferhead = buffers[s].buffertail = buffers[s].buffer;
 
               // Store response to the oposite buffer
               if (response != 200)
               {
                 client_done = true;
                 sprintf(buffers[s2].buffer, "HTTP/1.1 %d ERROR\r\nConnection: close\r\n\r\n", response);
                 buffers[s2].buffertail = buffers[s2].buffer + strlen(buffers[s2].buffer);
@@ -391,21 +424,21 @@ void HandleConnection(void* data)
           {
             buffers[s2].bufferhead += bytesWrite;
             if (buffers[s2].present())
               in_flags |= PR_POLL_WRITE;              
             else
             {
               if (!ssl_updated)
               {
                 // Proxy response has just been writen, update to ssl
                 ssl_updated = true;
-                if (!ConfigureSSLServerSocket(ci->client_sock, ci->server_info, certificateToUse))
+                if (!ConfigureSSLServerSocket(ci->client_sock, ci->server_info, certificateToUse, clientAuth))
                 {
                   client_error = true;
                   break;
                 }
 
                 numberOfSockets = 2;
               } // sslUpdate
 
               in_flags &= ~PR_POLL_WRITE;              
               in_flags2 |= PR_POLL_READ;
@@ -521,80 +554,150 @@ int processConfigLine(char* configLine)
   }
 
   // Configure the forward address of the target server
   if (!strcmp(keyword, "forward"))
   {
     char* ipstring = strtok(NULL, ":");
     if (PR_StringToNetAddr(ipstring, &remote_addr) != PR_SUCCESS) {
       fprintf(stderr, "Invalid remote IP address: %s\n", ipstring);
       return 1;
     }
-    char* portstring = strtok(NULL, ":");
-    int port = atoi(portstring);
+    char* serverportstring = strtok(NULL, ":");
+    int port = atoi(serverportstring);
     if (port <= 0) {
-      fprintf(stderr, "Invalid remote port: %s\n", portstring);
+      fprintf(stderr, "Invalid remote port: %s\n", serverportstring);
       return 1;
     }
     remote_addr.inet.port = PR_htons(port);
 
     return 0;
   }
 
   // Configure all listen sockets and port+certificate bindings
   if (!strcmp(keyword, "listen"))
   {
     char* hostname = strtok(NULL, ":");
     char* hostportstring = NULL;
     if (strcmp(hostname, "*"))
     {
-      any_host_cert_mapping = true;
+      any_host_spec_config = true;
       hostportstring = strtok(NULL, ":");
     }
 
-    char* portstring = strtok(NULL, ":");
+    char* serverportstring = strtok(NULL, ":");
     char* certnick = strtok(NULL, ":");
 
-    int port = atoi(portstring);
+    int port = atoi(serverportstring);
     if (port <= 0) {
-      fprintf(stderr, "Invalid port specified: %s\n", portstring);
+      fprintf(stderr, "Invalid port specified: %s\n", serverportstring);
       return 1;
     }
 
     if (server_info_t* existingServer = findServerInfo(port))
     {
       char *certnick_copy = new char[strlen(certnick)+1];
       char *hostname_copy = new char[strlen(hostname)+strlen(hostportstring)+2];
 
       strcpy(hostname_copy, hostname);
       strcat(hostname_copy, ":");
       strcat(hostname_copy, hostportstring);
       strcpy(certnick_copy, certnick);
 
-      PL_HashTableAdd(existingServer->host_cert_table, hostname_copy, certnick_copy);
+      PLHashEntry* entry = PL_HashTableAdd(existingServer->host_cert_table, hostname_copy, certnick_copy);
+      if (!entry) {
+        fprintf(stderr, "Out of memory");
+        return 1;
+      }
     }
     else
     {
       server_info_t server;
       server.cert_nickname = certnick;
       server.listen_port = port;
       server.host_cert_table = PL_NewHashTable(0, PL_HashString, PL_CompareStrings, PL_CompareStrings, NULL, NULL);
       if (!server.host_cert_table)
       {
         fprintf(stderr, "Internal, could not create hash table\n");
         return 1;
       }
+      server.host_clientauth_table = PL_NewHashTable(0, PL_HashString, PL_CompareStrings, ClientAuthValueComparator, NULL, NULL);
+      if (!server.host_clientauth_table)
+      {
+        fprintf(stderr, "Internal, could not create hash table\n");
+        return 1;
+      }
       servers.push_back(server);
     }
 
     return 0;
   }
   
+  if (!strcmp(keyword, "clientauth"))
+  {
+    char* hostname = strtok(NULL, ":");
+    char* hostportstring = strtok(NULL, ":");
+    char* serverportstring = strtok(NULL, ":");
+
+    int port = atoi(serverportstring);
+    if (port <= 0) {
+      fprintf(stderr, "Invalid port specified: %s\n", serverportstring);
+      return 1;
+    }
+
+    if (server_info_t* existingServer = findServerInfo(port))
+    {
+      char* authoptionstring = strtok(NULL, ":");
+      client_auth_option* authoption = new client_auth_option;
+      if (!authoption) {
+        fprintf(stderr, "Out of memory");
+        return 1;
+      }
+
+      if (!strcmp(authoptionstring, "require"))
+        *authoption = caRequire;
+      else if (!strcmp(authoptionstring, "request"))
+        *authoption = caRequest;
+      else if (!strcmp(authoptionstring, "none"))
+        *authoption = caNone;
+      else
+      {
+        fprintf(stderr, "Incorrect client auth option modifier for host '%s'", hostname);
+        return 1;
+      }
+
+      any_host_spec_config = true;
+
+      char *hostname_copy = new char[strlen(hostname)+strlen(hostportstring)+2];
+      if (!hostname_copy) {
+        fprintf(stderr, "Out of memory");
+        return 1;
+      }
+
+      strcpy(hostname_copy, hostname);
+      strcat(hostname_copy, ":");
+      strcat(hostname_copy, hostportstring);
+
+      PLHashEntry* entry = PL_HashTableAdd(existingServer->host_clientauth_table, hostname_copy, authoption);
+      if (!entry) {
+        fprintf(stderr, "Out of memory");
+        return 1;
+      }
+    }
+    else
+    {
+      fprintf(stderr, "Server on port %d for client authentication option is not defined, use 'listen' option first", port);
+      return 1;
+    }
+
+    return 0;
+  }
+
   // Configure the NSS certificate database directory
   if (!strcmp(keyword, "certdbdir"))
   {
     nssconfigdir = strtok(NULL, "\n");
     return 0;
   }
 
   printf("Error: keyword \"%s\" unexpected\n", keyword);
   return 1;
 }
@@ -626,32 +729,39 @@ int parseConfigFile(const char* filePath
 
   fclose(f);
 
   // Check mandatory items
   if (nssconfigdir.empty())
   {
     printf("Error: missing path to NSS certification database\n,use certdbdir:<path> in the config file\n");
     return 1;
   }
 
-  if (any_host_cert_mapping && !do_http_proxy)
+  if (any_host_spec_config && !do_http_proxy)
   {
-    printf("Warning: any host-specific certificate configurations are ignored, add httpproxy:1 to allow them\n");
+    printf("Warning: any host-specific configurations are ignored, add httpproxy:1 to allow them\n");
   }
 
   return 0;
 }
 
-PRIntn freeHashItems(PLHashEntry *he, PRIntn i, void *arg)
+PRIntn freeHostCertHashItems(PLHashEntry *he, PRIntn i, void *arg)
 {
   delete [] (char*)he->key;
   delete [] (char*)he->value;
+  return HT_ENUMERATE_REMOVE;
+}
+
+PRIntn freeClientAuthHashItems(PLHashEntry *he, PRIntn i, void *arg)
+{
+  delete [] (char*)he->key;
+  delete (client_auth_option*)he->value;
   return HT_ENUMERATE_REMOVE;
 }
 
 int main(int argc, char** argv)
 {
   char* configFilePath;
   if (argc == 1)
     configFilePath = "ssltunnel.cfg";
   else
     configFilePath = argv[1];
@@ -667,23 +777,29 @@ int main(int argc, char** argv)
       "       # Specify path to the certification database used.\n"
       "       certdbdir:/path/to/certdb\n\n"
       "       # Forward/proxy all requests in raw to 127.0.0.1:8888.\n"
       "       forward:127.0.0.1:8888\n\n"
       "       # Accept connections on port 4443 or 5678 resp. and authenticate\n"
       "       # to any host ('*') using the 'server cert' or 'server cert 2' resp.\n"
       "       listen:*:4443:server cert\n"
       "       listen:*:5678:server cert 2\n\n"
       "       # Accept connections on port 4443 and authenticate using\n"
       "       # 'a different cert' when target host is 'my.host.name:443'.\n"
-      "       # This works only in httpproxy mode and has higher priority\n"
-      "       # then the previews option.\n"
-      "       listen:my.host.name:443:4443:a different cert\n",
+      "       # This only works in httpproxy mode and has higher priority\n"
+      "       # than the previous option.\n"
+      "       listen:my.host.name:443:4443:a different cert\n\n"
+      "       # To make a specific host require or just request a client certificate\n"
+      "       # to authenticate use the following options. This can only be used\n"
+      "       # in httpproxy mode and only after the 'listen' option has been\n"
+      "       # specified. You also have to specify the tunnel listen port.\n"
+      "       clientauth:requesting-client-cert.host.com:443:4443:request\n"
+      "       clientauth:requiring-client-cert.host.com:443:4443:require\n",
       configFilePath);
     return 1;
   }
 
   // create a thread pool to handle connections
   threads = PR_CreateThreadPool(std::max<PRInt32>(INITIAL_THREADS,
                                                   servers.size()*2),
                                 std::max<PRInt32>(MAX_THREADS,
                                                   servers.size()*2),
                                 DEFAULT_STACKSIZE);
@@ -757,17 +873,19 @@ int main(int argc, char** argv)
   PR_JoinThreadPool(threads);
   PR_DestroyCondVar(shutdown_condvar);
   PR_DestroyLock(shutdown_lock);
   if (NSS_Shutdown() == SECFailure) {
     fprintf(stderr, "Leaked NSS objects!\n");
   }
   
   for (vector<server_info_t>::iterator it = servers.begin();
        it != servers.end(); it++) 
   {
-    PL_HashTableEnumerateEntries(it->host_cert_table, freeHashItems, NULL);
+    PL_HashTableEnumerateEntries(it->host_cert_table, freeHostCertHashItems, NULL);
+    PL_HashTableEnumerateEntries(it->host_clientauth_table, freeClientAuthHashItems, NULL);
     PL_HashTableDestroy(it->host_cert_table);
+    PL_HashTableDestroy(it->host_clientauth_table);
   }
 
   PR_Cleanup();
   return 0;
 }
