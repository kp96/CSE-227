Index: docshell/base/nsWebShell.cpp
===================================================================
RCS file: /cvsroot/mozilla/docshell/base/nsWebShell.cpp,v
retrieving revision 1.604
diff -u -9 -p -r1.604 nsWebShell.cpp
--- docshell/base/nsWebShell.cpp	18 Apr 2003 18:55:10 -0000	1.604
+++ docshell/base/nsWebShell.cpp	18 Apr 2003 21:26:15 -0000
@@ -278,18 +278,23 @@ NS_INTERFACE_MAP_END_INHERITING(nsDocShe
 NS_IMETHODIMP
 nsWebShell::GetInterface(const nsIID &aIID, void** aInstancePtr)
 {
    NS_ENSURE_ARG_POINTER(aInstancePtr);
    nsresult rv = NS_OK;
    *aInstancePtr = nsnull;
 
    if(aIID.Equals(NS_GET_IID(nsILinkHandler)))
       {
+      // Note: If we ever allow for registering other link handlers,
+      // we need to make sure that link handler implementations take
+      // the necessary precautions to prevent the security compromise
+      // that is blocked by nsWebSell::OnLinkClickSync().
+
       *aInstancePtr = NS_STATIC_CAST(nsILinkHandler*, this);
       NS_ADDREF((nsISupports*)*aInstancePtr);
       return NS_OK;
       }
    else if(aIID.Equals(NS_GET_IID(nsIScriptGlobalObjectOwner)))
       {
       *aInstancePtr = NS_STATIC_CAST(nsIScriptGlobalObjectOwner*, this);
       NS_ADDREF((nsISupports*)*aInstancePtr);
       return NS_OK;
@@ -534,26 +539,25 @@ OnLinkClickEvent::~OnLinkClickEvent()
 NS_IMETHODIMP
 nsWebShell::OnLinkClick(nsIContent* aContent,
                         nsLinkVerb aVerb,
                         nsIURI* aURI,
                         const PRUnichar* aTargetSpec,
                         nsIInputStream* aPostDataStream,
                         nsIInputStream* aHeadersDataStream)
 {
   OnLinkClickEvent* ev;
-  nsresult rv = NS_OK;
 
   ev = new OnLinkClickEvent(this, aContent, aVerb, aURI,
                             aTargetSpec, aPostDataStream, aHeadersDataStream);
-  if (nsnull == ev) {
-    rv = NS_ERROR_OUT_OF_MEMORY;
+  if (!ev) {
+    return NS_ERROR_OUT_OF_MEMORY;
   }
-  return rv;
+  return NS_OK;
 }
 
 nsresult
 nsWebShell::GetEventQueue(nsIEventQueue **aQueue)
 {
   NS_ENSURE_ARG_POINTER(aQueue);
   *aQueue = 0;
 
   nsCOMPtr<nsIEventQueueService> eventService(do_GetService(kEventQueueServiceCID));
@@ -566,18 +570,74 @@ NS_IMETHODIMP
 nsWebShell::OnLinkClickSync(nsIContent *aContent,
                             nsLinkVerb aVerb,
                             nsIURI* aURI,
                             const PRUnichar* aTargetSpec,
                             nsIInputStream* aPostDataStream,
                             nsIInputStream* aHeadersDataStream,
                             nsIDocShell** aDocShell,
                             nsIRequest** aRequest)
 {
+  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(aContent));
+  NS_ENSURE_TRUE(node, NS_ERROR_UNEXPECTED);
+
+  PRBool isJS = PR_FALSE;
+  PRBool isData = PR_FALSE;
+
+  aURI->SchemeIs("javascript", &isJS);
+  aURI->SchemeIs("data", &isData);
+
+  if (isJS || isData) {
+    nsCOMPtr<nsIDocument> sourceDoc;
+    aContent->GetDocument(*getter_AddRefs(sourceDoc));
+
+    if (!sourceDoc) {
+      // The source is in a 'zombie' document, or not part of a
+      // document any more. Don't let it execute any javascript in the
+      // new document.
+
+      return NS_OK;
+    }
+
+    nsCOMPtr<nsIPresShell> presShell;
+    GetPresShell(getter_AddRefs(presShell));
+    NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
+
+    nsCOMPtr<nsIDocument> currentDoc;
+    presShell->GetDocument(getter_AddRefs(currentDoc));
+
+    if (currentDoc != sourceDoc) {
+      // The source is not in the current document, don't let it
+      // execute any javascript in the current document.
+
+      return NS_OK;
+    }
+  }
+
+  // Get the owner document of the link that was clicked, this will be
+  // the document that the link is in, or the last document that the
+  // link was in. From that document, we'll get the URI to use as the
+  // referer, since the current URI in this webshell/docshell may be a
+  // new document that we're in the process of loading.
+  nsCOMPtr<nsIDOMDocument> refererOwnerDoc;
+  node->GetOwnerDocument(getter_AddRefs(refererOwnerDoc));
+
+  nsCOMPtr<nsIDocument> refererDoc(do_QueryInterface(refererOwnerDoc));
+  NS_ENSURE_TRUE(refererDoc, NS_ERROR_UNEXPECTED);
+
+  nsCOMPtr<nsIURI> referer;
+  refererDoc->GetDocumentURL(getter_AddRefs(referer));
+
+  if (!referer) {
+    // No referer, no loading links!
+
+    return NS_OK;
+  }
+
   nsAutoString target(aTargetSpec);
 
   // Initialize the DocShell / Request
   if (aDocShell) {
     *aDocShell = nsnull;
   }
   if (aRequest) {
     *aRequest = nsnull;
   }
@@ -585,19 +645,19 @@ nsWebShell::OnLinkClickSync(nsIContent *
   switch(aVerb) {
     case eLinkVerb_New:
       target.Assign(NS_LITERAL_STRING("_blank"));
       // Fall into replace case
     case eLinkVerb_Undefined:
       // Fall through, this seems like the most reasonable action
     case eLinkVerb_Replace:
       {
         return InternalLoad(aURI,               // New URI
-                            mCurrentURI,        // Referer URI
+                            referer,            // Referer URI
                             nsnull,             // No onwer
                             PR_TRUE,            // Inherit owner from document
                             target.get(),       // Window target
                             aPostDataStream,    // Post data stream
                             aHeadersDataStream, // Headers stream
                             LOAD_LINK,          // Load type
                             nsnull,             // No SHEntry
                             PR_TRUE,            // first party site
                             aDocShell,          // DocShell out-param
