Index: jsapi.c
===================================================================
RCS file: /cvsroot/mozilla/js/src/jsapi.c,v
retrieving revision 3.152
diff -p -u -8 -r3.152 jsapi.c
--- jsapi.c	22 Oct 2003 06:26:03 -0000	3.152
+++ jsapi.c	30 Oct 2003 00:42:19 -0000
@@ -2869,24 +2869,48 @@ JS_SetReservedSlot(JSContext *cx, JSObje
                              JSMSG_RESERVED_SLOT_RANGE);
         return JS_FALSE;
     }
     slot = JSSLOT_START(clasp) + index;
     OBJ_SET_REQUIRED_SLOT(cx, obj, slot, v);
     return JS_TRUE;
 }
 
+#ifdef JS_THREADSAFE
+JS_PUBLIC_API(jsrefcount)
+JS_HoldPrincipals(JSContext *cx, JSPrincipals *principals)
+{
+    return JS_ATOMIC_INCREMENT(&principals->refcount);
+}
+
+JS_PUBLIC_API(jsrefcount)
+JS_DropPrincipals(JSContext *cx, JSPrincipals *principals)
+{
+    return JS_ATOMIC_DECREMENT(&principals->refcount);
+}
+#endif
+
 JS_PUBLIC_API(JSPrincipalsTranscoder)
 JS_SetPrincipalsTranscoder(JSRuntime *rt, JSPrincipalsTranscoder px)
 {
     JSPrincipalsTranscoder oldpx;
 
     oldpx = rt->principalsTranscoder;
     rt->principalsTranscoder = px;
     return oldpx;
+}
+
+JS_PUBLIC_API(JSObjectPrincipalsFinder)
+JS_SetObjectPrincipalsFinder(JSContext *cx, JSObjectPrincipalsFinder fop)
+{
+    JSObjectPrincipalsFinder oldfop;
+
+    oldfop = cx->findObjectPrincipals;
+    cx->findObjectPrincipals = fop;
+    return oldfop;
 }
 
 JS_PUBLIC_API(JSFunction *)
 JS_NewFunction(JSContext *cx, JSNative native, uintN nargs, uintN flags,
                JSObject *parent, const char *name)
 {
     JSAtom *atom;
 
Index: jsapi.h
===================================================================
RCS file: /cvsroot/mozilla/js/src/jsapi.h,v
retrieving revision 3.81
diff -p -u -8 -r3.81 jsapi.h
--- jsapi.h	27 Oct 2003 17:00:38 -0000	3.81
+++ jsapi.h	30 Oct 2003 00:42:19 -0000
@@ -1097,29 +1097,43 @@ JS_SetReservedSlot(JSContext *cx, JSObje
  * Security protocol.
  */
 struct JSPrincipals {
     char *codebase;
     void * (* JS_DLL_CALLBACK getPrincipalArray)(JSContext *cx, JSPrincipals *);
     JSBool (* JS_DLL_CALLBACK globalPrivilegesEnabled)(JSContext *cx, JSPrincipals *);
 
     /* Don't call "destroy"; use reference counting macros below. */
-    uintN refcount;
+    jsrefcount refcount;
     void (* JS_DLL_CALLBACK destroy)(JSContext *cx, struct JSPrincipals *);
 };
 
-#define JSPRINCIPALS_HOLD(cx, principals)               \
-    ((principals)->refcount++)
-#define JSPRINCIPALS_DROP(cx, principals)               \
-    ((--((principals)->refcount) == 0)                  \
-        ? (*(principals)->destroy)((cx), (principals))  \
-        : (void) 0)
+#ifdef JS_THREADSAFE
+#define JSPRINCIPALS_HOLD(cx, principals)   JS_HoldPrincipals(cx,principals)
+#define JSPRINCIPALS_DROP(cx, principals)   JS_DropPrincipals(cx,principals)
+
+extern JS_PUBLIC_API(jsrefcount)
+JS_HoldPrincipals(JSContext *cx, JSPrincipals *principals);
+
+extern JS_PUBLIC_API(jsrefcount)
+JS_DropPrincipals(JSContext *cx, JSPrincipals *principals);
+
+#else
+#define JSPRINCIPALS_HOLD(cx, principals)   (++(principals)->refcount)
+#define JSPRINCIPALS_DROP(cx, principals)                                     \
+    ((--(principals)->refcount == 0)                                          \
+     ? ((*(principals)->destroy)((cx), (principals)), 0)                      \
+     : (principals)->refcount)
+#endif
 
 extern JS_PUBLIC_API(JSPrincipalsTranscoder)
 JS_SetPrincipalsTranscoder(JSRuntime *rt, JSPrincipalsTranscoder px);
+
+extern JS_PUBLIC_API(JSObjectPrincipalsFinder)
+JS_SetObjectPrincipalsFinder(JSContext *cx, JSObjectPrincipalsFinder fop);
 
 /************************************************************************/
 
 /*
  * Functions and scripts.
  */
 extern JS_PUBLIC_API(JSFunction *)
 JS_NewFunction(JSContext *cx, JSNative call, uintN nargs, uintN flags,
Index: js.c
===================================================================
RCS file: /cvsroot/mozilla/js/src/js.c,v
retrieving revision 3.72
diff -p -u -8 -r3.72 js.c
--- js.c	26 Jul 2003 22:37:01 -0000	3.72
+++ js.c	30 Oct 2003 00:42:19 -0000
@@ -758,17 +758,17 @@ GetTrapArgs(JSContext *cx, uintN argc, j
 static JSTrapStatus
 TrapHandler(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
             void *closure)
 {
     JSString *str;
     JSStackFrame *caller;
 
     str = (JSString *) closure;
-    caller = cx->fp->down;
+    caller = JS_GetScriptedCaller(cx, NULL);
     if (!JS_EvaluateScript(cx, caller->scopeChain,
                            JS_GetStringBytes(str), JS_GetStringLength(str),
                            caller->script->filename, caller->script->lineno,
                            rval)) {
         return JSTRAP_ERROR;
     }
     if (*rval != JSVAL_VOID)
         return JSTRAP_RETURN;
Index: jscntxt.h
===================================================================
RCS file: /cvsroot/mozilla/js/src/jscntxt.h,v
retrieving revision 3.55
diff -p -u -8 -r3.55 jscntxt.h
--- jscntxt.h	26 Sep 2003 22:47:01 -0000	3.55
+++ jscntxt.h	30 Oct 2003 00:42:19 -0000
@@ -393,16 +393,19 @@ struct JSContext {
      * standard classes lazily, or if we are otherwise recursing indirectly
      * from js_LookupProperty through a JSClass.resolve hook.  It is used to
      * limit runaway recursion (see jsapi.c and jsobj.c).
      */
     JSDHashTable        *resolvingTable;
 
     /* PDL of stack headers describing stack slots not rooted by argv, etc. */
     JSStackHeader       *stackHeaders;
+
+    /* Optional hook to find principals for an object being accessed on cx. */
+    JSObjectPrincipalsFinder findObjectPrincipals;
 };
 
 /* Slightly more readable macros, also to hide bitset implementation detail. */
 #define JS_HAS_STRICT_OPTION(cx)    ((cx)->options & JSOPTION_STRICT)
 #define JS_HAS_WERROR_OPTION(cx)    ((cx)->options & JSOPTION_WERROR)
 
 extern JSContext *
 js_NewContext(JSRuntime *rt, size_t stackChunkSize);
Index: jsdbgapi.c
===================================================================
RCS file: /cvsroot/mozilla/js/src/jsdbgapi.c,v
retrieving revision 3.43
diff -p -u -8 -r3.43 jsdbgapi.c
--- jsdbgapi.c	1 Aug 2003 23:16:04 -0000	3.43
+++ jsdbgapi.c	30 Oct 2003 00:42:20 -0000
@@ -13,17 +13,17 @@
  * The Original Code is Mozilla Communicator client code, released
  * March 31, 1998.
  *
  * The Initial Developer of the Original Code is Netscape
  * Communications Corporation.  Portions created by Netscape are
  * Copyright (C) 1998 Netscape Communications Corporation. All
  * Rights Reserved.
  *
- * Contributor(s): 
+ * Contributor(s):
  *
  * Alternatively, the contents of this file may be used under the
  * terms of the GNU Public License (the "GPL"), in which case the
  * provisions of the GPL are applicable instead of those above.
  * If you wish to allow use of your version of this file only
  * under the terms of the GPL and not to allow others to use your
  * version of this file under the NPL, indicate your decision by
  * deleting the provisions above and replace them with the notice
@@ -347,17 +347,17 @@ js_watch_set(JSContext *cx, JSObject *ob
             HoldWatchPoint(wp);
             ok = wp->handler(cx, obj, userid,
                              SPROP_HAS_VALID_SLOT(sprop, scope)
                              ? OBJ_GET_SLOT(cx, obj, wp->sprop->slot)
                              : JSVAL_VOID,
                              vp, wp->closure);
             if (ok) {
                 /*
-                 * Create pseudo-frame for call to setter so that any 
+                 * Create pseudo-frame for call to setter so that any
                  * stack-walking security code in the setter will correctly
                  * identify the guilty party.
                  */
                 JSObject *funobj = (JSObject *) wp->closure;
                 JSFunction *fun = (JSFunction *) JS_GetPrivate(cx, funobj);
                 JSStackFrame frame;
 
                 memset(&frame, 0, sizeof(frame));
@@ -628,21 +628,58 @@ JS_GetFrameScript(JSContext *cx, JSStack
 }
 
 JS_PUBLIC_API(jsbytecode *)
 JS_GetFramePC(JSContext *cx, JSStackFrame *fp)
 {
     return fp->pc;
 }
 
+JS_PUBLIC_API(JSStackFrame *)
+JS_GetScriptedCaller(JSContext *cx, JSStackFrame *fp)
+{
+    if (!fp)
+        fp = cx->fp;
+    while ((fp = fp->down) != NULL) {
+        if (fp->script)
+            return fp;
+    }
+    return NULL;
+}
+
+JS_PUBLIC_API(JSPrincipals *)
+JS_StackFramePrincipals(JSContext *cx, JSStackFrame *fp)
+{
+    if (fp->fun && cx->findObjectPrincipals) {
+        JSObject *callee = JSVAL_TO_OBJECT(fp->argv[-2]);
+
+        if (fp->fun->object != callee)
+            return cx->findObjectPrincipals(cx, callee);
+        /* FALL THROUGH */
+    }
+    if (fp->script)
+        return fp->script->principals;
+    return NULL;
+}
+
+JS_PUBLIC_API(JSPrincipals *)
+JS_EvalFramePrincipals(JSContext *cx, JSStackFrame *fp, JSStackFrame *caller)
+{
+    if (cx->findObjectPrincipals)
+        return cx->findObjectPrincipals(cx, JSVAL_TO_OBJECT(fp->argv[-2]));
+    if (!caller)
+        return NULL;
+    return JS_StackFramePrincipals(cx, caller);
+}
+
 JS_PUBLIC_API(void *)
 JS_GetFrameAnnotation(JSContext *cx, JSStackFrame *fp)
 {
     if (fp->annotation && fp->script) {
-        JSPrincipals *principals = fp->script->principals;
+        JSPrincipals *principals = JS_StackFramePrincipals(cx, fp);
 
         if (principals && principals->globalPrivilegesEnabled(cx, principals)) {
             /*
              * Give out an annotation only if privileges have not been revoked
              * or disabled globally.
              */
             return fp->annotation;
         }
@@ -656,20 +693,18 @@ JS_SetFrameAnnotation(JSContext *cx, JSS
 {
     fp->annotation = annotation;
 }
 
 JS_PUBLIC_API(void *)
 JS_GetFramePrincipalArray(JSContext *cx, JSStackFrame *fp)
 {
     JSPrincipals *principals;
-    
-    if (!fp->script)
-        return NULL;
-    principals = fp->script->principals;
+
+    principals = JS_StackFramePrincipals(cx, fp);
     if (!principals)
         return NULL;
     return principals->getPrincipalArray(cx, principals);
 }
 
 JS_PUBLIC_API(JSBool)
 JS_IsNativeFrame(JSContext *cx, JSStackFrame *fp)
 {
@@ -811,19 +846,17 @@ JS_EvaluateUCInStackFrame(JSContext *cx,
 
     /*
      * XXX Hack around ancient compiler API to propagate the JSFRAME_SPECIAL
      * flags to the code generator (see js_EmitTree's TOK_SEMI case).
      */
     flags = fp->flags;
     fp->flags |= JSFRAME_DEBUGGER | JSFRAME_EVAL;
     script = JS_CompileUCScriptForPrincipals(cx, fp->scopeChain,
-                                             fp->script
-                                             ? fp->script->principals
-                                             : NULL,
+                                             JS_StackFramePrincipals(cx, fp),
                                              bytes, length, filename, lineno);
     fp->flags = flags;
     if (!script)
         return JS_FALSE;
 
     ok = js_Execute(cx, fp->scopeChain, script, fp,
                     JSFRAME_DEBUGGER | JSFRAME_EVAL, rval);
     js_DestroyScript(cx, script);
@@ -893,36 +926,36 @@ JS_GetPropertyDesc(JSContext *cx, JSObje
     if (wasThrowing) {
         lastException = cx->exception;
         if (JSVAL_IS_GCTHING(lastException) &&
             !js_AddRoot(cx, &lastException, "lastException")) {
                 return JS_FALSE;
         }
         cx->throwing = JS_FALSE;
     }
-    
+
     if (!js_GetProperty(cx, obj, sprop->id, &pd->value)) {
         if (!cx->throwing) {
             pd->flags = JSPD_ERROR;
             pd->value = JSVAL_VOID;
         } else {
             pd->flags = JSPD_EXCEPTION;
             pd->value = cx->exception;
         }
     } else {
         pd->flags = 0;
     }
-    
+
     cx->throwing = wasThrowing;
     if (wasThrowing) {
         cx->exception = lastException;
         if (JSVAL_IS_GCTHING(lastException))
             js_RemoveRoot(cx->runtime, &lastException);
     }
-    
+
     getter = sprop->getter;
     pd->flags |= ((sprop->attrs & JSPROP_ENUMERATE) ? JSPD_ENUMERATE : 0)
               | ((sprop->attrs & JSPROP_READONLY)  ? JSPD_READONLY  : 0)
               | ((sprop->attrs & JSPROP_PERMANENT) ? JSPD_PERMANENT : 0)
 #if JS_HAS_CALL_OBJECT
               | ((getter == js_GetCallVariable)    ? JSPD_VARIABLE  : 0)
 #endif /* JS_HAS_CALL_OBJECT */
               | ((getter == js_GetArgument)        ? JSPD_ARGUMENT  : 0)
@@ -1136,17 +1169,17 @@ JS_GetFunctionTotalSize(JSContext *cx, J
     JSAtom *atom;
 
     nbytes = sizeof *fun;
     JS_ASSERT(fun->nrefs);
     obj = fun->object;
     if (obj) {
         obytes = JS_GetObjectTotalSize(cx, obj);
         if (fun->nrefs > 1)
-            obytes = (obytes + fun->nrefs - 1) / fun->nrefs;
+            obytes = JS_HOWMANY(obytes, fun->nrefs);
         nbytes += obytes;
     }
     if (fun->script)
         nbytes += JS_GetScriptTotalSize(cx, fun->script);
     atom = fun->atom;
     if (atom)
         nbytes += GetAtomTotalSize(cx, atom);
     return nbytes;
@@ -1189,14 +1222,14 @@ JS_GetScriptTotalSize(JSContext *cx, JSS
         nbytes += (tn - tnotes + 1) * sizeof *tn;
     }
 
     principals = script->principals;
     if (principals) {
         JS_ASSERT(principals->refcount);
         pbytes = sizeof *principals;
         if (principals->refcount > 1)
-            pbytes = (pbytes + principals->refcount - 1) / principals->refcount;
+            pbytes = JS_HOWMANY(pbytes, principals->refcount);
         nbytes += pbytes;
     }
 
     return nbytes;
 }
Index: jsdbgapi.h
===================================================================
RCS file: /cvsroot/mozilla/js/src/jsdbgapi.h,v
retrieving revision 3.17
diff -p -u -8 -r3.17 jsdbgapi.h
--- jsdbgapi.h	19 Mar 2002 04:28:20 -0000	3.17
+++ jsdbgapi.h	30 Oct 2003 00:42:20 -0000
@@ -13,17 +13,17 @@
  * The Original Code is Mozilla Communicator client code, released
  * March 31, 1998.
  *
  * The Initial Developer of the Original Code is Netscape
  * Communications Corporation.  Portions created by Netscape are
  * Copyright (C) 1998 Netscape Communications Corporation. All
  * Rights Reserved.
  *
- * Contributor(s): 
+ * Contributor(s):
  *
  * Alternatively, the contents of this file may be used under the
  * terms of the GNU Public License (the "GPL"), in which case the
  * provisions of the GPL are applicable instead of those above.
  * If you wish to allow use of your version of this file only
  * under the terms of the GPL and not to allow others to use your
  * version of this file under the NPL, indicate your decision by
  * deleting the provisions above and replace them with the notice
@@ -140,28 +140,54 @@ extern JS_PUBLIC_API(JSStackFrame *)
 JS_FrameIterator(JSContext *cx, JSStackFrame **iteratorp);
 
 extern JS_PUBLIC_API(JSScript *)
 JS_GetFrameScript(JSContext *cx, JSStackFrame *fp);
 
 extern JS_PUBLIC_API(jsbytecode *)
 JS_GetFramePC(JSContext *cx, JSStackFrame *fp);
 
-extern JS_PUBLIC_API(JSBool)
-JS_IsNativeFrame(JSContext *cx, JSStackFrame *fp);
+/*
+ * Get the closest scripted frame below fp.  If fp is null, start from cx->fp.
+ */
+extern JS_PUBLIC_API(JSStackFrame *)
+JS_GetScriptedCaller(JSContext *cx, JSStackFrame *fp);
+
+/*
+ * Return a weak reference to fp's principals.  A null return does not denote
+ * an error, it means there are no principals.
+ */
+extern JS_PUBLIC_API(JSPrincipals *)
+JS_StackFramePrincipals(JSContext *cx, JSStackFrame *fp);
+
+/*
+ * Like JS_StackFramePrincipals(cx, caller), but if cx->findObjectPrincipals
+ * is non-null, return the object principals for fp's callee function object
+ * (fp->argv[-2]), which is eval, Function, or a similar eval-like method.
+ * The caller parameter should be the result of JS_GetScriptedCaller(cx, fp).
+ *
+ * All eval-like methods must use JS_EvalFramePrincipals to acquire a weak
+ * reference to the correct principals for the eval call to be secure, given
+ * an embedding that calls JS_SetObjectPrincipalsFinder (see jsapi.h).
+ */
+extern JS_PUBLIC_API(JSPrincipals *)
+JS_EvalFramePrincipals(JSContext *cx, JSStackFrame *fp, JSStackFrame *caller);
 
 extern JS_PUBLIC_API(void *)
 JS_GetFrameAnnotation(JSContext *cx, JSStackFrame *fp);
 
 extern JS_PUBLIC_API(void)
 JS_SetFrameAnnotation(JSContext *cx, JSStackFrame *fp, void *annotation);
 
 extern JS_PUBLIC_API(void *)
 JS_GetFramePrincipalArray(JSContext *cx, JSStackFrame *fp);
 
+extern JS_PUBLIC_API(JSBool)
+JS_IsNativeFrame(JSContext *cx, JSStackFrame *fp);
+
 /* this is deprecated, use JS_GetFrameScopeChain instead */
 extern JS_PUBLIC_API(JSObject *)
 JS_GetFrameObject(JSContext *cx, JSStackFrame *fp);
 
 extern JS_PUBLIC_API(JSObject *)
 JS_GetFrameScopeChain(JSContext *cx, JSStackFrame *fp);
 
 extern JS_PUBLIC_API(JSObject *)
@@ -198,17 +224,17 @@ JS_GetScriptFilename(JSContext *cx, JSSc
 extern JS_PUBLIC_API(uintN)
 JS_GetScriptBaseLineNumber(JSContext *cx, JSScript *script);
 
 extern JS_PUBLIC_API(uintN)
 JS_GetScriptLineExtent(JSContext *cx, JSScript *script);
 
 extern JS_PUBLIC_API(JSVersion)
 JS_GetScriptVersion(JSContext *cx, JSScript *script);
-     
+
 /************************************************************************/
 
 /*
  * Hook setters for script creation and destruction, see jsprvtd.h for the
  * typedefs.  These macros provide binary compatibility and newer, shorter
  * synonyms.
  */
 #define JS_SetNewScriptHook     JS_SetNewScriptHookProc
Index: jsfun.c
===================================================================
RCS file: /cvsroot/mozilla/js/src/jsfun.c,v
retrieving revision 3.89
diff -p -u -8 -r3.89 jsfun.c
--- jsfun.c	22 Oct 2003 06:26:03 -0000	3.89
+++ jsfun.c	30 Oct 2003 00:42:20 -0000
@@ -40,16 +40,17 @@
 #include "jstypes.h"
 #include "jsbit.h"
 #include "jsutil.h" /* Added by JSIFY */
 #include "jsapi.h"
 #include "jsarray.h"
 #include "jsatom.h"
 #include "jscntxt.h"
 #include "jsconfig.h"
+#include "jsdbgapi.h"
 #include "jsfun.h"
 #include "jsgc.h"
 #include "jsinterp.h"
 #include "jslock.h"
 #include "jsnum.h"
 #include "jsobj.h"
 #include "jsopcode.h"
 #include "jsparse.h"
@@ -1610,34 +1611,35 @@ js_IsIdentifier(JSString *str)
             return JS_FALSE;
     }
     return JS_TRUE;
 }
 
 static JSBool
 Function(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
+    JSStackFrame *fp, *caller;
     JSFunction *fun;
     JSObject *parent;
     uintN i, n, lineno, dupflag;
     JSAtom *atom;
     const char *filename;
     JSObject *obj2;
     JSScopeProperty *sprop;
     JSString *str, *arg;
-    JSStackFrame *fp;
     void *mark;
     JSTokenStream *ts;
     JSPrincipals *principals;
     jschar *collected_args, *cp;
     size_t arg_length, args_length;
     JSTokenType tt;
     JSBool ok;
 
-    if (cx->fp && !(cx->fp->flags & JSFRAME_CONSTRUCTING)) {
+    fp = cx->fp;
+    if (fp && !(fp->flags & JSFRAME_CONSTRUCTING)) {
         obj = js_NewObject(cx, &js_FunctionClass, NULL, NULL);
         if (!obj)
             return JS_FALSE;
         *rval = OBJECT_TO_JSVAL(obj);
     }
     fun = (JSFunction *) JS_GetPrivate(cx, obj);
     if (fun)
         return JS_TRUE;
@@ -1655,50 +1657,40 @@ Function(JSContext *cx, JSObject *obj, u
      */
     parent = OBJ_GET_PARENT(cx, JSVAL_TO_OBJECT(argv[-2]));
 #else
     /* Set up for dynamic parenting (see js_Invoke in jsinterp.c). */
     parent = NULL;
 #endif
 
     fun = js_NewFunction(cx, obj, NULL, 0, JSFUN_LAMBDA, parent,
-                         (JSVERSION_IS_ECMA(cx->version))
+                         JSVERSION_IS_ECMA(cx->version)
                          ? cx->runtime->atomState.anonymousAtom
                          : NULL);
 
     if (!fun)
         return JS_FALSE;
 
     /*
      * Function is static and not called directly by other functions in this
      * file, therefore it is callable only as a native function by js_Invoke.
      * Find the scripted caller, possibly skipping other native frames such as
      * are built for Function.prototype.call or .apply activations that invoke
      * Function indirectly from a script.
      */
-    fp = cx->fp;
     JS_ASSERT(!fp->script && fp->fun && fp->fun->native == Function);
-    for (;;) {
-        fp = fp->down;
-        if (!fp) {
-            filename = NULL;
-            lineno = 0;
-            principals = NULL;
-            break;
-        }
-        if (fp->script) {
-            /*
-             * Load fp->script->* before calling js_PCToLineNumber, to avoid
-             * a pessimal reload of fp->script.
-             */
-            principals = fp->script->principals;
-            filename = fp->script->filename;
-            lineno = js_PCToLineNumber(cx, fp->script, fp->pc);
-            break;
-        }
+    caller = JS_GetScriptedCaller(cx, fp);
+    if (caller) {
+        filename = caller->script->filename;
+        lineno = js_PCToLineNumber(cx, caller->script, caller->pc);
+        principals = JS_EvalFramePrincipals(cx, fp, caller);
+    } else {
+        filename = NULL;
+        lineno = 0;
+        principals = NULL;
     }
 
     n = argc ? argc - 1 : 0;
     if (n > 0) {
         /*
          * Collect the function-argument arguments into one string, separated
          * by commas, then make a tokenstream from that string, and scan it to
          * get the arguments.  We need to throw the full scanner at the
Index: jsobj.c
===================================================================
RCS file: /cvsroot/mozilla/js/src/jsobj.c,v
retrieving revision 3.151
diff -p -u -8 -r3.151 jsobj.c
--- jsobj.c	22 Oct 2003 06:26:03 -0000	3.151
+++ jsobj.c	30 Oct 2003 00:42:21 -0000
@@ -957,18 +957,18 @@ obj_eval(JSContext *cx, JSObject *obj, u
     JSScript *script;
     JSBool ok;
 #if JS_HAS_EVAL_THIS_SCOPE
     JSObject *callerScopeChain = NULL, *callerVarObj = NULL;
     JSBool setCallerScopeChain = JS_FALSE, setCallerVarObj = JS_FALSE;
 #endif
 
     fp = cx->fp;
-    caller = fp->down;
-    indirectCall = (!caller->pc || *caller->pc != JSOP_EVAL);
+    caller = JS_GetScriptedCaller(cx, fp);
+    indirectCall = (caller && caller->pc && *caller->pc != JSOP_EVAL);
 
     if (JSVERSION_IS_ECMA(cx->version) &&
         indirectCall &&
         !JS_ReportErrorFlagsAndNumber(cx,
                                       JSREPORT_WARNING | JSREPORT_STRICT,
                                       js_GetErrorMessage, NULL,
                                       JSMSG_BAD_INDIRECT_CALL,
                                       js_eval_str)) {
@@ -1019,48 +1019,51 @@ obj_eval(JSContext *cx, JSObject *obj, u
         /* From here on, control must exit through label out with ok set. */
 #endif
 
 #if JS_BUG_EVAL_THIS_SCOPE
         /* An old version used the object in which eval was found for scope. */
         scopeobj = obj;
 #else
         /* Compile using caller's current scope object. */
-        scopeobj = caller->scopeChain;
+        if (caller)
+            scopeobj = caller->scopeChain;
 #endif
     }
 
     str = JSVAL_TO_STRING(argv[0]);
-    if (caller->script) {
+    if (caller) {
         file = caller->script->filename;
         line = js_PCToLineNumber(cx, caller->script, caller->pc);
-        principals = caller->script->principals;
+        principals = JS_EvalFramePrincipals(cx, fp, caller);
     } else {
         file = NULL;
         line = 0;
         principals = NULL;
     }
 
+    /* XXXbe set only for the compiler, which does not currently test it */
     fp->flags |= JSFRAME_EVAL;
     script = JS_CompileUCScriptForPrincipals(cx, scopeobj, principals,
                                              JSSTRING_CHARS(str),
                                              JSSTRING_LENGTH(str),
                                              file, line);
     if (!script) {
         ok = JS_FALSE;
         goto out;
     }
 
 #if !JS_BUG_EVAL_THIS_SCOPE
 #if JS_HAS_SCRIPT_OBJECT
     if (argc < 2)
 #endif
     {
         /* Execute using caller's new scope object (might be a Call object). */
-        scopeobj = caller->scopeChain;
+        if (caller)
+            scopeobj = caller->scopeChain;
     }
 #endif
     ok = js_Execute(cx, scopeobj, script, caller, JSFRAME_EVAL, rval);
     JS_DestroyScript(cx, script);
 
 out:
 #if JS_HAS_EVAL_THIS_SCOPE
     /* Restore OBJ_GET_PARENT(scopeobj) not callerScopeChain in case of Call. */
Index: jspubtd.h
===================================================================
RCS file: /cvsroot/mozilla/js/src/jspubtd.h,v
retrieving revision 3.38
diff -p -u -8 -r3.38 jspubtd.h
--- jspubtd.h	27 Oct 2003 17:00:38 -0000	3.38
+++ jspubtd.h	30 Oct 2003 00:42:21 -0000
@@ -13,17 +13,17 @@
  * The Original Code is Mozilla Communicator client code, released
  * March 31, 1998.
  *
  * The Initial Developer of the Original Code is Netscape
  * Communications Corporation.  Portions created by Netscape are
  * Copyright (C) 1998 Netscape Communications Corporation. All
  * Rights Reserved.
  *
- * Contributor(s): 
+ * Contributor(s):
  *
  * Alternatively, the contents of this file may be used under the
  * terms of the GNU Public License (the "GPL"), in which case the
  * provisions of the GPL are applicable instead of those above.
  * If you wish to allow use of your version of this file only
  * under the terms of the GPL and not to allow others to use your
  * version of this file under the NPL, indicate your decision by
  * deleting the provisions above and replace them with the notice
@@ -509,17 +509,17 @@ typedef const JSErrorFormatString *
 #define JS_ARGUMENT_FORMATTER_DEFINED 1
 
 typedef JSBool
 (* JS_DLL_CALLBACK JSArgumentFormatter)(JSContext *cx, const char *format,
                                         JSBool fromJS, jsval **vpp,
                                         va_list *app);
 #endif
 
-typedef JSBool 
+typedef JSBool
 (* JS_DLL_CALLBACK JSLocaleToUpperCase)(JSContext *cx, JSString *src,
                                         jsval *rval);
 
 typedef JSBool
 (* JS_DLL_CALLBACK JSLocaleToLowerCase)(JSContext *cx, JSString *src,
                                         jsval *rval);
 
 typedef JSBool
@@ -537,12 +537,23 @@ typedef struct JSPrincipals JSPrincipals
  * JSXDR_ENCODE, in which case *principalsp should be encoded; or JSXDR_DECODE,
  * in which case implementations must return a held (via JSPRINCIPALS_HOLD),
  * non-null *principalsp out parameter.  Return true on success, false on any
  * error, which the implementation must have reported.
  */
 typedef JSBool
 (* JS_DLL_CALLBACK JSPrincipalsTranscoder)(JSXDRState *xdr,
                                            JSPrincipals **principalsp);
+
+/*
+ * Return a weak reference to the principals associated with obj, possibly via
+ * the immutable parent chain leading from obj to a top-level container (e.g.,
+ * a window object in the DOM level 0).  If there are no principals associated
+ * with obj, return null.  Therefore null does not mean an error was reported;
+ * in no event should an error be reported or an exception be thrown by this
+ * callback's implementation.
+ */
+typedef JSPrincipals *
+(* JS_DLL_CALLBACK JSObjectPrincipalsFinder)(JSContext *cx, JSObject *obj);
 
 JS_END_EXTERN_C
 
 #endif /* jspubtd_h___ */
Index: jsscript.c
===================================================================
RCS file: /cvsroot/mozilla/js/src/jsscript.c,v
retrieving revision 3.51
diff -p -u -8 -r3.51 jsscript.c
--- jsscript.c	27 Oct 2003 19:13:01 -0000	3.51
+++ jsscript.c	30 Oct 2003 00:42:21 -0000
@@ -169,38 +169,41 @@ script_compile(JSContext *cx, JSObject *
 
     /* Otherwise, the first arg is the script source to compile. */
     str = js_ValueToString(cx, argv[0]);
     if (!str)
         return JS_FALSE;
 
     /* Compile using the caller's scope chain, which js_Invoke passes to fp. */
     fp = cx->fp;
-    caller = fp->down;
-    JS_ASSERT(fp->scopeChain == caller->scopeChain);
+    caller = JS_GetScriptedCaller(cx, fp);
+    JS_ASSERT(!caller || fp->scopeChain == caller->scopeChain);
 
     scopeobj = NULL;
     if (argc >= 2) {
         if (!js_ValueToObject(cx, argv[1], &scopeobj))
             return JS_FALSE;
         argv[1] = OBJECT_TO_JSVAL(scopeobj);
     }
-    if (!scopeobj)
-        scopeobj = caller->scopeChain;
+    if (caller) {
+        if (!scopeobj)
+            scopeobj = caller->scopeChain;
 
-    if (caller->script) {
         file = caller->script->filename;
         line = js_PCToLineNumber(cx, caller->script, caller->pc);
-        principals = caller->script->principals;
+        principals = JS_EvalFramePrincipals(cx, fp, caller);
     } else {
         file = NULL;
         line = 0;
         principals = NULL;
     }
 
+    /* XXXbe set only for the compiler, which does not currently test it */
+    fp->flags |= JSFRAME_EVAL;
+
     /* Compile the new script using the caller's scope chain, a la eval(). */
     script = JS_CompileUCScriptForPrincipals(cx, scopeobj, principals,
                                              JSSTRING_CHARS(str),
                                              JSSTRING_LENGTH(str),
                                              file, line);
     if (!script)
         return JS_FALSE;
 
@@ -237,23 +240,20 @@ script_exec(JSContext *cx, JSObject *obj
     if (argc) {
         if (!js_ValueToObject(cx, argv[0], &scopeobj))
             return JS_FALSE;
         argv[0] = OBJECT_TO_JSVAL(scopeobj);
     }
 
     /* Emulate eval() by using caller's this, scope chain, and sharp array. */
     fp = cx->fp;
-    caller = fp->down;
-    if (!scopeobj)
-      scopeobj = caller->scopeChain;
-    fp->thisp = caller->thisp;
-    JS_ASSERT(fp->scopeChain == caller->scopeChain);
-    fp->sharpArray = caller->sharpArray;
-    return js_Execute(cx, scopeobj, script, fp, 0, rval);
+    caller = JS_GetScriptedCaller(cx, fp);
+    if (caller && !scopeobj)
+        scopeobj = caller->scopeChain;
+    return js_Execute(cx, scopeobj, script, caller, JSFRAME_EVAL, rval);
 }
 
 #if JS_HAS_XDR
 
 static JSBool
 XDRAtomListElement(JSXDRState *xdr, JSAtomListElement *ale)
 {
     jsval value;
