Bug 504021 - Add an API to the script security manager to clamp principals for a given context.

diff --git a/caps/idl/nsIScriptSecurityManager.idl b/caps/idl/nsIScriptSecurityManager.idl
--- a/caps/idl/nsIScriptSecurityManager.idl
+++ b/caps/idl/nsIScriptSecurityManager.idl
@@ -36,17 +36,17 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsISupports.idl"
 #include "nsIPrincipal.idl"
 #include "nsIXPCSecurityManager.idl"
 interface nsIURI;
 interface nsIChannel;
 
-[scriptable, uuid(f8e350b9-9f31-451a-8c8f-d10fea26b780)]
+[scriptable, uuid(c0dbfd5e-b7ae-4c18-8674-82492f35d715)]
 interface nsIScriptSecurityManager : nsIXPCSecurityManager
 {
     ///////////////// Security Checks //////////////////
     /**
      * Checks whether the running script is allowed to access aProperty.
      */
     [noscript] void checkPropertyAccess(in JSContextPtr aJSContext,
                                         in JSObjectPtr aJSObject,
@@ -185,16 +185,39 @@ interface nsIScriptSecurityManager : nsI
     /**
      * Return the principal of the innermost frame of the currently 
      * executing script. Will return null if there is no script 
      * currently executing.
      */
     [noscript] nsIPrincipal getSubjectPrincipal();
 
     /**
+     * If no scripted code is running "above" (or called from) fp, then
+     * instead of looking at cx->globalObject, we will return |principal|.
+     * This function only affects |cx|. If someone pushes another context onto
+     * the context stack, then it supercedes this call.
+     * NOTE: If |fp| is non-null popContextPrincipal must be called before fp
+     * has finished executing.
+     *
+     * @param cx The context to clamp.
+     * @param fp The frame pointer to clamp at. May be 'null'.
+     * @param principal The principal to clamp to.
+     */
+    [noscript] void pushContextPrincipal(in JSContextPtr cx,
+                                         in JSStackFramePtr fp,
+                                         in nsIPrincipal principal);
+
+    /**
+     * Removes a clamp set by pushContextPrincipal from cx. This must be
+     * called in a stack-like fashion (e.g., given two contexts |a| and |b|,
+     * it is not legal to do: push(a) push(b) pop(a)).
+     */
+    [noscript] void popContextPrincipal(in JSContextPtr cx);
+
+    /**
      * Return the all-powerful system principal.
      */
     [noscript] nsIPrincipal getSystemPrincipal();
 
     /**
      * Return a principal with the specified certificate fingerprint, subject
      * name (the full name or concatenated set of names of the entity
      * represented by the certificate), pretty name, certificate, and
diff --git a/caps/include/nsScriptSecurityManager.h b/caps/include/nsScriptSecurityManager.h
--- a/caps/include/nsScriptSecurityManager.h
+++ b/caps/include/nsScriptSecurityManager.h
@@ -481,25 +481,25 @@ private:
                               nsISupports* aCertificate,
                               nsIURI* aURI,
                               PRBool aModifyTable,
                               nsIPrincipal **result);
 
     // Returns null if a principal cannot be found.  Note that rv can be NS_OK
     // when this happens -- this means that there was no script for the
     // context.  Callers MUST pass in a non-null rv here.
-    static nsIPrincipal*
+    nsIPrincipal*
     GetSubjectPrincipal(JSContext* cx, nsresult* rv);
 
     // Returns null if a principal cannot be found.  Note that rv can be NS_OK
     // when this happens -- this means that there was no script for the frame.
     // Callers MUST pass in a non-null rv here.
-    static nsIPrincipal*
+    nsIPrincipal*
     GetFramePrincipal(JSContext* cx, JSStackFrame* fp, nsresult* rv);
-                                                     
+
     // Returns null if a principal cannot be found.  Note that rv can be NS_OK
     // when this happens -- this means that there was no script.  Callers MUST
     // pass in a non-null rv here.
     static nsIPrincipal*
     GetScriptPrincipal(JSContext* cx, JSScript* script, nsresult* rv);
 
     // Returns null if a principal cannot be found.  Note that rv can be NS_OK
     // when this happens -- this means that there was no script associated
@@ -509,17 +509,17 @@ private:
     // Callers MUST pass in a non-null rv here.
     static nsIPrincipal*
     GetFunctionObjectPrincipal(JSContext* cx, JSObject* obj, JSStackFrame *fp,
                                nsresult* rv);
 
     // Returns null if a principal cannot be found.  Note that rv can be NS_OK
     // when this happens -- this means that there was no script
     // running.  Callers MUST pass in a non-null rv here.
-    static nsIPrincipal*
+    nsIPrincipal*
     GetPrincipalAndFrame(JSContext *cx,
                          JSStackFrame** frameResult,
                          nsresult* rv);
 
     static PRBool
     CheckConfirmDialog(JSContext* cx, nsIPrincipal* aPrincipal,
                        const char* aCapability, PRBool *checkValue);
 
@@ -596,16 +596,27 @@ private:
     nsresult
     CheckComponentPermissions(JSContext *cx, const nsCID &aCID);
 #endif
 #ifdef DEBUG_CAPS_HACKER
     void
     PrintPolicyDB();
 #endif
 
+    struct ContextPrincipal {
+        ContextPrincipal(ContextPrincipal *next, JSContext *cx,
+                         JSStackFrame *fp, nsIPrincipal *principal)
+            : next(next), cx(cx), fp(fp), principal(principal) {}
+
+        ContextPrincipal *next;
+        JSContext *cx;
+        JSStackFrame *fp;
+        nsCOMPtr<nsIPrincipal> principal;
+    };
+
     // JS strings we need to clean up on shutdown
     static jsval sEnabledID;
 
     inline void
     ScriptSecurityPrefChanged();
 
     static const char sJSEnabledPrefName[];
     static const char sFileOriginPolicyPrefName[];
@@ -613,16 +624,21 @@ private:
     nsObjectHashtable* mOriginToPolicyMap;
     DomainPolicy* mDefaultPolicy;
     nsObjectHashtable* mCapabilities;
 
     nsCOMPtr<nsIPrefBranch> mPrefBranch;
     nsCOMPtr<nsISecurityPref> mSecurityPref;
     nsCOMPtr<nsIPrincipal> mSystemPrincipal;
     nsCOMPtr<nsIPrincipal> mSystemCertificate;
+    ContextPrincipal *mContextPrincipals;
+#ifdef DEBUG
+    PRUint32 mContextPrincipalsDepth;
+    PRUint32 mMaxContextPrincipalsDepth;
+#endif
     nsInterfaceHashtable<PrincipalKey, nsIPrincipal> mPrincipals;
     PRPackedBool mIsJavaScriptEnabled;
     PRPackedBool mIsWritingPrefs;
     PRPackedBool mPolicyPrefsChanged;
 #ifdef XPC_IDISPATCH_SUPPORT    
     PRPackedBool mXPCDefaultGrantAll;
     static const char sXPCDefaultGrantAllName[];
 #endif
diff --git a/caps/src/nsScriptSecurityManager.cpp b/caps/src/nsScriptSecurityManager.cpp
--- a/caps/src/nsScriptSecurityManager.cpp
+++ b/caps/src/nsScriptSecurityManager.cpp
@@ -1851,16 +1851,49 @@ nsScriptSecurityManager::GetSubjectPrinc
 {
     nsresult rv;
     *aSubjectPrincipal = doGetSubjectPrincipal(&rv);
     if (NS_SUCCEEDED(rv))
         NS_IF_ADDREF(*aSubjectPrincipal);
     return rv;
 }
 
+NS_IMETHODIMP
+nsScriptSecurityManager::PushContextPrincipal(JSContext *cx,
+                                              JSStackFrame *fp,
+                                              nsIPrincipal *principal)
+{
+    ContextPrincipal *cp = new ContextPrincipal(mContextPrincipals, cx, fp,
+                                                principal);
+    if (!cp)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+#ifdef DEBUG
+    if (++mContextPrincipalsDepth > mMaxContextPrincipalsDepth)
+        mMaxContextPrincipalsDepth = mContextPrincipalsDepth;
+#endif
+    mContextPrincipals = cp;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsScriptSecurityManager::PopContextPrincipal(JSContext *cx)
+{
+    NS_ASSERTION(mContextPrincipals->cx == cx, "Mismatched push/pop");
+
+#ifdef DEBUG
+    --mContextPrincipalsDepth;
+#endif
+    ContextPrincipal *next = mContextPrincipals->next;
+    delete mContextPrincipals;
+    mContextPrincipals = next;
+
+    return NS_OK;
+}
+
 nsIPrincipal*
 nsScriptSecurityManager::doGetSubjectPrincipal(nsresult* rv)
 {
     NS_PRECONDITION(rv, "Null out param");
     JSContext *cx = GetCurrentJSContext();
     if (!cx)
     {
         *rv = NS_OK;
@@ -2210,17 +2243,16 @@ nsScriptSecurityManager::GetFunctionObje
         if (!result)
             *rv = NS_ERROR_FAILURE;
         return result;
     }
 
     return GetScriptPrincipal(cx, script, rv);
 }
 
-// static
 nsIPrincipal*
 nsScriptSecurityManager::GetFramePrincipal(JSContext *cx,
                                            JSStackFrame *fp,
                                            nsresult *rv)
 {
     NS_PRECONDITION(rv, "Null out param");
     JSObject *obj = JS_GetFrameFunctionObject(cx, fp);
     if (!obj)
@@ -2240,41 +2272,65 @@ nsScriptSecurityManager::GetFramePrincip
 
         NS_ASSERTION(!script, "Null principal for non-native function!");
     }
 #endif
 
     return result;
 }
 
-// static
 nsIPrincipal*
 nsScriptSecurityManager::GetPrincipalAndFrame(JSContext *cx,
                                               JSStackFrame **frameResult,
                                               nsresult* rv)
 {
-    NS_PRECONDITION(rv, "Null out param");    
+    NS_PRECONDITION(rv, "Null out param");
     //-- If there's no principal on the stack, look at the global object
     //   and return the innermost frame for annotations.
     *rv = NS_OK;
+
     if (cx)
     {
+        JSStackFrame *target = nsnull;
+        nsIPrincipal *targetPrincipal = nsnull;
+        for (ContextPrincipal *cp = mContextPrincipals; cp; cp = cp->next)
+        {
+            if (cp->cx == cx)
+            {
+                target = cp->fp;
+                targetPrincipal = cp->principal;
+            }
+        }
+
         // Get principals from innermost frame of JavaScript or Java.
         JSStackFrame *fp = nsnull; // tell JS_FrameIterator to start at innermost
         for (fp = JS_FrameIterator(cx, &fp); fp; fp = JS_FrameIterator(cx, &fp))
         {
+            if (fp == target)
+                break;
             nsIPrincipal* result = GetFramePrincipal(cx, fp, rv);
             if (result)
             {
                 NS_ASSERTION(NS_SUCCEEDED(*rv), "Weird return");
                 *frameResult = fp;
                 return result;
             }
         }
 
+        // If targetPrincipal is non-null, then it means that someone wants to
+        // clamp the principals on this context to this principal. Note that
+        // fp might not equal target here (fp might be null) because someone
+        // could have set aside the frame chain in the meantime.
+        if (targetPrincipal)
+        {
+            JSStackFrame *inner = nsnull;
+            *frameResult = JS_FrameIterator(cx, &inner);
+            return targetPrincipal;
+        }
+
         nsIScriptContext *scriptContext = GetScriptContext(cx);
         if (scriptContext)
         {
             nsCOMPtr<nsIScriptObjectPrincipal> globalData =
                 do_QueryInterface(scriptContext->GetGlobalObject());
             if (!globalData)
             {
                 *rv = NS_ERROR_FAILURE;
@@ -2291,17 +2347,16 @@ nsScriptSecurityManager::GetPrincipalAnd
                 return result;
             }
         }
     }
 
     return nsnull;
 }
 
-// static
 nsIPrincipal*
 nsScriptSecurityManager::GetSubjectPrincipal(JSContext *cx,
                                              nsresult* rv)
 {
     NS_PRECONDITION(rv, "Null out param");
     JSStackFrame *fp;
     return GetPrincipalAndFrame(cx, &fp, rv);
 }
@@ -3292,16 +3347,21 @@ nsScriptSecurityManager::Observe(nsISupp
 
 /////////////////////////////////////////////
 // Constructor, Destructor, Initialization //
 /////////////////////////////////////////////
 nsScriptSecurityManager::nsScriptSecurityManager(void)
     : mOriginToPolicyMap(nsnull),
       mDefaultPolicy(nsnull),
       mCapabilities(nsnull),
+      mContextPrincipals(nsnull),
+#ifdef DEBUG
+      mContextPrincipalsDepth(0),
+      mMaxContextPrincipalsDepth(0),
+#endif
       mIsJavaScriptEnabled(PR_FALSE),
       mIsWritingPrefs(PR_FALSE),
       mPolicyPrefsChanged(PR_TRUE)
 #ifdef XPC_IDISPATCH_SUPPORT
       , mXPCDefaultGrantAll(PR_FALSE)
 #endif
 {
     NS_ASSERTION(sizeof(PRWord) == sizeof(void*),
@@ -3374,16 +3434,20 @@ nsresult nsScriptSecurityManager::Init()
 }
 
 static nsScriptSecurityManager *gScriptSecMan = nsnull;
 
 jsval nsScriptSecurityManager::sEnabledID   = JSVAL_VOID;
 
 nsScriptSecurityManager::~nsScriptSecurityManager(void)
 {
+#ifdef DEBUG
+    printf("Max context principals depth: %u\n", mMaxContextPrincipalsDepth);
+#endif
+    NS_ASSERTION(!mContextPrincipals, "Leaking mContextPrincipals");
     delete mOriginToPolicyMap;
     if(mDefaultPolicy)
         mDefaultPolicy->Drop();
     delete mCapabilities;
     gScriptSecMan = nsnull;
 }
 
 void
diff --git a/js/src/xpconnect/shell/xpcshell.cpp b/js/src/xpconnect/shell/xpcshell.cpp
--- a/js/src/xpconnect/shell/xpcshell.cpp
+++ b/js/src/xpconnect/shell/xpcshell.cpp
@@ -1271,16 +1271,30 @@ FullTrustSecMan::CanExecuteScripts(JSCon
 /* [noscript] nsIPrincipal getSubjectPrincipal (); */
 NS_IMETHODIMP
 FullTrustSecMan::GetSubjectPrincipal(nsIPrincipal **_retval)
 {
     NS_IF_ADDREF(*_retval = mSystemPrincipal);
     return *_retval ? NS_OK : NS_ERROR_FAILURE;
 }
 
+/* [noscript] void pushContextPrincipal (in JSContextPtr cx, in JSStackFramePtr fp, in nsIPrincipal principal); */
+NS_IMETHODIMP
+FullTrustSecMan::PushContextPrincipal(JSContext * cx, JSStackFrame * fp, nsIPrincipal *principal)
+{
+    return NS_OK;
+}
+
+/* [noscript] void popContextPrincipal (in JSContextPtr cx); */
+NS_IMETHODIMP
+FullTrustSecMan::PopContextPrincipal(JSContext * cx)
+{
+    return NS_OK;
+}
+
 /* [noscript] nsIPrincipal getSystemPrincipal (); */
 NS_IMETHODIMP
 FullTrustSecMan::GetSystemPrincipal(nsIPrincipal **_retval)
 {
     NS_IF_ADDREF(*_retval = mSystemPrincipal);
     return *_retval ? NS_OK : NS_ERROR_FAILURE;
 }
 
diff --git a/js/src/xpconnect/src/XPCSafeJSObjectWrapper.cpp b/js/src/xpconnect/src/XPCSafeJSObjectWrapper.cpp
--- a/js/src/xpconnect/src/XPCSafeJSObjectWrapper.cpp
+++ b/js/src/xpconnect/src/XPCSafeJSObjectWrapper.cpp
@@ -37,16 +37,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "xpcprivate.h"
 #include "jsdbgapi.h"
 #include "jsscript.h" // for js_ScriptClass
 #include "XPCWrapper.h"
 #include "jsregexp.h"
+#include "nsJSPrincipals.h"
 
 static JSBool
 XPC_SJOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
 static JSBool
 XPC_SJOW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
 static JSBool
@@ -162,33 +163,57 @@ CanCallerAccess(JSContext *cx, JSObject 
     if (!enabled) {
       return ThrowException(NS_ERROR_XPC_SECURITY_MANAGER_VETO, cx);
     }
   }
 
   return PR_TRUE;
 }
 
-static JSPrincipals *
-FindObjectPrincipals(JSContext *cx, JSObject *obj)
+// Reserved slot indexes on safe wrappers.
+
+// Boolean value, initialized to false on object creation and true
+// only while we're resolving a property on the object.
+#define XPC_SJOW_SLOT_IS_RESOLVING           0
+
+// Slot for holding on to the principal to use if a principal other
+// than that of the unsafe object is desired for this wrapper
+// (nsIPrincipal, strong reference).
+#define XPC_SJOW_SLOT_PRINCIPAL              1
+
+
+// Returns a weak reference.
+static nsIPrincipal *
+FindObjectPrincipals(JSContext *cx, JSObject *safeObj, JSObject *innerObj)
 {
+  // Check if we have a cached principal first.
+  jsval v;
+  if (!JS_GetReservedSlot(cx, safeObj, XPC_SJOW_SLOT_PRINCIPAL, &v)) {
+    return nsnull;
+  }
+
+  if (!JSVAL_IS_VOID(v)) {
+    // Found one! No need to do any more refcounting.
+    return static_cast<nsIPrincipal *>(JSVAL_TO_PRIVATE(v));
+  }
+
   nsCOMPtr<nsIPrincipal> objPrincipal;
-  nsresult rv = FindPrincipals(cx, obj, getter_AddRefs(objPrincipal), nsnull,
+  nsresult rv = FindPrincipals(cx, innerObj, getter_AddRefs(objPrincipal), nsnull,
                                nsnull);
   if (NS_FAILED(rv)) {
     return nsnull;
   }
 
-  JSPrincipals *jsprin;
-  rv = objPrincipal->GetJSPrincipals(cx, &jsprin);
-  if (NS_FAILED(rv)) {
+  if (!JS_SetReservedSlot(cx, safeObj, XPC_SJOW_SLOT_PRINCIPAL,
+                          PRIVATE_TO_JSVAL(objPrincipal.get()))) {
     return nsnull;
   }
 
-  return jsprin;
+  // The wrapper owns the principal now.
+  return objPrincipal.forget().get();
 }
 
 
 // JS class for XPCSafeJSObjectWrapper (and this doubles as the
 // constructor for XPCSafeJSObjectWrapper for the moment too...)
 
 JSExtendedClass sXPC_SJOW_JSClass = {
   // JSClass (JSExtendedClass.base) initialization
@@ -212,39 +237,16 @@ JSExtendedClass sXPC_SJOW_JSClass = {
   XPC_SJOW_WrappedObject,
   JSCLASS_NO_RESERVED_MEMBERS
 };
 
 static JSBool
 XPC_SJOW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                   jsval *rval);
 
-// Reserved slot indexes on safe wrappers.
-
-// Boolean value, initialized to false on object creation and true
-// only while we're resolving a property on the object.
-#define XPC_SJOW_SLOT_IS_RESOLVING           0
-
-// Slot for caching a compiled scripted function for property
-// get/set.
-#define XPC_SJOW_SLOT_SCRIPTED_GETSET        1
-
-// Slot for caching a compiled scripted function for function
-// calling.
-#define XPC_SJOW_SLOT_SCRIPTED_FUN           2
-
-// Slot for caching a compiled scripted function for calling
-// toString().
-#define XPC_SJOW_SLOT_SCRIPTED_TOSTRING      3
-
-// Slot for holding on to the principal to use if a principal other
-// than that of the unsafe object is desired for this wrapper
-// (nsIPrincipal, strong reference).
-#define XPC_SJOW_SLOT_PRINCIPAL              4
-
 
 // Wrap a JS value in a safe wrapper of a function wrapper if
 // needed. Note that rval must point to something rooted when calling
 // this function.
 static JSBool
 WrapJSValue(JSContext *cx, JSObject *obj, jsval val, jsval *rval)
 {
   JSBool ok = JS_TRUE;
@@ -261,31 +263,17 @@ WrapJSValue(JSContext *cx, JSObject *obj
     if (!safeObj) {
       return JS_FALSE;
     }
 
     // Set *rval to safeObj here to ensure it doesn't get collected in
     // any of the code below.
     *rval = OBJECT_TO_JSVAL(safeObj);
 
-    // If obj and safeObj are from the same scope, propagate cached
-    // scripted functions to the new safe object.
-    if (JS_GetGlobalForObject(cx, obj) == JS_GetGlobalForObject(cx, safeObj)) {
-      jsval rsval;
-      if (!::JS_GetReservedSlot(cx, obj, XPC_SJOW_SLOT_SCRIPTED_GETSET,
-                                &rsval) ||
-          !::JS_SetReservedSlot(cx, safeObj, XPC_SJOW_SLOT_SCRIPTED_GETSET,
-                                rsval) ||
-          !::JS_GetReservedSlot(cx, obj, XPC_SJOW_SLOT_SCRIPTED_FUN,
-                                &rsval) ||
-          !::JS_SetReservedSlot(cx, safeObj, XPC_SJOW_SLOT_SCRIPTED_FUN,
-                                rsval)) {
-        return JS_FALSE;
-      }
-    } else {
+    if (JS_GetGlobalForObject(cx, obj) != JS_GetGlobalForObject(cx, safeObj)) {
       // Check to see if the new object we just wrapped is accessible
       // from the unsafe object we got the new object through. If not,
       // force the new wrapper to use the principal of the unsafe
       // object we got the new object from.
       nsCOMPtr<nsIPrincipal> srcObjPrincipal;
       nsCOMPtr<nsIPrincipal> subjPrincipal;
       nsCOMPtr<nsIPrincipal> valObjPrincipal;
 
@@ -390,91 +378,16 @@ UnwrapJSValue(jsval val)
   JSObject *unsafeObj = GetUnsafeObject(JSVAL_TO_OBJECT(val));
   if (unsafeObj) {
     return OBJECT_TO_JSVAL(unsafeObj);
   }
 
   return val;
 }
 
-// Get a scripted function for use with the safe wrapper (obj) when
-// accessing an unsafe object (unsafeObj). If a scripted function
-// already exists in the reserved slot slotIndex, use it, otherwise
-// create a new one and cache it in that same slot. The source of the
-// script is passed in funScript, and the resulting (new or cached)
-// scripted function is returned through scriptedFunVal.
-/* Keep GetScriptedFunction prototype in sync with corresponding macro */
-static JSBool
-GetScriptedFunction(JSContext *cx, JSObject *obj, JSObject *unsafeObj,
-                    uint32 slotIndex, const nsAFlatCString& funScript,
-                    jsval *scriptedFunVal, uintN lineno)
-{
-  if (!::JS_GetReservedSlot(cx, obj, slotIndex, scriptedFunVal)) {
-    return JS_FALSE;
-  }
-
-  // If we either have no scripted function in the requested slot yet,
-  // or if the scope of the unsafeObj changed since we compiled the
-  // scripted function, re-compile to make sure the scripted function
-  // is properly scoped etc.
-  if (JSVAL_IS_VOID(*scriptedFunVal) ||
-      JS_GetGlobalForObject(cx, unsafeObj) !=
-      JS_GetGlobalForObject(cx, JSVAL_TO_OBJECT(*scriptedFunVal))) {
-    // Check whether we have a cached principal or not.
-    jsval pv;
-    if (!::JS_GetReservedSlot(cx, obj, XPC_SJOW_SLOT_PRINCIPAL, &pv)) {
-      return JS_FALSE;
-    }
-
-    JSPrincipals *jsprin = nsnull;
-
-    if (!JSVAL_IS_VOID(pv)) {
-      nsIPrincipal *principal = (nsIPrincipal *)JSVAL_TO_PRIVATE(pv);
-
-      // Found a cached principal, use it rather than looking up the
-      // principal of the unsafe object.
-      principal->GetJSPrincipals(cx, &jsprin);
-    } else {
-      // No cached principal found, look up the principal based on the
-      // unsafe object.
-      jsprin = FindObjectPrincipals(cx, unsafeObj);
-    }
-
-    if (!jsprin) {
-      return ThrowException(NS_ERROR_UNEXPECTED, cx);
-    }
-
-    JSFunction *scriptedFun =
-      ::JS_CompileFunctionForPrincipals(cx,
-                                        JS_GetGlobalForObject(cx, unsafeObj),
-                                        jsprin, nsnull, 0, nsnull,
-                                        funScript.get(), funScript.Length(),
-                                        "XPCSafeJSObjectWrapper.cpp",
-                                        lineno);
-
-    JSPRINCIPALS_DROP(cx, jsprin);
-
-    if (!scriptedFun) {
-      return ThrowException(NS_ERROR_FAILURE, cx);
-    }
-
-    *scriptedFunVal = OBJECT_TO_JSVAL(::JS_GetFunctionObject(scriptedFun));
-
-    if (*scriptedFunVal == JSVAL_NULL ||
-        !::JS_SetReservedSlot(cx, obj, slotIndex, *scriptedFunVal)) {
-      return JS_FALSE;
-    }
-  }
-
-  return JS_TRUE;
-}
-
-#define GetScriptedFunction(cx, obj, unsafeObj, slotIndex, funScript, scriptedFunVal) \
-  (GetScriptedFunction)(cx, obj, unsafeObj, slotIndex, funScript, scriptedFunVal, __LINE__)
-
 static JSBool
 XPC_SJOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   // The constructor and toString properties needs to live on the safe
   // wrapper.
   if (id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_CONSTRUCTOR) ||
       id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_TO_STRING)) {
     return JS_TRUE;
@@ -518,33 +431,63 @@ XPC_SJOW_DelProperty(JSContext *cx, JSOb
   if (!CanCallerAccess(cx, unsafeObj)) {
     // CanCallerAccess() already threw for us.
     return JS_FALSE;
   }
 
   return XPCWrapper::DelProperty(cx, unsafeObj, id, vp);
 }
 
-static inline JSBool
-CallWithoutStatics(JSContext *cx, JSObject *obj, jsval fval, uintN argc,
-                   jsval *argv, jsval *rval)
-{
+NS_STACK_CLASS class SafeCallGuard {
+public:
+  SafeCallGuard(JSContext *cx, nsIPrincipal *principal)
+    : cx(cx) {
+    nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
+    if (ssm) {
+      // Note: We pass null as the target frame pointer because we know that
+      // we're about to set aside the frame chain.
+      nsresult rv = ssm->PushContextPrincipal(cx, nsnull, principal);
+      if (NS_FAILED(rv)) {
+        NS_WARNING("Not allowing call because we're out of memory");
+        JS_ReportOutOfMemory(cx);
+        this->cx = nsnull;
+        return;
+      }
+    }
+
+    js_SaveRegExpStatics(cx, &statics, &tvr);
+    JS_ClearRegExpStatics(cx);
+    fp = JS_SaveFrameChain(cx);
+    options =
+      JS_SetOptions(cx, JS_GetOptions(cx) | JSOPTION_DONT_REPORT_UNCAUGHT);
+  }
+
+  JSBool ready() {
+    return cx != nsnull;
+  }
+
+  ~SafeCallGuard() {
+    if (cx) {
+      JS_SetOptions(cx, options);
+      JS_RestoreFrameChain(cx, fp);
+      js_RestoreRegExpStatics(cx, &statics, &tvr);
+      nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
+      if (ssm) {
+        ssm->PopContextPrincipal(cx);
+      }
+    }
+  }
+
+private:
+  JSContext *cx;
   JSRegExpStatics statics;
   JSTempValueRooter tvr;
-  js_SaveRegExpStatics(cx, &statics, &tvr);
-  JS_ClearRegExpStatics(cx);
-  JSStackFrame *fp = JS_SaveFrameChain(cx);
-  uint32 options =
-    JS_SetOptions(cx, JS_GetOptions(cx) | JSOPTION_DONT_REPORT_UNCAUGHT);
-  JSBool ok = ::JS_CallFunctionValue(cx, obj, fval, argc, argv, rval);
-  JS_SetOptions(cx, options);
-  JS_RestoreFrameChain(cx, fp);
-  js_RestoreRegExpStatics(cx, &statics, &tvr);
-  return ok;
-}
+  uint32 options;
+  JSStackFrame *fp;
+};
 
 static JSBool
 XPC_SJOW_GetOrSetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp,
                           JSBool aIsSet)
 {
   // We resolve toString to a function in our resolve hook.
   if (id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_TO_STRING)) {
     return JS_TRUE;
@@ -559,45 +502,35 @@ XPC_SJOW_GetOrSetProperty(JSContext *cx,
   }
 
   // Check that the caller can access the unsafe object.
   if (!CanCallerAccess(cx, unsafeObj)) {
     // CanCallerAccess() already threw for us.
     return JS_FALSE;
   }
 
-  // Function body for wrapping property get/set in a scripted
-  // caller. This scripted function's first argument is the property
-  // to get/set. If the operation is a get operation, the function is
-  // passed one argument. If the operation is a set operation, the
-  // function gets two arguments and the second argument will be the
-  // value to set the property to.
-  NS_NAMED_LITERAL_CSTRING(funScript,
-    "if (arguments.length == 1) return this[arguments[0]];"
-    "return this[arguments[0]] = arguments[1];");
-
-  jsval scriptedFunVal;
-  if (!GetScriptedFunction(cx, obj, unsafeObj, XPC_SJOW_SLOT_SCRIPTED_GETSET,
-                           funScript, &scriptedFunVal)) {
+  SafeCallGuard guard(cx, FindObjectPrincipals(cx, obj, unsafeObj));
+  if (!guard.ready()) {
     return JS_FALSE;
   }
 
-  // Build up our argument array per the comment above.
-  jsval args[2];
-
-  args[0] = id;
+  jsid interned_id;
+  if (!JS_ValueToId(cx, id, &interned_id)) {
+    return JS_FALSE;
+  }
 
   if (aIsSet) {
-    args[1] = UnwrapJSValue(*vp);
+    *vp = UnwrapJSValue(*vp);
   }
 
-  jsval val;
-  JSBool ok = CallWithoutStatics(cx, unsafeObj, scriptedFunVal,
-                                 aIsSet ? 2 : 1, args, &val);
-  return ok && WrapJSValue(cx, obj, val, vp);
+  JSBool ok = aIsSet
+              ? JS_SetPropertyById(cx, unsafeObj, interned_id, vp)
+              : JS_GetPropertyById(cx, unsafeObj, interned_id, vp);
+
+  return ok && WrapJSValue(cx, obj, *vp, vp);
 }
 
 static JSBool
 XPC_SJOW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
   return XPC_SJOW_GetOrSetProperty(cx, obj, id, vp, PR_FALSE);
 }
 
@@ -762,76 +695,45 @@ XPC_SJOW_Call(JSContext *cx, JSObject *o
   if (!unsafeObj) {
     return ThrowException(NS_ERROR_UNEXPECTED, cx);
   }
 
   if (!callThisObj) {
     callThisObj = unsafeObj;
   }
 
-  JSObject *funToCall = GetUnsafeObject(JSVAL_TO_OBJECT(argv[-2]));
+  JSObject *safeObj = JSVAL_TO_OBJECT(argv[-2]);
+  JSObject *funToCall = GetUnsafeObject(safeObj);
 
   if (!funToCall) {
     // Someone has called XPCSafeJSObjectWrapper.prototype() causing
     // us to find a safe object wrapper without an unsafeObject as
     // its parent. That call shouldn't do anything, so bail here.
     return JS_TRUE;
   }
 
   // Check that the caller can access the unsafe object on which the
   // call is being made, and the actual function we're about to call.
   if (!CanCallerAccess(cx, unsafeObj) || !CanCallerAccess(cx, funToCall)) {
     // CanCallerAccess() already threw for us.
     return JS_FALSE;
   }
 
-  // Function body for wrapping calls to functions or callable objects
-  // in a scripted caller. This scripted function's first argument is
-  // a native call wrapper, and the second argument is the unsafe
-  // function to call. All but the first argument are passed to the
-  // call wrapper.
-  NS_NAMED_LITERAL_CSTRING(funScript,
-                           "var args = [];"
-                           "for (var i = 1; i < arguments.length; i++)"
-                           "args.push(arguments[i]);"
-                           "return arguments[0].apply(this, args);");
+  SafeCallGuard guard(cx, FindObjectPrincipals(cx, safeObj, funToCall));
 
-  // Get the scripted function.
-  jsval scriptedFunVal;
-  if (!GetScriptedFunction(cx, obj, unsafeObj, XPC_SJOW_SLOT_SCRIPTED_FUN,
-                           funScript, &scriptedFunVal)) {
+  for (uintN i = 0; i < argc; ++i) {
+    argv[i] = UnwrapJSValue(argv[i]);
+  }
+
+  if (!JS_CallFunctionValue(cx, callThisObj, OBJECT_TO_JSVAL(funToCall),
+                            argc, argv, rval)) {
     return JS_FALSE;
   }
 
-  // Build up our argument array per earlier comment.
-  jsval argsBuf[8];
-  jsval *args = argsBuf;
-
-  if (argc > 7) {
-    args = (jsval *)nsMemory::Alloc((argc + 1) * sizeof(jsval *));
-    if (!args) {
-      return ThrowException(NS_ERROR_OUT_OF_MEMORY, cx);
-    }
-  }
-
-  args[0] = OBJECT_TO_JSVAL(funToCall);
-
-  for (uintN i = 0; i < argc; ++i) {
-    args[i + 1] = UnwrapJSValue(argv[i]);
-  }
-
-  jsval val;
-  JSBool ok = CallWithoutStatics(cx, callThisObj, scriptedFunVal, argc + 1,
-                                 args, &val);
-
-  if (args != argsBuf) {
-    nsMemory::Free(args);
-  }
-
-  return ok && WrapJSValue(cx, obj, val, rval);
+  return WrapJSValue(cx, obj, *rval, rval);
 }
 
 JSBool
 XPC_SJOW_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                    jsval *rval)
 {
   if (argc < 1) {
     return ThrowException(NS_ERROR_XPC_NOT_ENOUGH_ARGS, cx);
@@ -925,19 +827,24 @@ XPC_SJOW_Create(JSContext *cx, JSObject 
   JSObject *unsafeObj = GetUnsafeObject(callee);
 
   // Check that the caller can access the unsafe object.
   if (!CanCallerAccess(cx, unsafeObj)) {
     // CanCallerAccess() already threw for us.
     return JS_FALSE;
   }
 
-  JSBool ok = CallWithoutStatics(cx, obj, OBJECT_TO_JSVAL(callee), argc, argv,
-                                 rval);
-  return ok && WrapJSValue(cx, callee, *rval, rval);
+  SafeCallGuard guard(cx, FindObjectPrincipals(cx, callee, unsafeObj));
+  if (!guard.ready()) {
+    return JS_FALSE;
+  }
+
+  return JS_CallFunctionValue(cx, obj, OBJECT_TO_JSVAL(callee),
+                              argc, argv, rval) &&
+         WrapJSValue(cx, callee, *rval, rval);
 }
 
 static JSBool
 XPC_SJOW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
 {
   if (JSVAL_IS_PRIMITIVE(v)) {
     *bp = JS_FALSE;
   } else {
@@ -1038,29 +945,27 @@ XPC_SJOW_toString(JSContext *cx, JSObjec
   }
 
   // Check that the caller can access the unsafe object.
   if (!CanCallerAccess(cx, unsafeObj)) {
     // CanCallerAccess() already threw for us.
     return JS_FALSE;
   }
 
-  // Function body for wrapping toString() in a scripted caller.
-  NS_NAMED_LITERAL_CSTRING(funScript, "return '' + this;");
-
-  jsval scriptedFunVal;
-  if (!GetScriptedFunction(cx, obj, unsafeObj, XPC_SJOW_SLOT_SCRIPTED_TOSTRING,
-                           funScript, &scriptedFunVal)) {
+  SafeCallGuard guard(cx, FindObjectPrincipals(cx, obj, unsafeObj));
+  if (!guard.ready()) {
     return JS_FALSE;
   }
 
-  jsval val;
-  JSBool ok = CallWithoutStatics(cx, unsafeObj, scriptedFunVal, 0, nsnull,
-                                 &val);
-  return ok && WrapJSValue(cx, obj, val, rval);
+  JSString *str = JS_ValueToString(cx, OBJECT_TO_JSVAL(unsafeObj));
+  if (!str) {
+    return JS_FALSE;
+  }
+  *rval = STRING_TO_JSVAL(str);
+  return JS_TRUE;
 }
 
 PRBool
 XPC_SJOW_AttachNewConstructorObject(XPCCallContext &ccx,
                                     JSObject *aGlobalObject)
 {
   // Initialize sEvalNative the first time we attach a constructor.
   // NB: This always happens before any cross origin wrappers are
diff --git a/js/src/xpconnect/src/xpcwrappedjsclass.cpp b/js/src/xpconnect/src/xpcwrappedjsclass.cpp
--- a/js/src/xpconnect/src/xpcwrappedjsclass.cpp
+++ b/js/src/xpconnect/src/xpcwrappedjsclass.cpp
@@ -1270,16 +1270,18 @@ nsXPCWrappedJSClass::CallMethod(nsXPCWra
     JSObject* obj;
     const char* name = info->name;
     jsval fval;
     void* mark;
     JSBool foundDependentParam;
     XPCContext* xpcc;
     JSContext* cx;
     JSObject* thisObj;
+    JSBool popPrincipal = JS_FALSE;
+    nsIScriptSecurityManager* ssm = nsnull;
 
     // Make sure not to set the callee on ccx until after we've gone through
     // the whole nsIXPCFunctionThisTranslator bit.  That code uses ccx to
     // convert natives to JSObjects, but we do NOT plan to pass those JSObjects
     // to our real callee.
     JSContext *context = GetContextFromObject(wrapper->GetJSObject());
     XPCCallContext ccx(NATIVE_CALLER, context);
     if(ccx.IsValid())
@@ -1592,18 +1594,16 @@ nsXPCWrappedJSClass::CallMethod(nsXPCWra
                 }
             }
             *sp++ = OBJECT_TO_JSVAL(out_obj);
         }
         else
             *sp++ = val;
     }
 
-
-
     readyToDoTheCall = JS_TRUE;
 
 pre_call_clean_up:
     // clean up any 'out' params handed in
     for(i = 0; i < paramCount; i++)
     {
         const nsXPTParamInfo& param = info->params[i];
         if(!param.IsOut())
@@ -1655,16 +1655,41 @@ pre_call_clean_up:
 
     if(!readyToDoTheCall)
         goto done;
 
     // do the deed - note exceptions
 
     JS_ClearPendingException(cx);
 
+    if(XPCPerThreadData::IsMainThread(ccx))
+    {
+        ssm = XPCWrapper::GetSecurityManager();
+        if(ssm)
+        {
+            nsCOMPtr<nsIPrincipal> objPrincipal;
+            ssm->GetObjectPrincipal(ccx, obj, getter_AddRefs(objPrincipal));
+            if(objPrincipal)
+            {
+                JSStackFrame* fp = nsnull;
+                nsresult rv =
+                    ssm->PushContextPrincipal(ccx, JS_FrameIterator(ccx, &fp),
+                                              objPrincipal);
+                if(NS_FAILED(rv))
+                {
+                    JS_ReportOutOfMemory(ccx);
+                    retval = NS_ERROR_OUT_OF_MEMORY;
+                    goto done;
+                }
+
+                popPrincipal = JS_TRUE;
+            }
+        }
+    }
+
     if(XPT_MD_IS_GETTER(info->flags))
         success = JS_GetProperty(cx, obj, name, &result);
     else if(XPT_MD_IS_SETTER(info->flags))
         success = JS_SetProperty(cx, obj, name, sp-1);
     else
     {
         if(!JSVAL_IS_PRIMITIVE(fval))
         {
@@ -1691,17 +1716,20 @@ pre_call_clean_up:
                                            nsnull, getter_AddRefs(e), nsnull, nsnull);
             xpcc->SetException(e);
             if(sz)
                 JS_smprintf_free(sz);
             success = JS_FALSE;
         }
     }
 
-    if (!success)
+    if(popPrincipal)
+        ssm->PopContextPrincipal(ccx);
+
+    if(!success)
     {
         PRBool forceReport;
         if(NS_FAILED(mInfo->IsFunction(&forceReport)))
             forceReport = PR_FALSE;
 
         // May also want to check if we're moving from content->chrome and force
         // a report in that case.
 
