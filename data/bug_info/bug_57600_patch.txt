Index: content/html/document/src/nsHTMLDocument.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/html/document/src/nsHTMLDocument.cpp,v
retrieving revision 3.547.2.2.2.2
diff -u -9 -p -r3.547.2.2.2.2 nsHTMLDocument.cpp
--- content/html/document/src/nsHTMLDocument.cpp	27 Jul 2004 22:54:55 -0000	3.547.2.2.2.2
+++ content/html/document/src/nsHTMLDocument.cpp	24 Sep 2004 05:21:35 -0000
@@ -2106,18 +2106,26 @@ nsHTMLDocument::OpenCommon(nsIURI* aSour
       root->UnsetAttr(nsid, name, PR_FALSE);
     }
 
     // Remove the root from the childlist
     mChildren.RemoveObject(root);
 
     mRootContent = nsnull;
   }
 
+  // Grab a reference to the callers principal as it may not be
+  // reachable past the call to Reset().
+  nsCOMPtr<nsIPrincipal> callingPrincipal;
+
+  if (callingDoc) {
+    callingPrincipal = callingDoc->GetPrincipal();
+  }
+
   // Call Reset(), this will now do the full reset, except removing
   // the root from the document, doing that confuses the scrollbar
   // code in mozilla since the document in the root element and all
   // the anonymous content (i.e. scrollbar elements) is set to
   // null.
 
   Reset(channel, group);
 
   if (root) {
@@ -2128,18 +2136,23 @@ nsHTMLDocument::OpenCommon(nsIURI* aSour
     // the document about this insertion since the sink will do that
     // for us, the sink will call InitialReflow() and that'll create
     // frames for the root element and the scrollbars work as expected
     // (since the document in the root element was never set to null)
 
     mChildren.AppendObject(root);
     mRootContent = root;
   }
 
+  if (!mPrincipal) {
+    // Restore the principal to that of the caller.
+    mPrincipal = callingPrincipal;
+  }
+
   // Store the security info of the caller now that we're done
   // resetting the document.
   mSecurityInfo = securityInfo;
 
   mParser = do_CreateInstance(kCParserCID, &rv);
 
   mIsWriting = 1;
 
   if (NS_SUCCEEDED(rv)) {
