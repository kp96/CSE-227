diff --git a/security/manager/ssl/src/nsNSSCertificateDB.cpp b/security/manager/ssl/src/nsNSSCertificateDB.cpp
--- a/security/manager/ssl/src/nsNSSCertificateDB.cpp
+++ b/security/manager/ssl/src/nsNSSCertificateDB.cpp
@@ -1492,37 +1492,74 @@ loser:
   if (cert) CERT_DestroyCertificate(cert);
   return rv;
 }
 
 NS_IMETHODIMP
 nsNSSCertificateDB::FindCertByEmailAddress(nsISupports *aToken, const char *aEmailAddress, nsIX509Cert **_retval)
 {
   nsNSSShutDownPreventionLock locker;
-  CERTCertificate *any_cert = CERT_FindCertByNicknameOrEmailAddr(CERT_GetDefaultCertDB(), (char*)aEmailAddress);
-  if (!any_cert)
-    return NS_ERROR_FAILURE;
+  
+  nsCOMPtr<nsINSSComponent> inss;
+  nsRefPtr<nsCERTValInParamWrapper> survivingParams;
+  
+  if (nsNSSComponent::globalConstFlagUsePKIXVerification) {
+    inss = do_GetService(kNSSComponentCID, &nsrv);
+    if (!inss)
+      return nsrv;
+    nsrv = inss->GetDefaultCERTValInParam(survivingParams);
+    if (NS_FAILED(nsrv))
+      return nsrv;
+  }
 
-  CERTCertificateCleaner certCleaner(any_cert);
-    
-  // any_cert now contains a cert with the right subject, but it might not have the correct usage
-  CERTCertList *certlist = CERT_CreateSubjectCertList(
-    nsnull, CERT_GetDefaultCertDB(), &any_cert->derSubject, PR_Now(), PR_TRUE);
+  CERTCertList *certlist = PK11_FindCertsFromEmailAddress(aEmailAddress, nsnull);
   if (!certlist)
     return NS_ERROR_FAILURE;  
 
+  // certlist now contains certificates with the right email address,
+  // but they might not have the correct usage or might even be invalid
+
   CERTCertListCleaner listCleaner(certlist);
 
-  if (SECSuccess != CERT_FilterCertListByUsage(certlist, certUsageEmailRecipient, PR_FALSE))
+  if (CERT_LIST_END(CERT_LIST_HEAD(certlist), certlist))
+    return NS_ERROR_FAILURE; // no certs found
+
+  CERTCertListNode *node;
+  // search for a valid certificate
+  for (node = CERT_LIST_HEAD(certlist);
+       !CERT_LIST_END(node, certlist);
+       node = CERT_LIST_NEXT(node)) {
+
+    if (!nsNSSComponent::globalConstFlagUsePKIXVerification) {
+      if (CERT_VerifyCert(certdb, node->cert,
+          PR_TRUE, certUsageEmailRecipient, PR_Now(), nsnull, nsnull) == SECSuccess) {
+        // found a valid certificate
+        break;
+      }
+    }
+    else {
+      CERTValOutParam cvout[1];
+      cvout[0].type = cert_po_end;
+      if (CERT_PKIXVerifyCert(node->cert, certificateUsageEmailRecipient,
+                              survivingParams->GetRawPointerForNSS(),
+                              cvout, nsnull)
+          == SECSuccess) {
+        // found a valid certificate
+        break;
+      }
+    }
+  }
+
+  if (CERT_LIST_END(node, certlist)) {
+    // no valid cert found
     return NS_ERROR_FAILURE;
-  
-  if (CERT_LIST_END(CERT_LIST_HEAD(certlist), certlist))
-    return NS_ERROR_FAILURE;
-  
-  nsNSSCertificate *nssCert = nsNSSCertificate::Create(CERT_LIST_HEAD(certlist)->cert);
+  }
+
+  // node now contains the first valid certificate with correct usage 
+  nsNSSCertificate *nssCert = nsNSSCertificate::Create(node->cert);
   if (!nssCert)
     return NS_ERROR_OUT_OF_MEMORY;
 
   NS_ADDREF(nssCert);
   *_retval = static_cast<nsIX509Cert*>(nssCert);
   return NS_OK;
 }
 
