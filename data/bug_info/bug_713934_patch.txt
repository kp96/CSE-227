# HG changeset patch
# Parent 5f606d407c14b09e52911b6725360d756f75cf27
# User Brian Smith <bsmith@mozilla.com>
Bug 713934, Part 1, version 1: Update SetCertVerificationResult to use SSL_AuthCertificateComplete, r?honzab

diff --git a/security/nss/cmd/tstclnt/tstclnt.c b/security/nss/cmd/tstclnt/tstclnt.c
--- a/security/nss/cmd/tstclnt/tstclnt.c
+++ b/security/nss/cmd/tstclnt/tstclnt.c
@@ -525,33 +525,43 @@ separateReqHeader(const PRFileDesc* outF
     }
 
 static SECStatus
 restartHandshakeAfterServerCertIfNeeded(PRFileDesc * fd,
                                         ServerCertAuth * serverCertAuth,
                                         PRBool override)
 {
     SECStatus rv;
+    PRErrorCode status;
     
     if (!serverCertAuth->isPaused)
 	return SECSuccess;
     
     FPRINTF(stderr, "%s: handshake was paused by auth certificate hook\n",
             progName);
 
     serverCertAuth->isPaused = PR_FALSE;
     rv = SSL_AuthCertificate(serverCertAuth->dbHandle, fd, PR_TRUE, PR_FALSE);
-    if (rv != SECSuccess && override) {
-        rv = ownBadCertHandler(NULL, fd);
+    if (rv != SECSuccess) {
+        status = PR_GetError();
+        if (status == 0) {
+            PR_NOT_REACHED("SSL_AuthCertificate return SECFailure without "
+                           "setting error code.");
+            status = PR_INVALID_STATE_ERROR;
+        } else if (override) {
+            rv = ownBadCertHandler(NULL, fd);
+        }
     }
-    if (rv != SECSuccess) {
-	return rv;
+    if (rv == SECSuccess) {
+        status = 0;
     }
-    
-    rv = SSL_RestartHandshakeAfterAuthCertificate(fd);
+
+    if (SSL_AuthCertificateComplete(fd, status) != SECSuccess) {
+        rv = SECFailure;
+    }
 
     return rv;
 }
     
 int main(int argc, char **argv)
 {
     PRFileDesc *       s;
     PRFileDesc *       std_out;
diff --git a/security/nss/lib/ssl/ssl.def b/security/nss/lib/ssl/ssl.def
--- a/security/nss/lib/ssl/ssl.def
+++ b/security/nss/lib/ssl/ssl.def
@@ -164,12 +164,12 @@ NSSSSL_GetVersion;
 ;+    local:
 ;+       *;
 ;+};
 ;+NSS_3.13.2 {    # NSS 3.13.2 release
 ;+    global:
 SSL_SetNextProtoCallback;
 SSL_SetNextProtoNego;
 SSL_GetNextProto;
-SSL_RestartHandshakeAfterAuthCertificate;
+SSL_AuthCertificateComplete;
 ;+    local:
 ;+       *;
 ;+};
diff --git a/security/nss/lib/ssl/ssl.h b/security/nss/lib/ssl/ssl.h
--- a/security/nss/lib/ssl/ssl.h
+++ b/security/nss/lib/ssl/ssl.h
@@ -338,25 +338,25 @@ SSL_IMPORT CERTCertificate *SSL_PeerCert
 /*
 ** Authenticate certificate hook. Called when a certificate comes in
 ** (because of SSL_REQUIRE_CERTIFICATE in SSL_Enable) to authenticate the
 ** certificate.
 **
 ** The authenticate certificate hook must return SECSuccess to indicate the
 ** certificate is valid, SECFailure to indicate the certificate is invalid,
 ** or SECWouldBlock if the application will authenticate the certificate
-** asynchronously.
+** asynchronously. SECWouldBlock is only supported for non-blocking sockets.
 **
 ** If the authenticate certificate hook returns SECFailure, then the bad cert
 ** hook will be called. The bad cert handler is NEVER called if the
 ** authenticate certificate hook returns SECWouldBlock.
-** 
-** See the documentation for SSL_RestartHandshakeAfterAuthCertificate for more
-** information about the asynchronous behavior that occurs when the
-** authenticate certificate hook returns SECWouldBlock.
+**
+** See the documentation for SSL_AuthCertificateComplete for more information
+** about the asynchronous behavior that occurs when the authenticate
+** certificate hook returns SECWouldBlock
 */
 typedef SECStatus (PR_CALLBACK *SSLAuthCertificate)(void *arg, PRFileDesc *fd, 
                                                     PRBool checkSig,
                                                     PRBool isServer);
 
 SSL_IMPORT SECStatus SSL_AuthCertificateHook(PRFileDesc *fd, 
 					     SSLAuthCertificate f,
 				             void *arg);
@@ -454,21 +454,22 @@ SSL_IMPORT SECStatus SSL_SetPKCS11PinArg
 /*
 ** This is a callback for dealing with server certs that are not authenticated
 ** by the client.  The client app can decide that it actually likes the
 ** cert by some external means and restart the connection.
 **
 ** The bad cert hook must return SECSuccess to override the result of the
 ** authenticate certificate hook, SECFailure if the certificate should still be
 ** considered invalid, or SECWouldBlock if the application will authenticate
-** the certificate asynchronously.
+** the certificate asynchronously. SECWouldBlock is only supported for
+** non-blocking sockets.
 **
-** See the documentation for SSL_RestartHandshakeAfterAuthCertificate for more
-** information about the asynchronous behavior that occurs when the bad cert
-** hook returns SECWouldBlock.
+** See the documentation for SSL_AuthCertificateComplete for more information
+** about the asynchronous behavior that occurs when the bad cert hook returns
+** SECWouldBlock.
 */
 typedef SECStatus (PR_CALLBACK *SSLBadCertHandler)(void *arg, PRFileDesc *fd);
 SSL_IMPORT SECStatus SSL_BadCertHook(PRFileDesc *fd, SSLBadCertHandler f, 
 				     void *arg);
 
 /*
 ** Configure SSL socket for running a secure server. Needs the
 ** certificate for the server and the servers private key. The arguments
@@ -761,54 +762,64 @@ extern PRBool NSSSSL_VersionCheck(const 
  * Returns a const string of the SSL library version.
  */
 extern const char *NSSSSL_GetVersion(void);
 
 /* Restart an SSL connection that was paused to do asynchronous certificate
  * chain validation (when the auth certificate hook or bad cert handler
  * returned SECWouldBlock).
  *
- * Currently, this function works only for the client role of a connection; it
- * does not work for the server role.
+ * This function only works for non-blocking sockets; Do not use it for
+ * blocking sockets. Currently, this function works only for the client role of
+ * a connection; it does not work for the server role.
  *
- * The application MUST call SSL_RestartHandshakeAfterAuthCertificate after it
- * has successfully validated the peer's certificate to continue the SSL
- * handshake.
+ * The application must call SSL_AuthCertificateComplete with 0 as the value of
+ * status parameter after it has successfully validated the peer's certificate,
+ * in order to continue the SSL handshake.
  *
- * The application MUST NOT call SSL_RestartHandshakeAfterAuthCertificate when
- * certificate validation fails; instead, it should just close the connection.
+ * The application may call SSL_AuthCertificateComplete with a non-zero value
+ * for status (e.g. SEC_ERROR_REVOKED_CERTIFICATE) when certificate validation
+ * fails, before it closes the connection. If the application does so, an
+ * alert corresponding to the error (e.g. certificate_revoked) will be sent to
+ * the peer. See the source code of the internal function
+ * ssl3_SendAlertForCertError for the current mapping of error to alert. This
+ * mapping may change in future versions of libssl.
  *
  * This function will not complete the entire handshake. The application must
  * call SSL_ForceHandshake, PR_Recv, PR_Send, etc. after calling this function
  * to force the handshake to complete.
  *
- * libssl will wait for the peer's certificate to be authenticated before
- * calling the handshake callback, sending a client certificate,
- * sending any application data, or returning any application data to the
- * application (on the first handshake on a connection only).
+ * On the first handshake of a connection, libssl will wait for the peer's
+ * certificate to be authenticated before calling the handshake callback,
+ * sending a client certificate, sending any application data, or returning
+ * any application data to the application. On subsequent (renegotiation)
+ * handshakes, libssl will block the handshake unconditionally while the
+ * certificate is being validated.
  *
- * However, libssl may send and receive handshake messages while waiting for
- * the application to call SSL_RestartHandshakeAfterAuthCertificate, and it may
- * call other callbacks (e.g, the client auth data hook) before
- * SSL_RestartHandshakeAfterAuthCertificate has been called. 
+ * libssl may send and receive handshake messages while waiting for the
+ * application to call SSL_AuthCertificateComplete, and it may call other
+ * callbacks (e.g, the client auth data hook) before
+ * SSL_AuthCertificateComplete has been called.
  *
  * An application that uses this asynchronous mechanism will usually have lower
  * handshake latency if it has to do public key operations on the certificate
- * chain during the authentication, especially if it does so in parallel on
- * another thread. However, if the application can authenticate the peer's
- * certificate quickly then it may be more efficient to use the synchronous
- * mechanism (i.e. returning SECFailure/SECSuccess instead of SECWouldBlock
- * from the authenticate certificate hook).
+ * chain and/or CRL/OCSP/cert fetching during the authentication, especially if
+ * it does so in parallel on another thread. However, if the application can
+ * authenticate the peer's certificate quickly then it may be more efficient
+ * to use the synchronous mechanism (i.e. returning SECFailure/SECSuccess
+ * instead of SECWouldBlock from the authenticate certificate hook).
  *
  * Be careful about converting an application from synchronous cert validation
  * to asynchronous certificate validation. A naive conversion is likely to
  * result in deadlocks; e.g. the application will wait in PR_Poll for network
  * I/O on the connection while all network I/O on the connection is blocked
  * waiting for this function to be called.
  *
  * Returns SECFailure on failure, SECSuccess on success. Never returns
- * SECWouldBlock.
+ * SECWouldBlock. Note that SSL_AuthCertificateComplete will (usually) return
+ * SECSuccess; do not interpret the return value of SSL_AuthCertificateComplete
+ * as an indicator of whether it is OK to continue using the connection.
  */
-SSL_IMPORT SECStatus SSL_RestartHandshakeAfterAuthCertificate(PRFileDesc *fd);
-
+SSL_IMPORT SECStatus SSL_AuthCertificateComplete(PRFileDesc *fd,
+						 PRErrorCode status);
 SEC_END_PROTOS
 
 #endif /* __ssl_h_ */
diff --git a/security/nss/lib/ssl/ssl3con.c b/security/nss/lib/ssl/ssl3con.c
--- a/security/nss/lib/ssl/ssl3con.c
+++ b/security/nss/lib/ssl/ssl3con.c
@@ -2602,16 +2602,50 @@ static SECStatus
 ssl3_HandshakeFailure(sslSocket *ss)
 {
     (void)SSL3_SendAlert(ss, alert_fatal, handshake_failure);
     PORT_SetError( ss->sec.isServer ? SSL_ERROR_BAD_CLIENT
                                     : SSL_ERROR_BAD_SERVER );
     return SECFailure;
 }
 
+static void
+ssl3_SendAlertForCertError(sslSocket * ss, PRErrorCode errCode)
+{
+    SSL3AlertDescription desc	= bad_certificate;
+    PRBool isTLS = ss->version >= SSL_LIBRARY_VERSION_3_1_TLS;
+
+    switch (errCode) {
+    case SEC_ERROR_LIBRARY_FAILURE:     desc = unsupported_certificate; break;
+    case SEC_ERROR_EXPIRED_CERTIFICATE: desc = certificate_expired;     break;
+    case SEC_ERROR_REVOKED_CERTIFICATE: desc = certificate_revoked;     break;
+    case SEC_ERROR_INADEQUATE_KEY_USAGE:
+    case SEC_ERROR_INADEQUATE_CERT_TYPE:
+		                        desc = certificate_unknown;     break;
+    case SEC_ERROR_UNTRUSTED_CERT:
+		    desc = isTLS ? access_denied : certificate_unknown; break;
+    case SEC_ERROR_UNKNOWN_ISSUER:      
+    case SEC_ERROR_UNTRUSTED_ISSUER:    
+		    desc = isTLS ? unknown_ca : certificate_unknown; break;
+    case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
+		    desc = isTLS ? unknown_ca : certificate_expired; break;
+
+    case SEC_ERROR_CERT_NOT_IN_NAME_SPACE:
+    case SEC_ERROR_PATH_LEN_CONSTRAINT_INVALID:
+    case SEC_ERROR_CA_CERT_INVALID:
+    case SEC_ERROR_BAD_SIGNATURE:
+    default:                            desc = bad_certificate;     break;
+    }
+    SSL_DBG(("%d: SSL3[%d]: peer certificate is no good: error=%d",
+	     SSL_GETPID(), ss->fd, errCode));
+
+    (void) SSL3_SendAlert(ss, alert_fatal, desc);
+}
+
+
 /*
  * Send handshake_Failure alert.  Set generic error number.
  */
 static SECStatus
 ssl3_DecodeError(sslSocket *ss)
 {
     (void)SSL3_SendAlert(ss, alert_fatal, 
 		  ss->version > SSL_LIBRARY_VERSION_3_0 ? decode_error 
@@ -5651,19 +5685,19 @@ done:
 
 PRBool
 ssl3_CanFalseStart(sslSocket *ss) {
     PRBool rv;
 
     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
 
     /* XXX: does not take into account whether we are waiting for
-     * SSL_RestartHandshakeAfterAuthCertificate or
-     * SSL_RestartHandshakeAfterCertReq. If/when that is done, this function
-     * could return different results each time it would be called.
+     * SSL_AuthCertificateComplete or SSL_RestartHandshakeAfterCertReq. If/when
+     * that is done, this function could return different results each time it
+     * would be called.
      */
 
     ssl_GetSpecReadLock(ss);
     rv = ss->opt.enableFalseStart &&
 	 !ss->sec.isServer &&
 	 !ss->ssl3.hs.isResuming &&
 	 ss->ssl3.cwSpec &&
 	 ss->ssl3.cwSpec->cipher_def->secret_key_size >= 10 &&
@@ -5700,18 +5734,17 @@ ssl3_HandleServerHelloDone(sslSocket *ss
 	return SECFailure;
     }
 
     rv = ssl3_SendClientSecondRound(ss);
 
     return rv;
 }
 
-/* Called from ssl3_HandleServerHelloDone and
- * ssl3_RestartHandshakeAfterServerCert.
+/* Called from ssl3_HandleServerHelloDone and ssl3_AuthCertificateComplete.
  *
  * Caller must hold Handshake and RecvBuf locks.
  */
 static SECStatus
 ssl3_SendClientSecondRound(sslSocket *ss)
 {
     SECStatus rv;
     PRBool sendClientCert;
@@ -5736,31 +5769,31 @@ ssl3_SendClientSecondRound(sslSocket *ss
      * application data until we have authenticated the server's certificate;
      * i.e. we have fully authenticated the handshake before using the cipher
      * specs agreed upon for that handshake. During a renegotiation, we may
      * continue sending and receiving application data during the handshake
      * interleaved with the handshake records. If we were to send the client's
      * second round for a renegotiation before the server's certificate was
      * authenticated, then the application data sent/received after this point
      * would be using cipher spec that hadn't been authenticated. By waiting
-     * until the server's certificate has been authenticated during 
+     * until the server's certificate has been authenticated during
      * renegotiations, we ensure that renegotiations have the same property
      * as initial handshakes; i.e. we have fully authenticated the handshake
      * before using the cipher specs agreed upon for that handshake for
      * application data.
      */
     if (ss->ssl3.hs.restartTarget) {
-        PR_NOT_REACHED("unexpected ss->ssl3.hs.restartTarget");
-        PORT_SetError(SEC_ERROR_LIBRARY_FAILURE);
-        return SECFailure;
+	PR_NOT_REACHED("unexpected ss->ssl3.hs.restartTarget");
+	PORT_SetError(SEC_ERROR_LIBRARY_FAILURE);
+	return SECFailure;
     }
     if (ss->ssl3.hs.authCertificatePending &&
-        (sendClientCert || ss->ssl3.sendEmptyCert || ss->firstHsDone)) {
-        ss->ssl3.hs.restartTarget = ssl3_SendClientSecondRound;
-        return SECWouldBlock;
+	(sendClientCert || ss->ssl3.sendEmptyCert || ss->firstHsDone)) {
+	ss->ssl3.hs.restartTarget = ssl3_SendClientSecondRound;
+	return SECWouldBlock;
     }
 
     ssl_GetXmitBufLock(ss);		/*******************************/
 
     if (ss->ssl3.sendEmptyCert) {
 	ss->ssl3.sendEmptyCert = PR_FALSE;
 	rv = ssl3_SendEmptyCertificate(ss);
 	/* Don't send verify */
@@ -7823,17 +7856,17 @@ ssl3_HandleCertificate(sslSocket *ss, SS
     ssl3CertNode *   c;
     ssl3CertNode *   lastCert 	= NULL;
     PRInt32          remaining  = 0;
     PRInt32          size;
     SECStatus        rv;
     PRBool           isServer	= (PRBool)(!!ss->sec.isServer);
     PRBool           trusted 	= PR_FALSE;
     PRBool           isTLS;
-    SSL3AlertDescription desc	= bad_certificate;
+    SSL3AlertDescription desc;
     int              errCode    = SSL_ERROR_RX_MALFORMED_CERTIFICATE;
     SECItem          certItem;
 
     SSL_TRC(3, ("%d: SSL3[%d]: handle certificate handshake",
 		SSL_GETPID(), ss->fd));
     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
 
@@ -7977,22 +8010,30 @@ ssl3_HandleCertificate(sslSocket *ss, SS
 
 	if (rv == SECWouldBlock) {
 	    if (ss->sec.isServer) {
 		errCode = SSL_ERROR_FEATURE_NOT_SUPPORTED_FOR_SERVERS;
 		rv = SECFailure;
 		goto loser;
 	    }
 
-            ss->ssl3.hs.authCertificatePending = PR_TRUE;
-            rv = SECSuccess;
-	}
-        
-        if (rv != SECSuccess) {
-	    goto bad_cert;
+	    ss->ssl3.hs.authCertificatePending = PR_TRUE;
+	    rv = SECSuccess;
+
+	    /* XXX: Async cert validation and False Start don't work together
+	     * safely yet; if we leave False Start enabled, we may end up false
+	     * starting (sending application data) before we
+	     * SSL_AuthCertificateComplete has been called.
+	     */
+	    ss->opt.enableFalseStart = PR_FALSE;
+	}
+
+	if (rv != SECSuccess) {
+	    ssl3_SendAlertForCertError(ss, errCode);
+	    goto loser;
 	}
     }
 
     ss->sec.ci.sid->peerCert = CERT_DupCertificate(ss->sec.peerCert);
 
     if (!ss->sec.isServer) {
         CERTCertificate *cert = ss->sec.peerCert;
 
@@ -8053,58 +8094,33 @@ server_no_cert:
     }
 
     PORT_Assert(rv == SECSuccess);
     if (rv != SECSuccess) {
 	errCode = SEC_ERROR_LIBRARY_FAILURE;
 	rv = SECFailure;
 	goto loser;
     }
+
     return rv;
 
 ambiguous_err:
     errCode = PORT_GetError();
     switch (errCode) {
     case PR_OUT_OF_MEMORY_ERROR:
     case SEC_ERROR_BAD_DATABASE:
     case SEC_ERROR_NO_MEMORY:
 	if (isTLS) {
 	    desc = internal_error;
 	    goto alert_loser;
 	}
 	goto loser;
     }
-    /* fall through to bad_cert. */
-
-bad_cert:	/* caller has set errCode. */
-    switch (errCode) {
-    case SEC_ERROR_LIBRARY_FAILURE:     desc = unsupported_certificate; break;
-    case SEC_ERROR_EXPIRED_CERTIFICATE: desc = certificate_expired;     break;
-    case SEC_ERROR_REVOKED_CERTIFICATE: desc = certificate_revoked;     break;
-    case SEC_ERROR_INADEQUATE_KEY_USAGE:
-    case SEC_ERROR_INADEQUATE_CERT_TYPE:
-		                        desc = certificate_unknown;     break;
-    case SEC_ERROR_UNTRUSTED_CERT:
-		    desc = isTLS ? access_denied : certificate_unknown; break;
-    case SEC_ERROR_UNKNOWN_ISSUER:      
-    case SEC_ERROR_UNTRUSTED_ISSUER:    
-		    desc = isTLS ? unknown_ca : certificate_unknown; break;
-    case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
-		    desc = isTLS ? unknown_ca : certificate_expired; break;
-
-    case SEC_ERROR_CERT_NOT_IN_NAME_SPACE:
-    case SEC_ERROR_PATH_LEN_CONSTRAINT_INVALID:
-    case SEC_ERROR_CA_CERT_INVALID:
-    case SEC_ERROR_BAD_SIGNATURE:
-    default:                            desc = bad_certificate;     break;
-    }
-    SSL_DBG(("%d: SSL3[%d]: peer certificate is no good: error=%d",
-	     SSL_GETPID(), ss->fd, errCode));
-
-    goto alert_loser;
+    ssl3_SendAlertForCertError(ss, errCode);
+    goto loser;
 
 decode_loser:
     desc = isTLS ? decode_error : bad_certificate;
 
 alert_loser:
     (void)SSL3_SendAlert(ss, alert_fatal, desc);
 
 loser:
@@ -8115,54 +8131,68 @@ loser:
 	ss->sec.peerCert = NULL;
     }
     (void)ssl_MapLowLevelError(errCode);
     return SECFailure;
 }
 
 static SECStatus ssl3_FinishHandshake(sslSocket *ss);
 
+static SECStatus
+ssl3_AlwaysFail(sslSocket * ss)
+{
+    PORT_SetError(PR_INVALID_STATE_ERROR);
+    return SECFailure;
+}
+
 /* Caller must hold 1stHandshakeLock.
 */
 SECStatus
-ssl3_RestartHandshakeAfterAuthCertificate(sslSocket *ss)
+ssl3_AuthCertificateComplete(sslSocket *ss, PRErrorCode status)
 {
     SECStatus rv;
 
     PORT_Assert(ss->opt.noLocks || ssl_Have1stHandshakeLock(ss));
 
     if (ss->sec.isServer) {
 	PORT_SetError(SSL_ERROR_FEATURE_NOT_SUPPORTED_FOR_SERVERS);
 	return SECFailure;
     }
 
     ssl_GetRecvBufLock(ss);
     ssl_GetSSL3HandshakeLock(ss);
 
     if (!ss->ssl3.hs.authCertificatePending) {
-        PORT_SetError(PR_INVALID_STATE_ERROR);
-        rv = SECFailure;
+	PORT_SetError(PR_INVALID_STATE_ERROR);
+	rv = SECFailure;
+	goto done;
+    }
+
+    ss->ssl3.hs.authCertificatePending = PR_FALSE;
+
+    if (status != 0) {
+	ss->ssl3.hs.restartTarget = ssl3_AlwaysFail;
+	ssl3_SendAlertForCertError(ss, status);
+	rv = SECSuccess;
+    } else if (ss->ssl3.hs.restartTarget != NULL) {
+	sslRestartTarget target = ss->ssl3.hs.restartTarget;
+	ss->ssl3.hs.restartTarget = NULL;
+	rv = target(ss);
+	/* Even if we blocked here, we have accomplished enough to claim
+	 * success. Any remaining work will be taken care of by subsequent
+	 * calls to SSL_ForceHandshake/PR_Send/PR_Read/etc. 
+	 */
+	if (rv == SECWouldBlock) {
+	    rv = SECSuccess;
+	}
     } else {
-        ss->ssl3.hs.authCertificatePending = PR_FALSE;
-        if (ss->ssl3.hs.restartTarget != NULL) {
-            sslRestartTarget target = ss->ssl3.hs.restartTarget;
-            ss->ssl3.hs.restartTarget = NULL;
-            rv = target(ss);
-	    /* Even if we blocked here, we have accomplished enough to claim
-	      * success. Any remaining work will be taken care of by subsequent
-              * calls to SSL_ForceHandshake/PR_Send/PR_Read/etc. 
-	      */
-            if (rv == SECWouldBlock) {
-                rv = SECSuccess;
-            }
-        } else {
-            rv = SECSuccess;
-        }
-    }
-
+	rv = SECSuccess;
+    }
+
+done:
     ssl_ReleaseSSL3HandshakeLock(ss);
     ssl_ReleaseRecvBufLock(ss);
 
     return rv;
 }
 
 static SECStatus
 ssl3_ComputeTLSFinished(ssl3CipherSpec *spec,
@@ -8561,35 +8591,35 @@ xmit_loser:
 
 	/* If the wrap failed, we don't cache the sid.
 	 * The connection continues normally however.
 	 */
 	ss->ssl3.hs.cacheSID = rv == SECSuccess;
     }
 
     if (ss->ssl3.hs.authCertificatePending) {
-      if (ss->ssl3.hs.restartTarget) {
-          PR_NOT_REACHED("ssl3_HandleFinished: unexpected restartTarget");
-          PORT_SetError(SEC_ERROR_LIBRARY_FAILURE);
-          return SECFailure;
-      }
-
-      ss->ssl3.hs.restartTarget = ssl3_FinishHandshake;
-      return SECWouldBlock;
-    }
-    
+	if (ss->ssl3.hs.restartTarget) {
+	    PR_NOT_REACHED("ssl3_HandleFinished: unexpected restartTarget");
+	    PORT_SetError(SEC_ERROR_LIBRARY_FAILURE);
+	    return SECFailure;
+	}
+
+	ss->ssl3.hs.restartTarget = ssl3_FinishHandshake;
+	return SECWouldBlock;
+    }
+
     rv = ssl3_FinishHandshake(ss);
     return rv;
 }
 
 SECStatus
 ssl3_FinishHandshake(sslSocket * ss)
 {
     SECStatus rv;
-    
+
     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
     PORT_Assert( ss->ssl3.hs.restartTarget == NULL );
 
     /* The first handshake is now completed. */
     ss->handshake           = NULL;
     ss->firstHsDone         = PR_TRUE;
 
@@ -8901,17 +8931,16 @@ ssl3_HandleHandshake(sslSocket *ss, sslB
  * checked, and is already sitting in databuf.  It is processed as an SSL
  * Handshake message.
  *
  * DOES NOT process the decrypted/decompressed application data.
  * On return, databuf contains the decrypted/decompressed record.
  *
  * Called from ssl3_GatherCompleteHandshake
  *             ssl3_RestartHandshakeAfterCertReq
- *             ssl3_RestartHandshakeAfterServerCert
  *
  * Caller must hold the RecvBufLock.
  *
  * This function aquires and releases the SSL3Handshake Lock, holding the
  * lock around any calls to functions that handle records other than
  * Application Data records.
  */
 SECStatus
diff --git a/security/nss/lib/ssl/ssl3gthr.c b/security/nss/lib/ssl/ssl3gthr.c
--- a/security/nss/lib/ssl/ssl3gthr.c
+++ b/security/nss/lib/ssl/ssl3gthr.c
@@ -187,63 +187,63 @@ int
 ssl3_GatherCompleteHandshake(sslSocket *ss, int flags)
 {
     SSL3Ciphertext cText;
     int            rv;
     PRBool         canFalseStart = PR_FALSE;
 
     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
     do {
-        /* Without this, we may end up wrongly reporting
-         * SSL_ERROR_RX_UNEXPECTED_* errors if we receive any records from the
-         * peer while we are waiting to be restarted. 
-         */
-        ssl_GetSSL3HandshakeLock(ss);
-        rv = ss->ssl3.hs.restartTarget == NULL ? SECSuccess : SECFailure;
-        ssl_ReleaseSSL3HandshakeLock(ss);
-        if (rv != SECSuccess) {
-            PORT_SetError(PR_WOULD_BLOCK_ERROR);
-            return (int) SECFailure;
-        }
+	/* Without this, we may end up wrongly reporting
+	 * SSL_ERROR_RX_UNEXPECTED_* errors if we receive any records from the
+	 * peer while we are waiting to be restarted.
+	 */
+	ssl_GetSSL3HandshakeLock(ss);
+	rv = ss->ssl3.hs.restartTarget == NULL ? SECSuccess : SECFailure;
+	ssl_ReleaseSSL3HandshakeLock(ss);
+	if (rv != SECSuccess) {
+	    PORT_SetError(PR_WOULD_BLOCK_ERROR);
+	    return (int) SECFailure;
+	}
 
-        /* Treat an empty msgState like a NULL msgState. (Most of the time
-         * when ssl3_HandleHandshake returns SECWouldBlock, it leaves
-         * behind a non-NULL but zero-length msgState).
-         * Test: async_cert_restart_server_sends_hello_request_first_in_separate_record
-         */
-        if (ss->ssl3.hs.msgState.buf != NULL) {
-            if (ss->ssl3.hs.msgState.len == 0) {
-                ss->ssl3.hs.msgState.buf = NULL;
-            }
-        }
+	/* Treat an empty msgState like a NULL msgState. (Most of the time
+	 * when ssl3_HandleHandshake returns SECWouldBlock, it leaves
+	 * behind a non-NULL but zero-length msgState).
+	 * Test: async_cert_restart_server_sends_hello_request_first_in_separate_record
+	 */
+	if (ss->ssl3.hs.msgState.buf != NULL) {
+	    if (ss->ssl3.hs.msgState.len == 0) {
+		ss->ssl3.hs.msgState.buf = NULL;
+	    }
+	}
 
-        if (ss->ssl3.hs.msgState.buf != NULL) {
-            /* ssl3_HandleHandshake previously returned SECWouldBlock and the
-             * as-yet-unprocessed plaintext of that previous handshake record.
-             * We need to process it now before we overwrite it with the next
-             * handshake record.
-             */
+	if (ss->ssl3.hs.msgState.buf != NULL) {
+	    /* ssl3_HandleHandshake previously returned SECWouldBlock and the
+	     * as-yet-unprocessed plaintext of that previous handshake record.
+	     * We need to process it now before we overwrite it with the next
+	     * handshake record.
+	     */
 	    rv = ssl3_HandleRecord(ss, NULL, &ss->gs.buf);
-        } else {
+	} else {
 	    /* bring in the next sslv3 record. */
 	    rv = ssl3_GatherData(ss, &ss->gs, flags);
 	    if (rv <= 0) {
-	        return rv;
+		return rv;
 	    }
 
-	    /* decipher it, and handle it if it's a handshake. 
-	     * If it's application data, ss->gs.buf will not be empty upon return. 
+	    /* decipher it, and handle it if it's a handshake.
+	     * If it's application data, ss->gs.buf will not be empty upon return.
 	     * If it's a change cipher spec, alert, or handshake message,
 	     * ss->gs.buf.len will be 0 when ssl3_HandleRecord returns SECSuccess.
 	     */
 	    cText.type    = (SSL3ContentType)ss->gs.hdr[0];
 	    cText.version = (ss->gs.hdr[1] << 8) | ss->gs.hdr[2];
 	    cText.buf     = &ss->gs.inbuf;
 	    rv = ssl3_HandleRecord(ss, &cText, &ss->gs.buf);
-        }
+	}
 	if (rv < 0) {
 	    return ss->recvdCloseNotify ? 0 : rv;
 	}
 
 	/* If we kicked off a false start in ssl3_HandleServerHelloDone, break
 	 * out of this loop early without finishing the handshake.
 	 */
 	if (ss->opt.enableFalseStart) {
diff --git a/security/nss/lib/ssl/sslimpl.h b/security/nss/lib/ssl/sslimpl.h
--- a/security/nss/lib/ssl/sslimpl.h
+++ b/security/nss/lib/ssl/sslimpl.h
@@ -789,20 +789,21 @@ const ssl3CipherSuiteDef *suite_def;
 	SSL3Opaque        data[72];
     }                     finishedMsgs;
 #ifdef NSS_ENABLE_ECC
     PRUint32              negotiatedECCurves; /* bit mask */
 #endif /* NSS_ENABLE_ECC */
 
     PRBool                authCertificatePending;
     /* Which function should SSL_RestartHandshake* call if we're blocked?
-     * One of NULL, ssl3_SendClientSecondRound, or ssl3_FinishHandshake. */
+     * One of NULL, ssl3_SendClientSecondRound, ssl3_FinishHandshake,
+     * or ssl3_AlwaysFail */
     sslRestartTarget      restartTarget;
     /* Shared state between ssl3_HandleFinished and ssl3_FinishHandshake */
-    PRBool                cacheSID; 
+    PRBool                cacheSID;
 } SSL3HandshakeState;
 
 
 
 /*
 ** This is the "ssl3" struct, as in "ss->ssl3".
 ** note:
 ** usually,   crSpec == cwSpec and prSpec == pwSpec.  
@@ -1353,17 +1354,17 @@ extern int SSL_RestartHandshakeAfterCert
 					    CERTCertificate *cert,
 					    SECKEYPrivateKey *key,
 					    CERTCertificateList *certChain);
 extern sslSocket *ssl_FindSocket(PRFileDesc *fd);
 extern void ssl_FreeSocket(struct sslSocketStr *ssl);
 extern SECStatus SSL3_SendAlert(sslSocket *ss, SSL3AlertLevel level,
 				SSL3AlertDescription desc);
 
-extern SECStatus ssl3_RestartHandshakeAfterAuthCertificate(sslSocket *ss);
+extern SECStatus ssl3_AuthCertificateComplete(sslSocket *ss, PRErrorCode status);
 
 /*
  * for dealing with SSL 3.0 clients sending SSL 2.0 format hellos
  */
 extern SECStatus ssl3_HandleV2ClientHello(
     sslSocket *ss, unsigned char *buffer, int length);
 extern SECStatus ssl3_StartHandshakeHash(
     sslSocket *ss, unsigned char *buf, int length);
diff --git a/security/nss/lib/ssl/sslsecur.c b/security/nss/lib/ssl/sslsecur.c
--- a/security/nss/lib/ssl/sslsecur.c
+++ b/security/nss/lib/ssl/sslsecur.c
@@ -1483,37 +1483,37 @@ int
 SSL_RestartHandshakeAfterServerCert(sslSocket * ss)
 {
     PORT_SetError(PR_NOT_IMPLEMENTED_ERROR);
     return -1;
 }
 
 /* See documentation in ssl.h */
 SECStatus
-SSL_RestartHandshakeAfterAuthCertificate(PRFileDesc *fd)
+SSL_AuthCertificateComplete(PRFileDesc *fd, PRErrorCode status)
 {
-    SECStatus rv = SECSuccess;
+    SECStatus rv;
     sslSocket *ss = ssl_FindSocket(fd);
 
     if (!ss) {
-	SSL_DBG(("%d: SSL[%d]: bad socket in SSL_RestartHandshakeAfterPeerCert",
+	SSL_DBG(("%d: SSL[%d]: bad socket in SSL_AuthCertificateComplete",
 		 SSL_GETPID(), fd));
 	return SECFailure;
     }
 
     ssl_Get1stHandshakeLock(ss);
 
     if (!ss->ssl3.initialized) {
 	PORT_SetError(SEC_ERROR_INVALID_ARGS);
 	rv = SECFailure;
     } else if (ss->version < SSL_LIBRARY_VERSION_3_0) {
 	PORT_SetError(SSL_ERROR_FEATURE_NOT_SUPPORTED_FOR_SSL2);
 	rv = SECFailure;
     } else {
-	rv = ssl3_RestartHandshakeAfterAuthCertificate(ss);
+	rv = ssl3_AuthCertificateComplete(ss, status);
     }
 
     ssl_Release1stHandshakeLock(ss);
 
     return rv;
 }
 
 /* For more info see ssl.h */
diff --git a/security/patches/README b/security/patches/README
--- a/security/patches/README
+++ b/security/patches/README
@@ -1,7 +1,20 @@
 This directory contains patches that were added locally
 on top of the NSS release.
 
-bug-542832-ssl-restart-4.patch and bug-542832-ssl-restart-tstclnt-4.patch were
-added so that we could test the new PSM SSL threading code (bug 674147) and
-SPDY (bug 528288). These patches will be removed when the NSS 3.13.2 release
-that includes them is imported into mozilla-central.
+bug-542832-ssl-restart-4.patch
+bug-542832-ssl-restart-tstclnt-4.patch
+
+	Added in Bug 542832 so that we could test the new PSM SSL threading
+	code (bug 674147) and SPDY (bug 528288). These patches will be removed
+	when the NSS 3.13.2 release that includes them is imported into
+	mozilla-central.
+
+ssl-restart-fix-whitespace-v1.patch
+ssl-restart-3-alerts-v1.patch
+ssl-restart-4-tstclnt-alerts-v2.patch
+ssl-restart-5-disable-false-start-v1.patch
+
+	Added in bug 713934 to update our local copy of NSS to use
+	the new version of the API added in the previous patches. These patches
+	will be removed	when the NSS 3.13.2 release that includes them is
+	imported into mozilla-central.
diff --git a/security/patches/ssl-restart-3-alerts-v1.patch b/security/patches/ssl-restart-3-alerts-v1.patch
new file mode 100644
--- /dev/null
+++ b/security/patches/ssl-restart-3-alerts-v1.patch
@@ -0,0 +1,572 @@
+Index: mozilla/security/nss/lib/ssl/ssl.def
+===================================================================
+RCS file: /c/p/nss/synced/subset/mozilla/security/nss/lib/ssl/ssl.def,v
+retrieving revision 1.28
+diff -u -8 -p -r1.28 ssl.def
+--- mozilla/security/nss/lib/ssl/ssl.def	2011/12/28 04:15:54	1.28
++++ mozilla/security/nss/lib/ssl/ssl.def	2011/12/28 04:30:51
+@@ -164,12 +164,12 @@ NSSSSL_GetVersion;
+ ;+    local:
+ ;+       *;
+ ;+};
+ ;+NSS_3.13.2 {    # NSS 3.13.2 release
+ ;+    global:
+ SSL_SetNextProtoCallback;
+ SSL_SetNextProtoNego;
+ SSL_GetNextProto;
+-SSL_RestartHandshakeAfterAuthCertificate;
++SSL_AuthCertificateComplete;
+ ;+    local:
+ ;+       *;
+ ;+};
+Index: mozilla/security/nss/lib/ssl/ssl.h
+===================================================================
+RCS file: /c/p/nss/synced/subset/mozilla/security/nss/lib/ssl/ssl.h,v
+retrieving revision 1.47
+diff -u -8 -p -r1.47 ssl.h
+--- mozilla/security/nss/lib/ssl/ssl.h	2011/12/28 04:30:13	1.47
++++ mozilla/security/nss/lib/ssl/ssl.h	2011/12/28 04:31:29
+@@ -338,25 +338,25 @@ SSL_IMPORT CERTCertificate *SSL_PeerCert
+ /*
+ ** Authenticate certificate hook. Called when a certificate comes in
+ ** (because of SSL_REQUIRE_CERTIFICATE in SSL_Enable) to authenticate the
+ ** certificate.
+ **
+ ** The authenticate certificate hook must return SECSuccess to indicate the
+ ** certificate is valid, SECFailure to indicate the certificate is invalid,
+ ** or SECWouldBlock if the application will authenticate the certificate
+-** asynchronously.
++** asynchronously. SECWouldBlock is only supported for non-blocking sockets.
+ **
+ ** If the authenticate certificate hook returns SECFailure, then the bad cert
+ ** hook will be called. The bad cert handler is NEVER called if the
+ ** authenticate certificate hook returns SECWouldBlock.
+ **
+-** See the documentation for SSL_RestartHandshakeAfterAuthCertificate for more
+-** information about the asynchronous behavior that occurs when the
+-** authenticate certificate hook returns SECWouldBlock.
++** See the documentation for SSL_AuthCertificateComplete for more information
++** about the asynchronous behavior that occurs when the authenticate
++** certificate hook returns SECWouldBlock
+ */
+ typedef SECStatus (PR_CALLBACK *SSLAuthCertificate)(void *arg, PRFileDesc *fd, 
+                                                     PRBool checkSig,
+                                                     PRBool isServer);
+ 
+ SSL_IMPORT SECStatus SSL_AuthCertificateHook(PRFileDesc *fd, 
+ 					     SSLAuthCertificate f,
+ 				             void *arg);
+@@ -454,21 +454,22 @@ SSL_IMPORT SECStatus SSL_SetPKCS11PinArg
+ /*
+ ** This is a callback for dealing with server certs that are not authenticated
+ ** by the client.  The client app can decide that it actually likes the
+ ** cert by some external means and restart the connection.
+ **
+ ** The bad cert hook must return SECSuccess to override the result of the
+ ** authenticate certificate hook, SECFailure if the certificate should still be
+ ** considered invalid, or SECWouldBlock if the application will authenticate
+-** the certificate asynchronously.
++** the certificate asynchronously. SECWouldBlock is only supported for
++** non-blocking sockets.
+ **
+-** See the documentation for SSL_RestartHandshakeAfterAuthCertificate for more
+-** information about the asynchronous behavior that occurs when the bad cert
+-** hook returns SECWouldBlock.
++** See the documentation for SSL_AuthCertificateComplete for more information
++** about the asynchronous behavior that occurs when the bad cert hook returns
++** SECWouldBlock.
+ */
+ typedef SECStatus (PR_CALLBACK *SSLBadCertHandler)(void *arg, PRFileDesc *fd);
+ SSL_IMPORT SECStatus SSL_BadCertHook(PRFileDesc *fd, SSLBadCertHandler f, 
+ 				     void *arg);
+ 
+ /*
+ ** Configure SSL socket for running a secure server. Needs the
+ ** certificate for the server and the servers private key. The arguments
+@@ -761,54 +762,64 @@ extern PRBool NSSSSL_VersionCheck(const 
+  * Returns a const string of the SSL library version.
+  */
+ extern const char *NSSSSL_GetVersion(void);
+ 
+ /* Restart an SSL connection that was paused to do asynchronous certificate
+  * chain validation (when the auth certificate hook or bad cert handler
+  * returned SECWouldBlock).
+  *
+- * Currently, this function works only for the client role of a connection; it
+- * does not work for the server role.
++ * This function only works for non-blocking sockets; Do not use it for
++ * blocking sockets. Currently, this function works only for the client role of
++ * a connection; it does not work for the server role.
+  *
+- * The application MUST call SSL_RestartHandshakeAfterAuthCertificate after it
+- * has successfully validated the peer's certificate to continue the SSL
+- * handshake.
++ * The application must call SSL_AuthCertificateComplete with 0 as the value of
++ * status parameter after it has successfully validated the peer's certificate,
++ * in order to continue the SSL handshake.
+  *
+- * The application MUST NOT call SSL_RestartHandshakeAfterAuthCertificate when
+- * certificate validation fails; instead, it should just close the connection.
++ * The application may call SSL_AuthCertificateComplete with a non-zero value
++ * for status (e.g. SEC_ERROR_REVOKED_CERTIFICATE) when certificate validation
++ * fails, before it closes the connection. If the application does so, an
++ * alert corresponding to the error (e.g. certificate_revoked) will be sent to
++ * the peer. See the source code of the internal function
++ * ssl3_SendAlertForCertError for the current mapping of error to alert. This
++ * mapping may change in future versions of libssl.
+  *
+  * This function will not complete the entire handshake. The application must
+  * call SSL_ForceHandshake, PR_Recv, PR_Send, etc. after calling this function
+  * to force the handshake to complete.
+  *
+- * libssl will wait for the peer's certificate to be authenticated before
+- * calling the handshake callback, sending a client certificate,
+- * sending any application data, or returning any application data to the
+- * application (on the first handshake on a connection only).
++ * On the first handshake of a connection, libssl will wait for the peer's
++ * certificate to be authenticated before calling the handshake callback,
++ * sending a client certificate, sending any application data, or returning
++ * any application data to the application. On subsequent (renegotiation)
++ * handshakes, libssl will block the handshake unconditionally while the
++ * certificate is being validated.
+  *
+- * However, libssl may send and receive handshake messages while waiting for
+- * the application to call SSL_RestartHandshakeAfterAuthCertificate, and it may
+- * call other callbacks (e.g, the client auth data hook) before
+- * SSL_RestartHandshakeAfterAuthCertificate has been called.
++ * libssl may send and receive handshake messages while waiting for the
++ * application to call SSL_AuthCertificateComplete, and it may call other
++ * callbacks (e.g, the client auth data hook) before
++ * SSL_AuthCertificateComplete has been called.
+  *
+  * An application that uses this asynchronous mechanism will usually have lower
+  * handshake latency if it has to do public key operations on the certificate
+- * chain during the authentication, especially if it does so in parallel on
+- * another thread. However, if the application can authenticate the peer's
+- * certificate quickly then it may be more efficient to use the synchronous
+- * mechanism (i.e. returning SECFailure/SECSuccess instead of SECWouldBlock
+- * from the authenticate certificate hook).
++ * chain and/or CRL/OCSP/cert fetching during the authentication, especially if
++ * it does so in parallel on another thread. However, if the application can
++ * authenticate the peer's certificate quickly then it may be more efficient
++ * to use the synchronous mechanism (i.e. returning SECFailure/SECSuccess
++ * instead of SECWouldBlock from the authenticate certificate hook).
+  *
+  * Be careful about converting an application from synchronous cert validation
+  * to asynchronous certificate validation. A naive conversion is likely to
+  * result in deadlocks; e.g. the application will wait in PR_Poll for network
+  * I/O on the connection while all network I/O on the connection is blocked
+  * waiting for this function to be called.
+  *
+  * Returns SECFailure on failure, SECSuccess on success. Never returns
+- * SECWouldBlock.
++ * SECWouldBlock. Note that SSL_AuthCertificateComplete will (usually) return
++ * SECSuccess; do not interpret the return value of SSL_AuthCertificateComplete
++ * as an indicator of whether it is OK to continue using the connection.
+  */
+-SSL_IMPORT SECStatus SSL_RestartHandshakeAfterAuthCertificate(PRFileDesc *fd);
+-
++SSL_IMPORT SECStatus SSL_AuthCertificateComplete(PRFileDesc *fd,
++						 PRErrorCode status);
+ SEC_END_PROTOS
+ 
+ #endif /* __ssl_h_ */
+Index: mozilla/security/nss/lib/ssl/ssl3con.c
+===================================================================
+RCS file: /c/p/nss/synced/subset/mozilla/security/nss/lib/ssl/ssl3con.c,v
+retrieving revision 1.160
+diff -u -8 -p -r1.160 ssl3con.c
+--- mozilla/security/nss/lib/ssl/ssl3con.c	2011/12/28 04:30:13	1.160
++++ mozilla/security/nss/lib/ssl/ssl3con.c	2011/12/28 04:31:42
+@@ -2602,16 +2602,50 @@ static SECStatus
+ ssl3_HandshakeFailure(sslSocket *ss)
+ {
+     (void)SSL3_SendAlert(ss, alert_fatal, handshake_failure);
+     PORT_SetError( ss->sec.isServer ? SSL_ERROR_BAD_CLIENT
+                                     : SSL_ERROR_BAD_SERVER );
+     return SECFailure;
+ }
+ 
++static void
++ssl3_SendAlertForCertError(sslSocket * ss, PRErrorCode errCode)
++{
++    SSL3AlertDescription desc	= bad_certificate;
++    PRBool isTLS = ss->version >= SSL_LIBRARY_VERSION_3_1_TLS;
++
++    switch (errCode) {
++    case SEC_ERROR_LIBRARY_FAILURE:     desc = unsupported_certificate; break;
++    case SEC_ERROR_EXPIRED_CERTIFICATE: desc = certificate_expired;     break;
++    case SEC_ERROR_REVOKED_CERTIFICATE: desc = certificate_revoked;     break;
++    case SEC_ERROR_INADEQUATE_KEY_USAGE:
++    case SEC_ERROR_INADEQUATE_CERT_TYPE:
++		                        desc = certificate_unknown;     break;
++    case SEC_ERROR_UNTRUSTED_CERT:
++		    desc = isTLS ? access_denied : certificate_unknown; break;
++    case SEC_ERROR_UNKNOWN_ISSUER:      
++    case SEC_ERROR_UNTRUSTED_ISSUER:    
++		    desc = isTLS ? unknown_ca : certificate_unknown; break;
++    case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
++		    desc = isTLS ? unknown_ca : certificate_expired; break;
++
++    case SEC_ERROR_CERT_NOT_IN_NAME_SPACE:
++    case SEC_ERROR_PATH_LEN_CONSTRAINT_INVALID:
++    case SEC_ERROR_CA_CERT_INVALID:
++    case SEC_ERROR_BAD_SIGNATURE:
++    default:                            desc = bad_certificate;     break;
++    }
++    SSL_DBG(("%d: SSL3[%d]: peer certificate is no good: error=%d",
++	     SSL_GETPID(), ss->fd, errCode));
++
++    (void) SSL3_SendAlert(ss, alert_fatal, desc);
++}
++
++
+ /*
+  * Send handshake_Failure alert.  Set generic error number.
+  */
+ static SECStatus
+ ssl3_DecodeError(sslSocket *ss)
+ {
+     (void)SSL3_SendAlert(ss, alert_fatal, 
+ 		  ss->version > SSL_LIBRARY_VERSION_3_0 ? decode_error 
+@@ -5651,19 +5685,19 @@ done:
+ 
+ PRBool
+ ssl3_CanFalseStart(sslSocket *ss) {
+     PRBool rv;
+ 
+     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
+ 
+     /* XXX: does not take into account whether we are waiting for
+-     * SSL_RestartHandshakeAfterAuthCertificate or
+-     * SSL_RestartHandshakeAfterCertReq. If/when that is done, this function
+-     * could return different results each time it would be called.
++     * SSL_AuthCertificateComplete or SSL_RestartHandshakeAfterCertReq. If/when
++     * that is done, this function could return different results each time it
++     * would be called.
+      */
+ 
+     ssl_GetSpecReadLock(ss);
+     rv = ss->opt.enableFalseStart &&
+ 	 !ss->sec.isServer &&
+ 	 !ss->ssl3.hs.isResuming &&
+ 	 ss->ssl3.cwSpec &&
+ 	 ss->ssl3.cwSpec->cipher_def->secret_key_size >= 10 &&
+@@ -5700,18 +5734,17 @@ ssl3_HandleServerHelloDone(sslSocket *ss
+ 	return SECFailure;
+     }
+ 
+     rv = ssl3_SendClientSecondRound(ss);
+ 
+     return rv;
+ }
+ 
+-/* Called from ssl3_HandleServerHelloDone and
+- * ssl3_RestartHandshakeAfterServerCert.
++/* Called from ssl3_HandleServerHelloDone and ssl3_AuthCertificateComplete.
+  *
+  * Caller must hold Handshake and RecvBuf locks.
+  */
+ static SECStatus
+ ssl3_SendClientSecondRound(sslSocket *ss)
+ {
+     SECStatus rv;
+     PRBool sendClientCert;
+@@ -7823,17 +7856,17 @@ ssl3_HandleCertificate(sslSocket *ss, SS
+     ssl3CertNode *   c;
+     ssl3CertNode *   lastCert 	= NULL;
+     PRInt32          remaining  = 0;
+     PRInt32          size;
+     SECStatus        rv;
+     PRBool           isServer	= (PRBool)(!!ss->sec.isServer);
+     PRBool           trusted 	= PR_FALSE;
+     PRBool           isTLS;
+-    SSL3AlertDescription desc	= bad_certificate;
++    SSL3AlertDescription desc;
+     int              errCode    = SSL_ERROR_RX_MALFORMED_CERTIFICATE;
+     SECItem          certItem;
+ 
+     SSL_TRC(3, ("%d: SSL3[%d]: handle certificate handshake",
+ 		SSL_GETPID(), ss->fd));
+     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
+     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
+ 
+@@ -7982,17 +8015,18 @@ ssl3_HandleCertificate(sslSocket *ss, SS
+ 		goto loser;
+ 	    }
+ 
+ 	    ss->ssl3.hs.authCertificatePending = PR_TRUE;
+ 	    rv = SECSuccess;
+ 	}
+ 
+ 	if (rv != SECSuccess) {
+-	    goto bad_cert;
++	    ssl3_SendAlertForCertError(ss, errCode);
++	    goto loser;
+ 	}
+     }
+ 
+     ss->sec.ci.sid->peerCert = CERT_DupCertificate(ss->sec.peerCert);
+ 
+     if (!ss->sec.isServer) {
+         CERTCertificate *cert = ss->sec.peerCert;
+ 
+@@ -8053,58 +8087,33 @@ server_no_cert:
+     }
+ 
+     PORT_Assert(rv == SECSuccess);
+     if (rv != SECSuccess) {
+ 	errCode = SEC_ERROR_LIBRARY_FAILURE;
+ 	rv = SECFailure;
+ 	goto loser;
+     }
++
+     return rv;
+ 
+ ambiguous_err:
+     errCode = PORT_GetError();
+     switch (errCode) {
+     case PR_OUT_OF_MEMORY_ERROR:
+     case SEC_ERROR_BAD_DATABASE:
+     case SEC_ERROR_NO_MEMORY:
+ 	if (isTLS) {
+ 	    desc = internal_error;
+ 	    goto alert_loser;
+ 	}
+ 	goto loser;
+-    }
+-    /* fall through to bad_cert. */
+-
+-bad_cert:	/* caller has set errCode. */
+-    switch (errCode) {
+-    case SEC_ERROR_LIBRARY_FAILURE:     desc = unsupported_certificate; break;
+-    case SEC_ERROR_EXPIRED_CERTIFICATE: desc = certificate_expired;     break;
+-    case SEC_ERROR_REVOKED_CERTIFICATE: desc = certificate_revoked;     break;
+-    case SEC_ERROR_INADEQUATE_KEY_USAGE:
+-    case SEC_ERROR_INADEQUATE_CERT_TYPE:
+-		                        desc = certificate_unknown;     break;
+-    case SEC_ERROR_UNTRUSTED_CERT:
+-		    desc = isTLS ? access_denied : certificate_unknown; break;
+-    case SEC_ERROR_UNKNOWN_ISSUER:      
+-    case SEC_ERROR_UNTRUSTED_ISSUER:    
+-		    desc = isTLS ? unknown_ca : certificate_unknown; break;
+-    case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
+-		    desc = isTLS ? unknown_ca : certificate_expired; break;
+-
+-    case SEC_ERROR_CERT_NOT_IN_NAME_SPACE:
+-    case SEC_ERROR_PATH_LEN_CONSTRAINT_INVALID:
+-    case SEC_ERROR_CA_CERT_INVALID:
+-    case SEC_ERROR_BAD_SIGNATURE:
+-    default:                            desc = bad_certificate;     break;
+     }
+-    SSL_DBG(("%d: SSL3[%d]: peer certificate is no good: error=%d",
+-	     SSL_GETPID(), ss->fd, errCode));
+-
+-    goto alert_loser;
++    ssl3_SendAlertForCertError(ss, errCode);
++    goto loser;
+ 
+ decode_loser:
+     desc = isTLS ? decode_error : bad_certificate;
+ 
+ alert_loser:
+     (void)SSL3_SendAlert(ss, alert_fatal, desc);
+ 
+ loser:
+@@ -8115,54 +8124,68 @@ loser:
+ 	ss->sec.peerCert = NULL;
+     }
+     (void)ssl_MapLowLevelError(errCode);
+     return SECFailure;
+ }
+ 
+ static SECStatus ssl3_FinishHandshake(sslSocket *ss);
+ 
++static SECStatus
++ssl3_AlwaysFail(sslSocket * ss)
++{
++    PORT_SetError(PR_INVALID_STATE_ERROR);
++    return SECFailure;
++}
++
+ /* Caller must hold 1stHandshakeLock.
+ */
+ SECStatus
+-ssl3_RestartHandshakeAfterAuthCertificate(sslSocket *ss)
++ssl3_AuthCertificateComplete(sslSocket *ss, PRErrorCode status)
+ {
+     SECStatus rv;
+ 
+     PORT_Assert(ss->opt.noLocks || ssl_Have1stHandshakeLock(ss));
+ 
+     if (ss->sec.isServer) {
+ 	PORT_SetError(SSL_ERROR_FEATURE_NOT_SUPPORTED_FOR_SERVERS);
+ 	return SECFailure;
+     }
+ 
+     ssl_GetRecvBufLock(ss);
+     ssl_GetSSL3HandshakeLock(ss);
+ 
+     if (!ss->ssl3.hs.authCertificatePending) {
+ 	PORT_SetError(PR_INVALID_STATE_ERROR);
+ 	rv = SECFailure;
+-    } else {
+-	ss->ssl3.hs.authCertificatePending = PR_FALSE;
+-	if (ss->ssl3.hs.restartTarget != NULL) {
+-	    sslRestartTarget target = ss->ssl3.hs.restartTarget;
+-	    ss->ssl3.hs.restartTarget = NULL;
+-	    rv = target(ss);
+-	    /* Even if we blocked here, we have accomplished enough to claim
+-	     * success. Any remaining work will be taken care of by subsequent
+-	     * calls to SSL_ForceHandshake/PR_Send/PR_Read/etc.
+-	     */
+-	    if (rv == SECWouldBlock) {
+-		rv = SECSuccess;
+-	    }
+-	} else {
++	goto done;
++    }
++
++    ss->ssl3.hs.authCertificatePending = PR_FALSE;
++
++    if (status != 0) {
++	ss->ssl3.hs.restartTarget = ssl3_AlwaysFail;
++	ssl3_SendAlertForCertError(ss, status);
++	rv = SECSuccess;
++    } else if (ss->ssl3.hs.restartTarget != NULL) {
++	sslRestartTarget target = ss->ssl3.hs.restartTarget;
++	ss->ssl3.hs.restartTarget = NULL;
++	rv = target(ss);
++	/* Even if we blocked here, we have accomplished enough to claim
++	 * success. Any remaining work will be taken care of by subsequent
++	 * calls to SSL_ForceHandshake/PR_Send/PR_Read/etc. 
++	 */
++	if (rv == SECWouldBlock) {
+ 	    rv = SECSuccess;
+ 	}
++    } else {
++	rv = SECSuccess;
+     }
+ 
++done:
+     ssl_ReleaseSSL3HandshakeLock(ss);
+     ssl_ReleaseRecvBufLock(ss);
+ 
+     return rv;
+ }
+ 
+ static SECStatus
+ ssl3_ComputeTLSFinished(ssl3CipherSpec *spec,
+@@ -8901,17 +8924,16 @@ ssl3_HandleHandshake(sslSocket *ss, sslB
+  * checked, and is already sitting in databuf.  It is processed as an SSL
+  * Handshake message.
+  *
+  * DOES NOT process the decrypted/decompressed application data.
+  * On return, databuf contains the decrypted/decompressed record.
+  *
+  * Called from ssl3_GatherCompleteHandshake
+  *             ssl3_RestartHandshakeAfterCertReq
+- *             ssl3_RestartHandshakeAfterServerCert
+  *
+  * Caller must hold the RecvBufLock.
+  *
+  * This function aquires and releases the SSL3Handshake Lock, holding the
+  * lock around any calls to functions that handle records other than
+  * Application Data records.
+  */
+ SECStatus
+Index: mozilla/security/nss/lib/ssl/sslimpl.h
+===================================================================
+RCS file: /c/p/nss/synced/subset/mozilla/security/nss/lib/ssl/sslimpl.h,v
+retrieving revision 1.92
+diff -u -8 -p -r1.92 sslimpl.h
+--- mozilla/security/nss/lib/ssl/sslimpl.h	2011/12/28 04:30:13	1.92
++++ mozilla/security/nss/lib/ssl/sslimpl.h	2011/12/28 04:31:46
+@@ -789,17 +789,18 @@ const ssl3CipherSuiteDef *suite_def;
+ 	SSL3Opaque        data[72];
+     }                     finishedMsgs;
+ #ifdef NSS_ENABLE_ECC
+     PRUint32              negotiatedECCurves; /* bit mask */
+ #endif /* NSS_ENABLE_ECC */
+ 
+     PRBool                authCertificatePending;
+     /* Which function should SSL_RestartHandshake* call if we're blocked?
+-     * One of NULL, ssl3_SendClientSecondRound, or ssl3_FinishHandshake. */
++     * One of NULL, ssl3_SendClientSecondRound, ssl3_FinishHandshake,
++     * or ssl3_AlwaysFail */
+     sslRestartTarget      restartTarget;
+     /* Shared state between ssl3_HandleFinished and ssl3_FinishHandshake */
+     PRBool                cacheSID;
+ } SSL3HandshakeState;
+ 
+ 
+ 
+ /*
+@@ -1353,17 +1354,17 @@ extern int SSL_RestartHandshakeAfterCert
+ 					    CERTCertificate *cert,
+ 					    SECKEYPrivateKey *key,
+ 					    CERTCertificateList *certChain);
+ extern sslSocket *ssl_FindSocket(PRFileDesc *fd);
+ extern void ssl_FreeSocket(struct sslSocketStr *ssl);
+ extern SECStatus SSL3_SendAlert(sslSocket *ss, SSL3AlertLevel level,
+ 				SSL3AlertDescription desc);
+ 
+-extern SECStatus ssl3_RestartHandshakeAfterAuthCertificate(sslSocket *ss);
++extern SECStatus ssl3_AuthCertificateComplete(sslSocket *ss, PRErrorCode status);
+ 
+ /*
+  * for dealing with SSL 3.0 clients sending SSL 2.0 format hellos
+  */
+ extern SECStatus ssl3_HandleV2ClientHello(
+     sslSocket *ss, unsigned char *buffer, int length);
+ extern SECStatus ssl3_StartHandshakeHash(
+     sslSocket *ss, unsigned char *buf, int length);
+Index: mozilla/security/nss/lib/ssl/sslsecur.c
+===================================================================
+RCS file: /c/p/nss/synced/subset/mozilla/security/nss/lib/ssl/sslsecur.c,v
+retrieving revision 1.54
+diff -u -8 -p -r1.54 sslsecur.c
+--- mozilla/security/nss/lib/ssl/sslsecur.c	2011/12/28 04:15:54	1.54
++++ mozilla/security/nss/lib/ssl/sslsecur.c	2011/12/28 04:31:50
+@@ -1483,37 +1483,37 @@ int
+ SSL_RestartHandshakeAfterServerCert(sslSocket * ss)
+ {
+     PORT_SetError(PR_NOT_IMPLEMENTED_ERROR);
+     return -1;
+ }
+ 
+ /* See documentation in ssl.h */
+ SECStatus
+-SSL_RestartHandshakeAfterAuthCertificate(PRFileDesc *fd)
++SSL_AuthCertificateComplete(PRFileDesc *fd, PRErrorCode status)
+ {
+-    SECStatus rv = SECSuccess;
++    SECStatus rv;
+     sslSocket *ss = ssl_FindSocket(fd);
+ 
+     if (!ss) {
+-	SSL_DBG(("%d: SSL[%d]: bad socket in SSL_RestartHandshakeAfterPeerCert",
++	SSL_DBG(("%d: SSL[%d]: bad socket in SSL_AuthCertificateComplete",
+ 		 SSL_GETPID(), fd));
+ 	return SECFailure;
+     }
+ 
+     ssl_Get1stHandshakeLock(ss);
+ 
+     if (!ss->ssl3.initialized) {
+ 	PORT_SetError(SEC_ERROR_INVALID_ARGS);
+ 	rv = SECFailure;
+     } else if (ss->version < SSL_LIBRARY_VERSION_3_0) {
+ 	PORT_SetError(SSL_ERROR_FEATURE_NOT_SUPPORTED_FOR_SSL2);
+ 	rv = SECFailure;
+     } else {
+-	rv = ssl3_RestartHandshakeAfterAuthCertificate(ss);
++	rv = ssl3_AuthCertificateComplete(ss, status);
+     }
+ 
+     ssl_Release1stHandshakeLock(ss);
+ 
+     return rv;
+ }
+ 
+ /* For more info see ssl.h */
diff --git a/security/patches/ssl-restart-4-tstclnt-alerts-v2.patch b/security/patches/ssl-restart-4-tstclnt-alerts-v2.patch
new file mode 100644
--- /dev/null
+++ b/security/patches/ssl-restart-4-tstclnt-alerts-v2.patch
@@ -0,0 +1,46 @@
+Index: mozilla/security/nss/cmd/tstclnt/tstclnt.c
+===================================================================
+RCS file: /c/p/nss/synced/subset/mozilla/security/nss/cmd/tstclnt/tstclnt.c,v
+retrieving revision 1.65
+retrieving revision 1.67
+diff -u -r1.65 -r1.67
+--- mozilla/security/nss/cmd/tstclnt/tstclnt.c	2011/12/28 04:36:59	1.65
++++ mozilla/security/nss/cmd/tstclnt/tstclnt.c	2011/12/28 15:02:15	1.67
+@@ -530,6 +530,7 @@
+                                         PRBool override)
+ {
+     SECStatus rv;
++    PRErrorCode status;
+     
+     if (!serverCertAuth->isPaused)
+ 	return SECSuccess;
+@@ -539,14 +540,23 @@
+ 
+     serverCertAuth->isPaused = PR_FALSE;
+     rv = SSL_AuthCertificate(serverCertAuth->dbHandle, fd, PR_TRUE, PR_FALSE);
+-    if (rv != SECSuccess && override) {
+-        rv = ownBadCertHandler(NULL, fd);
+-    }
+     if (rv != SECSuccess) {
+-	return rv;
++        status = PR_GetError();
++        if (status == 0) {
++            PR_NOT_REACHED("SSL_AuthCertificate return SECFailure without "
++                           "setting error code.");
++            status = PR_INVALID_STATE_ERROR;
++        } else if (override) {
++            rv = ownBadCertHandler(NULL, fd);
++        }
+     }
+-    
+-    rv = SSL_RestartHandshakeAfterAuthCertificate(fd);
++    if (rv == SECSuccess) {
++        status = 0;
++    }
++
++    if (SSL_AuthCertificateComplete(fd, status) != SECSuccess) {
++        rv = SECFailure;
++    }
+ 
+     return rv;
+ }
diff --git a/security/patches/ssl-restart-5-disable-false-start-v1.patch b/security/patches/ssl-restart-5-disable-false-start-v1.patch
new file mode 100644
--- /dev/null
+++ b/security/patches/ssl-restart-5-disable-false-start-v1.patch
@@ -0,0 +1,31 @@
+Index: mozilla/security/nss/lib/ssl/ssl3con.c
+===================================================================
+RCS file: /c/p/nss/synced/subset/mozilla/security/nss/lib/ssl/ssl3con.c,v
+retrieving revision 1.161
+diff -u -8 -p -r1.161 ssl3con.c
+--- mozilla/security/nss/lib/ssl/ssl3con.c	2011/12/28 04:35:31	1.161
++++ mozilla/security/nss/lib/ssl/ssl3con.c	2011/12/28 15:02:31
+@@ -8012,16 +8012,23 @@ ssl3_HandleCertificate(sslSocket *ss, SS
+ 	    if (ss->sec.isServer) {
+ 		errCode = SSL_ERROR_FEATURE_NOT_SUPPORTED_FOR_SERVERS;
+ 		rv = SECFailure;
+ 		goto loser;
+ 	    }
+ 
+ 	    ss->ssl3.hs.authCertificatePending = PR_TRUE;
+ 	    rv = SECSuccess;
++
++	    /* XXX: Async cert validation and False Start don't work together
++	     * safely yet; if we leave False Start enabled, we may end up false
++	     * starting (sending application data) before we
++	     * SSL_AuthCertificateComplete has been called.
++	     */
++	    ss->opt.enableFalseStart = PR_FALSE;
+ 	}
+ 
+ 	if (rv != SECSuccess) {
+ 	    ssl3_SendAlertForCertError(ss, errCode);
+ 	    goto loser;
+ 	}
+     }
+ 
diff --git a/security/patches/ssl-restart-fix-whitespace-v1.patch b/security/patches/ssl-restart-fix-whitespace-v1.patch
new file mode 100644
--- /dev/null
+++ b/security/patches/ssl-restart-fix-whitespace-v1.patch
@@ -0,0 +1,342 @@
+Index: mozilla/security/nss/lib/ssl/ssl.h
+===================================================================
+RCS file: /c/p/nss/synced/subset/mozilla/security/nss/lib/ssl/ssl.h,v
+retrieving revision 1.46
+diff -u -8 -p -r1.46 ssl.h
+--- mozilla/security/nss/lib/ssl/ssl.h	2011/12/28 04:15:54	1.46
++++ mozilla/security/nss/lib/ssl/ssl.h	2011/12/28 04:26:47
+@@ -343,17 +343,17 @@ SSL_IMPORT CERTCertificate *SSL_PeerCert
+ ** The authenticate certificate hook must return SECSuccess to indicate the
+ ** certificate is valid, SECFailure to indicate the certificate is invalid,
+ ** or SECWouldBlock if the application will authenticate the certificate
+ ** asynchronously.
+ **
+ ** If the authenticate certificate hook returns SECFailure, then the bad cert
+ ** hook will be called. The bad cert handler is NEVER called if the
+ ** authenticate certificate hook returns SECWouldBlock.
+-** 
++**
+ ** See the documentation for SSL_RestartHandshakeAfterAuthCertificate for more
+ ** information about the asynchronous behavior that occurs when the
+ ** authenticate certificate hook returns SECWouldBlock.
+ */
+ typedef SECStatus (PR_CALLBACK *SSLAuthCertificate)(void *arg, PRFileDesc *fd, 
+                                                     PRBool checkSig,
+                                                     PRBool isServer);
+ 
+@@ -783,17 +783,17 @@ extern const char *NSSSSL_GetVersion(voi
+  * libssl will wait for the peer's certificate to be authenticated before
+  * calling the handshake callback, sending a client certificate,
+  * sending any application data, or returning any application data to the
+  * application (on the first handshake on a connection only).
+  *
+  * However, libssl may send and receive handshake messages while waiting for
+  * the application to call SSL_RestartHandshakeAfterAuthCertificate, and it may
+  * call other callbacks (e.g, the client auth data hook) before
+- * SSL_RestartHandshakeAfterAuthCertificate has been called. 
++ * SSL_RestartHandshakeAfterAuthCertificate has been called.
+  *
+  * An application that uses this asynchronous mechanism will usually have lower
+  * handshake latency if it has to do public key operations on the certificate
+  * chain during the authentication, especially if it does so in parallel on
+  * another thread. However, if the application can authenticate the peer's
+  * certificate quickly then it may be more efficient to use the synchronous
+  * mechanism (i.e. returning SECFailure/SECSuccess instead of SECWouldBlock
+  * from the authenticate certificate hook).
+Index: mozilla/security/nss/lib/ssl/ssl3con.c
+===================================================================
+RCS file: /c/p/nss/synced/subset/mozilla/security/nss/lib/ssl/ssl3con.c,v
+retrieving revision 1.159
+diff -u -8 -p -r1.159 ssl3con.c
+--- mozilla/security/nss/lib/ssl/ssl3con.c	2011/12/28 04:15:54	1.159
++++ mozilla/security/nss/lib/ssl/ssl3con.c	2011/12/28 04:26:55
+@@ -5736,31 +5736,31 @@ ssl3_SendClientSecondRound(sslSocket *ss
+      * application data until we have authenticated the server's certificate;
+      * i.e. we have fully authenticated the handshake before using the cipher
+      * specs agreed upon for that handshake. During a renegotiation, we may
+      * continue sending and receiving application data during the handshake
+      * interleaved with the handshake records. If we were to send the client's
+      * second round for a renegotiation before the server's certificate was
+      * authenticated, then the application data sent/received after this point
+      * would be using cipher spec that hadn't been authenticated. By waiting
+-     * until the server's certificate has been authenticated during 
++     * until the server's certificate has been authenticated during
+      * renegotiations, we ensure that renegotiations have the same property
+      * as initial handshakes; i.e. we have fully authenticated the handshake
+      * before using the cipher specs agreed upon for that handshake for
+      * application data.
+      */
+     if (ss->ssl3.hs.restartTarget) {
+-        PR_NOT_REACHED("unexpected ss->ssl3.hs.restartTarget");
+-        PORT_SetError(SEC_ERROR_LIBRARY_FAILURE);
+-        return SECFailure;
++	PR_NOT_REACHED("unexpected ss->ssl3.hs.restartTarget");
++	PORT_SetError(SEC_ERROR_LIBRARY_FAILURE);
++	return SECFailure;
+     }
+     if (ss->ssl3.hs.authCertificatePending &&
+-        (sendClientCert || ss->ssl3.sendEmptyCert || ss->firstHsDone)) {
+-        ss->ssl3.hs.restartTarget = ssl3_SendClientSecondRound;
+-        return SECWouldBlock;
++	(sendClientCert || ss->ssl3.sendEmptyCert || ss->firstHsDone)) {
++	ss->ssl3.hs.restartTarget = ssl3_SendClientSecondRound;
++	return SECWouldBlock;
+     }
+ 
+     ssl_GetXmitBufLock(ss);		/*******************************/
+ 
+     if (ss->ssl3.sendEmptyCert) {
+ 	ss->ssl3.sendEmptyCert = PR_FALSE;
+ 	rv = ssl3_SendEmptyCertificate(ss);
+ 	/* Don't send verify */
+@@ -7977,21 +7977,21 @@ ssl3_HandleCertificate(sslSocket *ss, SS
+ 
+ 	if (rv == SECWouldBlock) {
+ 	    if (ss->sec.isServer) {
+ 		errCode = SSL_ERROR_FEATURE_NOT_SUPPORTED_FOR_SERVERS;
+ 		rv = SECFailure;
+ 		goto loser;
+ 	    }
+ 
+-            ss->ssl3.hs.authCertificatePending = PR_TRUE;
+-            rv = SECSuccess;
++	    ss->ssl3.hs.authCertificatePending = PR_TRUE;
++	    rv = SECSuccess;
+ 	}
+-        
+-        if (rv != SECSuccess) {
++
++	if (rv != SECSuccess) {
+ 	    goto bad_cert;
+ 	}
+     }
+ 
+     ss->sec.ci.sid->peerCert = CERT_DupCertificate(ss->sec.peerCert);
+ 
+     if (!ss->sec.isServer) {
+         CERTCertificate *cert = ss->sec.peerCert;
+@@ -8133,34 +8133,34 @@ ssl3_RestartHandshakeAfterAuthCertificat
+ 	PORT_SetError(SSL_ERROR_FEATURE_NOT_SUPPORTED_FOR_SERVERS);
+ 	return SECFailure;
+     }
+ 
+     ssl_GetRecvBufLock(ss);
+     ssl_GetSSL3HandshakeLock(ss);
+ 
+     if (!ss->ssl3.hs.authCertificatePending) {
+-        PORT_SetError(PR_INVALID_STATE_ERROR);
+-        rv = SECFailure;
++	PORT_SetError(PR_INVALID_STATE_ERROR);
++	rv = SECFailure;
+     } else {
+-        ss->ssl3.hs.authCertificatePending = PR_FALSE;
+-        if (ss->ssl3.hs.restartTarget != NULL) {
+-            sslRestartTarget target = ss->ssl3.hs.restartTarget;
+-            ss->ssl3.hs.restartTarget = NULL;
+-            rv = target(ss);
++	ss->ssl3.hs.authCertificatePending = PR_FALSE;
++	if (ss->ssl3.hs.restartTarget != NULL) {
++	    sslRestartTarget target = ss->ssl3.hs.restartTarget;
++	    ss->ssl3.hs.restartTarget = NULL;
++	    rv = target(ss);
+ 	    /* Even if we blocked here, we have accomplished enough to claim
+-	      * success. Any remaining work will be taken care of by subsequent
+-              * calls to SSL_ForceHandshake/PR_Send/PR_Read/etc. 
+-	      */
+-            if (rv == SECWouldBlock) {
+-                rv = SECSuccess;
+-            }
+-        } else {
+-            rv = SECSuccess;
+-        }
++	     * success. Any remaining work will be taken care of by subsequent
++	     * calls to SSL_ForceHandshake/PR_Send/PR_Read/etc.
++	     */
++	    if (rv == SECWouldBlock) {
++		rv = SECSuccess;
++	    }
++	} else {
++	    rv = SECSuccess;
++	}
+     }
+ 
+     ssl_ReleaseSSL3HandshakeLock(ss);
+     ssl_ReleaseRecvBufLock(ss);
+ 
+     return rv;
+ }
+ 
+@@ -8561,35 +8561,35 @@ xmit_loser:
+ 
+ 	/* If the wrap failed, we don't cache the sid.
+ 	 * The connection continues normally however.
+ 	 */
+ 	ss->ssl3.hs.cacheSID = rv == SECSuccess;
+     }
+ 
+     if (ss->ssl3.hs.authCertificatePending) {
+-      if (ss->ssl3.hs.restartTarget) {
+-          PR_NOT_REACHED("ssl3_HandleFinished: unexpected restartTarget");
+-          PORT_SetError(SEC_ERROR_LIBRARY_FAILURE);
+-          return SECFailure;
+-      }
++	if (ss->ssl3.hs.restartTarget) {
++	    PR_NOT_REACHED("ssl3_HandleFinished: unexpected restartTarget");
++	    PORT_SetError(SEC_ERROR_LIBRARY_FAILURE);
++	    return SECFailure;
++	}
+ 
+-      ss->ssl3.hs.restartTarget = ssl3_FinishHandshake;
+-      return SECWouldBlock;
++	ss->ssl3.hs.restartTarget = ssl3_FinishHandshake;
++	return SECWouldBlock;
+     }
+-    
++
+     rv = ssl3_FinishHandshake(ss);
+     return rv;
+ }
+ 
+ SECStatus
+ ssl3_FinishHandshake(sslSocket * ss)
+ {
+     SECStatus rv;
+-    
++
+     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
+     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
+     PORT_Assert( ss->ssl3.hs.restartTarget == NULL );
+ 
+     /* The first handshake is now completed. */
+     ss->handshake           = NULL;
+     ss->firstHsDone         = PR_TRUE;
+ 
+Index: mozilla/security/nss/lib/ssl/ssl3gthr.c
+===================================================================
+RCS file: /c/p/nss/synced/subset/mozilla/security/nss/lib/ssl/ssl3gthr.c,v
+retrieving revision 1.11
+diff -u -8 -p -r1.11 ssl3gthr.c
+--- mozilla/security/nss/lib/ssl/ssl3gthr.c	2011/12/28 04:15:54	1.11
++++ mozilla/security/nss/lib/ssl/ssl3gthr.c	2011/12/28 04:27:04
+@@ -187,63 +187,63 @@ int
+ ssl3_GatherCompleteHandshake(sslSocket *ss, int flags)
+ {
+     SSL3Ciphertext cText;
+     int            rv;
+     PRBool         canFalseStart = PR_FALSE;
+ 
+     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
+     do {
+-        /* Without this, we may end up wrongly reporting
+-         * SSL_ERROR_RX_UNEXPECTED_* errors if we receive any records from the
+-         * peer while we are waiting to be restarted. 
+-         */
+-        ssl_GetSSL3HandshakeLock(ss);
+-        rv = ss->ssl3.hs.restartTarget == NULL ? SECSuccess : SECFailure;
+-        ssl_ReleaseSSL3HandshakeLock(ss);
+-        if (rv != SECSuccess) {
+-            PORT_SetError(PR_WOULD_BLOCK_ERROR);
+-            return (int) SECFailure;
+-        }
++	/* Without this, we may end up wrongly reporting
++	 * SSL_ERROR_RX_UNEXPECTED_* errors if we receive any records from the
++	 * peer while we are waiting to be restarted.
++	 */
++	ssl_GetSSL3HandshakeLock(ss);
++	rv = ss->ssl3.hs.restartTarget == NULL ? SECSuccess : SECFailure;
++	ssl_ReleaseSSL3HandshakeLock(ss);
++	if (rv != SECSuccess) {
++	    PORT_SetError(PR_WOULD_BLOCK_ERROR);
++	    return (int) SECFailure;
++	}
+ 
+-        /* Treat an empty msgState like a NULL msgState. (Most of the time
+-         * when ssl3_HandleHandshake returns SECWouldBlock, it leaves
+-         * behind a non-NULL but zero-length msgState).
+-         * Test: async_cert_restart_server_sends_hello_request_first_in_separate_record
+-         */
+-        if (ss->ssl3.hs.msgState.buf != NULL) {
+-            if (ss->ssl3.hs.msgState.len == 0) {
+-                ss->ssl3.hs.msgState.buf = NULL;
+-            }
+-        }
++	/* Treat an empty msgState like a NULL msgState. (Most of the time
++	 * when ssl3_HandleHandshake returns SECWouldBlock, it leaves
++	 * behind a non-NULL but zero-length msgState).
++	 * Test: async_cert_restart_server_sends_hello_request_first_in_separate_record
++	 */
++	if (ss->ssl3.hs.msgState.buf != NULL) {
++	    if (ss->ssl3.hs.msgState.len == 0) {
++		ss->ssl3.hs.msgState.buf = NULL;
++	    }
++	}
+ 
+-        if (ss->ssl3.hs.msgState.buf != NULL) {
+-            /* ssl3_HandleHandshake previously returned SECWouldBlock and the
+-             * as-yet-unprocessed plaintext of that previous handshake record.
+-             * We need to process it now before we overwrite it with the next
+-             * handshake record.
+-             */
++	if (ss->ssl3.hs.msgState.buf != NULL) {
++	    /* ssl3_HandleHandshake previously returned SECWouldBlock and the
++	     * as-yet-unprocessed plaintext of that previous handshake record.
++	     * We need to process it now before we overwrite it with the next
++	     * handshake record.
++	     */
+ 	    rv = ssl3_HandleRecord(ss, NULL, &ss->gs.buf);
+-        } else {
++	} else {
+ 	    /* bring in the next sslv3 record. */
+ 	    rv = ssl3_GatherData(ss, &ss->gs, flags);
+ 	    if (rv <= 0) {
+-	        return rv;
++		return rv;
+ 	    }
+ 
+-	    /* decipher it, and handle it if it's a handshake. 
+-	     * If it's application data, ss->gs.buf will not be empty upon return. 
++	    /* decipher it, and handle it if it's a handshake.
++	     * If it's application data, ss->gs.buf will not be empty upon return.
+ 	     * If it's a change cipher spec, alert, or handshake message,
+ 	     * ss->gs.buf.len will be 0 when ssl3_HandleRecord returns SECSuccess.
+ 	     */
+ 	    cText.type    = (SSL3ContentType)ss->gs.hdr[0];
+ 	    cText.version = (ss->gs.hdr[1] << 8) | ss->gs.hdr[2];
+ 	    cText.buf     = &ss->gs.inbuf;
+ 	    rv = ssl3_HandleRecord(ss, &cText, &ss->gs.buf);
+-        }
++	}
+ 	if (rv < 0) {
+ 	    return ss->recvdCloseNotify ? 0 : rv;
+ 	}
+ 
+ 	/* If we kicked off a false start in ssl3_HandleServerHelloDone, break
+ 	 * out of this loop early without finishing the handshake.
+ 	 */
+ 	if (ss->opt.enableFalseStart) {
+Index: mozilla/security/nss/lib/ssl/sslimpl.h
+===================================================================
+RCS file: /c/p/nss/synced/subset/mozilla/security/nss/lib/ssl/sslimpl.h,v
+retrieving revision 1.91
+diff -u -8 -p -r1.91 sslimpl.h
+--- mozilla/security/nss/lib/ssl/sslimpl.h	2011/12/28 04:15:54	1.91
++++ mozilla/security/nss/lib/ssl/sslimpl.h	2011/12/28 04:27:09
+@@ -792,17 +792,17 @@ const ssl3CipherSuiteDef *suite_def;
+     PRUint32              negotiatedECCurves; /* bit mask */
+ #endif /* NSS_ENABLE_ECC */
+ 
+     PRBool                authCertificatePending;
+     /* Which function should SSL_RestartHandshake* call if we're blocked?
+      * One of NULL, ssl3_SendClientSecondRound, or ssl3_FinishHandshake. */
+     sslRestartTarget      restartTarget;
+     /* Shared state between ssl3_HandleFinished and ssl3_FinishHandshake */
+-    PRBool                cacheSID; 
++    PRBool                cacheSID;
+ } SSL3HandshakeState;
+ 
+ 
+ 
+ /*
+ ** This is the "ssl3" struct, as in "ss->ssl3".
+ ** note:
+ ** usually,   crSpec == cwSpec and prSpec == pwSpec.  
