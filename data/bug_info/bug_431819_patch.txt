diff --git a/netwerk/base/public/security-prefs.js b/netwerk/base/public/security-prefs.js
--- a/netwerk/base/public/security-prefs.js
+++ b/netwerk/base/public/security-prefs.js
@@ -54,20 +54,21 @@ pref("security.ssl3.dhe_rsa_aes_128_sha"
 pref("security.ssl3.dhe_dss_aes_128_sha", true);
 pref("security.ssl3.rsa_aes_128_sha", true);
 pref("security.ssl3.dhe_rsa_des_ede3_sha", true);
 pref("security.ssl3.dhe_dss_des_ede3_sha", true);
 pref("security.ssl3.dhe_rsa_des_sha", false);
 pref("security.ssl3.dhe_dss_des_sha", false);
 pref("security.ssl3.rsa_null_sha", false);
 pref("security.ssl3.rsa_null_md5", false);
 
 pref("security.default_personal_cert",   "Ask Every Time");
+pref("security.remember_cert_checkbox_default_setting", true);
 pref("security.ask_for_password",        0);
 pref("security.password_lifetime",       30);
 pref("security.warn_entering_secure",    false);
 pref("security.warn_entering_weak",      true);
 pref("security.warn_leaving_secure",     false);
 pref("security.warn_viewing_mixed",      true);
 pref("security.warn_submit_insecure",    false);
 
 pref("security.OCSP.enabled", 1);
 pref("security.OCSP.require", false);
diff --git a/security/manager/pki/resources/content/clientauthask.js b/security/manager/pki/resources/content/clientauthask.js
--- a/security/manager/pki/resources/content/clientauthask.js
+++ b/security/manager/pki/resources/content/clientauthask.js
@@ -35,32 +35,55 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 
 const nsIDialogParamBlock = Components.interfaces.nsIDialogParamBlock;
 
 var dialogParams;
 var itemCount = 0;
+var rememberBox;
 
 function onLoad()
 {
     var cn;
     var org;
     var issuer;
 
     dialogParams = window.arguments[0].QueryInterface(nsIDialogParamBlock);
     cn = dialogParams.GetString(0);
     org = dialogParams.GetString(1);
     issuer = dialogParams.GetString(2);
 
+    // added with bug 431819. reuse string from caps in order to avoid string changes
+    var capsBundle = srGetStrBundle("chrome://global/locale/security/caps.properties");
+    var rememberString = capsBundle.GetStringFromName("CheckMessage");
+    var rememberSetting = true;
+
+    var pref = Components.classes['@mozilla.org/preferences-service;1']
+	       .getService(Components.interfaces.nsIPrefService);
+    if (pref) {
+      pref = pref.getBranch(null);
+      try {
+	rememberSetting = 
+	  pref.getBoolPref("security.remember_cert_checkbox_default_setting");
+      }
+      catch(e) {
+	// pref is missing
+      }
+    }
+
+    rememberBox = document.getElementById("rememberBox");
+    rememberBox.label = rememberString;
+    rememberBox.checked = rememberSetting;
+
     var bundle = srGetStrBundle("chrome://pippki/locale/pippki.properties");
     var message1 = bundle.formatStringFromName("clientAuthMessage1", 
                                              [org],
                                              1);
     var message2 = bundle.formatStringFromName("clientAuthMessage2",
                                              [issuer],
                                              1);
     setText("hostname", cn);
     setText("organization", message1);
     setText("issuer", message2);
@@ -91,18 +114,21 @@ function setDetails()
 function onCertSelected()
 {
   setDetails();
 }
 
 function doOK()
 {
   dialogParams.SetInt(0,1);
   var index = parseInt(document.getElementById("nicknames").value);
   dialogParams.SetInt(1, index);
+  dialogParams.SetInt(2, rememberBox.checked);
   return true;
 }
 
 function doCancel()
 {
   dialogParams.SetInt(0,0);
+  dialogParams.SetInt(1, -1); // invalid value
+  dialogParams.SetInt(2, rememberBox.checked);
   return true;
 }
diff --git a/security/manager/pki/resources/content/clientauthask.xul b/security/manager/pki/resources/content/clientauthask.xul
--- a/security/manager/pki/resources/content/clientauthask.xul
+++ b/security/manager/pki/resources/content/clientauthask.xul
@@ -66,13 +66,14 @@
     <broadcaster id="certSelected" oncommand="onCertSelected();"/>
     <!-- The items in this menulist must never be sorted,
          but remain in the order filled by the application
     -->
     <menulist id="nicknames" observes="certSelected">
         <menupopup/>
     </menulist>
     <description>&clientAuthAsk.message3;</description>
     <textbox readonly="true" id="details" multiline="true"
       style="height: 11em;"/>
+    <checkbox id="rememberBox" checked="true"/>
   </groupbox>
 
 </dialog>
diff --git a/security/manager/pki/src/nsNSSDialogs.cpp b/security/manager/pki/src/nsNSSDialogs.cpp
--- a/security/manager/pki/src/nsNSSDialogs.cpp
+++ b/security/manager/pki/src/nsNSSDialogs.cpp
@@ -304,24 +304,32 @@ nsNSSDialogs::ChooseCertificate(nsIInter
 
   rv = block->SetInt(0, count);
   if (NS_FAILED(rv)) return rv;
 
   rv = nsNSSDialogHelper::openDialog(nsnull,
                                 "chrome://pippki/content/clientauthask.xul",
                                 block);
   if (NS_FAILED(rv)) return rv;
 
   PRInt32 status;
-
   rv = block->GetInt(0, &status);
   if (NS_FAILED(rv)) return rv;
 
+  nsCOMPtr<nsIClientAuthUserDecision> extraResult = do_QueryInterface(ctx);
+  if (extraResult) {
+    PRInt32 rememberSelection;
+    rv = block->GetInt(2, &rememberSelection);
+    if (NS_SUCCEEDED(rv)) {
+      extraResult->SetRememberClientAuthCertificate(rememberSelection!=0);
+    }
+  }
+
   *canceled = (status == 0)?PR_TRUE:PR_FALSE;
   if (!*canceled) {
     // retrieve the nickname
     rv = block->GetInt(1, selectedIndex);
   }
   return rv;
 }
 
 
 NS_IMETHODIMP
diff --git a/security/manager/ssl/public/nsIClientAuthDialogs.idl b/security/manager/ssl/public/nsIClientAuthDialogs.idl
--- a/security/manager/ssl/public/nsIClientAuthDialogs.idl
+++ b/security/manager/ssl/public/nsIClientAuthDialogs.idl
@@ -54,13 +54,19 @@ interface nsIClientAuthDialogs : nsISupp
                         in wstring cn,
                         in wstring organization,
                         in wstring issuer,
                         [array, size_is(count)] in wstring certNickList,
                         [array, size_is(count)] in wstring certDetailsList,
                         in unsigned long count,
                         out long selectedIndex,
                         out boolean canceled);
 };
 
+[scriptable, uuid(95c4373e-bdd4-4a63-b431-f5b000367721)]
+interface nsIClientAuthUserDecision : nsISupports
+{
+  attribute boolean rememberClientAuthCertificate;
+};
+
 %{C++
 #define NS_CLIENTAUTHDIALOGS_CONTRACTID "@mozilla.org/nsClientAuthDialogs;1"
 %}
diff --git a/security/manager/ssl/src/Makefile.in b/security/manager/ssl/src/Makefile.in
--- a/security/manager/ssl/src/Makefile.in
+++ b/security/manager/ssl/src/Makefile.in
@@ -51,20 +51,21 @@ IS_COMPONENT	= 1
 MODULE_NAME	= NSS
 EXPORT_LIBRARY	= 1
 META_COMPONENT	= crypto
 GRE_MODULE	= 1
 LIBXUL_LIBRARY	= 1
 
 CPPSRCS = 				\
 	nsNSSCleaner.cpp                \
 	nsCertOverrideService.cpp   \
 	nsRecentBadCerts.cpp \
+        nsClientAuthRemember.cpp        \
 	nsPSMBackgroundThread.cpp       \
 	nsSSLThread.cpp                 \
 	nsCertVerificationThread.cpp    \
 	nsCipherInfo.cpp \
 	nsProtectedAuthThread.cpp \
 	nsNSSCallbacks.cpp		\
 	nsNSSComponent.cpp		\
 	nsNSSErrors.cpp			\
 	nsNSSIOLayer.cpp		\
 	nsSSLStatus.cpp		\
diff --git a/security/manager/ssl/src/nsClientAuthRemember.cpp b/security/manager/ssl/src/nsClientAuthRemember.cpp
new file mode 100644
--- /dev/null
+++ b/security/manager/ssl/src/nsClientAuthRemember.cpp
@@ -0,0 +1,265 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Red Hat, Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Kai Engert <kengert@redhat.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsClientAuthRemember.h"
+
+#include "nsIX509Cert.h"
+#include "nsCRT.h"
+#include "nsNetUtil.h"
+#include "nsIObserverService.h"
+#include "nsNetUtil.h"
+#include "nsISupportsPrimitives.h"
+#include "nsPromiseFlatString.h"
+#include "nsProxiedService.h"
+#include "nsStringBuffer.h"
+#include "nsAutoLock.h"
+#include "nspr.h"
+#include "pk11pub.h"
+#include "certdb.h"
+#include "sechash.h"
+#include "ssl.h" // For SSL_ClearSessionCache
+
+#include "nsNSSCleaner.h"
+NSSCleanupAutoPtrClass(CERTCertificate, CERT_DestroyCertificate)
+
+NS_IMPL_THREADSAFE_ISUPPORTS2(nsClientAuthRememberService, 
+                              nsIObserver,
+                              nsISupportsWeakReference)
+
+nsClientAuthRememberService::nsClientAuthRememberService()
+{
+  monitor = PR_NewMonitor();
+}
+
+nsClientAuthRememberService::~nsClientAuthRememberService()
+{
+  RemoveAllFromMemory();
+  if (monitor)
+    PR_DestroyMonitor(monitor);
+}
+
+nsresult
+nsClientAuthRememberService::Init()
+{
+  if (!mSettingsTable.Init())
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  nsCOMPtr<nsIProxyObjectManager> proxyman(do_GetService(NS_XPCOMPROXY_CONTRACTID));
+  if (!proxyman)
+    return NS_ERROR_FAILURE;
+
+  nsCOMPtr<nsIObserverService> observerService(do_GetService("@mozilla.org/observer-service;1"));
+  nsCOMPtr<nsIObserverService> proxiedObserver;
+
+  NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
+                       NS_GET_IID(nsIObserverService),
+                       observerService,
+                       NS_PROXY_SYNC,
+                       getter_AddRefs(proxiedObserver));
+
+  if (proxiedObserver) {
+    proxiedObserver->AddObserver(this, "profile-before-change", PR_TRUE);
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsClientAuthRememberService::Observe(nsISupports     *aSubject,
+                               const char      *aTopic,
+                               const PRUnichar *aData)
+{
+  // check the topic
+  if (!nsCRT::strcmp(aTopic, "profile-before-change")) {
+    // The profile is about to change,
+    // or is going away because the application is shutting down.
+
+    nsAutoMonitor lock(monitor);
+    RemoveAllFromMemory();
+  }
+
+  return NS_OK;
+}
+
+void nsClientAuthRememberService::ClearRememberedDecisions()
+{
+  nsAutoMonitor lock(monitor);
+  RemoveAllFromMemory();
+}
+
+void
+nsClientAuthRememberService::RemoveAllFromMemory()
+{
+  mSettingsTable.Clear();
+}
+
+static nsresult
+GetCertFingerprintByOidTag(CERTCertificate* nsscert,
+                           SECOidTag aOidTag, 
+                           nsCString &fp)
+{
+  unsigned int hash_len = HASH_ResultLenByOidTag(aOidTag);
+  nsRefPtr<nsStringBuffer> fingerprint = nsStringBuffer::Alloc(hash_len);
+  if (!fingerprint)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  PK11_HashBuf(aOidTag, (unsigned char*)fingerprint->Data(), 
+               nsscert->derCert.data, nsscert->derCert.len);
+
+  SECItem fpItem;
+  fpItem.data = (unsigned char*)fingerprint->Data();
+  fpItem.len = hash_len;
+
+  fp.Adopt(CERT_Hexify(&fpItem, 1));
+  return NS_OK;
+}
+
+nsresult
+nsClientAuthRememberService::RememberDecision(const nsACString & aHostName, 
+                                              CERTCertificate *aServerCert, CERTCertificate *aClientCert)
+{
+  // aClientCert == NULL means: remember that user does not want to use a cert
+  NS_ENSURE_ARG_POINTER(aServerCert);
+  if (aHostName.IsEmpty())
+    return NS_ERROR_INVALID_ARG;
+
+  nsCAutoString fpStr;
+  nsresult rv = GetCertFingerprintByOidTag(aServerCert, SEC_OID_SHA256, fpStr);
+  if (NS_FAILED(rv))
+    return rv;
+
+  {
+    nsAutoMonitor lock(monitor);
+    if (aClientCert) {
+      nsNSSCertificate pipCert(aClientCert);
+      char *dbkey = NULL;
+      rv = pipCert.GetDbKey(&dbkey);
+      if (NS_SUCCEEDED(rv) && dbkey) {
+        AddEntryToList(aHostName, fpStr, 
+                       nsDependentCString(dbkey));
+      }
+      if (dbkey) {
+        PORT_Free(dbkey);
+      }
+    }
+    else {
+      nsCString empty;
+      AddEntryToList(aHostName, fpStr, empty);
+    }
+  }
+
+  return NS_OK;
+}
+
+nsresult
+nsClientAuthRememberService::HasRememberedDecision(const nsACString & aHostName, 
+                                                   CERTCertificate *aCert, 
+                                                   nsACString & aCertDBKey,
+                                                   PRBool *_retval)
+{
+  if (aHostName.IsEmpty())
+    return NS_ERROR_INVALID_ARG;
+
+  NS_ENSURE_ARG_POINTER(aCert);
+  NS_ENSURE_ARG_POINTER(_retval);
+  *_retval = PR_FALSE;
+
+  nsresult rv;
+  nsCAutoString fpStr;
+  rv = GetCertFingerprintByOidTag(aCert, SEC_OID_SHA256, fpStr);
+  if (NS_FAILED(rv))
+    return rv;
+
+  nsCAutoString hostCert;
+  GetHostWithCert(aHostName, fpStr, hostCert);
+  nsClientAuthRemember settings;
+
+  {
+    nsAutoMonitor lock(monitor);
+    nsClientAuthRememberEntry *entry = mSettingsTable.GetEntry(hostCert.get());
+    if (!entry)
+      return NS_OK;
+    settings = entry->mSettings; // copy
+  }
+
+  aCertDBKey = settings.mDBKey;
+  *_retval = PR_TRUE;
+  return NS_OK;
+}
+
+nsresult
+nsClientAuthRememberService::AddEntryToList(const nsACString &aHostName, 
+                                      const nsACString &fingerprint,
+                                      const nsACString &db_key)
+
+{
+  nsCAutoString hostCert;
+  GetHostWithCert(aHostName, fingerprint, hostCert);
+
+  {
+    nsAutoMonitor lock(monitor);
+    nsClientAuthRememberEntry *entry = mSettingsTable.PutEntry(hostCert.get());
+
+    if (!entry) {
+      NS_ERROR("can't insert a null entry!");
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    entry->mHostWithCert = hostCert;
+
+    nsClientAuthRemember &settings = entry->mSettings;
+    settings.mAsciiHost = aHostName;
+    settings.mFingerprint = fingerprint;
+    settings.mDBKey = db_key;
+  }
+
+  return NS_OK;
+}
+
+void
+nsClientAuthRememberService::GetHostWithCert(const nsACString & aHostName, 
+                                             const nsACString & fingerprint, 
+                                             nsACString& _retval)
+{
+  nsCAutoString hostCert(aHostName);
+  hostCert.AppendLiteral(":");
+  hostCert.Append(fingerprint);
+  
+  _retval.Assign(hostCert);
+}
diff --git a/security/manager/ssl/src/nsClientAuthRemember.h b/security/manager/ssl/src/nsClientAuthRemember.h
new file mode 100644
--- /dev/null
+++ b/security/manager/ssl/src/nsClientAuthRemember.h
@@ -0,0 +1,175 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Red Hat, Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Kai Engert <kengert@redhat.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NSCLIENTAUTHREMEMBER_H__
+#define __NSCLIENTAUTHREMEMBER_H__
+
+#include "nsTHashtable.h"
+#include "nsIObserver.h"
+#include "nsIX509Cert.h"
+#include "nsAutoPtr.h"
+#include "nsNSSCertificate.h"
+#include "nsString.h"
+#include "nsWeakReference.h"
+#include "prmon.h"
+
+class nsClientAuthRemember
+{
+public:
+
+  nsClientAuthRemember()
+  {
+  }
+  
+  nsClientAuthRemember(const nsClientAuthRemember &other)
+  {
+    this->operator=(other);
+  }
+
+  nsClientAuthRemember &operator=(const nsClientAuthRemember &other)
+  {
+    mAsciiHost = other.mAsciiHost;
+    mFingerprint = other.mFingerprint;
+    mDBKey = other.mDBKey;
+    return *this;
+  }
+
+  nsCString mAsciiHost;
+  nsCString mFingerprint;
+  nsCString mDBKey;
+};
+
+
+// hash entry class
+class nsClientAuthRememberEntry : public PLDHashEntryHdr
+{
+  public:
+    // Hash methods
+    typedef const char* KeyType;
+    typedef const char* KeyTypePointer;
+
+    // do nothing with aHost - we require mHead to be set before we're live!
+    nsClientAuthRememberEntry(KeyTypePointer aHostWithCertUTF8)
+    {
+    }
+
+    nsClientAuthRememberEntry(const nsClientAuthRememberEntry& toCopy)
+    {
+      mSettings = toCopy.mSettings;
+    }
+
+    ~nsClientAuthRememberEntry()
+    {
+    }
+
+    KeyType GetKey() const
+    {
+      return HostWithCertPtr();
+    }
+
+    KeyTypePointer GetKeyPointer() const
+    {
+      return HostWithCertPtr();
+    }
+
+    PRBool KeyEquals(KeyTypePointer aKey) const
+    {
+      return !strcmp(HostWithCertPtr(), aKey);
+    }
+
+    static KeyTypePointer KeyToPointer(KeyType aKey)
+    {
+      return aKey;
+    }
+
+    static PLDHashNumber HashKey(KeyTypePointer aKey)
+    {
+      // PL_DHashStringKey doesn't use the table parameter, so we can safely
+      // pass nsnull
+      return PL_DHashStringKey(nsnull, aKey);
+    }
+
+    enum { ALLOW_MEMMOVE = PR_FALSE };
+
+    // get methods
+    inline const nsCString &HostWithCert() const { return mHostWithCert; }
+
+    inline KeyTypePointer HostWithCertPtr() const
+    {
+      return mHostWithCert.get();
+    }
+
+    nsClientAuthRemember mSettings;
+    nsCString mHostWithCert;
+};
+
+class nsClientAuthRememberService : public nsIObserver,
+                                    public nsSupportsWeakReference
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIOBSERVER
+
+  nsClientAuthRememberService();
+  ~nsClientAuthRememberService();
+
+  nsresult Init();
+
+  static void GetHostWithCert(const nsACString & aHostName, 
+                              const nsACString & nickname, nsACString& _retval);
+
+  nsresult RememberDecision(const nsACString & aHostName, 
+                            CERTCertificate *aServerCert, CERTCertificate *aClientCert);
+  nsresult HasRememberedDecision(const nsACString & aHostName, 
+                                 CERTCertificate *aServerCert, 
+                                 nsACString & aCertDBKey, PRBool *_retval);
+
+  void ClearRememberedDecisions();
+
+protected:
+    PRMonitor *monitor;
+    nsTHashtable<nsClientAuthRememberEntry> mSettingsTable;
+
+    void RemoveAllFromMemory();
+    nsresult AddEntryToList(const nsACString &host, 
+                            const nsACString &server_fingerprint,
+                            const nsACString &db_key);
+};
+
+#endif
diff --git a/security/manager/ssl/src/nsNSSComponent.cpp b/security/manager/ssl/src/nsNSSComponent.cpp
--- a/security/manager/ssl/src/nsNSSComponent.cpp
+++ b/security/manager/ssl/src/nsNSSComponent.cpp
@@ -1735,20 +1735,23 @@ nsNSSComponent::ShutdownNSS()
     mHttpForNSS.unregisterHttpClient();
     UnregisterMyOCSPAIAInfoCallback();
 
     if (mPrefBranch) {
       nsCOMPtr<nsIPrefBranch2> pbi = do_QueryInterface(mPrefBranch);
       pbi->RemoveObserver("security.", this);
     }
 
     ShutdownSmartCardThreads();
     SSL_ClearSessionCache();
+    if (mClientAuthRememberService) {
+      mClientAuthRememberService->ClearRememberedDecisions();
+    }
     UnloadLoadableRoots();
     CleanupIdentityInfo();
     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("evaporating psm resources\n"));
     mShutdownObjectList->evaporateAllNSSResources();
     if (SECSuccess != ::NSS_Shutdown()) {
       PR_LOG(gPIPNSSLog, PR_LOG_ALWAYS, ("NSS SHUTDOWN FAILURE\n"));
       rv = NS_ERROR_FAILURE;
     }
     else {
       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NSS shutdown =====>> OK <<=====\n"));
@@ -1805,20 +1808,24 @@ nsNSSComponent::Init()
   if (NS_FAILED(rv)) {
     PR_LOG(gPIPNSSLog, PR_LOG_ERROR, ("Unable to Initialize NSS.\n"));
 
     DeregisterObservers();
     mPIPNSSBundle = nsnull;
     return rv;
   }
 
   nsSSLIOLayerHelpers::Init();
 
+  mClientAuthRememberService = new nsClientAuthRememberService;
+  if (mClientAuthRememberService)
+    mClientAuthRememberService->Init();
+
   mSSLThread = new nsSSLThread();
   if (mSSLThread)
     mSSLThread->startThread();
   mCertVerificationThread = new nsCertVerificationThread();
   if (mCertVerificationThread)
     mCertVerificationThread->startThread();
 
   if (!mSSLThread || !mCertVerificationThread)
   {
     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NSS init, could not create threads\n"));
@@ -2223,20 +2230,24 @@ nsresult nsNSSComponent::LogoutAuthentic
   nsCOMPtr<nsICertOverrideService> icos = 
     do_GetService("@mozilla.org/security/certoverride;1");
     
   nsCertOverrideService *cos = 
     reinterpret_cast<nsCertOverrideService*>(icos.get());
 
   if (cos) {
     cos->RemoveAllTemporaryOverrides();
   }
 
+  if (mClientAuthRememberService) {
+    mClientAuthRememberService->ClearRememberedDecisions();
+  }
+
   return mShutdownObjectList->doPK11Logout();
 }
 
 nsresult
 nsNSSComponent::RegisterObservers()
 {
   // Happens once during init only, no mutex protection.
 
   nsCOMPtr<nsIObserverService> observerService(do_GetService("@mozilla.org/observer-service;1"));
   NS_ASSERTION(observerService, "could not get observer service");
@@ -2508,20 +2519,28 @@ nsNSSComponent::DoProfileChangeNetRestor
   mSSLThread = new nsSSLThread();
   if (mSSLThread)
     mSSLThread->startThread();
   delete mCertVerificationThread;
   mCertVerificationThread = new nsCertVerificationThread();
   if (mCertVerificationThread)
     mCertVerificationThread->startThread();
   mIsNetworkDown = PR_FALSE;
 }
 
+NS_IMETHODIMP
+nsNSSComponent::GetClientAuthRememberService(nsClientAuthRememberService **cars)
+{
+  NS_ENSURE_ARG_POINTER(cars);
+  NS_IF_ADDREF(*cars = mClientAuthRememberService);
+  return NS_OK;
+}
+
 //---------------------------------------------
 // Implementing nsICryptoHash
 //---------------------------------------------
 
 nsCryptoHash::nsCryptoHash()
   : mHashContext(nsnull)
 {
 }
 
 nsCryptoHash::~nsCryptoHash()
@@ -3277,11 +3296,10 @@ PSMContentListener::GetParentContentList
   NS_IF_ADDREF(*aContentListener);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 PSMContentListener::SetParentContentListener(nsIURIContentListener * aContentListener)
 {
   mParentContentListener = aContentListener;
   return NS_OK;
 }
-
diff --git a/security/manager/ssl/src/nsNSSComponent.h b/security/manager/ssl/src/nsNSSComponent.h
--- a/security/manager/ssl/src/nsNSSComponent.h
+++ b/security/manager/ssl/src/nsNSSComponent.h
@@ -62,20 +62,21 @@
 #include "nsITimer.h"
 #include "nsNetUtil.h"
 #include "nsHashtable.h"
 #include "prlock.h"
 #include "nsICryptoHash.h"
 #include "nsICryptoHMAC.h"
 #include "hasht.h"
 #include "nsNSSCallbacks.h"
 
 #include "nsNSSHelper.h"
+#include "nsClientAuthRemember.h"
 
 #define NS_NSSCOMPONENT_CID \
 {0xa277189c, 0x1dd1, 0x11b2, {0xa8, 0xc9, 0xe4, 0xe8, 0xbf, 0xb1, 0x33, 0x8e}}
 
 #define PSM_COMPONENT_CONTRACTID "@mozilla.org/psm;1"
 #define PSM_COMPONENT_CLASSNAME "Mozilla PSM Component"
 
 //Define an interface that we can use to look up from the
 //callbacks passed to NSS.
 
@@ -175,20 +176,22 @@ class NS_NO_VTABLE nsINSSComponent : pub
   NS_IMETHOD LogoutAuthenticatedPK11() = 0;
 
   NS_IMETHOD LaunchSmartCardThread(SECMODModule *module) = 0;
 
   NS_IMETHOD ShutdownSmartCardThread(SECMODModule *module) = 0;
 
   NS_IMETHOD PostEvent(const nsAString &eventType, const nsAString &token) = 0;
 
   NS_IMETHOD DispatchEvent(const nsAString &eventType, const nsAString &token) = 0;
   
+  NS_IMETHOD GetClientAuthRememberService(nsClientAuthRememberService **cars) = 0;
+
   NS_IMETHOD EnsureIdentityInfoLoaded() = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsINSSComponent, NS_INSSCOMPONENT_IID)
 
 class nsCryptoHash : public nsICryptoHash
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSICRYPTOHASH
@@ -263,20 +266,21 @@ public:
   NS_IMETHOD DefineNextTimer();
   NS_IMETHOD LogoutAuthenticatedPK11();
   NS_IMETHOD DownloadCRLDirectly(nsAutoString, nsAutoString);
   NS_IMETHOD RememberCert(CERTCertificate *cert);
   static nsresult GetNSSCipherIDFromPrefString(const nsACString &aPrefString, PRUint16 &aCipherId);
 
   NS_IMETHOD LaunchSmartCardThread(SECMODModule *module);
   NS_IMETHOD ShutdownSmartCardThread(SECMODModule *module);
   NS_IMETHOD PostEvent(const nsAString &eventType, const nsAString &token);
   NS_IMETHOD DispatchEvent(const nsAString &eventType, const nsAString &token);
+  NS_IMETHOD GetClientAuthRememberService(nsClientAuthRememberService **cars);
   NS_IMETHOD EnsureIdentityInfoLoaded();
 
 private:
 
   nsresult InitializeNSS(PRBool showWarningBox);
   nsresult ShutdownNSS();
 
 #ifdef XP_MACOSX
   void TryCFM2MachOMigration(nsIFile *cfmPath, nsIFile *machoPath);
 #endif
@@ -329,20 +333,21 @@ private:
   nsHashtable *crlsScheduledForDownload;
   PRBool crlDownloadTimerOn;
   PRBool mUpdateTimerInitialized;
   static int mInstanceCount;
   nsNSSShutDownList *mShutdownObjectList;
   SmartCardThreadList *mThreadList;
   PRBool mIsNetworkDown;
   nsSSLThread *mSSLThread;
   nsCertVerificationThread *mCertVerificationThread;
   nsNSSHttpInterface mHttpForNSS;
+  nsRefPtr<nsClientAuthRememberService> mClientAuthRememberService;
 
   static PRStatus PR_CALLBACK IdentityInfoInit(void);
   PRCallOnceType mIdentityInfoCallOnce;
 };
 
 class PSMContentListener : public nsIURIContentListener,
                             public nsSupportsWeakReference {
 public:
   PSMContentListener();
   virtual ~PSMContentListener();
diff --git a/security/manager/ssl/src/nsNSSIOLayer.cpp b/security/manager/ssl/src/nsNSSIOLayer.cpp
--- a/security/manager/ssl/src/nsNSSIOLayer.cpp
+++ b/security/manager/ssl/src/nsNSSIOLayer.cpp
@@ -51,20 +51,21 @@
 #include "nsIServiceManager.h"
 #include "nsIWebProgressListener.h"
 #include "nsIChannel.h"
 #include "nsNSSCertificate.h"
 #include "nsIX509CertValidity.h"
 #include "nsIProxyObjectManager.h"
 #include "nsProxiedService.h"
 #include "nsIDateTimeFormat.h"
 #include "nsDateTimeFormatCID.h"
 #include "nsIClientAuthDialogs.h"
+#include "nsClientAuthRemember.h"
 #include "nsICertOverrideService.h"
 #include "nsIBadCertListener2.h"
 #include "nsISSLErrorListener.h"
 #include "nsIObjectInputStream.h"
 #include "nsIObjectOutputStream.h"
 #include "nsRecentBadCerts.h"
 #include "nsISSLCertErrorDialog.h"
 
 #include "nsXPIDLString.h"
 #include "nsReadableUtils.h"
@@ -232,29 +233,30 @@ nsNSSSocketInfo::~nsNSSSocketInfo()
   if (isAlreadyShutDown())
     return;
 
   shutdown(calledFromObject);
 }
 
 void nsNSSSocketInfo::virtualDestroyNSSReference()
 {
 }
 
-NS_IMPL_THREADSAFE_ISUPPORTS8(nsNSSSocketInfo,
+NS_IMPL_THREADSAFE_ISUPPORTS9(nsNSSSocketInfo,
                               nsITransportSecurityInfo,
                               nsISSLSocketControl,
                               nsIInterfaceRequestor,
                               nsISSLStatusProvider,
                               nsIIdentityInfo,
                               nsIAssociatedContentSecurity,
                               nsISerializable,
-                              nsIClassInfo)
+                              nsIClassInfo,
+                              nsIClientAuthUserDecision)
 
 nsresult
 nsNSSSocketInfo::GetHandshakePending(PRBool *aHandshakePending)
 {
   *aHandshakePending = mHandshakePending;
   return NS_OK;
 }
 
 nsresult
 nsNSSSocketInfo::SetHandshakePending(PRBool aHandshakePending)
@@ -294,20 +296,33 @@ nsNSSSocketInfo::GetPort(PRInt32 *aPort)
 void nsNSSSocketInfo::SetCanceled(PRBool aCanceled)
 {
   mCanceled = aCanceled;
 }
 
 PRBool nsNSSSocketInfo::GetCanceled()
 {
   return mCanceled;
 }
 
+NS_IMETHODIMP nsNSSSocketInfo::GetRememberClientAuthCertificate(PRBool *aRememberClientAuthCertificate)
+{
+  NS_ENSURE_ARG_POINTER(aRememberClientAuthCertificate);
+  *aRememberClientAuthCertificate = mRememberClientAuthCertificate;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsNSSSocketInfo::SetRememberClientAuthCertificate(PRBool aRememberClientAuthCertificate)
+{
+  mRememberClientAuthCertificate = aRememberClientAuthCertificate;
+  return NS_OK;
+}
+
 void nsNSSSocketInfo::SetHasCleartextPhase(PRBool aHasCleartextPhase)
 {
   mHasCleartextPhase = aHasCleartextPhase;
 }
 
 PRBool nsNSSSocketInfo::GetHasCleartextPhase()
 {
   return mHasCleartextPhase;
 }
 
@@ -2604,26 +2619,24 @@ static PRBool hasExplicitKeyUsageNonRepu
  * - returns: SECSuccess if successful; error code otherwise
  */
 SECStatus nsNSS_SSLGetClientAuthData(void* arg, PRFileDesc* socket,
 								   CERTDistNames* caNames,
 								   CERTCertificate** pRetCert,
 								   SECKEYPrivateKey** pRetKey)
 {
   nsNSSShutDownPreventionLock locker;
   void* wincx = NULL;
   SECStatus ret = SECFailure;
-  nsresult rv;
   nsNSSSocketInfo* info = NULL;
   PRArenaPool* arena = NULL;
   char** caNameStrings;
   CERTCertificate* cert = NULL;
-  CERTCertificate* serverCert = NULL;
   SECKEYPrivateKey* privKey = NULL;
   CERTCertList* certList = NULL;
   CERTCertListNode* node;
   CERTCertNicknames* nicknames = NULL;
   char* extracted = NULL;
   PRIntn keyError = 0; /* used for private key retrieval error */
   SSM_UserCertChoice certChoice;
   PRInt32 NumberOfCerts = 0;
 	
   /* do some argument checking */
@@ -2733,27 +2746,103 @@ SECStatus nsNSS_SSLGetClientAuthData(voi
     if (!cert && low_prio_nonrep_cert) {
       cert = low_prio_nonrep_cert;
       low_prio_nonrep_cert = NULL; // take it away from the cleaner
       privKey = PK11_FindKeyByAnyCert(cert, wincx);
     }
 
     if (cert == NULL) {
         goto noCert;
     }
   }
-  else {
+  else { // Not Auto => ask
+    /* Get the SSL Certificate */
+    CERTCertificate* serverCert = NULL;
+    CERTCertificateCleaner serverCertCleaner(serverCert);
+    serverCert = SSL_PeerCertificate(socket);
+    if (serverCert == NULL) {
+      /* couldn't get the server cert: what do I do? */
+      goto loser;
+    }
+
+    nsXPIDLCString hostname;
+    info->GetHostName(getter_Copies(hostname));
+
+    nsresult rv;
+    NS_DEFINE_CID(nssComponentCID, NS_NSSCOMPONENT_CID);
+    nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(nssComponentCID, &rv));
+    nsRefPtr<nsClientAuthRememberService> cars;
+    if (nssComponent) {
+      nssComponent->GetClientAuthRememberService(getter_AddRefs(cars));
+    }
+
+    PRBool hasRemembered = PR_FALSE;
+    nsCString rememberedDBKey;
+    if (cars) {
+      PRBool found;
+      nsresult rv = cars->HasRememberedDecision(hostname, 
+                                                serverCert,
+                                                rememberedDBKey, &found);
+      if (NS_SUCCEEDED(rv) && found) {
+        hasRemembered = PR_TRUE;
+      }
+    }
+
+    PRBool canceled = PR_FALSE;
+
+if (hasRemembered)
+{
+    if (rememberedDBKey.IsEmpty())
+    {
+      canceled = PR_TRUE;
+    }
+    else
+    {
+      nsCOMPtr<nsIX509CertDB> certdb;
+      certdb = do_GetService(NS_X509CERTDB_CONTRACTID);
+      if (certdb)
+      {
+        nsCOMPtr<nsIX509Cert> found_cert;
+        nsresult find_rv = 
+          certdb->FindCertByDBKey(rememberedDBKey.get(), nsnull,
+                                  getter_AddRefs(found_cert));
+        if (NS_SUCCEEDED(find_rv) && found_cert) {
+          nsNSSCertificate *obj_cert = reinterpret_cast<nsNSSCertificate *>(found_cert.get());
+          if (obj_cert) {
+            cert = obj_cert->GetCert();
+
+#ifdef DEBUG_kaie
+            nsAutoString nick, nickWithSerial, details;
+            if (NS_SUCCEEDED(obj_cert->FormatUIStrings(nick, 
+                                                       nickWithSerial, 
+                                                       details))) {
+              NS_LossyConvertUTF16toASCII asc(nickWithSerial);
+              fprintf(stderr, "====> remembered serial %s\n", asc.get());
+            }
+#endif
+
+          }
+        }
+        
+        if (!cert) {
+          hasRemembered = PR_FALSE;
+        }
+      }
+    }
+}
+
+if (!hasRemembered)
+{
     /* user selects a cert to present */
     nsIClientAuthDialogs *dialogs = NULL;
     PRInt32 selectedIndex = -1;
     PRUnichar **certNicknameList = NULL;
     PRUnichar **certDetailsList = NULL;
-    PRBool canceled;
 
     /* find all user certs that are for SSL */
     /* note that we are allowing expired certs in this list */
     certList = CERT_FindUserCertsByUsage(CERT_GetDefaultCertDB(), 
                                          certUsageSSLClient, PR_FALSE, 
                                          PR_FALSE, wincx);
     if (certList == NULL) {
       goto noCert;
     }
 
@@ -2796,37 +2885,28 @@ SECStatus nsNSS_SSLGetClientAuthData(voi
     }
 
     nicknames = getNSSCertNicknamesFromCertList(certList);
 
     if (nicknames == NULL) {
       goto loser;
     }
 
     NS_ASSERTION(nicknames->numnicknames == NumberOfCerts, "nicknames->numnicknames != NumberOfCerts");
 
-    /* Get the SSL Certificate */
-    serverCert = SSL_PeerCertificate(socket);
-    if (serverCert == NULL) {
-      /* couldn't get the server cert: what do I do? */
-      goto loser;
-    }
-
     /* Get CN and O of the subject and O of the issuer */
     char *ccn = CERT_GetCommonName(&serverCert->subject);
     void *v = ccn;
     voidCleaner ccnCleaner(v);
     NS_ConvertUTF8toUTF16 cn(ccn);
 
     PRInt32 port;
     info->GetPort(&port);
-    char *hostname = SSL_RevealURL(socket);
-    charCleaner hostnameCleaner(hostname);
 
     nsString cn_host_port;
     if (ccn && strcmp(ccn, hostname) == 0) {
       cn_host_port.Append(cn);
       cn_host_port.AppendLiteral(":");
       cn_host_port.AppendInt(port);
     }
     else {
       cn_host_port.Append(cn);
       cn_host_port.AppendLiteral(" (");
@@ -2836,22 +2916,20 @@ SECStatus nsNSS_SSLGetClientAuthData(voi
     }
 
     char *corg = CERT_GetOrgName(&serverCert->subject);
     NS_ConvertUTF8toUTF16 org(corg);
     if (corg) PORT_Free(corg);
 
     char *cissuer = CERT_GetOrgName(&serverCert->issuer);
     NS_ConvertUTF8toUTF16 issuer(cissuer);
     if (cissuer) PORT_Free(cissuer);
 
-    CERT_DestroyCertificate(serverCert);
-
     certNicknameList = (PRUnichar **)nsMemory::Alloc(sizeof(PRUnichar *) * nicknames->numnicknames);
     if (!certNicknameList)
       goto loser;
     certDetailsList = (PRUnichar **)nsMemory::Alloc(sizeof(PRUnichar *) * nicknames->numnicknames);
     if (!certDetailsList) {
       nsMemory::Free(certNicknameList);
       goto loser;
     }
 
     PRInt32 CertsToUse;
@@ -2905,33 +2983,45 @@ SECStatus nsNSS_SSLGetClientAuthData(voi
           CertsToUse, &selectedIndex, &canceled);
       }
     }
 
     NS_RELEASE(dialogs);
     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(CertsToUse, certNicknameList);
     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(CertsToUse, certDetailsList);
     
     if (NS_FAILED(rv)) goto loser;
 
-    if (canceled) { rv = NS_ERROR_NOT_AVAILABLE; goto loser; }
+    // even if the user has canceled, we want to remember that, to avoid repeating prompts
+    PRBool wantRemember = PR_FALSE;
+    info->GetRememberClientAuthCertificate(&wantRemember);
 
     int i;
+    if (!canceled)
     for (i = 0, node = CERT_LIST_HEAD(certList);
          !CERT_LIST_END(node, certList);
          ++i, node = CERT_LIST_NEXT(node)) {
 
       if (i == selectedIndex) {
         cert = CERT_DupCertificate(node->cert);
         break;
       }
     }
 
+    if (cars && wantRemember) {
+      cars->RememberDecision(hostname, 
+                             serverCert, 
+                             canceled ? 0 : cert);
+    }
+}
+
+    if (canceled) { rv = NS_ERROR_NOT_AVAILABLE; goto loser; }
+
     if (cert == NULL) {
       goto loser;
     }
 
     /* go get the private key */
     privKey = PK11_FindKeyByAnyCert(cert, wincx);
     if (privKey == NULL) {
       keyError = PR_GetError();
       if (keyError == SEC_ERROR_BAD_PASSWORD) {
           /* problem with password: bail */
diff --git a/security/manager/ssl/src/nsNSSIOLayer.h b/security/manager/ssl/src/nsNSSIOLayer.h
--- a/security/manager/ssl/src/nsNSSIOLayer.h
+++ b/security/manager/ssl/src/nsNSSIOLayer.h
@@ -48,20 +48,21 @@
 #include "nsIInterfaceRequestor.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsITransportSecurityInfo.h"
 #include "nsISSLSocketControl.h"
 #include "nsSSLStatus.h"
 #include "nsISSLStatusProvider.h"
 #include "nsIIdentityInfo.h"
 #include "nsIAssociatedContentSecurity.h"
 #include "nsXPIDLString.h"
 #include "nsNSSShutDown.h"
+#include "nsIClientAuthDialogs.h"
 #include "nsAutoPtr.h"
 #include "nsNSSCertificate.h"
 #include "nsDataHashtable.h"
 
 class nsIChannel;
 class nsSSLThread;
 
 /*
  * This class is used to store SSL socket I/O state information,
  * that is not being executed directly, but defered to 
@@ -126,36 +127,38 @@ public:
 };
 
 class nsNSSSocketInfo : public nsITransportSecurityInfo,
                         public nsISSLSocketControl,
                         public nsIInterfaceRequestor,
                         public nsISSLStatusProvider,
                         public nsIIdentityInfo,
                         public nsIAssociatedContentSecurity,
                         public nsISerializable,
                         public nsIClassInfo,
+                        public nsIClientAuthUserDecision,
                         public nsNSSShutDownObject,
                         public nsOnPK11LogoutCancelObject
 {
 public:
   nsNSSSocketInfo();
   virtual ~nsNSSSocketInfo();
   
   NS_DECL_ISUPPORTS
   NS_DECL_NSITRANSPORTSECURITYINFO
   NS_DECL_NSISSLSOCKETCONTROL
   NS_DECL_NSIINTERFACEREQUESTOR
   NS_DECL_NSISSLSTATUSPROVIDER
   NS_DECL_NSIIDENTITYINFO
   NS_DECL_NSIASSOCIATEDCONTENTSECURITY
   NS_DECL_NSISERIALIZABLE
   NS_DECL_NSICLASSINFO
+  NS_DECL_NSICLIENTAUTHUSERDECISION
 
   nsresult SetSecurityState(PRUint32 aState);
   nsresult SetShortSecurityDescription(const PRUnichar *aText);
   nsresult SetErrorMessage(const PRUnichar *aText);
 
   nsresult SetForSTARTTLS(PRBool aForSTARTTLS);
   nsresult GetForSTARTTLS(PRBool *aForSTARTTLS);
 
   nsresult GetFileDescPtr(PRFileDesc** aFilePtr);
   nsresult SetFileDescPtr(PRFileDesc* aFilePtr);
@@ -214,20 +217,21 @@ protected:
   nsString mShortDesc;
   nsString mErrorMessage;
   PRPackedBool mDocShellDependentStuffKnown;
   PRPackedBool mExternalErrorReporting; // DocShellDependent
   PRPackedBool mForSTARTTLS;
   PRPackedBool mHandshakePending;
   PRPackedBool mCanceled;
   PRPackedBool mHasCleartextPhase;
   PRPackedBool mHandshakeInProgress;
   PRPackedBool mAllowTLSIntoleranceTimeout;
+  PRPackedBool mRememberClientAuthCertificate;
   PRIntervalTime mHandshakeStartTime;
   PRInt32 mPort;
   nsXPIDLCString mHostName;
 
   /* SSL Status */
   nsRefPtr<nsSSLStatus> mSSLStatus;
 
   nsresult ActivateSSL();
 
   nsSSLSocketThreadData *mThreadData;
