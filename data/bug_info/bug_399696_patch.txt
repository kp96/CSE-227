Index: mozilla/security/manager/locales/en-US/chrome/pipnss/pipnss.properties
===================================================================
RCS file: /cvsroot/mozilla/security/manager/locales/en-US/chrome/pipnss/pipnss.properties,v
retrieving revision 1.29
diff -u -1 -0 -p -r1.29 pipnss.properties
--- mozilla/security/manager/locales/en-US/chrome/pipnss/pipnss.properties	30 Oct 2007 20:26:26 -0000	1.29
+++ mozilla/security/manager/locales/en-US/chrome/pipnss/pipnss.properties	31 Oct 2007 19:14:34 -0000
@@ -392,10 +392,12 @@ CertNoNickname=(no nickname)
 CertNoEmailAddress=(no email address)
 NicknameExpired=(expired)
 NicknameNotYetValid=(not yet valid)
 CaCertExists=This certificate is already installed as a certificate authority.
 NotACACert=This is not a certificate authority certificate, so it can't be imported into the certificate authority list.
 NotImportingUnverifiedCert=This certificate can't be verified and will not be imported. The certificate issuer might be unknown or untrusted, the certificate might have expired or been revoked, or the certificate might not have been approved.
 UserCertIgnoredNoPrivateKey=This personal certificate can't be installed because you do not own the corresponding private key which was created when the certificate was requested.
 UserCertImported=Your personal certificate has been installed. You should keep a backup copy of this certificate.
 CertOrgUnknown=(Unknown)
 CertNotStored=(Not Stored)
+CertExceptionPermanent=Permanent
+CertExceptionTemporary=Temporary
Index: mozilla/security/manager/locales/en-US/chrome/pippki/certManager.dtd
===================================================================
RCS file: /cvsroot/mozilla/security/manager/locales/en-US/chrome/pippki/certManager.dtd,v
retrieving revision 1.15
diff -u -1 -0 -p -r1.15 certManager.dtd
--- mozilla/security/manager/locales/en-US/chrome/pippki/certManager.dtd	19 Oct 2007 19:13:23 -0000	1.15
+++ mozilla/security/manager/locales/en-US/chrome/pippki/certManager.dtd	31 Oct 2007 19:14:34 -0000
@@ -88,20 +88,21 @@
 <!ENTITY certmgr.deletecert.title             "Delete Certificate">
 <!ENTITY certmgr.deletecert.beforename        "You have requested to delete this certificate:">
 <!ENTITY certmgr.deletecert.aftername         "Are you sure you want to delete this certificate?">
 <!ENTITY certmgr.deleteusercert.title         "Delete Your Certificate">
 <!ENTITY certmgr.deleteusercert.beforename    "You have requested to delete the certificate:">
 <!ENTITY certmgr.deleteusercert.aftername     "Once you have deleted this certificate, you will not be able to read mail that has been encrypted with it.">
 
 <!ENTITY certmgr.certname                     "Certificate Name">
 <!ENTITY certmgr.certsite                     "Site">
 <!ENTITY certmgr.typesofoverrides             "Exceptions">
+<!ENTITY certmgr.override_lifetime            "Lifetime">
 <!ENTITY certmgr.tokenname                    "Security Device">
 <!ENTITY certmgr.purpose                      "Purposes">
 <!ENTITY certmgr.issued                       "Issued On">
 <!ENTITY certmgr.expires                      "Expires On">
 <!ENTITY certmgr.email                        "E-Mail Address">
 <!ENTITY certmgr.serial                       "Serial Number">
 
 <!ENTITY certmgr.close.label                  "Close">
 <!ENTITY certmgr.close.accesskey              "C">
 <!ENTITY certmgr.view2.label                   "View…">
@@ -135,10 +136,12 @@
 <!ENTITY exceptionMgr.exceptionButton         "Confirm Security Exception">
 <!ENTITY exceptionMgr.exceptionButtonAccess   "C">
 <!ENTITY exceptionMgr.supplementalWarning     "Legitimate banks, stores, and other public sites will not ask you to do this.">
 <!ENTITY exceptionMgr.certlocation.caption2   "Server">
 <!ENTITY exceptionMgr.certlocation.url        "Location:">
 <!ENTITY exceptionMgr.certlocation.download   "Get Certificate">
 <!ENTITY exceptionMgr.certlocation.accesskey  "G">
 <!ENTITY exceptionMgr.certstatus.caption      "Certificate Status">
 <!ENTITY exceptionMgr.certstatus.viewCert     "View…">
 <!ENTITY exceptionMgr.certstatus.accesskey    "V">
+<!ENTITY exceptionMgr.permanent.label         "Permanently store this exception">
+<!ENTITY exceptionMgr.permanent.accesskey     "P">
Index: mozilla/security/manager/pki/resources/content/WebSitesOverlay.xul
===================================================================
RCS file: /cvsroot/mozilla/security/manager/pki/resources/content/WebSitesOverlay.xul,v
retrieving revision 1.31
diff -u -1 -0 -p -r1.31 WebSitesOverlay.xul
--- mozilla/security/manager/pki/resources/content/WebSitesOverlay.xul	19 Oct 2007 19:13:24 -0000	1.31
+++ mozilla/security/manager/pki/resources/content/WebSitesOverlay.xul	31 Oct 2007 19:14:34 -0000
@@ -52,20 +52,23 @@
     <separator class="thin"/>
     <tree id="server-tree" flex="1" enableColumnDrag="true"
               onselect="websites_enableButtons()">
       <treecols>
         <treecol id="certcol" label="&certmgr.certname;" primary="true" 
                      persist="hidden width ordinal" flex="1"/>
         <splitter class="tree-splitter"/>
         <treecol id="sitecol" label="&certmgr.certsite;" 
                  persist="hidden width ordinal" flex="1"/>
         <splitter class="tree-splitter"/>
+        <treecol id="lifetimecol" label="&certmgr.override_lifetime;" 
+                 persist="hidden width ordinal" flex="1"/>
+        <splitter class="tree-splitter"/>
 <!-- this is too geeky, leave out for now
         <treecol id="overridetypecol" label="&certmgr.typesofoverrides;" 
                  persist="hidden width ordinal" flex="1"/>
         <splitter class="tree-splitter"/>
 -->
 <!-- disable the purposes column until we get a solution
      to fill in this information that is compatible with OCSP
      and does not block the whole interface
         <treecol id="purposecol" label="&certmgr.purpose;"
                      persist="hidden width ordinal" flex="1"/>
Index: mozilla/security/manager/pki/resources/content/exceptionDialog.js
===================================================================
RCS file: /cvsroot/mozilla/security/manager/pki/resources/content/exceptionDialog.js,v
retrieving revision 1.4
diff -u -1 -0 -p -r1.4 exceptionDialog.js
--- mozilla/security/manager/pki/resources/content/exceptionDialog.js	19 Oct 2007 19:16:34 -0000	1.4
+++ mozilla/security/manager/pki/resources/content/exceptionDialog.js	31 Oct 2007 19:14:34 -0000
@@ -171,20 +171,21 @@ function getURI() {
     uri.scheme = "https";
 
   if (uri.port == -1)
     uri.port = 443;
 
   return uri;
 }
 
 function resetDialog() {
   document.getElementById("viewCertButton").disabled = true;
+  document.getElementById("permanent").disabled = true;
   gDialog.getButton("extra1").disabled = true;
   setText("headerDescription", "");
   setText("statusDescription", "");
   setText("statusLongDescription", "");
   setText("status2Description", "");
   setText("status2LongDescription", "");
   setText("status3Description", "");
   setText("status3LongDescription", "");
 }
 
@@ -245,41 +246,45 @@ function updateCertStatus() {
         } 
         else {
           use3 = true;
           shortDesc3 = uts;
           longDesc3  = utl;
         }
       }
       
       // In these cases, we do want to enable the "Add Exception" button
       gDialog.getButton("extra1").disabled = false;
+      document.getElementById("permanent").disabled = false;
       setText("headerDescription", gPKIBundle.GetStringFromName("addExceptionInvalidHeader"));
     }
     else {
       shortDesc = "addExceptionValidShort";
       longDesc  = "addExceptionValidLong";
       gDialog.getButton("extra1").disabled = true;
+      document.getElementById("permanent").disabled = true;
     }
     
     document.getElementById("viewCertButton").disabled = false;
   }
   else if (gChecking) {
     shortDesc = "addExceptionCheckingShort";
     longDesc  = "addExceptionCheckingLong";
     document.getElementById("viewCertButton").disabled = true;
     gDialog.getButton("extra1").disabled = true;
+    document.getElementById("permanent").disabled = true;
   }
   else {
     shortDesc = "addExceptionNoCertShort";
     longDesc  = "addExceptionNoCertLong";
     document.getElementById("viewCertButton").disabled = true;
     gDialog.getButton("extra1").disabled = true;
+    document.getElementById("permanent").disabled = true;
   }
   
   setText("statusDescription", gPKIBundle.GetStringFromName(shortDesc));
   setText("statusLongDescription", gPKIBundle.GetStringFromName(longDesc));
 
   if (use2) {
     setText("status2Description", gPKIBundle.GetStringFromName(shortDesc2));
     setText("status2LongDescription", gPKIBundle.GetStringFromName(longDesc2));
   }
 
@@ -309,17 +314,20 @@ function addException() {
 
   var overrideService = Components.classes["@mozilla.org/security/certoverride;1"]
                                   .getService(Components.interfaces.nsICertOverrideService);
   var flags = 0;
   if(gSSLStatus.isUntrusted)
     flags |= overrideService.ERROR_UNTRUSTED;
   if(gSSLStatus.isDomainMismatch)
     flags |= overrideService.ERROR_MISMATCH;
   if(gSSLStatus.isNotValidAtThisTime)
     flags |= overrideService.ERROR_TIME;
+
+  var permanentCheckbox = document.getElementById("permanent");
   
   overrideService.rememberValidityOverride(
     getURI().hostPort,
     gCert,
-    flags);
+    flags,
+    !permanentCheckbox.checked);
   gDialog.acceptDialog();
 }
Index: mozilla/security/manager/pki/resources/content/exceptionDialog.xul
===================================================================
RCS file: /cvsroot/mozilla/security/manager/pki/resources/content/exceptionDialog.xul,v
retrieving revision 1.4
diff -u -1 -0 -p -r1.4 exceptionDialog.xul
--- mozilla/security/manager/pki/resources/content/exceptionDialog.xul	22 Oct 2007 18:08:18 -0000	1.4
+++ mozilla/security/manager/pki/resources/content/exceptionDialog.xul	31 Oct 2007 19:14:34 -0000
@@ -101,12 +101,15 @@
     <description id="statusDescription"
                  style="font-weight: bold; padding-bottom: 1em;"/>
     <description id="statusLongDescription" style="white-space: -moz-pre-wrap;"/>
     <description id="status2Description"
                  style="font-weight: bold; padding-bottom: 1em;"/>
     <description id="status2LongDescription" style="white-space: -moz-pre-wrap;"/>
     <description id="status3Description" 
                  style="font-weight: bold; padding-bottom: 1em;"/>
     <description id="status3LongDescription" style="white-space: -moz-pre-wrap;"/>
     <spacer flex="1"/>
+    <checkbox id="permanent" checked="true" disabled="true"
+              label="&exceptionMgr.permanent.label;"
+              accesskey="&exceptionMgr.permanent.accesskey;"/>
   </groupbox>
 </dialog>
Index: mozilla/security/manager/ssl/public/nsICertOverrideService.idl
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/public/nsICertOverrideService.idl,v
retrieving revision 1.1
diff -u -1 -0 -p -r1.1 nsICertOverrideService.idl
--- mozilla/security/manager/ssl/public/nsICertOverrideService.idl	3 Oct 2007 11:43:54 -0000	1.1
+++ mozilla/security/manager/ssl/public/nsICertOverrideService.idl	31 Oct 2007 19:14:34 -0000
@@ -75,70 +75,75 @@ interface nsICertOverrideService : nsISu
    *  Host:Port is a primary key, only one entry per host:port can exist.
    *  The implementation will store a fingerprint of the cert.
    *  The implementation will decide which fingerprint alg is used.
    *
    *  @param aHostNameWithPort The host:port this mapping belongs to
    *  @param aCert The cert that should always be accepted
    *  @param aOverrideBits The errors we want to be overriden
    */
   void rememberValidityOverride(in AString aHostNameWithPort, 
                                 in nsIX509Cert aCert,
-                                in PRUint32 aOverrideBits);
+                                in PRUint32 aOverrideBits,
+                                in boolean aTemporary);
 
   /**
    *  The given cert should always be accepted for the given hostname:port,
    *  regardless of errors verifying the cert.
    *  Host:Port is a primary key, only one entry per host:port can exist.
    *  The implementation will store a fingerprint of the cert.
    *  The implementation will decide which fingerprint alg is used.
    *
    *  @param aHostNameWithPort The host:port this mapping belongs to
    *  @param aCert The cert that should always be accepted
    *  @param aOverrideBits The errors that are currently overriden
    *  @return whether an override entry for aHostNameWithPort is currently on file
    *          that matches the given certificate
    */
   boolean hasMatchingOverride(in AString aHostNameWithPort, 
                               in nsIX509Cert aCert,
-                              out PRUint32 aOverrideBits);
+                              out PRUint32 aOverrideBits,
+                              out boolean aIsTemporary);
 
   /**
    *  Retrieve the stored override for the given hostname:port.
    *
    *  @param aHostNameWithPort The host:port whose entry should be tested
    *  @param aHashAlg On return value True, the fingerprint hash algorithm
    *                  as an OID value in dotted notation.
    *  @param aFingerprint On return value True, the stored fingerprint 
    *  @param aOverrideBits The errors that are currently overriden
    *  @return whether a matching override entry for aHostNameWithPort 
    *          and aFingerprint is currently on file
    */
   boolean getValidityOverride(in AString aHostNameWithPort, 
                               out ACString aHashAlg,
                               out ACString aFingerprint,
-                              out PRUint32 aOverrideBits);
+                              out PRUint32 aOverrideBits,
+                              out boolean aIsTemporary);
 
   /**
-   *  Remove a stored override for the given hostname:port.
+   *  Remove a override for the given hostname:port.
    *
    *  @param aHostNameWithPort The host:port whose entry should be cleared.
    */
   void clearValidityOverride(in AString aHostNameWithPort);
 
   /**
-   *  Obtain the full list of hostname:port for which overrides are stored.
+   *  Obtain the full list of hostname:port for which overrides are known.
    *
    *  @param aCount The number of host:port entries returned
    *  @param aHostsWithPortsArray The array of host:port entries returned
    */
   void getAllOverrideHostsWithPorts(out PRUint32 aCount, 
                                     [array, size_is(aCount)] out wstring aHostsWithPortsArray);
 
   /**
    *  Is the given cert used in rules?
    *
    *  @param aCert The cert we're looking for
    *  @return how many override entries are currently on file
    *          for the given certificate
    */
-  PRUint32 isCertUsedForOverrides(in nsIX509Cert aCert);
+  PRUint32 isCertUsedForOverrides(in nsIX509Cert aCert,
+                                  in boolean aCheckTemporaries,
+                                  in boolean aCheckPermanents);
 };
Index: mozilla/security/manager/ssl/public/nsISSLStatus.idl
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/public/nsISSLStatus.idl,v
retrieving revision 1.5
diff -u -1 -0 -p -r1.5 nsISSLStatus.idl
--- mozilla/security/manager/ssl/public/nsISSLStatus.idl	3 Oct 2007 11:49:54 -0000	1.5
+++ mozilla/security/manager/ssl/public/nsISSLStatus.idl	31 Oct 2007 19:14:34 -0000
@@ -49,17 +49,14 @@ interface nsISSLStatus : nsISupports {
   readonly attribute unsigned long keyLength;
   readonly attribute unsigned long secretKeyLength;
 
   readonly attribute boolean isDomainMismatch;
   readonly attribute boolean isNotValidAtThisTime;
 
   /* Note: To distinguish between 
    *         "unstrusted because missing or untrusted issuer"
    *       and 
    *         "untrusted because self signed"
-   *       compare for equality of 
-   *         nsIX509Cert::subjectName
-   *       and
-   *         nsIX509Cert::issuerName
+   *       query nsIX509Cert3::isSelfSigned 
    */
   readonly attribute boolean isUntrusted;
 };
Index: mozilla/security/manager/ssl/src/nsCertOverrideService.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsCertOverrideService.cpp,v
retrieving revision 1.1
diff -u -1 -0 -p -r1.1 nsCertOverrideService.cpp
--- mozilla/security/manager/ssl/src/nsCertOverrideService.cpp	3 Oct 2007 11:43:56 -0000	1.1
+++ mozilla/security/manager/ssl/src/nsCertOverrideService.cpp	31 Oct 2007 19:14:34 -0000
@@ -261,40 +261,44 @@ nsCertOverrideService::Read()
 
     const nsASingleFragmentCString &host = Substring(buffer, hostIndex, algoIndex - hostIndex - 1);
     const nsASingleFragmentCString &algo_string = Substring(buffer, algoIndex, fingerprintIndex - algoIndex - 1);
     const nsASingleFragmentCString &fingerprint = Substring(buffer, fingerprintIndex, overrideBitsIndex - fingerprintIndex - 1);
     const nsASingleFragmentCString &bits_string = Substring(buffer, overrideBitsIndex, dbKeyIndex - overrideBitsIndex - 1);
     const nsASingleFragmentCString &db_key = Substring(buffer, dbKeyIndex, buffer.Length() - dbKeyIndex);
 
     nsCertOverride::OverrideBits bits;
     nsCertOverride::convertStringToBits(bits_string, bits);
 
-    AddEntryToList(host, algo_string, fingerprint, bits, db_key);
+    AddEntryToList(host, 
+                   PR_FALSE, // not temporary
+                   algo_string, fingerprint, bits, db_key);
   }
 
   return NS_OK;
 }
 
 PR_STATIC_CALLBACK(PLDHashOperator)
 WriteEntryCallback(nsCertOverrideEntry *aEntry,
                    void *aArg)
 {
   static const char kNew[] = "\n";
   static const char kTab[] = "\t";
 
   nsIOutputStream *rawStreamPtr = (nsIOutputStream *)aArg;
 
   nsresult rv;
 
   if (rawStreamPtr && aEntry)
   {
     const nsCertOverride &settings = aEntry->mSettings;
+    if (settings.mIsTemporary)
+      return PL_DHASH_NEXT;
 
     nsCAutoString bits_string;
     nsCertOverride::convertBitsToString(settings.mOverrideBits, 
                                             bits_string);
 
     rawStreamPtr->Write(settings.mHostWithPortUTF8.get(), settings.mHostWithPortUTF8.Length(), &rv);
     rawStreamPtr->Write(kTab, sizeof(kTab) - 1, &rv);
     rawStreamPtr->Write(settings.mFingerprintAlgOID.get(), 
                         settings.mFingerprintAlgOID.Length(), &rv);
     rawStreamPtr->Write(kTab, sizeof(kTab) - 1, &rv);
@@ -395,130 +399,29 @@ GetCertFingerprintByOidTag(nsIX509Cert *
     return NS_ERROR_FAILURE;
 
   CERTCertificate* nsscert = cert2->GetCert();
   if (!nsscert)
     return NS_ERROR_FAILURE;
 
   CERTCertificateCleaner nsscertCleaner(nsscert);
   return GetCertFingerprintByOidTag(nsscert, aOidTag, fp);
 }
 
-#include <string.h>
-#include "secitem.h"
-#include "secport.h"
-#include "secerr.h"
-
-// FIXME: This is a temporary copy of NSS function SEC_StringToOID,
-//        already available on NSS trunk, but not yet delivered to
-//        the client application. Remove this function and the include
-//        statements after a new tag landed with bug 397296.
-static SECStatus
-_psm_copy_SEC_StringToOID(PLArenaPool *pool, SECItem *to, const char *from, PRUint32 len)
-{
-    PRUint32 decimal_numbers = 0;
-    PRUint32 result_bytes = 0;
-    SECStatus rv;
-    PRUint8 result[1024];
-
-    static const PRUint32 max_decimal = (0xffffffff / 10);
-    static const char OIDstring[] = {"OID."};
-
-    if (!from || !to) {
-    	PORT_SetError(SEC_ERROR_INVALID_ARGS);
-	return SECFailure;
-    }
-    if (!len) {
-    	len = PL_strlen(from);
-    }
-    if (len >= 4 && !PL_strncasecmp(from, OIDstring, 4)) {
-    	from += 4; /* skip leading "OID." if present */
-	len  -= 4;
-    }
-    if (!len) {
-bad_data:
-    	PORT_SetError(SEC_ERROR_BAD_DATA);
-	return SECFailure;
-    }
-    do {
-	PRUint32 decimal = 0;
-        while (len > 0 && isdigit(*from)) {
-	    PRUint32 addend = (*from++ - '0');
-	    --len;
-	    if (decimal > max_decimal)  /* overflow */
-		goto bad_data;
-	    decimal = (decimal * 10) + addend;
-	    if (decimal < addend)	/* overflow */
-		goto bad_data;
-	}
-	if (len != 0 && *from != '.') {
-	    goto bad_data;
-	}
-	if (decimal_numbers == 0) {
-	    if (decimal > 2)
-	    	goto bad_data;
-	    result[0] = decimal * 40;
-	    result_bytes = 1;
-	} else if (decimal_numbers == 1) {
-	    if (decimal > 40)
-	    	goto bad_data;
-	    result[0] += decimal;
-	} else {
-	    /* encode the decimal number,  */
-	    PRUint8 * rp;
-	    PRUint32 num_bytes = 0;
-	    PRUint32 tmp = decimal;
-	    while (tmp) {
-	        num_bytes++;
-		tmp >>= 7;
-	    }
-	    if (!num_bytes )
-	    	++num_bytes;  /* use one byte for a zero value */
-	    if (num_bytes + result_bytes > sizeof result)
-	    	goto bad_data;
-	    tmp = num_bytes;
-	    rp = result + result_bytes - 1;
-	    rp[tmp] = (PRUint8)(decimal & 0x7f);
-	    decimal >>= 7;
-	    while (--tmp > 0) {
-		rp[tmp] = (PRUint8)(decimal | 0x80);
-		decimal >>= 7;
-	    }
-	    result_bytes += num_bytes;
-	}
-	++decimal_numbers;
-	if (len > 0) { /* skip trailing '.' */
-	    ++from;
-	    --len;
-	}
-    } while (len > 0);
-    /* now result contains result_bytes of data */
-    if (to->data && to->len >= result_bytes) {
-    	PORT_Memcpy(to->data, result, to->len = result_bytes);
-	rv = SECSuccess;
-    } else {
-    	SECItem result_item = {siBuffer, NULL, 0 };
-	result_item.data = result;
-	result_item.len  = result_bytes;
-	rv = SECITEM_CopyItem(pool, to, &result_item);
-    }
-    return rv;
-}
-
 static nsresult
 GetCertFingerprintByDottedOidString(CERTCertificate* nsscert,
                                     const nsCString &dottedOid, 
                                     nsCString &fp)
 {
   SECItem oid;
   oid.data = nsnull;
   oid.len = 0;
-  SECStatus srv = _psm_copy_SEC_StringToOID(nsnull, &oid, 
+  SECStatus srv = SEC_StringToOID(nsnull, &oid, 
                     dottedOid.get(), dottedOid.Length());
   if (srv != SECSuccess)
     return NS_ERROR_FAILURE;
 
   SECOidTag oid_tag = SECOID_FindOIDTag(&oid);
   SECITEM_FreeItem(&oid, PR_FALSE);
 
   if (oid_tag == SEC_OID_UNKNOWN)
     return NS_ERROR_FAILURE;
 
@@ -538,21 +441,22 @@ GetCertFingerprintByDottedOidString(nsIX
   if (!nsscert)
     return NS_ERROR_FAILURE;
 
   CERTCertificateCleaner nsscertCleaner(nsscert);
   return GetCertFingerprintByDottedOidString(nsscert, dottedOid, fp);
 }
 
 NS_IMETHODIMP
 nsCertOverrideService::RememberValidityOverride(const nsAString & aHostNameWithPort, 
                                                 nsIX509Cert *aCert,
-                                                PRUint32 aOverrideBits)
+                                                PRUint32 aOverrideBits, 
+                                                PRBool aTemporary)
 {
   NS_ENSURE_ARG_POINTER(aCert);
   if (aHostNameWithPort.IsEmpty())
     return NS_ERROR_INVALID_ARG;
 
   nsCOMPtr<nsIX509Cert2> cert2 = do_QueryInterface(aCert);
   if (!cert2)
     return NS_ERROR_FAILURE;
 
   CERTCertificate* nsscert = cert2->GetCert();
@@ -601,59 +505,64 @@ nsCertOverrideService::RememberValidityO
        *dbkey_walk;
       ++dbkey_walk) {
     char c = *dbkey_walk;
     if (c == '\r' || c == '\n') {
       *dbkey_walk = ' ';
     }
   }
 
   {
     nsAutoMonitor lock(monitor);
-    AddEntryToList(myHostPort, mDottedOidForStoringNewHashes, fpStr, 
+    AddEntryToList(myHostPort,
+                   aTemporary, 
+                   mDottedOidForStoringNewHashes, fpStr, 
                    (nsCertOverride::OverrideBits)aOverrideBits, 
                    nsDependentCString(dbkey));
     Write();
   }
 
   PR_Free(dbkey);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCertOverrideService::HasMatchingOverride(const nsAString & aHostNameWithPort, 
                                            nsIX509Cert *aCert, 
                                            PRUint32 *aOverrideBits,
+                                           PRBool *aIsTemporary,
                                            PRBool *_retval)
 {
   if (aHostNameWithPort.IsEmpty())
     return NS_ERROR_INVALID_ARG;
 
   NS_ENSURE_ARG_POINTER(aCert);
   NS_ENSURE_ARG_POINTER(aOverrideBits);
+  NS_ENSURE_ARG_POINTER(aIsTemporary);
   NS_ENSURE_ARG_POINTER(_retval);
   *_retval = PR_FALSE;
   *aOverrideBits = nsCertOverride::ob_None;
 
   NS_ConvertUTF16toUTF8 hp8(aHostNameWithPort);
   nsCertOverride settings;
 
   {
     nsAutoMonitor lock(monitor);
     nsCertOverrideEntry *entry = mSettingsTable.GetEntry(hp8.get());
   
     if (!entry)
       return NS_OK;
   
     settings = entry->mSettings; // copy
   }
 
   *aOverrideBits = settings.mOverrideBits;
+  *aIsTemporary = settings.mIsTemporary;
 
   nsCAutoString fpStr;
   nsresult rv;
 
   if (settings.mFingerprintAlgOID.Equals(mDottedOidForStoringNewHashes)) {
     rv = GetCertFingerprintByOidTag(aCert, mOidTagForStoringNewHashes, fpStr);
   }
   else {
     rv = GetCertFingerprintByDottedOidString(aCert, settings.mFingerprintAlgOID, fpStr);
   }
@@ -662,69 +571,74 @@ nsCertOverrideService::HasMatchingOverri
 
   *_retval = settings.mFingerprint.Equals(fpStr);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCertOverrideService::GetValidityOverride(const nsAString & aHostNameWithPort, 
                                            nsACString & aHashAlg, 
                                            nsACString & aFingerprint, 
                                            PRUint32 *aOverrideBits,
+                                           PRBool *aIsTemporary,
                                            PRBool *_found)
 {
   NS_ENSURE_ARG_POINTER(_found);
+  NS_ENSURE_ARG_POINTER(aIsTemporary);
   NS_ENSURE_ARG_POINTER(aOverrideBits);
   *_found = PR_FALSE;
   *aOverrideBits = nsCertOverride::ob_None;
 
   NS_ConvertUTF16toUTF8 hp8(aHostNameWithPort);
   nsCertOverride settings;
 
   {
     nsAutoMonitor lock(monitor);
     nsCertOverrideEntry *entry = mSettingsTable.GetEntry(hp8.get());
   
     if (entry) {
       *_found = PR_TRUE;
       settings = entry->mSettings; // copy
     }
   }
 
   if (*_found) {
     *aOverrideBits = settings.mOverrideBits;
+    *aIsTemporary = settings.mIsTemporary;
     aFingerprint = settings.mFingerprint;
     aHashAlg = settings.mFingerprintAlgOID;
   }
 
   return NS_OK;
 }
 
 nsresult
 nsCertOverrideService::AddEntryToList(const nsACString &hostWithPortUTF8, 
+                                      const PRBool aIsTemporary,
                                       const nsACString &fingerprintAlgOID, 
                                       const nsACString &fingerprint,
                                       nsCertOverride::OverrideBits ob,
                                       const nsACString &dbKey)
 {
   const nsPromiseFlatCString &flat = PromiseFlatCString(hostWithPortUTF8);
 
   {
     nsAutoMonitor lock(monitor);
     nsCertOverrideEntry *entry = mSettingsTable.PutEntry(flat.get());
 
     if (!entry) {
       NS_ERROR("can't insert a null entry!");
       return NS_ERROR_OUT_OF_MEMORY;
     }
 
     nsCertOverride &settings = entry->mSettings;
     settings.mHostWithPortUTF8 = hostWithPortUTF8;
+    settings.mIsTemporary = aIsTemporary;
     settings.mFingerprintAlgOID = fingerprintAlgOID;
     settings.mFingerprint = fingerprint;
     settings.mOverrideBits = ob;
     settings.mDBKey = dbKey;
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -787,39 +701,49 @@ matchesDBKey(nsIX509Cert *cert, const ch
     }
 
     ++key1;
     ++key2;
   }
 
   PR_Free(dbkey);
   return !found_mismatch;
 }
 
-struct nsCertAndInt
+struct nsCertAndBoolsAndInt
 {
   nsIX509Cert *cert;
+  PRBool aCheckTemporaries;
+  PRBool aCheckPermanents;
   PRUint32 counter;
 
   SECOidTag mOidTagForStoringNewHashes;
   nsCString mDottedOidForStoringNewHashes;
 };
 
 PR_STATIC_CALLBACK(PLDHashOperator)
 FindMatchingCertCallback(nsCertOverrideEntry *aEntry,
                          void *aArg)
 {
-  nsCertAndInt *cai = (nsCertAndInt *)aArg;
+  nsCertAndBoolsAndInt *cai = (nsCertAndBoolsAndInt *)aArg;
 
   if (cai && aEntry)
   {
     const nsCertOverride &settings = aEntry->mSettings;
-    if (matchesDBKey(cai->cert, settings.mDBKey.get())) {
+    PRBool still_ok = PR_TRUE;
+
+    if ((settings.mIsTemporary && !cai->aCheckTemporaries)
+        ||
+        (!settings.mIsTemporary && !cai->aCheckPermanents)) {
+      still_ok = PR_FALSE;
+    }
+
+    if (still_ok && matchesDBKey(cai->cert, settings.mDBKey.get())) {
       nsCAutoString cert_fingerprint;
       nsresult rv;
       if (settings.mFingerprintAlgOID.Equals(cai->mDottedOidForStoringNewHashes)) {
         rv = GetCertFingerprintByOidTag(cai->cert,
                cai->mOidTagForStoringNewHashes, cert_fingerprint);
       }
       else {
         rv = GetCertFingerprintByDottedOidString(cai->cert,
                settings.mFingerprintAlgOID, cert_fingerprint);
       }
@@ -828,27 +752,31 @@ FindMatchingCertCallback(nsCertOverrideE
         cai->counter++;
       }
     }
   }
 
   return PL_DHASH_NEXT;
 }
 
 NS_IMETHODIMP
 nsCertOverrideService::IsCertUsedForOverrides(nsIX509Cert *aCert, 
+                                              PRBool aCheckTemporaries,
+                                              PRBool aCheckPermanents,
                                               PRUint32 *_retval)
 {
   NS_ENSURE_ARG(aCert);
   NS_ENSURE_ARG(_retval);
 
-  nsCertAndInt cai;
+  nsCertAndBoolsAndInt cai;
   cai.cert = aCert;
+  cai.aCheckTemporaries = aCheckTemporaries;
+  cai.aCheckPermanents = aCheckPermanents;
   cai.counter = 0;
   cai.mOidTagForStoringNewHashes = mOidTagForStoringNewHashes;
   cai.mDottedOidForStoringNewHashes = mDottedOidForStoringNewHashes;
 
   {
     nsAutoMonitor lock(monitor);
     mSettingsTable.EnumerateEntries(FindMatchingCertCallback, &cai);
   }
   *_retval = cai.counter;
   return NS_OK;
Index: mozilla/security/manager/ssl/src/nsCertOverrideService.h
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsCertOverrideService.h,v
retrieving revision 1.1
diff -u -1 -0 -p -r1.1 nsCertOverrideService.h
--- mozilla/security/manager/ssl/src/nsCertOverrideService.h	3 Oct 2007 11:43:56 -0000	1.1
+++ mozilla/security/manager/ssl/src/nsCertOverrideService.h	31 Oct 2007 19:14:34 -0000
@@ -61,28 +61,30 @@ public:
   }
 
   nsCertOverride(const nsCertOverride &other)
   {
     this->operator=(other);
   }
 
   nsCertOverride &operator=(const nsCertOverride &other)
   {
     mHostWithPortUTF8 = other.mHostWithPortUTF8;
+    mIsTemporary = other.mIsTemporary;
     mFingerprintAlgOID = other.mFingerprintAlgOID;
     mFingerprint = other.mFingerprint;
     mOverrideBits = other.mOverrideBits;
     mDBKey = other.mDBKey;
     return *this;
   }
 
   nsCString mHostWithPortUTF8;
+  PRBool mIsTemporary; // true: session only, false: stored on disk
   nsCString mFingerprint;
   nsCString mFingerprintAlgOID;
   OverrideBits mOverrideBits;
   nsCString mDBKey;
 
   static void convertBitsToString(OverrideBits ob, nsACString &str);
   static void convertStringToBits(const nsACString &str, OverrideBits &ob);
 };
 
 
@@ -175,21 +177,22 @@ protected:
     PRMonitor *monitor;
     nsCOMPtr<nsIFile> mSettingsFile;
     nsTHashtable<nsCertOverrideEntry> mSettingsTable;
 
     SECOidTag mOidTagForStoringNewHashes;
     nsCString mDottedOidForStoringNewHashes;
 
     void RemoveAllFromMemory();
     nsresult Read();
     nsresult Write();
-    nsresult AddEntryToList(const nsACString &hostWithPortUTF8, 
+    nsresult AddEntryToList(const nsACString &hostWithPortUTF8,
+                            const PRBool aIsTemporary,
                             const nsACString &algo_oid, 
                             const nsACString &fingerprint,
                             nsCertOverride::OverrideBits ob,
                             const nsACString &dbKey);
 };
 
 #define NS_CERTOVERRIDE_CID { /* 67ba681d-5485-4fff-952c-2ee337ffdcd6 */ \
     0x67ba681d,                                                        \
     0x5485,                                                            \
     0x4fff,                                                            \
Index: mozilla/security/manager/ssl/src/nsCertTree.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsCertTree.cpp,v
retrieving revision 1.62
diff -u -1 -0 -p -r1.62 nsCertTree.cpp
--- mozilla/security/manager/ssl/src/nsCertTree.cpp	19 Oct 2007 19:12:07 -0000	1.62
+++ mozilla/security/manager/ssl/src/nsCertTree.cpp	31 Oct 2007 19:14:35 -0000
@@ -137,29 +137,31 @@ static PLDHashTableOps gMapOps = {
   CompareCacheInitEntry
 };
 
 NS_IMPL_ISUPPORTS0(nsCertAddonInfo)
 NS_IMPL_ISUPPORTS1(nsCertTreeDispInfo, nsICertTreeItem)
 
 nsCertTreeDispInfo::nsCertTreeDispInfo()
 :mAddonInfo(nsnull)
 ,mTypeOfEntry(direct_db)
 ,mOverrideBits(nsCertOverride::ob_None)
+,mIsTemporary(PR_TRUE)
 {
 }
 
 nsCertTreeDispInfo::nsCertTreeDispInfo(nsCertTreeDispInfo &other)
 {
   mAddonInfo = other.mAddonInfo;
   mTypeOfEntry = other.mTypeOfEntry;
   mHostWithPort = other.mHostWithPort;
   mOverrideBits = other.mOverrideBits;
+  mIsTemporary = other.mIsTemporary;
 }
 
 nsCertTreeDispInfo::~nsCertTreeDispInfo()
 {
 }
 
 NS_IMETHODIMP
 nsCertTreeDispInfo::GetCert(nsIX509Cert **_cert)
 {
   NS_ENSURE_ARG(_cert);
@@ -382,20 +384,21 @@ MatchingCertOverridesCallback(const nsCe
     return;
 
   nsCertTreeDispInfo *certdi = new nsCertTreeDispInfo;
   if (certdi) {
     if (cap->certai)
       cap->certai->mUsageCount++;
     certdi->mAddonInfo = cap->certai;
     certdi->mTypeOfEntry = nsCertTreeDispInfo::host_port_override;
     certdi->mHostWithPort = NS_ConvertUTF8toUTF16(aSettings.mHostWithPortUTF8);
     certdi->mOverrideBits = aSettings.mOverrideBits;
+    certdi->mIsTemporary = aSettings.mIsTemporary;
     NS_IF_ADDREF(certdi);
     cap->array->InsertElementAt(cap->position, certdi);
     cap->position++;
     cap->counter++;
   }
 
   // this entry is now associated to a displayed cert, remove
   // it from the list of remaining entries
   cap->tracker->RemoveEntry(aSettings.mHostWithPortUTF8);
 }
@@ -438,20 +441,21 @@ AddRemaningHostPortOverridesCallback(con
 
   // This entry is not associated to any stored cert,
   // so we still need to display it.
 
   nsCertTreeDispInfo *certdi = new nsCertTreeDispInfo;
   if (certdi) {
     certdi->mAddonInfo = nsnull;
     certdi->mTypeOfEntry = nsCertTreeDispInfo::host_port_override;
     certdi->mHostWithPort = NS_ConvertUTF8toUTF16(aSettings.mHostWithPortUTF8);
     certdi->mOverrideBits = aSettings.mOverrideBits;
+    certdi->mIsTemporary = aSettings.mIsTemporary;
     NS_IF_ADDREF(certdi);
     cap->array->InsertElementAt(cap->position, certdi);
     cap->position++;
     cap->counter++;
   }
 }
 
 nsresult
 nsCertTree::GetCertsByTypeFromCertList(CERTCertList *aCertList,
                                        PRUint32 aWantedType,
@@ -553,22 +557,25 @@ nsCertTree::GetCertsByTypeFromCertList(C
         wantThisCert = PR_TRUE;
       }
     }
 
     nsCOMPtr<nsIX509Cert> pipCert = new nsNSSCertificate(node->cert);
     if (!pipCert)
       return NS_ERROR_OUT_OF_MEMORY;
 
     if (wantThisCertIfNoOverrides || wantThisCertIfHaveOverrides) {
       PRUint32 ocount = 0;
-      nsresult rv = mOverrideService->IsCertUsedForOverrides(pipCert, &ocount);
-
+      nsresult rv = 
+        mOverrideService->IsCertUsedForOverrides(pipCert, 
+                                                 PR_TRUE, // we want temporaries
+                                                 PR_TRUE, // we want permanents
+                                                 &ocount);
       if (wantThisCertIfNoOverrides) {
         if (NS_FAILED(rv) || ocount == 0) {
           // no overrides for this cert
           wantThisCert = PR_TRUE;
         }
       }
 
       if (wantThisCertIfHaveOverrides) {
         if (NS_SUCCEEDED(rv) && ocount > 0) {
           // there are overrides for this cert
@@ -599,20 +606,21 @@ nsCertTree::GetCertsByTypeFromCertList(C
       if (wantThisCert) {
         nsCertTreeDispInfo *certdi = new nsCertTreeDispInfo;
         if (!certdi)
           return NS_ERROR_OUT_OF_MEMORY;
 
         certdi->mAddonInfo = certai;
         certai->mUsageCount++;
         certdi->mTypeOfEntry = nsCertTreeDispInfo::direct_db;
         // not necessary: certdi->mHostWithPort.Clear();
         certdi->mOverrideBits = nsCertOverride::ob_None;
+        certdi->mIsTemporary = PR_FALSE;
         mDispInfo.InsertElementAt(InsertPosition, certdi);
         ++count;
         ++InsertPosition;
       }
       if (addOverrides && cos) {
         nsCertAndArrayAndPositionAndCounterAndTracker cap;
         cap.certai = certai;
         cap.array = &mDispInfo;
         cap.position = InsertPosition;
         cap.counter = 0;
@@ -1230,20 +1238,24 @@ nsCertTree::GetCellText(PRInt32 row, nsI
     nsCAutoString temp;
     nsCertOverride::convertBitsToString(ob, temp);
     _retval = NS_ConvertUTF8toUTF16(temp);
   } else if (NS_LITERAL_STRING("sitecol").Equals(colID)) {
     if (certdi->mTypeOfEntry == nsCertTreeDispInfo::host_port_override) {
       _retval = certdi->mHostWithPort;
     }
     else {
       _retval = NS_LITERAL_STRING("*");
     }
+  } else if (NS_LITERAL_STRING("lifetimecol").Equals(colID)) {
+    const char *stringID = 
+      (certdi->mIsTemporary) ? "CertExceptionTemporary" : "CertExceptionPermanent";
+    rv = mNSSComponent->GetPIPNSSBundleString(stringID, _retval);
   } else if (NS_LITERAL_STRING("typecol").Equals(colID) && cert) {
     nsCOMPtr<nsIX509Cert2> pipCert = do_QueryInterface(cert);
     PRUint32 type = nsIX509Cert::UNKNOWN_CERT;
 
     if (pipCert) {
 	rv = pipCert->GetCertType(&type);
     }
 
     switch (type) {
     case nsIX509Cert::USER_CERT:
Index: mozilla/security/manager/ssl/src/nsCertTree.h
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsCertTree.h,v
retrieving revision 1.18
diff -u -1 -0 -p -r1.18 nsCertTree.h
--- mozilla/security/manager/ssl/src/nsCertTree.h	19 Oct 2007 19:12:07 -0000	1.18
+++ mozilla/security/manager/ssl/src/nsCertTree.h	31 Oct 2007 19:14:35 -0000
@@ -93,20 +93,21 @@ public:
   nsCertTreeDispInfo();
   nsCertTreeDispInfo(nsCertTreeDispInfo &other);
   virtual ~nsCertTreeDispInfo();
 
   nsRefPtr<nsCertAddonInfo> mAddonInfo;
   enum {
     direct_db, host_port_override
   } mTypeOfEntry;
   nsString mHostWithPort;
   nsCertOverride::OverrideBits mOverrideBits;
+  PRBool mIsTemporary;
 };
 
 class nsCertTree : public nsICertTree
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSICERTTREE
   NS_DECL_NSITREEVIEW
 
   nsCertTree();
Index: mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp,v
retrieving revision 1.139
diff -u -1 -0 -p -r1.139 nsNSSIOLayer.cpp
--- mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp	30 Oct 2007 20:26:27 -0000	1.139
+++ mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp	31 Oct 2007 19:14:35 -0000
@@ -2630,34 +2630,36 @@ nsNSSBadCertHandler(void *arg, PRFileDes
     status->mIsNotValidAtThisTime = collected_errors & nsICertOverrideService::ERROR_TIME;
     status->mIsUntrusted = collected_errors & nsICertOverrideService::ERROR_UNTRUSTED;
   }
 
   remaining_display_errors = collected_errors;
 
   nsCOMPtr<nsICertOverrideService> overrideService = 
     do_GetService(NS_CERTOVERRIDE_CONTRACTID);
   // it is fine to continue without the nsICertOverrideService
 
-  PRUint32 storedOverrideBits = 0; 
+  PRUint32 overrideBits = 0; 
 
   if (overrideService)
   {
-    PRBool haveStoredOverride;
+    PRBool haveOverride;
+    PRBool isTemporaryOverride; // we don't care
   
-    nsrv = overrideService->HasMatchingOverride(hostWithPortStringUTF16,
+    nsrv = overrideService->HasMatchingOverride(hostWithPortStringUTF16, 
                                                 ix509, 
-                                                &storedOverrideBits, 
-                                                &haveStoredOverride);
-    if (NS_SUCCEEDED(nsrv) && haveStoredOverride) 
+                                                &overrideBits,
+                                                &isTemporaryOverride, 
+                                                &haveOverride);
+    if (NS_SUCCEEDED(nsrv) && haveOverride) 
     {
       // remove the errors that are already overriden
-      remaining_display_errors -= storedOverrideBits;
+      remaining_display_errors -= overrideBits;
     }
   }
 
   if (!remaining_display_errors) {
     // all errors are covered by override rules, so let's accept the cert
     return SECSuccess;
   }
 
   // Ok, this is a full stop.
   // First, deliver the technical details of the broken SSL status,
