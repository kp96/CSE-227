Index: dom/src/jsurl/nsJSProtocolHandler.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/jsurl/nsJSProtocolHandler.cpp,v
retrieving revision 1.136
diff -1 -5 -u -p -r1.136 nsJSProtocolHandler.cpp
--- dom/src/jsurl/nsJSProtocolHandler.cpp	10 Nov 2006 23:49:03 -0000	1.136
+++ dom/src/jsurl/nsJSProtocolHandler.cpp	13 Dec 2006 06:08:26 -0000
@@ -61,31 +61,31 @@
 #include "nsIWindowMediator.h"
 #include "nsPIDOMWindow.h"
 #include "nsIDOMDocument.h"
 #include "nsIJSConsoleService.h"
 #include "nsIConsoleService.h"
 #include "nsXPIDLString.h"
 #include "prprf.h"
 #include "nsEscape.h"
 #include "nsIWebNavigation.h"
 #include "nsIDocShell.h"
 #include "nsIContentViewer.h"
 #include "nsIXPConnect.h"
 #include "nsContentUtils.h"
 #include "nsJSUtils.h"
 #include "nsThreadUtils.h"
-
+#include "nsIJSContextStack.h"
 
 class nsJSThunk : public nsIInputStream
 {
 public:
     nsJSThunk();
 
     NS_DECL_ISUPPORTS
     NS_FORWARD_SAFE_NSIINPUTSTREAM(mInnerStream)
 
     nsresult Init(nsIURI* uri);
     nsresult EvaluateScript(nsIChannel *aChannel, PopupControlState aPopupState);
     nsresult BringUpConsole(nsIDOMWindow *aDomWindow);
 
 protected:
     virtual ~nsJSThunk();
@@ -266,59 +266,73 @@ nsresult nsJSThunk::EvaluateScript(nsICh
         // to access.
 
         nsIXPConnect *xpc = nsContentUtils::XPConnect();
 
         JSContext *cx = (JSContext*)scriptContext->GetNativeContext();
         nsCOMPtr<nsIXPConnectJSObjectHolder> sandbox;
         rv = xpc->CreateSandbox(cx, principal, getter_AddRefs(sandbox));
         NS_ENSURE_SUCCESS(rv, rv);
 
         jsval rval = JSVAL_VOID;
         nsAutoGCRoot root(&rval, &rv);
         if (NS_FAILED(rv)) {
             return rv;
         }
 
+        // Push our JSContext on the context stack so the JS_ValueToString call (and
+        // JS_ReportPendingException, if relevant) will use the principal of cx.
+        // Note that we do this as late as possible to make popping simpler.
+        nsCOMPtr<nsIJSContextStack> stack =
+            do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
+        if (NS_SUCCEEDED(rv)) {
+            rv = stack->Push(cx);
+        }
+        if (NS_FAILED(rv)) {
+            return rv;
+        }    
+
         rv = xpc->EvalInSandboxObject(NS_ConvertUTF8toUTF16(script), cx,
                                       sandbox, &rval);
 
         // Propagate and report exceptions that happened in the
         // sandbox.
         if (JS_IsExceptionPending(cx)) {
             JS_ReportPendingException(cx);
         }
 
         isUndefined = rval == JSVAL_VOID;
 
         if (!isUndefined && NS_SUCCEEDED(rv)) {
             JSAutoRequest ar(cx);
 
             JSString *str = JS_ValueToString(cx, rval);
             if (!str) {
                 // Report any pending exceptions.
                 if (JS_IsExceptionPending(cx)) {
                     JS_ReportPendingException(cx);
                 }
 
                 // We don't know why this failed, so just use a
                 // generic error code. It'll be translated to a
                 // different one below anyways.
                 rv = NS_ERROR_FAILURE;
             } else {
                 result = nsDependentJSString(str);
             }
         }
+
+        stack->Pop(nsnull);
     } else {
         // No need to use the sandbox, evaluate the script directly in
         // the given scope.
         rv = scriptContext->EvaluateString(NS_ConvertUTF8toUTF16(script),
                                            globalJSObject, // obj
                                            principal,
                                            url.get(),      // url
                                            1,              // line no
                                            nsnull,
                                            &result,
                                            &isUndefined);
 
         // If there's an error on cx as a result of that call, report
         // it now -- either we're just running under the event loop,
         // so we shouldn't propagate JS exceptions out of here, or we
