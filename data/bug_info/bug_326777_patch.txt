Index: xpcom/threads/nsIEventQueueListener.idl
===================================================================
RCS file: xpcom/threads/nsIEventQueueListener.idl
diff -N xpcom/threads/nsIEventQueueListener.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ xpcom/threads/nsIEventQueueListener.idl	16 Apr 2007 02:33:29 -0000
@@ -0,0 +1,66 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Boris Zbarsky <bzbarsky@mit.edu>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+interface nsIEventQueue;
+
+/**
+ * This interface represents a listener who wants to be notified when
+ * an event queue is about to process events or when it has finished
+ * processing events.
+ */
+[uuid(7579c049-8f16-4981-a6fb-a2c4126799ca)]
+interface nsIEventQueueListener : nsISupports
+{
+  /**
+   * Call before processing events.
+   *
+   * @param aQueue the queue that will process events
+   *
+   * If this method throws, events should NOT be processed.
+   */
+  void willProcessEvents(in nsIEventQueue aQueue);
+
+  /**
+   * Call after processing events.
+   *
+   * @param aQueue the queue that has processed events
+   */
+  void didProcessEvents(in nsIEventQueue aQueue);
+};
Index: xpcom/threads/nsEventQueue.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpcom/threads/nsEventQueue.cpp,v
retrieving revision 3.46.8.2
diff -u -p -d -8 -r3.46.8.2 nsEventQueue.cpp
--- xpcom/threads/nsEventQueue.cpp	18 Oct 2005 01:47:31 -0000	3.46.8.2
+++ xpcom/threads/nsEventQueue.cpp	16 Apr 2007 02:34:20 -0000
@@ -34,16 +34,17 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsCOMPtr.h"
 #include "nsEventQueue.h"
 #include "nsIEventQueueService.h"
 #include "nsIThread.h"
+#include "nsIEventQueueListener.h"
 
 #include "nsIServiceManager.h"
 #include "nsIObserverService.h"
 
 #include "nsString.h"
 
 #include "prlog.h"
 
@@ -61,16 +62,41 @@ static int gEventQueueLogPPLevel = 0;
 static PLEventQueue *gEventQueueLogQueue = 0;
 static PRThread *gEventQueueLogThread = 0;
 #endif
 
 // in a real system, these would be members in a header class...
 static const char gActivatedNotification[] = "nsIEventQueueActivated";
 static const char gDestroyedNotification[] = "nsIEventQueueDestroyed";
 
+class ListenerCaller {
+public:
+  ListenerCaller(nsIEventQueue* aQueue, nsresult* rv) : mQueue(aQueue)
+  {
+    mListener = do_GetService(NS_EVENT_QUEUE_LISTENER_CONTRACTID);
+    // There might be no listener...  but if so, warn
+    if (mListener) {
+      *rv = mListener->WillProcessEvents(mQueue);
+    } else {
+      NS_WARNING("No event queue listener?");
+      *rv = NS_OK;
+    }
+  }
+
+  ~ListenerCaller() {
+    if (mListener) {
+      mListener->DidProcessEvents(mQueue);
+    }
+  }
+  
+private:
+  nsIEventQueue* mQueue;
+  nsCOMPtr<nsIEventQueueListener> mListener;
+};
+
 nsEventQueueImpl::nsEventQueueImpl()
 {
   NS_ADDREF_THIS();
   /* The slightly weird ownership model for eventqueues goes like this:
 
      General:
        There's an addref from the factory generally held by whoever asked for
      the queue. The queue addrefs itself (right here) and releases itself
@@ -397,16 +423,21 @@ NS_IMETHODIMP
 nsEventQueueImpl::ProcessPendingEvents()
 {
   PRBool correctThread = PL_IsQueueOnCurrentThread(mEventQueue);
 
   NS_ASSERTION(correctThread, "attemping to process events on the wrong thread");
 
   if (!correctThread)
     return NS_ERROR_FAILURE;
+
+  nsresult rv;
+  ListenerCaller caller(this, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+  
 #if defined(PR_LOGGING) && defined(DEBUG_danm)
   ++gEventQueueLogPPLevel;
   if ((gEventQueueLogQueue != mEventQueue || gEventQueueLogThread != PR_GetCurrentThread() ||
        gEventQueueLogCount != gEventQueueLogPPCount) && gEventQueueLogPPLevel == 1) {
     PR_LOG(gEventQueueLog, PR_LOG_DEBUG,
            ("EventQueue: Process pending [queue=%lx, accept=%d, could=%d]",
            (long)mEventQueue,(int)mAcceptingEvents,(int)mCouldHaveEvents));
     gEventQueueLogPPCount = ++gEventQueueLogCount;
@@ -466,16 +497,20 @@ nsEventQueueImpl::GetEvent(PLEvent** aRe
 NS_IMETHODIMP
 nsEventQueueImpl::HandleEvent(PLEvent* aEvent)
 {
   PRBool correctThread = PL_IsQueueOnCurrentThread(mEventQueue);
   NS_ASSERTION(correctThread, "attemping to process events on the wrong thread");
   if (!correctThread)
     return NS_ERROR_FAILURE;
 
+  nsresult rv;
+  ListenerCaller caller(this, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+  
 #if defined(PR_LOGGING) && defined(DEBUG_danm)
   PR_LOG(gEventQueueLog, PR_LOG_DEBUG,
          ("EventQueue: handle event [queue=%lx, accept=%d, could=%d]",
          (long)mEventQueue,(int)mAcceptingEvents,(int)mCouldHaveEvents));
   ++gEventQueueLogCount;
 #endif
   PL_HandleEvent(aEvent);
   return NS_OK;
Index: xpcom/threads/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/xpcom/threads/Makefile.in,v
retrieving revision 1.40
diff -u -p -d -8 -r1.40 Makefile.in
--- xpcom/threads/Makefile.in	1 Apr 2005 18:22:56 -0000	1.40
+++ xpcom/threads/Makefile.in	16 Apr 2007 02:24:02 -0000
@@ -81,16 +81,17 @@ XPIDLSRCS	= \
 		nsIThread.idl \
 		nsITimer.idl \
 		nsITimerInternal.idl \
 		nsITimerManager.idl \
 		nsIRunnable.idl \
 		nsIEventTarget.idl \
 		nsIEventQueue.idl \
 		nsIEventQueueService.idl \
+		nsIEventQueueListener.idl \
 		nsIEnvironment.idl \
 		nsIProcess.idl \
 		nsISupportsPriority.idl \
 		$(NULL)
 
 EXPORTS		:= $(addprefix $(srcdir)/, $(EXPORTS))
 
 LOCAL_INCLUDES	= -I$(srcdir)/../components
Index: xpcom/build/nsXPCOMCID.h
===================================================================
RCS file: /cvsroot/mozilla/xpcom/build/nsXPCOMCID.h,v
retrieving revision 1.6
diff -u -p -d -8 -r1.6 nsXPCOMCID.h
--- xpcom/build/nsXPCOMCID.h	13 Jun 2005 18:39:19 -0000	1.6
+++ xpcom/build/nsXPCOMCID.h	16 Apr 2007 02:13:34 -0000
@@ -176,9 +176,16 @@
 /**
  * nsHashPropertyBag impl of nsIWritablePropertyBag
  */
 #define NS_HASH_PROPERTY_BAG_CID \
 { 0x678c50b8, 0x6bcb, 0x4ad0, \
 { 0xb9, 0xb8, 0xc8, 0x11, 0x75, 0x95, 0x51, 0x99 } }
 #define NS_HASH_PROPERTY_BAG_CONTRACTID "@mozilla.org/hash-property-bag;1"
 
+/**
+ * A service that wants to be notified before and after event queues
+ * will process events.
+ */
+#define NS_EVENT_QUEUE_LISTENER_CONTRACTID \
+  "@mozilla.org/event-queue-listener;1"
+
 #endif
Index: js/src/xpconnect/src/xpcprivate.h
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcprivate.h,v
retrieving revision 1.162.2.18
diff -u -p -d -8 -r1.162.2.18 xpcprivate.h
--- js/src/xpconnect/src/xpcprivate.h	2 Dec 2006 00:20:51 -0000	1.162.2.18
+++ js/src/xpconnect/src/xpcprivate.h	16 Apr 2007 02:32:57 -0000
@@ -116,16 +116,18 @@
 #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
 #include "nsISecurityCheckedComponent.h"
 #endif
 
 #ifdef XPC_TOOLS_SUPPORT
 #include "nsIXPCToolsProfiler.h"
 #endif
 
+#include "nsIEventQueueListener.h"
+
 #ifdef XPC_IDISPATCH_SUPPORT
 // This goop was added because of EXCEPINFO in ThrowCOMError
 // This include is here, because it needs to occur before the undefines below
 #include <atlbase.h>
 #include "oaidl.h"
 // Nasty MS defines
 #undef GetClassInfo
 #undef GetClassName
@@ -415,23 +417,25 @@ private:
 // pointer generally do so using an 'out' parm. When interface pointers are
 // returned as function call result values they are not addref'd. Exceptions
 // to this rule are noted explicitly.
 
 const PRBool OBJ_IS_GLOBAL = PR_TRUE;
 const PRBool OBJ_IS_NOT_GLOBAL = PR_FALSE;
 
 class nsXPConnect : public nsIXPConnect_MOZILLA_1_8_BRANCH,
+                    public nsIEventQueueListener,
                     public nsSupportsWeakReference
 {
 public:
     // all the interface method declarations...
     NS_DECL_ISUPPORTS
     NS_DECL_NSIXPCONNECT
     NS_DECL_NSIXPCONNECT_MOZILLA_1_8_BRANCH
+    NS_DECL_NSIEVENTQUEUELISTENER
 
     // non-interface implementation
 public:
     // These get non-addref'd pointers
     static nsXPConnect*  GetXPConnect();
     static XPCJSRuntime* GetRuntime(nsXPConnect* xpc = nsnull);
     static XPCContext*   GetContext(JSContext* cx, nsXPConnect* xpc = nsnull);
     static nsIJSRuntimeService* GetJSRuntimeService(nsXPConnect* xpc = nsnull);
Index: js/src/xpconnect/src/nsXPConnect.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/nsXPConnect.cpp,v
retrieving revision 1.73.4.11
diff -u -p -d -8 -r1.73.4.11 nsXPConnect.cpp
--- js/src/xpconnect/src/nsXPConnect.cpp	2 Dec 2006 00:20:51 -0000	1.73.4.11
+++ js/src/xpconnect/src/nsXPConnect.cpp	16 Apr 2007 02:37:40 -0000
@@ -40,20 +40,21 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 /* High level class and public functions implementation. */
 
 #include "xpcprivate.h"
 #include "XPCNativeWrapper.h"
 
-NS_IMPL_THREADSAFE_ISUPPORTS3(nsXPConnect,
+NS_IMPL_THREADSAFE_ISUPPORTS4(nsXPConnect,
                               nsIXPConnect,
                               nsIXPConnect_MOZILLA_1_8_BRANCH,
-                              nsISupportsWeakReference)
+                              nsISupportsWeakReference,
+                              nsIEventQueueListener)
 
 nsXPConnect* nsXPConnect::gSelf = nsnull;
 JSBool       nsXPConnect::gOnceAliveNowDead = JS_FALSE;
 PRThread*    nsXPConnect::gMainThread = nsnull;
 
 const char XPC_CONTEXT_STACK_CONTRACTID[] = "@mozilla.org/js/xpc/ContextStack;1";
 const char XPC_RUNTIME_CONTRACTID[]       = "@mozilla.org/js/xpc/RuntimeService;1";
 const char XPC_EXCEPTION_CONTRACTID[]     = "@mozilla.org/js/xpc/Exception;1";
@@ -1565,16 +1566,32 @@ nsXPConnect::FlagSystemFilenamePrefix(co
     if(NS_FAILED(rv))
         return rv;
 
     if(!JS_FlagScriptFilenamePrefix(rt, aFilenamePrefix, JSFILENAME_SYSTEM))
         return NS_ERROR_OUT_OF_MEMORY;
     return NS_OK;
 }
 
+NS_IMETHODIMP
+nsXPConnect::WillProcessEvents(nsIEventQueue *aQueue)
+{
+    // Push a null JSContext so that we don't see any script during
+    // event processing.
+    NS_ENSURE_STATE(mContextStack);
+    return mContextStack->Push(nsnull);
+}
+
+NS_IMETHODIMP
+nsXPConnect::DidProcessEvents(nsIEventQueue *aQueue)
+{
+    NS_ENSURE_STATE(mContextStack);
+    return mContextStack->Pop(nsnull);
+}
+
 #ifdef DEBUG
 /* These are here to be callable from a debugger */
 JS_BEGIN_EXTERN_C
 void DumpJSStack()
 {
     nsresult rv;
     nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
     if(NS_SUCCEEDED(rv) && xpc)
Index: js/src/xpconnect/src/xpcmodule.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcmodule.cpp,v
retrieving revision 1.40.28.2
diff -u -p -d -8 -r1.40.28.2 xpcmodule.cpp
--- js/src/xpconnect/src/xpcmodule.cpp	16 May 2006 18:29:35 -0000	1.40.28.2
+++ js/src/xpconnect/src/xpcmodule.cpp	16 Apr 2007 03:56:22 -0000
@@ -36,16 +36,17 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /* Module level methods. */
 
 #include "xpcprivate.h"
+#include "nsXPCOMCID.h"
 #ifdef MOZ_JSLOADER
 #include "mozJSLoaderConstructors.h"
 #endif
 
 /* Module implementation for the xpconnect library. */
 
 NS_DECL_CLASSINFO(XPCVariant)
 
@@ -85,17 +86,18 @@ static const nsModuleComponentInfo compo
   {nsnull, NS_JS_ID_CID,                         XPC_ID_CONTRACTID,            nsJSIDConstructor             },
   {nsnull, NS_XPCONNECT_CID,                     XPC_XPCONNECT_CONTRACTID,     nsIXPConnectConstructor       },
   {nsnull, NS_XPC_THREAD_JSCONTEXT_STACK_CID,    XPC_CONTEXT_STACK_CONTRACTID, nsIJSContextStackConstructor  },
   {nsnull, NS_XPCEXCEPTION_CID,                  XPC_EXCEPTION_CONTRACTID,     nsXPCExceptionConstructor, nsnull, nsnull, nsnull, NS_CI_INTERFACE_GETTER_NAME(nsXPCException), nsnull, &NS_CLASSINFO_NAME(nsXPCException)},
   {nsnull, NS_JS_RUNTIME_SERVICE_CID,            XPC_RUNTIME_CONTRACTID,       nsIJSRuntimeServiceConstructor},
   {NS_SCRIPTERROR_CLASSNAME, NS_SCRIPTERROR_CID, NS_SCRIPTERROR_CONTRACTID,    nsScriptErrorConstructor      },
   {nsnull, SCRIPTABLE_INTERFACES_CID,            NS_SCRIPTABLE_INTERFACES_CONTRACTID,        nsXPCComponents_InterfacesConstructor },
   {nsnull, XPCVARIANT_CID,                       XPCVARIANT_CONTRACTID,        nsnull, nsnull, nsnull, nsnull, NS_CI_INTERFACE_GETTER_NAME(XPCVariant), nsnull, &NS_CLASSINFO_NAME(XPCVariant)},
-  {nsnull, NS_XPC_JSCONTEXT_STACK_ITERATOR_CID,  XPC_JSCONTEXT_STACK_ITERATOR_CONTRACTID, nsXPCJSContextStackIteratorConstructor }
+  {nsnull, NS_XPC_JSCONTEXT_STACK_ITERATOR_CID,  XPC_JSCONTEXT_STACK_ITERATOR_CONTRACTID, nsXPCJSContextStackIteratorConstructor },
+  {nsnull, NS_XPCONNECT_CID,                     NS_EVENT_QUEUE_LISTENER_CONTRACTID,     nsIXPConnectConstructor       }
 
 #ifdef MOZ_JSLOADER
   // jsloader stuff
  ,{ "JS component loader", MOZJSCOMPONENTLOADER_CID,
     MOZJSCOMPONENTLOADER_CONTRACTID, mozJSComponentLoaderConstructor,
     RegisterJSLoader, UnregisterJSLoader }
 #ifndef NO_SUBSCRIPT_LOADER
  ,{ "JS subscript loader", MOZ_JSSUBSCRIPTLOADER_CID,
