Index: mozilla/mailnews/mime/src/mimecms.cpp
===================================================================
RCS file: /cvsroot/mozilla/mailnews/mime/src/mimecms.cpp,v
retrieving revision 1.26
diff -u -u -2 -0 -r1.26 mimecms.cpp
--- mozilla/mailnews/mime/src/mimecms.cpp	10 Mar 2006 15:35:04 -0000	1.26
+++ mozilla/mailnews/mime/src/mimecms.cpp	30 Mar 2006 11:37:24 -0000
@@ -354,41 +354,44 @@
     wrt the shown part in the toplevel window
   */
 
   // if we are showing the toplevel message, aTopMessageNestLevel == 0
   int aTopMessageNestLevel = 0;
   MimeObject *aTopShownObject = nsnull;
   if (obj && obj->options->part_to_load) {
     PRBool aAlreadyFoundTop = PR_FALSE;
     for (MimeObject *walker = obj; walker; walker = walker->parent) {
       if (aAlreadyFoundTop) {
         if (!mime_typep(walker, (MimeObjectClass *) &mimeEncryptedClass)
             && !mime_typep(walker, (MimeObjectClass *) &mimeMultipartSignedClass)) {
           ++aTopMessageNestLevel;
         }
       }
       if (!aAlreadyFoundTop && !strcmp(mime_part_address(walker), walker->options->part_to_load)) {
         aAlreadyFoundTop = PR_TRUE;
         aTopShownObject = walker;
       }
       if (!aAlreadyFoundTop && !walker->parent) {
-        aTopShownObject = walker;
+        // The mime part part_to_load is not a parent of the
+        // the crypto mime part passed in to this function as parameter obj.
+        // That means the crypto part belongs to another branch of the mime tree.
+        return -1;
       }
     }
   }
 
   PRBool CryptoObjectIsChildOfTopShownObject = PR_FALSE;
   if (!aTopShownObject) {
     // no sub part specified, top message is displayed, and
     // our crypto object is definitively a child of it
     CryptoObjectIsChildOfTopShownObject = PR_TRUE;
   }
 
   // if we are the child of the topmost message, aCryptoPartNestLevel == 1
   int aCryptoPartNestLevel = 0;
   if (obj) {
     for (MimeObject *walker = obj; walker; walker = walker->parent) {
       // Crypto mime objects are transparent wrt nesting.
       if (!mime_typep(walker, (MimeObjectClass *) &mimeEncryptedClass)
           && !mime_typep(walker, (MimeObjectClass *) &mimeMultipartSignedClass)) {
         ++aCryptoPartNestLevel;
       }
Index: mozilla/mailnews/mime/src/mimemcms.cpp
===================================================================
RCS file: /cvsroot/mozilla/mailnews/mime/src/mimemcms.cpp,v
retrieving revision 1.22
diff -u -u -2 -0 -r1.22 mimemcms.cpp
--- mozilla/mailnews/mime/src/mimemcms.cpp	10 Mar 2006 15:35:04 -0000	1.22
+++ mozilla/mailnews/mime/src/mimemcms.cpp	30 Mar 2006 11:37:24 -0000
@@ -455,40 +455,43 @@
 
   delete data;
 }
 
 static char *
 MimeMultCMS_generate (void *crypto_closure)
 {
   MimeMultCMSdata *data = (MimeMultCMSdata *) crypto_closure;
   PRBool signed_p = PR_TRUE;
   PRBool good_p = PR_FALSE;
   PRBool encrypted_p;
   PRBool unverified_p = PR_FALSE;
   nsresult rv;
   if (!data) return 0;
   encrypted_p = data->parent_is_encrypted_p;
   PRInt32 signature_status = nsICMSMessageErrors::GENERAL_ERROR;
   nsCOMPtr<nsIX509Cert> signerCert;
 
   int aRelativeNestLevel = MIMEGetRelativeCryptoNestLevel(data->self);
 
+  if (aRelativeNestLevel < 0)
+    return nsnull;
+
   unverified_p = data->self->options->missing_parts; 
 
   if (unverified_p)
   {
     // We were not given all parts of the message.
     // We are therefore unable to verify correctness of the signature.
     signature_status = nsICMSMessageErrors::VERIFY_NOT_YET_ATTEMPTED;
   }
   else
   if (data->content_info)
   {
     rv = data->content_info->VerifyDetachedSignature(data->item_data, data->item_len);
     data->content_info->GetSignerCert(getter_AddRefs(signerCert));
 
     if (NS_FAILED(rv)) {
       if (NS_ERROR_MODULE_SECURITY == NS_ERROR_GET_MODULE(rv)) {
         signature_status = NS_ERROR_GET_CODE(rv);
       }
       
       if (!data->verify_error) {
