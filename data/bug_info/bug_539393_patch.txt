diff --git a/js/src/xpconnect/src/XPCNativeWrapper.cpp b/js/src/xpconnect/src/XPCNativeWrapper.cpp
--- a/js/src/xpconnect/src/XPCNativeWrapper.cpp
+++ b/js/src/xpconnect/src/XPCNativeWrapper.cpp
@@ -283,16 +283,30 @@ RewrapIfDeepWrapper(JSContext *cx, JSObj
                                                           JS_GetScopeChain(cx),
                                                           nsnull);
     if (!wrapperObj) {
       return JS_FALSE;
     }
 
     *rval = OBJECT_TO_JSVAL(wrapperObj);
   } else {
+    if (!JSVAL_IS_PRIMITIVE(v)) {
+      JSObject *scope = JS_GetScopeChain(cx);
+      if (!scope) {
+        return JS_FALSE;
+      }
+
+      // NB: Because we're not a deep wrapper, we give a hint of SJOW to
+      // imitate not having a wrapper at all.
+      if (!RewrapObject(cx, JS_GetGlobalForObject(cx, scope),
+                        JSVAL_TO_OBJECT(v), SJOW, &v)) {
+        return JS_FALSE;
+      }
+    }
+
     *rval = v;
   }
 
   return JS_TRUE;
 }
 
 } // namespace XPCNativeWrapper
 
diff --git a/js/src/xpconnect/src/xpcwrappednativescope.cpp b/js/src/xpconnect/src/xpcwrappednativescope.cpp
--- a/js/src/xpconnect/src/xpcwrappednativescope.cpp
+++ b/js/src/xpconnect/src/xpcwrappednativescope.cpp
@@ -1131,14 +1131,17 @@ XPCWrappedNativeScope::GetWrapperFor(JSC
 #endif
             return COW; // NB: Ignore hint.
         }
     }
 
     if(!principalEqual ||
        XPCCrossOriginWrapper::ClassNeedsXOW(obj->getClass()->name))
     {
-        NS_ASSERTION(hint != SJOW, "shouldn't have a SJOW for cross origin access?");
+        // NB: We want to assert that hint is not SJOW here, but it can
+        // be because of shallow XPCNativeWrappers. In that case, XOW is
+        // the right return value because XPCNativeWrappers are meant for
+        // chrome, and we're in content which shouldn't expect SJOWs.
         return (hint & XPCNW) ? XPCNW_EXPLICIT : XOW;
     }
 
     return (hint & XPCNW) ? XPCNW_EXPLICIT : (hint == SJOW) ? SJOW : NONE;
 }
