Index: security/manager/ssl/src/nsNSSCallbacks.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSCallbacks.cpp,v
retrieving revision 1.43
diff -p -u -u -p -U10 -r1.43 nsNSSCallbacks.cpp
--- security/manager/ssl/src/nsNSSCallbacks.cpp	10 May 2006 17:29:56 -0000	1.43
+++ security/manager/ssl/src/nsNSSCallbacks.cpp	13 Jun 2006 20:06:27 -0000
@@ -56,20 +56,21 @@
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsCRT.h"
 #include "nsNSSShutDown.h"
 #include "nsIUploadChannel.h"
 #include "nsSSLThread.h"
 #include "nsThreadUtils.h"
 #include "nsAutoLock.h"
 #include "nsIThread.h"
 #include "nsIWindowWatcher.h"
 #include "nsIPrompt.h"
+#include "nsITokenPasswordDialogs.h"
 
 #include "ssl.h"
 #include "cert.h"
 #include "ocsp.h"
 
 static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
 
 struct nsHTTPDownloadEvent : nsRunnable {
   nsHTTPDownloadEvent();
   ~nsHTTPDownloadEvent();
@@ -611,87 +612,61 @@ nsSSLStatus::nsSSLStatus()
 NS_IMPL_THREADSAFE_ISUPPORTS1(nsSSLStatus, nsISSLStatus)
 
 nsSSLStatus::~nsSSLStatus()
 {
 }
 
 
 char* PR_CALLBACK
 PK11PasswordPrompt(PK11SlotInfo* slot, PRBool retry, void* arg) {
   nsNSSShutDownPreventionLock locker;
-  nsresult rv = NS_OK;
+  nsresult rv;
   PRUnichar *password = nsnull;
-  PRBool value = PR_FALSE;
+  PRBool cancelled = PR_TRUE;
   nsIInterfaceRequestor *ir = NS_STATIC_CAST(nsIInterfaceRequestor*, arg);
-  nsCOMPtr<nsIPrompt> proxyPrompt;
 
   // If no context is provided, no prompt is possible.
   if (!ir)
     return nsnull;
 
-  /* TODO: Retry should generate a different dialog message */
-/*
-  if (retry)
-    return nsnull;
-*/
-
   // The interface requestor object may not be safe, so
   // proxy the call to get the nsIPrompt.
-
   nsCOMPtr<nsIInterfaceRequestor> proxiedCallbacks;
-  NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
-                       NS_GET_IID(nsIInterfaceRequestor),
-                       ir,
-                       NS_PROXY_SYNC,
-                       getter_AddRefs(proxiedCallbacks));
-
-  // Get the desired interface
-  nsCOMPtr<nsIPrompt> prompt(do_GetInterface(proxiedCallbacks));
-  if (!prompt) {
-    NS_ASSERTION(PR_FALSE, "callbacks does not implement nsIPrompt");
-    return nsnull;
-  }
-
-  // Finally, get a proxy for the nsIPrompt
-  NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
-                       NS_GET_IID(nsIPrompt),
-                       prompt,
-                       NS_PROXY_SYNC,
-                       getter_AddRefs(proxyPrompt));
-
-  nsAutoString promptString;
-  nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
-
+  rv = NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
+			    NS_GET_IID(nsIInterfaceRequestor),
+			    ir,
+			    NS_PROXY_SYNC,
+			    getter_AddRefs(proxiedCallbacks));
   if (NS_FAILED(rv))
-    return nsnull; 
-
-  const PRUnichar* formatStrings[1] = { ToNewUnicode(NS_ConvertUTF8toUTF16(PK11_GetTokenName(slot))) };
-  rv = nssComponent->PIPBundleFormatStringFromName("CertPassPrompt",
-                                      formatStrings, 1,
-                                      promptString);
-  nsMemory::Free(NS_CONST_CAST(PRUnichar*, formatStrings[0]));
+    return nsnull;
 
+  /* Get the get password dialog handler imlementation */
+  nsCOMPtr<nsITokenPasswordDialogs> dialogs;
+  rv = getNSSDialogs(getter_AddRefs(dialogs),
+		     NS_GET_IID(nsITokenPasswordDialogs),
+		     NS_TOKENPASSWORDSDIALOG_CONTRACTID);
   if (NS_FAILED(rv))
     return nsnull;
 
   {
     nsPSMUITracker tracker;
     if (tracker.isUIForbidden()) {
       rv = NS_ERROR_NOT_AVAILABLE;
     }
     else {
-      rv = proxyPrompt->PromptPassword(nsnull, promptString.get(),
-                                       &password, nsnull, nsnull, &value);
+      NS_ConvertUTF8toUTF16 tokenName(PK11_GetTokenName(slot));
+      rv = dialogs->GetPassword(proxiedCallbacks, tokenName.get(),
+				&password, &cancelled);
     }
   }
-  
-  if (NS_SUCCEEDED(rv) && value) {
+
+  if (NS_SUCCEEDED(rv) && !cancelled) {
     char* str = ToNewUTF8String(nsDependentString(password));
     Recycle(password);
     return str;
   }
 
   return nsnull;
 }
 
 void PR_CALLBACK HandshakeCallback(PRFileDesc* fd, void* client_data) {
   nsNSSShutDownPreventionLock locker;
