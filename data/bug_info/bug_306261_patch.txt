Index: netwerk/protocol/about/public/Makefile.in
===================================================================
RCS file: /cvs/mozilla/netwerk/protocol/about/public/Makefile.in,v
retrieving revision 1.6
diff -p -u -1 -2 -r1.6 Makefile.in
--- netwerk/protocol/about/public/Makefile.in	5 Apr 2005 17:40:24 -0000	1.6
+++ netwerk/protocol/about/public/Makefile.in	13 Sep 2005 21:07:38 -0000
@@ -39,15 +39,17 @@ DEPTH		= ../../../..
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= necko
 XPIDL_MODULE	= necko_about
 GRE_MODULE	= 1
 
 XPIDLSRCS	= nsIAboutModule.idl
 
+EXPORTS		= nsAboutProtocolUtils.h
+
 include $(topsrcdir)/config/rules.mk
 
 DEFINES += -DIMPL_NS_NET
Index: netwerk/protocol/about/public/nsAboutProtocolUtils.h
===================================================================
RCS file: netwerk/protocol/about/public/nsAboutProtocolUtils.h
diff -N netwerk/protocol/about/public/nsAboutProtocolUtils.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ netwerk/protocol/about/public/nsAboutProtocolUtils.h	13 Sep 2005 21:44:46 -0000
@@ -0,0 +1,55 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsAboutProtocolUtils.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIURI.h"
+#include "nsString.h"
+#include "nsReadableUtils.h"
+
+inline nsresult
+NS_GetAboutModuleName(nsIURI *aAboutURI, nsCString& aModule)
+{
+    nsresult rv = aAboutURI->GetPath(aModule);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    PRInt32 f = aModule.FindCharInSet(NS_LITERAL_CSTRING("#?"));
+    if (f != kNotFound) {
+        aModule.Truncate(f);
+    }
+
+    // convert to lowercase, as all about: modules are lowercase
+    ToLowerCase(aModule);
+    return NS_OK;
+}
Index: netwerk/protocol/about/src/nsAboutProtocolHandler.cpp
===================================================================
RCS file: /cvs/mozilla/netwerk/protocol/about/src/nsAboutProtocolHandler.cpp,v
retrieving revision 1.39
diff -p -u -1 -2 -r1.39 nsAboutProtocolHandler.cpp
--- netwerk/protocol/about/src/nsAboutProtocolHandler.cpp	14 Jul 2005 17:46:54 -0000	1.39
+++ netwerk/protocol/about/src/nsAboutProtocolHandler.cpp	13 Sep 2005 21:44:47 -0000
@@ -37,24 +37,25 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsAboutProtocolHandler.h"
 #include "nsIURI.h"
 #include "nsIIOService.h"
 #include "nsCRT.h"
 #include "nsIComponentManager.h"
 #include "nsIServiceManager.h"
 #include "nsIAboutModule.h"
 #include "nsString.h"
 #include "nsReadableUtils.h"
 #include "nsNetCID.h"
+#include "nsAboutProtocolUtils.h"
 
 static NS_DEFINE_CID(kSimpleURICID,     NS_SIMPLEURI_CID);
 
 ////////////////////////////////////////////////////////////////////////////////
 
 nsAboutProtocolHandler::nsAboutProtocolHandler()
 {
 }
 
 nsresult
 nsAboutProtocolHandler::Init()
 {
@@ -122,47 +123,33 @@ nsAboutProtocolHandler::NewURI(const nsA
     if (NS_FAILED(rv)) return rv;
 
     rv = url->SetSpec(aSpec);
     if (NS_FAILED(rv)) {
         NS_RELEASE(url);
         return rv;
     }
 
     *result = url;
     return rv;
 }
 
-void
-nsAboutProtocolHandler::StripQueryAndHash(nsCString& aPath)
-{
-    PRInt32 f = aPath.FindCharInSet(NS_LITERAL_CSTRING("#?"));
-    if (f != kNotFound) {
-        aPath.Truncate(f);
-    }
-
-    // convert to lowercase, as all about: modules are lowercase
-    ToLowerCase(aPath);
-}
-
 NS_IMETHODIMP
 nsAboutProtocolHandler::NewChannel(nsIURI* uri, nsIChannel* *result)
 {
     // about:what you ask?
     nsresult rv;
     nsCAutoString contractID;
-    rv = uri->GetPath(contractID);
+    rv = NS_GetAboutModuleName(uri, contractID);
     if (NS_FAILED(rv)) return rv;
 
-    StripQueryAndHash(contractID);
-
     // look up a handler to deal with "what"
     contractID.Insert(NS_LITERAL_CSTRING(NS_ABOUT_MODULE_CONTRACTID_PREFIX), 0);
 
     nsCOMPtr<nsIAboutModule> aboutMod(do_GetService(contractID.get(), &rv));
     if (NS_SUCCEEDED(rv)) {
         // The standard return case:
         return aboutMod->NewChannel(uri, result);
     }
 
     // mumble...
 
     return rv;
Index: netwerk/protocol/about/src/nsAboutProtocolHandler.h
===================================================================
RCS file: /cvs/mozilla/netwerk/protocol/about/src/nsAboutProtocolHandler.h,v
retrieving revision 1.7
diff -p -u -1 -2 -r1.7 nsAboutProtocolHandler.h
--- netwerk/protocol/about/src/nsAboutProtocolHandler.h	14 Jul 2005 17:46:54 -0000	1.7
+++ netwerk/protocol/about/src/nsAboutProtocolHandler.h	13 Sep 2005 21:11:00 -0000
@@ -57,19 +57,15 @@ public:
 
     // nsIProtocolHandler methods:
     NS_DECL_NSIPROTOCOLHANDLER
 
     // nsAboutProtocolHandler methods:
     nsAboutProtocolHandler();
     virtual ~nsAboutProtocolHandler();
 
     static NS_METHOD
     Create(nsISupports *aOuter, REFNSIID aIID, void **aResult);
 
     nsresult Init();
-
-    static void StripQueryAndHash(nsCString& aPath);
-
-protected:
 };
 
 #endif /* nsAboutProtocolHandler_h___ */
Index: netwerk/protocol/about/src/nsAboutRedirector.cpp
===================================================================
RCS file: /cvs/mozilla/netwerk/protocol/about/src/nsAboutRedirector.cpp,v
retrieving revision 1.22
diff -p -u -1 -2 -r1.22 nsAboutRedirector.cpp
--- netwerk/protocol/about/src/nsAboutRedirector.cpp	14 Jul 2005 17:46:54 -0000	1.22
+++ netwerk/protocol/about/src/nsAboutRedirector.cpp	13 Sep 2005 21:44:52 -0000
@@ -33,24 +33,25 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsAboutProtocolHandler.h"
 #include "nsAboutRedirector.h"
 #include "nsNetUtil.h"
 #include "plstr.h"
 #include "nsIScriptSecurityManager.h"
+#include "nsAboutProtocolUtils.h"
 
 NS_IMPL_ISUPPORTS1(nsAboutRedirector, nsIAboutModule)
 
 struct RedirEntry {
     const char* id;
     const char* url;
     PRBool dropChromePrivs; // if PR_TRUE, the page will not have chrome privileges
 };
 
 /*
   Entries with dropChromePrivs == PR_FALSE will run with chrome
   privileges. This is potentially dangerous. Please use PR_TRUE
@@ -72,30 +73,28 @@ static RedirEntry kRedirMap[] = {
 };
 static const int kRedirTotal = NS_ARRAY_LENGTH(kRedirMap);
 
 NS_IMETHODIMP
 nsAboutRedirector::NewChannel(nsIURI *aURI, nsIChannel **result)
 {
     NS_ASSERTION(aURI, "must not be null");
     NS_ASSERTION(result, "must not be null");
 
     nsresult rv;
 
     nsCAutoString path;
-    rv = aURI->GetPath(path);
+    rv = NS_GetAboutModuleName(aURI, path);
     if (NS_FAILED(rv))
         return rv;
 
-    nsAboutProtocolHandler::StripQueryAndHash(path);
-
     nsCOMPtr<nsIIOService> ioService = do_GetIOService(&rv);
     if (NS_FAILED(rv))
         return rv;
 
     for (int i=0; i<kRedirTotal; i++) 
     {
         if (!strcmp(path.get(), kRedirMap[i].id))
         {
             nsCOMPtr<nsIChannel> tempChannel;
             rv = ioService->NewChannel(nsDependentCString(kRedirMap[i].url),
                                        nsnull, nsnull, getter_AddRefs(tempChannel));
             if (NS_FAILED(rv))
Index: caps/src/nsScriptSecurityManager.cpp
===================================================================
RCS file: /cvs/mozilla/caps/src/nsScriptSecurityManager.cpp,v
retrieving revision 1.273
diff -p -u -1 -2 -r1.273 nsScriptSecurityManager.cpp
--- caps/src/nsScriptSecurityManager.cpp	9 Sep 2005 18:43:45 -0000	1.273
+++ caps/src/nsScriptSecurityManager.cpp	13 Sep 2005 21:44:54 -0000
@@ -71,24 +71,25 @@
 #include "nsIDOMWindowInternal.h"
 #include "nsIDocShell.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsIPrompt.h"
 #include "nsIWindowWatcher.h"
 #include "nsIConsoleService.h"
 #include "nsISecurityCheckedComponent.h"
 #include "nsIPrefBranch2.h"
 #include "nsIJSRuntimeService.h"
 #include "nsIObserverService.h"
 #include "nsIContent.h"
 #include "nsAutoPtr.h"
+#include "nsAboutProtocolUtils.h"
 
 static NS_DEFINE_CID(kZipReaderCID, NS_ZIPREADER_CID);
 
 nsIIOService    *nsScriptSecurityManager::sIOService = nsnull;
 nsIXPConnect    *nsScriptSecurityManager::sXPConnect = nsnull;
 nsIStringBundle *nsScriptSecurityManager::sStrBundle = nsnull;
 JSRuntime       *nsScriptSecurityManager::sRuntime   = 0;
 
 ///////////////////////////
 // Convenience Functions //
 ///////////////////////////
 // Result of this function should not be freed.
@@ -1143,59 +1144,59 @@ nsScriptSecurityManager::GetBaseURISchem
                                           nsCString& aScheme)
 {
     if (!aURI)
        return NS_ERROR_FAILURE;
 
     nsresult rv;
 
     //-- get the source scheme
     rv = aURI->GetScheme(aScheme);
     if (NS_FAILED(rv)) return rv;
 
     //-- If aURI is a view-source URI, drill down to the base URI
-    nsCAutoString path;
     if (aScheme.EqualsLiteral("view-source"))
     {
+        nsCAutoString path;
         rv = aURI->GetPath(path);
         if (NS_FAILED(rv)) return rv;
         nsCOMPtr<nsIURI> innerURI;
         rv = NS_NewURI(getter_AddRefs(innerURI), path, nsnull, nsnull,
                        sIOService);
         if (NS_FAILED(rv)) return rv;
         return nsScriptSecurityManager::GetBaseURIScheme(innerURI, aScheme);
     }
 
     //-- If aURI is a jar URI, drill down again
     nsCOMPtr<nsIJARURI> jarURI = do_QueryInterface(aURI);
     if (jarURI)
     {
         nsCOMPtr<nsIURI> innerURI;
         jarURI->GetJARFile(getter_AddRefs(innerURI));
         if (!innerURI) return NS_ERROR_FAILURE;
         return nsScriptSecurityManager::GetBaseURIScheme(innerURI, aScheme);
     }
 
     //-- if aURI is an about uri, distinguish 'safe' and 'unsafe' about URIs
     if(aScheme.EqualsLiteral("about"))
     {
         nsCAutoString path;
-        if(NS_FAILED(aURI->GetPath(path)))
-            return NS_ERROR_FAILURE;
+        rv = NS_GetAboutModuleName(aURI, path);
+        NS_ENSURE_SUCCESS(rv, rv);
         if (path.EqualsLiteral("blank")   ||
             path.EqualsLiteral("mozilla") ||
             path.EqualsLiteral("logo")    ||
             path.EqualsLiteral("license") ||
             path.EqualsLiteral("licence") ||
             path.EqualsLiteral("credits") ||
-            Substring(path,0,9).EqualsLiteral("neterror?"))
+            path.EqualsLiteral("neterror"))
         {
             aScheme = NS_LITERAL_CSTRING("about safe");
             return NS_OK;
         }
     }
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsScriptSecurityManager::CheckLoadURI(nsIURI *aSourceURI, nsIURI *aTargetURI,
                                       PRUint32 aFlags)
