Please read this document first
  https://bugzilla.mozilla.org/attachment.cgi?id=209709
to understand the general idea of the patch.

The new SSL thread does not use a job queue, I use a very simple 
approach for the initial version.

When a request to read/write comes in, it is handed over
to the SSL thread, in variable mBusySocket.

Only one socket at a time can be in the possession of the SSL
thread. While the SSL thread is operating on it,
read/write requests for any other sockets will immediately
return with WOULD_BLOCK.

The calls to SSL read/write are non-blocking in general,
with the exception that some calls might block on OCSP or UI.

Details of the read/write request and its results need
to be transfered between Necko thread and SSL thread.

All additional state is stored in class nsSSLSocketThreadData.
Our existing class nsNSSSocketInfo of PSM's per-socket state 
information gets a new member mThreadData.

---------
Changes to file
mozilla/security/manager/ssl/src/nsNSSIOLayer.h

Please read the interface and comments of class nsSSLSocketThreadData

As Necko might request to close a socket while it's busy on the
SSL thread, we add a delayed close ability.

class nsSSLIOLayerHelpers looks new, but it is mostly
old stuff, that is now grouped and protected by a lock.

New is the shared pollable event.

mSocketOwningPollableEvent is used for assertion checking only.

----------
Changes to file
mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp

Mostly straightforward init/destruction code.

The existing functions that implement PSM's I/O layer
are changed to forward the call to a member function
in nsSSLThread.

They follow the naming convention nsSSLThread::request*,
like requestRead, requestPoll, etc.

Added a new Poll function, as the PSM layer might 
already have data ready for Necko, produced by the 
SSL thread, triggered by an earlier request from Necko 
to read or write, that was defered to the SSL thread.

Actual checks (GetCanceled(), etc.) 
and actual read/write calls to the SSL layer are removed from
here and added to the SSL thread code.

Removed FD layer function "available", it's never called.

---------
new file
mozilla/security/manager/ssl/src/nsSSLThread.h

Please read this file, it has a lot of comments.

Basically the thread has a mBusySocket member that it will
work with, if the mBusySocket->mThreadData->mSSLState
member says, there is work to be done by the thread.

We'll look at the pending HTTP request later.

---------
new file
mozilla/security/manager/ssl/src/nsSSLThread.cpp

This implements a new thread that will sit and wait
for signals (using a condition variable)
and work to be done.

The class is a singleton.

Please find and read the comment starting with
  "Remember we are operating on a layered file descriptor,"
which is inside nsSSLThread::requestRead,
which is being called on the Necko thread.

The comment explains how we use the pollable event.

Note there is just one pollable event, because users
with a personal firewall might see a warning each time
we create a pollable event, so we just create one
initially, and will reuse it for the whole lifetime
of the application session.

Let's look at nsSSLThread::Run(void)

It loops until it's requested to exit.

If Necko had requested to close a socket, while the SSL 
thread was operating on it, it will be closed here.

Look how we check for "pending_work" and wait if there is none.

If there is, we'll excute the read/write call on the SSL 
file descriptor layer and store the results in the socket's
thread data state object.

CheckHandshake is an old function that you can ignore,
it contains the logic, whether we run into some SSL protocol
incompatibility and whether we need to reset the connection
and try again with an older protocol.

Once we've obtained the result of the read/write call,
even if it's just the error code returned,
we'll signal the pollable event, to make Necko wake up.

Have a look at nsSSLThread::requestRead

When Necko requests us to read, there are multiple
possible scenarios what to do, based on what happened earlier.

If currently some other socket is busy on the SSL thread,
we'll return WOULD_BLOCK.

If the requested socket is the one currently marked as 
busy, let's check for more details in the mSSLState.

If a previous requested operation on this socket has not
yet been completed by the SSL thread, we return WOULD_BLOCK.

We might have produced the read results already,
and they might be ready to be returned.

Make sure we restore the original file descriptor layering
configuration (remove pollable event) if we haven't done yet.

Copy error code results and thread data buffer contents back to 
the caller's buffer.

Be safe, and allow a scenario, where Necko e.g. requested 
100 bytes in an earlier call, we obtained 100 bytes on the SSL
thread, and now Necko comes back to fetch our results,
but for some reason this time Necko asks for just 50 bytes.

We'll return the data requested in this call, and remain in
the readable state, and will return the remaining bytes
when Necko calls read next time.

If none of the above scenarios was true, we are asked to operate on
an idle socket and we need to transfer the request to the thread.

The isLoggedOut, GetCanceled sanity checks are old code,
and have been moved here.

Update mThreadData with the details of our new request,
prepare the file descriptor stacking to contain the pollable
event, set nsSSLThread::mBusySocket and signal the SSL thread
that work is available.

The requestWrite function is very similar to the read function.

nsSSLThread::requestPoll directs the call to the SSL level,
if we are not currently operating on this sockets,
or it will return information based on our state.

-----------
Until now, everything we saw were changes to uncouple 
Necko from SSL calls. We did this to make the following work
without blocking the application.

in
mozilla/security/manager/ssl/src/nsNSSComponent.cpp
and
mozilla/security/manager/ssl/src/nsNSSComponent.h

we init a function table that implements
the callback API desired by NSS, and register
ourselves (PSM) as a http client implementation

see
  mHttpForNSS.registerHttpClient();

-------
The code that implements NSS' http callback API
is contained here:

mozilla/security/manager/ssl/src/nsNSSCallbacks.h
mozilla/security/manager/ssl/src/nsNSSCallbacks.cpp

If you are interested in the details of the API,
you could read the comments in the patch attached
to bug 152426.

But in short, the API does not use URLs, but will provide
the URL pieces. We don't need to care why NSS prefers
to do it that way.

class nsNSSHttpInterface implements the various
functions the API describes and has small stub functions
to forward the calls to our implementation layer.

Basically there are several functions to prepare
the request, and one function that will trigger
the action - trySendAndReceiveFcn.

While the API in general supports nonblocking functionality,
at this time, we have implemented a blocking mode only.

That is, NSS will call into the trySendAndReceiveFcn
function, and we will not return to NSS until our results
are done.

We do this by kicking of a PL_Event to the UI event queue,
construct the URI, open a channel and asyncOpen it.
Then we'll wait until Necko has completed the request,
and then we'll finally return back to the caller (NSS).

class nsHTTPListener contains our helper code that will
receive result data from Necko.

NSS will specify a timeout on the HTTP data it's requesting,
and we might send a second event to the UI thread to cancel
the HTTP request, after the allowed time has passed.

This explains the mPendingHttpRequest member we saw earlier.
If we time out, we will cancel the HTTP request.

The NSS API defines a maximum HTTP result size acceptable
to the caller of the trySendAndReceive function.

The HTTP listener object will receive and store incoming
data, it will live as long as the RequestSession object
associated to the URL request, so we can return 
our result data back to NSS by reference.

--------
The above was sufficient to make the OCSP during network I/O
work. However, the application still blocked,
when a request for OCSP information was made from within the UI.

Specifically in file
  mozilla/security/manager/pki/resources/content/viewCertDetails.js
the call to
  cert.getUsagesArray
with OCSP enabled calls into NSS, which calls back into PSM,
which calls back into Necko, makes the application hang.

Therefore a new async certificate interface was introduced,
requestUsagesArrayAsync, and the UI code was changed to call it.

Have a look at the small changes in files
---------
mozilla/security/manager/ssl/src/nsNSSCertificate.h
mozilla/security/manager/ssl/src/nsNSSCertificate.cpp

A call to function RequestUsagesArrayAsync makes us allocate
a new job object and send it to yet another thread,
introduced by this patch.

The new thread is implemented in files 
--------
mozilla/security/manager/ssl/src/nsCertVerificationThread.cpp
mozilla/security/manager/ssl/src/nsCertVerificationThread.h

It's a simple thread.
It loops and waits on incoming job objects arriving in a 
queue container, will pop the jobs off the queue,
make a call to the old blocking verification API,
and once it's done, will notify the callback object
nsICertVerificationListener listed in the job object.

As the results need to be communicated back to JavaScript,
and as the function signature of existing function 
getUsagesArray looks difficult to send to JavaScript directly,
I decided to use yet another level of indirection.

When the result data is ready, a notification function
on a callback interface nsICertVerificationListener
will be called, but not yet deliver the results.

Instead, callback nsICertVerificationListener::notify
will provide a data object that implements interface
nsICertVerificationResult.

Once the JavaScript callback received the callback notification,
it makes a call on the nsICertVerificationResult object,
calling function getUsagesArray, that uses the same function
signature as it is used by the old, blocking interface.

How does the UI look like?

You go to a secure web page, you click page info, security tab,
and click the "view certificate" button.

The UI contents are updated immediately with most information,
except the data that needs to be obtained from OCSP.

At onLoad time the OCSP data will be requested asynchronously.

The user will see a window come up, and after a few moments,
as soon as the data from the OCSP server arrives,
the displayed window will update and additional rows of text
information appear dynamically in the window.

The getProxyOnUIThread code has been borrowed from
mailnews code.
