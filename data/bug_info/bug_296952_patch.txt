diff --git a/mail/base/content/phishingDetector.js b/mail/base/content/phishingDetector.js
--- a/mail/base/content/phishingDetector.js
+++ b/mail/base/content/phishingDetector.js
@@ -19,21 +19,21 @@ var gPhishingDetector = {
   shutdown: function()
   {
     try {
       this.mPhishingWarden.shutdown();
     } catch (ex) {}
   },
 
   /**
-   * initialize the phishing warden. 
-   * initialize the black and white list url tables. 
+   * initialize the phishing warden.
+   * initialize the black and white list url tables.
    * update the local tables if necessary
    */
-  init: function() 
+  init: function()
   {
     Components.utils.import("resource:///modules/hostnameUtils.jsm", this);
 
     try {
       // set up the anti phishing service
       var appContext = Components.classes["@mozilla.org/phishingprotection/application;1"]
                          .getService().wrappedJSObject;
 
@@ -41,32 +41,32 @@ var gPhishingDetector = {
 
       // Register tables
       // XXX: move table names to a pref that we originally will download
       // from the provider (need to workout protocol details)
       this.mPhishingWarden.registerWhiteTable("goog-white-exp");
       this.mPhishingWarden.registerBlackTable("goog-phish-sha128");
 
       // Download/update lists if we're in non-enhanced mode
-      this.mPhishingWarden.maybeToggleUpdateChecking();  
+      this.mPhishingWarden.maybeToggleUpdateChecking();
     } catch (ex) { dump('unable to create the phishing warden: ' + ex + '\n');}
 
     this.mCheckForIPAddresses = Services.prefs.getBoolPref("mail.phishing.detection.ipaddresses");
     this.mCheckForMismatchedHosts = Services.prefs.getBoolPref("mail.phishing.detection.mismatched_hosts");
   },
 
   /**
    * Analyzes the urls contained in the currently loaded message in the message pane, looking for
    * phishing URLs.
    * Assumes the message has finished loading in the message pane (i.e. OnMsgParsed has fired).
-   * 
+   *
    * @param aUrl nsIURI for the message being analyzed.
    *
    * @return asynchronously calls gMessageNotificationBar.setPhishingMsg if the message
-   *         is identified as a scam.         
+   *         is identified as a scam.
    */
   analyzeMsgForPhishingURLs: function (aUrl)
   {
     if (!aUrl || !Services.prefs.getBoolPref("mail.phishing.detection.enabled"))
       return;
 
     try {
       // nsIMsgMailNewsUrl.folder can throw an NS_ERROR_FAILURE, especially if
@@ -97,19 +97,19 @@ var gPhishingDetector = {
     // extract the action urls associated with any form elements in the message and analyze them.
     let formNodes = document.getElementById('messagepane').contentDocument.querySelectorAll("form[action]");
     for (index = 0; index < formNodes.length; index++)
     {
       this.analyzeUrl(formNodes[index].action);
     }
   },
 
-  /** 
+  /**
    * Analyze the url contained in aLinkNode for phishing attacks. If a phishing URL is found,
-   * 
+   *
    * @param aHref the url to be analyzed
    * @param aLinkText (optional) user visible link text associated with aHref in case
    *        we are dealing with a link node.
    * @return asynchronously calls gMessageNotificationBar.setPhishingMsg if the link node
    *         contains a phishing URL.
    */
   analyzeUrl: function (aUrl, aLinkText)
   {
@@ -160,25 +160,25 @@ var gPhishingDetector = {
                                        this.localListCallback);
       else
         this.localListCallback(gFolderDisplay.selectedMessage,
                                failsStaticTests, aUrl, 2 /* not found */);
     }
   },
 
   /**
-    * 
+    *
     * @param aMsgHdr the header for the loaded message when the look up was initiated.
     * @param aFailsStaticTests true if our static tests think the url is a phishing scam
     * @param aUrl the url we looked up in the phishing tables
     * @param aLocalListStatus the result of the local lookup (PROT_ListWarden.IN_BLACKLIST,
     *        PROT_ListWarden.IN_WHITELIST or PROT_ListWarden.NOT_FOUND.
     */
   localListCallback: function (aMsgHdr, aFailsStaticTests, aUrl, aLocalListStatus)
-  {  
+  {
     // for urls in the blacklist, notify the phishing bar.
     // for urls in the whitelist, do nothing
     // for all other urls, fall back to the static tests
     if (aMsgHdr == gFolderDisplay.selectedMessage)
     {
       if (aLocalListStatus == 0 /* PROT_ListWarden.IN_BLACKLIST */ ||
           (aLocalListStatus == 2 /* PROT_ListWarden.PROT_ListWarden.NOT_FOUND */ && aFailsStaticTests)) {
         gMessageNotificationBar.setPhishingMsg();
@@ -201,57 +201,65 @@ var gPhishingDetector = {
        reportUrl += "&url=" + encodeURIComponent(aPhishingURL);
        // now send the url to the default browser
 
        var uri = Services.io.newURI(reportUrl, null, null);
        var protocolSvc = Components.classes["@mozilla.org/uriloader/external-protocol-service;1"]
                          .getService(Components.interfaces.nsIExternalProtocolService);
        protocolSvc.loadUrl(uri);
      }
-   },   
+   },
 
   /**
    * Private helper method to determine if the link node contains a user visible
-   * url with a host name that differs from the actual href the user would get taken to.
+   * url with a host name that differs from the actual href the user would get
+   * taken to.
    * i.e. <a href="http://myevilsite.com">http://mozilla.org</a>
-   * 
+   *
    * @return true if aHrefURL.host does NOT match the host of the link node text
    */
   misMatchedHostWithLinkText: function(aHrefURL, aLinkNodeText)
   {
     // gatherTextUnder puts a space between each piece of text it gathers,
     // so strip the spaces out (see bug 326082 for details).
     aLinkNodeText = aLinkNodeText.replace(/ /g, "");
 
-    // only worry about http and https urls
-    if (aLinkNodeText)
+    // Only worry about http: and https: urls.
+    if (aLinkNodeText && aLinkNodeText.search(/(^https?:)/) != -1)
     {
-      // does the link text look like a http url?
-       if (aLinkNodeText.search(/(^http:|^https:)/) != -1)
-       {
-         let linkURI = Services.io.newURI(aLinkNodeText, null, null);
-         // compare hosts, but ignore possible www. prefix
-         return !(aHrefURL.host.replace(/^www\./, "") == linkURI.host.replace(/^www\./, ""));
-       }
+      let eTLD = Components.classes["@mozilla.org/network/effective-tld-service;1"]
+                           .getService(Components.interfaces.nsIEffectiveTLDService);
+
+      let linkTextURI = Services.io.newURI(aLinkNodeText, null, null);
+
+      // Compare the base domain of the href and the link text.
+      try {
+        return eTLD.getBaseDomain(aHrefURL) !=
+               eTLD.getBaseDomain(linkTextURI);
+      } catch (e) {
+        // If we throw above, one of the URIs probably has no TLD (e.g.
+        // http://localhost), so just check the entire host.
+        return aHrefURL.host != linkTextURI.host;
+      }
     }
 
     return false;
   },
 
   /**
    * If the current message has been identified as an email scam, prompts the user with a warning
    * before allowing the link click to be processed. The warning prompt includes the unobscured host name
    * of the http(s) url the user clicked on.
    *
-   * @param aUrl the url 
+   * @param aUrl the url
    * @return true if the link should be allowed to load
    */
   warnOnSuspiciousLinkClick: function(aUrl)
   {
-    // if the loaded message has been flagged as a phishing scam, 
+    // if the loaded message has been flagged as a phishing scam,
     if (!gMessageNotificationBar.isShowingJunkNotification())
       return true;
 
     var hrefURL;
     // make sure relative link urls don't make us bail out
     try {
       hrefURL = Services.io.newURI(aUrl, null, null);
     } catch(ex) { return false; }
@@ -262,17 +270,17 @@ var gPhishingDetector = {
       // unobscure the host name in case it's an encoded ip address..
       let unobscuredHostNameValue = this.isLegalIPAddress(hrefURL.host, true)
         || hrefURL.host;
 
       var brandShortName = document.getElementById("bundle_brand")
                                    .getString("brandShortName");
       var bundle = document.getElementById("bundle_messenger");
       var titleMsg = bundle.getString("confirmPhishingTitle");
-      var dialogMsg = bundle.getFormattedString("confirmPhishingUrl", 
+      var dialogMsg = bundle.getFormattedString("confirmPhishingUrl",
                         [brandShortName, unobscuredHostNameValue], 2);
 
       const nsIPS = Components.interfaces.nsIPromptService;
       return !Services.prompt.confirmEx(window, titleMsg, dialogMsg,
                                         nsIPS.STD_YES_NO_BUTTONS +
                                         nsIPS.BUTTON_POS_1_DEFAULT,
                                         "", "", "", "", {}); /* the yes button is in position 0 */
     }
diff --git a/mail/test/mozmill/message-header/test-phishing-bar.js b/mail/test/mozmill/message-header/test-phishing-bar.js
--- a/mail/test/mozmill/message-header/test-phishing-bar.js
+++ b/mail/test/mozmill/message-header/test-phishing-bar.js
@@ -32,16 +32,28 @@ function setupModule(module) {
     body: '<a href="http://www.evil.com/google/">http://www.google.com</a>',
     contentType: "text/html"
   }}));
   add_message_to_folder(folder, create_message());
   add_message_to_folder(folder, create_message({body: {
     body: 'check out http://130.128.4.1. and http://130.128.4.2/.',
     contentType: "text/plain"
   }}));
+  add_message_to_folder(folder, create_message({body: {
+    body: '<a href="http://subdomain.google.com/">http://www.google.com</a>.',
+    contentType: "text/html"
+  }}));
+  add_message_to_folder(folder, create_message({body: {
+    body: '<a href="http://subdomain.google.com/">http://google.com</a>.',
+    contentType: "text/html"
+  }}));
+  add_message_to_folder(folder, create_message({body: {
+    body: '<a href="http://evilhost">http://localhost</a>.',
+    contentType: "text/html"
+  }}));
 }
 
 /**
  * Make sure the notification shows, and goes away once the Ignore menuitem
  * is clicked.
  */
 function assert_ignore_works(aController) {
   wait_for_notification_to_show(aController, kBoxId, kNotificationValue);
@@ -111,9 +123,35 @@ function test_ignore_phishing_warning_fr
  * get a warning. We'll have http://130.128.4.1 vs. http://130.128.4.1/
  */
 function test_no_phishing_warning_for_ip_sameish_text() {
   be_in_folder(folder);
   select_click_row(2); // Mail with Public IP address.
   assert_notification_displayed(mc, kBoxId, kNotificationValue, false); // not shown
 }
 
+/**
+ * Test that when viewing a message with a link whose base domain matches but
+ * has a different subdomain (e.g. http://subdomain.google.com/ vs
+ * http://google.com/), we don't get a warning.
+ */
+function test_no_phishing_warning_for_subdomain() {
+  be_in_folder(folder);
+  select_click_row(3);
+  assert_notification_displayed(mc, kBoxId, kNotificationValue, false); // not shown
 
+  select_click_row(4);
+  assert_notification_displayed(mc, kBoxId, kNotificationValue, false); // not shown
+}
+
+/**
+ * Test that when viewing a message with a link where the text and/or href
+ * has no TLD, we still warn as appropriate.
+ */
+function test_phishing_warning_for_local_domain() {
+  be_in_folder(folder);
+  select_click_row(5);
+  assert_notification_displayed(mc, kBoxId, kNotificationValue, true); // shown
+}
+
+
+
+
