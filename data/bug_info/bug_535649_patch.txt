diff --git a/netwerk/base/public/security-prefs.js b/netwerk/base/public/security-prefs.js
--- a/netwerk/base/public/security-prefs.js
+++ b/netwerk/base/public/security-prefs.js
@@ -1,15 +1,20 @@
 pref("general.useragent.security",       "U");
 
 pref("security.enable_ssl2",             false);
 pref("security.enable_ssl3",             true);
 pref("security.enable_tls",		 true);
 pref("security.enable_tls_session_tickets", true);
 
+pref("security.ssl.allow_unrestricted_renego_everywhere__temporarily_available_pref", false);
+pref("security.ssl.renego_unrestricted_hosts", "");
+pref("security.ssl.treat_unsafe_negotiation_as_broken", false);
+pref("security.ssl.require_safe_negotiation",  false);
+
 pref("security.ssl2.rc4_128", false);
 pref("security.ssl2.rc2_128", false);
 pref("security.ssl2.des_ede3_192", false);
 pref("security.ssl2.des_64", false);
 pref("security.ssl2.rc4_40", false);
 pref("security.ssl2.rc2_40", false);
 pref("security.ssl3.rsa_rc4_128_md5", true);
 pref("security.ssl3.rsa_rc4_128_sha", true);
diff --git a/security/manager/ssl/src/nsNSSCallbacks.cpp b/security/manager/ssl/src/nsNSSCallbacks.cpp
--- a/security/manager/ssl/src/nsNSSCallbacks.cpp
+++ b/security/manager/ssl/src/nsNSSCallbacks.cpp
@@ -64,16 +64,17 @@
 #include "nsIUploadChannel.h"
 #include "nsSSLThread.h"
 #include "nsThreadUtils.h"
 #include "nsAutoLock.h"
 #include "nsIThread.h"
 #include "nsIWindowWatcher.h"
 #include "nsIPrompt.h"
 #include "nsProxyRelease.h"
+#include "nsIConsoleService.h"
 
 #include "ssl.h"
 #include "cert.h"
 #include "ocsp.h"
 #include "nssb64.h"
 
 static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
 NSSCleanupAutoPtrClass(CERTCertificate, CERT_DestroyCertificate)
@@ -866,16 +867,38 @@ void PR_CALLBACK HandshakeCallback(PRFil
     secStatus = nsIWebProgressListener::STATE_IS_BROKEN;
   else if (encryptBits >= 90)
     secStatus = (nsIWebProgressListener::STATE_IS_SECURE |
                  nsIWebProgressListener::STATE_SECURE_HIGH);
   else
     secStatus = (nsIWebProgressListener::STATE_IS_SECURE |
                  nsIWebProgressListener::STATE_SECURE_LOW);
 
+  PRBool siteSupportsSafeRenego;
+  if (SSL_HandshakeNegotiatedExtension(fd, ssl_renegotiation_info_xtn, &siteSupportsSafeRenego) != SECSuccess
+      || !siteSupportsSafeRenego) {
+
+    nsNSSSocketInfo* infoObject = (nsNSSSocketInfo*) fd->higher->secret;
+    nsCOMPtr<nsIConsoleService> console(do_GetService(NS_CONSOLESERVICE_CONTRACTID));
+    if (infoObject && console) {
+      nsXPIDLCString hostName;
+      infoObject->GetHostName(getter_Copies(hostName));
+
+      nsAutoString msg;
+      msg.Append(NS_ConvertASCIItoUTF16(hostName));
+      msg.Append(NS_LITERAL_STRING(" : potentially vulnerable to CVE-2009-3555"));
+
+      console->LogStringMessage(msg.get());
+    }
+    if (nsSSLIOLayerHelpers::treatUnsafeNegotiationAsBroken()) {
+      secStatus = nsIWebProgressListener::STATE_IS_BROKEN;
+    }
+  }
+
+
   CERTCertificate *peerCert = SSL_PeerCertificate(fd);
   const char* caName = nsnull; // caName is a pointer only, no ownership
   char* certOrgName = CERT_GetOrgName(&peerCert->issuer);
   CERT_DestroyCertificate(peerCert);
   caName = certOrgName ? certOrgName : signer;
 
   const char* verisignName = "Verisign, Inc.";
   // If the CA name is RSA Data Security, then change the name to the real
diff --git a/security/manager/ssl/src/nsNSSComponent.cpp b/security/manager/ssl/src/nsNSSComponent.cpp
--- a/security/manager/ssl/src/nsNSSComponent.cpp
+++ b/security/manager/ssl/src/nsNSSComponent.cpp
@@ -1688,16 +1688,25 @@ nsNSSComponent::InitializeNSS(PRBool sho
       SSL_OptionSetDefault(SSL_ENABLE_SSL3, enabled);
       mPrefBranch->GetBoolPref("security.enable_tls", &enabled);
       SSL_OptionSetDefault(SSL_ENABLE_TLS, enabled);
 
       // Configure TLS session tickets
       mPrefBranch->GetBoolPref("security.enable_tls_session_tickets", &enabled);
       SSL_OptionSetDefault(SSL_ENABLE_SESSION_TICKETS, enabled);
 
+      mPrefBranch->GetBoolPref("security.ssl.require_safe_negotiation", &enabled);
+      SSL_OptionSetDefault(SSL_REQUIRE_SAFE_NEGOTIATION, enabled);
+
+      mPrefBranch->GetBoolPref(
+        "security.ssl.allow_unrestricted_renego_everywhere__temporarily_available_pref", 
+        &enabled);
+      SSL_OptionSetDefault(SSL_ENABLE_RENEGOTIATION, 
+        enabled ? SSL_RENEGOTIATE_UNRESTRICTED : SSL_RENEGOTIATE_REQUIRES_XTN);
+
       // Disable any ciphers that NSS might have enabled by default
       for (PRUint16 i = 0; i < SSL_NumImplementedCiphers; ++i)
       {
         PRUint16 cipher_id = SSL_ImplementedCiphers[i];
         SSL_CipherPrefSetDefault(cipher_id, PR_FALSE);
       }
 
       // Now only set SSL/TLS ciphers we knew about at compile time
@@ -1848,17 +1857,28 @@ nsNSSComponent::Init()
     PR_LOG(gPIPNSSLog, PR_LOG_ERROR, ("Unable to Initialize NSS.\n"));
 
     DeregisterObservers();
     mPIPNSSBundle = nsnull;
     return rv;
   }
 
   nsSSLIOLayerHelpers::Init();
-
+  char *unrestricted_hosts=nsnull;
+  mPrefBranch->GetCharPref("security.ssl.renego_unrestricted_hosts", &unrestricted_hosts);
+  if (unrestricted_hosts) {
+    nsSSLIOLayerHelpers::setRenegoUnrestrictedSites(nsDependentCString(unrestricted_hosts));
+    nsMemory::Free(unrestricted_hosts);
+    unrestricted_hosts=nsnull;
+  }
+
+  PRBool enabled = PR_FALSE;
+  mPrefBranch->GetBoolPref("security.ssl.treat_unsafe_negotiation_as_broken", &enabled);
+  nsSSLIOLayerHelpers::setTreatUnsafeNegotiationAsBroken(enabled);
+  
   mClientAuthRememberService = new nsClientAuthRememberService;
   if (mClientAuthRememberService)
     mClientAuthRememberService->Init();
 
   mSSLThread = new nsSSLThread();
   if (mSSLThread)
     mSSLThread->startThread();
   mCertVerificationThread = new nsCertVerificationThread();
@@ -2179,16 +2199,33 @@ nsNSSComponent::Observe(nsISupports *aSu
       clearSessionCache = PR_TRUE;
     } else if (prefName.Equals("security.enable_tls")) {
       mPrefBranch->GetBoolPref("security.enable_tls", &enabled);
       SSL_OptionSetDefault(SSL_ENABLE_TLS, enabled);
       clearSessionCache = PR_TRUE;
     } else if (prefName.Equals("security.enable_tls_session_tickets")) {
       mPrefBranch->GetBoolPref("security.enable_tls_session_tickets", &enabled);
       SSL_OptionSetDefault(SSL_ENABLE_SESSION_TICKETS, enabled);
+    } else if (prefName.Equals("security.ssl.require_safe_negotiation")) {
+      mPrefBranch->GetBoolPref("security.ssl.require_safe_negotiation", &enabled);
+      SSL_OptionSetDefault(SSL_REQUIRE_SAFE_NEGOTIATION, enabled);
+    } else if (prefName.Equals("security.ssl.allow_unrestricted_renego_everywhere__temporarily_available_pref")) {
+      mPrefBranch->GetBoolPref("security.ssl.allow_unrestricted_renego_everywhere__temporarily_available_pref", &enabled);
+      SSL_OptionSetDefault(SSL_ENABLE_RENEGOTIATION, 
+        enabled ? SSL_RENEGOTIATE_UNRESTRICTED : SSL_RENEGOTIATE_REQUIRES_XTN);
+    } else if (prefName.Equals("security.ssl.renego_unrestricted_hosts")) {
+      char *unrestricted_hosts=nsnull;
+      mPrefBranch->GetCharPref("security.ssl.renego_unrestricted_hosts", &unrestricted_hosts);
+      if (unrestricted_hosts) {
+        nsSSLIOLayerHelpers::setRenegoUnrestrictedSites(nsDependentCString(unrestricted_hosts));
+        nsMemory::Free(unrestricted_hosts);
+      }
+    } else if (prefName.Equals("security.ssl.treat_unsafe_negotiation_as_broken")) {
+      mPrefBranch->GetBoolPref("security.ssl.treat_unsafe_negotiation_as_broken", &enabled);
+      nsSSLIOLayerHelpers::setTreatUnsafeNegotiationAsBroken(enabled);
     } else if (prefName.Equals("security.OCSP.enabled")
                || prefName.Equals("security.OCSP.require")) {
       setOCSPOptions(mPrefBranch);
     } else {
       /* Look through the cipher table and set according to pref setting */
       for (CipherPref* cp = CipherPrefs; cp->pref; ++cp) {
         if (prefName.Equals(cp->pref)) {
           mPrefBranch->GetBoolPref(cp->pref, &enabled);
diff --git a/security/manager/ssl/src/nsNSSIOLayer.cpp b/security/manager/ssl/src/nsNSSIOLayer.cpp
--- a/security/manager/ssl/src/nsNSSIOLayer.cpp
+++ b/security/manager/ssl/src/nsNSSIOLayer.cpp
@@ -82,16 +82,17 @@
 #include "nsThreadUtils.h"
 #include "nsIDocShell.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsISecureBrowserUI.h"
 #include "nsProxyRelease.h"
 #include "nsIClassInfoImpl.h"
 #include "nsIProgrammingLanguage.h"
 #include "nsIArray.h"
+#include "nsCommaSeparatedTokenizer.h"
 
 #include "ssl.h"
 #include "secerr.h"
 #include "sslerr.h"
 #include "secder.h"
 #include "secasn1.h"
 #include "certdb.h"
 #include "cert.h"
@@ -832,16 +833,21 @@ void nsSSLIOLayerHelpers::Cleanup()
     mTLSIntolerantSites = nsnull;
   }
 
   if (mTLSTolerantSites) {
     delete mTLSTolerantSites;
     mTLSTolerantSites = nsnull;
   }
 
+  if (mRenegoUnrestrictedSites) {
+    delete mRenegoUnrestrictedSites;
+    mRenegoUnrestrictedSites = nsnull;
+  }
+
   if (mSharedPollableEvent)
     PR_DestroyPollableEvent(mSharedPollableEvent);
 
   if (mutex) {
     PR_DestroyLock(mutex);
     mutex = nsnull;
   }
 
@@ -1981,16 +1987,18 @@ nsSSLIOLayerPoll(PRFileDesc *fd, PRInt16
 
 PRBool nsSSLIOLayerHelpers::nsSSLIOLayerInitialized = PR_FALSE;
 PRDescIdentity nsSSLIOLayerHelpers::nsSSLIOLayerIdentity;
 PRIOMethods nsSSLIOLayerHelpers::nsSSLIOLayerMethods;
 PRLock *nsSSLIOLayerHelpers::mutex = nsnull;
 nsCStringHashSet *nsSSLIOLayerHelpers::mTLSIntolerantSites = nsnull;
 nsCStringHashSet *nsSSLIOLayerHelpers::mTLSTolerantSites = nsnull;
 nsPSMRememberCertErrorsTable *nsSSLIOLayerHelpers::mHostsWithCertErrors = nsnull;
+nsCStringHashSet *nsSSLIOLayerHelpers::mRenegoUnrestrictedSites = nsnull;
+PRBool nsSSLIOLayerHelpers::mTreatUnsafeNegotiationAsBroken = PR_FALSE;
 PRFileDesc *nsSSLIOLayerHelpers::mSharedPollableEvent = nsnull;
 nsNSSSocketInfo *nsSSLIOLayerHelpers::mSocketOwningPollableEvent = nsnull;
 PRBool nsSSLIOLayerHelpers::mPollableEventCurrentlySet = PR_FALSE;
 
 static PRIntn _PSM_InvalidInt(void)
 {
     PR_ASSERT(!"I/O method is invalid");
     PR_SetError(PR_INVALID_METHOD_ERROR, 0);
@@ -2199,16 +2207,24 @@ nsresult nsSSLIOLayerHelpers::Init()
   if (!mTLSTolerantSites)
     return NS_ERROR_OUT_OF_MEMORY;
 
   // Initialize the tolerant site hashtable to 16 items at the start seems
   // reasonable as most servers are TLS tolerant. We just want to lower 
   // the rate of hashtable array reallocation.
   mTLSTolerantSites->Init(16);
 
+  mRenegoUnrestrictedSites = new nsCStringHashSet();
+  if (!mRenegoUnrestrictedSites)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  mRenegoUnrestrictedSites->Init(1);
+
+  mTreatUnsafeNegotiationAsBroken = PR_FALSE;
+  
   mHostsWithCertErrors = new nsPSMRememberCertErrorsTable();
   if (!mHostsWithCertErrors || !mHostsWithCertErrors->mErrorHosts.IsInitialized())
     return NS_ERROR_OUT_OF_MEMORY;
 
   return NS_OK;
 }
 
 void nsSSLIOLayerHelpers::addIntolerantSite(const nsCString &str)
@@ -2226,16 +2242,59 @@ void nsSSLIOLayerHelpers::removeIntolera
 }
 
 PRBool nsSSLIOLayerHelpers::isKnownAsIntolerantSite(const nsCString &str)
 {
   nsAutoLock lock(mutex);
   return mTLSIntolerantSites->Contains(str);
 }
 
+void nsSSLIOLayerHelpers::setRenegoUnrestrictedSites(const nsCString &str)
+{
+  nsAutoLock lock(mutex);
+  
+  if (mRenegoUnrestrictedSites) {
+    delete mRenegoUnrestrictedSites;
+    mRenegoUnrestrictedSites = nsnull;
+  }
+
+  mRenegoUnrestrictedSites = new nsCStringHashSet();
+  if (!mRenegoUnrestrictedSites)
+    return;
+  
+  mRenegoUnrestrictedSites->Init(1);
+  
+  nsCCommaSeparatedTokenizer toker(str);
+
+  while (toker.hasMoreTokens()) {
+    const nsCSubstring &host = toker.nextToken();
+    if (!host.IsEmpty()) {
+      mRenegoUnrestrictedSites->Put(host);
+    }
+  }
+}
+
+PRBool nsSSLIOLayerHelpers::isRenegoUnrestrictedSite(const nsCString &str)
+{
+  nsAutoLock lock(mutex);
+  return mRenegoUnrestrictedSites->Contains(str);
+}
+
+void nsSSLIOLayerHelpers::setTreatUnsafeNegotiationAsBroken(PRBool broken)
+{
+  nsAutoLock lock(mutex);
+  mTreatUnsafeNegotiationAsBroken = broken;
+}
+
+PRBool nsSSLIOLayerHelpers::treatUnsafeNegotiationAsBroken()
+{
+  nsAutoLock lock(mutex);
+  return mTreatUnsafeNegotiationAsBroken;
+}
+
 nsresult
 nsSSLIOLayerNewSocket(PRInt32 family,
                       const char *host,
                       PRInt32 port,
                       const char *proxyHost,
                       PRInt32 proxyPort,
                       PRFileDesc **fd,
                       nsISupports** info,
@@ -3518,16 +3577,25 @@ nsSSLIOLayerSetOptions(PRFileDesc *fd, P
 
   if (SECSuccess != SSL_OptionSet(fd, SSL_HANDSHAKE_AS_CLIENT, PR_TRUE)) {
     return NS_ERROR_FAILURE;
   }
   if (SECSuccess != SSL_BadCertHook(fd, (SSLBadCertHandler) nsNSSBadCertHandler,
                                     infoObject)) {
     return NS_ERROR_FAILURE;
   }
+  
+  if (nsSSLIOLayerHelpers::isRenegoUnrestrictedSite(nsDependentCString(host))) {
+    if (SECSuccess != SSL_OptionSet(fd, SSL_REQUIRE_SAFE_NEGOTIATION, PR_FALSE)) {
+      return NS_ERROR_FAILURE;
+    }
+    if (SECSuccess != SSL_OptionSet(fd, SSL_ENABLE_RENEGOTIATION, SSL_RENEGOTIATE_UNRESTRICTED)) {
+      return NS_ERROR_FAILURE;
+    }
+  }
 
   // Set the Peer ID so that SSL proxy connections work properly.
   char *peerId;
   if (anonymousLoad) {  // See bug #466080. Separate the caches.
       peerId = PR_smprintf("anon:%s:%d", host, port);
   } else {
       peerId = PR_smprintf("%s:%d", host, port);
   }
diff --git a/security/manager/ssl/src/nsNSSIOLayer.h b/security/manager/ssl/src/nsNSSIOLayer.h
--- a/security/manager/ssl/src/nsNSSIOLayer.h
+++ b/security/manager/ssl/src/nsNSSIOLayer.h
@@ -281,25 +281,34 @@ public:
   static PRBool nsSSLIOLayerInitialized;
   static PRDescIdentity nsSSLIOLayerIdentity;
   static PRIOMethods nsSSLIOLayerMethods;
 
   static PRLock *mutex;
   static nsCStringHashSet *mTLSIntolerantSites;
   static nsCStringHashSet *mTLSTolerantSites;
   static nsPSMRememberCertErrorsTable* mHostsWithCertErrors;
-  
+
+  static nsCStringHashSet *mRenegoUnrestrictedSites;
+  static PRBool mTreatUnsafeNegotiationAsBroken;
+
+  static void setTreatUnsafeNegotiationAsBroken(PRBool broken);
+  static PRBool treatUnsafeNegotiationAsBroken();
+
   static void getSiteKey(nsNSSSocketInfo *socketInfo, nsCSubstring &key);
   static PRBool rememberPossibleTLSProblemSite(PRFileDesc* fd, nsNSSSocketInfo *socketInfo);
   static void rememberTolerantSite(PRFileDesc* ssl_layer_fd, nsNSSSocketInfo *socketInfo);
 
   static void addIntolerantSite(const nsCString &str);
   static void removeIntolerantSite(const nsCString &str);
   static PRBool isKnownAsIntolerantSite(const nsCString &str);
-  
+
+  static void setRenegoUnrestrictedSites(const nsCString &str);
+  static PRBool isRenegoUnrestrictedSite(const nsCString &str);
+
   static PRFileDesc *mSharedPollableEvent;
   static nsNSSSocketInfo *mSocketOwningPollableEvent;
   
   static PRBool mPollableEventCurrentlySet;
 };
 
 nsresult nsSSLIOLayerNewSocket(PRInt32 family,
                                const char *host,
