diff --git a/dom/src/base/nsDOMClassInfo.cpp b/dom/src/base/nsDOMClassInfo.cpp
--- a/dom/src/base/nsDOMClassInfo.cpp
+++ b/dom/src/base/nsDOMClassInfo.cpp
@@ -474,10 +474,6 @@ static const char kDOMStringBundleURL[] 
 #define ELEMENT_SCRIPTABLE_FLAGS                                              \
   (NODE_SCRIPTABLE_FLAGS & ~nsIXPCScriptable::CLASSINFO_INTERFACES_ONLY)
 
-#define FRAME_ELEMENT_SCRIPTABLE_FLAGS                                        \
-  (ELEMENT_SCRIPTABLE_FLAGS |                                                 \
-   nsIXPCScriptable::WANT_DELPROPERTY)
-
 #define EXTERNAL_OBJ_SCRIPTABLE_FLAGS                                         \
   (ELEMENT_SCRIPTABLE_FLAGS & ~nsIXPCScriptable::USE_JSSTUB_FOR_SETPROPERTY | \
    nsIXPCScriptable::WANT_GETPROPERTY |                                       \
@@ -682,8 +678,8 @@ static nsDOMClassInfoData sClassInfoData
                            ELEMENT_SCRIPTABLE_FLAGS |
                            nsIXPCScriptable::WANT_GETPROPERTY |
                            nsIXPCScriptable::WANT_NEWENUMERATE)
-  NS_DEFINE_CLASSINFO_DATA(HTMLFrameElement, nsHTMLFrameElementSH,
-                           FRAME_ELEMENT_SCRIPTABLE_FLAGS)
+  NS_DEFINE_CLASSINFO_DATA(HTMLFrameElement, nsHTMLElementSH,
+                           ELEMENT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(HTMLFrameSetElement, nsHTMLElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(HTMLHRElement, nsHTMLElementSH,
@@ -694,8 +690,8 @@ static nsDOMClassInfoData sClassInfoData
                            ELEMENT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(HTMLHtmlElement, nsHTMLElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)
-  NS_DEFINE_CLASSINFO_DATA(HTMLIFrameElement, nsHTMLFrameElementSH,
-                           FRAME_ELEMENT_SCRIPTABLE_FLAGS)
+  NS_DEFINE_CLASSINFO_DATA(HTMLIFrameElement, nsHTMLElementSH,
+                           ELEMENT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(HTMLImageElement, nsHTMLElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(HTMLInputElement, nsHTMLElementSH,
@@ -3953,147 +3949,7 @@ nsDOMClassInfo::ShutDown()
   sIsInitialized = PR_FALSE;
 }
 
-
-static const nsIXPConnectWrappedNative *cached_win_wrapper;
-static const JSContext *cached_win_cx;
-static PRBool cached_win_needs_check = PR_TRUE;
-static const nsIXPConnectWrappedNative *cached_doc_wrapper;
-static const JSContext *cached_doc_cx;
-static PRBool cached_doc_needs_check = PR_TRUE;
-
-
-void InvalidateContextAndWrapperCache()
-{
-  cached_win_wrapper = nsnull;
-  cached_doc_wrapper = nsnull;
-  cached_win_cx = nsnull;
-  cached_doc_cx = nsnull;
-  cached_win_needs_check = PR_TRUE;
-  cached_doc_needs_check = PR_TRUE;
-}
-
-// static helper that determines if a security manager check is needed
-// by checking if the callee's context is the same as the caller's
-// context
-// Note: See documentNeedsSecurityCheck for information about the control
-// flow in this function.
-
-static inline PRBool
-needsSecurityCheck(JSContext *cx, nsIXPConnectWrappedNative *wrapper)
-{
-  // We cache a pointer to a wrapper and a context that we've last vetted
-  // and cache what the verdict was.
-
-  // First, compare the context and wrapper with the cached ones
-  if (cx == cached_win_cx && wrapper == cached_win_wrapper) {
-    return cached_win_needs_check;
-  }
-
-  cached_win_cx = cx;
-  cached_win_wrapper = wrapper;
-  cached_win_needs_check = PR_TRUE;
-  
-  nsCOMPtr<nsIScriptGlobalObject> sgo(do_QueryWrappedNative(wrapper));
-
-  if (!sgo) {
-    NS_ERROR("Huh, global not a nsIScriptGlobalObject?");
-
-    return PR_TRUE;
-  }
-
-  nsIScriptContext *otherScriptContext = sgo->GetContext();
-
-  if (!otherScriptContext) {
-    return PR_TRUE;
-  }
-
-  if (cx != (JSContext *)otherScriptContext->GetNativeContext()) {
-    return PR_TRUE;
-  }
-
-  // Compare the current context and function object
-  // to the ones in the next JS frame
-  JSStackFrame *fp = nsnull;
-  JSObject *fp_obj = nsnull;
-
-  cached_win_needs_check = PR_FALSE;
-
-  do {
-    fp = ::JS_FrameIterator(cx, &fp);
-
-    if (!fp) {
-      cached_win_cx = nsnull;
-      return cached_win_needs_check;
-    }
-
-    fp_obj = ::JS_GetFrameFunctionObject(cx, fp);
-    cached_win_needs_check = PR_TRUE;
-  } while (!fp_obj);
-
-  JSObject *global = GetGlobalJSObject(cx, fp_obj);
-
-  JSObject *wrapper_obj = nsnull;
-  wrapper->GetJSObject(&wrapper_obj);
-
-  if (global != wrapper_obj) {
-    return PR_TRUE;
-  }
-
-  cached_win_needs_check = PR_FALSE;
-  return PR_FALSE;
-}
-
-
 // Window helper
-
-nsresult
-nsDOMClassInfo::doCheckPropertyAccess(JSContext *cx, JSObject *obj, jsval id,
-                                      nsIXPConnectWrappedNative *wrapper,
-                                      PRUint32 accessMode, PRBool isWindow)
-{
-  if (!sSecMan) {
-    return NS_OK;
-  }
-
-  nsISupports *native = wrapper->Native();
-  nsCOMPtr<nsIScriptGlobalObject> sgo;
-
-  if (isWindow) {
-    sgo = do_QueryInterface(native);
-    NS_ENSURE_TRUE(sgo, NS_ERROR_UNEXPECTED);
-  } else {
-    nsCOMPtr<nsIDocument> doc(do_QueryInterface(native));
-    NS_ENSURE_TRUE(doc, NS_ERROR_UNEXPECTED);
-
-    sgo = doc->GetScriptGlobalObject();
-
-    if (!sgo) {
-      // There's no script global in the document. This means that
-      // this document is a result from using XMLHttpRequest or it's a
-      // document created through a DOMImplementation. In that case
-      // there's nothing we can do since the context on which the
-      // document was created is not accessible and we can't do a
-      // security check, but the document must remain
-      // scriptable. Documents loaded through these methods have
-      // already been vetted by the security manager before they were
-      // loaded, so allowing access here w/o doing a security check
-      // here is probably safe anyway.
-
-      return NS_OK;
-    }
-  }
-
-  nsIScriptContext *scx = sgo->GetContext();
-  JSObject *global;
-
-  if (!scx || !scx->IsContextInitialized() ||
-      !(global = sgo->GetGlobalJSObject())) {
-    return NS_OK;
-  }
-
-  return sSecMan->CheckPropertyAccess(cx, global, mData->mName, id,
-                                      accessMode);
-}
 
 NS_IMETHODIMP
 nsWindowSH::PreCreate(nsISupports *nativeObj, JSContext *cx,
@@ -4462,46 +4318,26 @@ nsWindowSH::GetProperty(nsIXPConnectWrap
     return NS_FAILED(rv) ? rv : NS_SUCCESS_I_DID_SOMETHING;
   }
 
-  if (needsSecurityCheck(cx, wrapper)) {
-    // Even if we'd need to do a security check for access to "normal"
-    // properties on a window, we won't do a security check if we're
-    // accessing a child frame.
-
-    if (JSVAL_IS_STRING(id) && !JSVAL_IS_PRIMITIVE(*vp) &&
-        ::JS_TypeOfValue(cx, *vp) != JSTYPE_FUNCTION) {
-      // A named property accessed which could have been resolved to a
-      // child frame in nsWindowSH::NewResolve() (*vp will tell us if
-      // that's the case). If *vp is a window object (i.e. a child
-      // frame), return without doing a security check.
-
-      nsCOMPtr<nsIXPConnectWrappedNative> vpwrapper;
-      sXPConnect->GetWrappedNativeOfJSObject(cx, JSVAL_TO_OBJECT(*vp),
-                                             getter_AddRefs(vpwrapper));
-
-      if (vpwrapper) {
-        nsCOMPtr<nsIDOMWindow> window(do_QueryWrappedNative(vpwrapper));
-
-        if (window) {
-          // Yup, *vp is a window object, return early (*vp is already
-          // the window, so no need to wrap it again).
-
-          return NS_SUCCESS_I_DID_SOMETHING;
-        }
+  if (JSVAL_IS_STRING(id) && !JSVAL_IS_PRIMITIVE(*vp) &&
+      ::JS_TypeOfValue(cx, *vp) != JSTYPE_FUNCTION) {
+    // A named property accessed which could have been resolved to a
+    // child frame in nsWindowSH::NewResolve() (*vp will tell us if
+    // that's the case). If *vp is a window object (i.e. a child
+    // frame), return without doing a security check.
+
+    nsCOMPtr<nsIXPConnectWrappedNative> vpwrapper;
+    sXPConnect->GetWrappedNativeOfJSObject(cx, JSVAL_TO_OBJECT(*vp),
+                                           getter_AddRefs(vpwrapper));
+
+    if (vpwrapper) {
+      nsCOMPtr<nsIDOMWindow> window(do_QueryWrappedNative(vpwrapper));
+
+      if (window) {
+        // Yup, *vp is a window object, return early (*vp is already
+        // the window, so no need to wrap it again).
+
+        return NS_SUCCESS_I_DID_SOMETHING;
       }
-    }
-
-    nsresult rv =
-      doCheckPropertyAccess(cx, obj, id, wrapper,
-                            nsIXPCSecurityManager::ACCESS_GET_PROPERTY,
-                            PR_TRUE);
-
-    if (NS_FAILED(rv)) {
-      // Security check failed. The security manager set a JS
-      // exception, we must make sure that exception is propagated.
-
-      *_retval = PR_FALSE;
-
-      *vp = JSVAL_NULL;
     }
   }
 
@@ -4560,22 +4396,6 @@ nsWindowSH::SetProperty(nsIXPConnectWrap
     }
   }
 
-  if (needsSecurityCheck(cx, wrapper)) {
-    nsresult rv =
-      doCheckPropertyAccess(cx, obj, id, wrapper,
-                            nsIXPCSecurityManager::ACCESS_SET_PROPERTY,
-                            PR_TRUE);
-
-    if (NS_FAILED(rv)) {
-      // Security check failed. The security manager set a JS
-      // exception, we must make sure that exception is propagated.
-
-      *_retval = PR_FALSE;
-
-      return NS_OK;
-    }
-  }
-
   if (id == sLocation_id) {
     JSAutoRequest ar(cx);
 
@@ -4660,20 +4480,6 @@ nsWindowSH::AddProperty(nsIXPConnectWrap
     return NS_ERROR_DOM_SECURITY_ERR;
   }
 
-  nsresult rv =
-    doCheckPropertyAccess(cx, obj, id, wrapper,
-                          nsIXPCSecurityManager::ACCESS_SET_PROPERTY,
-                          PR_TRUE);
-
-  if (NS_FAILED(rv)) {
-    // Security check failed. The security manager set a JS
-    // exception, we must make sure that exception is propagated.
-
-    *_retval = PR_FALSE;
-
-    return NS_OK;
-  }
-
   return nsEventReceiverSH::AddProperty(wrapper, cx, obj, id, vp, _retval);
 }
 
@@ -4726,18 +4532,6 @@ nsWindowSH::DelProperty(nsIXPConnectWrap
     // to security bugs (see bug 143369).
 
     return NS_ERROR_DOM_SECURITY_ERR;
-  }
-
-  nsresult rv =
-    doCheckPropertyAccess(cx, obj, id, wrapper,
-                          nsIXPCSecurityManager::ACCESS_SET_PROPERTY,
-                          PR_TRUE);
-
-  if (NS_FAILED(rv)) {
-    // Security check failed. The security manager set a JS
-    // exception, we must make sure that exception is propagated.
-
-    *_retval = PR_FALSE;
   }
 
   return NS_OK;
@@ -5853,15 +5647,21 @@ nsWindowSH::NewResolve(nsIXPConnectWrapp
         // property is 'ok' in this case, even if the call comes from
         // a different context.
 
-        PRBool doSecurityCheckInAddProperty = sDoSecurityCheckInAddProperty;
-        sDoSecurityCheckInAddProperty = PR_FALSE;
+        nsCOMPtr<nsIDOMChromeWindow> chrome =
+          do_QueryInterface((nsIScriptGlobalObject *)win);
+        if (!chrome) {
+          rv = sXPConnect->GetCrossOriginWrapperForObject(cx,
+                                                          win->GetGlobalJSObject(),
+                                                          JSVAL_TO_OBJECT(v),
+                                                          &v);
+          NS_ENSURE_SUCCESS(rv, rv);
+        }
 
         JSAutoRequest ar(cx);
 
-        PRBool ok = ::JS_DefineUCProperty(cx, obj, chars, ::JS_GetStringLength(str),
-                                    v, nsnull, nsnull, 0);
-
-        sDoSecurityCheckInAddProperty = doSecurityCheckInAddProperty;
+        PRBool ok = ::JS_DefineUCProperty(cx, obj, chars,
+                                          ::JS_GetStringLength(str),
+                                          v, nsnull, nsnull, 0);
 
         if (!ok) {
           return NS_ERROR_FAILURE;
@@ -5962,6 +5762,15 @@ nsWindowSH::NewResolve(nsIXPConnectWrapp
 
     PRBool doSecurityCheckInAddProperty = sDoSecurityCheckInAddProperty;
     sDoSecurityCheckInAddProperty = PR_FALSE;
+
+    nsCOMPtr<nsIDOMChromeWindow> chrome =
+      do_QueryInterface((nsIScriptGlobalObject *)win);
+    if (!chrome) {
+      rv = sXPConnect->GetCrossOriginWrapperForObject(cx, scope,
+                                                      JSVAL_TO_OBJECT(v),
+                                                      &v);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
 
     JSAutoRequest ar(cx);
 
@@ -6045,6 +5854,16 @@ nsWindowSH::NewResolve(nsIXPConnectWrapp
 
     if (id == sWindow_id) {
       // window should *always* be the outer window object.
+      JSObject *scope;
+      nsGlobalWindow *innerWin;
+      if (win->IsInnerWindow()) {
+        scope = win->GetGlobalJSObject();
+      } else if (!(innerWin = win->GetCurrentInnerWindowInternal())) {
+        scope = innerWin->GetGlobalJSObject();
+      } else {
+        NS_ERROR("I don't know what scope to use!");
+        scope = win->GetGlobalJSObject();
+      }
       win = win->GetOuterWindowInternal();
       NS_ENSURE_TRUE(win, NS_ERROR_NOT_AVAILABLE);
 
@@ -6053,11 +5872,20 @@ nsWindowSH::NewResolve(nsIXPConnectWrapp
       PRBool doSecurityCheckInAddProperty = sDoSecurityCheckInAddProperty;
       sDoSecurityCheckInAddProperty = PR_FALSE;
 
+      jsval winVal = OBJECT_TO_JSVAL(win->GetGlobalJSObject());
+      nsCOMPtr<nsIDOMChromeWindow> chrome =
+        do_QueryInterface((nsIScriptGlobalObject *)win);
+      if (!chrome) {
+        rv = sXPConnect->GetCrossOriginWrapperForObject(cx,
+                                                        scope,
+                                                        JSVAL_TO_OBJECT(winVal),
+                                                        &winVal);
+        NS_ENSURE_SUCCESS(rv, rv);
+      }
       PRBool ok =
         ::JS_DefineUCProperty(cx, obj, ::JS_GetStringChars(str),
                               ::JS_GetStringLength(str),
-                              OBJECT_TO_JSVAL(win->GetGlobalJSObject()),
-                              nsnull, nsnull,
+                              winVal, nsnull, nsnull,
                               JSPROP_READONLY | JSPROP_ENUMERATE);
 
       sDoSecurityCheckInAddProperty = doSecurityCheckInAddProperty;
@@ -6066,25 +5894,6 @@ nsWindowSH::NewResolve(nsIXPConnectWrapp
         return NS_ERROR_FAILURE;
       }
       *objp = obj;
-
-      return NS_OK;
-    }
-
-    // Do a security check when resolving heretofore unknown string
-    // properties on window objects to prevent detection of a
-    // property's existence across origins. We only do this when
-    // resolving for a GET, no need to do it for set since we'll do
-    // a security check in nsWindowSH::SetProperty() in that case.
-    rv =
-      doCheckPropertyAccess(cx, obj, id, wrapper,
-                            nsIXPCSecurityManager::ACCESS_GET_PROPERTY,
-                            PR_TRUE);
-    if (NS_FAILED(rv)) {
-      // Security check failed. The security manager set a JS
-      // exception, we must make sure that exception is propagated, so
-      // return NS_OK here.
-
-      *_retval = PR_FALSE;
 
       return NS_OK;
     }
@@ -7280,92 +7089,6 @@ nsFormControlListSH::GetNamedItem(nsISup
 
 // Document helper for document.location and document.on*
 
-static inline PRBool
-documentNeedsSecurityCheck(JSContext *cx, nsIXPConnectWrappedNative *wrapper)
-{
-  // We cache a pointer to a wrapper and a context that we've last vetted
-  // and cache what the verdict was.
-
-  if (cx == cached_doc_cx && wrapper == cached_doc_wrapper) {
-    return cached_doc_needs_check;
-  }
-
-  cached_doc_cx = cx;
-  cached_doc_wrapper = wrapper;
-  
-  // Get the JS object from the wrapper
-  JSObject *wrapper_obj = nsnull;
-  wrapper->GetJSObject(&wrapper_obj);
-
-  JSObject *wrapper_global = GetGlobalJSObject(cx, wrapper_obj);
-
-#ifdef DEBUG
-  {
-    JSClass *clazz = JS_GET_CLASS(cx, wrapper_obj);
-
-    NS_ASSERTION(clazz && clazz->flags & JSCLASS_HAS_PRIVATE &&
-                 clazz->flags & JSCLASS_PRIVATE_IS_NSISUPPORTS,
-                 "Bad class for Document object!");
-  }
-#endif
-
-  // Check if the calling function comes from the same scope that the
-  // wrapper comes from. If that's the case, or if there's no JS
-  // running at the moment (i.e. someone is using the JS engine API
-  // directly to access a property on a JS object) there's no need to
-  // do a security check.
-
-  JSObject *function_obj = nsnull;
-  JSStackFrame *fp = nsnull;
-
-  // Initialize to false to handle the case where there's no JS running
-  // on the current context (e.g., we're getting here from a property
-  // access from the JS API).  Since the scope chain is immutable, it's
-  // OK to keep skipping the check.
-
-  cached_doc_needs_check = PR_FALSE;
-
-  do {
-    fp = ::JS_FrameIterator(cx, &fp);
-    if (!fp) {
-      // Clear cached_doc_cx so that we don't really cache this return
-      // value. If we hit this case, then we didn't really have enough
-      // information about the currently running code to make any long-term
-      // decisions.
-
-      cached_doc_cx = nsnull;
-      return cached_doc_needs_check;
-    }
-
-    function_obj = ::JS_GetFrameFunctionObject(cx, fp);
-
-    // Since we're here, we know that there is some JS running. Now, we
-    // need to default to being paranoid, and can only skip the security
-    // check if we find that the currently-running function is from the
-    // same scope.
-
-    cached_doc_needs_check = PR_TRUE;
-  } while (!function_obj);
-
-  // Get the global object that the calling function comes from.
-  JSObject *function_global = GetGlobalJSObject(cx, function_obj);
-
-  if (function_global != wrapper_global) {
-    // The global object we're trying to access a property on is not
-    // from the scope that the calling function comes from. Do a
-    // security check.
-
-    return PR_TRUE;
-  }
-
-  // We're called from the same context as the context in the global
-  // object in the scope that wrapper came from, no need to do a
-  // security check now.
-  cached_doc_needs_check = PR_FALSE;
-
-  return PR_FALSE;
-}
-
 NS_IMETHODIMP
 nsDocumentSH::AddProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
                           JSObject *obj, jsval id, jsval *vp,
@@ -7450,30 +7173,6 @@ nsDocumentSH::NewResolve(nsIXPConnectWra
     return NS_OK;
   }
 
-  if (documentNeedsSecurityCheck(cx, wrapper)) {
-    PRUint32 accessType;
-
-    if (flags & JSRESOLVE_ASSIGNING)
-      accessType = nsIXPCSecurityManager::ACCESS_SET_PROPERTY;
-    else
-      accessType = nsIXPCSecurityManager::ACCESS_GET_PROPERTY;
-
-    // Do a security check when resolving heretofore unknown string
-    // properties on document objects to prevent detection of a
-    // property's existence across origins.
-    rv = doCheckPropertyAccess(cx, obj, id, wrapper, accessType, PR_FALSE);
-
-    if (NS_FAILED(rv)) {
-      // Security check failed. The security manager set a JS exception,
-      // we must make sure that exception is propagated, so return NS_OK
-      // here.
-
-      *_retval = PR_FALSE;
-      
-      return NS_OK;
-    }
-  }
-
   if (id == sDocumentURIObject_id && IsPrivilegedScript()) {
     return DefineVoidProp(cx, obj, id, objp);
   } 
@@ -7485,22 +7184,6 @@ nsDocumentSH::GetProperty(nsIXPConnectWr
 nsDocumentSH::GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
                           JSObject *obj, jsval id, jsval *vp, PRBool *_retval)
 {
-  if (documentNeedsSecurityCheck(cx, wrapper)) {
-    nsresult rv =
-      doCheckPropertyAccess(cx, obj, id, wrapper,
-                            nsIXPCSecurityManager::ACCESS_GET_PROPERTY,
-                            PR_FALSE);
-
-    if (NS_FAILED(rv)) {
-      // Security check failed. The security manager set a JS
-      // exception, we must make sure that exception is propagated.
-
-      *_retval = PR_FALSE;
-
-      *vp = JSVAL_NULL;
-    }
-  }
-
   if (id == sDocumentURIObject_id && IsPrivilegedScript()) {
     nsCOMPtr<nsIDocument> doc = do_QueryWrappedNative(wrapper);
     NS_ENSURE_TRUE(doc, NS_ERROR_UNEXPECTED);
@@ -7522,22 +7205,6 @@ nsDocumentSH::SetProperty(nsIXPConnectWr
 nsDocumentSH::SetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
                           JSObject *obj, jsval id, jsval *vp, PRBool *_retval)
 {
-  if (documentNeedsSecurityCheck(cx, wrapper)) {
-    nsresult rv =
-      doCheckPropertyAccess(cx, obj, id, wrapper,
-                            nsIXPCSecurityManager::ACCESS_SET_PROPERTY,
-                            PR_FALSE);
-
-    if (NS_FAILED(rv)) {
-      // Security check failed. The security manager set a JS
-      // exception, we must make sure that exception is propagated.
-
-      *_retval = PR_FALSE;
-
-      return NS_OK;
-    }
-  }
-
   if (id == sLocation_id) {
     nsCOMPtr<nsIDOMNSDocument> doc(do_QueryWrappedNative(wrapper));
     NS_ENSURE_TRUE(doc, NS_ERROR_UNEXPECTED);
@@ -7597,8 +7264,8 @@ nsDocumentSH::PostCreate(nsIXPConnectWra
     return NS_ERROR_UNEXPECTED;
   }
 
-  nsCOMPtr<nsPIDOMWindow> win =
-    do_QueryInterface(doc->GetScriptGlobalObject());
+  nsIScriptGlobalObject *sgo = doc->GetScriptGlobalObject();
+  nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(sgo);
   if (!win) {
     // No window, nothing else to do here
     return NS_OK;
@@ -7607,7 +7274,7 @@ nsDocumentSH::PostCreate(nsIXPConnectWra
   nsIDOMDocument* currentDoc = win->GetExtantDocument();
 
   if (SameCOMIdentity(doc, currentDoc)) {
-    jsval winVal;
+    jsval winVal, docVal;
 
     nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
     rv = WrapNative(cx, obj, win, NS_GET_IID(nsIDOMWindow), &winVal,
@@ -7616,13 +7283,22 @@ nsDocumentSH::PostCreate(nsIXPConnectWra
 
     NS_NAMED_LITERAL_STRING(doc_str, "document");
 
+    docVal = OBJECT_TO_JSVAL(obj);
+
+    nsCOMPtr<nsIDOMChromeWindow> chrome = do_QueryInterface(win);
+    if (!chrome) {
+      rv = sXPConnect->GetCrossOriginWrapperForObject(cx, sgo->GetGlobalJSObject(),
+                                                      obj, &docVal);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+
     if (!::JS_DefineUCProperty(cx, JSVAL_TO_OBJECT(winVal),
                                reinterpret_cast<const jschar *>
                                                (doc_str.get()),
-                               doc_str.Length(), OBJECT_TO_JSVAL(obj), nsnull,
+                               doc_str.Length(), docVal, nsnull,
                                nsnull, JSPROP_READONLY | JSPROP_ENUMERATE)) {
       return NS_ERROR_FAILURE;
-    }    
+    }
   }
   return NS_OK;
 }
@@ -8412,109 +8088,6 @@ nsHTMLElementSH::NewResolve(nsIXPConnect
 
   return nsElementSH::NewResolve(wrapper, cx, obj, id, flags, objp, _retval);
 }
-
-
-// HTML[I]FrameElement helper
-
-NS_IMETHODIMP
-nsHTMLFrameElementSH::GetProperty(nsIXPConnectWrappedNative *wrapper,
-                                  JSContext *cx, JSObject *obj, jsval id,
-                                  jsval *vp, PRBool *_retval)
-{
-  nsresult rv =
-    sSecMan->CheckPropertyAccess(cx, obj, mData->mName, id,
-                                 nsIXPCSecurityManager::ACCESS_GET_PROPERTY);
-
-  if (NS_FAILED(rv)) {
-    // Let XPConnect know that the access was not granted.
-    *_retval = PR_FALSE;
-  }
-
-  // None of our base classes "implement" GetProperty(), so simply
-  // return NS_OK;
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsHTMLFrameElementSH::SetProperty(nsIXPConnectWrappedNative *wrapper,
-                                  JSContext *cx, JSObject *obj, jsval id,
-                                  jsval *vp, PRBool *_retval)
-{
-  nsresult rv =
-    sSecMan->CheckPropertyAccess(cx, obj, mData->mName, id,
-                                 nsIXPCSecurityManager::ACCESS_SET_PROPERTY);
-
-  if (NS_FAILED(rv)) {
-    // Let XPConnect know that the access was not granted.
-    *_retval = PR_FALSE;
-
-    return NS_OK;
-  }
-
-  return nsHTMLElementSH::SetProperty(wrapper, cx, obj, id, vp, _retval);
-}
-
-NS_IMETHODIMP
-nsHTMLFrameElementSH::AddProperty(nsIXPConnectWrappedNative *wrapper,
-                                  JSContext *cx, JSObject *obj, jsval id,
-                                  jsval *vp, PRBool *_retval)
-{
-  nsresult rv =
-    sSecMan->CheckPropertyAccess(cx, obj, mData->mName, id,
-                                 nsIXPCSecurityManager::ACCESS_SET_PROPERTY);
-
-  if (NS_FAILED(rv)) {
-    // Let XPConnect know that the access was not granted.
-    *_retval = PR_FALSE;
-
-    return NS_OK;
-  }
-
-  return nsHTMLElementSH::AddProperty(wrapper, cx, obj, id, vp, _retval);
-}
-
-NS_IMETHODIMP
-nsHTMLFrameElementSH::DelProperty(nsIXPConnectWrappedNative *wrapper,
-                                  JSContext *cx, JSObject *obj, jsval id,
-                                  jsval *vp, PRBool *_retval)
-{
-  nsresult rv =
-    sSecMan->CheckPropertyAccess(cx, obj, mData->mName, id,
-                                 nsIXPCSecurityManager::ACCESS_SET_PROPERTY);
-
-  if (NS_FAILED(rv)) {
-    // Let XPConnect know that the access was not granted.
-    *_retval = PR_FALSE;
-  }
-
-  // None of our base classes "implement" GetProperty(), so simply
-  // return NS_OK;
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsHTMLFrameElementSH::NewResolve(nsIXPConnectWrappedNative *wrapper,
-                                 JSContext *cx, JSObject *obj, jsval id,
-                                 PRUint32 flags, JSObject **objp,
-                                 PRBool *_retval)
-{
-  nsresult rv =
-    sSecMan->CheckPropertyAccess(cx, obj, mData->mName, id,
-                                 nsIXPCSecurityManager::ACCESS_GET_PROPERTY);
-
-  if (NS_FAILED(rv)) {
-    // Let XPConnect know that the access was not granted.
-    *_retval = PR_FALSE;
-
-    return NS_OK;
-  }
-
-  return nsHTMLElementSH::NewResolve(wrapper, cx, obj, id, flags, objp,
-                                     _retval);
-}
-
 
 // HTMLFormElement helper
 
diff --git a/dom/src/base/nsDOMClassInfo.h b/dom/src/base/nsDOMClassInfo.h
--- a/dom/src/base/nsDOMClassInfo.h
+++ b/dom/src/base/nsDOMClassInfo.h
@@ -226,10 +226,6 @@ protected:
             id == sStatus_id       ||
             id == sName_id);
   }
-
-  nsresult doCheckPropertyAccess(JSContext *cx, JSObject *obj, jsval id,
-                                 nsIXPConnectWrappedNative *wrapper,
-                                 PRUint32 accessMode, PRBool isWindow);
 
   static JSClass sDOMConstructorProtoClass;
   static JSFunctionSpec sDOMJSClass_methods[];
@@ -920,39 +916,6 @@ public:
 };
 
 
-// HTML[I]FrameElement helper
-
-class nsHTMLFrameElementSH : public nsHTMLElementSH
-{
-protected:
-  nsHTMLFrameElementSH(nsDOMClassInfoData* aData) : nsHTMLElementSH(aData)
-  {
-  }
-
-  virtual ~nsHTMLFrameElementSH()
-  {
-  }
-
-public:
-  NS_IMETHOD GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
-                         JSObject *obj, jsval id, jsval *vp, PRBool *_retval);
-  NS_IMETHOD SetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
-                         JSObject *obj, jsval id, jsval *vp, PRBool *_retval);
-  NS_IMETHOD AddProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
-                         JSObject *obj, jsval id, jsval *vp, PRBool *_retval);
-  NS_IMETHOD DelProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
-                         JSObject *obj, jsval id, jsval *vp, PRBool *_retval);
-  NS_IMETHOD NewResolve(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
-                        JSObject *obj, jsval id, PRUint32 flags,
-                        JSObject **objp, PRBool *_retval);
-
-  static nsIClassInfo *doCreate(nsDOMClassInfoData* aData)
-  {
-    return new nsHTMLFrameElementSH(aData);
-  }
-};
-
-
 // HTMLSelectElement helper
 
 class nsHTMLSelectElementSH : public nsHTMLElementSH
@@ -1644,8 +1607,4 @@ public:
   }
 };
 
-
-void InvalidateContextAndWrapperCache();
-
-
 #endif /* nsDOMClassInfo_h___ */
diff --git a/dom/src/base/nsDOMWindowList.cpp b/dom/src/base/nsDOMWindowList.cpp
--- a/dom/src/base/nsDOMWindowList.cpp
+++ b/dom/src/base/nsDOMWindowList.cpp
@@ -179,7 +179,6 @@ nsDOMWindowList::NamedItem(const nsAStri
                                      nsnull, getter_AddRefs(item));
 
     nsCOMPtr<nsIScriptGlobalObject> globalObject(do_GetInterface(item));
-    NS_ASSERTION(globalObject, "Couldn't get to the globalObject");
     if (globalObject) {
       CallQueryInterface(globalObject.get(), aReturn);
     }
diff --git a/dom/src/base/nsJSEnvironment.cpp b/dom/src/base/nsJSEnvironment.cpp
--- a/dom/src/base/nsJSEnvironment.cpp
+++ b/dom/src/base/nsJSEnvironment.cpp
@@ -992,8 +992,6 @@ nsJSContext::nsJSContext(JSRuntime *aRun
   mBranchCallbackTime = LL_ZERO;
   mProcessingScriptTag = PR_FALSE;
   mIsTrackingChromeCodeTime = PR_FALSE;
-
-  InvalidateContextAndWrapperCache();
 }
 
 nsJSContext::~nsJSContext()
@@ -2215,8 +2213,6 @@ nsJSContext::InitContext(nsIScriptGlobal
 
   if (!mContext)
     return NS_ERROR_OUT_OF_MEMORY;
-
-  InvalidateContextAndWrapperCache();
 
   nsresult rv;
 
diff --git a/js/src/xpconnect/idl/nsIXPConnect.idl b/js/src/xpconnect/idl/nsIXPConnect.idl
--- a/js/src/xpconnect/idl/nsIXPConnect.idl
+++ b/js/src/xpconnect/idl/nsIXPConnect.idl
@@ -443,7 +443,7 @@ interface nsIXPCFunctionThisTranslator :
     { 0xbd, 0xd6, 0x0, 0x0, 0x64, 0x65, 0x73, 0x74 } }
 %}
 
-[uuid(33f03128-e8a0-4906-8cdb-79c8c1144009)]
+[uuid(52fc2ff3-c0ea-46c1-9105-655283c361ff)]
 interface nsIXPConnect : nsISupports
 {
 %{ C++
@@ -717,4 +717,14 @@ interface nsIXPConnect : nsISupports
     [noscript] JSVal evalInSandboxObject(in AString source, in JSContextPtr cx,
                                          in nsIXPConnectJSObjectHolder sandbox,
                                          in PRBool returnStringOnly);
+
+    /**
+     * Wrap a jsval in a cross origin wrapper.
+     * @param aJSContext A context to use to create objects.
+     * @param aParent The parent to create the wrapper with.
+     * @param aWrappedObj The object to wrap.
+     */
+    [noscript] JSVal getCrossOriginWrapperForObject(in JSContextPtr aJSContext,
+                                                    in JSObjectPtr aParent,
+                                                    in JSObjectPtr aWrappedObj);
 };
diff --git a/js/src/xpconnect/src/Makefile.in b/js/src/xpconnect/src/Makefile.in
--- a/js/src/xpconnect/src/Makefile.in
+++ b/js/src/xpconnect/src/Makefile.in
@@ -97,6 +97,8 @@ CPPSRCS		= \
 		XPCNativeWrapper.cpp \
 		xpcJSWeakReference.cpp \
 		XPCSafeJSObjectWrapper.cpp \
+		XPCCrossOriginWrapper.cpp \
+		XPCWrapper.cpp \
 		$(NULL)
 ifdef XPC_IDISPATCH_SUPPORT
 CPPSRCS +=	XPCDispObject.cpp	\
diff --git a/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp b/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp
new file mode 100644
--- /dev/null
+++ b/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp
@@ -0,0 +1,867 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=2 sw=2 et tw=78: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Blake Kaplan <mrbkap@gmail.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "xpcprivate.h"
+#include "nsDOMError.h"
+#include "jsdbgapi.h"
+#include "jsobj.h"    // For OBJ_GET_PROPERTY.
+#include "XPCWrapper.h"
+#include "nsIDOMWindow.h"
+#include "nsIDOMWindowCollection.h"
+
+// This file implements a wrapper around objects that allows them to be
+// accessed safely from across origins.
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_Enumerate(JSContext *cx, JSObject *obj);
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
+                   JSObject **objp);
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp);
+
+JS_STATIC_DLL_CALLBACK(void)
+XPC_XOW_Finalize(JSContext *cx, JSObject *obj);
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_CheckAccess(JSContext *cx, JSObject *obj, jsval id, JSAccessMode mode,
+                    jsval *vp);
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
+                  jsval *rval);
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
+
+JSExtendedClass sXPC_XOW_JSClass = {
+  // JSClass (JSExtendedClass.base) initialization
+  { "XPCCrossOriginWrapper",
+    JSCLASS_NEW_RESOLVE | JSCLASS_IS_EXTENDED |
+    JSCLASS_HAS_RESERVED_SLOTS(XPCWrapper::sNumSlots),
+    XPC_XOW_AddProperty, XPC_XOW_DelProperty,
+    XPC_XOW_GetProperty, XPC_XOW_SetProperty,
+    XPC_XOW_Enumerate,   (JSResolveOp)XPC_XOW_NewResolve,
+    XPC_XOW_Convert,     XPC_XOW_Finalize,
+    nsnull,              XPC_XOW_CheckAccess,
+    XPC_XOW_Call,        XPC_XOW_Construct,
+    nsnull,              nsnull,
+    nsnull,              nsnull
+  },
+  // JSExtendedClass initialization
+  XPC_XOW_Equality
+};
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
+                 jsval *rval);
+
+// Throws an exception on context |cx|.
+static inline
+JSBool
+ThrowException(nsresult ex, JSContext *cx)
+{
+  XPCThrower::Throw(ex, cx);
+
+  return JS_FALSE;
+}
+
+// Get the (possibly non-existant) XOW off of an object
+static inline
+JSObject *
+GetWrapper(JSContext *cx, JSObject *obj)
+{
+  while (JS_GET_CLASS(cx, obj) != &sXPC_XOW_JSClass.base) {
+    obj = JS_GetParent(cx, obj);
+    if (!obj) {
+      break;
+    }
+  }
+
+  return obj;
+}
+
+static inline
+JSObject *
+GetWrappedObject(JSContext *cx, JSObject *wrapper)
+{
+  if (JS_GET_CLASS(cx, wrapper) != &sXPC_XOW_JSClass.base) {
+    return nsnull;
+  }
+
+  jsval v;
+  if (!JS_GetReservedSlot(cx, wrapper, XPCWrapper::sWrappedObjSlot, &v)) {
+    JS_ClearPendingException(cx);
+    return nsnull;
+  }
+
+  if (!JSVAL_IS_OBJECT(v)) {
+    return nsnull;
+  }
+
+  return JSVAL_TO_OBJECT(v);
+}
+
+static inline
+nsIScriptSecurityManager *
+GetSecurityManager(JSContext *cx)
+{
+  XPCCallContext ccx(JS_CALLER, cx);
+
+  // XXX HOOK_CALL_METHOD seems wrong.
+  nsCOMPtr<nsIXPCSecurityManager> sm = ccx.GetXPCContext()->
+    GetAppropriateSecurityManager(nsIXPCSecurityManager::HOOK_CALL_METHOD);
+
+  nsCOMPtr<nsIScriptSecurityManager> ssm(do_QueryInterface(sm));
+
+  // This Releases, but that's OK, since XPConnect holds a reference to it.
+  return ssm;
+}
+
+static JSBool
+IsValFrame(JSContext *cx, JSObject *obj, jsval v, XPCWrappedNative *wn)
+{
+  // Fast path for the common case.
+  if (JS_GET_CLASS(cx, obj)->name[0] != 'W') {
+    return JS_FALSE;
+  }
+
+  nsCOMPtr<nsIDOMWindow> domwin(do_QueryWrappedNative(wn));
+  if (!domwin) {
+    return JS_FALSE;
+  }
+
+  nsCOMPtr<nsIDOMWindowCollection> col;
+  domwin->GetFrames(getter_AddRefs(col));
+  if (!col) {
+    return JS_FALSE;
+  }
+
+  if (JSVAL_IS_INT(v)) {
+    col->Item(JSVAL_TO_INT(v), getter_AddRefs(domwin));
+  } else {
+    nsAutoString str(JS_GetStringChars(JSVAL_TO_STRING(v)));
+    col->NamedItem(str, getter_AddRefs(domwin));
+  }
+
+  return domwin != nsnull;
+}
+
+// Returns whether the currently executing code has the same origin as the
+// wrapper. Uses nsIScriptSecurityManager::CheckSameOriginPrincipal.
+// |cx| must be the top context on the context stack.
+// If the two principals have the same origin, returns NS_OK. If they differ,
+// returns NS_ERROR_DOM_PROP_ACCESS_DENIED, returns another error code on
+// failure.
+nsresult
+IsWrapperSameOrigin(JSContext *cx, JSObject *wrappedObj)
+{
+  nsCOMPtr<nsIPrincipal> subjectPrin, objectPrin;
+
+  // Get the subject principal from the execution stack.
+  nsIScriptSecurityManager *ssm = GetSecurityManager(cx);
+  if (!ssm) {
+    ThrowException(NS_ERROR_NOT_INITIALIZED, cx);
+    return NS_ERROR_NOT_INITIALIZED;
+  }
+
+  nsresult rv = ssm->GetSubjectPrincipal(getter_AddRefs(subjectPrin));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (!subjectPrin) {
+    ThrowException(NS_ERROR_FAILURE, cx);
+    return NS_ERROR_FAILURE;
+  }
+
+  PRBool isSystem = PR_FALSE;
+  rv = ssm->IsSystemPrincipal(subjectPrin, &isSystem);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // If we somehow end up being called from chrome, just allow full access.
+  // This can happen from components with xpcnativewrappers=no.
+  if (isSystem) {
+    return NS_OK;
+  }
+
+  rv = ssm->GetObjectPrincipal(cx, wrappedObj, getter_AddRefs(objectPrin));
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+  NS_ASSERTION(objectPrin, "Object didn't have principals?");
+
+  // Micro-optimization: don't call into caps if we know the answer.
+  if (subjectPrin == objectPrin) {
+    return NS_OK;
+  }
+
+  // Now, we have our two principals, compare them!
+  return ssm->CheckSameOriginPrincipal(subjectPrin, objectPrin);
+}
+
+static JSBool
+XPC_XOW_FunctionWrapper(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
+                        jsval *rval)
+{
+  JSObject *wrappedObj;
+
+  obj = GetWrapper(cx, obj);
+  if (!obj || (wrappedObj = GetWrappedObject(cx, obj)) == nsnull) {
+    return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
+  }
+
+  JSObject *funObj = JSVAL_TO_OBJECT(argv[-2]);
+  jsval funToCall;
+  if (!JS_GetReservedSlot(cx, funObj, 0, &funToCall)) {
+    return JS_FALSE;
+  }
+
+  JSFunction *fun = JS_ValueToFunction(cx, funToCall);
+  if (!fun) {
+    return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
+  }
+
+  JSNative native = JS_GetFunctionNative(cx, fun);
+  NS_ASSERTION(native, "How'd we get here with a scripted function?");
+
+  // A trick! Calling the native directly doesn't push the native onto the
+  // JS stack, so interested onlookers will only see us, meaning that they
+  // will compute *our* subject principal.
+
+  argv[-2] = funToCall;
+  argv[-1] = OBJECT_TO_JSVAL(wrappedObj);
+  if (!native(cx, wrappedObj, argc, argv, rval)) {
+    return JS_FALSE;
+  }
+
+  return XPC_XOW_RewrapIfNeeded(cx, obj, rval);
+}
+
+static JSObject *
+GetGlobalObject(JSContext *cx, JSObject *start)
+{
+  JSObject *next;
+  while ((next = JS_GetParent(cx, start)) != nsnull) {
+    start = next;
+  }
+
+  return start;
+}
+
+JSBool
+XPC_XOW_WrapFunction(JSContext *cx, JSObject *outerObj, JSObject *funobj, jsval *rval)
+{
+  jsval funobjVal = OBJECT_TO_JSVAL(funobj);
+  JSNative native = JS_GetFunctionNative(cx, JS_ValueToFunction(cx, funobjVal));
+  if (!native || native == XPC_XOW_FunctionWrapper) {
+    *rval = funobjVal;
+    return JS_TRUE;
+  }
+
+  JSFunction *wrappedFun = JS_ValueToFunction(cx, OBJECT_TO_JSVAL(funobj));
+  NS_ASSERTION(wrappedFun, "We were told this was a function");
+
+  JSFunction *funWrapper =
+    JS_NewFunction(cx, XPC_XOW_FunctionWrapper,
+                   JS_GetFunctionArity(wrappedFun), 0,
+                   GetGlobalObject(cx, outerObj),
+                   "Wrapped function");
+                   // XXX JS_GetFunctionName(wrappedFun));
+  if (!funWrapper) {
+    return JS_FALSE;
+  }
+
+  JSObject *funWrapperObj = JS_GetFunctionObject(funWrapper);
+  if (!JS_SetReservedSlot(cx, funWrapperObj, 0, funobjVal)) {
+    return JS_FALSE;
+  }
+
+  *rval = OBJECT_TO_JSVAL(funWrapperObj);
+  return JS_TRUE;
+}
+
+JSBool
+XPC_XOW_RewrapIfNeeded(JSContext *cx, JSObject *outerObj, jsval *vp)
+{
+  // Don't need to wrap primitive values.
+  if (JSVAL_IS_PRIMITIVE(*vp)) {
+    return JS_TRUE;
+  }
+
+  JSObject *obj = JSVAL_TO_OBJECT(*vp);
+
+  if (JS_ObjectIsFunction(cx, obj)) {
+    return XPC_XOW_WrapFunction(cx, outerObj, obj, vp);
+  }
+
+  // Don't need to wrap non-C++-implemented objects.
+  // Note: This catches attempts to double-wrap cross origin wrappers.
+  if (!XPCWrappedNative::GetWrappedNativeOfJSObject(cx, obj)) {
+    return JS_TRUE;
+  }
+
+  return XPC_XOW_WrapObject(cx, GetGlobalObject(cx, outerObj), vp);
+}
+
+JSBool
+XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp)
+{
+  // Our argument should be a wrapped native object.
+  JSObject *wrappedObj;
+  XPCWrappedNative *wn;
+  if (!JSVAL_IS_OBJECT(*vp) ||
+      !(wrappedObj = JSVAL_TO_OBJECT(*vp)) ||
+      !(wn = XPCWrappedNative::GetWrappedNativeOfJSObject(cx, wrappedObj))) {
+    return JS_TRUE;
+  }
+
+  XPCJSRuntime *rt = nsXPConnect::GetRuntime();
+  XPCCallContext ccx(NATIVE_CALLER, cx);
+  XPCWrappedNativeScope *parentScope =
+    XPCWrappedNativeScope::FindInJSObjectScope(ccx, parent);
+  XPCWrappedNativeScope *wrapperScope = wn->GetScope();
+
+#ifdef DEBUG_mrbkap
+  printf("Wrapping object at %p (%s) [%p %p]\n",
+         (void *)wrappedObj, JS_GET_CLASS(cx, wrappedObj)->name,
+         (void *)parentScope, (void *)wrapperScope);
+#endif
+
+  JSObject *outerObj = nsnull;
+  JSBool sameOrigin = (parentScope == wrapperScope);
+  WrappedNative2WrapperMap *map =
+    sameOrigin ? wrapperScope->GetWrapperMap() : parentScope->GetWrapperMap();
+
+  if (sameOrigin) {
+    outerObj = wn->GetWrapper();
+    if (outerObj && JS_GET_CLASS(cx, outerObj) == &sXPC_XOW_JSClass.base) {
+#ifdef DEBUG_mrbkap
+      printf("But found a wrapper already there %p!\n", (void *)outerObj);
+#endif
+      *vp = OBJECT_TO_JSVAL(outerObj);
+      return JS_TRUE;
+    }
+  }
+
+  { // Scoped lock
+    XPCAutoLock al(rt->GetMapLock());
+
+    if (outerObj) {
+      outerObj = map->Add(wrappedObj, outerObj);
+      if (sameOrigin) {
+        wn->SetWrapper(nsnull);
+      }
+    } else {
+      outerObj = map->Find(wrappedObj);
+    }
+  }
+
+  if (outerObj) {
+    NS_ASSERTION(JS_GET_CLASS(cx, outerObj) == &sXPC_XOW_JSClass.base,
+                              "What crazy object are we getting here?");
+#ifdef DEBUG_mrbkap
+    printf("But found a wrapper in the map %p!\n", (void *)outerObj);
+#endif
+    if (sameOrigin) {
+      wn->SetWrapper(outerObj);
+    }
+    *vp = OBJECT_TO_JSVAL(outerObj);
+    return JS_TRUE;
+  }
+
+  outerObj = JS_NewObject(cx, &sXPC_XOW_JSClass.base, nsnull, parent);
+  if (!outerObj) {
+    return JS_FALSE;
+  }
+
+  if (!JS_SetReservedSlot(cx, outerObj, XPCWrapper::sWrappedObjSlot, *vp) ||
+      !JS_SetReservedSlot(cx, outerObj, XPCWrapper::sResolvingSlot,
+                          BOOLEAN_TO_JSVAL(JS_FALSE))) {
+    return JS_FALSE;
+  }
+
+  *vp = OBJECT_TO_JSVAL(outerObj);
+  if (!sameOrigin) {
+    XPCAutoLock al(rt->GetMapLock());
+    map->Add(wrappedObj, outerObj);
+  } else {
+#ifdef DEBUG_mrbkap
+    printf("Setting wrapper to %p\n", (void *)outerObj);
+#endif
+    wn->SetWrapper(outerObj);
+  }
+
+  return JS_TRUE;
+}
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+  // All AddProperty needs to do is pass on addProperty requests to
+  // same-origin objects, and throw for all else.
+
+  obj = GetWrapper(cx, obj);
+  jsval resolving;
+  if (!JS_GetReservedSlot(cx, obj, XPCWrapper::sResolvingSlot, &resolving)) {
+    return JS_FALSE;
+  }
+
+  if (JSVAL_TO_BOOLEAN(resolving)) {
+    // Allow us to define a property on ourselves.
+    return JS_TRUE;
+  }
+
+  JSObject *wrappedObj = GetWrappedObject(cx, obj);
+  if (!wrappedObj) {
+    return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
+  }
+  nsresult rv = IsWrapperSameOrigin(cx, wrappedObj);
+  if (NS_FAILED(rv)) {
+    if (rv == NS_ERROR_DOM_PROP_ACCESS_DENIED) {
+      // Can't override properties on foreign objects.
+      return ThrowException(rv, cx);
+    }
+    return JS_FALSE;
+  }
+
+  // Same origin, pass this request along.
+  return XPCWrapper::AddProperty(cx, wrappedObj, id, vp);
+}
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+  JSObject *wrappedObj = GetWrappedObject(cx, obj);
+  if (!wrappedObj) {
+    return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
+  }
+  nsresult rv = IsWrapperSameOrigin(cx, wrappedObj);
+  if (NS_FAILED(rv)) {
+    if (rv == NS_ERROR_DOM_PROP_ACCESS_DENIED) {
+      // Can't delete properties on foreign objects.
+      return ThrowException(rv, cx);
+    }
+    return JS_FALSE;
+  }
+
+  // Same origin, pass this request along.
+  return XPCWrapper::DelProperty(cx, wrappedObj, id, vp);
+}
+
+static JSBool
+XPC_XOW_GetOrSetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp,
+                         JSBool isSet)
+{
+  if (id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_TO_STRING)) {
+    return JS_TRUE;
+  }
+
+  JSObject *wrappedObj = GetWrappedObject(cx, obj);
+  if (!wrappedObj) {
+    return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
+  }
+  nsresult rv = IsWrapperSameOrigin(cx, wrappedObj);
+  if (NS_FAILED(rv)) {
+    if (rv != NS_ERROR_DOM_PROP_ACCESS_DENIED) {
+      return JS_FALSE;
+    }
+
+    // This is a request to get a property across origins. We need to
+    // determine if this property is allAccess. If it is, then we need to
+    // actually get the property. If not, we simply need to throw an
+    // exception.
+
+    XPCWrappedNative *wn =
+      XPCWrappedNative::GetWrappedNativeOfJSObject(cx, wrappedObj);
+    NS_ASSERTION(wn, "How did we wrap a non-WrappedNative?");
+    if (!IsValFrame(cx, wrappedObj, id, wn)) {
+      nsIScriptSecurityManager *ssm = GetSecurityManager(cx);
+      PRUint32 check = isSet
+                       ? (PRUint32)nsIXPCSecurityManager::ACCESS_SET_PROPERTY
+                       : (PRUint32)nsIXPCSecurityManager::ACCESS_GET_PROPERTY;
+      rv = ssm->CheckPropertyAccess(cx, wrappedObj,
+                                    JS_GET_CLASS(cx, wrappedObj)->name,
+                                    id, check);
+      if (NS_FAILED(rv)) {
+        // The security manager threw an exception for us.
+        return JS_FALSE;
+      }
+    }
+
+    if (!XPCWrapper::GetOrSetNativeProperty(cx, obj, wn, id, vp, isSet,
+                                            JS_FALSE)) {
+      return JS_FALSE;
+    }
+
+    return XPC_XOW_RewrapIfNeeded(cx, obj, vp);
+  }
+
+  // Same origin, pass this request along as though nothing interesting
+  // happened.
+  jsid asId;
+
+  if (!JS_ValueToId(cx, id, &asId)) {
+    return JS_FALSE;
+  }
+
+  JSBool ok = isSet
+              ? OBJ_SET_PROPERTY(cx, wrappedObj, asId, vp)
+              : OBJ_GET_PROPERTY(cx, wrappedObj, asId, vp);
+  if (!ok) {
+    return JS_FALSE;
+  }
+
+  // Don't call XPC_XOW_RewrapIfNeeded for same origin properties. We only
+  // need to wrap window, document and location.
+  if (JSVAL_IS_PRIMITIVE(*vp)) {
+    return JS_TRUE;
+  }
+
+  wrappedObj = JSVAL_TO_OBJECT(*vp);
+  const char *name = JS_GET_CLASS(cx, wrappedObj)->name;
+  if (XPC_XOW_ClassNeedsXOW(name)) {
+    return XPC_XOW_WrapObject(cx, GetGlobalObject(cx, obj), vp);
+  }
+
+  return JS_TRUE;
+}
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+  return XPC_XOW_GetOrSetProperty(cx, obj, id, vp, JS_FALSE);
+}
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+  return XPC_XOW_GetOrSetProperty(cx, obj, id, vp, JS_TRUE);
+}
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_Enumerate(JSContext *cx, JSObject *obj)
+{
+  obj = GetWrapper(cx, obj);
+  JSObject *wrappedObj = GetWrappedObject(cx, obj);
+  if (!wrappedObj) {
+    // Nothing to enumerate.
+    return JS_TRUE;
+  }
+  nsresult rv = IsWrapperSameOrigin(cx, wrappedObj);
+  if (NS_FAILED(rv)) {
+    if (rv == NS_ERROR_DOM_PROP_ACCESS_DENIED) {
+      // Can't enumerate on foreign objects.
+      return ThrowException(rv, cx);
+    }
+
+    return JS_FALSE;
+  }
+
+  return XPCWrapper::Enumerate(cx, obj, wrappedObj);
+}
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
+                   JSObject **objp)
+{
+  obj = GetWrapper(cx, obj);
+
+  if (id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_TO_STRING)) {
+    *objp = obj;
+    return JS_DefineFunction(cx, obj, "toString",
+                             XPC_XOW_toString, 0, 0) != nsnull;
+  }
+
+  JSObject *wrappedObj = GetWrappedObject(cx, obj);
+  if (!wrappedObj) {
+    // No wrappedObj means that this is probably the prototype.
+    *objp = nsnull;
+    return JS_TRUE;
+  }
+
+  nsresult rv = IsWrapperSameOrigin(cx, wrappedObj);
+  if (NS_FAILED(rv)) {
+    if (rv != NS_ERROR_DOM_PROP_ACCESS_DENIED) {
+      return JS_FALSE;
+    }
+
+    // We're dealing with a cross-origin lookup. Ensure that we're allowed to
+    // resolve this property and resolve it if so. Otherwise, we deny access
+    // and throw a security error. Note that this code does not actually check
+    // to see if the property exists, that's dealt with below.
+
+    XPCWrappedNative *wn =
+      XPCWrappedNative::GetWrappedNativeOfJSObject(cx, wrappedObj);
+    NS_ASSERTION(wn, "How did we wrap a non-WrappedNative?");
+    if (!IsValFrame(cx, wrappedObj, id, wn)) {
+      nsIScriptSecurityManager *ssm = GetSecurityManager(cx);
+      PRUint32 action = (flags & JSRESOLVE_ASSIGNING)
+                        ? (PRUint32)nsIXPCSecurityManager::ACCESS_SET_PROPERTY
+                        : (PRUint32)nsIXPCSecurityManager::ACCESS_GET_PROPERTY;
+      rv = ssm->CheckPropertyAccess(cx, wrappedObj,
+                                    JS_GET_CLASS(cx, wrappedObj)->name,
+                                    id, action);
+      if (NS_FAILED(rv)) {
+        // The security manager threw an exception for us.
+        return JS_FALSE;
+      }
+    }
+
+    // We're out! We're allowed to resolve this property.
+    return XPCWrapper::ResolveNativeProperty(cx, obj, wrappedObj, wn, id,
+                                             flags, objp, JS_FALSE);
+
+  }
+
+  return XPCWrapper::NewResolve(cx, obj, wrappedObj, id, flags, objp);
+}
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
+{
+  JSObject *wrappedObj = GetWrappedObject(cx, obj);
+  if (!wrappedObj) {
+    // Converting the prototype to something.
+
+    if (type == JSTYPE_STRING) {
+      return XPC_XOW_toString(cx, obj, 0, nsnull, vp);
+    }
+
+    *vp = OBJECT_TO_JSVAL(obj);
+    return JS_TRUE;
+  }
+
+  nsresult rv = IsWrapperSameOrigin(cx, wrappedObj);
+  if (NS_FAILED(rv) &&
+      (rv != NS_ERROR_DOM_PROP_ACCESS_DENIED || type != JSTYPE_STRING)) {
+    return JS_FALSE;
+  }
+
+  // TODO wrap return value?
+  return JS_GET_CLASS(cx, wrappedObj)->convert(cx, wrappedObj, type, vp);
+}
+
+JS_STATIC_DLL_CALLBACK(void)
+XPC_XOW_Finalize(JSContext *cx, JSObject *obj)
+{
+  JSObject *wrappedObj = GetWrappedObject(cx, obj);
+  if (!wrappedObj) {
+    return;
+  }
+
+  // Get our scope.
+  XPCCallContext ccx(NATIVE_CALLER, cx);
+
+  // Get our scope, using ourselves to find the right scope.
+  // It's OK if we're not intialized, we can be called pretty late.
+  XPCWrappedNativeScope *scope =
+    XPCWrappedNativeScope::FindInJSObjectScope(ccx, obj, JS_TRUE);
+
+  if (scope) {
+    scope->GetWrapperMap()->Remove(wrappedObj);
+  }
+}
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_CheckAccess(JSContext *cx, JSObject *obj, jsval prop, JSAccessMode mode,
+                    jsval *vp)
+{
+  // Simply forward checkAccess to our wrapped object. It's already expecting
+  // untrusted things to ask it about accesses.
+
+  uintN junk;
+  jsid id;
+  return JS_ValueToId(cx, prop, &id) &&
+         JS_CheckAccess(cx, GetWrappedObject(cx, obj), id, mode, vp, &junk);
+}
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+  JSObject *wrappedObj = GetWrappedObject(cx, obj);
+  if (!wrappedObj) {
+    // Nothing to call.
+    return JS_TRUE;
+  }
+  nsresult rv = IsWrapperSameOrigin(cx, wrappedObj);
+  if (NS_FAILED(rv)) {
+    if (rv == NS_ERROR_DOM_PROP_ACCESS_DENIED) {
+      // Can't call.
+      return ThrowException(rv, cx);
+    }
+
+    return JS_FALSE;
+  }
+
+  JSObject *callee = JSVAL_TO_OBJECT(argv[-2]);
+  NS_ASSERTION(GetWrappedObject(cx, callee), "How'd we get here?");
+  callee = GetWrappedObject(cx, callee);
+  if (!JS_CallFunctionValue(cx, obj, OBJECT_TO_JSVAL(callee), argc, argv,
+                            rval)) {
+    return JS_FALSE;
+  }
+
+  return XPC_XOW_RewrapIfNeeded(cx, callee, rval);
+}
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
+                  jsval *rval)
+{
+  JSObject *realObj = GetWrapper(cx, JSVAL_TO_OBJECT(argv[-2]));
+  JSObject *wrappedObj = GetWrappedObject(cx, realObj);
+  if (!wrappedObj) {
+    // Nothing to construct.
+    return JS_TRUE;
+  }
+  nsresult rv = IsWrapperSameOrigin(cx, wrappedObj);
+  if (NS_FAILED(rv)) {
+    if (rv == NS_ERROR_DOM_PROP_ACCESS_DENIED) {
+      // Can't construct.
+      return ThrowException(rv, cx);
+    }
+    return JS_FALSE;
+  }
+
+  JSObject *callee = JSVAL_TO_OBJECT(argv[-2]);
+  NS_ASSERTION(GetWrappedObject(cx, callee), "How'd we get here?");
+  callee = GetWrappedObject(cx, callee);
+  if (!JS_CallFunctionValue(cx, obj, OBJECT_TO_JSVAL(callee), argc, argv,
+                            rval)) {
+    return JS_FALSE;
+  }
+
+  return XPC_XOW_RewrapIfNeeded(cx, callee, rval);
+}
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
+{
+  // Convert both sides to XPCWrappedNative and see if they match.
+  if (JSVAL_IS_PRIMITIVE(v)) {
+    *bp = JS_FALSE;
+    return JS_TRUE;
+  }
+
+  JSObject *test = JSVAL_TO_OBJECT(v);
+  if (JS_GET_CLASS(cx, test) == &sXPC_XOW_JSClass.base) {
+    if (!JS_GetReservedSlot(cx, test, XPCWrapper::sWrappedObjSlot, &v)) {
+      return JS_FALSE;
+    }
+
+    if (JSVAL_IS_PRIMITIVE(v)) {
+      *bp = JS_FALSE;
+      return JS_TRUE;
+    }
+
+    test = JSVAL_TO_OBJECT(v);
+  }
+
+  obj = GetWrappedObject(cx, obj);
+  if (!obj) {
+    return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
+  }
+  XPCWrappedNative *other =
+    XPCWrappedNative::GetWrappedNativeOfJSObject(cx, test);
+  if (!other) {
+    *bp = JS_FALSE;
+    return JS_TRUE;
+  }
+
+  XPCWrappedNative *me = XPCWrappedNative::GetWrappedNativeOfJSObject(cx, obj);
+  obj = me->GetFlatJSObject();
+  test = other->GetFlatJSObject();
+  return ((JSExtendedClass *)JS_GET_CLASS(cx, obj))->
+    equality(cx, obj, OBJECT_TO_JSVAL(test), bp);
+}
+
+JS_STATIC_DLL_CALLBACK(JSBool)
+XPC_XOW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
+                 jsval *rval)
+{
+  obj = GetWrapper(cx, obj);
+  if (!obj) {
+    return ThrowException(NS_ERROR_UNEXPECTED, cx);
+  }
+
+  JSObject *wrappedObj = GetWrappedObject(cx, obj);
+  if (!wrappedObj) {
+    // Someone's calling toString on our prototype.
+    NS_NAMED_LITERAL_CSTRING(protoString, "[object XPCCrossOriginWrapper]");
+    JSString *str =
+      JS_NewStringCopyN(cx, protoString.get(), protoString.Length());
+    if (!str) {
+      return JS_FALSE;
+    }
+    *rval = STRING_TO_JSVAL(str);
+    return JS_TRUE;
+  }
+
+  nsresult rv = IsWrapperSameOrigin(cx, wrappedObj);
+  if (rv == NS_ERROR_DOM_PROP_ACCESS_DENIED) {
+    nsIScriptSecurityManager *ssm = GetSecurityManager(cx);
+    rv = ssm->CheckPropertyAccess(cx, wrappedObj,
+                                  JS_GET_CLASS(cx, wrappedObj)->name,
+                                  GetRTStringByIndex(cx, XPCJSRuntime::IDX_TO_STRING),
+                                  nsIXPCSecurityManager::ACCESS_GET_PROPERTY);
+  }
+  if (NS_FAILED(rv)) {
+    return JS_FALSE;
+  }
+
+  XPCWrappedNative *wn =
+    XPCWrappedNative::GetWrappedNativeOfJSObject(cx, wrappedObj);
+  return XPCWrapper::NativeToString(cx, wn, argc, argv, rval, JS_FALSE);
+}
diff --git a/js/src/xpconnect/src/XPCNativeWrapper.cpp b/js/src/xpconnect/src/XPCNativeWrapper.cpp
--- a/js/src/xpconnect/src/XPCNativeWrapper.cpp
+++ b/js/src/xpconnect/src/XPCNativeWrapper.cpp
@@ -41,6 +41,7 @@
 #include "xpcprivate.h"
 #include "XPCNativeWrapper.h"
 #include "jsdbgapi.h"
+#include "XPCWrapper.h"
 
 JS_STATIC_DLL_CALLBACK(JSBool)
 XPC_NW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
@@ -87,9 +88,6 @@ XPC_NW_Trace(JSTracer *trc, JSObject *ob
 
 JS_STATIC_DLL_CALLBACK(JSBool)
 XPC_NW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
-
-static JSBool
-RewrapIfDeepWrapper(JSContext *cx, JSObject *obj, jsval v, jsval *rval);
 
 JS_STATIC_DLL_CALLBACK(JSBool)
 XPC_NW_FunctionWrapper(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
@@ -118,19 +116,6 @@ JSExtendedClass XPCNativeWrapper::sXPC_N
   XPC_NW_Equality
 };
 
-#define FLAG_DEEP     0x1
-#define FLAG_EXPLICIT 0x2
-// FLAG_RESOLVING is used to tag an XPCNativeWrapper when while it's calling
-// the newResolve hook on the XPCWrappedNative's scriptable info.
-#define FLAG_RESOLVING 0x4
-
-#define HAS_FLAGS(_val, _flags) \
-  ((PRUint32(JSVAL_TO_INT(_val)) & (_flags)) != 0)
-
-#define NATIVE_HAS_FLAG(_wn, _flag)                \
-  ((_wn)->GetScriptableInfo() &&                   \
-   (_wn)->GetScriptableInfo()->GetFlags()._flag())
-
 // If one of our class hooks is ever called from a non-system script, bypass
 // the hook by calling the same hook on our wrapped native, with obj reset to
 // the wrapped native's flat JSObject, so the hook and args macro parameters
@@ -257,8 +242,8 @@ EnsureLegalActivity(JSContext *cx, JSObj
   return ThrowException(NS_ERROR_XPC_SECURITY_MANAGER_VETO, cx);
 }
 
-static JSBool
-WrapFunction(JSContext* cx, JSObject* funobj, jsval *rval)
+JSBool
+XPC_NW_WrapFunction(JSContext* cx, JSObject* funobj, jsval *rval)
 {
   // If funobj is already a wrapped function, just return it.
   if (JS_GetFunctionNative(cx,
@@ -307,7 +292,7 @@ XPC_NW_AddProperty(JSContext *cx, JSObje
   // Note: no need to protect *vp from GC here, since it's already in the slot
   // on |obj|.
   return EnsureLegalActivity(cx, obj) &&
-         RewrapIfDeepWrapper(cx, obj, *vp, vp);
+         XPC_NW_RewrapIfDeepWrapper(cx, obj, *vp, vp);
 }
 
 JS_STATIC_DLL_CALLBACK(JSBool)
@@ -335,8 +320,8 @@ XPC_NW_DelProperty(JSContext *cx, JSObje
   return ThrowException(NS_ERROR_XPC_SECURITY_MANAGER_VETO, cx);
 }
 
-static JSBool
-RewrapIfDeepWrapper(JSContext *cx, JSObject *obj, jsval v, jsval *rval)
+JSBool
+XPC_NW_RewrapIfDeepWrapper(JSContext *cx, JSObject *obj, jsval v, jsval *rval)
 {
   NS_ASSERTION(XPCNativeWrapper::IsNativeWrapper(cx, obj),
                "Unexpected object");
@@ -346,7 +331,7 @@ RewrapIfDeepWrapper(JSContext *cx, JSObj
   
   // We always want to wrap function objects, no matter whether we're deep.
   if (!primitive && JS_ObjectIsFunction(cx, nativeObj)) {
-    return WrapFunction(cx, nativeObj, rval);
+    return XPC_NW_WrapFunction(cx, nativeObj, rval);
   }
 
   jsval flags;
@@ -355,6 +340,19 @@ RewrapIfDeepWrapper(JSContext *cx, JSObj
   // Re-wrap non-primitive values if this is a deep wrapper, i.e.
   // if (HAS_FLAGS(flags, FLAG_DEEP).
   if (HAS_FLAGS(flags, FLAG_DEEP) && !primitive) {
+    // Unwrap a cross origin wrapper, since we're more restrictive.
+    if (JS_GET_CLASS(cx, nativeObj) == &sXPC_XOW_JSClass.base) {
+      if (!::JS_GetReservedSlot(cx, nativeObj, XPCWrapper::sWrappedObjSlot,
+                                &v)) {
+        return JS_FALSE;
+      }
+
+      // If v is primitive, allow nativeObj to remain a cross origin wrapper,
+      // which will fail below (since it isn't a wrapped native).
+      if (!JSVAL_IS_PRIMITIVE(v)) {
+        nativeObj = JSVAL_TO_OBJECT(v);
+      }
+    }
 
     XPCWrappedNative* wrappedNative =
       XPCWrappedNative::GetWrappedNativeOfJSObject(cx, nativeObj);
@@ -440,7 +438,7 @@ XPC_NW_FunctionWrapper(JSContext *cx, JS
   // Make sure v doesn't get collected while we're re-wrapping it.
   AUTO_MARK_JSVAL(ccx, v);
 
-  return RewrapIfDeepWrapper(cx, obj, v, rval);
+  return XPC_NW_RewrapIfDeepWrapper(cx, obj, v, rval);
 }
 
 static JSBool
@@ -500,156 +498,8 @@ XPC_NW_GetOrSetProperty(JSContext *cx, J
     return XPC_SJOW_Construct(cx, nsnull, 1, &nativeVal, vp);
   }
 
-  // This will do verification and the method lookup for us.
-  XPCCallContext ccx(JS_CALLER, cx, nativeObj, nsnull, id);
-
-  if (aIsSet ? NATIVE_HAS_FLAG(wrappedNative, WantSetProperty) :
-               NATIVE_HAS_FLAG(wrappedNative, WantGetProperty)) {
-
-    jsval v = *vp;
-    // Note that some sets return random DOM objects (setting
-    // document.location, say), so we want to rewrap for sets too if v != *vp.
-    JSBool retval = JS_TRUE;
-    nsresult rv;
-    if (aIsSet) {
-      rv = wrappedNative->GetScriptableCallback()->
-        SetProperty(wrappedNative, cx, obj, id, &v, &retval);
-    } else {
-      rv = wrappedNative->GetScriptableCallback()->
-        GetProperty(wrappedNative, cx, obj, id, &v, &retval);
-    }
-    
-    if (NS_FAILED(rv)) {
-      return ThrowException(rv, cx);
-    }
-    if (!retval) {
-      return JS_FALSE;
-    }
-
-    if (rv == NS_SUCCESS_I_DID_SOMETHING) {
-      // Make sure v doesn't get collected while we're re-wrapping it.
-      AUTO_MARK_JSVAL(ccx, v);
-
-#ifdef DEBUG_XPCNativeWrapper
-      JSString* strId = ::JS_ValueToString(cx, id);
-      if (strId) {
-        NS_ConvertUTF16toUTF8 propName((PRUnichar*)::JS_GetStringChars(strId),
-                                       ::JS_GetStringLength(strId));
-        printf("%s via scriptable hooks for '%s'\n",
-               aIsSet ? "Set" : "Got", propName.get());
-      }
-#endif
-
-      return RewrapIfDeepWrapper(cx, obj, v, vp);
-    }
-  }
-  
-  if (!JSVAL_IS_STRING(id)) {
-    // Not going to be found here
-    return JS_TRUE;
-  }
-
-  // Verify that our jsobject really is a wrapped native.
-  XPCWrappedNative* wrapper = ccx.GetWrapper();
-  if (wrapper != wrappedNative || !wrapper->IsValid()) {
-    NS_ASSERTION(wrapper == wrappedNative, "Uh, how did this happen!");
-    return ThrowException(NS_ERROR_XPC_BAD_CONVERT_JS, cx);
-  }
-
-  // it would be a big surprise if there is a member without an
-  // interface :)
-  XPCNativeInterface* iface = ccx.GetInterface();
-  if (!iface) {
-
-    return JS_TRUE;
-  }
-
-  // did we find a method/attribute by that name?
-  XPCNativeMember* member = ccx.GetMember();
-  NS_ASSERTION(member, "not doing IDispatch, how'd this happen?");
-  if (!member) {
-    // No member, no IDL property to expose.
-
-    return JS_TRUE;
-  }
-
-  // Get (and perhaps lazily create) the member's value (commonly a
-  // cloneable function).
-  jsval memberval;
-  if (!member->GetValue(ccx, iface, &memberval)) {
-    return ThrowException(NS_ERROR_XPC_BAD_CONVERT_JS, cx);
-  }
-
-  if (member->IsConstant()) {
-    // Getting the value of constants is easy, just return the
-    // value. Setting is not supported (obviously).
-    if (aIsSet) {
-      return ThrowException(NS_ERROR_XPC_BAD_CONVERT_JS, cx);
-    }
-
-    *vp = memberval;
-
-    return JS_TRUE;
-  }
-
-  if (!member->IsAttribute()) {
-    // Getting the value of a method. Just return and let the value
-    // from XPC_NW_NewResolve() be used.
-
-    return JS_TRUE;
-  }
-
-  // Make sure the function we're cloning doesn't go away while
-  // we're cloning it.
-  AUTO_MARK_JSVAL(ccx, memberval);
-
-  // clone a function we can use for this object
-  JSObject* funobj = xpc_CloneJSFunction(ccx, JSVAL_TO_OBJECT(memberval),
-                                         wrapper->GetFlatJSObject());
-  if (!funobj) {
-    return JS_FALSE;
-  }
-
-  jsval *argv = nsnull;
-  uintN argc = 0;
-
-  if (aIsSet) {
-    if (member->IsReadOnlyAttribute()) {
-      // Trying to set a property for which there is no setter!
-      return ThrowException(NS_ERROR_NOT_AVAILABLE, cx);
-    }
-
-#ifdef DEBUG_XPCNativeWrapper
-    printf("Calling setter for %s\n",
-           ::JS_GetStringBytes(JSVAL_TO_STRING(id)));
-#endif
-
-    argv = vp;
-    argc = 1;
-  } else {
-#ifdef DEBUG_XPCNativeWrapper
-    printf("Calling getter for %s\n",
-           ::JS_GetStringBytes(JSVAL_TO_STRING(id)));
-#endif
-  }
-
-  // Call the getter
-  jsval v;
-  if (!::JS_CallFunctionValue(cx, wrapper->GetFlatJSObject(),
-                              OBJECT_TO_JSVAL(funobj), argc, argv, &v)) {
-    return JS_FALSE;
-  }
-
-  if (aIsSet) {
-    return JS_TRUE;
-  }
-
-  {
-    // Make sure v doesn't get collected while we're re-wrapping it.
-    AUTO_MARK_JSVAL(ccx, v);
-
-    return RewrapIfDeepWrapper(cx, obj, v, vp);
-  }
+  return XPCWrapper::GetOrSetNativeProperty(cx, obj, wrappedNative, id, vp,
+                                            aIsSet, JS_TRUE);
 }
 
 JS_STATIC_DLL_CALLBACK(JSBool)
@@ -682,45 +532,7 @@ XPC_NW_Enumerate(JSContext *cx, JSObject
     return JS_TRUE;
   }
 
-  JSIdArray *ida = JS_Enumerate(cx, wn->GetFlatJSObject());
-  if (!ida) {
-    return JS_FALSE;
-  }
-
-  JSBool ok = JS_TRUE;
-
-  for (jsint i = 0, n = ida->length; i < n; i++) {
-    JSObject *pobj;
-    JSProperty *prop;
-
-    // Let OBJ_LOOKUP_PROPERTY, in particular XPC_NW_NewResolve, figure
-    // out whether this id should be bypassed or reflected.
-    ok = OBJ_LOOKUP_PROPERTY(cx, obj, ida->vector[i], &pobj, &prop);
-    if (!ok) {
-      break;
-    }
-    if (prop) {
-      OBJ_DROP_PROPERTY(cx, pobj, prop);
-    }
-  }
-
-  JS_DestroyIdArray(cx, ida);
-  return ok;
-}
-
-static
-JSBool MaybePreserveWrapper(JSContext* cx, XPCWrappedNative *wn, uintN flags)
-{
-  if ((flags & JSRESOLVE_ASSIGNING) &&
-      (::JS_GetOptions(cx) & JSOPTION_PRIVATE_IS_NSISUPPORTS)) {
-    nsCOMPtr<nsIXPCScriptNotify> scriptNotify = 
-      do_QueryInterface(static_cast<nsISupports*>
-                                   (JS_GetContextPrivate(cx)));
-    if (scriptNotify) {
-      return NS_SUCCEEDED(scriptNotify->PreserveWrapper(wn));
-    }
-  }
-  return JS_TRUE;
+  return XPCWrapper::Enumerate(cx, obj, wn->GetFlatJSObject());
 }
 
 JS_STATIC_DLL_CALLBACK(JSBool)
@@ -793,159 +605,10 @@ XPC_NW_NewResolve(JSContext *cx, JSObjec
     return JS_TRUE;
   }
 
-  JSObject *nativeObj = wrappedNative->GetFlatJSObject();
-
-  // This will do verification and the method lookup for us.
-  XPCCallContext ccx(JS_CALLER, cx, nativeObj, nsnull, id);
-
-  // For "constructor" we don't want to call into the resolve hooks on the
-  // wrapped native, since that would give the wrong constructor.
-  if (NATIVE_HAS_FLAG(wrappedNative, WantNewResolve) &&
-      id != GetRTStringByIndex(cx, XPCJSRuntime::IDX_CONSTRUCTOR)) {
-
-    // Mark ourselves as resolving so our AddProperty hook can do the
-    // right thing here.
-    jsval oldFlags;
-    ::JS_GetReservedSlot(cx, obj, 0, &oldFlags);
-    if (!::JS_SetReservedSlot(cx, obj, 0,
-                              INT_TO_JSVAL(JSVAL_TO_INT(oldFlags) |
-                                           FLAG_RESOLVING))) {
-      return JS_FALSE;
-    }        
-    
-    XPCWrappedNative* oldResolvingWrapper = nsnull;
-    JSBool allowPropMods =
-      NATIVE_HAS_FLAG(wrappedNative, AllowPropModsDuringResolve);
-    if (allowPropMods) {
-      oldResolvingWrapper = ccx.SetResolvingWrapper(wrappedNative);
-    }
-      
-    JSBool retval = JS_TRUE;
-    JSObject* newObj = nsnull;
-    nsresult rv = wrappedNative->GetScriptableInfo()->
-      GetCallback()->NewResolve(wrappedNative, cx, obj, id, flags,
-                                &newObj, &retval);
-
-    if (allowPropMods) {
-      ccx.SetResolvingWrapper(oldResolvingWrapper);
-    }
-
-    if (!::JS_SetReservedSlot(cx, obj, 0, oldFlags)) {
-      return JS_FALSE;
-    }
-    
-    if (NS_FAILED(rv)) {
-      return ThrowException(rv, cx);
-    }
-
-    if (newObj) {
-#ifdef DEBUG_XPCNativeWrapper
-      JSString* strId = ::JS_ValueToString(cx, id);
-      if (strId) {
-        NS_ConvertUTF16toUTF8 propName((PRUnichar*)::JS_GetStringChars(strId),
-                                       ::JS_GetStringLength(strId));
-        printf("Resolved via scriptable hooks for '%s'\n", propName.get());
-      }
-#endif
-      // Note that we don't need to preserve the wrapper here, since this is
-      // not an "expando" property if the scriptable newResolve hook found it.
-      *objp = newObj;
-      return retval;
-    }      
-  }
-
-  if (!JSVAL_IS_STRING(id)) {
-    // A non-string id is being resolved. Won't be found here, return
-    // early.
-
-    return MaybePreserveWrapper(cx, wrappedNative, flags);
-  }
-
-  // Verify that our jsobject really is a wrapped native.
-  XPCWrappedNative* wrapper = ccx.GetWrapper();
-  if (wrapper != wrappedNative || !wrapper->IsValid()) {
-    NS_ASSERTION(wrapper == wrappedNative, "Uh, how did this happen!");
-    return ThrowException(NS_ERROR_XPC_BAD_CONVERT_JS, cx);
-  }
-
-  // it would be a big surprise if there is a member without an
-  // interface :)
-  XPCNativeInterface* iface = ccx.GetInterface();
-  if (!iface) {
-    // No interface, nothing to resolve.
-
-    return MaybePreserveWrapper(cx, wrappedNative, flags);
-  }
-
-  // did we find a method/attribute by that name?
-  XPCNativeMember* member = ccx.GetMember();
-  NS_ASSERTION(member, "not doing IDispatch, how'd this happen?");
-  if (!member) {
-    // No member, nothing to resolve.
-
-    return MaybePreserveWrapper(cx, wrappedNative, flags);
-  }
-
-  // Get (and perhaps lazily create) the member's value (commonly a
-  // cloneable function).
-  jsval memberval;
-  if (!member->GetValue(ccx, iface, &memberval)) {
-    return ThrowException(NS_ERROR_XPC_BAD_CONVERT_JS, cx);
-  }
-
-  // Make sure memberval doesn't go away while we mess with it.
-  AUTO_MARK_JSVAL(ccx, memberval);
-  
-  JSString *str = JSVAL_TO_STRING(id);
-  if (!str) {
-    return ThrowException(NS_ERROR_UNEXPECTED, cx);
-  }
-
-  jsval v;
-  uintN attrs = JSPROP_ENUMERATE;
-
-  if (member->IsConstant()) {
-    v = memberval;
-  } else if (member->IsAttribute()) {
-    // An attribute is being resolved. Define the property, the value
-    // will be dealt with in the get/set hooks.  Use JSPROP_SHARED to
-    // avoid entraining last-got or last-set garbage beyond the life
-    // of the value in the getter or setter call site.
-
-    v = JSVAL_VOID;
-    attrs |= JSPROP_SHARED;
-  } else {
-    // We're dealing with a method member here. Clone a function we can
-    // use for this object.  NB: cx's newborn roots will protect funobj
-    // and funWrapper and its object from GC.
-
-    JSObject* funobj = xpc_CloneJSFunction(ccx, JSVAL_TO_OBJECT(memberval),
-                                           wrapper->GetFlatJSObject());
-    if (!funobj) {
-      return JS_FALSE;
-    }
-
-    AUTO_MARK_JSVAL(ccx, OBJECT_TO_JSVAL(funobj));
-
-#ifdef DEBUG_XPCNativeWrapper
-    printf("Wrapping function object for %s\n",
-           ::JS_GetStringBytes(JSVAL_TO_STRING(id)));
-#endif
-
-    if (!WrapFunction(cx, funobj, &v)) {
-      return JS_FALSE;
-    }
-  }
-
-  if (!::JS_DefineUCProperty(cx, obj, ::JS_GetStringChars(str),
-                            ::JS_GetStringLength(str), v, nsnull, nsnull,
-                            attrs)) {
-    return JS_FALSE;
-  }
-
-  *objp = obj;
-
-  return JS_TRUE;
+  return XPCWrapper::ResolveNativeProperty(cx, obj,
+                                           wrappedNative->GetFlatJSObject(),
+                                           wrappedNative, id, flags, objp,
+                                           JS_TRUE);
 }
 
 JS_STATIC_DLL_CALLBACK(JSBool)
@@ -1061,7 +724,7 @@ XPC_NW_Construct(JSContext *cx, JSObject
     return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
   }
 
-  return RewrapIfDeepWrapper(cx, obj, *rval, rval);
+  return XPC_NW_RewrapIfDeepWrapper(cx, obj, *rval, rval);
 }
 
 JS_STATIC_DLL_CALLBACK(JSBool)
@@ -1109,6 +772,19 @@ XPCNativeWrapperCtor(JSContext *cx, JSOb
   }
 
   JSObject *nativeObj = JSVAL_TO_OBJECT(native);
+
+  // Unwrap a cross origin wrapper, since we're more restrictive than it is.
+  if (JS_GET_CLASS(cx, nativeObj) == &sXPC_XOW_JSClass.base) {
+    jsval v;
+    if (!::JS_GetReservedSlot(cx, nativeObj, XPCWrapper::sWrappedObjSlot, &v)) {
+      return JS_FALSE;
+    }
+    // If v is primitive, allow nativeObj to remain a cross origin wrapper,
+    // which will fail below (since it isn't a wrapped native).
+    if (!JSVAL_IS_PRIMITIVE(v)) {
+      nativeObj = JSVAL_TO_OBJECT(v);
+    }
+  }
 
   XPCWrappedNative *wrappedNative;
 
@@ -1321,18 +997,6 @@ XPC_NW_toString(JSContext *cx, JSObject 
     return JS_FALSE;
   }
 
-  // Check whether toString was overridden in any object along
-  // the wrapped native's object's prototype chain.
-  XPCJSRuntime *rt = nsXPConnect::GetRuntime();
-  if (!rt)
-    return JS_FALSE;
-
-  jsid id = rt->GetStringID(XPCJSRuntime::IDX_TO_STRING);
-  jsval idAsVal;
-  if (!::JS_IdToValue(cx, id, &idAsVal)) {
-    return JS_FALSE;
-  }
-
   XPCWrappedNative *wrappedNative =
     XPCNativeWrapper::GetWrappedNative(cx, obj);
 
@@ -1348,82 +1012,8 @@ XPC_NW_toString(JSContext *cx, JSObject 
     return JS_TRUE;
   }
 
-  // Someone is trying to call toString on our wrapped object.
-  JSObject *wn_obj = wrappedNative->GetFlatJSObject();
-  XPCCallContext ccx(JS_CALLER, cx, wn_obj, nsnull, idAsVal);
-  if (!ccx.IsValid()) {
-    // Shouldn't really happen.
-    return ThrowException(NS_ERROR_FAILURE, cx);
-  }
-
-  XPCNativeInterface *iface = ccx.GetInterface();
-  XPCNativeMember *member = ccx.GetMember();
-  JSBool overridden = JS_FALSE;
-  jsval toStringVal;
-
-  // First, try to see if the object declares a toString in its IDL. If it does,
-  // then we need to defer to that.
-  if (iface && member) {
-    if (!member->GetValue(ccx, iface, &toStringVal)) {
-      return JS_FALSE;
-    }
-
-    overridden = member->IsMethod();
-  }
-
-  JSString* str = nsnull;
-  if (overridden) {
-    // Defer to the IDL-declared toString.
-
-    AUTO_MARK_JSVAL(ccx, toStringVal);
-
-    JSObject *funobj = xpc_CloneJSFunction(ccx, JSVAL_TO_OBJECT(toStringVal),
-                                           wn_obj);
-    if (!funobj) {
-      return JS_FALSE;
-    }
-
-    jsval v;
-    if (!::JS_CallFunctionValue(cx, wn_obj, OBJECT_TO_JSVAL(funobj), argc, argv,
-                                &v)) {
-      return JS_FALSE;
-    }
-
-    if (JSVAL_IS_STRING(v)) {
-      str = JSVAL_TO_STRING(v);
-    }
-  }
-
-  if (!str) {
-    // Ok, we do no damage, and add value, by returning our own idea
-    // of what toString() should be.
-    // Note: We can't just call JS_ValueToString on the wrapped object. Instead,
-    // we need to call the wrapper's ToString in order to safely convert our
-    // object to a string.
-
-    nsAutoString resultString;
-    resultString.AppendLiteral("[object XPCNativeWrapper");
-
-    char *wrapperStr = wrappedNative->ToString(ccx);
-    if (!wrapperStr) {
-      return JS_FALSE;
-    }
-
-    resultString.Append(' ');
-    resultString.AppendASCII(wrapperStr);
-    JS_smprintf_free(wrapperStr);
-
-    resultString.Append(']');
-
-    str = ::JS_NewUCStringCopyN(cx, reinterpret_cast<const jschar *>
-                                                    (resultString.get()),
-                                resultString.Length());
-  }
-
-  NS_ENSURE_TRUE(str, JS_FALSE);
-
-  *rval = STRING_TO_JSVAL(str);
-  return JS_TRUE;
+  return XPCWrapper::NativeToString(cx, wrappedNative, argc, argv, rval,
+                                    JS_TRUE);
 }
 
 // static
@@ -1469,8 +1059,29 @@ XPCNativeWrapper::GetNewOrUsed(JSContext
     return nsnull;
   }
 
-  JSObject *obj = wrapper->GetNativeWrapper();
+  JSObject *obj = wrapper->GetWrapper();
+  if (obj && XPCNativeWrapper::IsNativeWrapper(cx, obj)) {
+    return obj;
+  }
+
+  XPCWrappedNativeScope *scope = wrapper->GetScope();
+  XPCJSRuntime *rt = nsXPConnect::GetRuntime();
+
+  { // Scoped lock.
+    XPCAutoLock al(rt->GetMapLock());
+
+    if (obj) {
+      obj = scope->GetWrapperMap()->Add(wrapper->GetFlatJSObject(), obj);
+      wrapper->SetWrapper(nsnull);
+    } else {
+      obj = scope->GetWrapperMap()->Find(wrapper->GetFlatJSObject());
+    }
+  }
+
   if (obj) {
+    NS_ASSERTION(XPCNativeWrapper::IsNativeWrapper(cx, obj),
+                 "Weird object in the wrapper map");
+    wrapper->SetWrapper(obj);
     return obj;
   }
 
@@ -1507,7 +1118,7 @@ XPCNativeWrapper::GetNewOrUsed(JSContext
     return nsnull;
   }
 
-  wrapper->SetNativeWrapper(obj);
+  wrapper->SetWrapper(obj);
 
 #if defined(DEBUG_XPCNativeWrapper) || defined(DEBUG_xpc_leaks)
   {
@@ -1540,7 +1151,7 @@ ClearNativeWrapperScope(JSDHashTable *ta
     JSDHashEntryStub* entry = (JSDHashEntryStub*)hdr;
     WrapperAndCxHolder* d = (WrapperAndCxHolder*)arg;
 
-    if (d->wrapper->GetNativeWrapper() == (JSObject*)entry->key)
+    if (d->wrapper->GetWrapper() == (JSObject*)entry->key)
     {
         ::JS_ClearScope(d->cx, (JSObject*)entry->key);
     }
@@ -1553,7 +1164,7 @@ XPCNativeWrapper::ClearWrappedNativeScop
 XPCNativeWrapper::ClearWrappedNativeScopes(JSContext* cx,
                                            XPCWrappedNative* wrapper)
 {
-  JSObject *nativeWrapper = wrapper->GetNativeWrapper();
+  JSObject *nativeWrapper = wrapper->GetWrapper();
 
   if (nativeWrapper) {
     ::JS_ClearScope(cx, nativeWrapper);
diff --git a/js/src/xpconnect/src/XPCNativeWrapper.h b/js/src/xpconnect/src/XPCNativeWrapper.h
--- a/js/src/xpconnect/src/XPCNativeWrapper.h
+++ b/js/src/xpconnect/src/XPCNativeWrapper.h
@@ -75,3 +75,6 @@ protected:
   static JSExtendedClass sXPC_NW_JSClass;
 };
 
+JSBool
+XPC_XOW_WrapObject(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
+                   jsval *rval);
diff --git a/js/src/xpconnect/src/XPCSafeJSObjectWrapper.cpp b/js/src/xpconnect/src/XPCSafeJSObjectWrapper.cpp
--- a/js/src/xpconnect/src/XPCSafeJSObjectWrapper.cpp
+++ b/js/src/xpconnect/src/XPCSafeJSObjectWrapper.cpp
@@ -40,6 +40,7 @@
 #include "xpcprivate.h"
 #include "jsdbgapi.h"
 #include "jsscript.h" // for js_ScriptClass
+#include "XPCWrapper.h"
 
 JS_STATIC_DLL_CALLBACK(JSBool)
 XPC_SJOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
@@ -186,7 +187,8 @@ JSExtendedClass sXPC_SJOW_JSClass = {
 JSExtendedClass sXPC_SJOW_JSClass = {
   // JSClass (JSExtendedClass.base) initialization
   { "XPCSafeJSObjectWrapper",
-    JSCLASS_NEW_RESOLVE | JSCLASS_IS_EXTENDED | JSCLASS_HAS_RESERVED_SLOTS(5),
+    JSCLASS_NEW_RESOLVE | JSCLASS_IS_EXTENDED |
+    JSCLASS_HAS_RESERVED_SLOTS(XPCWrapper::sNumSlots + 3),
     XPC_SJOW_AddProperty, XPC_SJOW_DelProperty,
     XPC_SJOW_GetProperty, XPC_SJOW_SetProperty,
     XPC_SJOW_Enumerate,   (JSResolveOp)XPC_SJOW_NewResolve,
@@ -495,21 +497,7 @@ XPC_SJOW_AddProperty(JSContext *cx, JSOb
     return JS_FALSE;
   }
 
-  if (JSVAL_IS_STRING(id)) {
-    JSString *str = JSVAL_TO_STRING(id);
-    jschar *chars = ::JS_GetStringChars(str);
-    size_t length = ::JS_GetStringLength(str);
-
-    return ::JS_DefineUCProperty(cx, unsafeObj, chars, length, *vp, nsnull,
-                                 nsnull, JSPROP_ENUMERATE);
-  }
-
-  if (!JSVAL_IS_INT(id)) {
-    return ThrowException(NS_ERROR_NOT_IMPLEMENTED, cx);
-  }
-
-  return ::JS_DefineElement(cx, unsafeObj, JSVAL_TO_INT(id), *vp, nsnull,
-                            nsnull, JSPROP_ENUMERATE);
+  return XPCWrapper::AddProperty(cx, unsafeObj, id, vp);
 }
 
 JS_STATIC_DLL_CALLBACK(JSBool)
@@ -526,19 +514,7 @@ XPC_SJOW_DelProperty(JSContext *cx, JSOb
     return JS_FALSE;
   }
 
-  if (JSVAL_IS_STRING(id)) {
-    JSString *str = JSVAL_TO_STRING(id);
-    jschar *chars = ::JS_GetStringChars(str);
-    size_t length = ::JS_GetStringLength(str);
-
-    return ::JS_DeleteUCProperty2(cx, unsafeObj, chars, length, vp);
-  }
-
-  if (!JSVAL_IS_INT(id)) {
-    return ThrowException(NS_ERROR_NOT_IMPLEMENTED, cx);
-  }
-
-  return ::JS_DeleteElement2(cx, unsafeObj, JSVAL_TO_INT(id), vp);
+  return XPCWrapper::DelProperty(cx, unsafeObj, id, vp);
 }
 
 // Call wrapper to help with wrapping calls to functions or callable
@@ -649,32 +625,7 @@ XPC_SJOW_Enumerate(JSContext *cx, JSObje
   // look up unsafeObj.__iterator__ and if we don't have permission to
   // access that, it'll throw and we'll be safe.
 
-  JSIdArray *ida = JS_Enumerate(cx, unsafeObj);
-  if (!ida) {
-    return JS_FALSE;
-  }
-
-  JSBool ok = JS_TRUE;
-
-  for (jsint i = 0, n = ida->length; i < n; i++) {
-    JSObject *pobj;
-    JSProperty *prop;
-
-    // Let OBJ_LOOKUP_PROPERTY, in particular XPC_SJOW_NewResolve,
-    // figure out whether this id should be reflected.
-    ok = OBJ_LOOKUP_PROPERTY(cx, obj, ida->vector[i], &pobj, &prop);
-    if (!ok) {
-      break;
-    }
-
-    if (prop) {
-      OBJ_DROP_PROPERTY(cx, pobj, prop);
-    }
-  }
-
-  JS_DestroyIdArray(cx, ida);
-
-  return ok;
+  return XPCWrapper::Enumerate(cx, obj, unsafeObj);
 }
 
 JS_STATIC_DLL_CALLBACK(JSBool)
@@ -702,58 +653,7 @@ XPC_SJOW_NewResolve(JSContext *cx, JSObj
     return JS_FALSE;
   }
 
-  jschar *chars = nsnull;
-  size_t length;
-  JSBool hasProp, ok;
-
-  if (JSVAL_IS_STRING(id)) {
-    JSString *str = JSVAL_TO_STRING(id);
-
-    chars = ::JS_GetStringChars(str);
-    length = ::JS_GetStringLength(str);
-
-    ok = ::JS_HasUCProperty(cx, unsafeObj, chars, length, &hasProp);
-  } else if (JSVAL_IS_INT(id)) {
-    ok = ::JS_HasElement(cx, unsafeObj, JSVAL_TO_INT(id), &hasProp);
-  } else {
-    // A non-string and non-int id is being resolved. We don't deal
-    // with those yet, return early.
-
-    return ThrowException(NS_ERROR_INVALID_ARG, cx);
-  }
-
-  if (!ok || !hasProp) {
-    // An error occured, or the property was not found. Return
-    // early. This is safe even in the case of a set operation since
-    // if the property doesn't exist there's no chance of a setter
-    // being called or any other code being run as a result of the
-    // set.
-
-    return ok;
-  }
-
-  jsval oldSlotVal;
-  if (!::JS_GetReservedSlot(cx, obj, XPC_SJOW_SLOT_IS_RESOLVING,
-                            &oldSlotVal) ||
-      !::JS_SetReservedSlot(cx, obj, XPC_SJOW_SLOT_IS_RESOLVING,
-                            BOOLEAN_TO_JSVAL(JS_TRUE))) {
-    return JS_FALSE;
-  }
-
-  if (chars) {
-    ok = ::JS_DefineUCProperty(cx, obj, chars, length, JSVAL_VOID,
-                               nsnull, nsnull, JSPROP_ENUMERATE);
-  } else {
-    ok = ::JS_DefineElement(cx, obj, JSVAL_TO_INT(id), JSVAL_VOID,
-                            nsnull, nsnull, JSPROP_ENUMERATE);
-  }
-
-  if (ok && (ok = ::JS_SetReservedSlot(cx, obj, XPC_SJOW_SLOT_IS_RESOLVING,
-                                       oldSlotVal))) {
-    *objp = obj;
-  }
-
-  return ok;
+  return XPCWrapper::NewResolve(cx, obj, unsafeObj, id, flags, objp);
 }
 
 JS_STATIC_DLL_CALLBACK(JSBool)
diff --git a/js/src/xpconnect/src/XPCWrapper.cpp b/js/src/xpconnect/src/XPCWrapper.cpp
new file mode 100644
--- /dev/null
+++ b/js/src/xpconnect/src/XPCWrapper.cpp
@@ -0,0 +1,648 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=2 sw=2 et tw=78: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Johnny Stenback <jst@mozilla.org> (original author)
+ *   Brendan Eich <brendan@mozilla.org>
+ *   Boris Zbarsky <bzbarsky@mit.edu>
+ *   Blake Kaplan <mrbkap@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "XPCWrapper.h"
+
+const PRUint32
+XPCWrapper::sWrappedObjSlot = 1;
+
+const PRUint32
+XPCWrapper::sResolvingSlot = 0;
+
+const PRUint32
+XPCWrapper::sNumSlots = 2;
+
+// static
+JSBool
+XPCWrapper::AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+  if (JSVAL_IS_STRING(id)) {
+    JSString *str = JSVAL_TO_STRING(id);
+    jschar *chars = ::JS_GetStringChars(str);
+    size_t length = ::JS_GetStringLength(str);
+
+    return ::JS_DefineUCProperty(cx, obj, chars, length, *vp, nsnull,
+                                 nsnull, JSPROP_ENUMERATE);
+  }
+
+  if (!JSVAL_IS_INT(id)) {
+    return ThrowException(NS_ERROR_NOT_IMPLEMENTED, cx);
+  }
+
+  return ::JS_DefineElement(cx, obj, JSVAL_TO_INT(id), *vp, nsnull,
+                            nsnull, JSPROP_ENUMERATE);
+}
+
+// static
+JSBool
+XPCWrapper::DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+  if (JSVAL_IS_STRING(id)) {
+    JSString *str = JSVAL_TO_STRING(id);
+    jschar *chars = ::JS_GetStringChars(str);
+    size_t length = ::JS_GetStringLength(str);
+
+    return ::JS_DeleteUCProperty2(cx, obj, chars, length, vp);
+  }
+
+  if (!JSVAL_IS_INT(id)) {
+    return ThrowException(NS_ERROR_NOT_IMPLEMENTED, cx);
+  }
+
+  return ::JS_DeleteElement2(cx, obj, JSVAL_TO_INT(id), vp);
+}
+
+// static
+JSBool
+XPCWrapper::Enumerate(JSContext *cx, JSObject *wrapperObj, JSObject *innerObj)
+{
+  // We are being notified of a for-in loop or similar operation on
+  // this wrapper. Forward to the correct high-level object hook,
+  // OBJ_ENUMERATE on the unsafe object, called via the JS_Enumerate API.
+  // Then reflect properties named by the enumerated identifiers from the
+  // unsafe object to the safe wrapper.
+
+  JSIdArray *ida = JS_Enumerate(cx, innerObj);
+  if (!ida) {
+    return JS_FALSE;
+  }
+
+  JSBool ok = JS_TRUE;
+
+  for (jsint i = 0, n = ida->length; i < n; i++) {
+    JSObject *pobj;
+    JSProperty *prop;
+
+    // Let OBJ_LOOKUP_PROPERTY, in particular our NewResolve hook,
+    // figure out whether this id should be reflected.
+    ok = OBJ_LOOKUP_PROPERTY(cx, wrapperObj, ida->vector[i], &pobj, &prop);
+    if (!ok) {
+      break;
+    }
+
+    if (prop) {
+      OBJ_DROP_PROPERTY(cx, pobj, prop);
+    }
+  }
+
+  JS_DestroyIdArray(cx, ida);
+
+  return ok;
+}
+
+// static
+JSBool
+XPCWrapper::NewResolve(JSContext *cx, JSObject *wrapperObj,
+                       JSObject *innerObj, jsval id, uintN flags,
+                       JSObject **objp, JSBool preserveVal)
+{
+  jschar *chars = nsnull;
+  size_t length;
+  JSBool hasProp, ok;
+  jsval v = JSVAL_VOID;
+
+  if (JSVAL_IS_STRING(id)) {
+    JSString *str = JSVAL_TO_STRING(id);
+
+    chars = ::JS_GetStringChars(str);
+    length = ::JS_GetStringLength(str);
+
+    ok = ::JS_HasUCProperty(cx, innerObj, chars, length, &hasProp);
+    if (preserveVal && ok && hasProp) {
+      ok = ::JS_LookupUCProperty(cx, innerObj, chars, length, &v);
+    }
+  } else if (JSVAL_IS_INT(id)) {
+    ok = ::JS_HasElement(cx, innerObj, JSVAL_TO_INT(id), &hasProp);
+    if (preserveVal && ok && hasProp) {
+      ok = ::JS_LookupElement(cx, innerObj, JSVAL_TO_INT(id), &v);
+    }
+  } else {
+    // FIXME: https://bugzilla.mozilla.org/show_bug.cgi?id=381662
+    // A non-string and non-int id is being resolved. We don't deal
+    // with those yet, return early.
+
+    return ThrowException(NS_ERROR_INVALID_ARG, cx);
+  }
+
+  if (!ok || !hasProp) {
+    // An error occured, or the property was not found. Return
+    // early. This is safe even in the case of a set operation since
+    // if the property doesn't exist there's no chance of a setter
+    // being called or any other code being run as a result of the
+    // set.
+
+    return ok;
+  }
+
+  jsval oldSlotVal;
+  if (!::JS_GetReservedSlot(cx, wrapperObj, sResolvingSlot, &oldSlotVal) ||
+      !::JS_SetReservedSlot(cx, wrapperObj, sResolvingSlot,
+                            BOOLEAN_TO_JSVAL(JS_TRUE))) {
+    return JS_FALSE;
+  }
+
+  if (chars) {
+    ok = ::JS_DefineUCProperty(cx, wrapperObj, chars, length, v,
+                               nsnull, nsnull, JSPROP_ENUMERATE);
+  } else {
+    ok = ::JS_DefineElement(cx, wrapperObj, JSVAL_TO_INT(id), v,
+                            nsnull, nsnull, JSPROP_ENUMERATE);
+  }
+
+  if (ok && (ok = ::JS_SetReservedSlot(cx, wrapperObj, sResolvingSlot,
+                                       oldSlotVal))) {
+    *objp = wrapperObj;
+  }
+
+  return ok;
+}
+
+// static
+JSBool
+XPCWrapper::ResolveNativeProperty(JSContext *cx, JSObject *wrapperObj,
+                                  JSObject *innerObj, XPCWrappedNative *wn,
+                                  jsval id, uintN flags, JSObject **objp,
+                                  JSBool isNativeWrapper)
+{
+  // This will do verification and the method lookup for us.
+  XPCCallContext ccx(JS_CALLER, cx, innerObj, nsnull, id);
+
+  // For "constructor" we don't want to call into the resolve hooks on the
+  // wrapped native, since that would give the wrong constructor.
+  if (NATIVE_HAS_FLAG(wn, WantNewResolve) &&
+      id != GetRTStringByIndex(cx, XPCJSRuntime::IDX_CONSTRUCTOR)) {
+
+    // Mark ourselves as resolving so our AddProperty hook can do the
+    // right thing here.
+    jsval oldFlags;
+    if (isNativeWrapper) {
+      if (!::JS_GetReservedSlot(cx, wrapperObj, 0, &oldFlags) ||
+          !::JS_SetReservedSlot(cx, wrapperObj, 0,
+                                INT_TO_JSVAL(JSVAL_TO_INT(oldFlags) |
+                                             FLAG_RESOLVING))) {
+        return JS_FALSE;
+      }
+    } else {
+      if (!::JS_GetReservedSlot(cx, wrapperObj, sResolvingSlot, &oldFlags) ||
+          !::JS_SetReservedSlot(cx, wrapperObj, sResolvingSlot, JSVAL_TRUE)) {
+        return JS_FALSE;
+      }
+    }
+
+    XPCWrappedNative* oldResolvingWrapper = nsnull;
+    JSBool allowPropMods =
+      NATIVE_HAS_FLAG(wn, AllowPropModsDuringResolve);
+    if (allowPropMods) {
+      oldResolvingWrapper = ccx.SetResolvingWrapper(wn);
+    }
+
+    JSBool retval = JS_TRUE;
+    JSObject* newObj = nsnull;
+    nsresult rv = wn->GetScriptableInfo()->
+      GetCallback()->NewResolve(wn, cx, wrapperObj, id, flags,
+                                &newObj, &retval);
+
+    if (allowPropMods) {
+      ccx.SetResolvingWrapper(oldResolvingWrapper);
+    }
+
+    if (!::JS_SetReservedSlot(cx, wrapperObj,
+                              isNativeWrapper ? 0 : sResolvingSlot,
+                              oldFlags)) {
+      return JS_FALSE;
+    }
+
+    if (NS_FAILED(rv)) {
+      return ThrowException(rv, cx);
+    }
+
+    if (newObj) {
+      if (isNativeWrapper || newObj == wrapperObj) {
+#ifdef DEBUG_XPCNativeWrapper
+        JSString* strId = ::JS_ValueToString(cx, id);
+        if (strId) {
+          NS_ConvertUTF16toUTF8 propName((PRUnichar*)::JS_GetStringChars(strId),
+                                         ::JS_GetStringLength(strId));
+          printf("Resolved via scriptable hooks for '%s'\n", propName.get());
+        }
+#endif
+        // Note that we don't need to preserve the wrapper here, since this is
+        // not an "expando" property if the scriptable newResolve hook found it.
+        *objp = newObj;
+        return retval;
+      }
+
+      return NewResolve(cx, wrapperObj, innerObj, id, flags, objp, JS_TRUE);
+    }
+  }
+
+  if (!JSVAL_IS_STRING(id)) {
+    // A non-string id is being resolved. Won't be found here, return
+    // early.
+
+    return MaybePreserveWrapper(cx, wn, flags);
+  }
+
+  // Verify that our jsobject really is a wrapped native.
+  XPCWrappedNative* wrapper = ccx.GetWrapper();
+  if (wrapper != wn || !wrapper->IsValid()) {
+    NS_ASSERTION(wrapper == wn, "Uh, how did this happen!");
+    return ThrowException(NS_ERROR_XPC_BAD_CONVERT_JS, cx);
+  }
+
+  // it would be a big surprise if there is a member without an
+  // interface :)
+  XPCNativeInterface* iface = ccx.GetInterface();
+  if (!iface) {
+    // No interface, nothing to resolve.
+
+    return MaybePreserveWrapper(cx, wn, flags);
+  }
+
+  // did we find a method/attribute by that name?
+  XPCNativeMember* member = ccx.GetMember();
+  NS_ASSERTION(member, "not doing IDispatch, how'd this happen?");
+  if (!member) {
+    // No member, nothing to resolve.
+
+    return MaybePreserveWrapper(cx, wn, flags);
+  }
+
+  // Get (and perhaps lazily create) the member's value (commonly a
+  // cloneable function).
+  jsval memberval;
+  if (!member->GetValue(ccx, iface, &memberval)) {
+    return ThrowException(NS_ERROR_XPC_BAD_CONVERT_JS, cx);
+  }
+
+  // Make sure memberval doesn't go away while we mess with it.
+  AUTO_MARK_JSVAL(ccx, memberval);
+
+  JSString *str = JSVAL_TO_STRING(id);
+  if (!str) {
+    return ThrowException(NS_ERROR_UNEXPECTED, cx);
+  }
+
+  jsval v;
+  uintN attrs = JSPROP_ENUMERATE;
+
+  if (member->IsConstant()) {
+    v = memberval;
+  } else if (member->IsAttribute()) {
+    // An attribute is being resolved. Define the property, the value
+    // will be dealt with in the get/set hooks.  Use JSPROP_SHARED to
+    // avoid entraining last-got or last-set garbage beyond the life
+    // of the value in the getter or setter call site.
+
+    v = JSVAL_VOID;
+    attrs |= JSPROP_SHARED;
+  } else {
+    // We're dealing with a method member here. Clone a function we can
+    // use for this object.  NB: cx's newborn roots will protect funobj
+    // and funWrapper and its object from GC.
+
+    JSObject* funobj = xpc_CloneJSFunction(ccx, JSVAL_TO_OBJECT(memberval),
+                                           wrapper->GetFlatJSObject());
+    if (!funobj) {
+      return JS_FALSE;
+    }
+
+    AUTO_MARK_JSVAL(ccx, OBJECT_TO_JSVAL(funobj));
+
+#ifdef DEBUG_XPCNativeWrapper
+    printf("Wrapping function object for %s\n",
+           ::JS_GetStringBytes(JSVAL_TO_STRING(id)));
+#endif
+
+    if (!WrapFunction(cx, wrapperObj, funobj, &v, isNativeWrapper)) {
+      return JS_FALSE;
+    }
+  }
+
+  // XPCNativeWrapper doesn't need to do this.
+  jsval oldFlags;
+  if (!isNativeWrapper &&
+      (!::JS_GetReservedSlot(cx, wrapperObj, sResolvingSlot, &oldFlags) ||
+       !::JS_SetReservedSlot(cx, wrapperObj, sResolvingSlot, JSVAL_TRUE))) {
+    return JS_FALSE;
+  }
+
+  if (!::JS_DefineUCProperty(cx, wrapperObj, ::JS_GetStringChars(str),
+                            ::JS_GetStringLength(str), v, nsnull, nsnull,
+                            attrs)) {
+    return JS_FALSE;
+  }
+
+  if (!isNativeWrapper &&
+      !::JS_SetReservedSlot(cx, wrapperObj, sResolvingSlot, oldFlags)) {
+    return JS_FALSE;
+  }
+
+  *objp = wrapperObj;
+
+  return JS_TRUE;
+}
+
+// static
+JSBool
+XPCWrapper::GetOrSetNativeProperty(JSContext *cx, JSObject *obj,
+                                   XPCWrappedNative *wrappedNative,
+                                   jsval id, jsval *vp, JSBool aIsSet,
+                                   JSBool isNativeWrapper)
+{
+  // This will do verification and the method lookup for us.
+  JSObject *nativeObj = wrappedNative->GetFlatJSObject();
+  XPCCallContext ccx(JS_CALLER, cx, nativeObj, nsnull, id);
+
+  if (aIsSet ? NATIVE_HAS_FLAG(wrappedNative, WantSetProperty) :
+               NATIVE_HAS_FLAG(wrappedNative, WantGetProperty)) {
+
+    jsval v = *vp;
+    // Note that some sets return random DOM objects (setting
+    // document.location, say), so we want to rewrap for sets too if v != *vp.
+    JSBool retval = JS_TRUE;
+    nsresult rv;
+    if (aIsSet) {
+      rv = wrappedNative->GetScriptableCallback()->
+        SetProperty(wrappedNative, cx, obj, id, &v, &retval);
+    } else {
+      rv = wrappedNative->GetScriptableCallback()->
+        GetProperty(wrappedNative, cx, obj, id, &v, &retval);
+    }
+
+    if (NS_FAILED(rv)) {
+      return ThrowException(rv, cx);
+    }
+    if (!retval) {
+      return JS_FALSE;
+    }
+
+    if (rv == NS_SUCCESS_I_DID_SOMETHING) {
+      // Make sure v doesn't get collected while we're re-wrapping it.
+      AUTO_MARK_JSVAL(ccx, v);
+
+#ifdef DEBUG_XPCNativeWrapper
+      JSString* strId = ::JS_ValueToString(cx, id);
+      if (strId) {
+        NS_ConvertUTF16toUTF8 propName((PRUnichar*)::JS_GetStringChars(strId),
+                                       ::JS_GetStringLength(strId));
+        printf("%s via scriptable hooks for '%s'\n",
+               aIsSet ? "Set" : "Got", propName.get());
+      }
+#endif
+
+      return RewrapIfDeepWrapper(cx, obj, v, vp, isNativeWrapper);
+    }
+  }
+
+  if (!JSVAL_IS_STRING(id)) {
+    // Not going to be found here
+    return JS_TRUE;
+  }
+
+  // Verify that our jsobject really is a wrapped native.
+  XPCWrappedNative* wrapper = ccx.GetWrapper();
+  if (wrapper != wrappedNative || !wrapper->IsValid()) {
+    NS_ASSERTION(wrapper == wrappedNative, "Uh, how did this happen!");
+    return ThrowException(NS_ERROR_XPC_BAD_CONVERT_JS, cx);
+  }
+
+  // it would be a big surprise if there is a member without an
+  // interface :)
+  XPCNativeInterface* iface = ccx.GetInterface();
+  if (!iface) {
+
+    return JS_TRUE;
+  }
+
+  // did we find a method/attribute by that name?
+  XPCNativeMember* member = ccx.GetMember();
+  NS_ASSERTION(member, "not doing IDispatch, how'd this happen?");
+  if (!member) {
+    // No member, no IDL property to expose.
+
+    return JS_TRUE;
+  }
+
+  // Get (and perhaps lazily create) the member's value (commonly a
+  // cloneable function).
+  jsval memberval;
+  if (!member->GetValue(ccx, iface, &memberval)) {
+    return ThrowException(NS_ERROR_XPC_BAD_CONVERT_JS, cx);
+  }
+
+  if (member->IsConstant()) {
+    // Getting the value of constants is easy, just return the
+    // value. Setting is not supported (obviously).
+    if (aIsSet) {
+      return ThrowException(NS_ERROR_XPC_BAD_CONVERT_JS, cx);
+    }
+
+    *vp = memberval;
+
+    return JS_TRUE;
+  }
+
+  if (!member->IsAttribute()) {
+    // Getting the value of a method. Just return and let the value
+    // from XPC_NW_NewResolve() be used.
+
+    return JS_TRUE;
+  }
+
+  // Make sure the function we're cloning doesn't go away while
+  // we're cloning it.
+  AUTO_MARK_JSVAL(ccx, memberval);
+
+  // clone a function we can use for this object
+  JSObject* funobj = xpc_CloneJSFunction(ccx, JSVAL_TO_OBJECT(memberval),
+                                         wrapper->GetFlatJSObject());
+  if (!funobj) {
+    return JS_FALSE;
+  }
+
+  jsval *argv = nsnull;
+  uintN argc = 0;
+
+  if (aIsSet) {
+    if (member->IsReadOnlyAttribute()) {
+      // Trying to set a property for which there is no setter!
+      return ThrowException(NS_ERROR_NOT_AVAILABLE, cx);
+    }
+
+#ifdef DEBUG_XPCNativeWrapper
+    printf("Calling setter for %s\n",
+           ::JS_GetStringBytes(JSVAL_TO_STRING(id)));
+#endif
+
+    argv = vp;
+    argc = 1;
+  } else {
+#ifdef DEBUG_XPCNativeWrapper
+    printf("Calling getter for %s\n",
+           ::JS_GetStringBytes(JSVAL_TO_STRING(id)));
+#endif
+  }
+
+  // Call the getter
+  jsval v;
+  if (!::JS_CallFunctionValue(cx, wrapper->GetFlatJSObject(),
+                              OBJECT_TO_JSVAL(funobj), argc, argv, &v)) {
+    return JS_FALSE;
+  }
+
+  if (aIsSet) {
+    return JS_TRUE;
+  }
+
+  {
+    // Make sure v doesn't get collected while we're re-wrapping it.
+    AUTO_MARK_JSVAL(ccx, v);
+
+    return RewrapIfDeepWrapper(cx, obj, v, vp, isNativeWrapper);
+  }
+}
+
+// static
+JSBool
+XPCWrapper::NativeToString(JSContext *cx, XPCWrappedNative *wrappedNative,
+                           uintN argc, jsval *argv, jsval *rval,
+                           JSBool isNativeWrapper)
+{
+  // Check whether toString was overridden in any object along
+  // the wrapped native's object's prototype chain.
+  XPCJSRuntime *rt = nsXPConnect::GetRuntime();
+  if (!rt)
+    return JS_FALSE;
+
+  jsid id = rt->GetStringID(XPCJSRuntime::IDX_TO_STRING);
+  jsval idAsVal;
+  if (!::JS_IdToValue(cx, id, &idAsVal)) {
+    return JS_FALSE;
+  }
+
+  // Someone is trying to call toString on our wrapped object.
+  JSObject *wn_obj = wrappedNative->GetFlatJSObject();
+  XPCCallContext ccx(JS_CALLER, cx, wn_obj, nsnull, idAsVal);
+  if (!ccx.IsValid()) {
+    // Shouldn't really happen.
+    return ThrowException(NS_ERROR_FAILURE, cx);
+  }
+
+  XPCNativeInterface *iface = ccx.GetInterface();
+  XPCNativeMember *member = ccx.GetMember();
+  JSBool overridden = JS_FALSE;
+  jsval toStringVal;
+
+  // First, try to see if the object declares a toString in its IDL. If it does,
+  // then we need to defer to that.
+  if (iface && member) {
+    if (!member->GetValue(ccx, iface, &toStringVal)) {
+      return JS_FALSE;
+    }
+
+    overridden = member->IsMethod();
+  }
+
+  JSString* str = nsnull;
+  if (overridden) {
+    // Defer to the IDL-declared toString.
+
+    AUTO_MARK_JSVAL(ccx, toStringVal);
+
+    JSObject *funobj = xpc_CloneJSFunction(ccx, JSVAL_TO_OBJECT(toStringVal),
+                                           wn_obj);
+    if (!funobj) {
+      return JS_FALSE;
+    }
+
+    jsval v;
+    if (!::JS_CallFunctionValue(cx, wn_obj, OBJECT_TO_JSVAL(funobj), argc, argv,
+                                &v)) {
+      return JS_FALSE;
+    }
+
+    if (JSVAL_IS_STRING(v)) {
+      str = JSVAL_TO_STRING(v);
+    }
+  }
+
+  if (!str) {
+    // Ok, we do no damage, and add value, by returning our own idea
+    // of what toString() should be.
+    // Note: We can't just call JS_ValueToString on the wrapped object. Instead,
+    // we need to call the wrapper's ToString in order to safely convert our
+    // object to a string.
+
+    char *wrapperStr = nsnull;
+    nsAutoString resultString;
+    if (isNativeWrapper) {
+      resultString.AppendLiteral("[object XPCNativeWrapper ");
+
+      wrapperStr = wrappedNative->ToString(ccx);
+      if (!wrapperStr) {
+        return JS_FALSE;
+      }
+    } else {
+      resultString.AppendLiteral("[object XPCCrossOriginWrapper ");
+
+      wrapperStr = wrappedNative->ToString(ccx);
+      if (!wrapperStr) {
+        return JS_FALSE;
+      }
+    }
+
+    resultString.AppendASCII(wrapperStr);
+    JS_smprintf_free(wrapperStr);
+
+    resultString.Append(']');
+
+    str = ::JS_NewUCStringCopyN(cx, reinterpret_cast<const jschar *>
+                                                    (resultString.get()),
+                                resultString.Length());
+  }
+
+  NS_ENSURE_TRUE(str, JS_FALSE);
+
+  *rval = STRING_TO_JSVAL(str);
+  return JS_TRUE;
+}
diff --git a/js/src/xpconnect/src/XPCWrapper.h b/js/src/xpconnect/src/XPCWrapper.h
new file mode 100644
--- /dev/null
+++ b/js/src/xpconnect/src/XPCWrapper.h
@@ -0,0 +1,254 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=2 sw=2 et tw=78: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Johnny Stenback <jst@mozilla.org> (original author)
+ *   Brendan Eich <brendan@mozilla.org>
+ *   Boris Zbarsky <bzbarsky@mit.edu>
+ *   Blake Kaplan <mrbkap@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef XPC_WRAPPER_H
+#define XPC_WRAPPER_H 1
+
+#include "xpcprivate.h"
+
+/* These are used by XPCNativeWrapper polluted code in the common wrapper. */
+#define FLAG_DEEP     0x1
+#define FLAG_EXPLICIT 0x2
+// FLAG_RESOLVING is used to tag an XPCNativeWrapper when while it's calling
+// the newResolve hook on the XPCWrappedNative's scriptable info.
+#define FLAG_RESOLVING 0x4
+
+#define HAS_FLAGS(_val, _flags) \
+  ((PRUint32(JSVAL_TO_INT(_val)) & (_flags)) != 0)
+
+#define NATIVE_HAS_FLAG(_wn, _flag)                \
+  ((_wn)->GetScriptableInfo() &&                   \
+   (_wn)->GetScriptableInfo()->GetFlags()._flag())
+
+JSBool
+XPC_NW_WrapFunction(JSContext* cx, JSObject* funobj, jsval *rval);
+
+JSBool
+XPC_NW_RewrapIfDeepWrapper(JSContext *cx, JSObject *obj, jsval v,
+                           jsval *rval);
+
+/* These are used by XPC_XOW_* polluted code in the common wrapper. */
+JSBool
+XPC_XOW_WrapFunction(JSContext *cx, JSObject *wrapperObj, JSObject *funobj,
+                     jsval *rval);
+
+JSBool
+XPC_XOW_RewrapIfNeeded(JSContext *cx, JSObject *wrapperObj, jsval *vp);
+
+nsresult
+IsWrapperSameOrigin(JSContext *cx, JSObject *wrappedObj);
+
+inline JSBool
+XPC_XOW_ClassNeedsXOW(const char *name)
+{
+  // TODO Make a perfect hash of these and use that?
+  return !strcmp(name, "Window")            ||
+         !strcmp(name, "Location")          ||
+         !strcmp(name, "HTMLDocument")      ||
+         !strcmp(name, "HTMLIFrameElement") ||
+         !strcmp(name, "HTMLFrameElement");
+}
+
+extern JSExtendedClass sXPC_XOW_JSClass;
+
+// This class wraps some common functionality between the three existing
+// wrappers. Its main purpose is to allow XPCCrossOriginWrapper to act both
+// as an XPCSafeSJSObjectWrapper and as an XPCNativeWrapper when required to
+// do so (the decision is based on the principals of the wrapper and wrapped
+// objects).
+class XPCWrapper
+{
+public:
+  /**
+   * Used by the cross origin and safe wrappers: the slot that the wrapped
+   * object is held in.
+   */
+  static const PRUint32 sWrappedObjSlot;
+
+  /**
+   * Used by the cross origin and safe wrappers: the slot that tells the
+   * AddProperty code that we're resolving a property, and therefore to not do
+   * a security check.
+   */
+  static const PRUint32 sResolvingSlot;
+
+  /**
+   * The base number of slots needed by code using the above constants.
+   */
+  static const PRUint32 sNumSlots;
+
+  /**
+   * A useful function that throws an exception onto cx.
+   */
+  static JSBool ThrowException(nsresult ex, JSContext *cx) {
+    XPCThrower::Throw(ex, cx);
+    return JS_FALSE;
+  }
+
+  /**
+   * Used to ensure that an XPCWrappedNative stays alive when its scriptable
+   * helper defines an "expando" property on it.
+   */
+  static JSBool MaybePreserveWrapper(JSContext *cx, XPCWrappedNative *wn,
+                                     uintN flags) {
+    if ((flags & JSRESOLVE_ASSIGNING) &&
+        (::JS_GetOptions(cx) & JSOPTION_PRIVATE_IS_NSISUPPORTS)) {
+      nsCOMPtr<nsIXPCScriptNotify> scriptNotify = 
+        do_QueryInterface(NS_STATIC_CAST(nsISupports*,
+                                         JS_GetContextPrivate(cx)));
+      if (scriptNotify) {
+        return NS_SUCCEEDED(scriptNotify->PreserveWrapper(wn));
+      }
+    }
+    return JS_TRUE;
+  }
+
+  /**
+   * Unwraps an XPCSafeJSObjectWrapper or an XPCCrossOriginWrapper into its
+   * wrapped native.
+   */
+  static JSObject *Unwrap(JSContext *cx, JSObject *wrapper) {
+    if (JS_GET_CLASS(cx, wrapper) != &sXPC_XOW_JSClass.base) {
+      return nsnull;
+    }
+
+    jsval v;
+    if (!JS_GetReservedSlot(cx, wrapper, XPCWrapper::sWrappedObjSlot, &v)) {
+      JS_ClearPendingException(cx);
+      return nsnull;
+    }
+
+    if (JSVAL_IS_PRIMITIVE(v)) {
+      return nsnull;
+    }
+
+    JSObject *wrappedObj = JSVAL_TO_OBJECT(v);
+    nsresult rv = IsWrapperSameOrigin(cx, wrappedObj);
+    if (NS_FAILED(rv)) {
+      JS_ClearPendingException(cx);
+      return nsnull;
+    }
+
+    return wrappedObj;
+  }
+
+  /**
+   * Rewraps a property if it needs to be rewrapped. Used by
+   * GetOrSetNativeProperty to rewrap the return value.
+   */
+  static JSBool RewrapIfDeepWrapper(JSContext *cx, JSObject *obj, jsval v,
+                                    jsval *rval, JSBool isNativeWrapper) {
+    *rval = v;
+    return isNativeWrapper
+           ? XPC_NW_RewrapIfDeepWrapper(cx, obj, v, rval)
+           : XPC_XOW_RewrapIfNeeded(cx, obj, rval);
+  }
+
+  /**
+   * Creates a wrapper around a JSObject function object. Note
+   * XPCSafeJSObjectWrapper code doesn't have special function wrappers,
+   * obviating the need for this function. Instead, this is used by
+   * XPCNativeWrapper and the cross origin wrapper.
+   */
+  static inline JSBool WrapFunction(JSContext *cx, JSObject *wrapperObj,
+                                    JSObject *funobj, jsval *v,
+                                    JSBool isNativeWrapper) {
+    return isNativeWrapper
+           ? XPC_NW_WrapFunction(cx, funobj, v)
+           : XPC_XOW_WrapFunction(cx, wrapperObj, funobj, v);
+  }
+
+  /**
+   * Called for the common part of adding a property to obj.
+   */
+  static JSBool AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+  /**
+   * Called for the common part of deleting a property from obj.
+   */
+  static JSBool DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+  /**
+   * Called to enumerate the properties of |innerObj| onto |wrapperObj|.
+   */
+  static JSBool Enumerate(JSContext *cx, JSObject *wrapperObj,
+                          JSObject *innerObj);
+
+  /**
+   * Resolves a property (that may be) defined on |innerObj| onto
+   * |wrapperObj|. This will also resolve random, page-defined objects
+   * and is therefore unsuitable for cross-origin resolution.
+   */
+  static JSBool NewResolve(JSContext *cx, JSObject *wrapperObj,
+                           JSObject *innerObj, jsval id, uintN flags,
+                           JSObject **objp, JSBool preserveVal = JS_FALSE);
+
+  /**
+   * Resolve a native property named id from innerObj onto wrapperObj. The
+   * native wrapper will be preserved if necessary. Note that if we resolve
+   * an attribute here, we don't deal with the value until later.
+   */
+  static JSBool ResolveNativeProperty(JSContext *cx, JSObject *wrapperObj,
+                                      JSObject *innerObj, XPCWrappedNative *wn,
+                                      jsval id, uintN flags, JSObject **objp,
+                                      JSBool isNativeWrapper);
+
+  /**
+   * Gets a native property from obj. This goes directly through XPConnect, it
+   * does not look at Javascript-defined getters or setters. This ensures that
+   * the caller gets a real answer.
+   */
+  static JSBool GetOrSetNativeProperty(JSContext *cx, JSObject *obj,
+                                       XPCWrappedNative *wrappedNative,
+                                       jsval id, jsval *vp, JSBool aIsSet,
+                                       JSBool isNativeWrapper);
+
+  /**
+   * Gets a string representation of wrappedNative, going through IDL.
+   */
+  static JSBool NativeToString(JSContext *cx, XPCWrappedNative *wrappedNative,
+                               uintN argc, jsval *argv, jsval *rval,
+                               JSBool isNativeWrapper);
+};
+
+
+#endif
diff --git a/js/src/xpconnect/src/nsXPConnect.cpp b/js/src/xpconnect/src/nsXPConnect.cpp
--- a/js/src/xpconnect/src/nsXPConnect.cpp
+++ b/js/src/xpconnect/src/nsXPConnect.cpp
@@ -1754,6 +1754,18 @@ nsXPConnect::GetWrappedNativePrototype(J
     return NS_OK;
 }
 
+/* [noscript] JSVal GetCrossOriginWrapperForValue(in JSContextPtr aJSContext, in JSVal aCurrentVal); */
+NS_IMETHODIMP
+nsXPConnect::GetCrossOriginWrapperForObject(JSContext * aJSContext,
+                                            JSObject * aParent,
+                                            JSObject * aWrappedObj,
+                                            jsval * rval)
+{
+    *rval = OBJECT_TO_JSVAL(aWrappedObj);
+    return XPC_XOW_WrapObject(aJSContext, aParent, rval)
+           ? NS_OK : NS_ERROR_FAILURE;
+}
+
 /* attribute PRBool collectGarbageOnMainThreadOnly; */
 NS_IMETHODIMP 
 nsXPConnect::GetCollectGarbageOnMainThreadOnly(PRBool *aCollectGarbageOnMainThreadOnly)
diff --git a/js/src/xpconnect/src/xpcconvert.cpp b/js/src/xpconnect/src/xpcconvert.cpp
--- a/js/src/xpconnect/src/xpcconvert.cpp
+++ b/js/src/xpconnect/src/xpcconvert.cpp
@@ -46,6 +46,7 @@
 #include "nsString.h"
 #include "XPCNativeWrapper.h"
 #include "nsIAtom.h"
+#include "XPCWrapper.h"
 
 //#define STRICT_CHECK_OF_UNICODE
 #ifdef STRICT_CHECK_OF_UNICODE
@@ -1191,10 +1192,32 @@ XPCConvert::NativeInterface2JSObject(XPC
                 }
             }
 
+            JSObject *flat = wrapper->GetFlatJSObject();
+            const char *name = JS_GET_CLASS(ccx, flat)->name;
+            uint32 flags = JS_GetTopScriptFilenameFlags(ccx, nsnull);
+            if(allowNativeWrapper &&
+               !(flags & JSFILENAME_SYSTEM) &&
+               !JS_IsSystemObject(ccx, flat) &&
+               XPC_XOW_ClassNeedsXOW(name))
+            {
+                jsval v = OBJECT_TO_JSVAL(flat);
+                XPCJSObjectHolder *objHolder = nsnull;
+                if (!XPC_XOW_WrapObject(ccx, scope, &v) ||
+                    !(objHolder = XPCJSObjectHolder::newHolder(ccx, JSVAL_TO_OBJECT(v))))
+                {
+                    NS_RELEASE(wrapper);
+                    return JS_FALSE;
+                }
+
+                NS_ADDREF(objHolder);
+                NS_RELEASE(wrapper);
+                *dest = objHolder;
+                return JS_TRUE;
+            }
+
             *dest = static_cast<nsIXPConnectJSObjectHolder*>(wrapper);
             return JS_TRUE;
         }
-        
     }
     return JS_FALSE;
 }
diff --git a/js/src/xpconnect/src/xpcforwards.h b/js/src/xpconnect/src/xpcforwards.h
--- a/js/src/xpconnect/src/xpcforwards.h
+++ b/js/src/xpconnect/src/xpcforwards.h
@@ -83,6 +83,7 @@ class XPCNativeScriptableSharedMap;
 class XPCNativeScriptableSharedMap;
 class XPCWrappedNativeProtoMap;
 class XPCNativeWrapperMap;
+class WrappedNative2WrapperMap;
 
 class nsXPCComponents;
 class nsXPCComponents_Interfaces;
diff --git a/js/src/xpconnect/src/xpcmaps.cpp b/js/src/xpconnect/src/xpcmaps.cpp
--- a/js/src/xpconnect/src/xpcmaps.cpp
+++ b/js/src/xpconnect/src/xpcmaps.cpp
@@ -650,3 +650,29 @@ XPCNativeWrapperMap::~XPCNativeWrapperMa
 }
 
 /***************************************************************************/
+// implement WrappedNative2WrapperMap...
+
+// static
+WrappedNative2WrapperMap*
+WrappedNative2WrapperMap::newMap(int size)
+{
+    WrappedNative2WrapperMap* map = new WrappedNative2WrapperMap(size);
+    if(map && map->mTable)
+        return map;
+    delete map;
+    return nsnull;
+}
+
+WrappedNative2WrapperMap::WrappedNative2WrapperMap(int size)
+{
+    mTable = JS_NewDHashTable(JS_DHashGetStubOps(), nsnull,
+                              sizeof(Entry), size);
+}
+
+WrappedNative2WrapperMap::~WrappedNative2WrapperMap()
+{
+    if(mTable)
+        JS_DHashTableDestroy(mTable);
+}
+
+/***************************************************************************/
diff --git a/js/src/xpconnect/src/xpcmaps.h b/js/src/xpconnect/src/xpcmaps.h
--- a/js/src/xpconnect/src/xpcmaps.h
+++ b/js/src/xpconnect/src/xpcmaps.h
@@ -684,4 +684,61 @@ private:
     JSDHashTable *mTable;
 };
 
+class WrappedNative2WrapperMap
+{
+public:
+    struct Entry : public JSDHashEntryHdr
+    {
+        // Note: key must be the flat JSObject for a wrapped native.
+        JSObject*         key;
+        JSObject*         value;
+    };
+
+    static WrappedNative2WrapperMap* newMap(int size);
+
+    inline JSObject* Find(JSObject* wrapper)
+    {
+        NS_PRECONDITION(wrapper, "bad param");
+        Entry* entry = (Entry*)
+            JS_DHashTableOperate(mTable, wrapper, JS_DHASH_LOOKUP);
+        if(JS_DHASH_ENTRY_IS_FREE(entry))
+            return nsnull;
+        return entry->value;
+    }
+
+    // Note: If the entry already exists, then this will overwrite the
+    // existing entry, returning the old value.
+    inline JSObject* Add(JSObject* wrapper, JSObject *obj)
+    {
+        NS_PRECONDITION(wrapper,"bad param");
+        Entry* entry = (Entry*)
+            JS_DHashTableOperate(mTable, wrapper, JS_DHASH_ADD);
+        if(!entry)
+            return nsnull;
+        JSObject *old;
+        if(!entry->key)
+            entry->key = wrapper;
+        old = entry->value;
+        entry->value = obj;
+        return old;
+    }
+
+    inline void Remove(JSObject* wrapper)
+    {
+        NS_PRECONDITION(wrapper,"bad param");
+        JS_DHashTableOperate(mTable, wrapper, JS_DHASH_REMOVE);
+    }
+
+    inline uint32 Count() {return mTable->entryCount;}
+    inline uint32 Enumerate(JSDHashEnumerator f, void *arg)
+        {return JS_DHashTableEnumerate(mTable, f, arg);}
+
+    ~WrappedNative2WrapperMap();
+private:
+    WrappedNative2WrapperMap();    // no implementation
+    WrappedNative2WrapperMap(int size);
+private:
+    JSDHashTable *mTable;
+};
+
 #endif /* xpcmaps_h___ */
diff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h
--- a/js/src/xpconnect/src/xpcprivate.h
+++ b/js/src/xpconnect/src/xpcprivate.h
@@ -222,6 +222,7 @@ void DEBUG_CheckWrapperThreadSafety(cons
 #define XPC_NATIVE_JSCLASS_MAP_SIZE         32
 #define XPC_THIS_TRANSLATOR_MAP_SIZE         8
 #define XPC_NATIVE_WRAPPER_MAP_SIZE         16
+#define XPC_WRAPPER_MAP_SIZE                 8
 
 /***************************************************************************/
 // data declarations...
@@ -1107,6 +1108,9 @@ public:
     Native2WrappedNativeMap*
     GetWrappedNativeMap() const {return mWrappedNativeMap;}
 
+    WrappedNative2WrapperMap*
+    GetWrapperMap() const {return mWrapperMap;}
+
     ClassInfo2WrappedNativeProtoMap*
     GetWrappedNativeProtoMap() const {return mWrappedNativeProtoMap;}
 
@@ -1202,6 +1206,7 @@ private:
     XPCJSRuntime*                    mRuntime;
     Native2WrappedNativeMap*         mWrappedNativeMap;
     ClassInfo2WrappedNativeProtoMap* mWrappedNativeProtoMap;
+    WrappedNative2WrapperMap*        mWrapperMap;
     nsXPCComponents*                 mComponents;
     XPCWrappedNativeScope*           mNext;
     // The JS global object for this scope.  If non-null, this will be the
@@ -2089,11 +2094,9 @@ public:
         if(mScriptableInfo && JS_IsGCMarkingTracer(trc))
             mScriptableInfo->Mark();
         if(HasProto()) mMaybeProto->TraceJS(trc);
-        if(mNativeWrapper)
-        {
-            JS_CALL_OBJECT_TRACER(trc, mNativeWrapper,
-                                  "XPCWrappedNative::mNativeWrapper");
-        }
+        if(mWrapper)
+            JS_CALL_OBJECT_TRACER(trc, mWrapper, "XPCWrappedNative::mWrapper");
+        TraceOtherWrapper(trc);
     }
 
     inline void AutoTrace(JSTracer* trc)
@@ -2132,8 +2135,8 @@ public:
 
     JSBool HasExternalReference() const {return mRefCnt > 1;}
 
-    JSObject* GetNativeWrapper()              { return mNativeWrapper; }
-    void      SetNativeWrapper(JSObject *obj) { mNativeWrapper = obj; }
+    JSObject* GetWrapper()              { return mWrapper; }
+    void      SetWrapper(JSObject *obj) { mWrapper = obj; }
 
     // Make ctor and dtor protected (rather than private) to placate nsCOMPtr.
 protected:
@@ -2151,6 +2154,7 @@ protected:
     virtual ~XPCWrappedNative();
 
 private:
+    void TraceOtherWrapper(JSTracer* trc);
     JSBool Init(XPCCallContext& ccx, JSObject* parent, JSBool isGlobal,
                 const XPCNativeScriptableCreateInfo* sci);
 
@@ -2181,7 +2185,7 @@ private:
     JSObject*                    mFlatJSObject;
     XPCNativeScriptableInfo*     mScriptableInfo;
     XPCWrappedNativeTearOffChunk mFirstChunk;
-    JSObject*                    mNativeWrapper;
+    JSObject*                    mWrapper;
 
 public:
     nsCOMPtr<nsIThread>          mThread; // Don't want to overload _mOwningThread
@@ -3791,6 +3795,9 @@ XPC_SJOW_AttachNewConstructorObject(XPCC
 XPC_SJOW_AttachNewConstructorObject(XPCCallContext &ccx,
                                     JSObject *aGlobalObject);
 
+JSBool
+XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp);
+
 #ifdef XPC_IDISPATCH_SUPPORT
 // IDispatch specific classes
 #include "XPCDispPrivate.h"
diff --git a/js/src/xpconnect/src/xpcwrappednative.cpp b/js/src/xpconnect/src/xpcwrappednative.cpp
--- a/js/src/xpconnect/src/xpcwrappednative.cpp
+++ b/js/src/xpconnect/src/xpcwrappednative.cpp
@@ -44,6 +44,7 @@
 #include "xpcprivate.h"
 #include "nsCRT.h"
 #include "XPCNativeWrapper.h"
+#include "XPCWrapper.h"
 
 /***************************************************************************/
 
@@ -598,7 +599,7 @@ XPCWrappedNative::XPCWrappedNative(nsISu
       mSet(aProto->GetSet()),
       mFlatJSObject((JSObject*)JSVAL_ONE), // non-null to pass IsValid() test
       mScriptableInfo(nsnull),
-      mNativeWrapper(nsnull)
+      mWrapper(nsnull)
 {
     NS_ADDREF(mIdentity = aIdentity);
 
@@ -617,7 +618,7 @@ XPCWrappedNative::XPCWrappedNative(nsISu
       mSet(aSet),
       mFlatJSObject((JSObject*)JSVAL_ONE), // non-null to pass IsValid() test
       mScriptableInfo(nsnull),
-      mNativeWrapper(nsnull)
+      mWrapper(nsnull)
 {
     NS_ADDREF(mIdentity = aIdentity);
 
@@ -641,6 +642,7 @@ XPCWrappedNative::~XPCWrappedNative()
     }
 
     Native2WrappedNativeMap* map = GetScope()->GetWrappedNativeMap();
+    WrappedNative2WrapperMap* wn2wmmap = GetScope()->GetWrapperMap();
     {   // scoped lock
         XPCAutoLock lock(GetRuntime()->GetMapLock());
         map->Remove(this);
@@ -787,6 +789,20 @@ XPCWrappedNative::GatherScriptableCreate
     }
 
     return NS_OK;
+}
+
+void
+XPCWrappedNative::TraceOtherWrapper(JSTracer* trc)
+{
+    // Note: This isn't wrapped by a MapLock, however, this is normally called
+    // during GC, where nobody should be playing with the wrapper map anyway,
+    // so this should be OK.
+    JSObject *otherWrapper = GetScope()->GetWrapperMap()->Find(mFlatJSObject);
+    if(otherWrapper)
+    {
+        JS_CALL_OBJECT_TRACER(trc, otherWrapper,
+                              "XPCWrappedNative::mOtherWrapper");
+    }
 }
 
 JSBool
@@ -1000,6 +1016,8 @@ XPCWrappedNative::FlatJSObjectFinalized(
         }
     }
 
+    GetScope()->GetWrapperMap()->Remove(mFlatJSObject);
+
     //This makes IsValid return false from now on...
     mFlatJSObject = nsnull;
 
@@ -1319,6 +1337,13 @@ return_tearoff:
             return wrapper;
         }
 
+        // Unwrap any XPCCrossOriginWrappers and SafeJSObjectWrappers.
+        JSObject *unsafeObj;
+        if(clazz == &sXPC_XOW_JSClass.base &&
+           (unsafeObj = XPCWrapper::Unwrap(cx, cur)))
+            return GetWrappedNativeOfJSObject(cx, unsafeObj, funobj, pobj2,
+                                              pTearOff);
+
         if(XPCNativeWrapper::IsNativeWrapperClass(clazz))
         {
             if(pobj2)
@@ -1327,7 +1352,6 @@ return_tearoff:
             return XPCNativeWrapper::GetWrappedNative(cx, cur);
         }
 
-        JSObject *unsafeObj;
         if(IsXPCSafeJSObjectWrapperClass(clazz) &&
            (unsafeObj = JS_GetParent(cx, cur)))
             return GetWrappedNativeOfJSObject(cx, unsafeObj, funobj, pobj2,
diff --git a/js/src/xpconnect/src/xpcwrappednativejsops.cpp b/js/src/xpconnect/src/xpcwrappednativejsops.cpp
--- a/js/src/xpconnect/src/xpcwrappednativejsops.cpp
+++ b/js/src/xpconnect/src/xpcwrappednativejsops.cpp
@@ -1,5 +1,5 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- * vim: set ts=8 sw=4 et tw=80:
+ * vim: set ts=8 sw=4 et tw=78:
  *
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
diff --git a/js/src/xpconnect/src/xpcwrappednativescope.cpp b/js/src/xpconnect/src/xpcwrappednativescope.cpp
--- a/js/src/xpconnect/src/xpcwrappednativescope.cpp
+++ b/js/src/xpconnect/src/xpcwrappednativescope.cpp
@@ -134,6 +134,7 @@ XPCWrappedNativeScope::XPCWrappedNativeS
     :   mRuntime(ccx.GetRuntime()),
         mWrappedNativeMap(Native2WrappedNativeMap::newMap(XPC_NATIVE_MAP_SIZE)),
         mWrappedNativeProtoMap(ClassInfo2WrappedNativeProtoMap::newMap(XPC_NATIVE_PROTO_MAP_SIZE)),
+        mWrapperMap(WrappedNative2WrapperMap::newMap(XPC_WRAPPER_MAP_SIZE)),
         mComponents(nsnull),
         mNext(nsnull),
         mGlobalJSObject(nsnull),
