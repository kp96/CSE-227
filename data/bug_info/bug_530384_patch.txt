diff --git a/security/manager/boot/src/nsEntropyCollector.cpp b/security/manager/boot/src/nsEntropyCollector.cpp
--- a/security/manager/boot/src/nsEntropyCollector.cpp
+++ b/security/manager/boot/src/nsEntropyCollector.cpp
@@ -35,16 +35,17 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "prlog.h"
 #include "nsEntropyCollector.h"
 #include "nsMemory.h"
+#include "nsAlgorithm.h"
 
 nsEntropyCollector::nsEntropyCollector()
 :mBytesCollected(0), mWritePointer(mEntropyCache)
 {
   // We could use the uninitialized memory in mEntropyCache as initial
   // random data, but that means (if any entropy is collected before NSS
   // initialization and then forwarded) that we'll get warnings from
   // tools like valgrind for every later operation that depends on the
@@ -67,30 +68,31 @@ nsEntropyCollector::RandomUpdate(void *n
     if (mForwardTarget) {
       return mForwardTarget->RandomUpdate(new_entropy, bufLen);
     }
     else {
       const unsigned char *InputPointer = (const unsigned char *)new_entropy;
       const unsigned char *PastEndPointer = mEntropyCache + entropy_buffer_size;
 
       // if the input is large, we only take as much as we can store
-      PRInt32 bytes_wanted = PR_MIN(bufLen, entropy_buffer_size);
+      PRInt32 bytes_wanted = NS_MIN(bufLen, PRInt32(entropy_buffer_size));
 
       // remember the number of bytes we will have after storing new_entropy
-      mBytesCollected = PR_MIN(entropy_buffer_size, mBytesCollected + bytes_wanted);
+      mBytesCollected = NS_MIN(PRInt32(entropy_buffer_size),
+                               mBytesCollected + bytes_wanted);
 
       // as the above statements limit bytes_wanted to the entropy_buffer_size,
       // this loop will iterate at most twice.
       while (bytes_wanted > 0) {
 
         // how many bytes to end of cyclic buffer?
         const PRInt32 space_to_end = PastEndPointer - mWritePointer;
 
         // how many bytes can we copy, not reaching the end of the buffer?
-        const PRInt32 this_time = PR_MIN(space_to_end, bytes_wanted);
+        const PRInt32 this_time = NS_MIN(space_to_end, bytes_wanted);
 
         // copy at most to the end of the cyclic buffer
         for (PRInt32 i = 0; i < this_time; ++i) {
 
           unsigned int old = *mWritePointer;
 
           // combine new and old value already stored in buffer
           // this logic comes from PSM 1
diff --git a/security/manager/ssl/src/nsNSSCertHelper.cpp b/security/manager/ssl/src/nsNSSCertHelper.cpp
--- a/security/manager/ssl/src/nsNSSCertHelper.cpp
+++ b/security/manager/ssl/src/nsNSSCertHelper.cpp
@@ -242,17 +242,17 @@ GetDefaultOIDFormat(SECItem *oid,
       }
 
       if (i < oid->len-1)
         continue;
     }
 
     if (!invalid) {
       if (first) {
-        unsigned long one = PR_MIN(val/40, 2); // never > 2
+        unsigned long one = NS_MIN(val/40, 2UL); // never > 2
         unsigned long two = val - (one * 40);
 
         written = PR_snprintf(&buf[len], sizeof(buf)-len, "%lu%c%lu", 
 			      one, separator, two);
       }
       else {
         written = PR_snprintf(&buf[len], sizeof(buf)-len, "%c%lu", 
 			      separator, val);
diff --git a/security/manager/ssl/src/nsNSSComponent.cpp b/security/manager/ssl/src/nsNSSComponent.cpp
--- a/security/manager/ssl/src/nsNSSComponent.cpp
+++ b/security/manager/ssl/src/nsNSSComponent.cpp
@@ -2715,17 +2715,17 @@ nsCryptoHash::UpdateFromStream(nsIInputS
   if (n == 0 || n < len)
     return NS_ERROR_NOT_AVAILABLE;
   
   char buffer[NS_CRYPTO_HASH_BUFFER_SIZE];
   PRUint32 read, readLimit;
   
   while(NS_SUCCEEDED(rv) && len>0)
   {
-    readLimit = PR_MIN(NS_CRYPTO_HASH_BUFFER_SIZE, len);
+    readLimit = NS_MIN(PRUint32(NS_CRYPTO_HASH_BUFFER_SIZE), len);
     
     rv = data->Read(buffer, readLimit, &read);
     
     if (NS_SUCCEEDED(rv))
       rv = Update((const PRUint8*)buffer, read);
     
     len -= read;
   }
@@ -2907,17 +2907,17 @@ NS_IMETHODIMP nsCryptoHMAC::UpdateFromSt
   if (n == 0 || n < aLen)
     return NS_ERROR_NOT_AVAILABLE;
   
   char buffer[NS_CRYPTO_HASH_BUFFER_SIZE];
   PRUint32 read, readLimit;
   
   while(NS_SUCCEEDED(rv) && aLen > 0)
   {
-    readLimit = PR_MIN(NS_CRYPTO_HASH_BUFFER_SIZE, aLen);
+    readLimit = NS_MIN(PRUint32(NS_CRYPTO_HASH_BUFFER_SIZE), aLen);
     
     rv = aStream->Read(buffer, readLimit, &read);
     if (read == 0)
       return NS_BASE_STREAM_CLOSED;
     
     if (NS_SUCCEEDED(rv))
       rv = Update((const PRUint8*)buffer, read);
     
