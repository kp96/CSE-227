Index: caps/idl/nsIPrincipal.idl
===================================================================
RCS file: /home/bzbarsky/mozilla/cvs-mirror/mozilla/caps/idl/nsIPrincipal.idl,v
retrieving revision 1.31
diff -u -p -d -u -1 -0 -r1.31 nsIPrincipal.idl
--- caps/idl/nsIPrincipal.idl	8 Jul 2005 23:26:35 -0000	1.31
+++ caps/idl/nsIPrincipal.idl	22 Jul 2005 18:59:52 -0000
@@ -44,71 +44,82 @@
 %{C++
 struct JSContext;
 struct JSPrincipals;
 %}
 
 interface nsIURI;
 
 [ptr] native JSContext(JSContext);
 [ptr] native JSPrincipals(JSPrincipals);
 
-[uuid(a67c4736-9a95-4ce1-9ffc-3f88c0913a34)]
+[uuid(fb9ddeb9-26f9-46b8-85d5-3978aaee05aa)]
 interface nsIPrincipal : nsISerializable
 {
     /**
      * Values of capabilities for each principal. Order is
      * significant: if an operation is performed on a set
      * of capabilities, the minimum is computed.
      */
     const short ENABLE_DENIED                = 1;
     const short ENABLE_UNKNOWN               = 2;
     const short ENABLE_WITH_USER_PERMISSION  = 3;
     const short ENABLE_GRANTED               = 4;
 
     /**
      * Returns the security preferences associated with this principal.
      * prefBranch will be set to the pref branch to which these preferences
      * pertain.  id is a pseudo-unique identifier, pertaining to either the
-     * certificateID or the origin.  grantedList and deniedList are
-     * space-separated lists of capabilities which were explicitly granted
-     * or denied by a pref.
+     * fingerprint or the origin.  subjectName is a name that identifies the
+     * entity this principal represents (may be empty).  grantedList and
+     * deniedList are space-separated lists of capabilities which were
+     * explicitly granted or denied by a pref.
      */
     void getPreferences(out string prefBranch, out string id,
+                        out string subjectName,
                         out string grantedList, out string deniedList);
 
     /**
      * Returns whether the other principal is equivalent to this principal.
      * Principals are considered equal if they are the same principal,
-     * they have the same origin, or have the same certificate ID
+     * they have the same origin, or have the same certificate fingerprint ID
      */
     boolean equals(in nsIPrincipal other);
 
     /**
      * Returns a hash value for the principal.
      */
     readonly attribute unsigned long hashValue;
 
     /**
      * Returns the JS equivalent of the principal.
      * @see JSPrincipals.h
      */
     JSPrincipals getJSPrincipals(in JSContext cx);
 
     /**
      * The domain security policy of the principal.
      */
     // XXXcaa should this be here?  The script security manager is the only
     // thing that should care about this.  Wouldn't storing this data in one
     // of the hashtables in nsScriptSecurityManager be better?
+    // XXXbz why is this writable?  Who should have write access to this?  What
+    // happens if this principal is in our hashtable and we pass it out of the
+    // security manager and someone writes to this field?  Especially if they
+    // write garbage?  If we need to give someone other than the security
+    // manager a way to set this (which I question, since it can increase the
+    // permissions of a page) it should be a |void clearSecurityPolicy()|
+    // method.
     attribute voidPtr securityPolicy;
 
     // XXXcaa probably should be turned into {get|set}CapabilityFlags
+    // XXXbz again, what if this lives in our hashtable and someone
+    // messes with it?  Is that OK?
     short canEnableCapability(in string capability);
     void setCanEnableCapability(in string capability, in short canEnable);
     boolean isCapabilityEnabled(in string capability, in voidPtr annotation);
     void enableCapability(in string capability, inout voidPtr annotation);
     void revertCapability(in string capability, inout voidPtr annotation);
     void disableCapability(in string capability, inout voidPtr annotation);
 
     /**
      * The codebase URI to which this principal pertains.  This is
      * generally the document URI.
@@ -136,39 +147,60 @@ interface nsIPrincipal : nsISerializable
      * Whether this principal is associated with a certificate.
      */
     readonly attribute boolean hasCertificate;
 
     /**
      * The fingerprint ID of this principal's certificate.
      * Throws if there is no certificate associated with this principal.
      */
     // XXXcaa kaie says this may not be unique.  We should probably
     // consider using something else for this....
-    readonly attribute string certificateID;
+    readonly attribute AUTF8String fingerprint;
 
     /**
-     * The common name for the certificate.
-     * This pertains to the certificate authority organization.
+     * The pretty name for the certificate.  This sort of (but not really)
+     * identifies the subject of the certificate (the entity that stands behind
+     * the certificate).  Note that this may be empty; prefer to get the
+     * certificate itself and get this information from it, since that may
+     * provide more information.
+     *
      * Throws if there is no certificate associated with this principal.
      */
-    attribute string commonName;
+    readonly attribute AUTF8String prettyName;
 
     /**
      * Returns whether the other principal is equal to or weaker than this
      * principal.  Principals are equal if they are the same object, they
      * have the same origin, or they have the same certificate ID.
      *
      * Thus a principal subsumes itself if it is equal to itself.
      *
      * The system principal subsumes itself and all other principals except
      * the non-principal.
      *
      * The non-principal is not equal to itself or any other principal, and
      * therefore does not subsume itself.
      *
      * Both codebase and certificate principals are subsumed by the system
      * principal, but no codebase or certificate principal yet subsumes any
      * other codebase or certificate principal.  This may change in a future
      * release; note that nsIPrincipal is unfrozen, not slated to be frozen.
      */
     boolean subsumes(in nsIPrincipal other);
+
+    /**
+     * The subject name for the certificate.  This actually identifies the
+     * subject of the certificate.  This may well not be a string that would
+     * mean much to a typical user on its own (e.g. it may have a number of
+     * different names all concatenated together with some information on what
+     * they mean in between).
+     *
+     * Throws if there is no certificate associated with this principal.
+     */
+    readonly attribute AUTF8String subjectName;
+
+    /**
+     * The certificate associated with this principal, if any.  If there isn't
+     * one, this will return null.  Getting this attribute never throws.
+     */
+    readonly attribute nsISupports certificate;
 };
Index: caps/idl/nsIScriptSecurityManager.idl
===================================================================
RCS file: /home/bzbarsky/mozilla/cvs-mirror/mozilla/caps/idl/nsIScriptSecurityManager.idl,v
retrieving revision 1.65
diff -u -p -d -u -1 -0 -r1.65 nsIScriptSecurityManager.idl
--- caps/idl/nsIScriptSecurityManager.idl	12 May 2005 18:20:05 -0000	1.65
+++ caps/idl/nsIScriptSecurityManager.idl	27 May 2005 06:17:59 -0000
@@ -34,21 +34,21 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsISupports.idl"
 #include "nsIPrincipal.idl"
 #include "nsIXPCSecurityManager.idl"
 interface nsIURI;
 
 
-[scriptable, uuid(463eb1fa-9dac-4ca7-826f-1fc921971d3a)]
+[scriptable, uuid(f4d74511-2b2d-4a14-a3e4-a392ac5ac3ff)]
 interface nsIScriptSecurityManager : nsIXPCSecurityManager
 {
     ///////////////// Security Checks //////////////////
     /**
      * Checks whether the running script is allowed to access aProperty.
      */
     [noscript] void checkPropertyAccess(in JSContextPtr aJSContext,
                                         in JSObjectPtr aJSObject,
                                         in string aClassName,
                                         in JSVal aProperty,
@@ -154,23 +154,33 @@ interface nsIScriptSecurityManager : nsI
      * currently executing.
      */
     [noscript] nsIPrincipal getSubjectPrincipal();
 
     /**
      * Return the all-powerful system principal.
      */
     [noscript] nsIPrincipal getSystemPrincipal();
 
     /**
-     * Return a principal with the specified certificate ID and codebase URI.
+     * Return a principal with the specified certificate fingerprint, subject
+     * name (the full name or concatenated set of names of the entity
+     * represented by the certificate), pretty name, certificate, and
+     * codebase URI.  The certificate fingerprint and subject name MUST be
+     * nonempty; otherwise an error will be thrown.  Similarly, aCert must
+     * not be null.
      */
-    [noscript] nsIPrincipal getCertificatePrincipal(in string CertID, in nsIURI aURI);
+    [noscript] nsIPrincipal
+         getCertificatePrincipal(in AUTF8String aCertFingerprint,
+                                 in AUTF8String aSubjectName,
+                                 in AUTF8String aPrettyName,
+                                 in nsISupports aCert,
+                                 in nsIURI aURI);
 
     /**
      * Return a principal that has the same origin as aURI.
      */
     [noscript] nsIPrincipal getCodebasePrincipal(in nsIURI aURI);
 
     ///////////////// Capabilities API /////////////////////
     /**
      * Request that 'capability' can be enabled by scripts or applets
      * running with 'principal'. Will prompt user if
@@ -202,21 +212,25 @@ interface nsIScriptSecurityManager : nsI
      * Disable 'capability' in the innermost frame of the currently executing
      * script.
      */
     void disableCapability(in string capability);
 
     //////////////// Master Certificate Functions ////////////////////
     /**
      * Allow 'certificateID' to enable 'capability.' Can only be performed
      * by code signed by the system certificate.
      */
-    void setCanEnableCapability(in string certificateID, in string capability, 
+    // XXXbz Capabilities can't have non-ascii chars?
+    // XXXbz ideally we'd pass a subjectName here too, and the nsISupports
+    // cert we're enabling for...
+    void setCanEnableCapability(in AUTF8String certificateFingerprint,
+                                in string capability, 
                                 in short canEnable);
 
     ///////////////////////
     /**
      * Return the principal of the specified object in the specified context.
      */
     [noscript] nsIPrincipal getObjectPrincipal(in JSContextPtr cx,
                                                in JSObjectPtr obj);
 
     /**
Index: caps/include/nsPrincipal.h
===================================================================
RCS file: /home/bzbarsky/mozilla/cvs-mirror/mozilla/caps/include/nsPrincipal.h,v
retrieving revision 1.15
diff -u -p -d -u -1 -0 -r1.15 nsPrincipal.h
--- caps/include/nsPrincipal.h	29 Jun 2005 16:29:49 -0000	1.15
+++ caps/include/nsPrincipal.h	4 Jul 2005 20:41:35 -0000
@@ -60,58 +60,80 @@ public:
   // Our refcount is managed by mJSPrincipals.  Use this macro to avoid
   // an extra refcount member.
   NS_DECL_ISUPPORTS_INHERITED
 public:
 
   NS_DECL_NSIPRINCIPAL
   NS_DECL_NSISERIALIZABLE
 
   // Either Init() or InitFromPersistent() must be called before
   // the principal is in a usable state.
-  nsresult Init(const char *aCertID, nsIURI *aCodebase);
+  nsresult Init(const nsACString& aCertFingerprint,
+                const nsACString& aSubjectName,
+                const nsACString& aPrettyName,
+                nsISupports* aCert,
+                nsIURI *aCodebase);
   nsresult InitFromPersistent(const char* aPrefName,
-                              const char* aToken,
+                              const nsCString& aFingerprint,
+                              const nsCString& aSubjectName,
+                              const nsACString& aPrettyName,
                               const char* aGrantedList,
                               const char* aDeniedList,
+                              nsISupports* aCert,
                               PRBool aIsCert,
                               PRBool aTrusted);
 
+  // Call this to ensure that this principal has a subject name, a pretty name,
+  // and a cert pointer.  This method will throw if there is already a
+  // different subject name or if this principal has no certificate.
+  nsresult EnsureCertData(const nsACString& aSubjectName,
+                          const nsACString& aPrettyName,
+                          nsISupports* aCert);
+
   enum AnnotationValue { AnnotationEnabled=1, AnnotationDisabled };
 
   void SetURI(nsIURI *aURI);
   nsresult SetCapability(const char *capability, void **annotation, 
                          AnnotationValue value);
 
   static const char sInvalid[];
 
 protected:
   nsJSPrincipals mJSPrincipals;
   nsVoidArray mAnnotations;
   nsHashtable mCapabilities;
   nsCString mPrefName;
   static PRInt32 sCapabilitiesOrdinal;
 
   // XXXcaa This is a semi-hack.  The best solution here is to keep
   // a reference to an interface here, except there is no interface
   // that we can use yet.
   struct Certificate
   {
-    Certificate(const char* aCertID, const char* aName)
-      : certificateID(aCertID),
-        commonName(aName)
+    Certificate(const nsACString& aFingerprint, const nsACString& aSubjectName,
+                const nsACString& aPrettyName, nsISupports* aCert)
+      : fingerprint(aFingerprint),
+        subjectName(aSubjectName),
+        prettyName(aPrettyName),
+        cert(aCert)
     {
     };
-    nsCString certificateID;
-    nsCString commonName;
+    nsCString fingerprint;
+    nsCString subjectName;
+    nsCString prettyName;
+    nsCOMPtr<nsISupports> cert;
   };
 
-  nsresult SetCertificate(const char* aCertID, const char* aName);
+  nsresult SetCertificate(const nsACString& aFingerprint,
+                          const nsACString& aSubjectName,
+                          const nsACString& aPrettyName,
+                          nsISupports* aCert);
 
   // Keep this is a pointer, even though it may slightly increase the
   // cost of keeping a certificate, this is a good tradeoff though since
   // it is very rare that we actually have a certificate.
   nsAutoPtr<Certificate> mCert;
 
   DomainPolicy* mSecurityPolicy;
 
   nsCOMPtr<nsIURI> mCodebase;
   nsCOMPtr<nsIURI> mDomain;
Index: caps/include/nsScriptSecurityManager.h
===================================================================
RCS file: /home/bzbarsky/mozilla/cvs-mirror/mozilla/caps/include/nsScriptSecurityManager.h,v
retrieving revision 1.90
diff -u -p -d -u -1 -0 -r1.90 nsScriptSecurityManager.h
--- caps/include/nsScriptSecurityManager.h	29 Jun 2005 16:29:49 -0000	1.90
+++ caps/include/nsScriptSecurityManager.h	1 Jul 2005 04:10:12 -0000
@@ -419,20 +419,32 @@ private:
     nsresult
     LookupPolicy(nsIPrincipal* principal,
                  const char* aClassName, jsval aProperty,
                  PRUint32 aAction,
                  ClassPolicy** aCachedClassPolicy,
                  SecurityLevel* result);
 
     nsresult
     CreateCodebasePrincipal(nsIURI* aURI, nsIPrincipal** result);
 
+    // This is just like the API method, but it doesn't check that the subject
+    // name is nonempty or aCertificate is non-null, and it doesn't change the
+    // certificate in the table (if any) in any way if aModifyTable is false.
+    nsresult
+    DoGetCertificatePrincipal(const nsACString& aCertFingerprint,
+                              const nsACString& aSubjectName,
+                              const nsACString& aPrettyName,
+                              nsISupports* aCertificate,
+                              nsIURI* aURI,
+                              PRBool aModifyTable,
+                              nsIPrincipal **result);
+
     // Returns null if a principal cannot be found.  Note that rv can be NS_OK
     // when this happens -- this means that there was no script for the
     // context.  Callers MUST pass in a non-null rv here.
     static nsIPrincipal*
     GetSubjectPrincipal(JSContext* cx, nsresult* rv);
 
     // Returns null if a principal cannot be found.  Note that rv can be NS_OK
     // when this happens -- this means that there was no script for the frame.
     // Callers MUST pass in a non-null rv here.
     static nsIPrincipal*
@@ -476,21 +488,24 @@ private:
     CheckXPCPermissions(nsISupports* aObj,
                         const char* aObjectSecurityLevel);
 
     nsresult
     Init();
     
     nsresult
     InitPrefs();
 
     static nsresult 
-    PrincipalPrefNames(const char* pref, char** grantedPref, char** deniedPref);
+    GetPrincipalPrefNames(const char* prefBase,
+                          nsCString& grantedPref,
+                          nsCString& deniedPref,
+                          nsCString& subjectNamePref);
 
     nsresult
     InitPolicies();
 
     nsresult
     InitDomainPolicy(JSContext* cx, const char* aPolicyName,
                      DomainPolicy* aDomainPolicy);
 
     nsresult
     InitPrincipals(PRUint32 prefCount, const char** prefNames,
Index: caps/src/nsPrincipal.cpp
===================================================================
RCS file: /home/bzbarsky/mozilla/cvs-mirror/mozilla/caps/src/nsPrincipal.cpp,v
retrieving revision 1.34
diff -u -p -d -u -1 -0 -r1.34 nsPrincipal.cpp
--- caps/src/nsPrincipal.cpp	8 Jul 2005 23:26:35 -0000	1.34
+++ caps/src/nsPrincipal.cpp	9 Jul 2005 04:45:40 -0000
@@ -92,34 +92,38 @@ nsPrincipal::Release()
 
 nsPrincipal::nsPrincipal()
   : mCapabilities(7),
     mSecurityPolicy(nsnull),
     mTrusted(PR_FALSE),
     mInitialized(PR_FALSE)
 {
 }
 
 nsresult
-nsPrincipal::Init(const char *aCertID, nsIURI *aCodebase)
+nsPrincipal::Init(const nsACString& aCertFingerprint,
+                  const nsACString& aSubjectName,
+                  const nsACString& aPrettyName,
+                  nsISupports* aCert,
+                  nsIURI *aCodebase)
 {
   NS_ENSURE_STATE(!mInitialized);
-  NS_ENSURE_ARG_POINTER(aCertID || aCodebase); // better have one of these.
+  NS_ENSURE_ARG(!aCertFingerprint.IsEmpty() || aCodebase); // better have one of these.
 
   mInitialized = PR_TRUE;
 
   mCodebase = aCodebase;
 
   nsresult rv;
-  if (aCertID) {
-    rv = SetCertificate(aCertID, nsnull);
+  if (!aCertFingerprint.IsEmpty()) {
+    rv = SetCertificate(aCertFingerprint, aSubjectName, aPrettyName, aCert);
     if (NS_SUCCEEDED(rv)) {
-      rv = mJSPrincipals.Init(this, aCertID);
+      rv = mJSPrincipals.Init(this, mCert->fingerprint.get());
     }
   }
   else {
     nsCAutoString spec;
     rv = mCodebase->GetSpec(spec);
     if (NS_SUCCEEDED(rv)) {
       rv = mJSPrincipals.Init(this, spec.get());
     }
   }
 
@@ -230,23 +234,33 @@ nsPrincipal::Equals(nsIPrincipal *aOther
   }
 
   if (this != aOther) {
     if (mCert) {
       PRBool otherHasCert;
       aOther->GetHasCertificate(&otherHasCert);
       if (!otherHasCert) {
         return NS_OK;
       }
 
-      nsXPIDLCString otherCertID;
-      aOther->GetCertificateID(getter_Copies(otherCertID));
-      *aResult = otherCertID.Equals(mCert->certificateID);
+      nsCAutoString str;
+      aOther->GetFingerprint(str);
+      *aResult = str.Equals(mCert->fingerprint);
+
+      // If either subject name is empty, just let the result stand (so that
+      // nsScriptSecurityManager::SetCanEnableCapability works), but if they're
+      // both nonempty, only claim equality if they're equal.
+      if (*aResult && !mCert->subjectName.IsEmpty()) {
+        // Check the other principal's subject name
+        aOther->GetSubjectName(str);
+        *aResult = str.Equals(mCert->subjectName) || str.IsEmpty();
+      }
+        
       return NS_OK;
     }
 
     // Codebases are equal if they have the same origin.
     nsIURI *origin = mDomain ? mDomain : mCodebase;
     nsCOMPtr<nsIURI> otherOrigin;
     aOther->GetDomain(getter_AddRefs(otherOrigin));
     if (!otherOrigin) {
       aOther->GetURI(getter_AddRefs(otherOrigin));
     }
@@ -481,84 +495,89 @@ nsPrincipal::GetURI(nsIURI** aURI)
 }
 
 void
 nsPrincipal::SetURI(nsIURI* aURI)
 {
   mCodebase = aURI;
 }
 
 
 nsresult
-nsPrincipal::SetCertificate(const char* aID, const char* aName)
+nsPrincipal::SetCertificate(const nsACString& aFingerprint,
+                            const nsACString& aSubjectName,
+                            const nsACString& aPrettyName,
+                            nsISupports* aCert)
 {
   NS_ENSURE_STATE(!mCert);
 
-  if (!aID && !aName) {
-    return NS_ERROR_INVALID_POINTER;
+  if (aFingerprint.IsEmpty()) {
+    return NS_ERROR_INVALID_ARG;
   }
 
-  mCert = new Certificate(aID, aName);
+  mCert = new Certificate(aFingerprint, aSubjectName, aPrettyName, aCert);
   if (!mCert) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsPrincipal::GetCertificateID(char** aID)
+nsPrincipal::GetFingerprint(nsACString& aFingerprint)
 {
   NS_ENSURE_STATE(mCert);
 
-  *aID = ToNewCString(mCert->certificateID);
-  if (!*aID) {
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
+  aFingerprint = mCert->fingerprint;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsPrincipal::GetCommonName(char** aName)
+nsPrincipal::GetPrettyName(nsACString& aName)
 {
   NS_ENSURE_STATE(mCert);
 
-  *aName = ToNewCString(mCert->commonName);
-  if (!*aName) {
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
+  aName = mCert->prettyName;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsPrincipal::SetCommonName(const char* aName)
+nsPrincipal::GetSubjectName(nsACString& aName)
 {
-  if (!mCert) {
-    NS_ERROR("You must first initialize the certificate with an ID");
-    return NS_ERROR_FAILURE;
-  }
+  NS_ENSURE_STATE(mCert);
 
-  mCert->commonName = aName;
+  aName = mCert->subjectName;
 
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsPrincipal::GetCertificate(nsISupports** aCertificate)
+{
+  if (mCert) {
+    NS_IF_ADDREF(*aCertificate = mCert->cert);
+  }
+  else {
+    *aCertificate = nsnull;
+  }
+  return NS_OK;
+}
 
 NS_IMETHODIMP
 nsPrincipal::GetHashValue(PRUint32* aValue)
 {
   NS_PRECONDITION(mCert || mCodebase, "Need a cert or codebase");
 
   // If there is a certificate, it takes precendence over the codebase.
   if (mCert) {
-    *aValue = nsCRT::HashCode(mCert->certificateID.get(), nsnull);
+    *aValue = nsCRT::HashCode(mCert->fingerprint.get(), nsnull);
   }
   else {
     nsCAutoString str;
     mCodebase->GetSpec(str);
     *aValue = nsCRT::HashCode(str.get(), nsnull);
   }
 
   return NS_OK;
 }
 
@@ -575,52 +594,56 @@ nsPrincipal::SetDomain(nsIURI* aDomain)
 {
   mDomain = aDomain;
   // Domain has changed, forget cached security policy
   SetSecurityPolicy(nsnull);
 
   return NS_OK;
 }
 
 nsresult
 nsPrincipal::InitFromPersistent(const char* aPrefName,
-                                const char* aToken,
+                                const nsCString& aToken,
+                                const nsCString& aSubjectName,
+                                const nsACString& aPrettyName,
                                 const char* aGrantedList,
                                 const char* aDeniedList,
+                                nsISupports* aCert,
                                 PRBool aIsCert,
                                 PRBool aTrusted)
 {
   NS_PRECONDITION(mCapabilities.Count() == 0,
                   "mCapabilities was already initialized?");
   NS_PRECONDITION(mAnnotations.Count() == 0,
                   "mAnnotations was already initialized?");
   NS_PRECONDITION(!mInitialized, "We were already initialized?");
 
   mInitialized = PR_TRUE;
 
   nsresult rv;
   if (aIsCert) {
-    rv = SetCertificate(aToken, nsnull);
+    rv = SetCertificate(aToken, aSubjectName, aPrettyName, aCert);
+    
     if (NS_FAILED(rv)) {
       return rv;
     }
   }
   else {
     rv = NS_NewURI(getter_AddRefs(mCodebase), aToken, nsnull);
     if (NS_FAILED(rv)) {
       NS_ERROR("Malformed URI in capability.principal preference.");
       return rv;
     }
 
     mTrusted = aTrusted;
   }
 
-  rv = mJSPrincipals.Init(this, aToken);
+  rv = mJSPrincipals.Init(this, aToken.get());
   NS_ENSURE_SUCCESS(rv, rv);
 
   //-- Save the preference name
   mPrefName = aPrefName;
 
   const char* ordinalBegin = PL_strpbrk(aPrefName, "1234567890");
   if (ordinalBegin) {
     PRIntn n = atoi(ordinalBegin);
     if (sCapabilitiesOrdinal <= n) {
       sCapabilitiesOrdinal = n + 1;
@@ -633,20 +656,38 @@ nsPrincipal::InitFromPersistent(const ch
     rv = SetCanEnableCapability(aGrantedList, nsIPrincipal::ENABLE_GRANTED);
   }
 
   if (NS_SUCCEEDED(rv) && aDeniedList) {
     rv = SetCanEnableCapability(aDeniedList, nsIPrincipal::ENABLE_DENIED);
   }
 
   return rv;
 }
 
+nsresult
+nsPrincipal::EnsureCertData(const nsACString& aSubjectName,
+                            const nsACString& aPrettyName,
+                            nsISupports* aCert)
+{
+  NS_ENSURE_STATE(mCert);
+
+  if (!mCert->subjectName.IsEmpty() &&
+      !mCert->subjectName.Equals(aSubjectName)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  mCert->subjectName = aSubjectName;
+  mCert->prettyName = aPrettyName;
+  mCert->cert = aCert;
+  return NS_OK;
+}
+
 struct CapabilityList
 {
   nsCString* granted;
   nsCString* denied;
 };
 
 PR_STATIC_CALLBACK(PRBool)
 AppendCapability(nsHashKey *aKey, void *aData, void *capListPtr)
 {
   CapabilityList* capList = (CapabilityList*)capListPtr;
@@ -659,96 +700,117 @@ AppendCapability(nsHashKey *aKey, void *
   else if (value == nsIPrincipal::ENABLE_DENIED) {
     capList->denied->Append(key->GetString(), key->GetStringLength());
     capList->denied->Append(' ');
   }
 
   return PR_TRUE;
 }
 
 NS_IMETHODIMP
 nsPrincipal::GetPreferences(char** aPrefName, char** aID,
+                            char** aSubjectName,
                             char** aGrantedList, char** aDeniedList)
 {
   if (mPrefName.IsEmpty()) {
     if (mCert) {
       mPrefName.Assign("capability.principal.certificate.p");
     }
     else {
       mPrefName.Assign("capability.principal.codebase.p");
     }
 
     mPrefName.AppendInt(sCapabilitiesOrdinal++);
     mPrefName.Append(".id");
   }
 
   *aPrefName = nsnull;
   *aID = nsnull;
+  *aSubjectName = nsnull;
   *aGrantedList = nsnull;
   *aDeniedList = nsnull;
 
   char *prefName = nsnull;
   char *id = nsnull;
+  char *subjectName = nsnull;
   char *granted = nsnull;
   char *denied = nsnull;
 
   //-- Preference name
   prefName = ToNewCString(mPrefName);
   if (!prefName) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   //-- ID
-  nsresult rv;
+  nsresult rv = NS_OK;
   if (mCert) {
-    rv = GetCertificateID(&id);
+    id = ToNewCString(mCert->fingerprint);
+    if (!id) {
+      rv = NS_ERROR_OUT_OF_MEMORY;
+    }
   }
   else {
     rv = GetOrigin(&id);
   }
 
   if (NS_FAILED(rv)) {
     nsMemory::Free(prefName);
     return rv;
   }
 
+  if (mCert) {
+    subjectName = ToNewCString(mCert->subjectName);
+  } else {
+    subjectName = ToNewCString(EmptyCString());
+  }
+
+  if (!subjectName) {
+    nsMemory::Free(prefName);
+    nsMemory::Free(id);
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+
   //-- Capabilities
   nsCAutoString grantedListStr, deniedListStr;
   CapabilityList capList = CapabilityList();
   capList.granted = &grantedListStr;
   capList.denied = &deniedListStr;
   mCapabilities.Enumerate(AppendCapability, (void*)&capList);
 
   if (!grantedListStr.IsEmpty()) {
     grantedListStr.Truncate(grantedListStr.Length() - 1);
     granted = ToNewCString(grantedListStr);
     if (!granted) {
       nsMemory::Free(prefName);
       nsMemory::Free(id);
+      nsMemory::Free(subjectName);
       return NS_ERROR_OUT_OF_MEMORY;
     }
   }
 
   if (!deniedListStr.IsEmpty()) {
     deniedListStr.Truncate(deniedListStr.Length() - 1);
     denied = ToNewCString(deniedListStr);
     if (!denied) {
       nsMemory::Free(prefName);
       nsMemory::Free(id);
+      nsMemory::Free(subjectName);
       if (granted) {
         nsMemory::Free(granted);
       }
       return NS_ERROR_OUT_OF_MEMORY;
     }
   }
 
   *aPrefName = prefName;
   *aID = id;
+  *aSubjectName = subjectName;
   *aGrantedList = granted;
   *aDeniedList = denied;
 
   return NS_OK;
 }
 
 PR_STATIC_CALLBACK(nsresult)
 ReadAnnotationEntry(nsIObjectInputStream* aStream, nsHashKey** aKey,
                     void** aData)
 {
Index: caps/src/nsSystemPrincipal.cpp
===================================================================
RCS file: /home/bzbarsky/mozilla/cvs-mirror/mozilla/caps/src/nsSystemPrincipal.cpp,v
retrieving revision 1.30
diff -u -p -d -u -1 -0 -r1.30 nsSystemPrincipal.cpp
--- caps/src/nsSystemPrincipal.cpp	8 Jul 2005 23:26:35 -0000	1.30
+++ caps/src/nsSystemPrincipal.cpp	9 Jul 2005 04:45:41 -0000
@@ -77,26 +77,28 @@ nsSystemPrincipal::Release()
 
   return count;
 }
 
 
 ///////////////////////////////////////
 // Methods implementing nsIPrincipal //
 ///////////////////////////////////////
 
 NS_IMETHODIMP
-nsSystemPrincipal::GetPreferences(char** aPrefName, char** aID, 
+nsSystemPrincipal::GetPreferences(char** aPrefName, char** aID,
+                                  char** aSubjectName,
                                   char** aGrantedList, char** aDeniedList)
 {
     // The system principal should never be streamed out
     *aPrefName = nsnull;
     *aID = nsnull;
+    *aSubjectName = nsnull;
     *aGrantedList = nsnull;
     *aDeniedList = nsnull;
 
     return NS_ERROR_FAILURE; 
 }
 
 NS_IMETHODIMP
 nsSystemPrincipal::Equals(nsIPrincipal *other, PRBool *result)
 {
     *result = (other == this);
@@ -174,36 +176,41 @@ nsSystemPrincipal::GetURI(nsIURI** aURI)
 }
 
 NS_IMETHODIMP 
 nsSystemPrincipal::GetOrigin(char** aOrigin)
 {
     *aOrigin = ToNewCString(NS_LITERAL_CSTRING("[System]"));
     return *aOrigin ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 }
 
 NS_IMETHODIMP 
-nsSystemPrincipal::GetCertificateID(char** aID)
+nsSystemPrincipal::GetFingerprint(nsACString& aID)
 {
-    *aID = nsnull;
-    return NS_OK;
+    return NS_ERROR_NOT_AVAILABLE;
 }
 
 NS_IMETHODIMP 
-nsSystemPrincipal::GetCommonName(char** aName)
+nsSystemPrincipal::GetPrettyName(nsACString& aName)
 {
-    *aName = nsnull;
-    return NS_OK;
+    return NS_ERROR_NOT_AVAILABLE;
 }
 
 NS_IMETHODIMP 
-nsSystemPrincipal::SetCommonName(const char* aName)
+nsSystemPrincipal::GetSubjectName(nsACString& aName)
 {
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
+NS_IMETHODIMP
+nsSystemPrincipal::GetCertificate(nsISupports** aCertificate)
+{
+    *aCertificate = nsnull;
     return NS_OK;
 }
 
 NS_IMETHODIMP 
 nsSystemPrincipal::GetHasCertificate(PRBool* aResult)
 {
     *aResult = PR_FALSE;
     return NS_OK;
 }
 
Index: caps/src/nsScriptSecurityManager.cpp
===================================================================
RCS file: /home/bzbarsky/mozilla/cvs-mirror/mozilla/caps/src/nsScriptSecurityManager.cpp,v
retrieving revision 1.264
diff -u -p -d -u -1 -0 -r1.264 nsScriptSecurityManager.cpp
--- caps/src/nsScriptSecurityManager.cpp	14 Jul 2005 17:46:55 -0000	1.264
+++ caps/src/nsScriptSecurityManager.cpp	16 Jul 2005 04:22:42 -0000
@@ -1679,86 +1679,135 @@ nsScriptSecurityManager::SubjectPrincipa
         // No subject principal means no JS is running;
         // this is the equivalent of system principal code
         *aIsSystem = PR_TRUE;
         return NS_OK;
     }
 
     return mSystemPrincipal->Equals(subject, aIsSystem);
 }
 
 NS_IMETHODIMP
-nsScriptSecurityManager::GetCertificatePrincipal(const char* aCertID,
+nsScriptSecurityManager::GetCertificatePrincipal(const nsACString& aCertFingerprint,
+                                                 const nsACString& aSubjectName,
+                                                 const nsACString& aPrettyName,
+                                                 nsISupports* aCertificate,
                                                  nsIURI* aURI,
                                                  nsIPrincipal **result)
 {
+    *result = nsnull;
+    
+    NS_ENSURE_ARG(!aCertFingerprint.IsEmpty() &&
+                  !aSubjectName.IsEmpty() &&
+                  aCertificate);
+
+    return DoGetCertificatePrincipal(aCertFingerprint, aSubjectName,
+                                     aPrettyName, aCertificate, aURI, PR_TRUE,
+                                     result);
+}
+    
+nsresult
+nsScriptSecurityManager::DoGetCertificatePrincipal(const nsACString& aCertFingerprint,
+                                                   const nsACString& aSubjectName,
+                                                   const nsACString& aPrettyName,
+                                                   nsISupports* aCertificate,
+                                                   nsIURI* aURI,
+                                                   PRBool aModifyTable,
+                                                   nsIPrincipal **result)
+{
+    NS_ENSURE_ARG(!aCertFingerprint.IsEmpty());
+    
     // Create a certificate principal out of the certificate ID
     // and URI given to us.  We will use this principal to test
     // equality when doing our hashtable lookups below.
     nsRefPtr<nsPrincipal> certificate = new nsPrincipal();
     if (!certificate)
         return NS_ERROR_OUT_OF_MEMORY;
 
-    nsresult rv = certificate->Init(aCertID, aURI);
+    nsresult rv = certificate->Init(aCertFingerprint, aSubjectName,
+                                    aPrettyName, aCertificate, aURI);
     NS_ENSURE_SUCCESS(rv, rv);
 
     // Check to see if we already have this principal.
     nsCOMPtr<nsIPrincipal> fromTable;
     mPrincipals.Get(certificate, getter_AddRefs(fromTable));
     if (fromTable) {
         // Bingo.  We found the certificate in the table, which means
-        // that it has escalated priveleges.
+        // that it has escalated privileges.
+
+        if (aModifyTable) {
+            // Make sure this principal has names, so if we ever go to save it
+            // we'll save them.  If we get a name mismatch here we'll throw,
+            // but that's desirable.
+            rv = NS_STATIC_CAST(nsPrincipal*,
+                                NS_STATIC_CAST(nsIPrincipal*, fromTable))
+                ->EnsureCertData(aSubjectName, aPrettyName, aCertificate);
+            if (NS_FAILED(rv)) {
+                // We have a subject name mismatch for the same cert id.
+                // Hand back the |certificate| object we created and don't give
+                // it any rights from the table.
+                NS_ADDREF(*result = certificate);
+                return NS_OK;
+            }                
+        }
+        
         if (!aURI) {
             // We were asked to just get the base certificate, so output
             // what we have in the table.
             certificate = NS_STATIC_CAST(nsPrincipal*,
                                          NS_STATIC_CAST(nsIPrincipal*,
                                                         fromTable));
         } else {
             // We found a certificate and now need to install a codebase
             // on it.  We don't want to modify the principal in the hash
             // table, so create a new principal and clone the pertinent
             // things.
             nsXPIDLCString prefName;
             nsXPIDLCString id;
+            nsXPIDLCString subjectName;
             nsXPIDLCString granted;
             nsXPIDLCString denied;
             rv = fromTable->GetPreferences(getter_Copies(prefName),
                                            getter_Copies(id),
+                                           getter_Copies(subjectName),
                                            getter_Copies(granted),
                                            getter_Copies(denied));
+            // XXXbz assert something about subjectName and aSubjectName here?
             if (NS_SUCCEEDED(rv)) {
                 certificate = new nsPrincipal();
                 if (!certificate)
                     return NS_ERROR_OUT_OF_MEMORY;
 
                 rv = certificate->InitFromPersistent(prefName, id,
+                                                     subjectName, aPrettyName,
                                                      granted, denied,
+                                                     aCertificate,
                                                      PR_TRUE, PR_FALSE);
                 if (NS_SUCCEEDED(rv))
                     certificate->SetURI(aURI);
             }
         }
     }
 
     NS_ADDREF(*result = certificate);
 
     return rv;
 }
 
 nsresult
 nsScriptSecurityManager::CreateCodebasePrincipal(nsIURI* aURI, nsIPrincipal **result)
 {
     nsRefPtr<nsPrincipal> codebase = new nsPrincipal();
     if (!codebase)
         return NS_ERROR_OUT_OF_MEMORY;
 
-    nsresult rv = codebase->Init(nsnull, aURI);
+    nsresult rv = codebase->Init(EmptyCString(), EmptyCString(),
+                                 EmptyCString(), nsnull, aURI);
     if (NS_FAILED(rv))
         return rv;
 
     NS_ADDREF(*result = codebase);
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsScriptSecurityManager::GetCodebasePrincipal(nsIURI *aURI,
@@ -2052,50 +2101,59 @@ nsScriptSecurityManager::doGetObjectPrin
 
 nsresult
 nsScriptSecurityManager::SavePrincipal(nsIPrincipal* aToSave)
 {
     //-- Save to mPrincipals
     mPrincipals.Put(aToSave, aToSave);
 
     //-- Save to prefs
     nsXPIDLCString idPrefName;
     nsXPIDLCString id;
+    nsXPIDLCString subjectName;
     nsXPIDLCString grantedList;
     nsXPIDLCString deniedList;
     nsresult rv = aToSave->GetPreferences(getter_Copies(idPrefName),
                                           getter_Copies(id),
+                                          getter_Copies(subjectName),
                                           getter_Copies(grantedList),
                                           getter_Copies(deniedList));
     if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
 
-    nsXPIDLCString grantedPrefName;
-    nsXPIDLCString deniedPrefName;
-    rv = PrincipalPrefNames( idPrefName,
-                             getter_Copies(grantedPrefName),
-                             getter_Copies(deniedPrefName)  );
+    nsCAutoString grantedPrefName;
+    nsCAutoString deniedPrefName;
+    nsCAutoString subjectNamePrefName;
+    rv = GetPrincipalPrefNames( idPrefName,
+                                grantedPrefName,
+                                deniedPrefName,
+                                subjectNamePrefName );
     if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
 
     mIsWritingPrefs = PR_TRUE;
     if (grantedList)
-        mSecurityPref->SecuritySetCharPref(grantedPrefName, grantedList);
+        mSecurityPref->SecuritySetCharPref(grantedPrefName.get(), grantedList);
     else
-        mSecurityPref->SecurityClearUserPref(grantedPrefName);
+        mSecurityPref->SecurityClearUserPref(grantedPrefName.get());
 
     if (deniedList)
-        mSecurityPref->SecuritySetCharPref(deniedPrefName, deniedList);
+        mSecurityPref->SecuritySetCharPref(deniedPrefName.get(), deniedList);
     else
-        mSecurityPref->SecurityClearUserPref(deniedPrefName);
+        mSecurityPref->SecurityClearUserPref(deniedPrefName.get());
 
-    if (grantedList || deniedList)
+    if (grantedList || deniedList) {
         mSecurityPref->SecuritySetCharPref(idPrefName, id);
-    else
+        mSecurityPref->SecuritySetCharPref(subjectNamePrefName.get(),
+                                           subjectName);
+    }
+    else {
         mSecurityPref->SecurityClearUserPref(idPrefName);
+        mSecurityPref->SecurityClearUserPref(subjectNamePrefName.get());
+    }
 
     mIsWritingPrefs = PR_FALSE;
 
     nsCOMPtr<nsIPrefService> prefService(do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
     NS_ENSURE_SUCCESS(rv, rv);
     return prefService->SavePrefFile(nsnull);
 }
 
 ///////////////// Capabilities API /////////////////////
 NS_IMETHODIMP
@@ -2257,28 +2315,28 @@ nsScriptSecurityManager::CheckConfirmDia
     nsXPIDLString noStr;
     rv = sStrBundle->GetStringFromName(NS_LITERAL_STRING("No").get(),
                                        getter_Copies(noStr));
     if (NS_FAILED(rv))
         return PR_FALSE;
 
     nsXPIDLCString val;
     PRBool hasCert;
     aPrincipal->GetHasCertificate(&hasCert);
     if (hasCert)
-        rv = aPrincipal->GetCommonName(getter_Copies(val));
+        rv = aPrincipal->GetPrettyName(val);
     else
         rv = aPrincipal->GetOrigin(getter_Copies(val));
 
     if (NS_FAILED(rv))
         return PR_FALSE;
 
-    NS_ConvertUTF8toUTF16 location(val.get());
+    NS_ConvertUTF8toUTF16 location(val);
     NS_ConvertASCIItoUTF16 capability(aCapability);
     FormatCapabilityString(capability);
     const PRUnichar *formatStrings[] = { location.get(), capability.get() };
 
     nsXPIDLString message;
     rv = sStrBundle->FormatStringFromName(NS_LITERAL_STRING("EnableCapabilityQuery").get(),
                                           formatStrings,
                                           NS_ARRAY_LENGTH(formatStrings),
                                           getter_Copies(message));
     if (NS_FAILED(rv))
@@ -2379,28 +2437,28 @@ nsScriptSecurityManager::EnableCapabilit
     if (NS_FAILED(RequestCapability(principal, capability, &canEnable)))
         return NS_ERROR_FAILURE;
 
     if (canEnable != nsIPrincipal::ENABLE_GRANTED)
     {
         nsXPIDLCString val;
         PRBool hasCert;
         nsresult rv;
         principal->GetHasCertificate(&hasCert);
         if (hasCert)
-            rv = principal->GetCommonName(getter_Copies(val));
+            rv = principal->GetPrettyName(val);
         else
             rv = principal->GetOrigin(getter_Copies(val));
 
         if (NS_FAILED(rv))
             return rv;
 
-        NS_ConvertUTF8toUTF16 location(val.get());
+        NS_ConvertUTF8toUTF16 location(val);
         NS_ConvertUTF8toUTF16 cap(capability);
         const PRUnichar *formatStrings[] = { location.get(), cap.get() };
 
         nsXPIDLString message;
         rv = sStrBundle->FormatStringFromName(NS_LITERAL_STRING("EnableCapabilityDenied").get(),
                                               formatStrings,
                                               NS_ARRAY_LENGTH(formatStrings),
                                               getter_Copies(message));
         if (NS_FAILED(rv))
             return rv;
@@ -2444,24 +2502,26 @@ nsScriptSecurityManager::DisableCapabili
     if (!principal)
         return NS_ERROR_NOT_AVAILABLE;
     void *annotation = JS_GetFrameAnnotation(cx, fp);
     principal->DisableCapability(capability, &annotation);
     JS_SetFrameAnnotation(cx, fp, annotation);
     return NS_OK;
 }
 
 //////////////// Master Certificate Functions ///////////////////////////////////////
 NS_IMETHODIMP
-nsScriptSecurityManager::SetCanEnableCapability(const char* certificateID,
+nsScriptSecurityManager::SetCanEnableCapability(const nsACString& certFingerprint,
                                                 const char* capability,
                                                 PRInt16 canEnable)
 {
+    NS_ENSURE_ARG(!certFingerprint.IsEmpty());
+    
     nsresult rv;
     nsIPrincipal* subjectPrincipal = doGetSubjectPrincipal(&rv);
     if (NS_FAILED(rv))
         return rv;
 
     //-- Get the system certificate
     if (!mSystemCertificate)
     {
         nsCOMPtr<nsIFile> systemCertFile;
         nsCOMPtr<nsIProperties> directoryService =
@@ -2503,21 +2563,24 @@ nsScriptSecurityManager::SetCanEnableCap
         JSContext* cx = GetCurrentJSContext();
         if (!cx) return NS_ERROR_FAILURE;
         static const char msg1[] = "Only code signed by the system certificate may call SetCanEnableCapability or Invalidate";
         static const char msg2[] = "Attempt to call SetCanEnableCapability or Invalidate when no system certificate has been established";
         SetPendingException(cx, mSystemCertificate ? msg1 : msg2);
         return NS_ERROR_FAILURE;
     }
 
     //-- Get the target principal
     nsCOMPtr<nsIPrincipal> objectPrincipal;
-    rv =  GetCertificatePrincipal(certificateID, nsnull, getter_AddRefs(objectPrincipal));
+    rv = DoGetCertificatePrincipal(certFingerprint, EmptyCString(),
+                                   EmptyCString(), nsnull,
+                                   nsnull, PR_FALSE,
+                                   getter_AddRefs(objectPrincipal));
     if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
     rv = objectPrincipal->SetCanEnableCapability(capability, canEnable);
     if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
     return SavePrincipal(objectPrincipal);
 }
 
 ////////////////////////////////////////////////
 // Methods implementing nsIXPCSecurityManager //
 ////////////////////////////////////////////////
 
@@ -3250,47 +3313,58 @@ nsScriptSecurityManager::InitDomainPolic
         }
     }
 
     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(prefCount, prefNames);
     if (currentPref < prefCount) // Loop exited early because of out-of-memory error
         return NS_ERROR_OUT_OF_MEMORY;
     return NS_OK;
 }
 
 
+// XXXbz We should really just get a prefbranch to handle this...
 nsresult
-nsScriptSecurityManager::PrincipalPrefNames(const char* pref,
-                                            char** grantedPref, char** deniedPref)
+nsScriptSecurityManager::GetPrincipalPrefNames(const char* prefBase,
+                                               nsCString& grantedPref,
+                                               nsCString& deniedPref,
+                                               nsCString& subjectNamePref)
 {
-    char* lastDot = PL_strrchr(pref, '.');
+    char* lastDot = PL_strrchr(prefBase, '.');
     if (!lastDot) return NS_ERROR_FAILURE;
-    PRInt32 prefLen = lastDot - pref + 1;
+    PRInt32 prefLen = lastDot - prefBase + 1;
 
-    *grantedPref = nsnull;
-    *deniedPref = nsnull;
+    grantedPref.Assign(prefBase, prefLen);
+    deniedPref.Assign(prefBase, prefLen);
+    subjectNamePref.Assign(prefBase, prefLen);
 
-    static const char granted[] = "granted";
-    *grantedPref = (char*)PR_MALLOC(prefLen + sizeof(granted));
-    if (!grantedPref) return NS_ERROR_OUT_OF_MEMORY;
-    PL_strncpy(*grantedPref, pref, prefLen);
-    PL_strcpy(*grantedPref + prefLen, granted);
+#define GRANTED "granted"
+#define DENIED "denied"
+#define SUBJECTNAME "subjectName"
 
-    static const char denied[] = "denied";
-    *deniedPref = (char*)PR_MALLOC(prefLen + sizeof(denied));
-    if (!deniedPref)
-    {
-        PR_FREEIF(*grantedPref);
+    grantedPref.AppendLiteral(GRANTED);
+    if (grantedPref.Length() != prefLen + sizeof(GRANTED) - 1) {
         return NS_ERROR_OUT_OF_MEMORY;
     }
-    PL_strncpy(*deniedPref, pref, prefLen);
-    PL_strcpy(*deniedPref + prefLen, denied);
 
+    deniedPref.AppendLiteral(DENIED);
+    if (deniedPref.Length() != prefLen + sizeof(DENIED) - 1) {
+        return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    subjectNamePref.AppendLiteral(SUBJECTNAME);
+    if (subjectNamePref.Length() != prefLen + sizeof(SUBJECTNAME) - 1) {
+        return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+#undef SUBJECTNAME
+#undef DENIED
+#undef GRANTED
+    
     return NS_OK;
 }
 
 nsresult
 nsScriptSecurityManager::InitPrincipals(PRUint32 aPrefCount, const char** aPrefNames,
                                         nsISecurityPref* aSecurityPref)
 {
     /* This is the principal preference syntax:
      * capability.principal.[codebase|codebaseTrusted|certificate].<name>.[id|granted|denied]
      * For example:
@@ -3300,49 +3374,58 @@ nsScriptSecurityManager::InitPrincipals(
      */
 
     /* codebaseTrusted means a codebase principal that can enable capabilities even if
      * codebase principals are disabled. Don't use trustedCodebase except with unspoofable
      * URLs such as HTTPS URLs.
      */
 
     static const char idSuffix[] = ".id";
     for (PRUint32 c = 0; c < aPrefCount; c++)
     {
-        PRInt32 prefNameLen = PL_strlen(aPrefNames[c]) - (sizeof(idSuffix)-1);
+        PRInt32 prefNameLen = PL_strlen(aPrefNames[c]) - 
+            (NS_ARRAY_LENGTH(idSuffix) - 1);
         if (PL_strcasecmp(aPrefNames[c] + prefNameLen, idSuffix) != 0)
             continue;
 
         nsXPIDLCString id;
         if (NS_FAILED(mSecurityPref->SecurityGetCharPref(aPrefNames[c], getter_Copies(id))))
             return NS_ERROR_FAILURE;
 
-        nsXPIDLCString grantedPrefName;
-        nsXPIDLCString deniedPrefName;
-        nsresult rv = PrincipalPrefNames(aPrefNames[c],
-                                         getter_Copies(grantedPrefName),
-                                         getter_Copies(deniedPrefName));
+        nsCAutoString grantedPrefName;
+        nsCAutoString deniedPrefName;
+        nsCAutoString subjectNamePrefName;
+        nsresult rv = GetPrincipalPrefNames(aPrefNames[c],
+                                            grantedPrefName,
+                                            deniedPrefName,
+                                            subjectNamePrefName);
         if (rv == NS_ERROR_OUT_OF_MEMORY)
             return rv;
         if (NS_FAILED(rv))
             continue;
 
         nsXPIDLCString grantedList;
-        mSecurityPref->SecurityGetCharPref(grantedPrefName, getter_Copies(grantedList));
+        mSecurityPref->SecurityGetCharPref(grantedPrefName.get(),
+                                           getter_Copies(grantedList));
         nsXPIDLCString deniedList;
-        mSecurityPref->SecurityGetCharPref(deniedPrefName, getter_Copies(deniedList));
+        mSecurityPref->SecurityGetCharPref(deniedPrefName.get(),
+                                           getter_Copies(deniedList));
+        nsXPIDLCString subjectName;
+        mSecurityPref->SecurityGetCharPref(subjectNamePrefName.get(),
+                                           getter_Copies(subjectName));
 
         //-- Delete prefs if their value is the empty string
         if (id.IsEmpty() || (grantedList.IsEmpty() && deniedList.IsEmpty()))
         {
             mSecurityPref->SecurityClearUserPref(aPrefNames[c]);
-            mSecurityPref->SecurityClearUserPref(grantedPrefName);
-            mSecurityPref->SecurityClearUserPref(deniedPrefName);
+            mSecurityPref->SecurityClearUserPref(grantedPrefName.get());
+            mSecurityPref->SecurityClearUserPref(deniedPrefName.get());
+            mSecurityPref->SecurityClearUserPref(subjectNamePrefName.get());
             continue;
         }
 
         //-- Create a principal based on the prefs
         static const char certificateName[] = "capability.principal.certificate";
         static const char codebaseName[] = "capability.principal.codebase";
         static const char codebaseTrustedName[] = "capability.principal.codebaseTrusted";
 
         PRBool isCert = PR_FALSE;
         PRBool isTrusted = PR_FALSE;
@@ -3360,22 +3443,23 @@ nsScriptSecurityManager::InitPrincipals(
         }
         else
         {
           NS_ERROR("Not a codebase or a certificate?!");
         }
 
         nsRefPtr<nsPrincipal> newPrincipal = new nsPrincipal();
         if (!newPrincipal)
             return NS_ERROR_OUT_OF_MEMORY;
 
-        rv = newPrincipal->InitFromPersistent(aPrefNames[c], id.get(),
-                                              grantedList, deniedList,
+        rv = newPrincipal->InitFromPersistent(aPrefNames[c], id, subjectName,
+                                              EmptyCString(),
+                                              grantedList, deniedList, nsnull, 
                                               isCert, isTrusted);
         if (NS_SUCCEEDED(rv))
             mPrincipals.Put(newPrincipal, newPrincipal);
     }
     return NS_OK;
 }
 
 const char nsScriptSecurityManager::sJSEnabledPrefName[] =
     "javascript.enabled";
 const char nsScriptSecurityManager::sJSMailEnabledPrefName[] =
Index: caps/src/nsSecurityManagerFactory.cpp
===================================================================
RCS file: /home/bzbarsky/mozilla/cvs-mirror/mozilla/caps/src/nsSecurityManagerFactory.cpp,v
retrieving revision 1.40
diff -u -p -d -u -1 -0 -r1.40 nsSecurityManagerFactory.cpp
--- caps/src/nsSecurityManagerFactory.cpp	6 Feb 2005 12:39:30 -0000	1.40
+++ caps/src/nsSecurityManagerFactory.cpp	27 May 2005 06:17:59 -0000
@@ -44,20 +44,21 @@
 #include "nsIPrincipal.h"
 #include "nsPrincipal.h"
 #include "nsSystemPrincipal.h"
 #include "nsIScriptNameSpaceManager.h"
 #include "nsIScriptExternalNameSet.h"
 #include "nsIScriptContext.h"
 #include "nsICategoryManager.h"
 #include "nsXPIDLString.h"
 #include "nsCOMPtr.h"
 #include "nsIServiceManager.h"
+#include "nsString.h"
 #include "nsPrefsCID.h"
 
 ///////////////////////
 // nsSecurityNameSet //
 ///////////////////////
 
 #define NS_SECURITYNAMESET_CID \
  { 0x7c02eadc, 0x76, 0x4d03, \
  { 0x99, 0x8d, 0x80, 0xd7, 0x79, 0xc4, 0x85, 0x89 } }
 #define NS_SECURITYNAMESET_CONTRACTID "@mozilla.org/security/script/nameset;1"
@@ -95,20 +96,44 @@ getStringArgument(JSContext *cx, JSObjec
      * We don't want to use JS_ValueToString because we want to be able
      * to have an object to represent a target in subsequent versions.
      */
     JSString *str = JSVAL_TO_STRING(argv[argNum]);
     if (!str)
         return nsnull;
 
     return JS_GetStringBytes(str);
 }
 
+static void
+getUTF8StringArgument(JSContext *cx, JSObject *obj, PRUint16 argNum,
+                      uintN argc, jsval *argv, nsCString& aRetval)
+{
+    if (argc <= argNum || !JSVAL_IS_STRING(argv[argNum])) {
+        JS_ReportError(cx, "String argument expected");
+        aRetval.Truncate();
+        return;
+    }
+
+    /*
+     * We don't want to use JS_ValueToString because we want to be able
+     * to have an object to represent a target in subsequent versions.
+     */
+    JSString *str = JSVAL_TO_STRING(argv[argNum]);
+    if (!str) {
+        aRetval.Truncate();
+        return;
+    }
+
+    PRUnichar *data = (PRUnichar*)JS_GetStringChars(str);
+    CopyUTF16toUTF8(data, aRetval);
+}
+
 PR_STATIC_CALLBACK(JSBool)
 netscape_security_isPrivilegeEnabled(JSContext *cx, JSObject *obj, uintN argc,
                                      jsval *argv, jsval *rval)
 {
     JSBool result = JS_FALSE;
     char *cap = getStringArgument(cx, obj, 0, argc, argv);
     if (cap) {
         nsresult rv;
         nsCOMPtr<nsIScriptSecurityManager> securityManager = 
                  do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
@@ -189,57 +214,59 @@ netscape_security_revertPrivilege(JSCont
     if (NS_FAILED(rv))
         return JS_FALSE;
     return JS_TRUE;
 }
 
 PR_STATIC_CALLBACK(JSBool)
 netscape_security_setCanEnablePrivilege(JSContext *cx, JSObject *obj, uintN argc,
                                         jsval *argv, jsval *rval)
 {
     if (argc < 2) return JS_FALSE;
-    char *principalID = getStringArgument(cx, obj, 0, argc, argv);
+    nsCAutoString principalFingerprint;
+    getUTF8StringArgument(cx, obj, 0, argc, argv, principalFingerprint);
     char *cap = getStringArgument(cx, obj, 1, argc, argv);
-    if (!principalID || !cap)
+    if (principalFingerprint.IsEmpty() || !cap)
         return JS_FALSE;
 
     nsresult rv;
     nsCOMPtr<nsIScriptSecurityManager> securityManager = 
              do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
     if (NS_FAILED(rv)) 
         return JS_FALSE;
 
     //    NS_ASSERTION(cx == GetCurrentContext(), "unexpected context");
 
-    rv = securityManager->SetCanEnableCapability(principalID, cap, 
+    rv = securityManager->SetCanEnableCapability(principalFingerprint, cap, 
                                                  nsIPrincipal::ENABLE_GRANTED);
     if (NS_FAILED(rv))
         return JS_FALSE;
     return JS_TRUE;
 }
 
 PR_STATIC_CALLBACK(JSBool)
 netscape_security_invalidate(JSContext *cx, JSObject *obj, uintN argc,
                              jsval *argv, jsval *rval)
 {
-    char *principalID = getStringArgument(cx, obj, 0, argc, argv);
-    if (!principalID)
+    nsCAutoString principalFingerprint;
+    getUTF8StringArgument(cx, obj, 0, argc, argv, principalFingerprint);
+    if (principalFingerprint.IsEmpty())
         return JS_FALSE;
 
     nsresult rv;
     nsCOMPtr<nsIScriptSecurityManager> securityManager = 
              do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
     if (NS_FAILED(rv)) 
         return JS_FALSE;
 
     //    NS_ASSERTION(cx == GetCurrentContext(), "unexpected context");
 
-    rv = securityManager->SetCanEnableCapability(principalID,
+    rv = securityManager->SetCanEnableCapability(principalFingerprint,
                                                  nsPrincipal::sInvalid,
                                                  nsIPrincipal::ENABLE_GRANTED);
     if (NS_FAILED(rv))
         return JS_FALSE;
     return JS_TRUE;
 }
 
 static JSFunctionSpec PrivilegeManager_static_methods[] = {
     { "isPrivilegeEnabled", netscape_security_isPrivilegeEnabled,   1},
     { "enablePrivilege",    netscape_security_enablePrivilege,      1},
Index: modules/oji/src/nsJVMManager.cpp
===================================================================
RCS file: /home/bzbarsky/mozilla/cvs-mirror/mozilla/modules/oji/src/nsJVMManager.cpp,v
retrieving revision 1.73
diff -u -p -d -u -1 -0 -r1.73 nsJVMManager.cpp
--- modules/oji/src/nsJVMManager.cpp	25 Feb 2005 20:46:24 -0000	1.73
+++ modules/oji/src/nsJVMManager.cpp	27 May 2005 06:17:59 -0000
@@ -896,50 +896,60 @@ nsJVMManager::IsLiveConnectEnabled(void)
 	return PR_TRUE;
 }
 
 /*
  * Find out if a given signer has been granted all permissions. This
  * is a precondition to loading a signed applet in trusted mode.
  * The certificate from which the fingerprint and commonname have
  * be derived, should have been verified before this method is 
  * called.
  */
-
+// XXXbz this function has been deprecated for 4.5 years.  We have no
+// callers in the tree.  Is it time to remove it?  It's returning
+// PRBools for a NS_METHOD, and NS_METHOD for an interface method, for
+// goodness' sake!
 NS_METHOD
 nsJVMManager::IsAllPermissionGranted(
     const char * lastFP,
     const char * lastCN, 
     const char * rootFP,
     const char * rootCN, 
     PRBool * isGranted)
 {
+    if (!lastFP || !lastCN) {
+        return PR_FALSE;
+    }
+    
     nsresult rv      = NS_OK;
 
     nsCOMPtr<nsIPrincipal> pIPrincipal;
   
     // Get the Script Security Manager.
 
     nsCOMPtr<nsIScriptSecurityManager> secMan = 
              do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
     if (NS_FAILED(rv) || !secMan) return PR_FALSE;
 
     // Ask the Script Security Manager to make a Certificate Principal.
     // The fingerprint is a one way hash of this certificate. It is used
     // as the key to store the principal in the principal database.
 
-    rv = secMan->GetCertificatePrincipal(lastFP, nsnull,
+    // XXXbz using the |lastCN| for the subjectName for lack of
+    // anything better.  Also not passing in a pointer to a cert,
+    // since we don't have one.
+    rv = secMan->GetCertificatePrincipal(nsDependentCString(lastFP),
+                                         nsDependentCString(lastCN),
+                                         nsDependentCString(lastCN),
+                                         nsnull, nsnull,
                                          getter_AddRefs(pIPrincipal));
     if (NS_FAILED(rv)) return PR_FALSE;
 
-    // Set the common name.
-    rv = pIPrincipal->SetCommonName(lastCN);
-
     PRInt16 ret;
 
     secMan->RequestCapability(pIPrincipal,"AllPermission",&ret);
 
     PR_ASSERT(isGranted);
     *isGranted = (ret!=0);
 
     return PR_TRUE;
 }
 
Index: modules/oji/src/nsCSecurityContext.cpp
===================================================================
RCS file: /home/bzbarsky/mozilla/cvs-mirror/mozilla/modules/oji/src/nsCSecurityContext.cpp,v
retrieving revision 1.34
diff -u -p -d -u -1 -0 -r1.34 nsCSecurityContext.cpp
--- modules/oji/src/nsCSecurityContext.cpp	18 Apr 2004 22:00:48 -0000	1.34
+++ modules/oji/src/nsCSecurityContext.cpp	27 May 2005 06:17:59 -0000
@@ -149,22 +149,22 @@ nsCSecurityContext::GetCertificateID(cha
     nsresult rv      = NS_OK;
     nsCOMPtr<nsIScriptSecurityManager> secMan = 
              do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
     if (NS_FAILED(rv) || !secMan) return NS_ERROR_FAILURE;
 
     secMan->GetSubjectPrincipal(getter_AddRefs(principal));
     if (!principal) {
         return NS_ERROR_FAILURE;
     }
 
-    nsXPIDLCString certificate;
-    principal->GetCertificateID(getter_Copies(certificate));
+    nsCAutoString certificate;
+    principal->GetFingerprint(certificate);
 
     PRInt32 certlen = certificate.Length();
     if (buflen <= certlen) {
         return NS_ERROR_FAILURE;
     }
 
     memcpy(buf, certificate.get(), certlen);
     buf[certlen] = nsnull;
 
     return NS_OK;
Index: modules/libjar/nsJARChannel.cpp
===================================================================
RCS file: /home/bzbarsky/mozilla/cvs-mirror/mozilla/modules/libjar/nsJARChannel.cpp,v
retrieving revision 1.115
diff -u -p -d -u -1 -0 -r1.115 nsJARChannel.cpp
--- modules/libjar/nsJARChannel.cpp	12 May 2005 15:20:43 -0000	1.115
+++ modules/libjar/nsJARChannel.cpp	27 May 2005 06:17:59 -0000
@@ -448,39 +448,46 @@ nsJARChannel::GetOwner(nsISupports **res
     if (NS_FAILED(rv)) {
         NS_ERROR("nsIJAR not supported");
         return rv;
     }
 
     nsCOMPtr<nsIPrincipal> cert;
     rv = jar->GetCertificatePrincipal(mJarEntry.get(), getter_AddRefs(cert));
     if (NS_FAILED(rv)) return rv;
 
     if (cert) {
-        nsXPIDLCString certID;
-        rv = cert->GetCertificateID(getter_Copies(certID));
+        nsCAutoString certFingerprint;
+        rv = cert->GetFingerprint(certFingerprint);
         if (NS_FAILED(rv)) return rv;
 
-        nsXPIDLCString commonName;
-        rv = cert->GetCommonName(getter_Copies(commonName));
+        nsCAutoString subjectName;
+        rv = cert->GetSubjectName(subjectName);
+        if (NS_FAILED(rv)) return rv;
+
+        nsCAutoString prettyName;
+        rv = cert->GetPrettyName(prettyName);
         if (NS_FAILED(rv)) return rv;
 
+        nsCOMPtr<nsISupports> certificate;
+        rv = cert->GetCertificate(getter_AddRefs(certificate));
+        if (NS_FAILED(rv)) return rv;
+        
         nsCOMPtr<nsIScriptSecurityManager> secMan = 
                  do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
         if (NS_FAILED(rv)) return rv;
 
-        rv = secMan->GetCertificatePrincipal(certID, mJarBaseURI,
+        rv = secMan->GetCertificatePrincipal(certFingerprint, subjectName,
+                                             prettyName, certificate,
+                                             mJarBaseURI,
                                              getter_AddRefs(cert));
         if (NS_FAILED(rv)) return rv;
 
-        rv = cert->SetCommonName(commonName);
-        if (NS_FAILED(rv)) return rv;
-        
         mOwner = do_QueryInterface(cert, &rv);
         if (NS_FAILED(rv)) return rv;
 
         NS_ADDREF(*result = mOwner);
     }
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsJARChannel::SetOwner(nsISupports *aOwner)
Index: security/manager/ssl/src/nsNSSComponent.cpp
===================================================================
RCS file: /home/bzbarsky/mozilla/cvs-mirror/mozilla/security/manager/ssl/src/nsNSSComponent.cpp,v
retrieving revision 1.124
diff -u -p -d -u -1 -0 -r1.124 nsNSSComponent.cpp
--- security/manager/ssl/src/nsNSSComponent.cpp	2 Jun 2005 02:39:16 -0000	1.124
+++ security/manager/ssl/src/nsNSSComponent.cpp	2 Jun 2005 05:57:37 -0000
@@ -1698,39 +1698,42 @@ nsNSSComponent::VerifySignature(const ch
           }
         }
       }
 
       //-- Create a certificate principal with id and organization data
       nsAutoString fingerprint;
       rv2 = pCert->GetSha1Fingerprint(fingerprint);
       if (NS_FAILED(rv2)) {
         break;
       }
-      nsCOMPtr<nsIPrincipal> certPrincipal;
-      rv2 = mScriptSecurityManager->
-        GetCertificatePrincipal(NS_ConvertUTF16toUTF8(fingerprint).get(),
-                                nsnull, getter_AddRefs(certPrincipal));
-      if (NS_FAILED(rv2) || !certPrincipal) {
-        break;
-      }
-      
       nsAutoString orgName;
       rv2 = pCert->GetOrganization(orgName);
       if (NS_FAILED(rv2)) {
         break;
       }
-      rv2 = certPrincipal->SetCommonName(NS_ConvertUTF16toUTF8(orgName).get());
+      nsAutoString subjectName;
+      rv2 = pCert->GetSubjectName(subjectName);
       if (NS_FAILED(rv2)) {
         break;
       }
     
-      NS_ADDREF(*aPrincipal = certPrincipal);
+      nsCOMPtr<nsIPrincipal> certPrincipal;
+      rv2 = mScriptSecurityManager->
+        GetCertificatePrincipal(NS_ConvertUTF16toUTF8(fingerprint),
+                                NS_ConvertUTF16toUTF8(subjectName),
+                                NS_ConvertUTF16toUTF8(orgName),
+                                pCert, nsnull, getter_AddRefs(certPrincipal));
+      if (NS_FAILED(rv2) || !certPrincipal) {
+        break;
+      }
+      
+      certPrincipal.swap(*aPrincipal);
     } while (0);
   }
 
   SEC_PKCS7DestroyContentInfo(p7_info);
 
   return rv2;
 }
 
 NS_IMETHODIMP
 nsNSSComponent::RandomUpdate(void *entropy, PRInt32 bufLen)
Index: xpinstall/src/nsXPITriggerInfo.cpp
===================================================================
RCS file: /home/bzbarsky/mozilla/cvs-mirror/mozilla/xpinstall/src/nsXPITriggerInfo.cpp,v
retrieving revision 1.29
diff -u -p -d -u -1 -0 -r1.29 nsXPITriggerInfo.cpp
--- xpinstall/src/nsXPITriggerInfo.cpp	6 Jul 2005 01:25:47 -0000	1.29
+++ xpinstall/src/nsXPITriggerInfo.cpp	9 Jul 2005 04:48:58 -0000
@@ -135,23 +135,26 @@ nsXPITriggerItem::SetPrincipal(nsIPrinci
     // aPrincipal can be null for various failure cases.
     // see bug 213894 for an example.
     // nsXPInstallManager::OnCertAvailable can be called with a null principal
     // and it can also force a null principal.
     if (!aPrincipal)
         return;
 
     PRBool hasCert;
     aPrincipal->GetHasCertificate(&hasCert);
     if (hasCert) {
-        nsXPIDLCString cName;
-        aPrincipal->GetCommonName(getter_Copies(cName));
-        CopyUTF8toUTF16(cName, mCertName);
+        nsCAutoString prettyName;
+        // XXXbz should this really be using the prettyName?  Perhaps
+        // it wants to get the subjectName or nsIX509Cert and display
+        // it sanely?
+        aPrincipal->GetPrettyName(prettyName);
+        CopyUTF8toUTF16(prettyName, mCertName);
     }
 }
 
 //
 // nsXPITriggerInfo
 //
 
 MOZ_DECL_CTOR_COUNTER(nsXPITriggerInfo)
 
 nsXPITriggerInfo::nsXPITriggerInfo()
Index: toolkit/mozapps/extensions/src/nsExtensionManager.js.in
===================================================================
RCS file: /home/bzbarsky/mozilla/cvs-mirror/mozilla/toolkit/mozapps/extensions/src/nsExtensionManager.js.in,v
retrieving revision 1.126
diff -u -p -d -u -1 -0 -r1.126 nsExtensionManager.js.in
--- toolkit/mozapps/extensions/src/nsExtensionManager.js.in	15 Jul 2005 11:07:32 -0000	1.126
+++ toolkit/mozapps/extensions/src/nsExtensionManager.js.in	16 Jul 2005 04:20:57 -0000
@@ -2634,26 +2634,28 @@ ExtensionManager.prototype = {
           // by the user, installing it if necessary. We do this here rather
           // than separately in |_finishOperations| because I don't want to
           // walk these lists multiple times on every startup.
           var item = this._getItemForDroppedFile(entry, location);
           if (item) {
             droppedInFiles.push({ file: entry, location: location });
 
             var zipReader = Components.classes["@mozilla.org/libjar/zip-reader;1"]
                                       .createInstance(Components.interfaces.nsIZipReader);
             zipReader.init(entry);
-            var commonName = "";
+            var prettyName = "";
             try {
               var jar = zipReader.QueryInterface(Components.interfaces.nsIJAR);
               var principal = { };
               var certPrincipal = zipReader.getCertificatePrincipal(null, principal);
-              commonName = principal.value.commonName;
+              // XXXbz This string could be empty.  This needs better
+              // UI to present principal.value.certificate's subject.
+              prettyName = principal.value.prettyName;
             }
             catch (e) { }
             xpinstallStrings = xpinstallStrings.concat([item.name, 
                                                         getURLSpecFromFile(entry),
                                                         item.iconURL, 
                                                         commonName]);
             isDirty = true;
           }
         }
       }
