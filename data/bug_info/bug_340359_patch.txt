? mozilla/security/manager/ssl/src/nsSSLThread.cpp-good
Index: mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp,v
retrieving revision 1.97.2.12
diff -u -u -1 -0 -p -r1.97.2.12 nsNSSIOLayer.cpp
--- mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp	9 Aug 2006 18:14:41 -0000	1.97.2.12
+++ mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp	18 Aug 2006 17:46:51 -0000
@@ -174,20 +174,21 @@ PRBool nsSSLSocketThreadData::ensure_buf
 }
 
 nsNSSSocketInfo::nsNSSSocketInfo()
   : mFd(nsnull),
     mSecurityState(nsIWebProgressListener::STATE_IS_INSECURE),
     mForSTARTTLS(PR_FALSE),
     mHandshakePending(PR_TRUE),
     mCanceled(PR_FALSE),
     mHasCleartextPhase(PR_FALSE),
     mHandshakeInProgress(PR_FALSE),
+    mHandshakeStartTime(0),
     mPort(0),
     mCAChain(nsnull)
 {
   mThreadData = new nsSSLSocketThreadData;
 }
 
 nsNSSSocketInfo::~nsNSSSocketInfo()
 {
   delete mThreadData;
 
@@ -455,20 +456,41 @@ nsresult nsNSSSocketInfo::RememberCAChai
   return NS_OK;
 }
 
 nsresult nsNSSSocketInfo::SetSSLStatus(nsISSLStatus *aSSLStatus)
 {
   mSSLStatus = aSSLStatus;
 
   return NS_OK;
 }
 
+void nsNSSSocketInfo::SetHandshakeInProgress(PRBool aIsIn)
+{
+  mHandshakeInProgress = aIsIn;
+
+  if (mHandshakeInProgress && !mHandshakeStartTime)
+  {
+    mHandshakeStartTime = PR_IntervalNow();
+  }
+}
+
+#define HANDSHAKE_TIMEOUT_SECONDS 8
+
+PRBool nsNSSSocketInfo::HandshakeTimeout()
+{
+  if (!mHandshakeInProgress)
+    return PR_FALSE;
+
+  return ((PRIntervalTime)(PR_IntervalNow() - mHandshakeStartTime)
+          > PR_SecondsToInterval(HANDSHAKE_TIMEOUT_SECONDS));
+}
+
 void nsSSLIOLayerHelpers::Cleanup()
 {
   if (mTLSIntolerantSites) {
     delete mTLSIntolerantSites;
     mTLSIntolerantSites = nsnull;
   }
 
   if (mSharedPollableEvent)
     PR_DestroyPollableEvent(mSharedPollableEvent);
 
@@ -1078,20 +1100,32 @@ nsSSLThread::checkHandshake(PRInt32 byte
   // In its response, the server says which version it wants to perform.
   // Many servers out there only know how to do v3.0.  Next, we're supposed
   // to send back the version of the protocol we requested (ie v3.1).  At
   // this point many servers's implementations are broken and they shut
   // down the connection when they don't see the version they sent back.
   // This is supposed to prevent a man in the middle from forcing one
   // side to dumb down to a lower level of the protocol.  Unfortunately,
   // there are enough broken servers out there that such a gross work-around
   // is necessary.  :(
 
+  // Additional comment added in August 2006:
+  // When we begun to use TLS hello extensions, we encountered a new class of
+  // broken server, which simply stall for a very long time.
+  // We would like to shorten the timeout, but limit this shorter timeout 
+  // to the handshake phase.
+  // When we arrive here for the first time (for a given socket),
+  // we know the connection is established, and the application code
+  // tried the first read or write. This triggers the beginning of the
+  // SSL handshake phase at the SSL FD level.
+  // We'll make a note of the current time,
+  // and use this to measure the elapsed time since handshake begin.
+
   PRBool handleHandshakeResultNow;
   socketInfo->GetHandshakePending(&handleHandshakeResultNow);
 
   if (0 > bytesTransfered) {
     PRInt32 err = PR_GetError();
     PRBool wantRetry = PR_FALSE;
     
     if (handleHandshakeResultNow) {
       // Let's see if there was an error set by the SSL libraries that we
       // should tell the user about.
Index: mozilla/security/manager/ssl/src/nsNSSIOLayer.h
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSIOLayer.h,v
retrieving revision 1.27.28.1
diff -u -u -1 -0 -p -r1.27.28.1 nsNSSIOLayer.h
--- mozilla/security/manager/ssl/src/nsNSSIOLayer.h	13 Apr 2006 22:07:18 -0000	1.27.28.1
+++ mozilla/security/manager/ssl/src/nsNSSIOLayer.h	18 Aug 2006 17:46:51 -0000
@@ -149,40 +149,42 @@ public:
 
   nsresult GetPort(PRInt32 *aPort);
   nsresult SetPort(PRInt32 aPort);
 
   void SetCanceled(PRBool aCanceled);
   PRBool GetCanceled();
   
   void SetHasCleartextPhase(PRBool aHasCleartextPhase);
   PRBool GetHasCleartextPhase();
   
-  void SetHandshakeInProgress(PRBool aIsIn) { mHandshakeInProgress = aIsIn; }
+  void SetHandshakeInProgress(PRBool aIsIn);
   PRBool GetHandshakeInProgress() { return mHandshakeInProgress; }
+  PRBool HandshakeTimeout();
 
   nsresult RememberCAChain(CERTCertList *aCertList);
 
   /* Set SSL Status values */
   nsresult SetSSLStatus(nsISSLStatus *aSSLStatus);  
   
   PRStatus CloseSocketAndDestroy();
   
 protected:
   nsCOMPtr<nsIInterfaceRequestor> mCallbacks;
   PRFileDesc* mFd;
   PRUint32 mSecurityState;
   nsString mShortDesc;
   PRPackedBool mForSTARTTLS;
   PRPackedBool mHandshakePending;
   PRPackedBool mCanceled;
   PRPackedBool mHasCleartextPhase;
   PRPackedBool mHandshakeInProgress;
+  PRIntervalTime mHandshakeStartTime;
   PRInt32 mPort;
   nsXPIDLCString mHostName;
   CERTCertList *mCAChain;
 
   /* SSL Status */
   nsCOMPtr<nsISSLStatus> mSSLStatus;
 
   nsresult ActivateSSL();
 
   nsSSLSocketThreadData *mThreadData;
Index: mozilla/security/manager/ssl/src/nsSSLThread.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsSSLThread.cpp,v
retrieving revision 1.2.2.4
diff -u -u -1 -0 -p -r1.2.2.4 nsSSLThread.cpp
--- mozilla/security/manager/ssl/src/nsSSLThread.cpp	9 Aug 2006 18:14:41 -0000	1.2.2.4
+++ mozilla/security/manager/ssl/src/nsSSLThread.cpp	18 Aug 2006 17:46:51 -0000
@@ -213,20 +213,21 @@ nsresult nsSSLThread::requestActivateSSL
 }
 
 PRInt16 nsSSLThread::requestPoll(nsNSSSocketInfo *si, PRInt16 in_flags, PRInt16 *out_flags)
 {
   if (!ssl_thread_singleton || !si || !ssl_thread_singleton->mThreadHandle)
     return 0;
 
   *out_flags = 0;
 
   PRBool want_sleep_and_wakeup_on_any_socket_activity = PR_FALSE;
+  PRBool handshake_timeout = PR_FALSE;
   
   {
     nsAutoLock threadLock(ssl_thread_singleton->mMutex);
 
     if (ssl_thread_singleton->mBusySocket)
     {
       // If there is currently any socket busy on the SSL thread,
       // use our own poll method implementation.
       
       switch (si->mThreadData->mSSLState)
@@ -295,20 +296,22 @@ PRInt16 nsSSLThread::requestPoll(nsNSSSo
             // can not be marked with pending I/O at the same time.
             
             NS_NOTREACHED("Socket not busy on SSL thread marked as pending");
             return 0;
           }
         }
         break;
         
         case nsSSLSocketThreadData::ssl_idle:
         {
+          handshake_timeout = si->HandshakeTimeout();
+
           if (si != ssl_thread_singleton->mBusySocket)
           {
             // Some other socket is currently busy on the SSL thread.
             // It is possible that busy socket is currently blocked (e.g. by UI).
             // Therefore we should not report "si" as being readable/writeable,
             // regardless whether it is.
             // (Because if we did report readable/writeable to the caller,
             // the caller would repeatedly request us to do I/O, 
             // although our read/write function would not be able to fulfil
             // the request, because our single worker is blocked).
@@ -320,20 +323,32 @@ PRInt16 nsSSLThread::requestPoll(nsNSSSo
             
             in_flags &= ~(PR_POLL_READ | PR_POLL_WRITE);
           }
         }
         break;
         
         default:
           break;
       }
     }
+    else
+    {
+      handshake_timeout = si->HandshakeTimeout();
+    }
+
+    if (handshake_timeout)
+    {
+      NS_ASSERTION(in_flags & PR_POLL_EXCEPT, "nsSSLThread::requestPoll handshake timeout, but caller did not poll for EXCEPT");
+
+      *out_flags |= PR_POLL_EXCEPT;
+      return in_flags;
+    }
   }
 
   if (want_sleep_and_wakeup_on_any_socket_activity)
   {
     // This is where we wait for any socket activity,
     // because we do not have a pollable event.
     // XXX Will this really cause us to wake up
     //     whatever happens?
 
     PR_Sleep( PR_MillisecondsToInterval(1) );
@@ -456,20 +471,28 @@ PRInt32 nsSSLThread::requestRead(nsNSSSo
         ssl_thread_singleton->mBusySocket = nsnull;
         
         // We'll handle the results further down,
         // while not holding the lock.
       }
     }
     else if (ssl_thread_singleton->mBusySocket)
     {
       some_other_socket_is_busy = PR_TRUE;
     }
+
+    if (!this_socket_is_busy && si->HandshakeTimeout())
+    {
+      restoreOriginalSocket_locked(si);
+      PR_SetError(PR_CONNECT_RESET_ERROR, 0);
+      checkHandshake(-1, si->mFd->lower, si);
+      return -1;
+    }
   }
 
   switch (my_ssl_state)
   {
     case nsSSLSocketThreadData::ssl_idle:
       {
         NS_ASSERTION(!this_socket_is_busy, "oops, unexpected incosistency");
         
         if (some_other_socket_is_busy)
         {
@@ -658,20 +681,28 @@ PRInt32 nsSSLThread::requestWrite(nsNSSS
         ssl_thread_singleton->mBusySocket = nsnull;
         
         // We'll handle the results further down,
         // while not holding the lock.
       }
     }
     else if (ssl_thread_singleton->mBusySocket)
     {
       some_other_socket_is_busy = PR_TRUE;
     }
+
+    if (!this_socket_is_busy && si->HandshakeTimeout())
+    {
+      restoreOriginalSocket_locked(si);
+      PR_SetError(PR_CONNECT_RESET_ERROR, 0);
+      checkHandshake(-1, si->mFd->lower, si);
+      return -1;
+    }
   }
 
   switch (my_ssl_state)
   {
     case nsSSLSocketThreadData::ssl_idle:
       {
         NS_ASSERTION(!this_socket_is_busy, "oops, unexpected incosistency");
         
         if (some_other_socket_is_busy)
         {
