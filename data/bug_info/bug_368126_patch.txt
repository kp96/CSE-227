Index: mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp,v
retrieving revision 1.97.2.15
diff -u -1 -0 -p -r1.97.2.15 nsNSSIOLayer.cpp
--- mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp	17 Dec 2006 02:37:44 -0000	1.97.2.15
+++ mozilla/security/manager/ssl/src/nsNSSIOLayer.cpp	2 Feb 2007 02:03:42 -0000
@@ -177,20 +177,22 @@ PRBool nsSSLSocketThreadData::ensure_buf
 }
 
 nsNSSSocketInfo::nsNSSSocketInfo()
   : mFd(nsnull),
     mSecurityState(nsIWebProgressListener::STATE_IS_INSECURE),
     mForSTARTTLS(PR_FALSE),
     mHandshakePending(PR_TRUE),
     mCanceled(PR_FALSE),
     mHasCleartextPhase(PR_FALSE),
     mHandshakeInProgress(PR_FALSE),
+    mAllowTLSIntoleranceTimeout(PR_TRUE),
+    mBlockedOnBadCertUI(PR_FALSE),
     mHandshakeStartTime(0),
     mPort(0),
     mCAChain(nsnull)
 {
   mThreadData = new nsSSLSocketThreadData;
 }
 
 nsNSSSocketInfo::~nsNSSSocketInfo()
 {
   delete mThreadData;
@@ -469,25 +471,43 @@ nsresult nsNSSSocketInfo::SetSSLStatus(n
 void nsNSSSocketInfo::SetHandshakeInProgress(PRBool aIsIn)
 {
   mHandshakeInProgress = aIsIn;
 
   if (mHandshakeInProgress && !mHandshakeStartTime)
   {
     mHandshakeStartTime = PR_IntervalNow();
   }
 }
 
-#define HANDSHAKE_TIMEOUT_SECONDS 8
+void nsNSSSocketInfo::SetBlockedOnBadCertUI(PRBool aCurrentlyBlockedOnUI)
+{
+  if (mBlockedOnBadCertUI && !aCurrentlyBlockedOnUI)
+  {
+    // we were blocked and going back to unblocked,
+    // so let's reset the handshake start time, in order to ensure
+    // we do not count the amount of time while the UI was shown.
+    mHandshakeStartTime = PR_IntervalNow();
+  }
+
+  mBlockedOnBadCertUI = aCurrentlyBlockedOnUI;
+}
+
+void nsNSSSocketInfo::SetAllowTLSIntoleranceTimeout(PRBool aAllow)
+{
+  mAllowTLSIntoleranceTimeout = aAllow;
+}
+
+#define HANDSHAKE_TIMEOUT_SECONDS 25
 
 PRBool nsNSSSocketInfo::HandshakeTimeout()
 {
-  if (!mHandshakeInProgress)
+  if (!mHandshakeInProgress || !mAllowTLSIntoleranceTimeout || mBlockedOnBadCertUI)
     return PR_FALSE;
 
   return ((PRIntervalTime)(PR_IntervalNow() - mHandshakeStartTime)
           > PR_SecondsToInterval(HANDSHAKE_TIMEOUT_SECONDS));
 }
 
 void nsSSLIOLayerHelpers::Cleanup()
 {
   if (mTLSIntolerantSites) {
     delete mTLSIntolerantSites;
@@ -2491,30 +2511,32 @@ nsNSSBadCertHandler(void *arg, PRFileDes
   CERTCertificate *peerCert;
   nsNSSCertificate *nssCert;
 
   error = PR_GetError();
   peerCert = SSL_PeerCertificate(sslSocket);
   nssCert = new nsNSSCertificate(peerCert);
   if (!nssCert) {
     return SECFailure;
   } 
   NS_ADDREF(nssCert);
+  infoObject->SetBlockedOnBadCertUI(PR_TRUE);
   while (rv != SECSuccess) {
      //Func nsContinueDespiteCertError does the same set of checks as func.
      //nsCertErrorNeedsDialog. So, removing call to nsCertErrorNeedsDialog
      if (!nsContinueDespiteCertError(infoObject, sslSocket, 
                                     error, nssCert)) {
       break;
     }
     rv = verifyCertAgain(peerCert, sslSocket, infoObject);
 	error = PR_GetError();
   }
+  infoObject->SetBlockedOnBadCertUI(PR_FALSE);
   NS_RELEASE(nssCert);
   CERT_DestroyCertificate(peerCert); 
   if (rv != SECSuccess) {
     // if the cert is bad, we don't want to connect
     infoObject->SetCanceled(PR_TRUE);
   }
   return rv;
 }
 
 static PRFileDesc*
@@ -2571,20 +2593,22 @@ nsSSLIOLayerSetOptions(PRFileDesc *fd, P
   }
 
   // Let's see if we're trying to connect to a site we know is
   // TLS intolerant.
   nsCAutoString key;
   key = nsDependentCString(host) + NS_LITERAL_CSTRING(":") + nsPrintfCString("%d", port);
 
   if (nsSSLIOLayerHelpers::isKnownAsIntolerantSite(key)) {
     if (SECSuccess != SSL_OptionSet(fd, SSL_ENABLE_TLS, PR_FALSE))
       return NS_ERROR_FAILURE;
+
+    infoObject->SetAllowTLSIntoleranceTimeout(PR_FALSE);
       
     // We assume that protocols that use the STARTTLS mechanism should support
     // modern hellos. For other protocols, if we suspect a site 
     // does not support TLS, let's also use V2 hellos.
     // One advantage of this approach, if a site only supports the older
     // hellos, it is more likely that we will get a reasonable error code
     // on our single retry attempt.
     
     if (!forSTARTTLS &&
         SECSuccess != SSL_OptionSet(fd, SSL_V2_COMPATIBLE_HELLO, PR_TRUE))
Index: mozilla/security/manager/ssl/src/nsNSSIOLayer.h
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsNSSIOLayer.h,v
retrieving revision 1.27.28.2
diff -u -1 -0 -p -r1.27.28.2 nsNSSIOLayer.h
--- mozilla/security/manager/ssl/src/nsNSSIOLayer.h	7 Sep 2006 18:39:48 -0000	1.27.28.2
+++ mozilla/security/manager/ssl/src/nsNSSIOLayer.h	2 Feb 2007 02:03:42 -0000
@@ -153,37 +153,42 @@ public:
   void SetCanceled(PRBool aCanceled);
   PRBool GetCanceled();
   
   void SetHasCleartextPhase(PRBool aHasCleartextPhase);
   PRBool GetHasCleartextPhase();
   
   void SetHandshakeInProgress(PRBool aIsIn);
   PRBool GetHandshakeInProgress() { return mHandshakeInProgress; }
   PRBool HandshakeTimeout();
 
+  void SetAllowTLSIntoleranceTimeout(PRBool aAllow);
+  void SetBlockedOnBadCertUI(PRBool aCurrentlyBlockedOnUI);
+
   nsresult RememberCAChain(CERTCertList *aCertList);
 
   /* Set SSL Status values */
   nsresult SetSSLStatus(nsISSLStatus *aSSLStatus);  
   
   PRStatus CloseSocketAndDestroy();
   
 protected:
   nsCOMPtr<nsIInterfaceRequestor> mCallbacks;
   PRFileDesc* mFd;
   PRUint32 mSecurityState;
   nsString mShortDesc;
   PRPackedBool mForSTARTTLS;
   PRPackedBool mHandshakePending;
   PRPackedBool mCanceled;
   PRPackedBool mHasCleartextPhase;
   PRPackedBool mHandshakeInProgress;
+  PRPackedBool mAllowTLSIntoleranceTimeout;
+  PRPackedBool mBlockedOnBadCertUI;
   PRIntervalTime mHandshakeStartTime;
   PRInt32 mPort;
   nsXPIDLCString mHostName;
   CERTCertList *mCAChain;
 
   /* SSL Status */
   nsCOMPtr<nsISSLStatus> mSSLStatus;
 
   nsresult ActivateSSL();
 
