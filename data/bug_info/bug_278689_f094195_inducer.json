{"bug_id":278689,"commitHash":"f094195","commit_info":{"sha":"f0941953dd79aaa15921ffd1597f0ccae2d1230a","commit":{"author":{"name":"Kaspar Brand","email":"mozcontrib@velox.ch","date":"2015-09-05T05:52:00Z"},"committer":{"name":"Kaspar Brand","email":"mozcontrib@velox.ch","date":"2015-09-05T05:52:00Z"},"message":"Bug 278689 - Multiple Certificates with the same subject are not shown in the digital signature select cert combo (only one is shown) r=dkeeler\n\n--HG--\nextra : rebase_source : 442661d99de1c5786c04d49cfcd96a672d3077be","tree":{"sha":"e38e14f8c3f6096a3d46e4bb1c363b090f7ccc84","url":"https://api.github.com/repos/mozilla/gecko-dev/git/trees/e38e14f8c3f6096a3d46e4bb1c363b090f7ccc84"},"url":"https://api.github.com/repos/mozilla/gecko-dev/git/commits/f0941953dd79aaa15921ffd1597f0ccae2d1230a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/mozilla/gecko-dev/commits/f0941953dd79aaa15921ffd1597f0ccae2d1230a","html_url":"https://github.com/mozilla/gecko-dev/commit/f0941953dd79aaa15921ffd1597f0ccae2d1230a","comments_url":"https://api.github.com/repos/mozilla/gecko-dev/commits/f0941953dd79aaa15921ffd1597f0ccae2d1230a/comments","author":null,"committer":null,"parents":[{"sha":"f0d829220d65b5c2d3f5111694ac5170d4b1f684","url":"https://api.github.com/repos/mozilla/gecko-dev/commits/f0d829220d65b5c2d3f5111694ac5170d4b1f684","html_url":"https://github.com/mozilla/gecko-dev/commit/f0d829220d65b5c2d3f5111694ac5170d4b1f684"}],"stats":{"total":53,"additions":43,"deletions":10},"files":[{"sha":"f4b6913611f81eb69fd1280d3d9a5b68310d4a98","filename":"security/manager/ssl/nsCertPicker.cpp","status":"modified","additions":37,"deletions":9,"changes":46,"blob_url":"https://github.com/mozilla/gecko-dev/blob/f0941953dd79aaa15921ffd1597f0ccae2d1230a/security/manager/ssl/nsCertPicker.cpp","raw_url":"https://github.com/mozilla/gecko-dev/raw/f0941953dd79aaa15921ffd1597f0ccae2d1230a/security/manager/ssl/nsCertPicker.cpp","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/security/manager/ssl/nsCertPicker.cpp?ref=f0941953dd79aaa15921ffd1597f0ccae2d1230a","patch":"@@ -36,6 +36,7 @@ NS_IMETHODIMP nsCertPicker::PickByUsage(nsIInterfaceRequestor *ctx,\n                                         int32_t certUsage, \n                                         bool allowInvalid, \n                                         bool allowDuplicateNicknames, \n+                                        const nsAString &emailAddress,\n                                         bool *canceled, \n                                         nsIX509Cert **_retval)\n {\n@@ -53,7 +54,7 @@ NS_IMETHODIMP nsCertPicker::PickByUsage(nsIInterfaceRequestor *ctx,\n     ScopedCERTCertList allcerts(PK11_ListCerts(PK11CertListUnique, ctx));\n   }\n \n-  /* find all user certs that are valid and for SSL */\n+  /* find all user certs that are valid for the specified usage */\n   /* note that we are allowing expired certs in this list */\n \n   ScopedCERTCertList certList(\n@@ -66,6 +67,32 @@ NS_IMETHODIMP nsCertPicker::PickByUsage(nsIInterfaceRequestor *ctx,\n     return NS_ERROR_NOT_AVAILABLE;\n   }\n \n+  /* if a (non-empty) emailAddress argument is supplied to PickByUsage, */\n+  /* remove non-matching certificates from the candidate list */\n+\n+  if (!emailAddress.IsEmpty()) {\n+    node = CERT_LIST_HEAD(certList);\n+    while (!CERT_LIST_END(node, certList)) {\n+      /* if the cert has at least one e-mail address, check if suitable */\n+      if (CERT_GetFirstEmailAddress(node->cert)) {\n+        RefPtr<nsNSSCertificate> tempCert(nsNSSCertificate::Create(node->cert));\n+        bool match = false;\n+        rv = tempCert->ContainsEmailAddress(emailAddress, &match);\n+        if (NS_FAILED(rv)) {\n+          return rv;\n+        }\n+        if (!match) {\n+          /* doesn't contain the specified address, so remove from the list */\n+          CERTCertListNode* freenode = node;\n+          node = CERT_LIST_NEXT(node);\n+          CERT_RemoveCertListNode(freenode);\n+          continue;\n+        }\n+      }\n+      node = CERT_LIST_NEXT(node);\n+    }\n+  }\n+\n   ScopedCERTCertNicknames nicknames(getNSSCertNicknamesFromCertList(certList.get()));\n   if (!nicknames) {\n     return NS_ERROR_NOT_AVAILABLE;\n@@ -88,20 +115,16 @@ NS_IMETHODIMP nsCertPicker::PickByUsage(nsIInterfaceRequestor *ctx,\n        node = CERT_LIST_NEXT(node)\n       )\n   {\n-    nsNSSCertificate *tempCert = nsNSSCertificate::Create(node->cert);\n+    RefPtr<nsNSSCertificate> tempCert(nsNSSCertificate::Create(node->cert));\n \n     if (tempCert) {\n \n-      // XXX we really should be using an nsCOMPtr instead of manually add-refing,\n-      // but nsNSSCertificate does not have a default constructor.\n-\n-      NS_ADDREF(tempCert);\n-\n       nsAutoString i_nickname(NS_ConvertUTF8toUTF16(nicknames->nicknames[CertsToUse]));\n       nsAutoString nickWithSerial;\n       nsAutoString details;\n \n       if (!selectionFound) {\n+        /* for the case when selectedNickname refers to a bare nickname */\n         if (i_nickname == nsDependentString(selectedNickname)) {\n           selectedIndex = CertsToUse;\n           selectionFound = true;\n@@ -111,14 +134,19 @@ NS_IMETHODIMP nsCertPicker::PickByUsage(nsIInterfaceRequestor *ctx,\n       if (NS_SUCCEEDED(tempCert->FormatUIStrings(i_nickname, nickWithSerial, details))) {\n         certNicknameList[CertsToUse] = ToNewUnicode(nickWithSerial);\n         certDetailsList[CertsToUse] = ToNewUnicode(details);\n+        if (!selectionFound) {\n+          /* for the case when selectedNickname refers to nickname + serial */\n+          if (nickWithSerial == nsDependentString(selectedNickname)) {\n+            selectedIndex = CertsToUse;\n+            selectionFound = true;\n+          }\n+        }\n       }\n       else {\n         certNicknameList[CertsToUse] = nullptr;\n         certDetailsList[CertsToUse] = nullptr;\n       }\n \n-      NS_RELEASE(tempCert);\n-\n       ++CertsToUse;\n     }\n   }"},{"sha":"e7e673c201f6265075a77f7f6a7e964d4b817e64","filename":"security/manager/ssl/nsIUserCertPicker.idl","status":"modified","additions":6,"deletions":1,"changes":7,"blob_url":"https://github.com/mozilla/gecko-dev/blob/f0941953dd79aaa15921ffd1597f0ccae2d1230a/security/manager/ssl/nsIUserCertPicker.idl","raw_url":"https://github.com/mozilla/gecko-dev/raw/f0941953dd79aaa15921ffd1597f0ccae2d1230a/security/manager/ssl/nsIUserCertPicker.idl","contents_url":"https://api.github.com/repos/mozilla/gecko-dev/contents/security/manager/ssl/nsIUserCertPicker.idl?ref=f0941953dd79aaa15921ffd1597f0ccae2d1230a","patch":"@@ -8,13 +8,18 @@\n interface nsIX509Cert;\n interface nsIInterfaceRequestor;\n \n-[scriptable, uuid(06d018e0-d41b-4629-a4fc-daaa6029888e)]\n+[scriptable, uuid(92396323-23f2-49e0-bf98-a25a725231ab)]\n interface nsIUserCertPicker : nsISupports {\n   nsIX509Cert pickByUsage(in nsIInterfaceRequestor ctx, \n                           in wstring selectedNickname,\n                           in long certUsage, // as defined by NSS enum SECCertUsage\n                           in boolean allowInvalid,\n                           in boolean allowDuplicateNicknames,\n+                          in AString emailAddress, // optional - if non-empty,\n+                                                   // skip certificates which\n+                                                   // have at least one e-mail\n+                                                   // address but do not\n+                                                   // include this specific one\n                           out boolean canceled);\n };\n "}]},"blames":["e368dc9c8","d2b70213a","2cd4e5db3","1a64376d9","783ead186","4876fecd7","4488103b7","b077d9624","c2d981f76","1a64376d","2cd4e5db","92da8727"]}