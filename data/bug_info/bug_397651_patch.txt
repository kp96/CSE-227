Index: security/manager/ssl/src/nsCrypto.cpp
===================================================================
RCS file: /cvsroot/mozilla/security/manager/ssl/src/nsCrypto.cpp,v
retrieving revision 1.75
diff -u -p -d -8 -r1.75 nsCrypto.cpp
--- security/manager/ssl/src/nsCrypto.cpp	28 Sep 2007 18:15:26 -0000	1.75
+++ security/manager/ssl/src/nsCrypto.cpp	18 Nov 2007 21:00:11 -0000
@@ -63,16 +63,17 @@
 #include "nsDOMJSUtils.h"
 #include "nsIXPConnect.h"
 #include "nsIRunnable.h"
 #include "nsIWindowWatcher.h"
 #include "nsIPrompt.h"
 #include "nsIFilePicker.h"
 #include "nsJSPrincipals.h"
 #include "nsIPrincipal.h"
+#include "nsIScriptSecurityManager.h"
 #include "nsXPIDLString.h"
 #include "nsIGenKeypairInfoDlg.h"
 #include "nsIDOMCryptoDialogs.h"
 #include "nsIFormSigningDialog.h"
 #include "nsIProxyObjectManager.h"
 #include "nsIJSContextStack.h"
 #include "jsapi.h"
 #include "jsdbgapi.h"
@@ -300,142 +301,16 @@ nsCrypto::SetEnableSmartCardEvents(PRBoo
 
 NS_IMETHODIMP
 nsCrypto::GetEnableSmartCardEvents(PRBool *aEnable)
 {
   *aEnable = mEnableSmartCardEvents;
   return NS_OK;
 }
 
-//These next few functions are based on implementation in
-//the script security manager to get the principals from
-//a JSContext.  We need that to successfully run the 
-//callback parameter passed to crypto.generateCRMFRequest
-static nsresult
-cryptojs_GetScriptPrincipal(JSContext *cx, JSScript *script,
-                            nsIPrincipal **result)
-{
-  if (!script) {
-    *result = nsnull;
-    return NS_OK;
-  }
-  JSPrincipals *jsp = JS_GetScriptPrincipals(cx, script);
-  if (!jsp) {
-    return NS_ERROR_FAILURE;
-  }
-  nsJSPrincipals *nsJSPrin = static_cast<nsJSPrincipals *>(jsp);
-  *result = nsJSPrin->nsIPrincipalPtr;
-  if (!*result) {
-    return NS_ERROR_FAILURE;
-  }
-  NS_ADDREF(*result);
-  return NS_OK;
-}
-
-static nsresult
-cryptojs_GetObjectPrincipal(JSContext *aCx, JSObject *aObj,
-                            nsIPrincipal **result)
-{
-  JSObject *parent = aObj;
-  do
-  {
-    JSClass *jsClass = JS_GetClass(aCx, parent);
-    const uint32 privateNsISupports = JSCLASS_HAS_PRIVATE | 
-                                      JSCLASS_PRIVATE_IS_NSISUPPORTS;
-    if (jsClass && (jsClass->flags & (privateNsISupports)) == 
-                    privateNsISupports)
-    {
-      nsISupports *supports = (nsISupports *) JS_GetPrivate(aCx, parent);
-      nsCOMPtr<nsIScriptObjectPrincipal> objPrin = do_QueryInterface(supports);
-              
-      if (!objPrin)
-      {
-        /*
-         * If it's a wrapped native, check the underlying native
-         * instead.
-         */
-        nsCOMPtr<nsIXPConnectWrappedNative> xpcNative = 
-                                            do_QueryInterface(supports);
-
-        if (xpcNative) {
-          objPrin = do_QueryWrappedNative(xpcNative);
-        }
-      }
-
-      if (objPrin && ((*result = objPrin->GetPrincipal()))) {
-        NS_ADDREF(*result);
-        return NS_OK;
-      }
-    }
-    parent = JS_GetParent(aCx, parent);
-  } while (parent);
-
-  // Couldn't find a principal for this object.
-  return NS_ERROR_FAILURE;
-}
-
-static nsresult
-cryptojs_GetFunctionObjectPrincipal(JSContext *cx, JSObject *obj,
-                                    nsIPrincipal **result)
-{
-  JSFunction *fun = (JSFunction *) JS_GetPrivate(cx, obj);
-
-  JSScript *script = JS_GetFunctionScript(cx, fun);
-  if (script && JS_GetFunctionObject(fun) != obj)
-  {
-    // Scripted function has been cloned; get principals from obj's
-    // parent-linked scope chain.  We do not get object principals for a
-    // cloned *native* function, because the subject in that case is a
-    // script or function further down the stack who is calling us.
-    return cryptojs_GetObjectPrincipal(cx, obj, result);
-  }
-  return cryptojs_GetScriptPrincipal(cx, script, result);
-}
-
-static nsresult
-cryptojs_GetFramePrincipal(JSContext *cx, JSStackFrame *fp,
-                           nsIPrincipal **principal)
-{
-  JSObject *obj = JS_GetFrameFunctionObject(cx, fp);
-  if (!obj) {
-    JSScript *script = JS_GetFrameScript(cx, fp);
-    return cryptojs_GetScriptPrincipal(cx, script, principal);
-  }
-  return cryptojs_GetFunctionObjectPrincipal(cx, obj, principal);
-}
-
-already_AddRefed<nsIPrincipal>
-nsCrypto::GetScriptPrincipal(JSContext *cx)
-{
-  JSStackFrame *fp = nsnull;
-  nsIPrincipal *principal=nsnull;
-
-  for (fp = JS_FrameIterator(cx, &fp); fp; fp = JS_FrameIterator(cx, &fp)) {
-    cryptojs_GetFramePrincipal(cx, fp, &principal);
-    if (principal != nsnull) {
-      break;
-    }
-  }
-
-  if (principal)
-    return principal;
-
-  nsIScriptContext *scriptContext = GetScriptContextFromJSContext(cx);
-
-  if (scriptContext)
-  {
-    nsCOMPtr<nsIScriptObjectPrincipal> globalData =
-      do_QueryInterface(scriptContext->GetGlobalObject());
-    NS_ENSURE_TRUE(globalData, nsnull);
-    NS_IF_ADDREF(principal = globalData->GetPrincipal());
-  }
-
-  return principal;
-}
-
 //A quick function to let us know if the key we're trying to generate
 //can be escrowed.
 static PRBool
 ns_can_escrow(nsKeyGenType keyGenType)
 {
   /* For now, we only escrow rsa-encryption and ec-encryption keys. */
   return (PRBool)(keyGenType == rsaEnc || keyGenType == ecEnc);
 }
@@ -2111,19 +1986,24 @@ nsCrypto::GenerateCRMFRequest(nsIDOMCRMF
   // the only way to make this method work was to have a callback
   // in the JS layer that got called after key generation had happened.
   // So for backwards compatibility, we return control and then just post
   // an event to call the JS the script provides as the code to execute
   // when the request has been generated.
   //
 
 
-  nsCOMPtr<nsIPrincipal>principals;
-  principals = GetScriptPrincipal(cx);
-  NS_ASSERTION(principals, "Couldn't get the principals");
+  nsCOMPtr<nsIScriptSecurityManager> secMan =
+    do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
+  NS_ENSURE_TRUE(secMan, NS_ERROR_UNEXPECTED);
+  
+  nsCOMPtr<nsIPrincipal> principals;
+  secMan->GetSubjectPrincipal(getter_AddRefs(principals));
+  NS_ENSURE_TRUE(principals, NS_ERROR_UNEXPECTED);
+  
   nsCryptoRunArgs *args = new nsCryptoRunArgs();
   if (!args)
     return NS_ERROR_OUT_OF_MEMORY;
 
   args->m_cx         = cx;
   args->m_kungFuDeathGrip = GetISupportsFromContext(cx);
   args->m_scope      = JS_GetParent(cx, script_obj);
   args->m_jsCallback.Adopt(jsCallback ? nsCRT::strdup(jsCallback) : 0);
