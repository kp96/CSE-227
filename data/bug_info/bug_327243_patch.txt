Index: caps/idl/nsIScriptSecurityManager.idl
===================================================================
RCS file: /cvsroot/mozilla/caps/idl/nsIScriptSecurityManager.idl,v
retrieving revision 1.70
diff -u -p -d -8 -r1.70 nsIScriptSecurityManager.idl
--- caps/idl/nsIScriptSecurityManager.idl	21 Aug 2006 22:15:20 -0000	1.70
+++ caps/idl/nsIScriptSecurityManager.idl	11 Nov 2006 23:10:31 -0000
@@ -36,17 +36,17 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsISupports.idl"
 #include "nsIPrincipal.idl"
 #include "nsIXPCSecurityManager.idl"
 interface nsIURI;
 
 
-[scriptable, uuid(5a46e611-cf4a-4407-a5b4-002fcf051120)]
+[scriptable, uuid(b9024f88-9ad2-491c-9777-ce5191033d3d)]
 interface nsIScriptSecurityManager : nsIXPCSecurityManager
 {
     ///////////////// Security Checks //////////////////
     /**
      * Checks whether the running script is allowed to access aProperty.
      */
     [noscript] void checkPropertyAccess(in JSContextPtr aJSContext,
                                         in JSObjectPtr aJSObject,
@@ -277,25 +277,14 @@ interface nsIScriptSecurityManager : nsI
     void checkSameOriginPrincipal(in nsIPrincipal aSourcePrincipal,
                                   in nsIPrincipal aTargetPrincipal);
 
     /**
      * Returns the principal of the global object of the given context, or null
      * if no global or no principal.
      */
     [noscript] nsIPrincipal getPrincipalFromContext(in JSContextPtr cx);
-
-    /**
-     * Utility method for comparing two URIs.  For security purposes, two URIs
-     * are equivalent if their schemes, hosts, and ports (if any) match.  This
-     * method returns true if aSubjectURI and aObjectURI have the same origin,
-     * false otherwise.
-     // FIXME: Bug 327243 -- this is no longer used outside caps.
-     // Should it even be exposed?
-     */
-    [noscript] boolean securityCompareURIs(in nsIURI aSubjectURI,
-                                           in nsIURI aObjectURI);
 };
 
 %{C++
 #define NS_SCRIPTSECURITYMANAGER_CONTRACTID "@mozilla.org/scriptsecuritymanager;1"
 #define NS_SCRIPTSECURITYMANAGER_CLASSNAME "scriptsecuritymanager"
 %}
Index: caps/include/nsScriptSecurityManager.h
===================================================================
RCS file: /cvsroot/mozilla/caps/include/nsScriptSecurityManager.h,v
retrieving revision 1.99
diff -u -p -d -8 -r1.99 nsScriptSecurityManager.h
--- caps/include/nsScriptSecurityManager.h	4 May 2006 15:23:42 -0000	1.99
+++ caps/include/nsScriptSecurityManager.h	11 Nov 2006 23:02:32 -0000
@@ -541,16 +541,25 @@ private:
     nsresult
     InitDomainPolicy(JSContext* cx, const char* aPolicyName,
                      DomainPolicy* aDomainPolicy);
 
     nsresult
     InitPrincipals(PRUint32 prefCount, const char** prefNames,
                    nsISecurityPref* securityPref);
 
+
+    /**
+     * Utility method for comparing two URIs.  For security purposes, two URIs
+     * are equivalent if their schemes, hosts, and ports (if any) match.  This
+     * method returns true if aSubjectURI and aObjectURI have the same origin,
+     * false otherwise.
+     */
+    PRBool SecurityCompareURIs(nsIURI* aSourceURI, nsIURI* aTargetURI);
+
 #ifdef XPC_IDISPATCH_SUPPORT
     // While this header is included outside of caps, this class isn't 
     // referenced so this should be fine.
     nsresult
     CheckComponentPermissions(JSContext *cx, const nsCID &aCID);
 #endif
 #ifdef DEBUG_CAPS_HACKER
     void
Index: caps/src/nsScriptSecurityManager.cpp
===================================================================
RCS file: /cvsroot/mozilla/caps/src/nsScriptSecurityManager.cpp,v
retrieving revision 1.310
diff -u -p -d -8 -r1.310 nsScriptSecurityManager.cpp
--- caps/src/nsScriptSecurityManager.cpp	21 Aug 2006 22:15:20 -0000	1.310
+++ caps/src/nsScriptSecurityManager.cpp	11 Nov 2006 23:10:03 -0000
@@ -241,130 +241,124 @@ nsScriptSecurityManager::GetSafeJSContex
     }
 
     JSContext *cx;
     if (NS_FAILED(mJSContextStack->GetSafeJSContext(&cx)))
         return nsnull;
     return cx;
 }
 
-NS_IMETHODIMP
+PRBool
 nsScriptSecurityManager::SecurityCompareURIs(nsIURI* aSourceURI,
-                                             nsIURI* aTargetURI,
-                                             PRBool* result)
+                                             nsIURI* aTargetURI)
 {
-    *result = PR_FALSE;
-
     // Note that this is not an Equals() test on purpose -- for URIs that don't
     // support host/port, we want equality to basically be object identity, for
     // security purposes.  Otherwise, for example, two javascript: URIs that
     // are otherwise unrelated could end up "same origin", which would be
     // unfortunate.
     if (aSourceURI == aTargetURI)
     {
-        *result = PR_TRUE;
-        return NS_OK;
+        return PR_TRUE;
     }
 
     if (!aTargetURI || !aSourceURI) 
     {
-        // return false
-        return NS_OK;
+        return PR_FALSE;
     }
 
     // If either URI is a nested URI, get the base URI
     nsCOMPtr<nsIURI> sourceBaseURI = NS_GetInnermostURI(aSourceURI);
     
     nsCOMPtr<nsIURI> targetBaseURI = NS_GetInnermostURI(aTargetURI);
 
     if (!sourceBaseURI || !targetBaseURI)
-        return NS_ERROR_FAILURE;
+        return PR_FALSE;
 
     // Compare schemes
     nsCAutoString targetScheme;
     nsresult rv = targetBaseURI->GetScheme(targetScheme);
     nsCAutoString sourceScheme;
     if (NS_SUCCEEDED(rv))
         rv = sourceBaseURI->GetScheme(sourceScheme);
-    if (NS_SUCCEEDED(rv) && targetScheme.Equals(sourceScheme))
+    if (NS_FAILED(rv) || !targetScheme.Equals(sourceScheme)) {
+        return PR_FALSE;
+    }
+    
+    if (targetScheme.EqualsLiteral("file"))
     {
-        if (targetScheme.EqualsLiteral("file"))
-        {
-            // All file: urls are considered to have the same origin.
-            *result = PR_TRUE;
-        }
-        else if (targetScheme.EqualsLiteral("imap") ||
-                 targetScheme.EqualsLiteral("mailbox") ||
-                 targetScheme.EqualsLiteral("news"))
-        {
-            // Each message is a distinct trust domain; use the 
-            // whole spec for comparison
-            nsCAutoString targetSpec;
-            if (NS_FAILED(targetBaseURI->GetSpec(targetSpec)))
-                return NS_ERROR_FAILURE;
-            nsCAutoString sourceSpec;
-            if (NS_FAILED(sourceBaseURI->GetSpec(sourceSpec)))
-                return NS_ERROR_FAILURE;
-            *result = targetSpec.Equals(sourceSpec);
-        }
-        else
-        {
-            // Compare hosts
-            nsCAutoString targetHost;
-            rv = targetBaseURI->GetHost(targetHost);
-            nsCAutoString sourceHost;
-            if (NS_SUCCEEDED(rv))
-                rv = sourceBaseURI->GetHost(sourceHost);
-            *result = NS_SUCCEEDED(rv) &&
-                      targetHost.Equals(sourceHost,
-                                        nsCaseInsensitiveCStringComparator());
-            if (*result) 
-            {
-                // Compare ports
-                PRInt32 targetPort;
-                rv = targetBaseURI->GetPort(&targetPort);
-                PRInt32 sourcePort;
-                if (NS_SUCCEEDED(rv))
-                    rv = sourceBaseURI->GetPort(&sourcePort);
-                *result = NS_SUCCEEDED(rv) && targetPort == sourcePort;
-                // If the port comparison failed, see if either URL has a
-                // port of -1. If so, replace -1 with the default port
-                // for that scheme.
-                if (NS_SUCCEEDED(rv) && !*result &&
-                    (sourcePort == -1 || targetPort == -1))
-                {
-                    NS_ENSURE_STATE(sIOService);
+        // All file: urls are considered to have the same origin.
+        return  PR_TRUE;
+    }
 
-                    NS_ASSERTION(targetScheme.Equals(sourceScheme),
-                                 "Schemes should be equal here");
+    if (targetScheme.EqualsLiteral("imap") ||
+        targetScheme.EqualsLiteral("mailbox") ||
+        targetScheme.EqualsLiteral("news"))
+    {
+        // Each message is a distinct trust domain; use the 
+        // whole spec for comparison
+        nsCAutoString targetSpec;
+        if (NS_FAILED(targetBaseURI->GetSpec(targetSpec)))
+            return PR_FALSE;
+        nsCAutoString sourceSpec;
+        if (NS_FAILED(sourceBaseURI->GetSpec(sourceSpec)))
+            return PR_FALSE;
+        return targetSpec.Equals(sourceSpec);
+    }
+
+    // Compare hosts
+    nsCAutoString targetHost;
+    rv = targetBaseURI->GetHost(targetHost);
+    nsCAutoString sourceHost;
+    if (NS_SUCCEEDED(rv))
+        rv = sourceBaseURI->GetHost(sourceHost);
+    if (NS_FAILED(rv) ||
+        !targetHost.Equals(sourceHost, nsCaseInsensitiveCStringComparator())) {
+        return PR_FALSE;
+    }
+    
+    // Compare ports
+    PRInt32 targetPort;
+    rv = targetBaseURI->GetPort(&targetPort);
+    PRInt32 sourcePort;
+    if (NS_SUCCEEDED(rv))
+        rv = sourceBaseURI->GetPort(&sourcePort);
+    PRBool result = NS_SUCCEEDED(rv) && targetPort == sourcePort;
+    // If the port comparison failed, see if either URL has a
+    // port of -1. If so, replace -1 with the default port
+    // for that scheme.
+    if (NS_SUCCEEDED(rv) && !result &&
+        (sourcePort == -1 || targetPort == -1))
+    {
+        NS_ENSURE_STATE(sIOService);
+
+        NS_ASSERTION(targetScheme.Equals(sourceScheme),
+                     "Schemes should be equal here");
                     
-                    PRInt32 defaultPort;
-                    nsCOMPtr<nsIProtocolHandler> protocolHandler;
-                    rv = sIOService->GetProtocolHandler(sourceScheme.get(),
-                                                        getter_AddRefs(protocolHandler));
-                    if (NS_FAILED(rv))
-                    {
-                        *result = PR_FALSE;
-                        return NS_OK;
-                    }
+        PRInt32 defaultPort;
+        nsCOMPtr<nsIProtocolHandler> protocolHandler;
+        rv = sIOService->GetProtocolHandler(sourceScheme.get(),
+                                            getter_AddRefs(protocolHandler));
+        if (NS_FAILED(rv))
+        {
+            return PR_FALSE;
+        }
                     
-                    rv = protocolHandler->GetDefaultPort(&defaultPort);
-                    if (NS_FAILED(rv) || defaultPort == -1)
-                        return NS_OK; // No default port for this scheme
+        rv = protocolHandler->GetDefaultPort(&defaultPort);
+        if (NS_FAILED(rv) || defaultPort == -1)
+            return PR_FALSE; // No default port for this scheme
 
-                    if (sourcePort == -1)
-                        sourcePort = defaultPort;
-                    else if (targetPort == -1)
-                        targetPort = defaultPort;
-                    *result = targetPort == sourcePort;
-                }
-            }
-        }
+        if (sourcePort == -1)
+            sourcePort = defaultPort;
+        else if (targetPort == -1)
+            targetPort = defaultPort;
+        result = targetPort == sourcePort;
     }
-    return NS_OK;
+
+    return result;
 }
 
 ////////////////////
 // Policy Storage //
 ////////////////////
 
 // Table of security levels
 PR_STATIC_CALLBACK(PRBool)
@@ -563,38 +557,29 @@ nsScriptSecurityManager::CheckSameOrigin
     nsCOMPtr<nsIURI> sourceURI;
     sourcePrincipal->GetDomain(getter_AddRefs(sourceURI));
     if (!sourceURI) {
       sourcePrincipal->GetURI(getter_AddRefs(sourceURI));
       NS_ENSURE_TRUE(sourceURI, NS_ERROR_FAILURE);
     }
 
     // Compare origins
-    PRBool sameOrigin = PR_FALSE;
-    rv = SecurityCompareURIs(sourceURI, aTargetURI, &sameOrigin);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    if (!sameOrigin)
+    if (!SecurityCompareURIs(sourceURI, aTargetURI))
     {
          ReportError(cx, NS_LITERAL_STRING("CheckSameOriginError"), sourceURI, aTargetURI);
          return NS_ERROR_DOM_BAD_URI;
     }
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsScriptSecurityManager::CheckSameOriginURI(nsIURI* aSourceURI,
                                             nsIURI* aTargetURI)
 {
-    nsresult rv;
-    PRBool sameOrigin = PR_FALSE;
-    rv = SecurityCompareURIs(aSourceURI, aTargetURI, &sameOrigin);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    if (!sameOrigin)
+    if (!SecurityCompareURIs(aSourceURI, aTargetURI))
     {
          ReportError(nsnull, NS_LITERAL_STRING("CheckSameOriginError"), 
                      aSourceURI, aTargetURI);
          return NS_ERROR_DOM_BAD_URI;
     }
     return NS_OK;
 }
 
@@ -870,21 +855,17 @@ nsScriptSecurityManager::CheckSameOrigin
         aObject->GetDomain(getter_AddRefs(objectURI));
         if (!objectURI) {
             aObject->GetURI(getter_AddRefs(objectURI));
         } else {
             objectSetDomain = PR_TRUE;
         }
     }
 
-    PRBool isSameOrigin = PR_FALSE;
-    nsresult rv = SecurityCompareURIs(subjectURI, objectURI, &isSameOrigin);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    if (isSameOrigin)
+    if (SecurityCompareURIs(subjectURI, objectURI))
     {   // If either the subject or the object has changed its principal by
         // explicitly setting document.domain then the other must also have
         // done so in order to be considered the same origin. This prevents
         // DNS spoofing based on document.domain (154930)
 
         // But this restriction does not apply to CheckConnect calls, since
         // that's called for data-only load checks like XMLHTTPRequest where
         // we ignore domain (bug 290100).
