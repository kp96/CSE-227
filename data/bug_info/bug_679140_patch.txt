# HG changeset patch
# Parent 2b2dd6daed7a7189e32cec730c11b212cf8fc45d
# User Brian Smith <bsmith@mozilla.com>
Bug 679140: Do all SSL error processing on the main thread, r=honzab.moz

diff --git a/security/manager/ssl/src/nsCertOverrideService.cpp b/security/manager/ssl/src/nsCertOverrideService.cpp
--- a/security/manager/ssl/src/nsCertOverrideService.cpp
+++ b/security/manager/ssl/src/nsCertOverrideService.cpp
@@ -45,17 +45,17 @@
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsStreamUtils.h"
 #include "nsNetUtil.h"
 #include "nsILineInputStream.h"
 #include "nsIObserver.h"
 #include "nsIObserverService.h"
 #include "nsISupportsPrimitives.h"
 #include "nsPromiseFlatString.h"
-#include "nsProxiedService.h"
+#include "nsThreadUtils.h"
 #include "nsStringBuffer.h"
 #include "nsAutoPtr.h"
 #include "nspr.h"
 #include "pk11pub.h"
 #include "certdb.h"
 #include "sechash.h"
 #include "ssl.h" // For SSL_ClearSessionCache
 
@@ -126,56 +126,55 @@ nsCertOverrideService::nsCertOverrideSer
 
 nsCertOverrideService::~nsCertOverrideService()
 {
 }
 
 nsresult
 nsCertOverrideService::Init()
 {
+  if (!NS_IsMainThread()) {
+    NS_NOTREACHED("nsCertOverrideService initialized off main thread");
+    return NS_ERROR_NOT_SAME_THREAD;
+  }
+
   if (!mSettingsTable.Init())
     return NS_ERROR_OUT_OF_MEMORY;
 
   mOidTagForStoringNewHashes = SEC_OID_SHA256;
 
   SECOidData *od = SECOID_FindOIDByTag(mOidTagForStoringNewHashes);
   if (!od)
     return NS_ERROR_FAILURE;
 
   char *dotted_oid = CERT_GetOidString(&od->oid);
   if (!dotted_oid)
     return NS_ERROR_FAILURE;
 
   mDottedOidForStoringNewHashes = dotted_oid;
   PR_smprintf_free(dotted_oid);
 
-  // cache mSettingsFile
-  NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR, getter_AddRefs(mSettingsFile));
-  if (mSettingsFile) {
-    mSettingsFile->AppendNative(NS_LITERAL_CSTRING(kCertOverrideFileName));
-  }
+  nsCOMPtr<nsIObserverService> observerService =
+      mozilla::services::GetObserverService();
 
-  Read();
-
-  nsresult rv;
-  NS_WITH_ALWAYS_PROXIED_SERVICE(nsIObserverService, mObserverService,
-                                 "@mozilla.org/observer-service;1",
-                                 NS_PROXY_TO_MAIN_THREAD, &rv);
-
-  if (mObserverService) {
-    mObserverService->AddObserver(this, "profile-before-change", PR_TRUE);
-    mObserverService->AddObserver(this, "profile-do-change", PR_TRUE);
-    mObserverService->AddObserver(this, "shutdown-cleanse", PR_TRUE);
+  // If we cannot add ourselves as a profile change observer, then we will not
+  // attempt to read/write any settings file. Otherwise, we would end up
+  // reading/writing the wrong settings file after a profile change.
+  if (observerService) {
+    observerService->AddObserver(this, "profile-before-change", true);
+    observerService->AddObserver(this, "profile-do-change", true);
+    // simulate a profile change so we read the current profile's settings file
+    Observe(nsnull, "profile-do-change", nsnull);
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsCertOverrideService::Observe(nsISupports     *aSubject,
+nsCertOverrideService::Observe(nsISupports     *,
                                const char      *aTopic,
                                const PRUnichar *aData)
 {
   // check the topic
   if (!nsCRT::strcmp(aTopic, "profile-before-change")) {
     // The profile is about to change,
     // or is going away because the application is shutting down.
 
@@ -196,16 +195,18 @@ nsCertOverrideService::Observe(nsISuppor
     // Now read from the new profile location.
     // we also need to update the cached file location
 
     ReentrantMonitorAutoEnter lock(monitor);
 
     nsresult rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR, getter_AddRefs(mSettingsFile));
     if (NS_SUCCEEDED(rv)) {
       mSettingsFile->AppendNative(NS_LITERAL_CSTRING(kCertOverrideFileName));
+    } else {
+      mSettingsFile = nsnull;
     }
     Read();
 
   }
 
   return NS_OK;
 }
 
@@ -238,16 +239,20 @@ nsCertOverrideService::RemoveAllTemporar
   }
 }
 
 nsresult
 nsCertOverrideService::Read()
 {
   ReentrantMonitorAutoEnter lock(monitor);
 
+  // If we don't have a profile, then we won't try to read any settings file.
+  if (!mSettingsFile)
+    return NS_OK;
+
   nsresult rv;
   nsCOMPtr<nsIInputStream> fileInputStream;
   rv = NS_NewLocalFileInputStream(getter_AddRefs(fileInputStream), mSettingsFile);
   if (NS_FAILED(rv)) {
     return rv;
   }
 
   nsCOMPtr<nsILineInputStream> lineInputStream = do_QueryInterface(fileInputStream, &rv);
@@ -357,18 +362,19 @@ WriteEntryCallback(nsCertOverrideEntry *
   return PL_DHASH_NEXT;
 }
 
 nsresult
 nsCertOverrideService::Write()
 {
   ReentrantMonitorAutoEnter lock(monitor);
 
+  // If we don't have any profile, then we won't try to write any file
   if (!mSettingsFile) {
-    return NS_ERROR_NULL_POINTER;
+    return NS_OK;
   }
 
   nsresult rv;
   nsCOMPtr<nsIOutputStream> fileOutputStream;
   rv = NS_NewSafeLocalFileOutputStream(getter_AddRefs(fileOutputStream),
                                        mSettingsFile,
                                        -1,
                                        0600);
diff --git a/security/manager/ssl/src/nsNSSComponent.cpp b/security/manager/ssl/src/nsNSSComponent.cpp
--- a/security/manager/ssl/src/nsNSSComponent.cpp
+++ b/security/manager/ssl/src/nsNSSComponent.cpp
@@ -1689,25 +1689,16 @@ nsNSSComponent::InitializeNSS(bool showW
       rv = profilePath->GetNativePath(profileStr);
   #endif
       if (NS_FAILED(rv)) {
         nsPSMInitPanic::SetPanic();
         return rv;
       }
     }
 
-    {
-      nsCOMPtr<nsICertOverrideService> icos =
-        do_GetService("@mozilla.org/security/certoverride;1", &rv);
-      if (NS_FAILED(rv)) {
-        nsPSMInitPanic::SetPanic();
-        return rv;
-      }
-    }
-
     hashTableCerts = PL_NewHashTable( 0, certHashtable_keyHash, certHashtable_keyCompare,
       certHashtable_valueCompare, 0, 0 );
 
   #if defined(XP_MACOSX)
     // function may modify the parameters
     // ignore return code from conversion, we continue anyway
     TryCFM2MachOMigration(cfmSecurityPath, profilePath);
   #endif
diff --git a/security/manager/ssl/src/nsNSSIOLayer.cpp b/security/manager/ssl/src/nsNSSIOLayer.cpp
--- a/security/manager/ssl/src/nsNSSIOLayer.cpp
+++ b/security/manager/ssl/src/nsNSSIOLayer.cpp
@@ -81,28 +81,30 @@
 #include "nsIDocShell.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsISecureBrowserUI.h"
 #include "nsProxyRelease.h"
 #include "nsIClassInfoImpl.h"
 #include "nsIProgrammingLanguage.h"
 #include "nsIArray.h"
 #include "nsCharSeparatedTokenizer.h"
+#include "PSMRunnable.h"
 
 #include "ssl.h"
 #include "secerr.h"
 #include "sslerr.h"
 #include "secder.h"
 #include "secasn1.h"
 #include "certdb.h"
 #include "cert.h"
 #include "keyhi.h"
 #include "secport.h"
 
 using namespace mozilla;
+using namespace mozilla::psm;
 
 //#define DEBUG_SSL_VERBOSE //Enable this define to get minimal 
                             //reports when doing SSL read/write
                             
 //#define DUMP_BUFFER  //Enable this define along with
                        //DEBUG_SSL_VERBOSE to dump SSL
                        //read/write buffer to a log.
                        //Uses PR_LOG except on Mac where
@@ -1320,49 +1322,49 @@ AppendErrorTextCode(PRErrorCode errorCod
     else {
       returnedMessage.Append(NS_LITERAL_STRING(" ("));
       returnedMessage.Append(idU);
       returnedMessage.Append(NS_LITERAL_STRING(")"));
     }
   }
 }
 
-static nsresult
+static void
 getInvalidCertErrorMessage(PRUint32 multipleCollectedErrors, 
                            PRErrorCode errorCodeToReport, 
                            PRErrorCode errTrust, 
                            PRErrorCode errMismatch, 
                            PRErrorCode errExpired,
                            const nsString &host,
                            const nsString &hostWithPort,
                            PRInt32 port,
                            nsIX509Cert* ix509,
-                           nsINSSComponent *component,
                            nsString &returnedMessage)
 {
-  NS_ENSURE_ARG_POINTER(component);
-
   const PRUnichar *params[1];
   nsresult rv;
 
   // For now, hide port when it's 443 and we're reporting the error.
   // In the future a better mechanism should be used
   // to make a decision about showing the port number, possibly by requiring
   // the context object to implement a specific interface.
   // The motivation is that Mozilla browser would like to hide the port number
   // in error pages in the common case.
   
   if (port == 443)
     params[0] = host.get();
   else
     params[0] = hostWithPort.get();
 
+  nsCOMPtr<nsINSSComponent> component = do_GetService(kNSSComponentCID, &rv);
+  if (NS_FAILED(rv))
+    return;
+
   nsString formattedString;
-  rv = component->PIPBundleFormatStringFromName("certErrorIntro", 
-                                                params, 1, 
+  rv = component->PIPBundleFormatStringFromName("certErrorIntro", params, 1,
                                                 formattedString);
   if (NS_SUCCEEDED(rv))
   {
     returnedMessage.Append(formattedString);
     returnedMessage.Append(NS_LITERAL_STRING("\n\n"));
   }
 
   if (multipleCollectedErrors & nsICertOverrideService::ERROR_UNTRUSTED)
@@ -1377,23 +1379,29 @@ getInvalidCertErrorMessage(PRUint32 mult
   }
 
   if (multipleCollectedErrors & nsICertOverrideService::ERROR_TIME)
   {
     AppendErrorTextTime(ix509, component, returnedMessage);
   }
 
   AppendErrorTextCode(errorCodeToReport, component, returnedMessage);
-
-  return NS_OK;
 }
 
 static void
 nsHandleSSLError(nsNSSSocketInfo *socketInfo, PRInt32 err)
 {
+  if (!NS_IsMainThread()) {
+    NS_ERROR("nsHandleSSLError called off the main thread");
+    return;
+  }
+
+  // SetCanceled is only called by the main thread or the SSL thread. Whenever
+  // this function is called, the SSL thread is waiting on this thread (the
+  // main thread). So, no mutex is necessary for SetCanceled()/GetCanceled().
   if (socketInfo->GetCanceled()) {
     // If the socket has been flagged as canceled,
     // the code who did was responsible for showing
     // an error message (if desired).
     return;
   }
 
   if (nsSSLThread::stoppedOrStopping()) {
@@ -1407,46 +1415,31 @@ nsHandleSSLError(nsNSSSocketInfo *socket
     return;
 
   nsXPIDLCString hostName;
   socketInfo->GetHostName(getter_Copies(hostName));
 
   PRInt32 port;
   socketInfo->GetPort(&port);
 
+  bool suppressMessage = false;
+
   // Try to get a nsISSLErrorListener implementation from the socket consumer.
   nsCOMPtr<nsIInterfaceRequestor> cb;
   socketInfo->GetNotificationCallbacks(getter_AddRefs(cb));
   if (cb) {
-    nsCOMPtr<nsIInterfaceRequestor> callbacks;
-    NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
-                         NS_GET_IID(nsIInterfaceRequestor),
-                         cb,
-                         NS_PROXY_SYNC,
-                         getter_AddRefs(callbacks));
-
-    nsCOMPtr<nsISSLErrorListener> sel = do_GetInterface(callbacks);
+    nsCOMPtr<nsISSLErrorListener> sel = do_GetInterface(cb);
     if (sel) {
-      nsISSLErrorListener *proxy_sel = nsnull;
-      NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
-                           NS_GET_IID(nsISSLErrorListener),
-                           sel,
-                           NS_PROXY_SYNC,
-                           (void**)&proxy_sel);
-      if (proxy_sel) {
-        nsIInterfaceRequestor *csi = static_cast<nsIInterfaceRequestor*>(socketInfo);
-        bool suppressMessage = false;
-        nsCString hostWithPortString = hostName;
-        hostWithPortString.AppendLiteral(":");
-        hostWithPortString.AppendInt(port);
-        rv = proxy_sel->NotifySSLError(csi, err, hostWithPortString, 
-                                       &suppressMessage);
-        if (NS_SUCCEEDED(rv) && suppressMessage)
-          return;
-      }
+      nsIInterfaceRequestor *csi = static_cast<nsIInterfaceRequestor*>(socketInfo);
+      nsCString hostWithPortString = hostName;
+      hostWithPortString.AppendLiteral(":");
+      hostWithPortString.AppendInt(port);
+      rv = sel->NotifySSLError(csi, err, hostWithPortString, &suppressMessage);
+      if (NS_SUCCEEDED(rv) && suppressMessage)
+        return;
     }
   }
 
   if (socketInfo->GetExternalErrorReporting()) {
     NS_ConvertASCIItoUTF16 hostNameU(hostName);
     nsString formattedString;
     (void) getErrorMessage(err, hostNameU, port, nssComponent, formattedString);
     socketInfo->SetErrorMessage(formattedString.get());
@@ -1797,16 +1790,33 @@ isTLSIntoleranceError(PRInt32 err, bool 
     case SSL_ERROR_DECODE_ERROR_ALERT:
     case SSL_ERROR_RX_UNKNOWN_ALERT:
       return PR_TRUE;
   }
   
   return PR_FALSE;
 }
 
+class SSLErrorRunnable : public SyncRunnableBase
+{
+ public:
+  SSLErrorRunnable(nsNSSSocketInfo * infoObject, PRErrorCode errorCode)
+    : mInfoObject(infoObject), mErrorCode(errorCode)
+  {
+  }
+
+  virtual void RunOnTargetThread()
+  {
+    nsHandleSSLError(mInfoObject, mErrorCode);
+  }
+  
+  nsRefPtr<nsNSSSocketInfo> mInfoObject;
+  const PRErrorCode mErrorCode;
+};
+
 PRInt32
 nsSSLThread::checkHandshake(PRInt32 bytesTransfered, 
                             bool wasReading,
                             PRFileDesc* ssl_layer_fd, 
                             nsNSSSocketInfo *socketInfo)
 {
   // This is where we work around all of those SSL servers that don't 
   // conform to the SSL spec and shutdown a connection when we request
@@ -1858,17 +1868,19 @@ nsSSLThread::checkHandshake(PRInt32 byte
       {
         wantRetry = nsSSLIOLayerHelpers::rememberPossibleTLSProblemSite(ssl_layer_fd, socketInfo);
       }
     }
     
     // This is the common place where we trigger an error message on a SSL socket.
     // This might be reached at any time of the connection.
     if (!wantRetry && (IS_SSL_ERROR(err) || IS_SEC_ERROR(err))) {
-      nsHandleSSLError(socketInfo, err);
+      nsRefPtr<SyncRunnableBase> runnable = new SSLErrorRunnable(socketInfo,
+                                                                 err);
+      (void) runnable->DispatchToMainThreadAndWait();
     }
   }
   else if (wasReading && 0 == bytesTransfered) // zero bytes on reading, socket closed
   {
     if (handleHandshakeResultNow)
     {
       if (!wantRetry // no decision yet
           && !socketInfo->GetHasCleartextPhase()) // mirror PR_CONNECT_RESET_ERROR treament
@@ -3180,33 +3192,68 @@ done:
   }
 
   *pRetCert = cert;
   *pRetKey = privKey;
 
   return ret;
 }
 
+class CertErrorRunnable : public SyncRunnableBase
+{
+ public:
+  CertErrorRunnable(const void * fdForLogging,
+                    nsIX509Cert * cert,
+                    nsNSSSocketInfo * infoObject,
+                    const CERTVerifyLog * verify_log,
+                    bool hasCertNameMismatch,
+                    PRErrorCode defaultErrorCodeToReport)
+    : mFdForLogging(fdForLogging), mCert(cert), mInfoObject(infoObject),
+      mVerifyLog(verify_log), mHasCertNameMismatch(hasCertNameMismatch),
+      mRv(SECFailure), mErrorCodeToReport(defaultErrorCodeToReport)
+  {
+  }
+
+  virtual void RunOnTargetThread();
+  
+  // in
+  const void * const mFdForLogging;
+  nsCOMPtr<nsIX509Cert> mCert;
+  nsNSSSocketInfo * const mInfoObject;
+  const CERTVerifyLog * const mVerifyLog;
+  const bool mHasCertNameMismatch;
+  nsXPIDLCString mHostname;
+
+  SECStatus mRv; // out
+  PRErrorCode mErrorCodeToReport; // in/out
+};
+
 static SECStatus
 cancel_and_failure(nsNSSSocketInfo* infoObject)
 {
   infoObject->SetCanceled(PR_TRUE);
   return SECFailure;
 }
 
 static SECStatus
 nsNSSBadCertHandler(void *arg, PRFileDesc *sslSocket)
 {
   // cert was revoked, don't do anything else
   // Calling cancel_and_failure is not necessary, and would be wrong,
   // [for errors other than the ones explicitly handled below,] 
   // because it suppresses error reporting.
-  if (PR_GetError() == SEC_ERROR_REVOKED_CERTIFICATE)
+  PRErrorCode defaultErrorCodeToReport = PR_GetError();
+  if (defaultErrorCodeToReport == SEC_ERROR_REVOKED_CERTIFICATE)
     return SECFailure;
 
+  if (defaultErrorCodeToReport == 0) {
+    NS_ERROR("No error code set during certificate validation failure.");
+    defaultErrorCodeToReport = SEC_ERROR_CERT_NOT_VALID;
+  }
+
   nsNSSShutDownPreventionLock locker;
   nsNSSSocketInfo* infoObject = (nsNSSSocketInfo *)arg;
   if (!infoObject)
     return SECFailure;
 
   if (nsSSLThread::stoppedOrStopping())
     return cancel_and_failure(infoObject);
 
@@ -3216,57 +3263,36 @@ nsNSSBadCertHandler(void *arg, PRFileDes
   if (!peerCert)
     return cancel_and_failure(infoObject);
 
   nsRefPtr<nsNSSCertificate> nssCert;
   nssCert = nsNSSCertificate::Create(peerCert);
   if (!nssCert)
     return cancel_and_failure(infoObject);
 
-  nsCOMPtr<nsIX509Cert> ix509 = static_cast<nsIX509Cert*>(nssCert.get());
-
   SECStatus srv;
   nsresult nsrv;
-  PRUint32 collected_errors = 0;
-  PRUint32 remaining_display_errors = 0;
-
-  PRErrorCode errorCodeTrust = SECSuccess;
-  PRErrorCode errorCodeMismatch = SECSuccess;
-  PRErrorCode errorCodeExpired = SECSuccess;
 
   nsCOMPtr<nsINSSComponent> inss = do_GetService(kNSSComponentCID, &nsrv);
   if (!inss)
     return cancel_and_failure(infoObject);
   nsRefPtr<nsCERTValInParamWrapper> survivingParams;
   nsrv = inss->GetDefaultCERTValInParam(survivingParams);
   if (NS_FAILED(nsrv))
     return cancel_and_failure(infoObject);
   
   char *hostname = SSL_RevealURL(sslSocket);
   if (!hostname)
     return cancel_and_failure(infoObject);
 
   charCleaner hostnameCleaner(hostname); 
-  nsDependentCString hostString(hostname);
-
-  PRInt32 port;
-  infoObject->GetPort(&port);
-
-  nsCString hostWithPortString = hostString;
-  hostWithPortString.AppendLiteral(":");
-  hostWithPortString.AppendInt(port);
-
-  NS_ConvertUTF8toUTF16 hostWithPortStringUTF16(hostWithPortString);
 
   // Check the name field against the desired hostname.
-  if (hostname[0] &&
-      CERT_VerifyCertName(peerCert, hostname) != SECSuccess) {
-    collected_errors |= nsICertOverrideService::ERROR_MISMATCH;
-    errorCodeMismatch = SSL_ERROR_BAD_CERT_DOMAIN;
-  }
+  bool hasCertNameMismatch =
+      hostname[0] && CERT_VerifyCertName(peerCert, hostname) != SECSuccess;
 
   {
     PRArenaPool *log_arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     if (!log_arena)    
       return cancel_and_failure(infoObject);
 
     PRArenaPoolCleanerFalseParam log_arena_cleaner(log_arena);
 
@@ -3275,43 +3301,104 @@ nsNSSBadCertHandler(void *arg, PRFileDes
       return cancel_and_failure(infoObject);
 
     CERTVerifyLogContentsCleaner verify_log_cleaner(verify_log);
 
     verify_log->arena = log_arena;
 
     if (!nsNSSComponent::globalConstFlagUsePKIXVerification) {
       srv = CERT_VerifyCertificate(CERT_GetDefaultCertDB(), peerCert,
-                                  PR_TRUE, certificateUsageSSLServer,
+                                  true, certificateUsageSSLServer,
                                   PR_Now(), (void*)infoObject, 
                                   verify_log, NULL);
     }
     else {
       CERTValOutParam cvout[2];
       cvout[0].type = cert_po_errorLog;
       cvout[0].value.pointer.log = verify_log;
       cvout[1].type = cert_po_end;
 
       srv = CERT_PKIXVerifyCert(peerCert, certificateUsageSSLServer,
                                 survivingParams->GetRawPointerForNSS(),
                                 cvout, (void*)infoObject);
     }
 
-    if (infoObject->IsCertIssuerBlacklisted()) {
-      collected_errors |= nsICertOverrideService::ERROR_UNTRUSTED;
-    }
-
     // We ignore the result code of the cert verification.
     // Either it is a failure, which is expected, and we'll process the
     //                         verify log below.
     // Or it is a success, then a domain mismatch is the only 
     //                     possible failure. 
 
+    nsRefPtr<CertErrorRunnable> runnable =
+      new CertErrorRunnable(static_cast<void*>(sslSocket), 
+                            static_cast<nsIX509Cert*>(nssCert.get()),
+                            infoObject, verify_log, hasCertNameMismatch,
+                            defaultErrorCodeToReport);
+
+    // now grab the host name to pass to the STS Service
+    nsrv = infoObject->GetHostName(getter_Copies(runnable->mHostname));
+    if (NS_FAILED(nsrv)) {
+      PR_SetError(defaultErrorCodeToReport, 0);
+      return SECFailure;
+    }
+
+    PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
+           ("[%p][%p] Before dispatching CertErrorRunnable\n",
+           sslSocket, runnable.get()));
+
+    // Dispatch SYNC since the result is used below
+    (void) runnable->DispatchToMainThreadAndWait();
+
+    PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
+           ("[%p][%p] After dispatching CertErrorRunnable\n",
+           sslSocket, runnable.get()));
+
+    if (runnable->mRv == SECSuccess)
+      return SECSuccess;
+  
+    NS_ASSERTION(runnable->mErrorCodeToReport != 0,
+                 "CertErrorRunnable did not set error code.");
+    PR_SetError(runnable->mErrorCodeToReport ? runnable->mErrorCodeToReport
+                                             : defaultErrorCodeToReport, 0);
+    return SECFailure;
+  }
+}
+
+void CertErrorRunnable::RunOnTargetThread()
+{
+  PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p][%p] top of CertErrorRunnable::Run\n",
+                                    mFdForLogging, this));
+
+  if (!NS_IsMainThread()) {
+    NS_ERROR("CertErrorRunnable::RunOnTargetThread called off main thread");
+    return;
+  }
+
+  if (nsSSLThread::stoppedOrStopping())
+    return;
+ 
+  PRErrorCode errorCodeMismatch = 0;
+  PRErrorCode errorCodeTrust = 0;
+  PRErrorCode errorCodeExpired = 0;
+
+  PRUint32 collected_errors = 0;
+
+  if (mInfoObject->IsCertIssuerBlacklisted()) {
+    collected_errors |= nsICertOverrideService::ERROR_UNTRUSTED;
+    errorCodeTrust = mErrorCodeToReport;
+  }
+
+  if (mHasCertNameMismatch) {
+    collected_errors |= nsICertOverrideService::ERROR_MISMATCH;
+    errorCodeMismatch = SSL_ERROR_BAD_CERT_DOMAIN;
+  }
+
+  {
     CERTVerifyLogNode *i_node;
-    for (i_node = verify_log->head; i_node; i_node = i_node->next)
+    for (i_node = mVerifyLog->head; i_node; i_node = i_node->next)
     {
       switch (i_node->error)
       {
         case SEC_ERROR_UNKNOWN_ISSUER:
         case SEC_ERROR_CA_CERT_INVALID:
         case SEC_ERROR_UNTRUSTED_ISSUER:
         case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
         case SEC_ERROR_UNTRUSTED_CERT:
@@ -3331,171 +3418,168 @@ nsNSSBadCertHandler(void *arg, PRFileDes
         case SEC_ERROR_EXPIRED_CERTIFICATE:
           collected_errors |= nsICertOverrideService::ERROR_TIME;
           if (errorCodeExpired == SECSuccess) {
             errorCodeExpired = i_node->error;
           }
           break;
         default:
           // we are not willing to continue on any other error
-          nsHandleSSLError(infoObject, i_node->error);
+          nsHandleSSLError(mInfoObject, i_node->error);
           // this error is our stop condition, so let's make sure
           // this error code will be reported to the external world.
-          PR_SetError(i_node->error, 0);
-          return cancel_and_failure(infoObject);
+          mErrorCodeToReport = i_node->error;
+          mInfoObject->SetCanceled(true);
+          return;
       }
     }
   }
 
   if (!collected_errors)
   {
     NS_NOTREACHED("why did NSS call our bad cert handler if all looks good? Let's cancel the connection");
-    return SECFailure;
+    PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p][%p] !collected_errors\n",
+           mFdForLogging, this));
+    return;
   }
 
-  nsRefPtr<nsSSLStatus> status = infoObject->SSLStatus();
+  nsRefPtr<nsSSLStatus> status = mInfoObject->SSLStatus();
   if (!status) {
     status = new nsSSLStatus();
-    infoObject->SetSSLStatus(status);
+    mInfoObject->SetSSLStatus(status);
   }
 
   if (status) {
     if (!status->mServerCert) {
-      status->mServerCert = nssCert;
+      status->mServerCert = mCert;
     }
 
-    status->mHaveCertErrorBits = PR_TRUE;
+    status->mHaveCertErrorBits = true;
     status->mIsDomainMismatch = collected_errors & nsICertOverrideService::ERROR_MISMATCH;
     status->mIsNotValidAtThisTime = collected_errors & nsICertOverrideService::ERROR_TIME;
     status->mIsUntrusted = collected_errors & nsICertOverrideService::ERROR_UNTRUSTED;
 
     nsSSLIOLayerHelpers::mHostsWithCertErrors->RememberCertHasError(
-      infoObject, status, SECFailure);
+      mInfoObject, status, SECFailure);
   }
 
-  remaining_display_errors = collected_errors;
+  nsDependentCString hostString(mHostname);
+
+  PRInt32 port;
+  mInfoObject->GetPort(&port);
+
+  nsCString hostWithPortString = hostString;
+  hostWithPortString.AppendLiteral(":");
+  hostWithPortString.AppendInt(port);
+
+  NS_ConvertUTF8toUTF16 hostWithPortStringUTF16(hostWithPortString);
+
+  PRUint32 remaining_display_errors = collected_errors;
+
+  nsresult nsrv;
 
   // Enforce Strict-Transport-Security for hosts that are "STS" hosts:
   // connections must be dropped when there are any certificate errors
   // (STS Spec section 7.3).
-
+  bool strictTransportSecurityEnabled = false;
   nsCOMPtr<nsIStrictTransportSecurityService> stss
-    = do_GetService(NS_STSSERVICE_CONTRACTID);
-  nsCOMPtr<nsIStrictTransportSecurityService> proxied_stss;
-
-  nsrv = NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
-                              NS_GET_IID(nsIStrictTransportSecurityService),
-                              stss, NS_PROXY_SYNC,
-                              getter_AddRefs(proxied_stss));
-  NS_ENSURE_SUCCESS(nsrv, SECFailure);
-
-  // now grab the host name to pass to the STS Service
-  nsXPIDLCString hostName;
-  nsrv = infoObject->GetHostName(getter_Copies(hostName));
-  NS_ENSURE_SUCCESS(nsrv, SECFailure);
-
-  bool strictTransportSecurityEnabled;
-  nsrv = proxied_stss->IsStsHost(hostName, &strictTransportSecurityEnabled);
-  NS_ENSURE_SUCCESS(nsrv, SECFailure);
+    = do_GetService(NS_STSSERVICE_CONTRACTID, &nsrv);
+  if (NS_SUCCEEDED(nsrv)) {
+    nsrv = stss->IsStsHost(mHostname, &strictTransportSecurityEnabled);
+  }
+  if (NS_FAILED(nsrv))
+    return; // use default rv and errorCodeToReport
 
   if (!strictTransportSecurityEnabled) {
     nsCOMPtr<nsICertOverrideService> overrideService =
       do_GetService(NS_CERTOVERRIDE_CONTRACTID);
     // it is fine to continue without the nsICertOverrideService
 
     PRUint32 overrideBits = 0;
 
     if (overrideService)
     {
       bool haveOverride;
       bool isTemporaryOverride; // we don't care
 
       nsrv = overrideService->HasMatchingOverride(hostString, port,
-                                                  ix509,
+                                                  mCert,
                                                   &overrideBits,
                                                   &isTemporaryOverride, 
                                                   &haveOverride);
       if (NS_SUCCEEDED(nsrv) && haveOverride) 
       {
         // remove the errors that are already overriden
         remaining_display_errors -= overrideBits;
       }
     }
 
     if (!remaining_display_errors) {
       // all errors are covered by override rules, so let's accept the cert
-      return SECSuccess;
+      PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
+             ("[%p][%p] All errors covered by override rules\n",
+             mFdForLogging, this));
+      mRv = SECSuccess;
+      return;
     }
   } else {
-    PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("Strict-Transport-Security is violated: untrusted transport layer\n"));
+    PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
+           ("[%p][%p] Strict-Transport-Security is violated: untrusted "
+            "transport layer\n", mFdForLogging, this));
   }
 
+  PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
+         ("[%p][%p] Certificate error was not overridden\n",
+         mFdForLogging, this));
+
   // Ok, this is a full stop.
   // First, deliver the technical details of the broken SSL status,
   // giving the caller a chance to suppress the error messages.
 
   bool suppressMessage = false;
 
   // Try to get a nsIBadCertListener2 implementation from the socket consumer.
   nsCOMPtr<nsIInterfaceRequestor> cb;
-  infoObject->GetNotificationCallbacks(getter_AddRefs(cb));
+  mInfoObject->GetNotificationCallbacks(getter_AddRefs(cb));
   if (cb) {
-    nsCOMPtr<nsIInterfaceRequestor> callbacks;
-    NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
-                         NS_GET_IID(nsIInterfaceRequestor),
-                         cb,
-                         NS_PROXY_SYNC,
-                         getter_AddRefs(callbacks));
-
-    nsCOMPtr<nsIBadCertListener2> bcl = do_GetInterface(callbacks);
+    nsCOMPtr<nsIBadCertListener2> bcl = do_GetInterface(cb);
     if (bcl) {
-      nsCOMPtr<nsIBadCertListener2> proxy_bcl;
-      NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
-                           NS_GET_IID(nsIBadCertListener2),
-                           bcl,
-                           NS_PROXY_SYNC,
-                           getter_AddRefs(proxy_bcl));
-      if (proxy_bcl) {
-        nsIInterfaceRequestor *csi = static_cast<nsIInterfaceRequestor*>(infoObject);
-        (void) proxy_bcl->NotifyCertProblem(csi, status, hostWithPortString, 
-                                            &suppressMessage);
-      }
+      nsIInterfaceRequestor *csi = static_cast<nsIInterfaceRequestor*>(mInfoObject);
+      nsrv = bcl->NotifyCertProblem(csi, status, hostWithPortString, &suppressMessage);
     }
   }
 
   nsCOMPtr<nsIRecentBadCertsService> recentBadCertsService = 
     do_GetService(NS_RECENTBADCERTS_CONTRACTID);
 
   if (recentBadCertsService) {
     recentBadCertsService->AddBadCert(hostWithPortStringUTF16, status);
   }
 
   // pick the error code to report by priority
-  PRErrorCode errorCodeToReport = SECSuccess;
+  mErrorCodeToReport = 0;
   if (remaining_display_errors & nsICertOverrideService::ERROR_UNTRUSTED)
-    errorCodeToReport = errorCodeTrust;
+    mErrorCodeToReport = errorCodeTrust;
   else if (remaining_display_errors & nsICertOverrideService::ERROR_MISMATCH)
-    errorCodeToReport = errorCodeMismatch;
+    mErrorCodeToReport = errorCodeMismatch;
   else if (remaining_display_errors & nsICertOverrideService::ERROR_TIME)
-    errorCodeToReport = errorCodeExpired;
-
-  if (!suppressMessage && infoObject->GetExternalErrorReporting()) {
+    mErrorCodeToReport = errorCodeExpired;
+
+  if (!suppressMessage && mInfoObject->GetExternalErrorReporting()) {
     NS_ConvertASCIItoUTF16 hostU(hostString);
     NS_ConvertASCIItoUTF16 hostWithPortU(hostWithPortString);
     nsString formattedString;
-    (void) getInvalidCertErrorMessage(remaining_display_errors,
-                                      errorCodeToReport, errorCodeTrust,
-                                      errorCodeMismatch, errorCodeExpired, hostU,
-                                      hostWithPortU, port, ix509, inss,
-                                      formattedString);
-    infoObject->SetErrorMessage(formattedString.get());
+    getInvalidCertErrorMessage(remaining_display_errors, mErrorCodeToReport,
+                               errorCodeTrust, errorCodeMismatch,
+                               errorCodeExpired, hostU, hostWithPortU, port,
+                               mCert, formattedString);
+    mInfoObject->SetErrorMessage(formattedString.get());
   }
 
-  PR_SetError(errorCodeToReport, 0);
-  return cancel_and_failure(infoObject);
+  mInfoObject->SetCanceled(true);
 }
 
 static PRFileDesc*
 nsSSLIOLayerImportFD(PRFileDesc *fd,
                      nsNSSSocketInfo *infoObject,
                      const char *host,
                      bool anonymousLoad)
 {
