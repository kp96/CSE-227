Index: modules/libpref/src/init/all.js
===================================================================
RCS file: /cvsroot/mozilla/modules/libpref/src/init/all.js,v
retrieving revision 3.689
diff -u -p -8 -r3.689 all.js
--- modules/libpref/src/init/all.js	29 Aug 2007 16:30:32 -0000	3.689
+++ modules/libpref/src/init/all.js	6 Sep 2007 03:22:43 -0000
@@ -491,16 +491,19 @@ pref("javascript.allow.mailnews",       
 pref("javascript.options.strict",           false);
 pref("javascript.options.relimit",          false);
 
 // advanced prefs
 pref("security.enable_java",                true);
 pref("advanced.mailftp",                    false);
 pref("image.animation_mode",                "normal");
 
+// Same-origin policy for file: URIs: 0=self, 1=samedir, 2=subdir, 3=anyfile
+pref("security.fileuri.origin_policy", 0);
+
 // If there is ever a security firedrill that requires
 // us to block certian ports global, this is the pref 
 // to use.  Is is a comma delimited list of port numbers
 // for example:
 //   pref("network.security.ports.banned", "1,2,3,4,5");
 // prevents necko connecting to ports 1-5 unless the protocol
 // overrides.
 
Index: caps/include/nsScriptSecurityManager.h
===================================================================
RCS file: /cvsroot/mozilla/caps/include/nsScriptSecurityManager.h,v
retrieving revision 1.104
diff -u -p -8 -r1.104 nsScriptSecurityManager.h
--- caps/include/nsScriptSecurityManager.h	8 Jul 2007 07:08:06 -0000	1.104
+++ caps/include/nsScriptSecurityManager.h	6 Sep 2007 03:22:43 -0000
@@ -540,35 +540,39 @@ private:
     /**
      * Utility method for comparing two URIs.  For security purposes, two URIs
      * are equivalent if their schemes, hosts, and ports (if any) match.  This
      * method returns true if aSubjectURI and aObjectURI have the same origin,
      * false otherwise.
      */
     PRBool SecurityCompareURIs(nsIURI* aSourceURI, nsIURI* aTargetURI);
 
+    /* encapsulate the file comparison rules */
+    PRBool SecurityCompareFileURIs(nsIURI* aSourceURI, nsIURI* aTargetURI);
+
 #ifdef XPC_IDISPATCH_SUPPORT
     // While this header is included outside of caps, this class isn't 
     // referenced so this should be fine.
     nsresult
     CheckComponentPermissions(JSContext *cx, const nsCID &aCID);
 #endif
 #ifdef DEBUG_CAPS_HACKER
     void
     PrintPolicyDB();
 #endif
 
     // JS strings we need to clean up on shutdown
     static jsval sEnabledID;
 
     inline void
-    JSEnabledPrefChanged(nsISecurityPref* aSecurityPref);
+    ScriptSecurityPrefChanged();
 
     static const char sJSEnabledPrefName[];
     static const char sJSMailEnabledPrefName[];
+    static const char sFileOriginPolicyPrefName[];
 
     nsObjectHashtable* mOriginToPolicyMap;
     DomainPolicy* mDefaultPolicy;
     nsObjectHashtable* mCapabilities;
 
     nsCOMPtr<nsIPrefBranch> mPrefBranch;
     nsCOMPtr<nsISecurityPref> mSecurityPref;
     nsCOMPtr<nsIPrincipal> mSystemPrincipal;
@@ -578,16 +582,29 @@ private:
     PRPackedBool mIsJavaScriptEnabled;
     PRPackedBool mIsMailJavaScriptEnabled;
     PRPackedBool mIsWritingPrefs;
     PRPackedBool mPolicyPrefsChanged;
 #ifdef XPC_IDISPATCH_SUPPORT    
     PRPackedBool mXPCDefaultGrantAll;
     static const char sXPCDefaultGrantAllName[];
 #endif
+    PRInt32 mFileURIOriginPolicy;
 
     static nsIIOService    *sIOService;
     static nsIXPConnect    *sXPConnect;
     static nsIStringBundle *sStrBundle;
     static JSRuntime       *sRuntime;
 };
 
+// Levels for file: URI same-origin policy:
+//   self:        same-origin only with itself
+//   samedir:     same-origin with files having the same path
+//   subdir:      same-origin with files having longer paths (asymetric)
+//   anyfile:     same-origin with any other file: URI (but not directories)
+//   traditional: any local file, any directory
+#define FILEURI_SOP_SELF        0
+#define FILEURI_SOP_SAMEDIR     1
+#define FILEURI_SOP_SUBDIR      2
+#define FILEURI_SOP_ANYFILE     3
+#define FILEURI_SOP_TRADITIONAL 4
+
 #endif // nsScriptSecurityManager_h__
Index: caps/src/nsScriptSecurityManager.cpp
===================================================================
RCS file: /cvsroot/mozilla/caps/src/nsScriptSecurityManager.cpp,v
retrieving revision 1.322
diff -u -p -8 -r1.322 nsScriptSecurityManager.cpp
--- caps/src/nsScriptSecurityManager.cpp	31 Aug 2007 00:52:59 -0000	1.322
+++ caps/src/nsScriptSecurityManager.cpp	6 Sep 2007 03:22:43 -0000
@@ -60,16 +60,17 @@
 #include "nsIXPConnect.h"
 #include "nsIXPCSecurityManager.h"
 #include "nsTextFormatter.h"
 #include "nsIStringBundle.h"
 #include "nsNetUtil.h"
 #include "nsIProperties.h"
 #include "nsDirectoryServiceDefs.h"
 #include "nsIFile.h"
+#include "nsIFileURL.h"
 #include "nsIZipReader.h"
 #include "nsIJAR.h"
 #include "nsIPluginInstance.h"
 #include "nsIXPConnect.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsPIDOMWindow.h"
 #include "nsIDocShell.h"
 #include "nsIDocShellTreeItem.h"
@@ -263,105 +264,176 @@ nsScriptSecurityManager::SecurityCompare
 
     if (!aTargetURI || !aSourceURI) 
     {
         return PR_FALSE;
     }
 
     // If either URI is a nested URI, get the base URI
     nsCOMPtr<nsIURI> sourceBaseURI = NS_GetInnermostURI(aSourceURI);
-    
     nsCOMPtr<nsIURI> targetBaseURI = NS_GetInnermostURI(aTargetURI);
 
     if (!sourceBaseURI || !targetBaseURI)
         return PR_FALSE;
 
     // Compare schemes
     nsCAutoString targetScheme;
-    nsresult rv = targetBaseURI->GetScheme(targetScheme);
-    nsCAutoString sourceScheme;
-    if (NS_SUCCEEDED(rv))
-        rv = sourceBaseURI->GetScheme(sourceScheme);
-    if (NS_FAILED(rv) || !targetScheme.Equals(sourceScheme)) {
+    PRBool sameScheme = PR_FALSE;
+    if (NS_FAILED( targetBaseURI->GetScheme(targetScheme) ) ||
+        NS_FAILED( sourceBaseURI->SchemeIs(targetScheme.get(), &sameScheme) ) ||
+        !sameScheme)
+    {
+        // Not same-origin if schemes differ
         return PR_FALSE;
     }
-    
+
+    // special handling for file: URIs
     if (targetScheme.EqualsLiteral("file"))
-    {
-        // All file: urls are considered to have the same origin.
-        return  PR_TRUE;
-    }
+        return SecurityCompareFileURIs( sourceBaseURI, targetBaseURI );
 
+    // Special handling for mailnews schemes
     if (targetScheme.EqualsLiteral("imap") ||
         targetScheme.EqualsLiteral("mailbox") ||
         targetScheme.EqualsLiteral("news"))
     {
         // Each message is a distinct trust domain; use the 
         // whole spec for comparison
         nsCAutoString targetSpec;
-        if (NS_FAILED(targetBaseURI->GetSpec(targetSpec)))
-            return PR_FALSE;
         nsCAutoString sourceSpec;
-        if (NS_FAILED(sourceBaseURI->GetSpec(sourceSpec)))
-            return PR_FALSE;
-        return targetSpec.Equals(sourceSpec);
+        return ( NS_SUCCEEDED( targetBaseURI->GetSpec(targetSpec) ) &&
+                 NS_SUCCEEDED( sourceBaseURI->GetSpec(sourceSpec) ) &&
+                 targetSpec.Equals(sourceSpec) );
     }
 
     // Compare hosts
     nsCAutoString targetHost;
-    rv = targetBaseURI->GetHost(targetHost);
     nsCAutoString sourceHost;
-    if (NS_SUCCEEDED(rv))
-        rv = sourceBaseURI->GetHost(sourceHost);
-    if (NS_FAILED(rv) ||
-        !targetHost.Equals(sourceHost, nsCaseInsensitiveCStringComparator())) {
+    if (NS_FAILED( targetBaseURI->GetHost(targetHost) ) ||
+        NS_FAILED( sourceBaseURI->GetHost(sourceHost) ) ||
+        !targetHost.Equals(sourceHost, nsCaseInsensitiveCStringComparator()))
+    {
+        // Not same-origin if hosts differ
         return PR_FALSE;
     }
-    
+
     // Compare ports
     PRInt32 targetPort;
-    rv = targetBaseURI->GetPort(&targetPort);
+    nsresult rv = targetBaseURI->GetPort(&targetPort);
     PRInt32 sourcePort;
     if (NS_SUCCEEDED(rv))
         rv = sourceBaseURI->GetPort(&sourcePort);
     PRBool result = NS_SUCCEEDED(rv) && targetPort == sourcePort;
     // If the port comparison failed, see if either URL has a
     // port of -1. If so, replace -1 with the default port
     // for that scheme.
     if (NS_SUCCEEDED(rv) && !result &&
         (sourcePort == -1 || targetPort == -1))
     {
         NS_ENSURE_STATE(sIOService);
 
-        NS_ASSERTION(targetScheme.Equals(sourceScheme),
-                     "Schemes should be equal here");
-                    
         PRInt32 defaultPort;
         nsCOMPtr<nsIProtocolHandler> protocolHandler;
-        rv = sIOService->GetProtocolHandler(sourceScheme.get(),
+        rv = sIOService->GetProtocolHandler(targetScheme.get(),
                                             getter_AddRefs(protocolHandler));
         if (NS_FAILED(rv))
         {
             return PR_FALSE;
         }
-                    
+
         rv = protocolHandler->GetDefaultPort(&defaultPort);
         if (NS_FAILED(rv) || defaultPort == -1)
             return PR_FALSE; // No default port for this scheme
 
         if (sourcePort == -1)
             sourcePort = defaultPort;
         else if (targetPort == -1)
             targetPort = defaultPort;
         result = targetPort == sourcePort;
     }
 
     return result;
 }
 
+// helper function for SecurityCompareURIs
+PRBool
+nsScriptSecurityManager::SecurityCompareFileURIs(nsIURI* aSourceURI,
+                                                 nsIURI* aTargetURI)
+{
+    // in traditional unsafe behavior all files are the same origin
+    if (mFileURIOriginPolicy == FILEURI_SOP_TRADITIONAL)
+        return PR_TRUE;
+
+
+    // Check simplest and default FILEURI_SOP_SELF case first:
+    // If they're equal or if the policy says they must be, we're done
+    PRBool filesAreEqual = PR_FALSE;
+    if (NS_FAILED( aSourceURI->Equals(aTargetURI, &filesAreEqual) ))
+        return PR_FALSE;
+    if (filesAreEqual || mFileURIOriginPolicy == FILEURI_SOP_SELF)
+        return filesAreEqual;
+
+
+    // disallow access to directory listings (bug 209234)
+    PRBool targetIsDir = PR_TRUE;
+    nsCOMPtr<nsIFile> targetFile;
+    nsCOMPtr<nsIFileURL> targetFileURL( do_QueryInterface(aTargetURI) );
+
+    if (!targetFileURL ||
+        NS_FAILED( targetFileURL->GetFile(getter_AddRefs(targetFile)) ) ||
+        NS_FAILED( targetFile->IsDirectory(&targetIsDir) ) ||
+        targetIsDir)
+    {
+        return PR_FALSE;
+    }
+
+
+    // For policy ANYFILE we're done
+    if (mFileURIOriginPolicy == FILEURI_SOP_ANYFILE)
+        return PR_TRUE;
+
+
+    // source parent directory is needed for remaining policies
+    nsCOMPtr<nsIFile> sourceFile;
+    nsCOMPtr<nsIFile> sourceParent;
+    nsCOMPtr<nsIFileURL> sourceFileURL( do_QueryInterface(aSourceURI) );
+
+    if (!sourceFileURL ||
+        NS_FAILED( sourceFileURL->GetFile(getter_AddRefs(sourceFile)) ) ||
+        NS_FAILED( sourceFile->GetParent(getter_AddRefs(sourceParent)) ) ||
+        !sourceParent)
+    {
+        // unexpected error
+        return PR_FALSE;
+    }
+
+    // check remaining policies
+    if (mFileURIOriginPolicy == FILEURI_SOP_SAMEDIR)
+    {
+        // file: URIs in the same directory have the same origin
+        PRBool sameParent = PR_FALSE;
+        nsCOMPtr<nsIFile> targetParent;
+        if (NS_FAILED( targetFile->GetParent(getter_AddRefs(targetParent)) ) ||
+            NS_FAILED( sourceParent->Equals(targetParent, &sameParent) ))
+            return PR_FALSE;
+        return sameParent;
+    }
+
+    if (mFileURIOriginPolicy == FILEURI_SOP_SUBDIR)
+    {
+        // file: URIs can access files in the same or lower directories
+        PRBool isChild = PR_FALSE;
+        if (NS_FAILED( sourceParent->Contains(targetFile, PR_TRUE, &isChild) ))
+            return PR_FALSE;
+        return isChild;
+    }
+
+    NS_NOTREACHED("invalid file uri policy setting");
+    return PR_FALSE;
+}
+
 NS_IMETHODIMP
 nsScriptSecurityManager::GetChannelPrincipal(nsIChannel* aChannel,
                                              nsIPrincipal** aPrincipal)
 {
     NS_PRECONDITION(aChannel, "Must have channel!");
     nsCOMPtr<nsISupports> owner;
     aChannel->GetOwner(getter_AddRefs(owner));
     if (owner) {
@@ -3066,26 +3138,29 @@ NS_IMETHODIMP
 nsScriptSecurityManager::Observe(nsISupports* aObject, const char* aTopic,
                                  const PRUnichar* aMessage)
 {
     nsresult rv = NS_OK;
     NS_ConvertUTF16toUTF8 messageStr(aMessage);
     const char *message = messageStr.get();
 
     static const char jsPrefix[] = "javascript.";
-    if((PL_strncmp(message, jsPrefix, sizeof(jsPrefix)-1) == 0)
-#ifdef XPC_IDISPATCH_SUPPORT
-        || (PL_strcmp(message, sXPCDefaultGrantAllName) == 0)
-#endif
-        )
-        JSEnabledPrefChanged(mSecurityPref);
-    if(PL_strncmp(message, sPolicyPrefix, sizeof(sPolicyPrefix)-1) == 0)
-        mPolicyPrefsChanged = PR_TRUE; // This will force re-initialization of the pref table
-    else if((PL_strncmp(message, sPrincipalPrefix, sizeof(sPrincipalPrefix)-1) == 0) &&
-            !mIsWritingPrefs)
+    static const char securityPrefix[] = "security.";
+    if ((PL_strncmp(message, jsPrefix, sizeof(jsPrefix)-1) == 0) ||
+        (PL_strncmp(message, securityPrefix, sizeof(securityPrefix)-1) == 0) )
+    {
+        ScriptSecurityPrefChanged();
+    }
+    else if (PL_strncmp(message, sPolicyPrefix, sizeof(sPolicyPrefix)-1) == 0)
+    {
+        // This will force re-initialization of the pref table
+        mPolicyPrefsChanged = PR_TRUE;
+    }
+    else if ((PL_strncmp(message, sPrincipalPrefix, sizeof(sPrincipalPrefix)-1) == 0) &&
+             !mIsWritingPrefs)
     {
         static const char id[] = "id";
         char* lastDot = PL_strrchr(message, '.');
         //-- This check makes sure the string copy below doesn't overwrite its bounds
         if(PL_strlen(lastDot) >= sizeof(id))
         {
             PL_strcpy(lastDot + 1, id);
             const char** idPrefArray = (const char**)&message;
@@ -3100,20 +3175,21 @@ nsScriptSecurityManager::Observe(nsISupp
 /////////////////////////////////////////////
 nsScriptSecurityManager::nsScriptSecurityManager(void)
     : mOriginToPolicyMap(nsnull),
       mDefaultPolicy(nsnull),
       mCapabilities(nsnull),
       mIsJavaScriptEnabled(PR_FALSE),
       mIsMailJavaScriptEnabled(PR_FALSE),
       mIsWritingPrefs(PR_FALSE),
-      mPolicyPrefsChanged(PR_TRUE)
+      mPolicyPrefsChanged(PR_TRUE),
 #ifdef XPC_IDISPATCH_SUPPORT
-      ,mXPCDefaultGrantAll(PR_FALSE)
+      mXPCDefaultGrantAll(PR_FALSE),
 #endif
+      mFileURIOriginPolicy(FILEURI_SOP_SELF)
 {
     NS_ASSERTION(sizeof(long) == sizeof(void*), "long and void* have different lengths on this platform. This may cause a security failure.");
     mPrincipals.Init(31);
 }
 
 
 nsresult nsScriptSecurityManager::Init()
 {
@@ -3692,32 +3768,38 @@ nsScriptSecurityManager::InitPrincipals(
     }
     return NS_OK;
 }
 
 const char nsScriptSecurityManager::sJSEnabledPrefName[] =
     "javascript.enabled";
 const char nsScriptSecurityManager::sJSMailEnabledPrefName[] =
     "javascript.allow.mailnews";
+const char nsScriptSecurityManager::sFileOriginPolicyPrefName[] =
+    "security.fileuri.origin_policy";
 #ifdef XPC_IDISPATCH_SUPPORT
 const char nsScriptSecurityManager::sXPCDefaultGrantAllName[] =
     "security.classID.allowByDefault";
 #endif
 
 inline void
-nsScriptSecurityManager::JSEnabledPrefChanged(nsISecurityPref* aSecurityPref)
+nsScriptSecurityManager::ScriptSecurityPrefChanged()
 {
     PRBool temp;
     nsresult rv = mSecurityPref->SecurityGetBoolPref(sJSEnabledPrefName, &temp);
     // JavaScript defaults to enabled in failure cases.
     mIsJavaScriptEnabled = NS_FAILED(rv) || temp;
 
     rv = mSecurityPref->SecurityGetBoolPref(sJSMailEnabledPrefName, &temp);
-    // JavaScript in Mail defaults to enabled in failure cases.
-    mIsMailJavaScriptEnabled = NS_FAILED(rv) || temp;
+    // JavaScript in Mail defaults to disabled in failure cases.
+    mIsMailJavaScriptEnabled = NS_SUCCEEDED(rv) && temp;
+
+    PRInt32 policy;
+    rv = mSecurityPref->SecurityGetIntPref(sFileOriginPolicyPrefName, &policy);
+    mFileURIOriginPolicy = NS_SUCCEEDED(rv) ? policy : FILEURI_SOP_SELF;
 
 #ifdef XPC_IDISPATCH_SUPPORT
     rv = mSecurityPref->SecurityGetBoolPref(sXPCDefaultGrantAllName, &temp);
     // Granting XPC Priveleges defaults to disabled in failure cases.
     mXPCDefaultGrantAll = NS_SUCCEEDED(rv) && temp;
 #endif
 }
 
@@ -3730,20 +3812,21 @@ nsScriptSecurityManager::InitPrefs()
     rv = prefService->GetBranch(nsnull, getter_AddRefs(mPrefBranch));
     NS_ENSURE_SUCCESS(rv, rv);
     nsCOMPtr<nsIPrefBranch2> prefBranchInternal(do_QueryInterface(mPrefBranch, &rv));
     NS_ENSURE_SUCCESS(rv, rv);
     mSecurityPref = do_QueryInterface(mPrefBranch, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
 
     // Set the initial value of the "javascript.enabled" prefs
-    JSEnabledPrefChanged(mSecurityPref);
+    ScriptSecurityPrefChanged();
     // set observer callbacks in case the value of the prefs change
     prefBranchInternal->AddObserver(sJSEnabledPrefName, this, PR_FALSE);
     prefBranchInternal->AddObserver(sJSMailEnabledPrefName, this, PR_FALSE);
+    prefBranchInternal->AddObserver(sFileOriginPolicyPrefName, this, PR_FALSE);
 #ifdef XPC_IDISPATCH_SUPPORT
     prefBranchInternal->AddObserver(sXPCDefaultGrantAllName, this, PR_FALSE);
 #endif
     PRUint32 prefCount;
     char** prefNames;
 
     // Set a callback for policy pref changes
     prefBranchInternal->AddObserver(sPolicyPrefix, this, PR_FALSE);
