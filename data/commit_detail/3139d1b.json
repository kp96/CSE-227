{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas3139d1b\""},"diff":"\"3139d1b Fix some nasty bugs with the way js generators were being used.  Have the snapshot [de]serialized to the profile\\ndiff --git a/services/sync/nsBookmarksSyncService.js b/services/sync/nsBookmarksSyncService.js\\nindex 4337781..73a4620 100644\\n--- a/services/sync/nsBookmarksSyncService.js\\n+++ b/services/sync/nsBookmarksSyncService.js\\n@@ -39,6 +39,15 @@ const Ci = Components.interfaces;\\n const Cr = Components.results;\\n const Cu = Components.utils;\\n \\n+const MODE_RDONLY   = 0x01;\\n+const MODE_WRONLY   = 0x02;\\n+const MODE_CREATE   = 0x08;\\n+const MODE_APPEND   = 0x10;\\n+const MODE_TRUNCATE = 0x20;\\n+\\n+const PERMS_FILE      = 0644;\\n+const PERMS_DIRECTORY = 0755;\\n+\\n Cu.import(\\\"resource://gre/modules/XPCOMUtils.jsm\\\");\\n \\n function BookmarksSyncService() { this._init(); }\\n@@ -101,6 +110,59 @@ BookmarksSyncService.prototype = {\\n     catch (ex) { /* use defaults */ }\\n     LOG(\\\"Bookmarks login server: \\\" + serverURL);\\n     this._dav = new DAVCollection(serverURL);\\n+    this._readSnapshot();\\n+  },\\n+\\n+  _saveSnapshot: function BSS__saveSnapshot() {\\n+    let dirSvc = Cc[\\\"@mozilla.org/file/directory_service;1\\\"].\\n+      getService(Ci.nsIProperties);\\n+\\n+    let file = dirSvc.get(\\\"ProfD\\\", Ci.nsIFile);\\n+    file.append(\\\"bm-sync-snapshot.json\\\");\\n+    file.QueryInterface(Ci.nsILocalFile);\\n+\\n+    if (!file.exists())\\n+      file.create(file.NORMAL_FILE_TYPE, PERMS_FILE);\\n+\\n+    let fos = Cc[\\\"@mozilla.org/network/file-output-stream;1\\\"].\\n+      createInstance(Ci.nsIFileOutputStream);\\n+    let flags = MODE_WRONLY | MODE_CREATE | MODE_TRUNCATE;\\n+    fos.init(file, flags, PERMS_FILE, 0);\\n+\\n+    let out = {version: this._snapshotVersion, snapshot: this._snapshot};\\n+    out = uneval(out);\\n+    fos.write(out, out.length);\\n+    fos.flush();\\n+    fos.close();\\n+  },\\n+\\n+  _readSnapshot: function BSS__readSnapshot() {\\n+    let dirSvc = Cc[\\\"@mozilla.org/file/directory_service;1\\\"].\\n+      getService(Ci.nsIProperties);\\n+\\n+    let file = dirSvc.get(\\\"ProfD\\\", Ci.nsIFile);\\n+    file.append(\\\"bm-sync-snapshot.json\\\");\\n+\\n+    if (!file.exists())\\n+      return;\\n+\\n+    let fis = Cc[\\\"@mozilla.org/network/file-input-stream;1\\\"].\\n+      createInstance(Ci.nsIFileInputStream);\\n+    fis.init(file, MODE_RDONLY, PERMS_FILE, 0);\\n+    fis.QueryInterface(Ci.nsILineInputStream);\\n+\\n+    let json = \\\"\\\";\\n+    while (fis.available()) {\\n+      let ret = {};\\n+      fis.readLine(ret);\\n+      json += ret.value;\\n+    }\\n+    json = eval(json);\\n+\\n+    if (json.snapshot && json.version) {\\n+      this._snapshot = json.snapshot;\\n+      this._snapshotVersion = json.version;\\n+    }\\n   },\\n \\n   _wrapNode: function BSS__wrapNode(node) {\\n@@ -319,9 +381,8 @@ BookmarksSyncService.prototype = {\\n \\n     for (let i = 0; i < listA.length; i++) {\\n \\n-      // Yield to main loop\\n       this._timer.initWithCallback(listener, 0, this._timer.TYPE_ONE_SHOT);\\n-      yield;\\n+      yield; // Yield to main loop\\n \\n       for (let j = 0; j < listB.length; j++) {\\n         if (this._deepEquals(listA[i], listB[j])) {\\n@@ -342,9 +403,8 @@ BookmarksSyncService.prototype = {\\n \\n     for (let i = 0; i < listA.length; i++) {\\n \\n-      // Yield to main loop\\n       this._timer.initWithCallback(listener, 0, this._timer.TYPE_ONE_SHOT);\\n-      yield;\\n+      yield; // Yield to main loop\\n \\n       for (let j = 0; j < listB.length; j++) {\\n         if (this._conflicts(listA[i], listB[j]) ||\\n@@ -372,7 +432,13 @@ BookmarksSyncService.prototype = {\\n     }\\n \\n     this._timer = null;\\n-    onComplete({propagations: propagations, conflicts: conflicts});\\n+    let ret = {propagations: propagations, conflicts: conflicts};\\n+    this._generatorDone(onComplete, ret);\\n+\\n+    // shutdown protocol\\n+    let cookie = yield;\\n+    if (cookie != \\\"generator shutdown\\\")\\n+      LOG(\\\"_reconcile: Error: generator not properly shut down.\\\")\\n   },\\n \\n   _applyCommandsToObj: function BSS__applyCommandsToObj(commands, obj) {\\n@@ -547,8 +613,10 @@ BookmarksSyncService.prototype = {\\n       LOG(\\\"local json: \\\" + uneval(localJson));\\n \\n       // 1) Fetch server deltas\\n-      asyncRun(bind2(this, this._getServerData), handlers['complete'], localJson);\\n-      var server = yield;\\n+      let gsd_gen = this._getServerData(handlers['complete'], localJson);\\n+      gsd_gen.next(); // must initialize before sending\\n+      gsd_gen.send(gsd_gen);\\n+      let server = yield;\\n \\n       LOG(\\\"server: \\\" + uneval(server));\\n       if (server['status'] == 2) {\\n@@ -574,63 +642,79 @@ BookmarksSyncService.prototype = {\\n \\t  \\n       // 3) Reconcile client/server deltas and generate new deltas for them.\\n \\n-      var propagations = [server['updates'], localUpdates];\\n-      var conflicts = [[],[]];\\n-\\n       LOG(\\\"Reconciling updates\\\");\\n-      asyncRun(bind2(this, this._reconcile),\\n-               handlers['complete'], [localUpdates, server.updates]);\\n+      let callback = function(retval) { continueGenerator(generator, retval); };\\n+      let rec_gen = this._reconcile(callback, [localUpdates, server.updates]);\\n+      rec_gen.next(); // must initialize before sending\\n+      rec_gen.send(rec_gen);\\n       let ret = yield;\\n-      propagations = ret.propagations;\\n-      conflicts = ret.conflicts;\\n-\\n-      LOG(\\\"Propagations: \\\" + uneval(propagations) + \\\"\\\\n\\\");\\n-      LOG(\\\"Conflicts: \\\" + uneval(conflicts) + \\\"\\\\n\\\");\\n-\\t  \\n-      this._snapshotVersion = server['version'];\\n-\\n-      if (!((propagations[0] && propagations[0].length) ||\\n-            (propagations[1] && propagations[1].length) ||\\n-            (conflicts &&\\n-             (conflicts[0] && conflicts[0].length) ||\\n-             (conflicts[1] && conflicts[1].length)))) {\\n-        this._snapshot = this._wrapNode(localBookmarks);\\n+      // FIXME: Need to come up with a closing protocol for generators\\n+      rec_gen.close();\\n+\\n+      let clientChanges = [];\\n+      let serverChanges = [];\\n+      let clientConflicts = [];\\n+      let serverConflicts = [];\\n+\\n+      if (ret.propagations[0])\\n+        clientChanges = ret.propagations[0];\\n+      if (ret.propagations[1])\\n+        serverChanges = ret.propagations[1];\\n+\\n+      if (ret.conflicts && ret.conflicts[0])\\n+        clientConflicts = ret.conflicts[0];\\n+      if (ret.conflicts && ret.conflicts[1])\\n+        serverConflicts = ret.conflicts[1];\\n+\\n+      LOG(\\\"Changes for client: \\\" + uneval(clientChanges));\\n+      LOG(\\\"Changes for server: \\\" + uneval(serverChanges));\\n+      LOG(\\\"Client conflicts: \\\" + uneval(clientConflicts));\\n+      LOG(\\\"Server conflicts: \\\" + uneval(serverConflicts));\\n+\\n+      if (!(clientChanges.length || serverChanges.length ||\\n+            clientConflicts.length || serverConflicts.length)) {\\n         LOG(\\\"Sync complete (2): no changes needed on client or server\\\");\\n+        this._snapshot = this._wrapNode(localBookmarks);\\n+        this._snapshotVersion = server['version'];\\n+        this._saveSnapshot();\\n         return;\\n       }\\n \\n-      if (conflicts && conflicts[0] && conflicts[0].length) {\\n-        LOG(\\\"\\\\nWARNING: Conflicts found, but we don't resolve conflicts yet!\\\\n\\\");\\n-        LOG(\\\"Conflicts(1) \\\" + uneval(conflicts[0]));\\n-      }\\n-\\n-      if (conflicts && conflicts[1] && conflicts[1].length) {\\n+      if (clientConflicts.length || serverConflicts.length) {\\n         LOG(\\\"\\\\nWARNING: Conflicts found, but we don't resolve conflicts yet!\\\\n\\\");\\n-        LOG(\\\"Conflicts(2) \\\" + uneval(conflicts[1]));\\n       }\\n \\n       // 3.1) Apply server changes to local store\\n-      if (propagations[0] && propagations[0].length) {\\n+      if (clientChanges.length) {\\n         LOG(\\\"Applying changes locally\\\");\\n+        // Note that we need to need to apply client changes to the\\n+        // current tree, not the saved snapshot\\n+        this._snapshot = this._applyCommandsToObj(clientChanges,\\n+                                                  this._wrapNode(localBookmarks));\\n+        this._snapshotVersion = server['version'];\\n+        this._applyCommands(clientChanges);\\n+        // FIXME: should wrapNode to a separate variable and make sure\\n+        // that snapshot -> that is an empty diff.\\n         this._snapshot = this._wrapNode(localBookmarks);\\n-        propagations[0] = this._applyCommandsToObj(this._snapshot, propagations[0]);\\n-        this._applyCommands(propagations[0]);\\n-        this._snapshot = this._wrapNode(localBookmarks);\\n+        this._saveSnapshot();\\n       }\\n \\n       // 3.2) Append server delta to the delta file and upload\\n-      if (propagations[1] && propagations[1].length) {\\n+      if (serverChanges.length) {\\n         LOG(\\\"Uploading changes to server\\\");\\n         this._snapshot = this._wrapNode(localBookmarks);\\n-        this._snapshotVersion++;\\n-        server['deltas'][this._snapshotVersion] = propagations[1];\\n+        this._snapshotVersion = server['version'] + 1;\\n+        server['deltas'][this._snapshotVersion] = serverChanges;\\n         this._dav.PUT(\\\"bookmarks.delta\\\", uneval(server['deltas']), handlers);\\n         data = yield;\\n \\n-        if (data.target.status >= 200 || data.target.status < 300)\\n+        if (data.target.status >= 200 || data.target.status < 300) {\\n           LOG(\\\"Successfully updated deltas on server\\\");\\n-        else\\n+          this._saveSnapshot();\\n+        } else {\\n+          // FIXME: revert snapshot here?\\n           LOG(\\\"Error: could not update deltas on server\\\");\\n+        }\\n       }\\n       LOG(\\\"Sync complete\\\");\\n     } finally {\\n@@ -710,8 +794,10 @@ BookmarksSyncService.prototype = {\\n       } else {\\n         LOG(\\\"Server delta can't update from our snapshot version, getting full file\\\");\\n         // generate updates from full local->remote snapshot diff\\n-        asyncRun(bind2(this, this._getServerUpdatesFull),\\n-                 handlers['complete'], localJson);\\n+        let gsdf_gen = this._getServerUpdatesFull(handlers['complete'],\\n+                                                  localJson);\\n+        gsdf_gen.next(); // must initialize before sending\\n+        gsdf_gen.send(gsdf_gen);\\n         data = yield;\\n         if (data.status == 2) {\\n           // we have a delta file but no snapshot on the server.  bad.\\n@@ -724,7 +810,6 @@ BookmarksSyncService.prototype = {\\n         tmp = this._applyCommandsToObj(data.updates, tmp);\\n \\n         // fixme: this is duplicated from above, need to do some refactoring\\n-\\n         var keys = [];\\n         for (var v in ret.deltas) {\\n           if (v > this._snapshotVersion)\\n@@ -750,7 +835,9 @@ BookmarksSyncService.prototype = {\\n     case 404:\\n       LOG(\\\"Server has no delta file.  Getting full bookmarks file from server\\\");\\n       // generate updates from full local->remote snapshot diff\\n-      asyncRun(bind2(this, this._getServerUpdatesFull), handlers['complete'], localJson);\\n+      let gsdf_gen = this._getServerUpdatesFull(handlers['complete'], localJson);\\n+      gsdf_gen.next(); // must initialize before sending\\n+      gsdf_gen.send(gsdf_gen);\\n       ret = yield;\\n       ret.deltas = {};\\n       break;\\n@@ -758,12 +845,12 @@ BookmarksSyncService.prototype = {\\n       LOG(\\\"Could not get bookmarks.delta: unknown HTTP status code \\\" + data.target.status);\\n       break;\\n     }\\n-    onComplete(ret);\\n+    this._generatorDone(onComplete, ret)\\n   },\\n \\n   _getServerUpdatesFull: function BSS__getServerUpdatesFull(onComplete, localJson) {\\n-    var generator = yield;\\n-    var handlers = this._handlersForGenerator(generator);\\n+    let generator = yield;\\n+    let handlers = this._handlersForGenerator(generator);\\n \\n     var ret = {status: -1, version: -1, updates: null};\\n \\n@@ -797,16 +884,36 @@ BookmarksSyncService.prototype = {\\n       LOG(\\\"Could not get bookmarks.json: unknown HTTP status code \\\" + data.target.status);\\n       break;\\n     }\\n-    onComplete(ret);\\n+    this._generatorDone(onComplete, ret);\\n   },\\n \\n   _handlersForGenerator: function BSS__handlersForGenerator(generator) {\\n-    var h = {load: bind2(this, function(event) { continueGenerator(generator, event); }),\\n-             error: bind2(this, function(event) { LOG(\\\"Request failed: \\\" + uneval(event)); })};\\n+    var h = {load: bind2(this, function(data) { continueGenerator(generator, data); }),\\n+             error: bind2(this, function(data) { LOG(\\\"Request failed: \\\" + uneval(data)); })};\\n     h['complete'] = h['load'];\\n     return h;\\n   },\\n \\n+  // generators called using asyncRun can't simply call the callback\\n+  // with the return value, since that would cause the calling\\n+  // function to end up running (after the yield) from inside the\\n+  // generator.  Instead, generators can call this method which sets\\n+  // up a timer to call the callback from a timer (and cleans up the\\n+  // timer to avoid leaks).\\n+  _generatorDone: function BSS__generatorDone(callback, retval) {\\n+    if (this._timer)\\n+      throw \\\"Called generatorDone when there is a timer already set.\\\"\\n+\\n+    let cb = bind2(this, function(event) {\\n+      this._timer = null;\\n+      callback(retval);\\n+    });\\n+\\n+    this._timer = Cc[\\\"@mozilla.org/timer;1\\\"].createInstance(Ci.nsITimer);\\n+    this._timer.initWithCallback(new EventListener(cb),\\n+                                 0, this._timer.TYPE_ONE_SHOT);\\n+  },\\n+\\n   _onLogin: function BSS__onLogin(event) {\\n     LOG(\\\"Bookmarks sync server: \\\" + this._dav.baseURL);\\n     this._os.notifyObservers(null, \\\"bookmarks-sync:login\\\", \\\"\\\");\\n@@ -829,7 +936,11 @@ BookmarksSyncService.prototype = {\\n \\n   // nsIBookmarksSyncService\\n \\n-  sync: function BSS_sync() { asyncRun(bind2(this, this._doSync)); },\\n+  sync: function BSS_sync() {\\n+    let sync_gen = this._doSync();\\n+    sync_gen.next(); // must initialize before sending\\n+    sync_gen.send(sync_gen);\\n+  },\\n \\n   login: function BSS_login() {\\n     this._dav.login({load: bind2(this, this._onLogin),\\n@@ -865,16 +976,12 @@ function bind2(object, method) {\\n   return function innerBind() { return method.apply(object, arguments); }\\n }\\n \\n-function asyncRun(func, handler, data) {\\n-  var generator = func(handler, data);\\n-  generator.next();\\n-  generator.send(generator);\\n-}\\n+\\n \\n function continueGenerator(generator, data) {\\n   try { generator.send(data); }\\n   catch (e) {\\n-    generator.close();\\n+    LOG(\\\"continueGenerator exception! - \\\" + e);\\n     if (e instanceof StopIteration)\\n       generator = null;\\n     else\\n\""}