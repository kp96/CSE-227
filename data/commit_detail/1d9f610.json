{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas1d9f610\""},"diff":"\"1d9f610 fix for bug #389491:  have url bar autocomplete do a case insensitive search against both url and title with results orderded by a combination of last visited and visit count also includes fixes for bugs: #383672: after visiting http://cheese.livejournal.com/, typing livejournal in the urlbar should suggest http://cheese.livejournal.com/ #392141: strip trailing / leading whitespace before doing url bar autocomplete #391887: typing \\\"https://\\\" no longer drops down a list of https sites #390404: javascript: urls (and other urls) that I didn't type or click on are in url bar when I autocomplete #385033: URLBar dropdown hangs and eats keystrokes when typing #373256: URL/location bar autocomplete slowness (sqlite database doesn't seem to be cached) r=dietrich\\ndiff --git a/browser/themes/pinstripe/browser/browser.css b/browser/themes/pinstripe/browser/browser.css\\nindex dceb47e..831b8de 100755\\n--- a/browser/themes/pinstripe/browser/browser.css\\n+++ b/browser/themes/pinstripe/browser/browser.css\\n@@ -972,6 +972,11 @@ statusbarpanel#statusbar-display {\\n   height: 16px;\\n }\\n \\n+.autocomplete-treebody::-moz-tree-image(bookmark, treecolAutoCompleteValue) {\\n+  width: 16px;\\n+  height: 16px;\\n+}\\n+\\n .autocomplete-treebody::-moz-tree-cell-text(treecolAutoCompleteComment) {\\n   color: #555566;\\n }\\ndiff --git a/browser/themes/winstripe/browser/browser.css b/browser/themes/winstripe/browser/browser.css\\nindex 2284892..0b76a18 100644\\n--- a/browser/themes/winstripe/browser/browser.css\\n+++ b/browser/themes/winstripe/browser/browser.css\\n@@ -965,6 +965,11 @@ statusbarpanel#statusbar-display {\\n   height: 16px;\\n }\\n \\n+.autocomplete-treebody::-moz-tree-image(bookmark, treecolAutoCompleteValue) {\\n+  width: 16px;\\n+  height: 16px;\\n+}\\n+\\n .autocomplete-treebody::-moz-tree-cell-text(treecolAutoCompleteComment) {\\n   color: #555566;\\n }\\ndiff --git a/toolkit/components/places/src/nsNavHistory.cpp b/toolkit/components/places/src/nsNavHistory.cpp\\nindex 8303402..4258425 100644\\n--- a/toolkit/components/places/src/nsNavHistory.cpp\\n+++ b/toolkit/components/places/src/nsNavHistory.cpp\\n@@ -221,8 +221,8 @@ const PRInt32 nsNavHistory::kGetInfoIndex_ItemLastModified = 10;\\n \\n const PRInt32 nsNavHistory::kAutoCompleteIndex_URL = 0;\\n const PRInt32 nsNavHistory::kAutoCompleteIndex_Title = 1;\\n-const PRInt32 nsNavHistory::kAutoCompleteIndex_VisitCount = 2;\\n-const PRInt32 nsNavHistory::kAutoCompleteIndex_Typed = 3;\\n+const PRInt32 nsNavHistory::kAutoCompleteIndex_FaviconURL = 2;\\n+const PRInt32 nsNavHistory::kAutoCompleteIndex_ItemId = 3;\\n \\n static nsDataHashtable<nsCStringHashKey, int>* gTldTypes;\\n static const char* gQuitApplicationMessage = \\\"quit-application\\\";\\n@@ -258,6 +258,11 @@ nsNavHistory::nsNavHistory() : mNowValid(PR_FALSE),\\n \\n nsNavHistory::~nsNavHistory()\\n {\\n+  if (mAutoCompleteTimer) {\\n+    mAutoCompleteTimer->Cancel();\\n+    mAutoCompleteTimer = nsnull;\\n+  }\\n+\\n   // remove the static reference to the service. Check to make sure its us\\n   // in case somebody creates an extra instance of the service.\\n   NS_ASSERTION(gHistoryService == this, \\\"YOU CREATED 2 COPIES OF THE HISTORY SERVICE.\\\");\\n@@ -762,18 +767,6 @@ nsNavHistory::InitStatements()\\n     getter_AddRefs(mDBGetIdPageInfoFull));\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n-  // mDBFullAutoComplete\\n-  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(\\n-      \\\"SELECT h.url, h.title, h.visit_count, h.typed \\\"\\n-      \\\"FROM moz_places h \\\"\\n-      \\\"JOIN moz_historyvisits v ON h.id = v.place_id \\\"\\n-      \\\"WHERE h.hidden <> 1 \\\"\\n-      \\\"GROUP BY h.id \\\"\\n-      \\\"ORDER BY h.visit_count \\\"\\n-      \\\"LIMIT ?1\\\"),\\n-    getter_AddRefs(mDBFullAutoComplete));\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n   // mDBRecentVisitOfURL\\n   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(\\n       \\\"SELECT v.id, v.session \\\"\\ndiff --git a/toolkit/components/places/src/nsNavHistory.h b/toolkit/components/places/src/nsNavHistory.h\\nindex 2b75fb4..5dce3e5 100644\\n--- a/toolkit/components/places/src/nsNavHistory.h\\n+++ b/toolkit/components/places/src/nsNavHistory.h\\n@@ -362,11 +362,6 @@ protected:\\n   nsCOMPtr<mozIStorageStatement> mDBGetURLPageInfoFull; // kGetInfoIndex_* results\\n   nsCOMPtr<mozIStorageStatement> mDBGetIdPageInfo;     // kGetInfoIndex_* results\\n   nsCOMPtr<mozIStorageStatement> mDBGetIdPageInfoFull; // kGetInfoIndex_* results\\n-  nsCOMPtr<mozIStorageStatement> mDBFullAutoComplete; // kAutoCompleteIndex_* results, 1 arg (max # results)\\n-  static const PRInt32 kAutoCompleteIndex_URL;\\n-  static const PRInt32 kAutoCompleteIndex_Title;\\n-  static const PRInt32 kAutoCompleteIndex_VisitCount;\\n-  static const PRInt32 kAutoCompleteIndex_Typed;\\n \\n   nsCOMPtr<mozIStorageStatement> mDBRecentVisitOfURL; // converts URL into most recent visit ID/session ID\\n   nsCOMPtr<mozIStorageStatement> mDBInsertVisit; // used by AddVisit\\n@@ -560,49 +555,31 @@ protected:\\n   //\\n   // AutoComplete stuff\\n   //\\n-  struct AutoCompletePrefix\\n-  {\\n-    AutoCompletePrefix(const nsAString& aPrefix, PRBool aSecondLevel) :\\n-      prefix(aPrefix), secondLevel(aSecondLevel) {}\\n-\\n-    // The prefix, for example, \\\"http://\\\" or \\\"https://www.\\\"\\n-    nsString prefix;\\n-\\n-    // Set when this prefix contains a spec AND a host. For example,\\n-    // \\\"http://www.\\\" is a second level prefix, but \\\"http://\\\" is not. This\\n-    // flag is used to exclude matches. For example, if I type \\\"http://w\\\"\\n-    // I probably want it to autocomplete to sites beginning with w and\\n-    // NOT every \\\"www\\\" site I've ever visited.\\n-    PRBool secondLevel;\\n-  };\\n-  nsTArray<AutoCompletePrefix> mAutoCompletePrefixes;\\n-\\n-  nsCOMPtr<mozIStorageStatement> mDBAutoCompleteQuery;\\n+  static const PRInt32 kAutoCompleteIndex_URL;\\n+  static const PRInt32 kAutoCompleteIndex_Title;\\n+  static const PRInt32 kAutoCompleteIndex_FaviconURL;\\n+  static const PRInt32 kAutoCompleteIndex_ItemId;\\n+  nsCOMPtr<mozIStorageStatement> mDBAutoCompleteQuery; //  kAutoCompleteIndex_* results\\n   nsresult InitAutoComplete();\\n   nsresult CreateAutoCompleteQuery();\\n-  PRInt32 mAutoCompleteMaxCount;\\n-  PRInt32 mExpireDays;\\n   PRBool mAutoCompleteOnlyTyped;\\n+  nsCOMPtr<nsITimer> mAutoCompleteTimer;\\n \\n-  // Used to describe what prefixes shouldn't be cut from\\n-  // history urls when doing an autocomplete url comparison.\\n-  struct AutoCompleteExclude {\\n-    // these are indices into mIgnoreSchemes and mIgnoreHostnames, or -1\\n-    PRInt32 schemePrefix;\\n-    PRInt32 hostnamePrefix;\\n+  nsString mCurrentSearchString;\\n+  nsCOMPtr<nsIAutoCompleteObserver> mCurrentListener;\\n+  nsCOMPtr<nsIAutoCompleteSimpleResult> mCurrentResult;\\n+  nsDataHashtable<nsStringHashKey, PRBool> mCurrentResultURLs;\\n+  PRTime mCurrentChunkEndTime;\\n+  PRTime mCurrentOldestVisit;\\n \\n-    // this is the offset of the character immediately after the prefix\\n-    PRInt32 postPrefixOffset;\\n-  };\\n+  nsresult AutoCompleteTypedSearch();\\n+  nsresult AutoCompleteFullHistorySearch();\\n \\n-  nsresult AutoCompleteTypedSearch(nsIAutoCompleteSimpleResult* result);\\n-  nsresult AutoCompleteFullHistorySearch(const nsAString& aSearchString,\\n-                                         nsIAutoCompleteSimpleResult* result);\\n-  nsresult AutoCompleteQueryOnePrefix(const nsString& aSearchString,\\n-                                      const nsTArray<PRInt32>& aExcludePrefixes,\\n-                                      PRInt32 aPriorityDelta,\\n-                                      nsTArray<AutoCompleteIntermediateResult>* aResult);\\n-  PRInt32 AutoCompleteGetPrefixLength(const nsString& aSpec);\\n+  nsresult PerformAutoComplete();\\n+  nsresult StartAutoCompleteTimer(PRUint32 aMilliseconds);\\n+  static void AutoCompleteTimerCallback(nsITimer* aTimer, void* aClosure);\\n+\\n+  PRInt32 mExpireDays;\\n \\n   // in nsNavHistoryQuery.cpp\\n   nsresult TokensToQueries(const nsTArray<QueryKeyValuePair>& aTokens,\\ndiff --git a/toolkit/components/places/src/nsNavHistoryAutoComplete.cpp b/toolkit/components/places/src/nsNavHistoryAutoComplete.cpp\\nindex b493c70..eeddaea 100644\\n--- a/toolkit/components/places/src/nsNavHistoryAutoComplete.cpp\\n+++ b/toolkit/components/places/src/nsNavHistoryAutoComplete.cpp\\n@@ -42,58 +42,11 @@\\n /**\\n  * Autocomplete algorithm:\\n  *\\n- * Scoring\\n- * -------\\n- * Generally ordering is by visit count. We given boosts to items that have\\n- * been bookmarked or typed into the address bar (as opposed to clicked links).\\n- * The penalties below for schemes and prefix matches also apply. We also\\n- * prefer paths (URLs ending in '/') and try to have shorter ones generally\\n- * appear first. The results are then presented in descending numeric order\\n- * using this score.\\n- *\\n- * Database queries\\n- * ----------------\\n- * It is tempting to do a select for \\\"url LIKE user_input\\\" but this is a very\\n- * slow query since it is brute-force over all URLs in histroy. We can,\\n- * however, do very efficient queries using < and > for strings. These\\n- * operators use the index over the URL column.\\n- *\\n- * Therefore, we try to prepend any prefixes that should be considered and\\n- * query for them individually. Therefore, we execute several very efficient\\n- * queries, score the results, and sort it.\\n- *\\n- * To limit the amount of searching we do, we ask the database to order the\\n- * results based on visit count for us and give us on the top N results.\\n- * These results will be in approximate order of score. As long as each query\\n- * has more results than the user is likely to see, they will not notice the\\n- * effects of this.\\n- *\\n- * First see if any specs match that from the beginning\\n- * ----------------------------------------------------\\n- * - If it matches the beginning of a known prefix prefix, exclude that prefix\\n- *   when querying. We would therefore exclude \\\"http://\\\" and \\\"https://\\\" if you type\\n- *   \\\"ht\\\". But match any other schemes that begin with \\\"ht\\\" (probably none).\\n- *\\n- * - Penalize all results. Most people don't type the scheme and don't want\\n- *   matches like this. This will make \\\"file://\\\" links go below\\n- *   \\\"http://www.fido.com/\\\". If one is typing the scheme \\\"file:\\\" for example, by\\n- *   the time you type the colon it won't match anything else (like \\\"http://file:\\\")\\n- *   and the penalty won't have any effect on the ordering (it will be applied to\\n- *   all results).\\n- *\\n- * Try different known prefixes\\n- * ----------------------------\\n- * - Prepend each prefix, running a query. If the concatenated string is itself a\\n- *   prefix of another known prefix (ie input is \\\"w\\\" and we prepend \\\"http://\\\", it\\n- *   will be a prefix of \\\"http://www.\\\"), select out that known prefix. In this\\n- *   case we'll query for everything starting with \\\"http://w\\\" except things\\n- *   starting with \\\"http://www.\\\"\\n- *\\n- * - For each selected out prefix above, run a query but apply prefix match\\n- *   penalty to the results. This way you'll still get \\\"http://www.\\\" results\\n- *   if you type \\\"w\\\", but they will generally be lower than \\\"http://wookie.net/\\\"\\n- *   For your favorite few sites with many visits, you might still get matches\\n- *   for \\\"www\\\" first, which is probably what you want for your favorite sites.\\n+ * The current algorithm searches history from now backwards to the oldest\\n+ * visit in chunks of time (AUTOCOMPLETE_SEARCH_CHUNK).  We currently\\n+ * do SQL LIKE searches of the search term in the url and title\\n+ * within in each chunk of time.  the results are ordered by visit_count \\n+ * (and then visit_date), giving us poor man's \\\"frecency\\\".\\n  */\\n \\n #include \\\"nsNavHistory.h\\\"\\n@@ -107,157 +60,24 @@\\n #include \\\"mozStorageCID.h\\\"\\n #include \\\"mozStorageHelper.h\\\"\\n #include \\\"nsFaviconService.h\\\"\\n+#include \\\"nsUnicharUtils.h\\\"\\n \\n #define NS_AUTOCOMPLETESIMPLERESULT_CONTRACTID \\\\\\n   \\\"@mozilla.org/autocomplete/simple-result;1\\\"\\n \\n-// Size of visit count boost to give to URLs which are sites or paths\\n-#define AUTOCOMPLETE_NONPAGE_VISIT_COUNT_BOOST 5\\n-\\n-// Boost to give to URLs which have been typed\\n-#define AUTOCOMPLETE_TYPED_BOOST 5\\n-\\n-// Boost to give to URLs which are bookmarked\\n-#define AUTOCOMPLETE_BOOKMARKED_BOOST 5\\n-\\n-// Penalty to add to sites that match a prefix. For example, if I type \\\"w\\\"\\n-// we will complte on \\\"http://www.w...\\\" like normal. We we will also complete\\n-// on \\\"http://w\\\" which will match almost every site, but will have this penalty\\n-// applied so they will come later. We want a pretty big penalty so that you'll\\n-// only get \\\"www\\\" beating domain names that start with w for your very favorite\\n-// sites.\\n-#define AUTOCOMPLETE_MATCHES_PREFIX_PENALTY (-50)\\n-\\n-// Penalty applied to matches that don't have prefixes applied. See\\n-// discussion above.\\n-#define AUTOCOMPLETE_MATCHES_SCHEME_PENALTY (-20)\\n-\\n-// Number of results we will consider for each prefix. Each prefix lookup is\\n-// done separately. Typically, we will only match one prefix, so this should be\\n-// a sufficient number to give \\\"enough\\\" autocomplete matches per prefix. The\\n-// total number of results that could ever be returned is this times the number\\n-// of prefixes. This should be as small as is reasonable to make it faster.\\n-#define AUTOCOMPLETE_MAX_PER_PREFIX 50\\n-\\n-// This is the maximum results we'll return for a \\\"typed\\\" search (usually\\n-// happens in response to clicking the down arrow next to the URL).\\n+// This is the maximum results we'll return for a \\\"typed\\\" search\\n+// This happens in response to clicking the down arrow next to the URL.\\n #define AUTOCOMPLETE_MAX_PER_TYPED 100\\n \\n-PRInt32 ComputeAutoCompletePriority(const nsAString& aUrl, PRInt32 aVisitCount,\\n-                                    PRBool aWasTyped, PRBool aIsBookmarked);\\n-nsresult NormalizeAutocompleteInput(const nsAString& aInput,\\n-                                    nsString& aOutput);\\n-\\n-// nsIAutoCompleteSearch *******************************************************\\n-\\n-\\n-// AutoCompleteIntermediateResult/Set\\n-//\\n-//    This class holds intermediate autocomplete results so that they can be\\n-//    sorted. This list is then handed off to a result using FillResult. The\\n-//    major reason for this is so that we can use nsArray's sorting functions,\\n-//    not use COM, yet have well-defined lifetimes for the objects. This uses\\n-//    a void array, but makes sure to delete the objects on desctruction.\\n-\\n-struct AutoCompleteIntermediateResult\\n-{\\n-  AutoCompleteIntermediateResult(const nsString& aUrl, const nsString& aTitle,\\n-                                 const nsString& aImage,\\n-                                 PRInt32 aVisitCount, PRInt32 aPriority) :\\n-    url(aUrl), title(aTitle), image(aImage), \\n-    visitCount(aVisitCount), priority(aPriority) {}\\n-  nsString url;\\n-  nsString title;\\n-  nsString image;\\n-  PRInt32 visitCount;\\n-  PRInt32 priority;\\n-};\\n-\\n-\\n-// AutoCompleteResultComparator\\n-\\n-class AutoCompleteResultComparator\\n-{\\n-public:\\n-  AutoCompleteResultComparator(nsNavHistory* history) : mHistory(history) {}\\n-\\n-  PRBool Equals(const AutoCompleteIntermediateResult& a,\\n-                const AutoCompleteIntermediateResult& b) const {\\n-    // Don't need an equals, this call will be optimized out when it\\n-    // is used by nsQuickSortComparator above\\n-    return PR_FALSE;\\n-  }\\n-  PRBool LessThan(const AutoCompleteIntermediateResult& match1,\\n-                  const AutoCompleteIntermediateResult& match2) const {\\n-    // we actually compare GREATER than here, since we want the array to be in\\n-    // most relevant (highest priority value) first\\n-\\n-    // In most cases the priorities will be different and we just use them\\n-    if (match1.priority != match2.priority)\\n-    {\\n-      return match1.priority > match2.priority;\\n-    }\\n-    else\\n-    {\\n-      // secondary sorting gives priority to site names and paths (ending in a /)\\n-      PRBool isPath1 = PR_FALSE, isPath2 = PR_FALSE;\\n-      if (!match1.url.IsEmpty())\\n-        isPath1 = (match1.url.Last() == PRUnichar('/'));\\n-      if (!match2.url.IsEmpty())\\n-        isPath2 = (match2.url.Last() == PRUnichar('/'));\\n-\\n-      if (isPath1 && !isPath2) return PR_FALSE; // match1->url is a website/path, match2->url isn't\\n-      if (!isPath1 && isPath2) return PR_TRUE;  // match1->url isn't a website/path, match2->url is\\n-\\n-      // find the prefixes so we can sort by the stuff after the prefixes\\n-      PRInt32 prefix1 = mHistory->AutoCompleteGetPrefixLength(match1.url);\\n-      PRInt32 prefix2 = mHistory->AutoCompleteGetPrefixLength(match2.url);\\n-\\n-      // Compare non-prefixed urls using the current locale string compare. This will sort\\n-      // things alphabetically (ignoring common prefixes). For example, \\\"http://www.abc.com/\\\"\\n-      // will come before \\\"ftp://ftp.xyz.com\\\"\\n-      PRInt32 ret = 0;\\n-      mHistory->mCollation->CompareString(\\n-          nsICollation::kCollationCaseInSensitive,\\n-          Substring(match1.url, prefix1), Substring(match2.url, prefix2),\\n-          &ret);\\n-      if (ret != 0)\\n-        return ret > 0;\\n-\\n-      // sort http://xyz.com before http://www.xyz.com\\n-      return prefix1 > prefix2;\\n-    }\\n-    return PR_FALSE;\\n-  }\\n-protected:\\n-  nsNavHistory* mHistory;\\n-};\\n-\\n-\\n // nsNavHistory::InitAutoComplete\\n-\\n nsresult\\n nsNavHistory::InitAutoComplete()\\n {\\n   nsresult rv = CreateAutoCompleteQuery();\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n-  AutoCompletePrefix* ok;\\n-\\n-  // These are the prefixes we check for implicitly. Prefixes with a\\n-  // host portion (like \\\"www.\\\") get their second level flag set.\\n-  ok = mAutoCompletePrefixes.AppendElement(AutoCompletePrefix(NS_LITERAL_STRING(\\\"http://\\\"), PR_FALSE));\\n-  NS_ENSURE_TRUE(ok, NS_ERROR_OUT_OF_MEMORY);\\n-  ok = mAutoCompletePrefixes.AppendElement(AutoCompletePrefix(NS_LITERAL_STRING(\\\"http://www.\\\"), PR_TRUE));\\n-  NS_ENSURE_TRUE(ok, NS_ERROR_OUT_OF_MEMORY);\\n-  ok = mAutoCompletePrefixes.AppendElement(AutoCompletePrefix(NS_LITERAL_STRING(\\\"ftp://\\\"), PR_FALSE));\\n-  NS_ENSURE_TRUE(ok, NS_ERROR_OUT_OF_MEMORY);\\n-  ok = mAutoCompletePrefixes.AppendElement(AutoCompletePrefix(NS_LITERAL_STRING(\\\"ftp://ftp.\\\"), PR_TRUE));\\n-  NS_ENSURE_TRUE(ok, NS_ERROR_OUT_OF_MEMORY);\\n-  ok = mAutoCompletePrefixes.AppendElement(AutoCompletePrefix(NS_LITERAL_STRING(\\\"https://\\\"), PR_FALSE));\\n-  NS_ENSURE_TRUE(ok, NS_ERROR_OUT_OF_MEMORY);\\n-  ok = mAutoCompletePrefixes.AppendElement(AutoCompletePrefix(NS_LITERAL_STRING(\\\"https://www.\\\"), PR_TRUE));\\n-  NS_ENSURE_TRUE(ok, NS_ERROR_OUT_OF_MEMORY);\\n+  if (!mCurrentResultURLs.Init(128))\\n+    return NS_ERROR_OUT_OF_MEMORY;\\n \\n   return NS_OK;\\n }\\n@@ -271,35 +91,121 @@ nsNavHistory::InitAutoComplete()\\n nsresult\\n nsNavHistory::CreateAutoCompleteQuery()\\n {\\n-  nsCString sql;\\n-  if (mAutoCompleteOnlyTyped) {\\n-    sql = NS_LITERAL_CSTRING(\\n-        \\\"SELECT p.url, p.title, p.visit_count, p.typed, \\\"\\n-          \\\"(SELECT b.fk FROM moz_bookmarks b WHERE b.fk = p.id), f.url \\\"\\n-        \\\"FROM moz_places p \\\"\\n-        \\\"LEFT OUTER JOIN moz_favicons f ON p.favicon_id = f.id \\\"\\n-        \\\"WHERE p.url >= ?1 AND p.url < ?2 \\\"\\n-        \\\"AND p.typed = 1 \\\"\\n-        \\\"ORDER BY p.visit_count DESC \\\"\\n-        \\\"LIMIT \\\");\\n+  nsCString sql = NS_LITERAL_CSTRING(\\n+    \\\"SELECT h.url, h.title, f.url, b.id \\\"\\n+    \\\"FROM moz_places h \\\"\\n+    \\\"JOIN moz_historyvisits v ON h.id = v.place_id \\\"\\n+    \\\"LEFT OUTER JOIN moz_bookmarks b ON b.fk = h.id \\\"\\n+    \\\"LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id \\\"\\n+    \\\"WHERE v.visit_date >= ?1 AND v.visit_date <= ?2 AND h.hidden <> 1 AND \\\"\\n+    \\\" v.visit_type <> 0 AND v.visit_type <> 4 AND \\\");\\n+\\n+  if (mAutoCompleteOnlyTyped)\\n+    sql += NS_LITERAL_CSTRING(\\\"h.typed = 1 AND \\\");\\n+\\n+  sql += NS_LITERAL_CSTRING(\\n+    \\\"(h.title LIKE ?3 ESCAPE '/' OR h.url LIKE ?3 ESCAPE '/') \\\"\\n+    \\\"GROUP BY h.id ORDER BY h.visit_count DESC, MAX(v.visit_date) DESC \\\");\\n+\\n+  return mDBConn->CreateStatement(sql, getter_AddRefs(mDBAutoCompleteQuery));\\n+}\\n+\\n+// nsNavHistory::StartAutoCompleteTimer\\n+\\n+nsresult\\n+nsNavHistory::StartAutoCompleteTimer(PRUint32 aMilliseconds)\\n+{\\n+  nsresult rv;\\n+\\n+  if (!mAutoCompleteTimer) {\\n+    mAutoCompleteTimer = do_CreateInstance(\\\"@mozilla.org/timer;1\\\", &rv);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+  }\\n+  \\n+  rv = mAutoCompleteTimer->InitWithFuncCallback(AutoCompleteTimerCallback, this,\\n+                                                aMilliseconds,\\n+                                                nsITimer::TYPE_ONE_SHOT);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+  return NS_OK;\\n+}\\n+\\n+static const PRInt64 USECS_PER_DAY = LL_INIT(20, 500654080);\\n+\\n+// search in day chunks.  too big, and the UI will be unresponsive\\n+// as we will be off searching the database.\\n+// too short, and because of AUTOCOMPLETE_SEARCH_TIMEOUT\\n+// results won't come back in fast enough to feel snappy.\\n+// because we sort within chunks by visit_count (then visit_date)\\n+// choose 4 days so that Friday's searches are in the first chunk\\n+// and those will affect Monday's results\\n+#define AUTOCOMPLETE_SEARCH_CHUNK (USECS_PER_DAY * 4)\\n+\\n+// wait this many milliseconds between searches\\n+// too short, and the UI will be unresponsive\\n+// as we will be off searching the database.\\n+// too big, and results won't come back in fast enough to feel snappy.\\n+#define AUTOCOMPLETE_SEARCH_TIMEOUT 100\\n+\\n+// nsNavHistory::AutoCompleteTimerCallback\\n+\\n+void // static\\n+nsNavHistory::AutoCompleteTimerCallback(nsITimer* aTimer, void* aClosure)\\n+{\\n+  nsNavHistory* history = static_cast<nsNavHistory*>(aClosure);\\n+  (void)history->PerformAutoComplete();\\n+}\\n+\\n+nsresult \\n+nsNavHistory::PerformAutoComplete()\\n+{\\n+  // if there is no listener, our search has been stopped\\n+  if (!mCurrentListener)\\n+    return NS_OK;\\n+\\n+  mCurrentResult->SetSearchString(mCurrentSearchString);\\n+  PRBool moreChunksToSearch = PR_FALSE;\\n+\\n+  nsresult rv;\\n+  // results will be put into mCurrentResult  \\n+  if (mCurrentSearchString.IsEmpty())\\n+    rv = AutoCompleteTypedSearch();\\n+  else {\\n+    rv = AutoCompleteFullHistorySearch();\\n+    moreChunksToSearch = (mCurrentChunkEndTime >= mCurrentOldestVisit);\\n+  }\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+ \\n+  // Determine the result of the search\\n+  PRUint32 count;\\n+  mCurrentResult->GetMatchCount(&count); \\n+\\n+  if (count > 0) {\\n+    mCurrentResult->SetSearchResult(moreChunksToSearch ?\\n+      nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING :\\n+      nsIAutoCompleteResult::RESULT_SUCCESS);\\n+    mCurrentResult->SetDefaultIndex(0);\\n   } else {\\n-    sql = NS_LITERAL_CSTRING(\\n-        \\\"SELECT p.url, p.title, p.visit_count, p.typed, \\\"\\n-          \\\"(SELECT b.fk FROM moz_bookmarks b WHERE b.fk = p.id), f.url \\\"\\n-        \\\"FROM moz_places p \\\"\\n-        \\\"LEFT OUTER JOIN moz_favicons f ON p.favicon_id = f.id \\\"\\n-        \\\"WHERE p.url >= ?1 AND p.url < ?2 \\\"\\n-        \\\"AND (p.hidden <> 1 OR p.typed = 1) \\\"\\n-        \\\"ORDER BY p.visit_count DESC \\\"\\n-        \\\"LIMIT \\\");\\n+    mCurrentResult->SetSearchResult(moreChunksToSearch ?\\n+      nsIAutoCompleteResult::RESULT_NOMATCH_ONGOING :\\n+      nsIAutoCompleteResult::RESULT_NOMATCH);\\n+    mCurrentResult->SetDefaultIndex(-1);\\n+  }\\n+\\n+  rv = mCurrentResult->SetListener(this);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  mCurrentListener->OnSearchResult(this, mCurrentResult);\\n+ \\n+  // if we're not done searching, adjust our end time and \\n+  // search the next earlier chunk of time\\n+  if (moreChunksToSearch) {\\n+    mCurrentChunkEndTime -= AUTOCOMPLETE_SEARCH_CHUNK;\\n+    rv = StartAutoCompleteTimer(AUTOCOMPLETE_SEARCH_TIMEOUT);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n   }\\n-  sql.AppendInt(AUTOCOMPLETE_MAX_PER_PREFIX);\\n-  nsresult rv = mDBConn->CreateStatement(sql,\\n-      getter_AddRefs(mDBAutoCompleteQuery));\\n   return rv;\\n }\\n \\n-\\n // nsNavHistory::StartSearch\\n //\\n \\n@@ -309,56 +215,100 @@ nsNavHistory::StartSearch(const nsAString & aSearchString,\\n                           nsIAutoCompleteResult *aPreviousResult,\\n                           nsIAutoCompleteObserver *aListener)\\n {\\n-  nsresult rv;\\n-\\n   NS_ENSURE_ARG_POINTER(aListener);\\n+  mCurrentSearchString = aSearchString;\\n+  // remove whitespace, see bug #392141 for details\\n+  mCurrentSearchString.Trim(\\\" \\\\r\\\\n\\\\t\\\\b\\\");\\n+  mCurrentListener = aListener;\\n+  nsresult rv;\\n \\n-  nsCOMPtr<nsIAutoCompleteSimpleResult> result =\\n-      do_CreateInstance(NS_AUTOCOMPLETESIMPLERESULT_CONTRACTID, &rv);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-  result->SetSearchString(aSearchString);\\n-\\n-  // Performance: We can improve performance for refinements of a previous\\n-  // result by filtering the old result with the new string. However, since\\n-  // our results are not a full match of history, we'll need to requery if\\n-  // any of the subresults returned the maximum number of elements (i.e. we\\n-  // didn't load all of them).\\n-  //\\n-  // Timing measurements show that the performance of this is actually very\\n-  // good for specific queries. Thus, the times where we can do the\\n-  // optimization (when there are few results) are exactly the times when\\n-  // we don't have to. As a result, we keep it this much simpler way.\\n-  if (aSearchString.IsEmpty()) {\\n-    rv = AutoCompleteTypedSearch(result);\\n-  } else {\\n-    rv = AutoCompleteFullHistorySearch(aSearchString, result);\\n+  // determine if we can start by searching through the previous search results.\\n+  // if we can't, we need to reset mCurrentChunkEndTime and mCurrentOldestVisit.\\n+  // if we can, we will search through our previous search results and then resume \\n+  // searching using the previous mCurrentChunkEndTime and mCurrentOldestVisit values.\\n+  PRBool searchPrevious = PR_FALSE;\\n+  if (aPreviousResult) {\\n+    PRUint32 matchCount = 0;\\n+    aPreviousResult->GetMatchCount(&matchCount);\\n+    nsAutoString prevSearchString;\\n+    aPreviousResult->GetSearchString(prevSearchString);\\n+\\n+    // if search string begins with the previous search string, it's a go\\n+    searchPrevious = Substring(mCurrentSearchString, 0,\\n+                       prevSearchString.Length()).Equals(prevSearchString);\\n+  }\\n+  else {\\n+    // reset to mCurrentChunkEndTime \\n+    mCurrentChunkEndTime = PR_Now();\\n+\\n+    // determine our earliest visit\\n+    nsCOMPtr<mozIStorageStatement> dbSelectStatement;\\n+    rv = mDBConn->CreateStatement(\\n+      NS_LITERAL_CSTRING(\\\"SELECT MIN(visit_date) id FROM moz_historyvisits WHERE visit_type <> 4 AND visit_type <> 0\\\"),\\n+      getter_AddRefs(dbSelectStatement));\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    PRBool hasMinVisit;\\n+    rv = dbSelectStatement->ExecuteStep(&hasMinVisit);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+  \\n+    if (hasMinVisit) {\\n+      rv = dbSelectStatement->GetInt64(0, &mCurrentOldestVisit);\\n+      NS_ENSURE_SUCCESS(rv, rv);\\n+    }\\n+    else {\\n+      // if we have no visits, use a reasonable value\\n+      mCurrentOldestVisit = PR_Now() - USECS_PER_DAY;\\n+    }\\n   }\\n+\\n+  mCurrentResult = do_CreateInstance(NS_AUTOCOMPLETESIMPLERESULT_CONTRACTID, &rv);\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n-  // Determine the result of the search\\n-  PRUint32 count;\\n-  result->GetMatchCount(&count);\\n-  if (count > 0) {\\n-    result->SetSearchResult(nsIAutoCompleteResult::RESULT_SUCCESS);\\n-    result->SetDefaultIndex(0);\\n-  } else {\\n-    result->SetSearchResult(nsIAutoCompleteResult::RESULT_NOMATCH);\\n-    result->SetDefaultIndex(-1);\\n+  mCurrentResultURLs.Clear();\\n+\\n+  // Search through the previous result\\n+  if (searchPrevious) {\\n+    PRUint32 matchCount;\\n+    aPreviousResult->GetMatchCount(&matchCount);\\n+    for (PRInt32 i = 0; i < matchCount; i++) {\\n+      nsAutoString url, title;\\n+      aPreviousResult->GetValueAt(i, url);\\n+      aPreviousResult->GetCommentAt(i, title);\\n+\\n+      PRBool isMatch = CaseInsensitiveFindInReadable(mCurrentSearchString, url);\\n+      if (!isMatch)\\n+        isMatch = CaseInsensitiveFindInReadable(mCurrentSearchString, title);\\n+\\n+      if (isMatch) {\\n+        nsAutoString image, style;\\n+        aPreviousResult->GetImageAt(i, image);\\n+        aPreviousResult->GetStyleAt(i, style);\\n+ \\n+        mCurrentResultURLs.Put(url, PR_TRUE);\\n+\\n+        rv = mCurrentResult->AppendMatch(url, title, image, style);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+      }\\n+    }\\n   }\\n \\n-  rv = result->SetListener(this);\\n+  // fire right away, we already waited to start searching\\n+  rv = StartAutoCompleteTimer(0);\\n   NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  aListener->OnSearchResult(this, result);\\n   return NS_OK;\\n }\\n \\n-\\n // nsNavHistory::StopSearch\\n \\n NS_IMETHODIMP\\n nsNavHistory::StopSearch()\\n {\\n+  if (mAutoCompleteTimer)\\n+    mAutoCompleteTimer->Cancel();\\n+\\n+  mCurrentSearchString.Truncate();\\n+  mCurrentListener = nsnull;\\n+\\n   return NS_OK;\\n }\\n \\n@@ -371,169 +321,104 @@ nsNavHistory::StopSearch()\\n //    is no URL information to use. The ordering just comes out of the DB by\\n //    visit count (primary) and time since last visited (secondary).\\n \\n-nsresult nsNavHistory::AutoCompleteTypedSearch(\\n-                                            nsIAutoCompleteSimpleResult* result)\\n+nsresult nsNavHistory::AutoCompleteTypedSearch()\\n {\\n-  // need to get more than the required minimum number since some will be dupes\\n   nsCOMPtr<mozIStorageStatement> dbSelectStatement;\\n-  nsCString sql = NS_LITERAL_CSTRING(\\n-      \\\"SELECT h.url, title, f.url \\\"\\n-      \\\"FROM moz_historyvisits v JOIN moz_places h ON v.place_id = h.id \\\"\\n-      \\\"LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id \\\" \\n-      \\\"WHERE h.typed = 1 ORDER BY visit_date DESC LIMIT \\\");\\n-  sql.AppendInt(AUTOCOMPLETE_MAX_PER_TYPED * 3);\\n-  nsresult rv = mDBConn->CreateStatement(sql, getter_AddRefs(dbSelectStatement));\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  // prevent duplicates\\n-  nsDataHashtable<nsStringHashKey, PRInt32> urls;\\n-  if (! urls.Init(500))\\n-    return NS_ERROR_OUT_OF_MEMORY;\\n \\n+  nsCString sql = NS_LITERAL_CSTRING(\\n+    \\\"SELECT h.url, h.title, f.url, b.id \\\"\\n+    \\\"FROM moz_places h \\\"\\n+    \\\"LEFT OUTER JOIN moz_bookmarks b ON b.fk = h.id \\\"\\n+    \\\"LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id \\\"\\n+    \\\"JOIN moz_historyvisits v ON h.id = v.place_id WHERE (h.id IN \\\"\\n+    \\\"(SELECT DISTINCT h.id from moz_historyvisits v, moz_places h WHERE \\\"\\n+    \\\"v.place_id = h.id AND h.typed = 1 AND v.visit_type <> 0 AND v.visit_type <> 4 \\\"\\n+    \\\"ORDER BY v.visit_date DESC LIMIT \\\");\\n+  sql.AppendInt(AUTOCOMPLETE_MAX_PER_TYPED);\\n+  sql += NS_LITERAL_CSTRING(\\\")) GROUP BY h.id ORDER BY MAX(v.visit_date) DESC\\\");  \\n+  \\n   nsFaviconService* faviconService = nsFaviconService::GetFaviconService();\\n   NS_ENSURE_TRUE(faviconService, NS_ERROR_OUT_OF_MEMORY);\\n \\n-  PRInt32 dummy;\\n-  PRInt32 count = 0;\\n+  nsresult rv = mDBConn->CreateStatement(sql, getter_AddRefs(dbSelectStatement));\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+ \\n   PRBool hasMore = PR_FALSE;\\n-  while (count < AUTOCOMPLETE_MAX_PER_TYPED &&\\n-         NS_SUCCEEDED(dbSelectStatement->ExecuteStep(&hasMore)) && hasMore) {\\n-    nsAutoString entryURL, entryTitle, entryImage;\\n-    dbSelectStatement->GetString(0, entryURL);\\n-    dbSelectStatement->GetString(1, entryTitle);\\n-    dbSelectStatement->GetString(2, entryImage);\\n-\\n-    if (! urls.Get(entryURL, &dummy)) {\\n-      // new item\\n-      nsCAutoString faviconSpec;\\n-      faviconService->GetFaviconSpecForIconString(\\n-        NS_ConvertUTF16toUTF8(entryImage), faviconSpec);\\n-      rv = result->AppendMatch(entryURL, entryTitle, \\n-        NS_ConvertUTF8toUTF16(faviconSpec), NS_LITERAL_STRING(\\\"favicon\\\"));\\n-      NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-      urls.Put(entryURL, 1);\\n-      count ++;\\n-    }\\n-  }\\n-\\n+  while (NS_SUCCEEDED(dbSelectStatement->ExecuteStep(&hasMore)) && hasMore) {\\n+    nsAutoString entryURL, entryTitle, entryFavicon;\\n+    dbSelectStatement->GetString(kAutoCompleteIndex_URL, entryURL);\\n+    dbSelectStatement->GetString(kAutoCompleteIndex_Title, entryTitle);\\n+    dbSelectStatement->GetString(kAutoCompleteIndex_FaviconURL, entryFavicon);\\n+    PRInt64 itemId = 0;\\n+    dbSelectStatement->GetInt64(kAutoCompleteIndex_ItemId, &itemId);\\n+\\n+    nsCAutoString imageSpec;\\n+    faviconService->GetFaviconSpecForIconString(\\n+      NS_ConvertUTF16toUTF8(entryFavicon), imageSpec);\\n+    rv = mCurrentResult->AppendMatch(entryURL, entryTitle, \\n+      NS_ConvertUTF8toUTF16(imageSpec), itemId ? NS_LITERAL_STRING(\\\"bookmark\\\") : NS_LITERAL_STRING(\\\"favicon\\\"));\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+  } \\n   return NS_OK;\\n }\\n \\n \\n // nsNavHistory::AutoCompleteFullHistorySearch\\n //\\n-//    A brute-force search of the entire history. This matches the given input\\n-//    with every possible history entry, and sorts them by likelihood.\\n+// Search history for visits that have a url or title that contains mCurrentSearchString\\n+// and are within our current chunk of time:\\n+// between (mCurrentChunkEndTime - AUTOCOMPLETE_SEARCH_CHUNK) and (mCurrentChunkEndTime)\\n //\\n-//    This may be slow for people on slow computers with large histories.\\n \\n nsresult\\n-nsNavHistory::AutoCompleteFullHistorySearch(const nsAString& aSearchString,\\n-                                            nsIAutoCompleteSimpleResult* aResult)\\n+nsNavHistory::AutoCompleteFullHistorySearch()\\n {\\n-  nsString searchString;\\n-  nsresult rv = NormalizeAutocompleteInput(aSearchString, searchString);\\n-  if (NS_FAILED(rv))\\n-    return NS_OK; // no matches for invalid input\\n-\\n-  nsTArray<AutoCompleteIntermediateResult> matches;\\n-\\n-  // Try a query using this search string and every prefix. Keep track of\\n-  // known prefixes that the input matches for exclusion later\\n-  PRUint32 i;\\n-  const nsTArray<PRInt32> emptyArray;\\n-  nsTArray<PRInt32> firstLevelMatches;\\n-  nsTArray<PRInt32> secondLevelMatches;\\n-  for (i = 0; i < mAutoCompletePrefixes.Length(); i ++) {\\n-    if (StringBeginsWith(mAutoCompletePrefixes[i].prefix, searchString)) {\\n-      if (mAutoCompletePrefixes[i].secondLevel)\\n-        secondLevelMatches.AppendElement(i);\\n-      else\\n-        firstLevelMatches.AppendElement(i);\\n-    }\\n+  mozStorageStatementScoper scope(mDBAutoCompleteQuery);\\n \\n-    // current string to search for\\n-    nsString cur = mAutoCompletePrefixes[i].prefix + searchString;\\n-\\n-    // see if the concatenated string itself matches any prefixes\\n-    nsTArray<PRInt32> curPrefixMatches;\\n-    for (PRUint32 prefix = 0; prefix < mAutoCompletePrefixes.Length(); prefix ++) {\\n-      if (StringBeginsWith(mAutoCompletePrefixes[prefix].prefix, cur))\\n-        curPrefixMatches.AppendElement(prefix);\\n-    }\\n+  nsresult rv = mDBAutoCompleteQuery->BindInt64Parameter(0, mCurrentChunkEndTime - AUTOCOMPLETE_SEARCH_CHUNK);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n \\n-    // search for the current string, excluding those matching prefixes\\n-    AutoCompleteQueryOnePrefix(cur, curPrefixMatches, 0, &matches);\\n+  rv = mDBAutoCompleteQuery->BindInt64Parameter(1, mCurrentChunkEndTime);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n \\n-    // search for each of those matching prefixes, applying the prefix penalty\\n-    for (PRUint32 match = 0; match < curPrefixMatches.Length(); match ++) {\\n-      AutoCompleteQueryOnePrefix(mAutoCompletePrefixes[curPrefixMatches[match]].prefix,\\n-                                 emptyArray, AUTOCOMPLETE_MATCHES_PREFIX_PENALTY,\\n-                                 &matches);\\n-    }\\n-  }\\n+  nsString escapedSearchString;\\n+  rv = mDBAutoCompleteQuery->EscapeStringForLIKE(mCurrentSearchString, PRUnichar('/'), escapedSearchString);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n \\n-  // Now try searching with no prefix\\n-  if (firstLevelMatches.Length() > 0) {\\n-    // This will get all matches that DON'T match any prefix. For example, if\\n-    // the user types \\\"http://w\\\" we will match \\\"http://westinghouse.com\\\" but\\n-    // not \\\"http://www.something\\\".\\n-    AutoCompleteQueryOnePrefix(searchString,\\n-                               firstLevelMatches, 0, &matches);\\n-  } else if (secondLevelMatches.Length() > 0) {\\n-    // if there are no first level matches (i.e. \\\"http://\\\") then we fall back on\\n-    // second level matches. Here, we assume that a first level match implies\\n-    // a second level match as well, so we only have to check when there are no\\n-    // first level matches.\\n-    AutoCompleteQueryOnePrefix(searchString,\\n-                               secondLevelMatches, 0, &matches);\\n-\\n-    // now we try to fill in matches of the prefix. For example, if you type\\n-    // \\\"http://w\\\" we will still match against \\\"http://www.\\\" but with a penalty.\\n-    // We only do this for second level prefixes.\\n-    for (PRUint32 match = 0; match < secondLevelMatches.Length(); match ++) {\\n-      AutoCompleteQueryOnePrefix(mAutoCompletePrefixes[secondLevelMatches[match]].prefix,\\n-                                 emptyArray, AUTOCOMPLETE_MATCHES_SCHEME_PENALTY,\\n-                                 &matches);\\n-    }\\n-  } else {\\n-    // Input matched no prefix, try to query for all URLs beinning with this\\n-    // exact input.\\n-    AutoCompleteQueryOnePrefix(searchString, emptyArray,\\n-                               AUTOCOMPLETE_MATCHES_SCHEME_PENALTY, &matches);\\n-  }\\n+  // prepend and append with % for \\\"contains\\\"\\n+  rv = mDBAutoCompleteQuery->BindStringParameter(2, NS_LITERAL_STRING(\\\"%\\\") + escapedSearchString + NS_LITERAL_STRING(\\\"%\\\"));\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n \\n   nsFaviconService* faviconService = nsFaviconService::GetFaviconService();\\n   NS_ENSURE_TRUE(faviconService, NS_ERROR_OUT_OF_MEMORY);\\n \\n-  // fill into result\\n-  if (matches.Length() > 0) {\\n-    // sort according to priorities\\n-    AutoCompleteResultComparator comparator(this);\\n-    matches.Sort(comparator);\\n+  PRBool hasMore = PR_FALSE;\\n \\n-    nsCAutoString faviconSpec;\\n-    faviconService->GetFaviconSpecForIconString(\\n-      NS_ConvertUTF16toUTF8(matches[0].image), faviconSpec);\\n-    rv = aResult->AppendMatch(matches[0].url, matches[0].title, \\n-                              NS_ConvertUTF8toUTF16(faviconSpec), \\n-                              NS_LITERAL_STRING(\\\"favicon\\\"));\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n+  // Determine the result of the search\\n+  while (NS_SUCCEEDED(mDBAutoCompleteQuery->ExecuteStep(&hasMore)) && hasMore) {\\n+    nsAutoString entryURL, entryTitle, entryFavicon;\\n+    mDBAutoCompleteQuery->GetString(kAutoCompleteIndex_URL, entryURL);\\n+    mDBAutoCompleteQuery->GetString(kAutoCompleteIndex_Title, entryTitle);\\n+    mDBAutoCompleteQuery->GetString(kAutoCompleteIndex_FaviconURL, entryFavicon);\\n+    PRInt64 itemId = 0;\\n+    mDBAutoCompleteQuery->GetInt64(kAutoCompleteIndex_ItemId, &itemId);\\n+\\n+    PRBool dummy;\\n+    // prevent duplicates.  this can happen when chunking as we\\n+    // may have already seen this URL from an earlier chunk of time\\n+    if (!mCurrentResultURLs.Get(entryURL, &dummy)) {\\n+      // new item, append to our results and put it in our hash table.\\n+      nsCAutoString faviconSpec;\\n+      faviconService->GetFaviconSpecForIconString(\\n+        NS_ConvertUTF16toUTF8(entryFavicon), faviconSpec);\\n+      rv = mCurrentResult->AppendMatch(entryURL, entryTitle, \\n+        NS_ConvertUTF8toUTF16(faviconSpec), itemId ? NS_LITERAL_STRING(\\\"bookmark\\\") : NS_LITERAL_STRING(\\\"favicon\\\"));\\n+      NS_ENSURE_SUCCESS(rv, rv);\\n \\n-    for (i = 1; i < matches.Length(); i ++) {\\n-      // only add ones that are NOT the same as the previous one. It's possible\\n-      // to get duplicates from the queries.\\n-      if (!matches[i].url.Equals(matches[i-1].url)) {\\n-        faviconService->GetFaviconSpecForIconString(\\n-          NS_ConvertUTF16toUTF8(matches[i].image), faviconSpec);\\n-        rv = aResult->AppendMatch(matches[i].url, matches[i].title, \\n-                                  NS_ConvertUTF8toUTF16(faviconSpec),  \\n-                                  NS_LITERAL_STRING(\\\"favicon\\\"));\\n-        NS_ENSURE_SUCCESS(rv, rv);\\n-      }\\n+      mCurrentResultURLs.Put(entryURL, PR_TRUE);\\n     }\\n   }\\n+\\n   return NS_OK;\\n }\\n \\n@@ -556,177 +441,3 @@ nsNavHistory::OnValueRemoved(nsIAutoCompleteSimpleResult* aResult,\\n \\n   return NS_OK;\\n }\\n-\\n-// nsNavHistory::AutoCompleteQueryOnePrefix\\n-//\\n-//    The values in aExcludePrefixes are indices into mAutoCompletePrefixes\\n-//    of prefixes to exclude during this query. For example, if I type\\n-//    \\\"ht\\\" this function will be called to match everything starting with\\n-//    \\\"ht\\\" EXCEPT \\\"http://\\\" and \\\"https://\\\".\\n-\\n-nsresult\\n-nsNavHistory::AutoCompleteQueryOnePrefix(const nsString& aSearchString,\\n-    const nsTArray<PRInt32>& aExcludePrefixes,\\n-    PRInt32 aPriorityDelta,\\n-    nsTArray<AutoCompleteIntermediateResult>* aResult)\\n-{\\n-  // All URL queries are in UTF-8. Compute the beginning (inclusive) and\\n-  // ending (exclusive) of the range of URLs to include when compared\\n-  // using strcmp (which is what sqlite does).\\n-  nsCAutoString beginQuery = NS_ConvertUTF16toUTF8(aSearchString);\\n-  if (beginQuery.IsEmpty())\\n-    return NS_OK;\\n-  nsCAutoString endQuery = beginQuery;\\n-  unsigned char maxChar[6] = { 0xfd, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf };\\n-  endQuery.Append(reinterpret_cast<const char*>(maxChar), 6);\\n-\\n-  nsTArray<nsCString> ranges;\\n-  if (aExcludePrefixes.Length() > 0) {\\n-    // we've been requested to include holes in our range, sort these ranges\\n-    ranges.AppendElement(beginQuery);\\n-    for (PRUint32 i = 0; i < aExcludePrefixes.Length(); i ++) {\\n-      nsCAutoString thisPrefix = NS_ConvertUTF16toUTF8(\\n-          mAutoCompletePrefixes[aExcludePrefixes[i]].prefix);\\n-      ranges.AppendElement(thisPrefix);\\n-      thisPrefix.Append(reinterpret_cast<const char*>(maxChar), 6);\\n-      ranges.AppendElement(thisPrefix);\\n-    }\\n-    ranges.AppendElement(endQuery);\\n-    ranges.Sort();\\n-  } else {\\n-    // simple range with no holes\\n-    ranges.AppendElement(beginQuery);\\n-    ranges.AppendElement(endQuery);\\n-  }\\n-\\n-  NS_ASSERTION(ranges.Length() % 2 == 0, \\\"Ranges should be pairs!\\\");\\n-\\n-  // The nested select expands to nonzero when the item is bookmarked.\\n-  // It might be nice to also select hidden bookmarks (unvisited) but that\\n-  // made this statement more complicated and should be an unusual case.\\n-  nsresult rv;\\n-  for (PRUint32 range = 0; range < ranges.Length() - 1; range += 2) {\\n-    mozStorageStatementScoper scoper(mDBAutoCompleteQuery);\\n-\\n-    rv = mDBAutoCompleteQuery->BindUTF8StringParameter(0, ranges[range]);\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n-    rv = mDBAutoCompleteQuery->BindUTF8StringParameter(1, ranges[range + 1]);\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-    PRBool hasMore;\\n-    nsAutoString url, title, image;\\n-    while (NS_SUCCEEDED(mDBAutoCompleteQuery->ExecuteStep(&hasMore)) && hasMore) {\\n-      mDBAutoCompleteQuery->GetString(0, url);\\n-      mDBAutoCompleteQuery->GetString(1, title);\\n-      PRInt32 visitCount = mDBAutoCompleteQuery->AsInt32(2);\\n-      PRInt32 priority = ComputeAutoCompletePriority(url, visitCount,\\n-          mDBAutoCompleteQuery->AsInt32(3) > 0,\\n-          mDBAutoCompleteQuery->AsInt32(4) > 0) + aPriorityDelta;\\n-      mDBAutoCompleteQuery->GetString(5, image);\\n-      aResult->AppendElement(AutoCompleteIntermediateResult(\\n-          url, title, image, visitCount, priority));\\n-    }\\n-  }\\n-  return NS_OK;\\n-}\\n-\\n-\\n-// nsNavHistory::AutoCompleteGetPrefixLength\\n-\\n-PRInt32\\n-nsNavHistory::AutoCompleteGetPrefixLength(const nsString& aSpec)\\n-{\\n-  for (PRUint32 i = 0; i < mAutoCompletePrefixes.Length(); ++i) {\\n-    if (StringBeginsWith(aSpec, mAutoCompletePrefixes[i].prefix))\\n-      return mAutoCompletePrefixes[i].prefix.Length();\\n-  }\\n-  return 0; // no prefix\\n-}\\n-\\n-\\n-// ComputeAutoCompletePriority\\n-//\\n-//    Favor websites and webpaths more than webpages by boosting\\n-//    their visit counts.  This assumes that URLs have been normalized,\\n-//    appending a trailing '/'.\\n-//\\n-//    We use addition to boost the visit count rather than multiplication\\n-//    since we want URLs with large visit counts to remain pretty much\\n-//    in raw visit count order - we assume the user has visited these urls\\n-//    often for a reason and there shouldn't be a problem with putting them\\n-//    high in the autocomplete list regardless of whether they are sites/\\n-//    paths or pages.  However for URLs visited only a few times, sites\\n-//    & paths should be presented before pages since they are generally\\n-//    more likely to be visited again.\\n-\\n-PRInt32\\n-ComputeAutoCompletePriority(const nsAString& aUrl, PRInt32 aVisitCount,\\n-                            PRBool aWasTyped, PRBool aIsBookmarked)\\n-{\\n-  PRInt32 aPriority = aVisitCount;\\n-\\n-  if (!aUrl.IsEmpty()) {\\n-    // url is a site/path if it has a trailing slash\\n-    if (aUrl.Last() == PRUnichar('/'))\\n-      aPriority += AUTOCOMPLETE_NONPAGE_VISIT_COUNT_BOOST;\\n-  }\\n-\\n-  if (aWasTyped)\\n-    aPriority += AUTOCOMPLETE_TYPED_BOOST;\\n-  if (aIsBookmarked)\\n-    aPriority += AUTOCOMPLETE_BOOKMARKED_BOOST;\\n-\\n-  return aPriority;\\n-}\\n-\\n-\\n-// NormalizeAutocompleteInput\\n-\\n-nsresult NormalizeAutocompleteInput(const nsAString& aInput,\\n-                                    nsString& aOutput)\\n-{\\n-  nsresult rv;\\n-\\n-  if (aInput.IsEmpty()) {\\n-    aOutput.Truncate();\\n-    return NS_OK;\\n-  }\\n-  nsCAutoString input = NS_ConvertUTF16toUTF8(aInput);\\n-\\n-  nsCOMPtr<nsIURI> uri;\\n-  rv = NS_NewURI(getter_AddRefs(uri), input);\\n-  PRBool isSchemeAdded = PR_FALSE;\\n-  if (NS_FAILED(rv)) {\\n-    // it may have failed because there is no scheme, prepend one\\n-    isSchemeAdded = PR_TRUE;\\n-    input = NS_LITERAL_CSTRING(\\\"http://\\\") + input;\\n-\\n-    rv = NS_NewURI(getter_AddRefs(uri), input);\\n-    if (NS_FAILED(rv))\\n-      return rv; // still not valid, can't autocomplete this URL\\n-  }\\n-\\n-  nsCAutoString spec;\\n-  rv = uri->GetSpec(spec);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-  if (spec.IsEmpty())\\n-    return NS_OK; // should never happen but we assume it's not empty below, so check\\n-\\n-  aOutput = NS_ConvertUTF8toUTF16(spec);\\n-\\n-  // trim the \\\"http://\\\" scheme if we added it\\n-  if (isSchemeAdded) {\\n-    NS_ASSERTION(aOutput.Length() > 7, \\\"String impossibly short\\\");\\n-    aOutput = Substring(aOutput, 7);\\n-  }\\n-\\n-  // it may have appended a slash, get rid of it\\n-  // example: input was \\\"http://www.mozil\\\" the URI spec will be\\n-  // \\\"http://www.mozil/\\\" which is obviously wrong to complete against.\\n-  // However, it won't always append a slash, for example, for the input\\n-  // \\\"http://www.mozilla.org/supp\\\"\\n-  if (input[input.Length() - 1] != '/' && aOutput[aOutput.Length() - 1] == '/')\\n-    aOutput.Truncate(aOutput.Length() - 1);\\n-\\n-  return NS_OK;\\n-}\\n\""}