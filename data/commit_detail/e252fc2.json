{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Base252fc2\""},"diff":"\"e252fc2 Somewhat reduce the amount of memory an nsPrincipal allocates in the common case.  Bug 397733, r+sr+a=jst\\ndiff --git a/caps/include/nsJSPrincipals.h b/caps/include/nsJSPrincipals.h\\nindex 1bc0173..782ac02 100644\\n--- a/caps/include/nsJSPrincipals.h\\n+++ b/caps/include/nsJSPrincipals.h\\n@@ -41,11 +41,13 @@\\n #include \\\"jsapi.h\\\"\\n #include \\\"nsIPrincipal.h\\\"\\n \\n+class nsCString;\\n+\\n struct nsJSPrincipals : JSPrincipals\\n {\\n   static nsresult Startup();\\n   nsJSPrincipals();\\n-  nsresult Init(nsIPrincipal* aPrincipal, const char *aCodebase);\\n+  nsresult Init(nsIPrincipal* aPrincipal, const nsCString& aCodebase);\\n   ~nsJSPrincipals(void);\\n \\n   nsIPrincipal *nsIPrincipalPtr; // [WEAK] it owns us.\\ndiff --git a/caps/include/nsPrincipal.h b/caps/include/nsPrincipal.h\\nindex 2f0c599..a4e5ad4 100755\\n--- a/caps/include/nsPrincipal.h\\n+++ b/caps/include/nsPrincipal.h\\n@@ -103,7 +103,7 @@ public:\\n protected:\\n   nsJSPrincipals mJSPrincipals;\\n   nsTArray< nsAutoPtr<nsHashtable> > mAnnotations;\\n-  nsHashtable mCapabilities;\\n+  nsHashtable* mCapabilities;\\n   nsCString mPrefName;\\n   static PRInt32 sCapabilitiesOrdinal;\\n \\ndiff --git a/caps/src/nsJSPrincipals.cpp b/caps/src/nsJSPrincipals.cpp\\nindex efd471c..0180d9a 100644\\n--- a/caps/src/nsJSPrincipals.cpp\\n+++ b/caps/src/nsJSPrincipals.cpp\\n@@ -47,6 +47,7 @@\\n #include \\\"nsIJSRuntimeService.h\\\"\\n #include \\\"nsIServiceManager.h\\\"\\n #include \\\"nsMemory.h\\\"\\n+#include \\\"nsStringBuffer.h\\\"\\n \\n JS_STATIC_DLL_CALLBACK(void *)\\n nsGetPrincipalArray(JSContext *cx, JSPrincipals *prin)\\n@@ -198,7 +199,7 @@ nsJSPrincipals::nsJSPrincipals()\\n }\\n \\n nsresult\\n-nsJSPrincipals::Init(nsIPrincipal *aPrincipal, const char *aCodebase)\\n+nsJSPrincipals::Init(nsIPrincipal *aPrincipal, const nsCString& aCodebase)\\n {\\n     if (nsIPrincipalPtr) {\\n         NS_ERROR(\\\"Init called twice!\\\");\\n@@ -206,15 +207,30 @@ nsJSPrincipals::Init(nsIPrincipal *aPrincipal, const char *aCodebase)\\n     }\\n \\n     nsIPrincipalPtr = aPrincipal;\\n-    codebase = PL_strdup(aCodebase);\\n-    if (!codebase)\\n-        return NS_ERROR_OUT_OF_MEMORY;\\n+    nsStringBuffer* buf = nsStringBuffer::FromString(aCodebase);\\n+    char* data;\\n+    if (buf) {\\n+        buf->AddRef();\\n+        data = static_cast<char*>(buf->Data());\\n+    } else {\\n+        PRUint32 len = aCodebase.Length();\\n+        buf = nsStringBuffer::Alloc(len + 1); // addrefs\\n+        if (!buf) {\\n+            return NS_ERROR_OUT_OF_MEMORY;\\n+        }\\n+        data = static_cast<char*>(buf->Data());\\n+        memcpy(data, aCodebase.get(), len);\\n+        data[len] = '\\\\0';\\n+    }\\n+    \\n+    codebase = data;\\n \\n     return NS_OK;\\n }\\n \\n nsJSPrincipals::~nsJSPrincipals()\\n {\\n-    if (codebase)\\n-        PL_strfree(codebase);\\n+    if (codebase) {\\n+        nsStringBuffer::FromData(codebase)->Release();\\n+    }\\n }\\ndiff --git a/caps/src/nsNullPrincipal.cpp b/caps/src/nsNullPrincipal.cpp\\nindex 6979582..f66f7d5 100644\\n--- a/caps/src/nsNullPrincipal.cpp\\n+++ b/caps/src/nsNullPrincipal.cpp\\n@@ -90,6 +90,8 @@ nsNullPrincipal::~nsNullPrincipal()\\n {\\n }\\n \\n+#define NS_NULLPRINCIPAL_PREFIX NS_NULLPRINCIPAL_SCHEME \\\":\\\"\\n+\\n nsresult\\n nsNullPrincipal::Init()\\n {\\n@@ -106,15 +108,21 @@ nsNullPrincipal::Init()\\n   char* chars = id.ToString();\\n   NS_ENSURE_TRUE(chars, NS_ERROR_OUT_OF_MEMORY);\\n \\n-  nsCAutoString str(NS_NULLPRINCIPAL_SCHEME \\\":\\\");\\n-  PRUint32 prefixLen = str.Length();\\n   PRUint32 suffixLen = strlen(chars);\\n+  PRUint32 prefixLen = NS_ARRAY_LENGTH(NS_NULLPRINCIPAL_PREFIX) - 1;\\n+\\n+  // Use an nsCString so we only do the allocation once here and then share\\n+  // with nsJSPrincipals\\n+  nsCString str;\\n+  str.SetCapacity(prefixLen + suffixLen);\\n \\n+  str.Append(NS_NULLPRINCIPAL_PREFIX);\\n   str.Append(chars);\\n \\n   PR_Free(chars);\\n   \\n   if (str.Length() != prefixLen + suffixLen) {\\n+    NS_WARNING(\\\"Out of memory allocating null-principal URI\\\");\\n     return NS_ERROR_OUT_OF_MEMORY;\\n   }\\n \\n@@ -129,7 +137,7 @@ nsNullPrincipal::Init()\\n \\n   NS_TryToSetImmutable(mURI);\\n \\n-  return mJSPrincipals.Init(this, str.get());\\n+  return mJSPrincipals.Init(this, str);\\n }\\n \\n /**\\ndiff --git a/caps/src/nsPrincipal.cpp b/caps/src/nsPrincipal.cpp\\nindex 05b68c5..f279eff 100755\\n--- a/caps/src/nsPrincipal.cpp\\n+++ b/caps/src/nsPrincipal.cpp\\n@@ -103,7 +103,7 @@ nsPrincipal::Release()\\n }\\n \\n nsPrincipal::nsPrincipal()\\n-  : mCapabilities(7),\\n+  : mCapabilities(nsnull),\\n     mSecurityPolicy(nsnull),\\n     mTrusted(PR_FALSE),\\n     mInitialized(PR_FALSE),\\n@@ -134,14 +134,14 @@ nsPrincipal::Init(const nsACString& aCertFingerprint,\\n   if (!aCertFingerprint.IsEmpty()) {\\n     rv = SetCertificate(aCertFingerprint, aSubjectName, aPrettyName, aCert);\\n     if (NS_SUCCEEDED(rv)) {\\n-      rv = mJSPrincipals.Init(this, mCert->fingerprint.get());\\n+      rv = mJSPrincipals.Init(this, mCert->fingerprint);\\n     }\\n   }\\n   else {\\n     nsCAutoString spec;\\n     rv = mCodebase->GetSpec(spec);\\n     if (NS_SUCCEEDED(rv)) {\\n-      rv = mJSPrincipals.Init(this, spec.get());\\n+      rv = mJSPrincipals.Init(this, spec);\\n     }\\n   }\\n \\n@@ -153,6 +153,7 @@ nsPrincipal::Init(const nsACString& aCertFingerprint,\\n nsPrincipal::~nsPrincipal(void)\\n {\\n   SetSecurityPolicy(nsnull); \\n+  delete mCapabilities;\\n }\\n \\n NS_IMETHODIMP\\n@@ -309,11 +310,13 @@ NS_IMETHODIMP\\n nsPrincipal::CanEnableCapability(const char *capability, PRInt16 *result)\\n {\\n   // If this principal is marked invalid, can't enable any capabilities\\n-  nsCStringKey invalidKey(sInvalid);\\n-  if (mCapabilities.Exists(&invalidKey)) {\\n-    *result = nsIPrincipal::ENABLE_DENIED;\\n+  if (mCapabilities) {\\n+    nsCStringKey invalidKey(sInvalid);\\n+    if (mCapabilities->Exists(&invalidKey)) {\\n+      *result = nsIPrincipal::ENABLE_DENIED;\\n \\n-    return NS_OK;\\n+      return NS_OK;\\n+    }\\n   }\\n \\n   if (!mCert && !mTrusted) {\\n@@ -353,7 +356,8 @@ nsPrincipal::CanEnableCapability(const char *capability, PRInt16 *result)\\n     PRInt32 len = space ? space - start : strlen(start);\\n     nsCAutoString capString(start, len);\\n     nsCStringKey key(capString);\\n-    PRInt16 value = (PRInt16)NS_PTR_TO_INT32(mCapabilities.Get(&key));\\n+    PRInt16 value =\\n+      mCapabilities ? (PRInt16)NS_PTR_TO_INT32(mCapabilities->Get(&key)) : 0;\\n     if (value == 0 || value == nsIPrincipal::ENABLE_UNKNOWN) {\\n       // We don't know whether we can enable this capability,\\n       // so we should ask the user.\\n@@ -379,14 +383,18 @@ nsPrincipal::SetCanEnableCapability(const char *capability,\\n                                     PRInt16 canEnable)\\n {\\n   // If this principal is marked invalid, can't enable any capabilities\\n+  if (!mCapabilities) {\\n+    mCapabilities = new nsHashtable(7);  // XXXbz gets bumped up to 16 anyway\\n+    NS_ENSURE_TRUE(mCapabilities, NS_ERROR_OUT_OF_MEMORY);\\n+  }\\n \\n   nsCStringKey invalidKey(sInvalid);\\n-  if (mCapabilities.Exists(&invalidKey)) {\\n+  if (mCapabilities->Exists(&invalidKey)) {\\n     return NS_OK;\\n   }\\n \\n   if (PL_strcmp(capability, sInvalid) == 0) {\\n-    mCapabilities.Reset();\\n+    mCapabilities->Reset();\\n   }\\n \\n   const char *start = capability;\\n@@ -395,7 +403,7 @@ nsPrincipal::SetCanEnableCapability(const char *capability,\\n     int len = space ? space - start : strlen(start);\\n     nsCAutoString capString(start, len);\\n     nsCStringKey key(capString);\\n-    mCapabilities.Put(&key, NS_INT32_TO_PTR(canEnable));\\n+    mCapabilities->Put(&key, NS_INT32_TO_PTR(canEnable));\\n     if (!space) {\\n       break;\\n     }\\n@@ -667,7 +675,7 @@ nsPrincipal::InitFromPersistent(const char* aPrefName,\\n                                 PRBool aIsCert,\\n                                 PRBool aTrusted)\\n {\\n-  NS_PRECONDITION(mCapabilities.Count() == 0,\\n+  NS_PRECONDITION(!mCapabilities || mCapabilities->Count() == 0,\\n                   \\\"mCapabilities was already initialized?\\\");\\n   NS_PRECONDITION(mAnnotations.Length() == 0,\\n                   \\\"mAnnotations was already initialized?\\\");\\n@@ -699,7 +707,7 @@ nsPrincipal::InitFromPersistent(const char* aPrefName,\\n     mOrigin = nsnull;\\n   }\\n \\n-  rv = mJSPrincipals.Init(this, aToken.get());\\n+  rv = mJSPrincipals.Init(this, aToken);\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n   //-- Save the preference name\\n@@ -836,10 +844,12 @@ nsPrincipal::GetPreferences(char** aPrefName, char** aID,\\n \\n   //-- Capabilities\\n   nsCAutoString grantedListStr, deniedListStr;\\n-  CapabilityList capList = CapabilityList();\\n-  capList.granted = &grantedListStr;\\n-  capList.denied = &deniedListStr;\\n-  mCapabilities.Enumerate(AppendCapability, (void*)&capList);\\n+  if (mCapabilities) {\\n+    CapabilityList capList = CapabilityList();\\n+    capList.granted = &grantedListStr;\\n+    capList.denied = &deniedListStr;\\n+    mCapabilities->Enumerate(AppendCapability, (void*)&capList);\\n+  }\\n \\n   if (!grantedListStr.IsEmpty()) {\\n     grantedListStr.Truncate(grantedListStr.Length() - 1);\\n@@ -910,12 +920,9 @@ nsPrincipal::Read(nsIObjectInputStream* aStream)\\n   PRBool hasCapabilities;\\n   nsresult rv = aStream->ReadBoolean(&hasCapabilities);\\n   if (NS_SUCCEEDED(rv) && hasCapabilities) {\\n-    // We want to use one of the nsHashtable constructors, but don't want to\\n-    // generally have mCapabilities be a pointer... and nsHashtable has no\\n-    // reasonable copy-constructor.  Placement-new to the rescue!\\n-    mCapabilities.~nsHashtable();\\n-    new (&mCapabilities) nsHashtable(aStream, ReadAnnotationEntry,\\n-                                     FreeAnnotationEntry, &rv);\\n+    mCapabilities = new nsHashtable(aStream, ReadAnnotationEntry,\\n+                                    FreeAnnotationEntry, &rv);\\n+    NS_ENSURE_TRUE(mCapabilities, NS_ERROR_OUT_OF_MEMORY);\\n   }\\n \\n   if (NS_FAILED(rv)) {\\n@@ -1008,10 +1015,10 @@ nsPrincipal::Write(nsIObjectOutputStream* aStream)\\n   // mAnnotations is transient data associated to specific JS stack frames.  We\\n   // don't want to serialize that.\\n   \\n-  PRBool hasCapabilities = (mCapabilities.Count() > 0);\\n+  PRBool hasCapabilities = (mCapabilities && mCapabilities->Count() > 0);\\n   nsresult rv = aStream->WriteBoolean(hasCapabilities);\\n   if (NS_SUCCEEDED(rv) && hasCapabilities) {\\n-    rv = mCapabilities.Write(aStream, WriteScalarValue);\\n+    rv = mCapabilities->Write(aStream, WriteScalarValue);\\n   }\\n \\n   if (NS_FAILED(rv)) {\\ndiff --git a/caps/src/nsSystemPrincipal.cpp b/caps/src/nsSystemPrincipal.cpp\\nindex 47bbfb1..e384742 100644\\n--- a/caps/src/nsSystemPrincipal.cpp\\n+++ b/caps/src/nsSystemPrincipal.cpp\\n@@ -280,10 +280,20 @@ nsSystemPrincipal::nsSystemPrincipal()\\n {\\n }\\n \\n+#define SYSTEM_PRINCIPAL_SPEC \\\"[System Principal]\\\"\\n+\\n nsresult\\n nsSystemPrincipal::Init()\\n {\\n-    return mJSPrincipals.Init(this, \\\"[System Principal]\\\"); \\n+    // Use an nsCString so we only do the allocation once here and then\\n+    // share with nsJSPrincipals\\n+    nsCString str(SYSTEM_PRINCIPAL_SPEC);\\n+    if (!str.EqualsLiteral(SYSTEM_PRINCIPAL_SPEC)) {\\n+        NS_WARNING(\\\"Out of memory initializing system principal\\\");\\n+        return NS_ERROR_OUT_OF_MEMORY;\\n+    }\\n+    \\n+    return mJSPrincipals.Init(this, str);\\n }\\n \\n nsSystemPrincipal::~nsSystemPrincipal(void)\\n\""}