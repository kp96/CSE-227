{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas01fa406\""},"diff":"\"01fa406 Bug 333236: merge sweep and free phases in GC. r=brendan\\ndiff --git a/js/src/jsatom.c b/js/src/jsatom.c\\nindex 547b26f..2897b85 100644\\n--- a/js/src/jsatom.c\\n+++ b/js/src/jsatom.c\\n@@ -397,6 +397,7 @@ js_string_uninterner(JSDHashTable *table, JSDHashEntryHdr *hdr,\\n {\\n     JSAtomHashEntry *entry = TO_ATOM_ENTRY(hdr);\\n     JSRuntime *rt = (JSRuntime *)arg;\\n+    JSString *str;\\n \\n     /*\\n      * Any string entry that remains at this point must be initialized, as the\\n@@ -404,7 +405,10 @@ js_string_uninterner(JSDHashTable *table, JSDHashEntryHdr *hdr,\\n      */\\n     JS_ASSERT(IS_STRING_TABLE(table));\\n     JS_ASSERT(entry->keyAndFlags != 0);\\n-    js_FinalizeStringRT(rt, (JSString *)ATOM_ENTRY_KEY(entry));\\n+    str = (JSString *)ATOM_ENTRY_KEY(entry);\\n+\\n+    /* Pass null as context. */\\n+    js_FinalizeStringRT(rt, str, GCF_TYPEMASK & *js_GetGCThingFlags(str), NULL);\\n     return JS_DHASH_NEXT;\\n }\\n \\ndiff --git a/js/src/jscntxt.c b/js/src/jscntxt.c\\nindex d4db418..74966e6 100644\\n--- a/js/src/jscntxt.c\\n+++ b/js/src/jscntxt.c\\n@@ -414,7 +414,7 @@ js_DestroyContext(JSContext *cx, JSDestroyContextMode mode)\\n \\n         /*\\n          * Free unit string storage only after the last GC has completed, so\\n-         * that js_FinalizeStringRT can detect unit strings and avoid calling\\n+         * that js_FinalizeString can detect unit strings and avoid calling\\n          * free on their chars storage.\\n          */\\n         free(rt->unitStrings);\\ndiff --git a/js/src/jsfun.c b/js/src/jsfun.c\\nindex 64f7be1..ade1ef4 100644\\n--- a/js/src/jsfun.c\\n+++ b/js/src/jsfun.c\\n@@ -2168,17 +2168,12 @@ out:\\n void\\n js_FinalizeFunction(JSContext *cx, JSFunction *fun)\\n {\\n-    JSScript *script;\\n-\\n     /*\\n      * Null-check of i.script is required since the parser sets interpreted\\n      * very early.\\n      */\\n-    if (FUN_INTERPRETED(fun) && fun->u.i.script) {\\n-        script = fun->u.i.script;\\n-        fun->u.i.script = NULL;\\n-        js_DestroyScript(cx, script);\\n-    }\\n+    if (FUN_INTERPRETED(fun) && fun->u.i.script)\\n+        js_DestroyScript(cx, fun->u.i.script);\\n }\\n \\n JSObject *\\ndiff --git a/js/src/jsgc.c b/js/src/jsgc.c\\nindex e5480d9..cebee5d 100644\\n--- a/js/src/jsgc.c\\n+++ b/js/src/jsgc.c\\n@@ -816,37 +816,6 @@ js_IsAboutToBeFinalized(JSContext *cx, void *thing)\\n     return !(flags & (GCF_MARK | GCF_LOCK | GCF_FINAL));\\n }\\n \\n-typedef void (*GCFinalizeOp)(JSContext *cx, JSGCThing *thing);\\n-\\n-#ifndef DEBUG\\n-# define js_FinalizeDouble       NULL\\n-#endif\\n-\\n-#if !JS_HAS_XML_SUPPORT\\n-# define js_FinalizeXMLNamespace NULL\\n-# define js_FinalizeXMLQName     NULL\\n-# define js_FinalizeXML          NULL\\n-#endif\\n-\\n-static GCFinalizeOp gc_finalizers[GCX_NTYPES] = {\\n-    (GCFinalizeOp) js_FinalizeObject,           /* GCX_OBJECT */\\n-    (GCFinalizeOp) js_FinalizeString,           /* GCX_STRING */\\n-    (GCFinalizeOp) js_FinalizeDouble,           /* GCX_DOUBLE */\\n-    (GCFinalizeOp) js_FinalizeFunction,         /* GCX_FUNCTION */\\n-    (GCFinalizeOp) js_FinalizeXMLNamespace,     /* GCX_NAMESPACE */\\n-    (GCFinalizeOp) js_FinalizeXMLQName,         /* GCX_QNAME */\\n-    (GCFinalizeOp) js_FinalizeXML,              /* GCX_XML */\\n-    NULL,                                       /* unused */\\n-    NULL,                                       /* GCX_EXTERNAL_STRING */\\n-    NULL,\\n-    NULL,\\n-    NULL,\\n-    NULL,\\n-    NULL,\\n-    NULL,\\n-    NULL\\n-};\\n-\\n #ifdef DEBUG\\n static const char newborn_external_string[] = \\\"newborn external string\\\";\\n \\n@@ -870,21 +839,6 @@ static const char *gc_typenames[GCX_NTYPES] = {\\n };\\n #endif\\n \\n-intN\\n-js_ChangeExternalStringFinalizer(JSStringFinalizeOp oldop,\\n-                                 JSStringFinalizeOp newop)\\n-{\\n-    uintN i;\\n-\\n-    for (i = GCX_EXTERNAL_STRING; i < GCX_NTYPES; i++) {\\n-        if (gc_finalizers[i] == (GCFinalizeOp) oldop) {\\n-            gc_finalizers[i] = (GCFinalizeOp) newop;\\n-            return (intN) i;\\n-        }\\n-    }\\n-    return -1;\\n-}\\n-\\n /* This is compatible with JSDHashEntryStub. */\\n typedef struct JSGCRootHashEntry {\\n     JSDHashEntryHdr hdr;\\n@@ -2390,11 +2344,10 @@ js_GC(JSContext *cx, JSGCInvocationKind gckind)\\n     uintN i, type;\\n     JSTracer trc;\\n     uint32 thingSize, indexLimit;\\n-    JSGCArenaInfo *a, **ap;\\n+    JSGCArenaInfo *a, **ap, *emptyArenas;\\n     uint8 flags, *flagp;\\n     JSGCThing *thing, *freeList;\\n     JSGCArenaList *arenaList;\\n-    GCFinalizeOp finalizer;\\n     JSBool allClear;\\n #ifdef JS_THREADSAFE\\n     uint32 requestDebit;\\n@@ -2647,91 +2600,70 @@ restart:\\n      * of the file guarantees that JSString and jsdouble instances are\\n      * allocated from a different list.\\n      */\\n+    emptyArenas = NULL;\\n     for (i = 0; i < GC_NUM_FREELISTS; i++) {\\n         arenaList = &rt->gcArenaList[i == 0\\n                                      ? GC_FREELIST_INDEX(sizeof(JSObject))\\n                                      : i == GC_FREELIST_INDEX(sizeof(JSObject))\\n                                      ? 0\\n                                      : i];\\n-        a = arenaList->last;\\n-        if (!a)\\n-            continue;\\n-\\n-        thingSize = arenaList->thingSize;\\n-        indexLimit = THINGS_PER_ARENA(thingSize);\\n-        JS_ASSERT(arenaList->lastCount > 0);\\n-        flagp = THING_FLAGP(a, arenaList->lastCount - 1);\\n-        for (;;) {\\n-            JS_ASSERT(a->prevUntracedPage == 0);\\n-            JS_ASSERT(a->untracedThings == 0);\\n-            do {\\n-                flags = *flagp;\\n-                if (flags & GCF_MARK) {\\n-                    *flagp &= ~GCF_MARK;\\n-                } else if (!(flags & (GCF_LOCK | GCF_FINAL))) {\\n-                    /* Call the finalizer with GCF_FINAL ORed into flags. */\\n-                    type = flags & GCF_TYPEMASK;\\n-                    finalizer = gc_finalizers[type];\\n-                    if (finalizer) {\\n-                        thing = (JSGCThing *) FLAGP_TO_THING(flagp, thingSize);\\n-                        *flagp = (uint8)(flags | GCF_FINAL);\\n-                        if (type >= GCX_EXTERNAL_STRING)\\n-                            js_PurgeDeflatedStringCache(rt, (JSString *)thing);\\n-                        finalizer(cx, thing);\\n-                    }\\n-\\n-                    /* Set flags to GCF_FINAL, signifying that thing is free. */\\n-                    *flagp = GCF_FINAL;\\n-                }\\n-            } while (++flagp != THING_FLAGS_END(a));\\n-            a = a->prev;\\n-            if (!a)\\n-                break;\\n-            flagp = THING_FLAGP(a, indexLimit - 1);\\n-        }\\n-    }\\n-\\n-    /*\\n-     * Sweep the runtime's property tree after finalizing objects, in case any\\n-     * had watchpoints referencing tree nodes.\\n-     */\\n-    js_SweepScopeProperties(cx);\\n-\\n-    /*\\n-     * Sweep script filenames after sweeping functions in the generic loop\\n-     * above. In this way when a scripted function's finalizer destroys the\\n-     * script and calls rt->destroyScriptHook, the hook can still access the\\n-     * script's filename. See bug 323267.\\n-     */\\n-    js_SweepScriptFilenames(rt);\\n-\\n-    /*\\n-     * Free phase.\\n-     * Free any unused arenas and rebuild the JSGCThing freelist.\\n-     */\\n-    for (i = 0; i < GC_NUM_FREELISTS; i++) {\\n-        arenaList = &rt->gcArenaList[i];\\n         ap = &arenaList->last;\\n         if (!(a = *ap))\\n             continue;\\n \\n-        allClear = JS_TRUE;\\n+        JS_ASSERT(arenaList->lastCount > 0);\\n         arenaList->freeList = NULL;\\n         freeList = NULL;\\n+        METER(arenaList->stats.nthings = 0);\\n+        METER(arenaList->stats.freelen = 0);\\n         thingSize = arenaList->thingSize;\\n         indexLimit = THINGS_PER_ARENA(thingSize);\\n-        JS_ASSERT(arenaList->lastCount > 0);\\n         flagp = THING_FLAGP(a, arenaList->lastCount - 1);\\n-        METER(arenaList->stats.nthings = 0);\\n-        METER(arenaList->stats.freelen = 0);\\n         for (;;) {\\n             METER(size_t nfree = 0);\\n+\\n+            JS_ASSERT(a->prevUntracedPage == 0);\\n+            JS_ASSERT(a->untracedThings == 0);\\n+            allClear = JS_TRUE;\\n             do {\\n-                if (*flagp != GCF_FINAL) {\\n+                flags = *flagp;\\n+                if (flags & (GCF_MARK | GCF_LOCK)) {\\n+                    *flagp &= ~GCF_MARK;\\n                     allClear = JS_FALSE;\\n                     METER(++arenaList->stats.nthings);\\n-                } else {\\n+                } else if (!(flags & GCF_FINAL)) {\\n+                    /* Call the finalizer with GCF_FINAL ORed into flags. */\\n                     thing = (JSGCThing *) FLAGP_TO_THING(flagp, thingSize);\\n+                    *flagp = (uint8)(flags | GCF_FINAL);\\n+                    type = flags & GCF_TYPEMASK;\\n+                    switch (type) {\\n+                      case GCX_OBJECT:\\n+                        js_FinalizeObject(cx, (JSObject *) thing);\\n+                        break;\\n+                      case GCX_DOUBLE:\\n+                        /* Do nothing. */\\n+                        break;\\n+                      case GCX_FUNCTION:\\n+                        js_FinalizeFunction(cx, (JSFunction *) thing);\\n+                        break;\\n+#if JS_HAS_XML_SUPPORT\\n+                      case GCX_NAMESPACE:\\n+                        js_FinalizeXMLNamespace(cx, (JSXMLNamespace *) thing);\\n+                        break;\\n+                      case GCX_QNAME:\\n+                        js_FinalizeXMLQName(cx, (JSXMLQName *) thing);\\n+                        break;\\n+                      case GCX_XML:\\n+                        js_FinalizeXML(cx, (JSXML *) thing);\\n+                        break;\\n+#endif\\n+                      default:\\n+                        JS_ASSERT(type == GCX_STRING ||\\n+                                  type - GCX_EXTERNAL_STRING <\\n+                                  GCX_NTYPES - GCX_EXTERNAL_STRING);\\n+                        js_FinalizeStringRT(rt, (JSString *) thing, type, cx);\\n+                        break;\\n+                    }\\n                     thing->flagp = flagp;\\n                     thing->next = freeList;\\n                     freeList = thing;\\n@@ -2742,7 +2674,7 @@ restart:\\n             if (allClear) {\\n                 /*\\n                  * Forget just assembled free list head for the arena and\\n-                 * destroy the arena itself.\\n+                 * add the arena itself to the destroy list.\\n                  */\\n                 freeList = arenaList->freeList;\\n                 if (a == arenaList->last)\\n@@ -2750,9 +2682,9 @@ restart:\\n                 *ap = a->prev;\\n                 JS_ASSERT(rt->gcBytes >= GC_ARENA_SIZE);\\n                 rt->gcBytes -= GC_ARENA_SIZE;\\n-                DestroyGCArena(rt, a);\\n+                a->prev = emptyArenas;\\n+                emptyArenas = a;\\n             } else {\\n-                allClear = JS_TRUE;\\n                 arenaList->freeList = freeList;\\n                 ap = &a->prev;\\n                 METER(arenaList->stats.freelen += nfree);\\n@@ -2765,6 +2697,30 @@ restart:\\n         }\\n     }\\n \\n+    /*\\n+     * Sweep the runtime's property tree after finalizing objects, in case any\\n+     * had watchpoints referencing tree nodes.\\n+     */\\n+    js_SweepScopeProperties(cx);\\n+\\n+    /*\\n+     * Sweep script filenames after sweeping functions in the generic loop\\n+     * above. In this way when a scripted function's finalizer destroys the\\n+     * script and calls rt->destroyScriptHook, the hook can still access the\\n+     * script's filename. See bug 323267.\\n+     */\\n+    js_SweepScriptFilenames(rt);\\n+\\n+    /*\\n+     * Destroy arenas after we finished the sweeping sofinalizers can safely\\n+     * use js_IsAboutToBeFinalized().\\n+     */\\n+    while (emptyArenas) {\\n+        a = emptyArenas;\\n+        emptyArenas = emptyArenas->prev;\\n+        DestroyGCArena(rt, a);\\n+    }\\n+\\n     if (rt->gcCallback)\\n         (void) rt->gcCallback(cx, JSGC_FINALIZE_END);\\n #ifdef DEBUG_srcnotesize\\ndiff --git a/js/src/jsgc.h b/js/src/jsgc.h\\nindex 66fdad7..eeac04b 100644\\n--- a/js/src/jsgc.h\\n+++ b/js/src/jsgc.h\\n@@ -91,16 +91,16 @@ js_GetGCStringRuntime(JSString *str);\\n #define GC_POKE(cx, oldval) ((cx)->runtime->gcPoke = JSVAL_IS_GCTHING(oldval))\\n #endif\\n \\n-extern intN\\n-js_ChangeExternalStringFinalizer(JSStringFinalizeOp oldop,\\n-                                 JSStringFinalizeOp newop);\\n-\\n extern JSBool\\n js_InitGC(JSRuntime *rt, uint32 maxbytes);\\n \\n extern void\\n js_FinishGC(JSRuntime *rt);\\n \\n+extern intN\\n+js_ChangeExternalStringFinalizer(JSStringFinalizeOp oldop,\\n+                                 JSStringFinalizeOp newop);\\n+\\n extern JSBool\\n js_AddRoot(JSContext *cx, void *rp, const char *name);\\n \\ndiff --git a/js/src/jsobj.c b/js/src/jsobj.c\\nindex 3d30058..d9c69bb 100644\\n--- a/js/src/jsobj.c\\n+++ b/js/src/jsobj.c\\n@@ -2796,7 +2796,6 @@ js_FinalizeObject(JSContext *cx, JSObject *obj)\\n \\n     /* Drop map and free slots. */\\n     js_DropObjectMap(cx, map, obj);\\n-    obj->map = NULL;\\n     FreeSlots(cx, obj);\\n }\\n \\ndiff --git a/js/src/jsstr.c b/js/src/jsstr.c\\nindex b29ef44..ef64715 100644\\n--- a/js/src/jsstr.c\\n+++ b/js/src/jsstr.c\\n@@ -2619,19 +2619,38 @@ js_PurgeDeflatedStringCache(JSRuntime *rt, JSString *str)\\n     JS_RELEASE_LOCK(rt->deflatedStringCacheLock);\\n }\\n \\n-void\\n-js_FinalizeString(JSContext *cx, JSString *str)\\n+static JSStringFinalizeOp str_finalizers[GCX_NTYPES - GCX_EXTERNAL_STRING] = {\\n+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\\n+};\\n+\\n+intN\\n+js_ChangeExternalStringFinalizer(JSStringFinalizeOp oldop,\\n+                                 JSStringFinalizeOp newop)\\n {\\n-    js_FinalizeStringRT(cx->runtime, str);\\n+    uintN i;\\n+\\n+    for (i = 0; i != JS_ARRAY_LENGTH(str_finalizers); i++) {\\n+        if (str_finalizers[i] == oldop) {\\n+            str_finalizers[i] = newop;\\n+            return (intN) i + GCX_EXTERNAL_STRING;\\n+        }\\n+    }\\n+    return -1;\\n }\\n \\n+/*\\n+ * cx is NULL when we are called from js_FinishAtomState to force the\\n+ * finalization of the permanently interned strings.\\n+ */\\n void\\n-js_FinalizeStringRT(JSRuntime *rt, JSString *str)\\n+js_FinalizeStringRT(JSRuntime *rt, JSString *str, uintN gctype, JSContext *cx)\\n {\\n     JSBool valid;\\n+    JSStringFinalizeOp finalizer;\\n \\n     JS_RUNTIME_UNMETER(rt, liveStrings);\\n     if (JSSTRING_IS_DEPENDENT(str)) {\\n+        JS_ASSERT(gctype == GCX_STRING);\\n         /* If JSSTRFLAG_DEPENDENT is set, this string must be valid. */\\n         JS_ASSERT(JSSTRDEP_BASE(str));\\n         JS_RUNTIME_UNMETER(rt, liveDependentStrings);\\n@@ -2642,17 +2661,26 @@ js_FinalizeStringRT(JSRuntime *rt, JSString *str)\\n         if (valid) {\\n             if (IN_UNIT_STRING_SPACE_RT(rt, str->u.chars)) {\\n                 JS_ASSERT(rt->unitStrings[*str->u.chars] == str);\\n+                JS_ASSERT(gctype == GCX_STRING);\\n                 rt->unitStrings[*str->u.chars] = NULL;\\n-            } else {\\n+            } else if (gctype == GCX_STRING) {\\n                 free(str->u.chars);\\n+            } else {\\n+                JS_ASSERT(gctype - GCX_EXTERNAL_STRING <\\n+                          JS_ARRAY_LENGTH(str_finalizers));\\n+                finalizer = str_finalizers[gctype - GCX_EXTERNAL_STRING];\\n+                if (finalizer) {\\n+                    /*\\n+                     * Assume that the finalizer for the permanently interned\\n+                     * string knows how to deal with null context.\\n+                     */\\n+                    finalizer(cx, str);\\n+                }\\n             }\\n         }\\n     }\\n     if (valid)\\n         js_PurgeDeflatedStringCache(rt, str);\\n-#ifdef DEBUG\\n-    memset(str, JS_FREE_PATTERN, sizeof *str);\\n-#endif\\n }\\n \\n JS_FRIEND_API(const char *)\\ndiff --git a/js/src/jsstr.h b/js/src/jsstr.h\\nindex 67452b0..1187e0e 100644\\n--- a/js/src/jsstr.h\\n+++ b/js/src/jsstr.h\\n@@ -406,12 +406,13 @@ js_NewStringCopyN(JSContext *cx, const jschar *s, size_t n);\\n extern JSString *\\n js_NewStringCopyZ(JSContext *cx, const jschar *s);\\n \\n-/* Free the chars held by str when it is finalized by the GC. */\\n-extern void\\n-js_FinalizeString(JSContext *cx, JSString *str);\\n-\\n+/*\\n+ * Free the chars held by str when it is finalized by the GC.\\n+ *\\n+ * This function always needs rt but can live with null cx.\\n+ */\\n extern void\\n-js_FinalizeStringRT(JSRuntime *rt, JSString *str);\\n+js_FinalizeStringRT(JSRuntime *rt, JSString *str, uintN gctype, JSContext *cx);\\n \\n /*\\n  * Convert a value to a printable C string.\\n\""}