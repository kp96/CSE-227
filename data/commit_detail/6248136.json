{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas6248136\""},"diff":"\"6248136 Bug 383673 - mozStorageValueArray only asserts on out of bounds (and other cleanup).  r=sspitzer\\ndiff --git a/storage/src/mozStorageValueArray.cpp b/storage/src/mozStorageValueArray.cpp\\nindex b34fdf5..ff2022d 100644\\n--- a/storage/src/mozStorageValueArray.cpp\\n+++ b/storage/src/mozStorageValueArray.cpp\\n@@ -72,7 +72,8 @@ mozStorageStatementRowValueArray::GetNumEntries(PRUint32 *aLength)\\n NS_IMETHODIMP\\n mozStorageStatementRowValueArray::GetTypeOfIndex(PRUint32 aIndex, PRInt32 *_retval)\\n {\\n-    NS_ASSERTION (aIndex < mNumEntries, \\\"aIndex out of range\\\");\\n+    if (aIndex < 0 || aIndex >= mNumEntries)\\n+        return NS_ERROR_ILLEGAL_VALUE;\\n \\n     int t = sqlite3_column_type (mSqliteStatement, aIndex);\\n     switch (t) {\\n@@ -102,7 +103,8 @@ mozStorageStatementRowValueArray::GetTypeOfIndex(PRUint32 aIndex, PRInt32 *_retv\\n NS_IMETHODIMP\\n mozStorageStatementRowValueArray::GetInt32(PRUint32 aIndex, PRInt32 *_retval)\\n {\\n-    NS_ASSERTION (aIndex < mNumEntries, \\\"aIndex out of range\\\");\\n+    if (aIndex < 0 || aIndex >= mNumEntries)\\n+        return NS_ERROR_ILLEGAL_VALUE;\\n \\n     *_retval = sqlite3_column_int (mSqliteStatement, aIndex);\\n \\n@@ -112,7 +114,8 @@ mozStorageStatementRowValueArray::GetInt32(PRUint32 aIndex, PRInt32 *_retval)\\n NS_IMETHODIMP\\n mozStorageStatementRowValueArray::GetInt64(PRUint32 aIndex, PRInt64 *_retval)\\n {\\n-    NS_ASSERTION (aIndex < mNumEntries, \\\"aIndex out of range\\\");\\n+    if (aIndex < 0 || aIndex >= mNumEntries)\\n+        return NS_ERROR_ILLEGAL_VALUE;\\n \\n     *_retval = sqlite3_column_int64 (mSqliteStatement, aIndex);\\n \\n@@ -122,7 +125,8 @@ mozStorageStatementRowValueArray::GetInt64(PRUint32 aIndex, PRInt64 *_retval)\\n NS_IMETHODIMP\\n mozStorageStatementRowValueArray::GetDouble(PRUint32 aIndex, double *_retval)\\n {\\n-    NS_ASSERTION (aIndex < mNumEntries, \\\"aIndex out of range\\\");\\n+    if (aIndex < 0 || aIndex >= mNumEntries)\\n+        return NS_ERROR_ILLEGAL_VALUE;\\n \\n     *_retval = sqlite3_column_double (mSqliteStatement, aIndex);\\n \\n@@ -132,8 +136,7 @@ mozStorageStatementRowValueArray::GetDouble(PRUint32 aIndex, double *_retval)\\n NS_IMETHODIMP\\n mozStorageStatementRowValueArray::GetUTF8String(PRUint32 aIndex, nsACString &_retval)\\n {\\n-    NS_ASSERTION (aIndex < mNumEntries, \\\"aIndex out of range\\\");\\n-\\n+    // GetTypeOfIndex will check aIndex for us, so we don't have to.\\n     PRInt32 type;\\n     nsresult rv = GetTypeOfIndex (aIndex, &type);\\n     NS_ENSURE_SUCCESS(rv, rv);\\n@@ -152,8 +155,7 @@ mozStorageStatementRowValueArray::GetUTF8String(PRUint32 aIndex, nsACString &_re\\n NS_IMETHODIMP\\n mozStorageStatementRowValueArray::GetString(PRUint32 aIndex, nsAString & _retval)\\n {\\n-    NS_ASSERTION (aIndex < mNumEntries, \\\"aIndex out of range\\\");\\n-\\n+    // GetTypeOfIndex will check aIndex for us, so we don't have to.\\n     PRInt32 type;\\n     nsresult rv = GetTypeOfIndex (aIndex, &type);\\n     NS_ENSURE_SUCCESS(rv, rv);\\n@@ -172,7 +174,8 @@ mozStorageStatementRowValueArray::GetString(PRUint32 aIndex, nsAString & _retval\\n NS_IMETHODIMP\\n mozStorageStatementRowValueArray::GetBlob(PRUint32 aIndex, PRUint32 *aDataSize, PRUint8 **aData)\\n {\\n-    NS_ASSERTION (aIndex < mNumEntries, \\\"aIndex out of range\\\");\\n+    if (aIndex < 0 || aIndex >= mNumEntries)\\n+        return NS_ERROR_ILLEGAL_VALUE;\\n \\n     int blobsize = sqlite3_column_bytes (mSqliteStatement, aIndex);\\n     const void *blob = sqlite3_column_blob (mSqliteStatement, aIndex);\\n@@ -190,10 +193,10 @@ mozStorageStatementRowValueArray::GetBlob(PRUint32 aIndex, PRUint32 *aDataSize,\\n NS_IMETHODIMP\\n mozStorageStatementRowValueArray::GetIsNull(PRUint32 aIndex, PRBool *_retval)\\n {\\n+    // GetTypeOfIndex will check aIndex for us, so we don't have to.\\n     PRInt32 t;\\n     nsresult rv = GetTypeOfIndex (aIndex, &t);\\n-    if (NS_FAILED(rv))\\n-        return rv;\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n \\n     if (t == VALUE_TYPE_NULL)\\n         *_retval = PR_TRUE;\\n@@ -266,7 +269,8 @@ mozStorageArgvValueArray::GetNumEntries(PRUint32 *aLength)\\n NS_IMETHODIMP\\n mozStorageArgvValueArray::GetTypeOfIndex(PRUint32 aIndex, PRInt32 *_retval)\\n {\\n-    NS_ASSERTION (aIndex < mArgc, \\\"aIndex out of range\\\");\\n+    if (aIndex < 0 || aIndex >= mArgc)\\n+        return NS_ERROR_ILLEGAL_VALUE;\\n \\n     int t = sqlite3_value_type (mArgv[aIndex]);\\n     switch (t) {\\n@@ -296,7 +300,8 @@ mozStorageArgvValueArray::GetTypeOfIndex(PRUint32 aIndex, PRInt32 *_retval)\\n NS_IMETHODIMP\\n mozStorageArgvValueArray::GetInt32(PRUint32 aIndex, PRInt32 *_retval)\\n {\\n-    NS_ASSERTION (aIndex < mArgc, \\\"aIndex out of range\\\");\\n+    if (aIndex < 0 || aIndex >= mArgc)\\n+        return NS_ERROR_ILLEGAL_VALUE;\\n \\n     *_retval = sqlite3_value_int (mArgv[aIndex]);\\n \\n@@ -306,7 +311,8 @@ mozStorageArgvValueArray::GetInt32(PRUint32 aIndex, PRInt32 *_retval)\\n NS_IMETHODIMP\\n mozStorageArgvValueArray::GetInt64(PRUint32 aIndex, PRInt64 *_retval)\\n {\\n-    NS_ASSERTION (aIndex < mArgc, \\\"aIndex out of range\\\");\\n+    if (aIndex < 0 || aIndex >= mArgc)\\n+        return NS_ERROR_ILLEGAL_VALUE;\\n \\n     *_retval = sqlite3_value_int64 (mArgv[aIndex]);\\n \\n@@ -316,7 +322,8 @@ mozStorageArgvValueArray::GetInt64(PRUint32 aIndex, PRInt64 *_retval)\\n NS_IMETHODIMP\\n mozStorageArgvValueArray::GetDouble(PRUint32 aIndex, double *_retval)\\n {\\n-    NS_ASSERTION (aIndex < mArgc, \\\"aIndex out of range\\\");\\n+    if (aIndex < 0 || aIndex >= mArgc)\\n+        return NS_ERROR_ILLEGAL_VALUE;\\n \\n     *_retval = sqlite3_value_double (mArgv[aIndex]);\\n \\n@@ -326,7 +333,8 @@ mozStorageArgvValueArray::GetDouble(PRUint32 aIndex, double *_retval)\\n NS_IMETHODIMP\\n mozStorageArgvValueArray::GetUTF8String(PRUint32 aIndex, nsACString & _retval)\\n {\\n-    NS_ASSERTION (aIndex < mArgc, \\\"aIndex out of range\\\");\\n+    if (aIndex < 0 || aIndex >= mArgc)\\n+        return NS_ERROR_ILLEGAL_VALUE;\\n \\n     if (sqlite3_value_type (mArgv[aIndex]) == SQLITE_NULL) {\\n         // null columns get IsVoid set to distinguish them from empty strings\\n@@ -343,7 +351,8 @@ mozStorageArgvValueArray::GetUTF8String(PRUint32 aIndex, nsACString & _retval)\\n NS_IMETHODIMP\\n mozStorageArgvValueArray::GetString(PRUint32 aIndex, nsAString & _retval)\\n {\\n-    NS_ASSERTION (aIndex < mArgc, \\\"aIndex out of range\\\");\\n+    if (aIndex < 0 || aIndex >= mArgc)\\n+        return NS_ERROR_ILLEGAL_VALUE;\\n \\n     if (sqlite3_value_type (mArgv[aIndex]) == SQLITE_NULL) {\\n         // null columns get IsVoid set to distinguish them from empty strings\\n@@ -360,7 +369,8 @@ mozStorageArgvValueArray::GetString(PRUint32 aIndex, nsAString & _retval)\\n NS_IMETHODIMP\\n mozStorageArgvValueArray::GetBlob(PRUint32 aIndex, PRUint32 *aDataSize, PRUint8 **aData)\\n {\\n-    NS_ASSERTION (aIndex < mArgc, \\\"aIndex out of range\\\");\\n+    if (aIndex < 0 || aIndex >= mArgc)\\n+        return NS_ERROR_ILLEGAL_VALUE;\\n \\n     int blobsize = sqlite3_value_bytes (mArgv[aIndex]);\\n     const void *blob = sqlite3_value_blob (mArgv[aIndex]);\\n@@ -379,10 +389,10 @@ mozStorageArgvValueArray::GetBlob(PRUint32 aIndex, PRUint32 *aDataSize, PRUint8\\n NS_IMETHODIMP\\n mozStorageArgvValueArray::GetIsNull(PRUint32 aIndex, PRBool *_retval)\\n {\\n+    // GetTypeOfIndex will check aIndex for us, so we don't have to.\\n     PRInt32 t;\\n     nsresult rv = GetTypeOfIndex (aIndex, &t);\\n-    if (NS_FAILED(rv))\\n-        return rv;\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n \\n     if (t == VALUE_TYPE_NULL)\\n         *_retval = PR_TRUE;\\n\""}