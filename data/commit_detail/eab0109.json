{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Baseab0109\""},"diff":"\"eab0109 Bug 393935 - Crash [@nsProxyObject::LockedFind] due to threads racing, r=brendan\\ndiff --git a/xpcom/proxy/src/nsProxyObjectManager.cpp b/xpcom/proxy/src/nsProxyObjectManager.cpp\\nindex 3d7ba2c..2905c3f 100644\\n--- a/xpcom/proxy/src/nsProxyObjectManager.cpp\\n+++ b/xpcom/proxy/src/nsProxyObjectManager.cpp\\n@@ -148,6 +148,36 @@ nsProxyObjectManager::Create(nsISupports* outer, const nsIID& aIID,\\n     return proxyObjectManager->QueryInterface(aIID, aInstancePtr);\\n }\\n \\n+class nsProxyLockedRefPtr\\n+{\\n+public:\\n+    nsProxyLockedRefPtr(nsProxyObject* aPtr) :\\n+        mProxyObject(aPtr)\\n+    {\\n+        if (mProxyObject)\\n+            mProxyObject->LockedAddRef();\\n+    }\\n+\\n+    ~nsProxyLockedRefPtr()\\n+    {\\n+        if (mProxyObject)\\n+            mProxyObject->LockedRelease();\\n+    }\\n+\\n+    operator nsProxyObject*() const\\n+    {\\n+        return mProxyObject;\\n+    }\\n+\\n+    nsProxyObject* operator->() const\\n+    {\\n+        return mProxyObject;\\n+    }\\n+\\n+private:\\n+    nsProxyObject *mProxyObject;\\n+};\\n+\\n NS_IMETHODIMP \\n nsProxyObjectManager::GetProxyForObject(nsIEventTarget* aTarget, \\n                                         REFNSIID aIID, \\n@@ -195,8 +225,8 @@ nsProxyObjectManager::GetProxyForObject(nsIEventTarget* aTarget,\\n \\n     {\\n         nsAutoLock lock(mProxyCreationLock);\\n-                nsProxyObject *root =\\n-                    (nsProxyObject*) mProxyObjectMap.Get(&rootKey);\\n+        nsProxyLockedRefPtr root =\\n+            (nsProxyObject*) mProxyObjectMap.Get(&rootKey);\\n         if (root)\\n             return root->LockedFind(aIID, aProxyObject);\\n     }\\n@@ -209,7 +239,7 @@ nsProxyObjectManager::GetProxyForObject(nsIEventTarget* aTarget,\\n     // lock again, and check for a race putting into mProxyObjectMap\\n     {\\n         nsAutoLock lock(mProxyCreationLock);\\n-        nsProxyObject *root =\\n+        nsProxyLockedRefPtr root = \\n             (nsProxyObject*) mProxyObjectMap.Get(&rootKey);\\n         if (root) {\\n             delete newRoot;\\n@@ -217,6 +247,8 @@ nsProxyObjectManager::GetProxyForObject(nsIEventTarget* aTarget,\\n         }\\n \\n         mProxyObjectMap.Put(&rootKey, newRoot);\\n+\\n+        nsProxyLockedRefPtr kungFuDeathGrip(newRoot);\\n         return newRoot->LockedFind(aIID, aProxyObject);\\n     }\\n }\\n\""}