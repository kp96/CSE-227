{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas18da58e\""},"diff":"\"18da58e Treat all empty and incomplete sequences as encoding errors, and some other clean-up. Bug 381412, r=jshin, sr=dveditz, b1.9=jst\\ndiff --git a/intl/uconv/ucvcn/nsHZToUnicode.cpp b/intl/uconv/ucvcn/nsHZToUnicode.cpp\\nindex 14f98e5..afea0a5 100644\\n--- a/intl/uconv/ucvcn/nsHZToUnicode.cpp\\n+++ b/intl/uconv/ucvcn/nsHZToUnicode.cpp\\n@@ -79,6 +79,7 @@\\n nsHZToUnicode::nsHZToUnicode() : nsBufferDecoderSupport(1)\\n {\\n   mHZState = HZ_STATE_ASCII;\\t// per HZ spec, default to ASCII state \\n+  mRunLength = 0;\\n }\\n //Overwriting the ConvertNoBuff() in nsUCvCnSupport.cpp.\\n NS_IMETHODIMP nsHZToUnicode::ConvertNoBuff(\\n@@ -102,8 +103,13 @@ NS_IMETHODIMP nsHZToUnicode::ConvertNoBuff(\\n     }\\n     if ( *aSrc & 0x80 ) // if it is a 8-bit byte\\n     {\\n-      // The source is a 8-bit GBCode\\n-      *aDest = mUtil.GBKCharToUnicode(aSrc[0], aSrc[1]);\\n+      if (UINT8_IN_RANGE(0x81, aSrc[0], 0xFE) &&\\n+          UINT8_IN_RANGE(0x40, aSrc[1], 0xFE)) {\\n+        // The source is a 8-bit GBCode\\n+        *aDest = mUtil.GBKCharToUnicode(aSrc[0], aSrc[1]);\\n+      } else {\\n+        *aDest = UCS2_NO_MAPPING;\\n+      }\\n       aSrc += 2;\\n       i++;\\n       iDestlen++;\\n@@ -123,6 +129,7 @@ NS_IMETHODIMP nsHZToUnicode::ConvertNoBuff(\\n           // we got a '~{'\\n           // we are switching to HZ state\\n           mHZState = HZ_STATE_GB;\\n+          mRunLength = 0;\\n           aSrc += 2;\\n           i++;\\n           break;\\n@@ -132,6 +139,12 @@ NS_IMETHODIMP nsHZToUnicode::ConvertNoBuff(\\n           mHZState = HZ_STATE_ASCII;\\n           aSrc += 2;\\n           i++;\\n+          if (mRunLength == 0) {\\n+            *aDest = UCS2_NO_MAPPING;\\n+            iDestlen++;\\n+            aDest++;\\n+          }\\n+          mRunLength = 0;\\n           break;\\n         case HZLEAD1: \\n           // we got a '~~', process like an ASCII, but no state change\\n@@ -141,6 +154,7 @@ NS_IMETHODIMP nsHZToUnicode::ConvertNoBuff(\\n           i++;\\n           iDestlen++;\\n           aDest++;\\n+          mRunLength++;\\n           break;\\n         case HZLEAD4:\\t\\n           // we got a \\\"~\\\\n\\\", it means maintain double byte mode cross lines, ignore the '~' itself\\n@@ -152,6 +166,9 @@ NS_IMETHODIMP nsHZToUnicode::ConvertNoBuff(\\n         default:\\n           // undefined ESC sequence '~X' are ignored since this is a illegal combination \\n           aSrc += 2;\\n+          *aDest = UCS2_NO_MAPPING;\\n+          iDestlen++;\\n+          aDest++;\\n           break;\\n       };\\n       continue;// go for next loop\\n@@ -166,6 +183,7 @@ NS_IMETHODIMP nsHZToUnicode::ConvertNoBuff(\\n         i++;\\n         iDestlen++;\\n         aDest++;\\n+        mRunLength++;\\n         break;\\n       case HZ_STATE_ASCII:\\n       default:\\ndiff --git a/intl/uconv/ucvcn/nsHZToUnicode.h b/intl/uconv/ucvcn/nsHZToUnicode.h\\nindex f847f1e..26e9156 100644\\n--- a/intl/uconv/ucvcn/nsHZToUnicode.h\\n+++ b/intl/uconv/ucvcn/nsHZToUnicode.h\\n@@ -70,6 +70,7 @@ protected:\\n \\n private:\\n   PRInt16 mHZState;\\n+  PRUint32 mRunLength; // length of a run of 8-bit GB-encoded characters\\n \\n };\\n \\ndiff --git a/intl/uconv/ucvcn/nsISO2022CNToUnicode.cpp b/intl/uconv/ucvcn/nsISO2022CNToUnicode.cpp\\nindex f7ad930..e49ac4d 100644\\n--- a/intl/uconv/ucvcn/nsISO2022CNToUnicode.cpp\\n+++ b/intl/uconv/ucvcn/nsISO2022CNToUnicode.cpp\\n@@ -164,6 +164,7 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n       case eState_ESC_24_29_A:  // ESC $ ) A\\n         if(SO == *src) {\\n            mState = eState_GB2312_1980;\\n+           mRunLength = 0;\\n         } else {\\n            if(dest+5 >= destEnd)\\n               goto error1;\\n@@ -180,6 +181,12 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n       case eState_GB2312_1980:   // ESC $ ) A SO\\n         if(SI == *src) { // Shift-In (SI)\\n            mState = eState_ESC_24_29_A_SO_SI;\\n+           if (mRunLength == 0) {\\n+              if(dest+1 >= destEnd)\\n+                 goto error1;\\n+              *dest++ = 0xFFFD;\\n+           }\\n+           mRunLength = 0;\\n         } else if(ESC == *src) {\\n            mState = eState_ESC;\\n         } else {\\n@@ -204,6 +211,7 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n \\n            aLen = destEnd - dest;\\n            rv = GB2312_To_Unicode(gb, gbLen, dest, &aLen);\\n+           ++mRunLength;\\n            if(rv == NS_OK_UDEC_MOREOUTPUT) {\\n               goto error1;\\n            } else if(NS_FAILED(rv)) {\\n@@ -223,6 +231,7 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n       case eState_ESC_24_29_A_SO_SI:  // ESC $ ) A SO SI\\n         if(SO == *src) {\\n            mState = eState_GB2312_1980;\\n+           mRunLength = 0;\\n         } else if(ESC == *src) {\\n            mState = eState_ESC;\\n         } else {\\n@@ -237,6 +246,7 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n       case eState_ESC_24_29_G:   // ESC $ ) G\\n         if(SO == *src) {\\n            mState = eState_CNS11643_1;\\n+           mRunLength = 0;\\n         } else {\\n            if(dest+5 >= destEnd)\\n               goto error1;\\n@@ -253,6 +263,12 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n       case eState_CNS11643_1:   // ESC $ ) G SO\\n         if(SI == *src) { // Shift-In (SI)\\n            mState = eState_ESC_24_29_G_SO_SI;\\n+           if (mRunLength == 0) {\\n+              if(dest+1 >= destEnd)\\n+                 goto error1;\\n+              *dest++ = 0xFFFD;\\n+           }\\n+           mRunLength = 0;\\n         } else if(ESC == *src) {\\n            mState = eState_ESC;\\n         } else {\\n@@ -277,6 +293,7 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n \\n            aLen = destEnd - dest;\\n            rv = EUCTW_To_Unicode(cns, cnsLen, dest, &aLen);\\n+           ++mRunLength;\\n            if(rv == NS_OK_UDEC_MOREOUTPUT) {\\n               goto error1;\\n            } else if(NS_FAILED(rv)) {\\n@@ -296,6 +313,7 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n       case eState_ESC_24_29_G_SO_SI: // ESC $ ) G SO SI\\n         if(SO == *src) {\\n            mState = eState_CNS11643_1;\\n+           mRunLength = 0;\\n         } else if(ESC == *src) {\\n            mState = eState_ESC;\\n         } else {\\n@@ -341,6 +359,7 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n       case eState_ESC_24_2A_H_ESC:  // ESC $ * H ESC\\n         if(SS2 == *src) {\\n            mState = eState_CNS11643_2;\\n+           mRunLength = 0;\\n         } else if('$' == *src) {\\n            mState = eState_ESC_24;\\n         } else {\\n@@ -360,6 +379,12 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n       case eState_CNS11643_2:  // ESC $ * H ESC SS2\\n         if(SI == *src) { // Shift-In (SI)\\n            mState = eState_ESC_24_2A_H_ESC_SS2_SI;\\n+           if (mRunLength == 0) {\\n+              if(dest+1 >= destEnd)\\n+                 goto error1;\\n+              *dest++ = 0xFFFD;\\n+           }\\n+           mRunLength = 0;\\n         } else if(ESC == *src) {\\n            mState = eState_ESC_24_2A_H_ESC;\\n         } else {\\n@@ -386,6 +411,7 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n  \\n            aLen = destEnd - dest;\\n            rv = EUCTW_To_Unicode(cns, cnsLen, dest, &aLen);\\n+           ++mRunLength;\\n            if(rv == NS_OK_UDEC_MOREOUTPUT) {\\n               goto error1;\\n            } else if(NS_FAILED(rv)) {\\n@@ -417,6 +443,7 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n       case eState_ESC_24_2A_H_ESC_SS2_SI_ESC:  // ESC $ * H ESC SS2 SI ESC\\n         if(SS2 == *src) {\\n            mState = eState_CNS11643_2;\\n+           mRunLength = 0;\\n         } else if('$' == *src) {\\n            mState = eState_ESC_24;\\n         } else {\\n@@ -463,6 +490,7 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n       case eState_ESC_24_2B_I_ESC:  // ESC $ + I ESC\\n         if(SS3 == *src) {\\n            mState = eState_CNS11643_3;\\n+           mRunLength = 0;\\n         } else if('$' == *src) {\\n            mState = eState_ESC_24;\\n         } else {\\n@@ -482,6 +510,12 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n       case eState_CNS11643_3:   // ESC $ + I ESC SS3\\n         if(SI == *src) { // Shift-In (SI)\\n            mState = eState_ESC_24_2B_I_ESC_SS3_SI;\\n+           if (mRunLength == 0) {\\n+              if(dest+1 >= destEnd)\\n+                 goto error1;\\n+              *dest++ = 0xFFFD;\\n+           }\\n+           mRunLength = 0;\\n         } else if(ESC == *src) {\\n            mState = eState_ESC_24_2B_I_ESC;\\n         } else {\\n@@ -509,6 +543,7 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n \\n            aLen = destEnd - dest;\\n            rv = EUCTW_To_Unicode(cns, cnsLen, dest, &aLen);\\n+           ++mRunLength;\\n            if(rv == NS_OK_UDEC_MOREOUTPUT) {\\n               goto error1;\\n            } else if(NS_FAILED(rv)) {\\n@@ -540,6 +575,7 @@ NS_IMETHODIMP nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n       case eState_ESC_24_2B_I_ESC_SS3_SI_ESC:  // ESC $ + I ESC SS3 SI ESC\\n         if(SS3 == *src) {\\n            mState = eState_CNS11643_3;\\n+           mRunLength = 0;\\n         } else if('$' == *src) {\\n            mState = eState_ESC_24;\\n         } else {\\ndiff --git a/intl/uconv/ucvcn/nsISO2022CNToUnicode.h b/intl/uconv/ucvcn/nsISO2022CNToUnicode.h\\nindex b5e87b1..e680c8a 100644\\n--- a/intl/uconv/ucvcn/nsISO2022CNToUnicode.h\\n+++ b/intl/uconv/ucvcn/nsISO2022CNToUnicode.h\\n@@ -56,7 +56,8 @@ class nsISO2022CNToUnicode : public nsBasicDecoderSupport\\n public:\\n   nsISO2022CNToUnicode() : \\n         mState(eState_ASCII), \\n-        mPlaneID(0) { }\\n+        mPlaneID(0),\\n+        mRunLength(0) { }\\n \\n   virtual ~nsISO2022CNToUnicode() {}\\n \\n@@ -74,6 +75,7 @@ public:\\n   {\\n     mState = eState_ASCII;\\n     mPlaneID = 0;\\n+    mRunLength = 0;\\n \\n     return NS_OK;\\n   }\\n@@ -118,6 +120,9 @@ private:\\n   // Plane number for CNS11643 code\\n   int mPlaneID;\\n \\n+  // Length of non-ASCII run\\n+  PRUint32 mRunLength;\\n+\\n   // Decoder handler\\n   nsCOMPtr<nsIUnicodeDecoder> mGB2312_Decoder;\\n   nsCOMPtr<nsIUnicodeDecoder> mEUCTW_Decoder;\\ndiff --git a/intl/uconv/ucvja/nsJapaneseToUnicode.cpp b/intl/uconv/ucvja/nsJapaneseToUnicode.cpp\\nindex 668903c..55a0765 100644\\n--- a/intl/uconv/ucvja/nsJapaneseToUnicode.cpp\\n+++ b/intl/uconv/ucvja/nsJapaneseToUnicode.cpp\\n@@ -120,7 +120,7 @@ NS_IMETHODIMP nsShiftJISToUnicode::Convert(\\n        {\\n \\n           case 0:\\n-          if(*src & 0x80 && *src != (unsigned char)0xa0)\\n+          if(*src & 0x80)\\n           {\\n             mData = SJIS_INDEX[*src & 0x7F];\\n             if(mData < 0xE000 )\\n@@ -130,15 +130,33 @@ NS_IMETHODIMP nsShiftJISToUnicode::Convert(\\n                if( mData > 0xFF00)\\n                {\\n                  if(0xFFFD == mData) {\\n-                   // IE convert fd-ff as single byte and convert to\\n-                   // U+f8f1 to U+f8f3\\n-                   if((0xfd == *src) || (0xfe == *src) || (0xff == *src))\\n-                   {\\n-                     *dest++ = (PRUnichar) 0xf8f1 + \\n+                   // IE-compatible handling of undefined codepoints:\\n+                   // 0x80 --> U+0080\\n+                   // 0xa0 --> U+F8F0\\n+                   // 0xfd --> U+F8F1\\n+                   // 0xfe --> U+F8F2\\n+                   // 0xff --> U+F8F3\\n+                   switch (*src) {\\n+                     case 0x80:\\n+                       *dest++ = (PRUnichar) *src;\\n+                       break;\\n+\\n+                     case 0xa0:\\n+                       *dest++ = (PRUnichar) 0xf8f0;\\n+                       break;\\n+\\n+                     case 0xfd:\\n+                     case 0xfe:\\n+                     case 0xff:\\n+                       *dest++ = (PRUnichar) 0xf8f1 + \\n                                    (*src - (unsigned char)(0xfd));\\n-                     if(dest >= destEnd)\\n-                        goto error1;\\n+                       break;\\n+\\n+                     default:\\n+                       *dest++ = 0x30FB;\\n                    }\\n+                   if(dest >= destEnd)\\n+                     goto error1;\\n                  } else {\\n                    *dest++ = mData; // JIS 0201\\n                    if(dest >= destEnd)\\n@@ -517,10 +535,16 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Convert(\\n           case mState_ESC_28: // ESC (\\n             if( 'B' == *src) {\\n               mState = mState_ASCII;\\n+              if (mRunLength == 0) {\\n+                goto error2;\\n+              }\\n+              mRunLength = 0;\\n             } else if ('J' == *src)  {\\n               mState = mState_JISX0201_1976Roman;\\n+              mRunLength = 0;\\n             } else if ('I' == *src)  {\\n               mState = mState_JISX0201_1976Kana;\\n+              mRunLength = 0;\\n             } else  {\\n               if((dest+3) >= destEnd)\\n                 goto error1;\\n@@ -536,10 +560,13 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Convert(\\n           case mState_ESC_24: // ESC $\\n             if( '@' == *src) {\\n               mState = mState_JISX0208_1978;\\n+              mRunLength = 0;\\n             } else if ('A' == *src)  {\\n               mState = mState_GB2312_1980;\\n+              mRunLength = 0;\\n             } else if ('B' == *src)  {\\n               mState = mState_JISX0208_1983;\\n+              mRunLength = 0;\\n             } else if ('(' == *src)  {\\n               mState = mState_ESC_24_28;\\n             } else  {\\n@@ -557,8 +584,10 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Convert(\\n           case mState_ESC_24_28: // ESC $ (\\n             if( 'C' == *src) {\\n               mState = mState_KSC5601_1987;\\n+              mRunLength = 0;\\n             } else if ('D' == *src) {\\n               mState = mState_JISX0212_1990;\\n+              mRunLength = 0;\\n             } else  {\\n               if((dest+4) >= destEnd)\\n                 goto error1;\\n@@ -583,6 +612,7 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Convert(\\n               // we may need a if statement here for '\\\\' and '~' \\n               // to map them to Yen and Overbar\\n               *dest++ = (PRUnichar) *src;\\n+              ++mRunLength;\\n               if(dest >= destEnd)\\n                 goto error1;\\n             }\\n@@ -595,6 +625,7 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Convert(\\n             } else {\\n               if((0x21 <= *src) && (*src <= 0x5F)) {\\n                 *dest++ = (0xFF61-0x0021) + *src;\\n+                ++mRunLength;\\n               } else {\\n                 goto error2;\\n               }\\n@@ -687,6 +718,7 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Convert(\\n                // XXX We need to map from JIS X 0208 1983 to 1987 \\n                // in the next line before pass to *dest++\\n                *dest++ = gJapaneseMap[mData+off];\\n+               ++mRunLength;\\n             }\\n             mState = mState_JISX0208_1978;\\n             if(dest >= destEnd)\\n@@ -724,6 +756,7 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Convert(\\n                 mGB2312Decoder->Convert((const char *)gb, &gbLen,\\n                                         &uni, &uniLen);\\n                 *dest++ = uni;\\n+                ++mRunLength;\\n               }\\n             }\\n             mState = mState_GB2312_1980;\\n@@ -739,6 +772,7 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Convert(\\n                goto error2;\\n             } else {\\n                *dest++ = gJapaneseMap[mData+off];\\n+               ++mRunLength;\\n             }\\n             mState = mState_JISX0208_1983;\\n             if(dest >= destEnd)\\n@@ -776,6 +810,7 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Convert(\\n                 mEUCKRDecoder->Convert((const char *)ksc, &kscLen,\\n                                        &uni, &uniLen);\\n                 *dest++ = uni;\\n+                ++mRunLength;\\n               }\\n             }\\n             mState = mState_KSC5601_1987;\\n@@ -791,6 +826,7 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Convert(\\n                goto error2;\\n             } else {\\n                *dest++ = gJapaneseMap[mData+off];\\n+               ++mRunLength;\\n             }\\n             mState = mState_JISX0212_1990;\\n             if(dest >= destEnd)\\n@@ -824,6 +860,7 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Convert(\\n             if((0x20 <= *src) && (*src <= 0x7F)) {\\n               if (G2_ISO88591 == G2charset) {\\n                 *dest++ = *src | 0x80;\\n+                ++mRunLength;\\n               } else if (G2_ISO88597 == G2charset) {\\n                 if (!mISO88597Decoder) {\\n                   // creating a delegate converter (ISO-8859-7)\\n@@ -845,6 +882,7 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Convert(\\n                   mISO88597Decoder->Convert((const char *)&gr, &grLen,\\n                                             &uni, &uniLen);\\n                   *dest++ = uni;\\n+                  ++mRunLength;\\n                 }\\n               } else {// G2charset is G2_unknown (not designated yet)\\n                 goto error2;\\n@@ -864,6 +902,7 @@ NS_IMETHODIMP nsISO2022JPToUnicodeV2::Convert(\\n \\n           case mState_ERROR:\\n              mState = mLastLegalState;\\n+             mRunLength = 0;\\n              goto error2;\\n           break;\\n \\ndiff --git a/intl/uconv/ucvja/nsJapaneseToUnicode.h b/intl/uconv/ucvja/nsJapaneseToUnicode.h\\nindex 6f35027..cc5723c 100644\\n--- a/intl/uconv/ucvja/nsJapaneseToUnicode.h\\n+++ b/intl/uconv/ucvja/nsJapaneseToUnicode.h\\n@@ -123,6 +123,7 @@ public:\\n         mState = mState_ASCII;\\n         mLastLegalState = mState_ASCII;\\n         mData = 0;\\n+        mRunLength = 0;\\n         G2charset = G2_unknown;\\n         mGB2312Decoder = nsnull;\\n         mEUCKRDecoder = nsnull;\\n@@ -148,6 +149,7 @@ public:\\n      {\\n         mState = mState_ASCII;\\n         mLastLegalState = mState_ASCII;\\n+        mRunLength = 0;\\n         setMapMode();\\n         return NS_OK;\\n      }\\n@@ -176,6 +178,7 @@ private:\\n    mState_ERROR\\n  } mState, mLastLegalState;\\n  PRInt32 mData;\\n+ PRInt32 mRunLength; // the length of a non-ASCII run\\n  enum {\\n    G2_unknown,\\n    G2_ISO88591,\\ndiff --git a/intl/uconv/ucvko/nsISO2022KRToUnicode.cpp b/intl/uconv/ucvko/nsISO2022KRToUnicode.cpp\\nindex 5851438..78c06b6 100644\\n--- a/intl/uconv/ucvko/nsISO2022KRToUnicode.cpp\\n+++ b/intl/uconv/ucvko/nsISO2022KRToUnicode.cpp\\n@@ -59,6 +59,7 @@ NS_IMETHODIMP nsISO2022KRToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n         } \\n         else if(0x0e == *src) { // Shift-Out \\n           mState = mState_KSX1001_1992;\\n+          mRunLength = 0;\\n         } \\n         else if(*src & 0x80) {\\n           *dest++ = 0xFFFD;\\n@@ -103,6 +104,12 @@ NS_IMETHODIMP nsISO2022KRToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n         mState = mLastLegalState;\\n         if('C' == *src) {\\n           mState = mState_ASCII;\\n+          if (mRunLength == 0) {\\n+            if(dest+1 >= destEnd)\\n+              goto error1;\\n+            *dest++ = 0xFFFD;\\n+          }\\n+          mRunLength = 0;\\n         } \\n         else  {\\n           if((dest+4) >= destEnd)\\n@@ -122,11 +129,18 @@ NS_IMETHODIMP nsISO2022KRToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n         } \\n         else if (0x0f == *src) { // Shift-In (SI)\\n           mState = mState_ASCII;\\n+          if (mRunLength == 0) {\\n+            if(dest+1 >= destEnd)\\n+              goto error1;\\n+            *dest++ = 0xFFFD;\\n+          }\\n+          mRunLength = 0;\\n         } \\n         else if ((PRUint8) *src == 0x20 || (PRUint8) *src == 0x09) {\\n           // Allow space and tab between SO and SI (i.e. in Hangul segment)\\n           mState = mState_KSX1001_1992;\\n           *dest++ = (PRUnichar) *src;\\n+          ++mRunLength;\\n           if(dest >= destEnd)\\n           goto error1;\\n         } \\n@@ -164,6 +178,7 @@ NS_IMETHODIMP nsISO2022KRToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen\\n             // Convert EUC-KR to unicode.\\n             mEUCKRDecoder->Convert((const char *)ksx, &ksxLen, &uni, &uniLen);\\n             *dest++ = uni;\\n+            ++mRunLength;\\n           }\\n           if(dest >= destEnd)\\n             goto error1;\\ndiff --git a/intl/uconv/ucvko/nsISO2022KRToUnicode.h b/intl/uconv/ucvko/nsISO2022KRToUnicode.h\\nindex 206ab8f..7d38fa5 100644\\n--- a/intl/uconv/ucvko/nsISO2022KRToUnicode.h\\n+++ b/intl/uconv/ucvko/nsISO2022KRToUnicode.h\\n@@ -50,6 +50,7 @@ public:\\n     mLastLegalState = mState_ASCII;\\n     mData = 0;\\n     mEUCKRDecoder = nsnull;\\n+    mRunLength = 0;\\n   }\\n \\n   virtual ~nsISO2022KRToUnicode()\\n@@ -71,6 +72,7 @@ public:\\n   {\\n     mState = mState_ASCII;\\n     mLastLegalState = mState_ASCII;\\n+    mRunLength = 0;\\n     return NS_OK;\\n   }\\n \\n@@ -87,6 +89,9 @@ private:\\n \\n   PRUint8 mData;\\n \\n+  // Length of non-ASCII run\\n+  PRUint32 mRunLength;\\n+\\n   nsIUnicodeDecoder *mEUCKRDecoder;\\n };\\n #endif // nsISO2022KRToUnicode_h__\\ndiff --git a/intl/uconv/util/uscan.c b/intl/uconv/util/uscan.c\\nindex 79a0945..63b2bee 100644\\n--- a/intl/uconv/util/uscan.c\\n+++ b/intl/uconv/util/uscan.c\\n@@ -787,8 +787,6 @@ PRIVATE PRBool uCheckAndScan4BytesGB18030(\\n     (in[2] - 0x81)) * 10 ) + (in[3] - 0x30);\\n   \\n   *inscanlen = 4;\\n-  if(data >= 0x00010000)  \\n-    return PR_FALSE;\\n-  *out = (PRUint16) data;\\n+  *out = (data < 0x00010000) ? data : 0xFFFD;\\n   return PR_TRUE;\\n }\\n\""}