{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas2319b4f\""},"diff":"\"2319b4f Bug 394551: taking out the last patch as broke Windows build.\\ndiff --git a/js/src/jsapi.c b/js/src/jsapi.c\\nindex d046a48..c3748b3 100644\\n--- a/js/src/jsapi.c\\n+++ b/js/src/jsapi.c\\n@@ -4136,6 +4136,7 @@ js_generic_fast_native_method_dispatcher(JSContext *cx, uintN argc, jsval *vp)\\n     jsval fsv;\\n     JSFunctionSpec *fs;\\n     JSObject *tmp;\\n+    JSStackFrame *fp;\\n \\n     if (!JS_GetReservedSlot(cx, JSVAL_TO_OBJECT(*vp), 0, &fsv))\\n         return JS_FALSE;\\n@@ -4170,8 +4171,13 @@ js_generic_fast_native_method_dispatcher(JSContext *cx, uintN argc, jsval *vp)\\n      * Follow Function.prototype.apply and .call by using the global object as\\n      * the 'this' param if no args.\\n      */\\n+    fp = cx->fp;\\n+    JS_ASSERT((fp->flags & JSFRAME_IN_FAST_CALL) || fp->argv == vp + 2);\\n     if (!js_ComputeThis(cx, vp + 2))\\n         return JS_FALSE;\\n+    if (!(fp->flags & JSFRAME_IN_FAST_CALL))\\n+        fp->thisp = JSVAL_TO_OBJECT(vp[1]);\\n+\\n     /*\\n      * Protect against argc underflowing. By calling js_ComputeThis, we made\\n      * it as if the static was called with one parameter, the explicit |this|\\n@@ -4191,6 +4197,8 @@ js_generic_native_method_dispatcher(JSContext *cx, JSObject *obj,\\n     JSFunctionSpec *fs;\\n     JSObject *tmp;\\n \\n+    JS_ASSERT(!(cx->fp->flags & JSFRAME_IN_FAST_CALL));\\n+\\n     if (!JS_GetReservedSlot(cx, JSVAL_TO_OBJECT(argv[-2]), 0, &fsv))\\n         return JS_FALSE;\\n     fs = (JSFunctionSpec *) JSVAL_TO_PRIVATE(fsv);\\n@@ -4953,6 +4961,7 @@ JS_IsRunning(JSContext *cx)\\n JS_PUBLIC_API(JSBool)\\n JS_IsConstructing(JSContext *cx)\\n {\\n+    JS_ASSERT(!cx->fp || !(cx->fp->flags & JSFRAME_IN_FAST_CALL));\\n     return cx->fp && (cx->fp->flags & JSFRAME_CONSTRUCTING);\\n }\\n \\n@@ -4962,6 +4971,7 @@ JS_IsAssigning(JSContext *cx)\\n     JSStackFrame *fp;\\n     jsbytecode *pc;\\n \\n+    JS_ASSERT(!cx->fp || !(cx->fp->flags & JSFRAME_IN_FAST_CALL));\\n     for (fp = cx->fp; fp && !fp->script; fp = fp->down)\\n         continue;\\n     if (!fp || !(pc = fp->pc))\\n@@ -4987,6 +4997,7 @@ JS_SaveFrameChain(JSContext *cx)\\n     if (!fp)\\n         return fp;\\n \\n+    JS_ASSERT(!(fp->flags & JSFRAME_IN_FAST_CALL));\\n     JS_ASSERT(!fp->dormantNext);\\n     fp->dormantNext = cx->dormantFrameChain;\\n     cx->dormantFrameChain = fp;\\ndiff --git a/js/src/jsarray.c b/js/src/jsarray.c\\nindex d1fb5df..8d0feaf 100644\\n--- a/js/src/jsarray.c\\n+++ b/js/src/jsarray.c\\n@@ -1762,23 +1762,29 @@ typedef enum ArrayExtraMode {\\n static JSBool\\n array_extra(JSContext *cx, ArrayExtraMode mode, uintN argc, jsval *vp)\\n {\\n+    enum { ELEM, TEMP, RVAL, NROOTS };\\n+    jsval *argv, roots[NROOTS], *sp, *origsp, *oldsp;\\n     JSObject *obj;\\n-    jsuint length, newlen;\\n-    jsval *argv, *elemroot, *invokevp, *sp;\\n     JSBool ok, cond, hole;\\n+    jsuint length, newlen;\\n     JSObject *callable, *thisp, *newarr;\\n     jsint start, end, step, i;\\n+    JSTempValueRooter tvr;\\n     void *mark;\\n+    JSStackFrame *fp;\\n+\\n+    /* Hoist the explicit local root address computation. */\\n+    argv = vp + 2;\\n \\n     obj = JSVAL_TO_OBJECT(vp[1]);\\n-    if (!js_GetLengthProperty(cx, obj, &length))\\n+    ok = js_GetLengthProperty(cx, obj, &length);\\n+    if (!ok)\\n         return JS_FALSE;\\n \\n     /*\\n      * First, get or compute our callee, so that we error out consistently\\n      * when passed a non-callable object.\\n      */\\n-    argv = vp + 2;\\n     callable = js_ValueToCallableObject(cx, &argv[0], JSV2F_SEARCH_STACK);\\n     if (!callable)\\n         return JS_FALSE;\\n@@ -1792,6 +1798,8 @@ array_extra(JSContext *cx, ArrayExtraMode mode, uintN argc, jsval *vp)\\n     newarr = NULL;\\n #endif\\n     start = 0, end = length, step = 1;\\n+    memset(roots, 0, sizeof roots);\\n+    JS_PUSH_TEMP_ROOT(cx, NROOTS, roots, &tvr);\\n \\n     switch (mode) {\\n       case REDUCE_RIGHT:\\n@@ -1801,21 +1809,24 @@ array_extra(JSContext *cx, ArrayExtraMode mode, uintN argc, jsval *vp)\\n         if (length == 0 && argc == 1) {\\n             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,\\n                                  JSMSG_EMPTY_ARRAY_REDUCE);\\n-            return JS_FALSE;\\n+            ok = JS_FALSE;\\n+            goto early_out;\\n         }\\n         if (argc >= 2) {\\n-            *vp = argv[1];\\n+            roots[RVAL] = argv[1];\\n         } else {\\n             do {\\n-                if (!GetArrayElement(cx, obj, start, &hole, vp))\\n-                    return JS_FALSE;\\n+                ok = GetArrayElement(cx, obj, start, &hole, &roots[RVAL]);\\n+                if (!ok)\\n+                    goto early_out;\\n                 start += step;\\n             } while (hole && start != end);\\n \\n             if (hole && start == end) {\\n                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,\\n                                      JSMSG_EMPTY_ARRAY_REDUCE);\\n-                return JS_FALSE;\\n+                ok = JS_FALSE;\\n+                goto early_out;\\n             }\\n         }\\n         break;\\n@@ -1823,80 +1834,87 @@ array_extra(JSContext *cx, ArrayExtraMode mode, uintN argc, jsval *vp)\\n       case FILTER:\\n         newlen = (mode == MAP) ? length : 0;\\n         newarr = js_NewArrayObject(cx, newlen, NULL);\\n-        if (!newarr)\\n-            return JS_FALSE;\\n-        *vp = OBJECT_TO_JSVAL(newarr);\\n+        if (!newarr) {\\n+            ok = JS_FALSE;\\n+            goto early_out;\\n+        }\\n+        roots[RVAL] = OBJECT_TO_JSVAL(newarr);\\n         break;\\n       case SOME:\\n-        *vp = JSVAL_FALSE;\\n+        roots[RVAL] = JSVAL_FALSE;\\n         break;\\n       case EVERY:\\n-        *vp = JSVAL_TRUE;\\n+        roots[RVAL] = JSVAL_TRUE;\\n         break;\\n       case FOREACH:\\n-        *vp = JSVAL_VOID;\\n         break;\\n     }\\n \\n     if (length == 0)\\n-        return JS_TRUE;\\n+        goto early_out;\\n \\n     if (argc > 1 && !REDUCE_MODE(mode)) {\\n-        if (!js_ValueToObject(cx, argv[1], &thisp))\\n-            return JS_FALSE;\\n+        ok = js_ValueToObject(cx, argv[1], &thisp);\\n+        if (!ok)\\n+            goto early_out;\\n         argv[1] = OBJECT_TO_JSVAL(thisp);\\n     } else {\\n         thisp = NULL;\\n     }\\n \\n     /*\\n-     * For all but REDUCE, we call with 3 args (value, index, array). REDUCE\\n-     * requires 4 args (accum, value, index, array).\\n+     * For all but REDUCE, we call with 3 args (value, index, array), plus\\n+     * room for rval.  REDUCE requires 4 args (accum, value, index, array).\\n      */\\n     argc = 3 + REDUCE_MODE(mode);\\n-    elemroot = js_AllocStack(cx, 1 + 2 + argc, &mark);\\n-    if (!elemroot)\\n-        return JS_FALSE;\\n+    origsp = js_AllocStack(cx, 2 + argc + 1, &mark);\\n+    if (!origsp) {\\n+        ok = JS_FALSE;\\n+        goto early_out;\\n+    }\\n \\n-    /* From this point the control must flow through out:. */\\n-    ok = JS_TRUE;\\n-    invokevp = elemroot + 1;\\n+    /* Lift current frame to include our args. */\\n+    fp = cx->fp;\\n+    oldsp = fp->sp;\\n \\n     for (i = start; i != end; i += step) {\\n-        ok = JS_CHECK_OPERATION_LIMIT(cx, JSOW_JUMP) &&\\n-             GetArrayElement(cx, obj, i, &hole, elemroot);\\n+        ok = (JS_CHECK_OPERATION_LIMIT(cx, JSOW_JUMP) &&\\n+              GetArrayElement(cx, obj, i, &hole, &roots[ELEM]));\\n         if (!ok)\\n-            goto out;\\n+            break;\\n         if (hole)\\n             continue;\\n \\n         /*\\n          * Push callable and 'this', then args. We must do this for every\\n-         * iteration around the loop since js_Invoke uses spbase[0] for return\\n-         * value storage, while some native functions use spbase[1] for local\\n+         * iteration around the loop since js_Invoke uses origsp[0] for return\\n+         * value storage, while some native functions use origsp[1] for local\\n          * rooting.\\n          */\\n-        sp = invokevp;\\n+        sp = origsp;\\n         *sp++ = OBJECT_TO_JSVAL(callable);\\n         *sp++ = OBJECT_TO_JSVAL(thisp);\\n         if (REDUCE_MODE(mode))\\n-            *sp++ = *vp;\\n-        *sp++ = *elemroot;\\n+            *sp++ = roots[RVAL];\\n+        *sp++ = roots[ELEM];\\n         *sp++ = INT_TO_JSVAL(i);\\n         *sp++ = OBJECT_TO_JSVAL(obj);\\n \\n         /* Do the call. */\\n-        ok = js_Invoke(cx, argc, invokevp, JSINVOKE_INTERNAL);\\n+        fp->sp = sp;\\n+        ok = js_Invoke(cx, argc, JSINVOKE_INTERNAL);\\n+        roots[TEMP] = fp->sp[-1];\\n+        fp->sp = oldsp;\\n         if (!ok)\\n             break;\\n \\n         if (mode > MAP) {\\n-            if (*invokevp == JSVAL_NULL) {\\n+            if (roots[TEMP] == JSVAL_NULL) {\\n                 cond = JS_FALSE;\\n-            } else if (JSVAL_IS_BOOLEAN(*invokevp)) {\\n-                cond = JSVAL_TO_BOOLEAN(*invokevp);\\n+            } else if (JSVAL_IS_BOOLEAN(roots[TEMP])) {\\n+                cond = JSVAL_TO_BOOLEAN(roots[TEMP]);\\n             } else {\\n-                ok = js_ValueToBoolean(cx, *invokevp, &cond);\\n+                ok = js_ValueToBoolean(cx, roots[TEMP], &cond);\\n                 if (!ok)\\n                     goto out;\\n             }\\n@@ -1907,30 +1925,30 @@ array_extra(JSContext *cx, ArrayExtraMode mode, uintN argc, jsval *vp)\\n             break;\\n           case REDUCE:\\n           case REDUCE_RIGHT:\\n-            *vp = *invokevp;\\n+            roots[RVAL] = roots[TEMP];\\n             break;\\n           case MAP:\\n-            ok = SetArrayElement(cx, newarr, i, *invokevp);\\n+            ok = SetArrayElement(cx, newarr, i, roots[TEMP]);\\n             if (!ok)\\n                 goto out;\\n             break;\\n           case FILTER:\\n             if (!cond)\\n                 break;\\n-            /* The filter passed *elemroot, so push it onto our result. */\\n-            ok = SetArrayElement(cx, newarr, newlen++, *elemroot);\\n+            /* The filter passed roots[ELEM], so push it onto our result. */\\n+            ok = SetArrayElement(cx, newarr, newlen++, roots[ELEM]);\\n             if (!ok)\\n                 goto out;\\n             break;\\n           case SOME:\\n             if (cond) {\\n-                *vp = JSVAL_TRUE;\\n+                roots[RVAL] = JSVAL_TRUE;\\n                 goto out;\\n             }\\n             break;\\n           case EVERY:\\n             if (!cond) {\\n-                *vp = JSVAL_FALSE;\\n+                roots[RVAL] = JSVAL_FALSE;\\n                 goto out;\\n             }\\n             break;\\n@@ -1941,6 +1959,9 @@ array_extra(JSContext *cx, ArrayExtraMode mode, uintN argc, jsval *vp)\\n     js_FreeStack(cx, mark);\\n     if (ok && mode == FILTER)\\n         ok = js_SetLengthProperty(cx, newarr, newlen);\\n+  early_out:\\n+    *vp = roots[RVAL];\\n+    JS_POP_TEMP_ROOT(cx, &tvr);\\n     return ok;\\n }\\n \\ndiff --git a/js/src/jsdbgapi.c b/js/src/jsdbgapi.c\\nindex 6d2f533..8e6ef22 100644\\n--- a/js/src/jsdbgapi.c\\n+++ b/js/src/jsdbgapi.c\\n@@ -545,16 +545,11 @@ js_watch_set(JSContext *cx, JSObject *obj, jsval id, jsval *vp)\\n                  * identify the guilty party.  So that the watcher appears to\\n                  * be active to obj_eval and other such code, point frame.pc\\n                  * at the JSOP_STOP at the end of the script.\\n-                 *\\n-                 * The pseudo-frame is not created for fast natives as they\\n-                 * are treated as interpreter frame extensions and always\\n-                 * trusted.\\n                  */\\n                 JSObject *closure;\\n                 JSClass *clasp;\\n                 JSFunction *fun;\\n                 JSScript *script;\\n-                JSBool injectFrame;\\n                 uintN nslots;\\n                 jsval smallv[5];\\n                 jsval *argv;\\n@@ -574,66 +569,56 @@ js_watch_set(JSContext *cx, JSObject *obj, jsval id, jsval *vp)\\n                 }\\n \\n                 nslots = 2;\\n-                injectFrame = JS_TRUE;\\n                 if (fun) {\\n                     nslots += FUN_MINARGS(fun);\\n-                    if (!FUN_INTERPRETED(fun)) {\\n+                    if (!FUN_INTERPRETED(fun))\\n                         nslots += fun->u.n.extra;\\n-                        injectFrame = !(fun->flags & JSFUN_FAST_NATIVE);\\n-                    }\\n                 }\\n \\n-                if (injectFrame) {\\n-                    if (nslots <= JS_ARRAY_LENGTH(smallv)) {\\n-                        argv = smallv;\\n-                    } else {\\n-                        argv = (jsval *) JS_malloc(cx, nslots * sizeof(jsval));\\n-                        if (!argv) {\\n-                            DBG_LOCK(rt);\\n-                            DropWatchPointAndUnlock(cx, wp, JSWP_HELD);\\n-                            return JS_FALSE;\\n-                        }\\n+                if (nslots <= JS_ARRAY_LENGTH(smallv)) {\\n+                    argv = smallv;\\n+                } else {\\n+                    argv = (jsval *) JS_malloc(cx, nslots * sizeof(jsval));\\n+                    if (!argv) {\\n+                        DBG_LOCK(rt);\\n+                        DropWatchPointAndUnlock(cx, wp, JSWP_HELD);\\n+                        return JS_FALSE;\\n                     }\\n+                }\\n \\n-                    argv[0] = OBJECT_TO_JSVAL(closure);\\n-                    argv[1] = JSVAL_NULL;\\n-                    memset(argv + 2, 0, (nslots - 2) * sizeof(jsval));\\n-\\n-                    memset(&frame, 0, sizeof(frame));\\n-                    frame.script = script;\\n-                    if (script) {\\n-                        JS_ASSERT(script->length >= JSOP_STOP_LENGTH);\\n-                        frame.pc = script->code + script->length\\n-                                   - JSOP_STOP_LENGTH;\\n-                    }\\n-                    frame.callee = closure;\\n-                    frame.fun = fun;\\n-                    frame.argv = argv + 2;\\n-                    frame.down = cx->fp;\\n-                    frame.scopeChain = OBJ_GET_PARENT(cx, closure);\\n+                argv[0] = OBJECT_TO_JSVAL(closure);\\n+                argv[1] = JSVAL_NULL;\\n+                memset(argv + 2, 0, (nslots - 2) * sizeof(jsval));\\n \\n-                    cx->fp = &frame;\\n+                memset(&frame, 0, sizeof(frame));\\n+                frame.script = script;\\n+                if (script) {\\n+                    JS_ASSERT(script->length >= JSOP_STOP_LENGTH);\\n+                    frame.pc = script->code + script->length\\n+                             - JSOP_STOP_LENGTH;\\n                 }\\n-#ifdef __GNUC__\\n-                else\\n-                    argv = NULL;    /* suppress bogus gcc warnings */\\n-#endif\\n+                frame.callee = closure;\\n+                frame.fun = fun;\\n+                frame.argv = argv + 2;\\n+                frame.down = cx->fp;\\n+                frame.scopeChain = OBJ_GET_PARENT(cx, closure);\\n+\\n+                cx->fp = &frame;\\n                 ok = !wp->setter ||\\n                      ((sprop->attrs & JSPROP_SETTER)\\n                       ? js_InternalCall(cx, obj, OBJECT_TO_JSVAL(wp->setter),\\n                                         1, vp, vp)\\n                       : wp->setter(cx, OBJ_THIS_OBJECT(cx, obj), userid, vp));\\n-                if (injectFrame) {\\n-                    /* Evil code can cause us to have an arguments object. */\\n-                    if (frame.callobj)\\n-                        ok &= js_PutCallObject(cx, &frame);\\n-                    if (frame.argsobj)\\n-                        ok &= js_PutArgsObject(cx, &frame);\\n-\\n-                    cx->fp = frame.down;\\n-                    if (argv != smallv)\\n-                        JS_free(cx, argv);\\n-                }\\n+\\n+                /* Evil code can cause us to have an arguments object. */\\n+                if (frame.callobj)\\n+                    ok &= js_PutCallObject(cx, &frame);\\n+                if (frame.argsobj)\\n+                    ok &= js_PutArgsObject(cx, &frame);\\n+\\n+                cx->fp = frame.down;\\n+                if (argv != smallv)\\n+                    JS_free(cx, argv);\\n             }\\n             DBG_LOCK(rt);\\n             return DropWatchPointAndUnlock(cx, wp, JSWP_HELD) && ok;\\ndiff --git a/js/src/jsfun.c b/js/src/jsfun.c\\nindex 64f7be1..9bcdc91 100644\\n--- a/js/src/jsfun.c\\n+++ b/js/src/jsfun.c\\n@@ -1059,6 +1059,8 @@ fun_getProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)\\n         break;\\n \\n       case FUN_CALLER:\\n+        while (fp && (fp->flags & JSFRAME_SKIP_CALLER) && fp->down)\\n+            fp = fp->down;\\n         if (fp && fp->down && fp->down->fun)\\n             *vp = OBJECT_TO_JSVAL(fp->down->callee);\\n         else\\n@@ -1588,9 +1590,11 @@ static JSBool\\n fun_call(JSContext *cx, uintN argc, jsval *vp)\\n {\\n     JSObject *obj;\\n-    jsval fval, *argv, *invokevp;\\n+    jsval fval, *argv, *sp, *oldsp;\\n     JSString *str;\\n     void *mark;\\n+    uintN i;\\n+    JSStackFrame *fp;\\n     JSBool ok;\\n \\n     obj = JSVAL_TO_OBJECT(vp[1]);\\n@@ -1628,17 +1632,28 @@ fun_call(JSContext *cx, uintN argc, jsval *vp)\\n     }\\n \\n     /* Allocate stack space for fval, obj, and the args. */\\n-    invokevp = js_AllocStack(cx, 2 + argc, &mark);\\n-    if (!invokevp)\\n+    sp = js_AllocStack(cx, 2 + argc, &mark);\\n+    if (!sp)\\n         return JS_FALSE;\\n \\n     /* Push fval, obj, and the args. */\\n-    invokevp[0] = fval;\\n-    invokevp[1] = OBJECT_TO_JSVAL(obj);\\n-    memcpy(invokevp + 2, argv, argc * sizeof *argv);\\n+    *sp++ = fval;\\n+    *sp++ = OBJECT_TO_JSVAL(obj);\\n+    for (i = 0; i < argc; i++)\\n+        *sp++ = argv[i];\\n \\n-    ok = js_Invoke(cx, argc, invokevp, JSINVOKE_INTERNAL);\\n-    *vp = *invokevp;\\n+    /* Lift current frame to include the args and do the call. */\\n+    fp = cx->fp;\\n+    oldsp = fp->sp;\\n+    fp->sp = sp;\\n+    ok = js_Invoke(cx, argc,\\n+                   (fp->flags & JSFRAME_IN_FAST_CALL)\\n+                   ? JSINVOKE_INTERNAL\\n+                   : JSINVOKE_INTERNAL | JSINVOKE_SKIP_CALLER);\\n+\\n+    /* Store rval and pop stack back to our frame's sp. */\\n+    *vp = fp->sp[-1];\\n+    fp->sp = oldsp;\\n     js_FreeStack(cx, mark);\\n     return ok;\\n }\\n@@ -1647,12 +1662,13 @@ static JSBool\\n fun_apply(JSContext *cx, uintN argc, jsval *vp)\\n {\\n     JSObject *obj, *aobj;\\n-    jsval fval, *invokevp, *sp;\\n+    jsval fval, *sp, *oldsp;\\n     JSString *str;\\n     jsuint length;\\n     JSBool arraylike, ok;\\n     void *mark;\\n     uintN i;\\n+    JSStackFrame *fp;\\n \\n     if (argc == 0) {\\n         /* Will get globalObject as 'this' and no other arguments. */\\n@@ -1711,12 +1727,11 @@ fun_apply(JSContext *cx, uintN argc, jsval *vp)\\n \\n     /* Allocate stack space for fval, obj, and the args. */\\n     argc = (uintN)JS_MIN(length, ARRAY_INIT_LIMIT - 1);\\n-    invokevp = js_AllocStack(cx, 2 + argc, &mark);\\n-    if (!invokevp)\\n+    sp = js_AllocStack(cx, 2 + argc, &mark);\\n+    if (!sp)\\n         return JS_FALSE;\\n \\n     /* Push fval, obj, and aobj's elements as args. */\\n-    sp = invokevp;\\n     *sp++ = fval;\\n     *sp++ = OBJECT_TO_JSVAL(obj);\\n     for (i = 0; i < argc; i++) {\\n@@ -1726,8 +1741,18 @@ fun_apply(JSContext *cx, uintN argc, jsval *vp)\\n         sp++;\\n     }\\n \\n-    ok = js_Invoke(cx, argc, invokevp, JSINVOKE_INTERNAL);\\n-    *vp = *invokevp;\\n+    /* Lift current frame to include the args and do the call. */\\n+    fp = cx->fp;\\n+    oldsp = fp->sp;\\n+    fp->sp = sp;\\n+    ok = js_Invoke(cx, argc,\\n+                   (fp->flags & JSFRAME_IN_FAST_CALL)\\n+                   ? JSINVOKE_INTERNAL\\n+                   : JSINVOKE_INTERNAL | JSINVOKE_SKIP_CALLER);\\n+\\n+    /* Store rval and pop stack back to our frame's sp. */\\n+    *vp = fp->sp[-1];\\n+    fp->sp = oldsp;\\n out:\\n     js_FreeStack(cx, mark);\\n     return ok;\\n@@ -1740,7 +1765,8 @@ fun_applyConstructor(JSContext *cx, uintN argc, jsval *vp)\\n     JSObject *aobj;\\n     uintN length, i;\\n     void *mark;\\n-    jsval *invokevp, *sp;\\n+    jsval *sp, *newsp, *oldsp;\\n+    JSStackFrame *fp;\\n     JSBool ok;\\n \\n     if (JSVAL_IS_PRIMITIVE(vp[2]) ||\\n@@ -1757,11 +1783,12 @@ fun_applyConstructor(JSContext *cx, uintN argc, jsval *vp)\\n \\n     if (length >= ARRAY_INIT_LIMIT)\\n         length = ARRAY_INIT_LIMIT - 1;\\n-    invokevp = js_AllocStack(cx, 2 + length, &mark);\\n-    if (!invokevp)\\n+    newsp = sp = js_AllocStack(cx, 2 + length, &mark);\\n+    if (!sp)\\n         return JS_FALSE;\\n \\n-    sp = invokevp;\\n+    fp = cx->fp;\\n+    oldsp = fp->sp;\\n     *sp++ = vp[1];\\n     *sp++ = JSVAL_NULL; /* This is filled automagically. */\\n     for (i = 0; i < length; i++) {\\n@@ -1771,8 +1798,12 @@ fun_applyConstructor(JSContext *cx, uintN argc, jsval *vp)\\n         sp++;\\n     }\\n \\n-    ok = js_InvokeConstructor(cx, invokevp, length);\\n-    *vp = *invokevp;\\n+    oldsp = fp->sp;\\n+    fp->sp = sp;\\n+    ok = js_InvokeConstructor(cx, newsp, length);\\n+\\n+    *vp = fp->sp[-1];\\n+    fp->sp = oldsp;\\n out:\\n     js_FreeStack(cx, mark);\\n     return ok;\\n@@ -2327,7 +2358,9 @@ js_ReportIsNotFunction(JSContext *cx, jsval *vp, uintN flags)\\n     }\\n \\n     js_ReportValueError3(cx, error,\\n-                         (fp && fp->spbase <= vp && vp < fp->sp)\\n+                         (fp &&\\n+                          !(fp->flags & JSFRAME_IN_FAST_CALL) &&\\n+                          fp->spbase <= vp && vp < fp->sp)\\n                          ? vp - fp->sp\\n                          : (flags & JSV2F_SEARCH_STACK)\\n                          ? JSDVG_SEARCH_STACK\\ndiff --git a/js/src/jsgc.c b/js/src/jsgc.c\\nindex b1ee60c..56d4751 100644\\n--- a/js/src/jsgc.c\\n+++ b/js/src/jsgc.c\\n@@ -2205,7 +2205,8 @@ gc_lock_traversal(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 num,\\n void\\n js_TraceStackFrame(JSTracer *trc, JSStackFrame *fp)\\n {\\n-    uintN nslots, minargs, skip;\\n+    uintN depth, nslots, minargs;\\n+    jsval *vp;\\n \\n     if (fp->callobj)\\n         JS_CALL_OBJECT_TRACER(trc, fp->callobj, \\\"call\\\");\\n@@ -2220,9 +2221,11 @@ js_TraceStackFrame(JSTracer *trc, JSStackFrame *fp)\\n              * Don't mark what has not been pushed yet, or what has been\\n              * popped already.\\n              */\\n-            JS_ASSERT(JS_UPTRDIFF(fp->sp, fp->spbase) <=\\n-                      fp->script->depth * sizeof(jsval));\\n-            nslots = (uintN) (fp->sp - fp->spbase);\\n+            depth = fp->script->depth;\\n+            nslots = (JS_UPTRDIFF(fp->sp, fp->spbase)\\n+                      < depth * sizeof(jsval))\\n+                     ? (uintN)(fp->sp - fp->spbase)\\n+                     : depth;\\n             TRACE_JSVALS(trc, nslots, fp->spbase, \\\"operand\\\");\\n         }\\n     }\\n@@ -2236,20 +2239,32 @@ js_TraceStackFrame(JSTracer *trc, JSStackFrame *fp)\\n         JS_CALL_OBJECT_TRACER(trc, fp->callee, \\\"callee\\\");\\n \\n     if (fp->argv) {\\n+        /* Trace argv including callee and thisp slots. */\\n         nslots = fp->argc;\\n-        skip = 0;\\n         if (fp->fun) {\\n             minargs = FUN_MINARGS(fp->fun);\\n             if (minargs > nslots)\\n                 nslots = minargs;\\n-            if (!FUN_INTERPRETED(fp->fun)) {\\n-                JS_ASSERT(!(fp->fun->flags & JSFUN_FAST_NATIVE));\\n+            if (!FUN_INTERPRETED(fp->fun))\\n                 nslots += fp->fun->u.n.extra;\\n+        }\\n+        nslots += 2;\\n+        vp = fp->argv - 2;\\n+        if (fp->down && fp->down->spbase) {\\n+            /*\\n+             * Avoid unnecessary tracing in the common case when args overlaps\\n+             * with the stack segment of the previous frame. That segment is\\n+             * traced via the above spbase code and, when sp > spbase + depth,\\n+             * during tracing of the stack headers in js_TraceContext.\\n+             */\\n+            if (JS_UPTRDIFF(vp, fp->down->spbase) <\\n+                JS_UPTRDIFF(fp->down->sp, fp->down->spbase)) {\\n+                JS_ASSERT((size_t)nslots >= (size_t)(fp->down->sp - vp));\\n+                nslots -= (uintN)(fp->down->sp - vp);\\n+                vp = fp->down->sp;\\n             }\\n-            if (fp->fun->flags & JSFRAME_ROOTED_ARGV)\\n-                skip = 2 + fp->argc;\\n         }\\n-        TRACE_JSVALS(trc, 2 + nslots - skip, fp->argv - 2 + skip, \\\"operand\\\");\\n+        TRACE_JSVALS(trc, nslots, vp, \\\"arg\\\");\\n     }\\n     JS_CALL_VALUE_TRACER(trc, fp->rval, \\\"rval\\\");\\n     if (fp->vars)\\ndiff --git a/js/src/jsinterp.c b/js/src/jsinterp.c\\nindex e9765a3..cff9d4b 100644\\n--- a/js/src/jsinterp.c\\n+++ b/js/src/jsinterp.c\\n@@ -81,9 +81,13 @@\\n  */\\n #define PUSH(v)         (*sp++ = (v))\\n #define POP()           (*--sp)\\n+#ifdef DEBUG\\n #define SAVE_SP(fp)                                                           \\\\\\n     (JS_ASSERT((fp)->script || !(fp)->spbase || (sp) == (fp)->spbase),        \\\\\\n      (fp)->sp = sp)\\n+#else\\n+#define SAVE_SP(fp)     ((fp)->sp = sp)\\n+#endif\\n #define RESTORE_SP(fp)  (sp = (fp)->sp)\\n \\n /*\\n@@ -261,35 +265,6 @@\\n         v = sp[n];                                                            \\\\\\n     JS_END_MACRO\\n \\n-/*\\n- * Check if the current arena has enough space to fit nslots after sp and, if\\n- * so, reserve the necessary space.\\n- */\\n-static JSBool\\n-AllocateAfterSP(JSContext *cx, jsval *sp, uintN nslots)\\n-{\\n-    uintN surplus;\\n-    jsval *sp2;\\n-\\n-    JS_ASSERT((jsval *) cx->stackPool.current->base <= sp);\\n-    JS_ASSERT(sp <= (jsval *) cx->stackPool.current->avail);\\n-    surplus = (jsval *) cx->stackPool.current->avail - sp;\\n-    if (nslots <= surplus)\\n-        return JS_TRUE;\\n-\\n-    /*\\n-     * No room before current->avail, check if the arena has enough space to\\n-     * fit the missing slots before the limit.\\n-     */\\n-    if (nslots > (size_t) ((jsval *) cx->stackPool.current->limit - sp))\\n-        return JS_FALSE;\\n-\\n-    JS_ARENA_ALLOCATE_CAST(sp2, jsval *, &cx->stackPool,\\n-                           (nslots - surplus) * sizeof(jsval));\\n-    JS_ASSERT(sp2 == sp + surplus);\\n-    return JS_TRUE;\\n-}\\n-\\n JS_FRIEND_API(jsval *)\\n js_AllocRawStack(JSContext *cx, uintN nslots, void **markp)\\n {\\n@@ -316,9 +291,10 @@ js_FreeRawStack(JSContext *cx, void *mark)\\n JS_FRIEND_API(jsval *)\\n js_AllocStack(JSContext *cx, uintN nslots, void **markp)\\n {\\n-    jsval *sp;\\n+    jsval *sp, *vp, *end;\\n     JSArena *a;\\n     JSStackHeader *sh;\\n+    JSStackFrame *fp;\\n \\n     /* Callers don't check for zero nslots: we do to avoid empty segments. */\\n     if (nslots == 0) {\\n@@ -340,9 +316,24 @@ js_AllocStack(JSContext *cx, uintN nslots, void **markp)\\n         a->avail -= 2 * sizeof(jsval);\\n     } else {\\n         /*\\n-         * Need a new stack segment, so allocate and push a stack segment\\n-         * header from the 2 extra slots.\\n+         * Need a new stack segment, so we must initialize unused slots in the\\n+         * current frame.  See js_GC, just before marking the \\\"operand\\\" jsvals,\\n+         * where we scan from fp->spbase to fp->sp or through fp->script->depth\\n+         * (whichever covers fewer slots).\\n          */\\n+        fp = cx->fp;\\n+        if (fp && fp->script && fp->spbase) {\\n+#ifdef DEBUG\\n+            jsuword depthdiff = fp->script->depth * sizeof(jsval);\\n+            JS_ASSERT(JS_UPTRDIFF(fp->sp, fp->spbase) <= depthdiff);\\n+            JS_ASSERT(JS_UPTRDIFF(*markp, fp->spbase) >= depthdiff);\\n+#endif\\n+            end = fp->spbase + fp->script->depth;\\n+            for (vp = fp->sp; vp < end; vp++)\\n+                *vp = JSVAL_VOID;\\n+        }\\n+\\n+        /* Allocate and push a stack segment header from the 2 extra slots. */\\n         sh = (JSStackHeader *)sp;\\n         sh->nslots = nslots;\\n         sh->down = cx->stackHeaders;\\n@@ -613,9 +604,9 @@ js_ComputeThis(JSContext *cx, jsval *argv)\\n #if JS_HAS_NO_SUCH_METHOD\\n \\n static JSBool\\n-NoSuchMethod(JSContext *cx, uintN argc, jsval *vp, uint32 flags)\\n+NoSuchMethod(JSContext *cx, JSStackFrame *fp, jsval *vp, uint32 flags,\\n+             uintN argc)\\n {\\n-    JSStackFrame *fp;\\n     JSObject *thisp, *argsobj;\\n     JSAtom *atom;\\n     jsval *sp, roots[3];\\n@@ -627,7 +618,6 @@ NoSuchMethod(JSContext *cx, uintN argc, jsval *vp, uint32 flags)\\n     /* NB: js_ComputeThis or equivalent must have been called already. */\\n     JS_ASSERT(JSVAL_IS_PRIMITIVE(vp[0]));\\n     JS_ASSERT(!JSVAL_IS_PRIMITIVE(vp[1]));\\n-    fp = cx->fp;\\n     RESTORE_SP(fp);\\n \\n     /* From here on, control must flow through label out: to return. */\\n@@ -1039,6 +1029,11 @@ LogCall(JSContext *cx, jsval callee, uintN argc, jsval *argv)\\n # define ASSERT_NOT_THROWING(cx) /* nothing */\\n #endif\\n \\n+#define START_FAST_CALL(fp) (JS_ASSERT(!((fp)->flags & JSFRAME_IN_FAST_CALL)),\\\\\\n+                             (fp)->flags |= JSFRAME_IN_FAST_CALL)\\n+#define END_FAST_CALL(fp)   (JS_ASSERT((fp)->flags & JSFRAME_IN_FAST_CALL),   \\\\\\n+                             (fp)->flags &= ~JSFRAME_IN_FAST_CALL)\\n+\\n /*\\n  * We check if the function accepts a primitive value as |this|. For that we\\n  * use a table that maps value's tag into the corresponding function flag.\\n@@ -1070,12 +1065,12 @@ static const uint16 PrimitiveTestFlags[] = {\\n  * when done.  Then push the return value.\\n  */\\n JS_FRIEND_API(JSBool)\\n-js_Invoke(JSContext *cx, uintN argc, jsval *vp, uintN flags)\\n+js_Invoke(JSContext *cx, uintN argc, uintN flags)\\n {\\n     void *mark;\\n-    JSStackFrame frame;\\n-    jsval *sp, *argv, *newvp;\\n-    jsval v;\\n+    JSStackFrame *fp, frame;\\n+    jsval *sp, *newsp, *limit;\\n+    jsval *vp, v;\\n     JSObject *funobj, *parent;\\n     JSBool ok;\\n     JSClass *clasp;\\n@@ -1083,21 +1078,24 @@ js_Invoke(JSContext *cx, uintN argc, jsval *vp, uintN flags)\\n     JSNative native;\\n     JSFunction *fun;\\n     JSScript *script;\\n-    uintN nslots, nvars, i;\\n-    uint32 rootedArgsFlag;\\n+    uintN nslots, nvars, nalloc, surplus;\\n     JSInterpreterHook hook;\\n     void *hookData;\\n \\n-    /* [vp .. vp + 2 + argc) must belong to the last JS stack arena. */\\n-    JS_ASSERT((jsval *) cx->stackPool.current->base <= vp);\\n-    JS_ASSERT(vp + 2 + argc <= (jsval *) cx->stackPool.current->avail);\\n+    /* Mark the top of stack and load frequently-used registers. */\\n+    mark = JS_ARENA_MARK(&cx->stackPool);\\n+    fp = cx->fp;\\n+    sp = fp->sp;\\n \\n     /*\\n-     * Mark the top of stack and load frequently-used registers. After this\\n-     * point the control should flow through label out2: to return.\\n+     * Set vp to the callee value's stack slot (it's where rval goes).\\n+     * Once vp is set, control should flow through label out2: to return.\\n+     * Set frame.rval early so native class and object ops can throw and\\n+     * return false, causing a goto out2 with ok set to false.\\n      */\\n-    mark = JS_ARENA_MARK(&cx->stackPool);\\n+    vp = sp - (2 + argc);\\n     v = *vp;\\n+    frame.rval = JSVAL_VOID;\\n \\n     /*\\n      * A callee must be an object reference, unless its 'this' parameter\\n@@ -1112,8 +1110,10 @@ js_Invoke(JSContext *cx, uintN argc, jsval *vp, uintN flags)\\n      */\\n     if (JSVAL_IS_PRIMITIVE(v)) {\\n #if JS_HAS_NO_SUCH_METHOD\\n-        if (cx->fp && cx->fp->script && !(flags & JSINVOKE_INTERNAL)) {\\n-            ok = NoSuchMethod(cx, argc, vp, flags);\\n+        if (fp->script && !(flags & JSINVOKE_INTERNAL)) {\\n+            ok = NoSuchMethod(cx, fp, vp, flags, argc);\\n+            if (ok)\\n+                frame.rval = *vp;\\n             goto out2;\\n         }\\n #endif\\n@@ -1170,8 +1170,8 @@ js_Invoke(JSContext *cx, uintN argc, jsval *vp, uintN flags)\\n have_fun:\\n         /* Get private data and set derived locals from it. */\\n         fun = (JSFunction *) OBJ_GET_PRIVATE(cx, funobj);\\n-        nslots = FUN_MINARGS(fun);\\n-        nslots = (nslots > argc) ? nslots - argc : 0;\\n+        nalloc = FUN_MINARGS(fun);\\n+        nslots = (nalloc > argc) ? nalloc - argc : 0;\\n         if (FUN_INTERPRETED(fun)) {\\n             native = NULL;\\n             script = fun->u.i.script;\\n@@ -1189,12 +1189,14 @@ have_fun:\\n         } else if (!JSVAL_IS_OBJECT(vp[1])) {\\n             JS_ASSERT(!(flags & JSINVOKE_CONSTRUCT));\\n             if (PRIMITIVE_THIS_TEST(fun, vp[1]))\\n-                goto init_slots;\\n+                goto init_frame;\\n         }\\n     }\\n \\n     if (flags & JSINVOKE_CONSTRUCT) {\\n+        /* Default return value for a constructor is the new object. */\\n         JS_ASSERT(!JSVAL_IS_PRIMITIVE(vp[1]));\\n+        frame.rval = vp[1];\\n     } else {\\n         /*\\n          * We must call js_ComputeThis in case we are not called from the\\n@@ -1206,80 +1208,9 @@ have_fun:\\n             goto out2;\\n     }\\n \\n-  init_slots:\\n-    argv = vp + 2;\\n-    sp = argv + argc;\\n-\\n-    rootedArgsFlag = JSFRAME_ROOTED_ARGV;\\n-    if (nslots != 0) {\\n-        /*\\n-         * The extra slots required by the function must be continues with the\\n-         * arguments. Thus, when the last arena does not have room to fit\\n-         * nslots right after sp and AllocateAfterSP fails, we have to copy\\n-         * [vp..vp+2+argc) slots and clear rootedArgsFlag to root the copy.\\n-         */\\n-        if (!AllocateAfterSP(cx, sp, nslots)) {\\n-            rootedArgsFlag = 0;\\n-            newvp = js_AllocRawStack(cx, 2 + argc + nslots, NULL);\\n-            if (!newvp) {\\n-                ok = JS_FALSE;\\n-                goto out2;\\n-            }\\n-            memcpy(newvp, vp, (2 + argc) * sizeof(jsval));\\n-            argv = newvp + 2;\\n-            sp = argv + argc;\\n-        }\\n-\\n-        /* Push void to initialize missing args. */\\n-        i = nslots;\\n-        do {\\n-            PUSH(JSVAL_VOID);\\n-        } while (--i != 0);\\n-    }\\n-\\n-    if (native && fun && (fun->flags & JSFUN_FAST_NATIVE)) {\\n-        JSTempValueRooter tvr;\\n-#ifdef DEBUG_NOT_THROWING\\n-        JSBool alreadyThrowing = cx->throwing;\\n-#endif\\n-#if JS_HAS_LVALUE_RETURN\\n-        /* Set by JS_SetCallReturnValue2, used to return reference types. */\\n-        cx->rval2set = JS_FALSE;\\n-#endif\\n-        /* Root the extra slots that are not covered by [vp..vp+2+argc). */\\n-        i = rootedArgsFlag ? 2 + argc : 0;\\n-        JS_PUSH_TEMP_ROOT(cx, 2 + argc + nslots - i, argv - 2 + i, &tvr);\\n-        ok = ((JSFastNative) native)(cx, argc, argv - 2);\\n-        JS_POP_TEMP_ROOT(cx, &tvr);\\n-\\n-        JS_RUNTIME_METER(cx->runtime, nativeCalls);\\n-#ifdef DEBUG_NOT_THROWING\\n-        if (ok && !alreadyThrowing)\\n-            ASSERT_NOT_THROWING(cx);\\n-#endif\\n-        goto out2;\\n-    }\\n-\\n-    /* Now allocate stack space for local variables of interpreted function. */\\n-    if (nvars) {\\n-        if (!AllocateAfterSP(cx, sp, nvars)) {\\n-            /* NB: Discontinuity between argv and vars. */\\n-            sp = js_AllocRawStack(cx, nvars, NULL);\\n-            if (!sp) {\\n-                ok = JS_FALSE;\\n-                goto out2;\\n-            }\\n-        }\\n-\\n-        /* Push void to initialize local variables. */\\n-        i = nvars;\\n-        do {\\n-            PUSH(JSVAL_VOID);\\n-        } while (--i != 0);\\n-    }\\n-\\n+  init_frame:\\n     /*\\n-     * Initialize the frame, except for sp (set by SAVE_SP later).\\n+     * Initialize the rest of frame, except for sp (set by SAVE_SP later).\\n      *\\n      * To set thisp we use an explicit cast and not JSVAL_TO_OBJECT, as vp[1]\\n      * can be a primitive value here for those native functions specified with\\n@@ -1292,20 +1223,17 @@ have_fun:\\n     frame.callee = funobj;\\n     frame.fun = fun;\\n     frame.argc = argc;\\n-    frame.argv = argv;\\n-\\n-    /* Default return value for a constructor is the new object. */\\n-    frame.rval = (flags & JSINVOKE_CONSTRUCT) ? vp[1] : JSVAL_VOID;\\n+    frame.argv = sp - argc;\\n     frame.nvars = nvars;\\n-    frame.vars = sp - nvars;\\n-    frame.down = cx->fp;\\n+    frame.vars = sp;\\n+    frame.down = fp;\\n     frame.annotation = NULL;\\n     frame.scopeChain = NULL;    /* set below for real, after cx->fp is set */\\n     frame.pc = NULL;\\n     frame.spbase = NULL;\\n     frame.sharpDepth = 0;\\n     frame.sharpArray = NULL;\\n-    frame.flags = flags | rootedArgsFlag;\\n+    frame.flags = flags;\\n     frame.dormantNext = NULL;\\n     frame.xmlNamespace = NULL;\\n     frame.blockChain = NULL;\\n@@ -1317,6 +1245,77 @@ have_fun:\\n     hook = cx->debugHooks->callHook;\\n     hookData = NULL;\\n \\n+    /* Check for argument slots required by the function. */\\n+    if (nslots) {\\n+        /* All arguments must be contiguous, so we may have to copy actuals. */\\n+        nalloc = nslots;\\n+        limit = (jsval *) cx->stackPool.current->limit;\\n+        JS_ASSERT((jsval *) cx->stackPool.current->base <= sp && sp <= limit);\\n+        if (sp + nslots > limit) {\\n+            /* Hit end of arena: we have to copy argv[-2..(argc+nslots-1)]. */\\n+            nalloc += 2 + argc;\\n+        } else {\\n+            /* Take advantage of surplus slots in the caller's frame depth. */\\n+            JS_ASSERT((jsval *)mark >= sp);\\n+            surplus = (jsval *)mark - sp;\\n+            nalloc -= surplus;\\n+        }\\n+\\n+        /* Check whether we have enough space in the caller's frame. */\\n+        if ((intN)nalloc > 0) {\\n+            /* Need space for actuals plus missing formals minus surplus. */\\n+            newsp = js_AllocRawStack(cx, nalloc, NULL);\\n+            if (!newsp) {\\n+                ok = JS_FALSE;\\n+                goto out;\\n+            }\\n+\\n+            /* If we couldn't allocate contiguous args, copy actuals now. */\\n+            if (newsp != mark) {\\n+                JS_ASSERT(sp + nslots > limit);\\n+                JS_ASSERT(2 + argc + nslots == nalloc);\\n+                *newsp++ = vp[0];\\n+                *newsp++ = vp[1];\\n+                if (argc)\\n+                    memcpy(newsp, frame.argv, argc * sizeof(jsval));\\n+                frame.argv = newsp;\\n+                sp = frame.vars = newsp + argc;\\n+            }\\n+        }\\n+\\n+        /* Advance frame.vars to make room for the missing args. */\\n+        frame.vars += nslots;\\n+\\n+        /* Push void to initialize missing args. */\\n+        do {\\n+            PUSH(JSVAL_VOID);\\n+        } while (--nslots != 0);\\n+    }\\n+    JS_ASSERT(nslots == 0);\\n+\\n+    /* Now allocate stack space for local variables. */\\n+    if (nvars) {\\n+        JS_ASSERT((jsval *)cx->stackPool.current->avail >= frame.vars);\\n+        surplus = (jsval *)cx->stackPool.current->avail - frame.vars;\\n+        if (surplus < nvars) {\\n+            newsp = js_AllocRawStack(cx, nvars, NULL);\\n+            if (!newsp) {\\n+                ok = JS_FALSE;\\n+                goto out;\\n+            }\\n+            if (newsp != sp) {\\n+                /* NB: Discontinuity between argv and vars. */\\n+                sp = frame.vars = newsp;\\n+            }\\n+        }\\n+\\n+        /* Push void to initialize local variables. */\\n+        do {\\n+            PUSH(JSVAL_VOID);\\n+        } while (--nvars != 0);\\n+    }\\n+    JS_ASSERT(nvars == 0);\\n+\\n     /* Store the current sp in frame before calling fun. */\\n     SAVE_SP(&frame);\\n \\n@@ -1336,20 +1335,23 @@ have_fun:\\n #endif\\n \\n         /* If native, use caller varobj and scopeChain for eval. */\\n-        if (cx->fp) {\\n-            frame.varobj = cx->fp->varobj;\\n-            frame.scopeChain = cx->fp->scopeChain;\\n-        } else {\\n-            frame.varobj = NULL;\\n-            frame.scopeChain = NULL;\\n-        }\\n+        frame.varobj = fp->varobj;\\n+        frame.scopeChain = fp->scopeChain;\\n \\n         /* But ensure that we have a scope chain. */\\n         if (!frame.scopeChain)\\n             frame.scopeChain = parent;\\n \\n+        if (fun && (fun->flags & JSFUN_FAST_NATIVE)) {\\n+            /*\\n+             * Note the lack of START/END_FAST_CALL bracketing here. Unlike\\n+             * the other JSFastNative call (see the JSOP_CALL special case in\\n+             * js_Interpret), we have a full stack frame for this call.\\n+             */\\n+            ok = ((JSFastNative) native)(cx, argc, frame.argv - 2);\\n+            frame.rval = frame.argv[-2];\\n+        } else {\\n #ifdef DEBUG_brendan\\n-        {\\n             static FILE *fp;\\n             if (!fp) {\\n                 fp = fopen(\\\"/tmp/slow-natives.dump\\\", \\\"w\\\");\\n@@ -1372,9 +1374,9 @@ have_fun:\\n                         ? JS_GetFunctionName(fun)\\n                         : \\\"???\\\");\\n             }\\n-        }\\n #endif\\n-        ok = native(cx, frame.thisp, argc, frame.argv, &frame.rval);\\n+            ok = native(cx, frame.thisp, argc, frame.argv, &frame.rval);\\n+        }\\n \\n         JS_RUNTIME_METER(cx->runtime, nativeCalls);\\n #ifdef DEBUG_NOT_THROWING\\n@@ -1416,16 +1418,24 @@ out:\\n     if (frame.argsobj)\\n         ok &= js_PutArgsObject(cx, &frame);\\n \\n-    *vp = frame.rval;\\n-\\n     /* Restore cx->fp now that we're done releasing frame objects. */\\n-    cx->fp = frame.down;\\n+    cx->fp = fp;\\n \\n out2:\\n     /* Pop everything we may have allocated off the stack. */\\n     JS_ARENA_RELEASE(&cx->stackPool, mark);\\n-    if (!ok)\\n-        *vp = JSVAL_NULL;\\n+\\n+    /* Store the return value and restore sp just above it. */\\n+    *vp = frame.rval;\\n+    fp->sp = vp + 1;\\n+\\n+    /*\\n+     * Store the location of the JSOP_CALL or JSOP_EVAL that generated the\\n+     * return value, but only if this is an external (compiled from script\\n+     * source) call that has stack budget for the generating pc.\\n+     */\\n+    if (fp->script && !(flags & JSINVOKE_INTERNAL))\\n+        vp[-(intN)fp->script->depth] = (jsval)fp->pc;\\n     return ok;\\n \\n bad:\\n@@ -1438,20 +1448,33 @@ JSBool\\n js_InternalInvoke(JSContext *cx, JSObject *obj, jsval fval, uintN flags,\\n                   uintN argc, jsval *argv, jsval *rval)\\n {\\n-    jsval *invokevp;\\n+    JSStackFrame *fp, *oldfp, frame;\\n+    jsval *oldsp, *sp;\\n     void *mark;\\n+    uintN i;\\n     JSBool ok;\\n \\n-    invokevp = js_AllocStack(cx, 2 + argc, &mark);\\n-    if (!invokevp)\\n-        return JS_FALSE;\\n-\\n-    invokevp[0] = fval;\\n-    invokevp[1] = OBJECT_TO_JSVAL(obj);\\n-    memcpy(invokevp + 2, argv, argc * sizeof *argv);\\n+    fp = oldfp = cx->fp;\\n+    if (!fp) {\\n+        memset(&frame, 0, sizeof frame);\\n+        cx->fp = fp = &frame;\\n+    }\\n+    oldsp = fp->sp;\\n+    sp = js_AllocStack(cx, 2 + argc, &mark);\\n+    if (!sp) {\\n+        ok = JS_FALSE;\\n+        goto out;\\n+    }\\n \\n-    ok = js_Invoke(cx, argc, invokevp, flags | JSINVOKE_INTERNAL);\\n+    PUSH(fval);\\n+    PUSH(OBJECT_TO_JSVAL(obj));\\n+    for (i = 0; i < argc; i++)\\n+        PUSH(argv[i]);\\n+    SAVE_SP(fp);\\n+    ok = js_Invoke(cx, argc, flags | JSINVOKE_INTERNAL);\\n     if (ok) {\\n+        RESTORE_SP(fp);\\n+\\n         /*\\n          * Store *rval in the a scoped local root if a scope is open, else in\\n          * the lastInternalResult pigeon-hole GC root, solely so users of\\n@@ -1459,7 +1482,7 @@ js_InternalInvoke(JSContext *cx, JSObject *obj, jsval fval, uintN flags,\\n          * example) callers do not need to manage roots for local, temporary\\n          * references to such results.\\n          */\\n-        *rval = *invokevp;\\n+        *rval = POP_OPND();\\n         if (JSVAL_IS_GCTHING(*rval) && *rval != JSVAL_NULL) {\\n             if (cx->localRootStack) {\\n                 if (js_PushLocalRoot(cx, cx->localRootStack, *rval) < 0)\\n@@ -1471,6 +1494,11 @@ js_InternalInvoke(JSContext *cx, JSObject *obj, jsval fval, uintN flags,\\n     }\\n \\n     js_FreeStack(cx, mark);\\n+out:\\n+    fp->sp = oldsp;\\n+    if (oldfp != fp)\\n+        cx->fp = oldfp;\\n+\\n     return ok;\\n }\\n \\n@@ -1928,7 +1956,7 @@ js_InvokeConstructor(JSContext *cx, jsval *vp, uintN argc)\\n \\n     /* Now we have an object with a constructor method; call it. */\\n     vp[1] = OBJECT_TO_JSVAL(obj);\\n-    if (!js_Invoke(cx, argc, vp, JSINVOKE_CONSTRUCT)) {\\n+    if (!js_Invoke(cx, argc, JSINVOKE_CONSTRUCT)) {\\n         cx->weakRoots.newborn[GCX_OBJECT] = NULL;\\n         return JS_FALSE;\\n     }\\n@@ -3488,8 +3516,7 @@ interrupt:\\n             ok = js_InvokeConstructor(cx, vp, argc);\\n             if (!ok)\\n                 goto out;\\n-            sp = vp + 1;\\n-            vp[-depth] = (jsval)pc;\\n+            RESTORE_SP(fp);\\n             LOAD_INTERRUPT_HANDLER(cx);\\n             obj = JSVAL_TO_OBJECT(*vp);\\n             len = js_CodeSpec[op].length;\\n@@ -4061,12 +4088,7 @@ interrupt:\\n                         if (sp + nargs > fp->spbase + depth)\\n                             goto do_invoke;\\n                         do {\\n-                            /*\\n-                             * Use PUSH_OPND to set the proper pc values for\\n-                             * the extra arguments. The decompiler relies on\\n-                             * this.\\n-                             */\\n-                            PUSH_OPND(JSVAL_VOID);\\n+                            PUSH(JSVAL_VOID);\\n                         } while (--nargs != 0);\\n                         SAVE_SP(fp);\\n                     }\\n@@ -4074,7 +4096,9 @@ interrupt:\\n                     JS_ASSERT(!JSVAL_IS_PRIMITIVE(vp[1]) ||\\n                               PRIMITIVE_THIS_TEST(fun, vp[1]));\\n \\n+                    START_FAST_CALL(fp);\\n                     ok = ((JSFastNative) fun->u.n.native)(cx, argc, vp);\\n+                    END_FAST_CALL(fp);\\n                     if (!ok)\\n                         goto out;\\n                     sp = vp + 1;\\n@@ -4084,9 +4108,8 @@ interrupt:\\n             }\\n \\n           do_invoke:\\n-            ok = js_Invoke(cx, argc, vp, 0);\\n-            sp = vp + 1;\\n-            vp[-depth] = (jsval)pc;\\n+            ok = js_Invoke(cx, argc, 0);\\n+            RESTORE_SP(fp);\\n             LOAD_INTERRUPT_HANDLER(cx);\\n             if (!ok)\\n                 goto out;\\n@@ -4123,10 +4146,8 @@ interrupt:\\n           BEGIN_CASE(JSOP_SETCALL)\\n             argc = GET_ARGC(pc);\\n             SAVE_SP_AND_PC(fp);\\n-            vp = sp - argc - 2;\\n-            ok = js_Invoke(cx, argc, vp, 0);\\n-            sp = vp + 1;\\n-            vp[-depth] = (jsval)pc;\\n+            ok = js_Invoke(cx, argc, 0);\\n+            RESTORE_SP(fp);\\n             LOAD_INTERRUPT_HANDLER(cx);\\n             if (!ok)\\n                 goto out;\\ndiff --git a/js/src/jsinterp.h b/js/src/jsinterp.h\\nindex 073d6da..65dd998 100644\\n--- a/js/src/jsinterp.h\\n+++ b/js/src/jsinterp.h\\n@@ -95,21 +95,24 @@ typedef struct JSInlineFrame {\\n /* JS stack frame flags. */\\n #define JSFRAME_CONSTRUCTING  0x01  /* frame is for a constructor invocation */\\n #define JSFRAME_INTERNAL      0x02  /* internal call, not invoked by a script */\\n-#define JSFRAME_ASSIGNING     0x04  /* a complex (not simplex JOF_ASSIGNING) op\\n+#define JSFRAME_SKIP_CALLER   0x04  /* skip one link when evaluating f.caller\\n+                                       for this invocation of f */\\n+#define JSFRAME_ASSIGNING     0x08  /* a complex (not simplex JOF_ASSIGNING) op\\n                                        is currently assigning to a property */\\n-#define JSFRAME_DEBUGGER      0x08  /* frame for JS_EvaluateInStackFrame */\\n-#define JSFRAME_EVAL          0x10  /* frame for obj_eval */\\n-#define JSFRAME_SPECIAL       0x18  /* special evaluation frame flags */\\n-#define JSFRAME_COMPILING     0x20  /* frame is being used by compiler */\\n-#define JSFRAME_COMPILE_N_GO  0x40  /* compiler-and-go mode, can optimize name\\n+#define JSFRAME_DEBUGGER      0x10  /* frame for JS_EvaluateInStackFrame */\\n+#define JSFRAME_EVAL          0x20  /* frame for obj_eval */\\n+#define JSFRAME_SPECIAL       0x30  /* special evaluation frame flags */\\n+#define JSFRAME_COMPILING     0x40  /* frame is being used by compiler */\\n+#define JSFRAME_COMPILE_N_GO  0x80  /* compiler-and-go mode, can optimize name\\n                                        references based on scope chain */\\n-#define JSFRAME_SCRIPT_OBJECT 0x80  /* compiling source for a Script object */\\n-#define JSFRAME_YIELDING      0x100 /* js_Interpret dispatched JSOP_YIELD */\\n-#define JSFRAME_FILTERING     0x200 /* XML filtering predicate expression */\\n-#define JSFRAME_ITERATOR      0x400 /* trying to get an iterator for for-in */\\n-#define JSFRAME_POP_BLOCKS    0x800 /* scope chain contains blocks to pop */\\n-#define JSFRAME_GENERATOR    0x1000 /* frame belongs to generator-iterator */\\n-#define JSFRAME_ROOTED_ARGV  0x2000 /* frame.argv is rooted by the caller */\\n+#define JSFRAME_SCRIPT_OBJECT 0x100 /* compiling source for a Script object */\\n+#define JSFRAME_YIELDING      0x200 /* js_Interpret dispatched JSOP_YIELD */\\n+#define JSFRAME_FILTERING     0x400 /* XML filtering predicate expression */\\n+#define JSFRAME_ITERATOR      0x800 /* trying to get an iterator for for-in */\\n+#define JSFRAME_POP_BLOCKS   0x1000 /* scope chain contains blocks to pop */\\n+#define JSFRAME_GENERATOR    0x2000 /* frame belongs to generator-iterator */\\n+#define JSFRAME_IN_FAST_CALL 0x4000 /* calling frame is calling a fast native */\\n+#define JSFRAME_DID_SET_RVAL 0x8000 /* fast native used JS_SET_RVAL(cx, vp) */\\n \\n #define JSFRAME_OVERRIDE_SHIFT 24   /* override bit-set params; see jsfun.c */\\n #define JSFRAME_OVERRIDE_BITS  8\\n@@ -175,15 +178,11 @@ js_ComputeThis(JSContext *cx, jsval *argv);\\n \\n /*\\n  * NB: js_Invoke requires that cx is currently running JS (i.e., that cx->fp\\n- * is non-null), and that vp points to the callee, |this| parameter, and\\n- * actual arguments of the call. [vp .. vp + 2 + argc) must belong to the last\\n- * JS stack segment that js_AllocStack or js_AllocRawStack allocated. The\\n- * function may use the space available after vp + 2 + argc in the stack\\n- * segment for temporaries so the caller should not use that space for values\\n- * that must be preserved across the call.\\n+ * is non-null), and that the callee, |this| parameter, and actual arguments\\n+ * are already pushed on the stack under cx->fp->sp.\\n  */\\n extern JS_FRIEND_API(JSBool)\\n-js_Invoke(JSContext *cx, uintN argc, jsval *vp, uintN flags);\\n+js_Invoke(JSContext *cx, uintN argc, uintN flags);\\n \\n /*\\n  * Consolidated js_Invoke flags simply rename certain JSFRAME_* flags, so that\\n@@ -200,6 +199,7 @@ js_Invoke(JSContext *cx, uintN argc, jsval *vp, uintN flags);\\n  */\\n #define JSINVOKE_CONSTRUCT      JSFRAME_CONSTRUCTING\\n #define JSINVOKE_INTERNAL       JSFRAME_INTERNAL\\n+#define JSINVOKE_SKIP_CALLER    JSFRAME_SKIP_CALLER\\n #define JSINVOKE_ITERATOR       JSFRAME_ITERATOR\\n \\n /*\\ndiff --git a/js/src/jsiter.c b/js/src/jsiter.c\\nindex 54dcfa9..8fe22ed 100644\\n--- a/js/src/jsiter.c\\n+++ b/js/src/jsiter.c\\n@@ -802,7 +802,7 @@ js_NewGenerator(JSContext *cx, JSStackFrame *fp)\\n     /* Copy remaining state (XXX sharp* and xml* should be local vars). */\\n     gen->frame.sharpDepth = 0;\\n     gen->frame.sharpArray = NULL;\\n-    gen->frame.flags = (fp->flags & ~JSFRAME_ROOTED_ARGV) | JSFRAME_GENERATOR;\\n+    gen->frame.flags = fp->flags | JSFRAME_GENERATOR;\\n     gen->frame.dormantNext = NULL;\\n     gen->frame.xmlNamespace = NULL;\\n     gen->frame.blockChain = NULL;\\ndiff --git a/js/src/jsstr.c b/js/src/jsstr.c\\nindex b29ef44..9340390 100644\\n--- a/js/src/jsstr.c\\n+++ b/js/src/jsstr.c\\n@@ -1391,8 +1391,9 @@ find_replen(JSContext *cx, ReplaceData *rdata, size_t *sizep)\\n     lambda = rdata->lambda;\\n     if (lambda) {\\n         uintN argc, i, j, m, n, p;\\n-        jsval *invokevp, *sp;\\n+        jsval *sp, *oldsp, rval;\\n         void *mark;\\n+        JSStackFrame *fp;\\n         JSBool ok;\\n \\n         /*\\n@@ -1414,12 +1415,11 @@ find_replen(JSContext *cx, ReplaceData *rdata, size_t *sizep)\\n          */\\n         p = rdata->base.regexp->parenCount;\\n         argc = 1 + p + 2;\\n-        invokevp = js_AllocStack(cx, 2 + argc, &mark);\\n-        if (!invokevp)\\n+        sp = js_AllocStack(cx, 2 + argc, &mark);\\n+        if (!sp)\\n             return JS_FALSE;\\n \\n         /* Push lambda and its 'this' parameter. */\\n-        sp = invokevp;\\n         *sp++ = OBJECT_TO_JSVAL(lambda);\\n         *sp++ = OBJECT_TO_JSVAL(OBJ_GET_PARENT(cx, lambda));\\n \\n@@ -1463,14 +1463,21 @@ find_replen(JSContext *cx, ReplaceData *rdata, size_t *sizep)\\n         *sp++ = INT_TO_JSVAL((jsint)cx->regExpStatics.leftContext.length);\\n         *sp++ = STRING_TO_JSVAL(rdata->base.str);\\n \\n-        ok = js_Invoke(cx, argc, invokevp, JSINVOKE_INTERNAL);\\n+        /* Lift current frame to include the args and do the call. */\\n+        fp = cx->fp;\\n+        oldsp = fp->sp;\\n+        fp->sp = sp;\\n+        ok = js_Invoke(cx, argc, JSINVOKE_INTERNAL);\\n+        rval = fp->sp[-1];\\n+        fp->sp = oldsp;\\n+\\n         if (ok) {\\n             /*\\n              * NB: we count on the newborn string root to hold any string\\n              * created by this js_ValueToString that would otherwise be GC-\\n              * able, until we use rdata->repstr in do_replace.\\n              */\\n-            repstr = js_ValueToString(cx, *invokevp);\\n+            repstr = js_ValueToString(cx, rval);\\n             if (!repstr) {\\n                 ok = JS_FALSE;\\n             } else {\\ndiff --git a/js/src/xpconnect/src/xpcwrappedjsclass.cpp b/js/src/xpconnect/src/xpcwrappedjsclass.cpp\\nindex faacc2b..2bc6080 100644\\n--- a/js/src/xpconnect/src/xpcwrappedjsclass.cpp\\n+++ b/js/src/xpconnect/src/xpcwrappedjsclass.cpp\\n@@ -1022,7 +1022,7 @@ nsXPCWrappedJSClass::CallMethod(nsXPCWrappedJS* wrapper, uint16 methodIndex,\\n                                 const XPTMethodDescriptor* info,\\n                                 nsXPTCMiniVariant* nativeParams)\\n {\\n-    jsval* stackbase = nsnull;\\n+    jsval* stackbase;\\n     jsval* sp = nsnull;\\n     uint8 i;\\n     uint8 argc=0;\\n@@ -1440,8 +1440,26 @@ pre_call_clean_up:\\n     {\\n         if(!JSVAL_IS_PRIMITIVE(fval))\\n         {\\n-            success = js_Invoke(cx, argc, stackbase, JSINVOKE_INTERNAL);\\n-            result = *stackbase;\\n+            // Lift current frame (or make new one) to include the args\\n+            // and do the call.\\n+            JSStackFrame *fp, *oldfp, frame;\\n+            jsval *oldsp;\\n+\\n+            fp = oldfp = cx->fp;\\n+            if(!fp)\\n+            {\\n+                memset(&frame, 0, sizeof frame);\\n+                cx->fp = fp = &frame;\\n+            }\\n+            oldsp = fp->sp;\\n+            fp->sp = sp;\\n+\\n+            success = js_Invoke(cx, argc, JSINVOKE_INTERNAL);\\n+\\n+            result = fp->sp[-1];\\n+            fp->sp = oldsp;\\n+            if(oldfp != fp)\\n+                cx->fp = oldfp;\\n         }\\n         else\\n         {\\n\""}