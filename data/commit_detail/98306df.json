{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas98306df\""},"diff":"\"98306df Do stack walking on a single thread to avoid deadlocks during thread creation.  b=391321  r=robarnold@mozilla.com  sr=jmathies@mozilla.com (delegated by bsmedberg)  a1.9=bzbarsky@mit.edu\\ndiff --git a/xpcom/base/nsStackWalk.cpp b/xpcom/base/nsStackWalk.cpp\\nindex e17840d..7bced5c 100644\\n--- a/xpcom/base/nsStackWalk.cpp\\n+++ b/xpcom/base/nsStackWalk.cpp\\n@@ -45,8 +45,10 @@\\n \\n #include \\\"nscore.h\\\"\\n #include <windows.h>\\n+#include <process.h>\\n #include <stdio.h>\\n #include \\\"plstr.h\\\"\\n+#include \\\"nsMemory.h\\\" // for NS_ARRAY_LENGTH\\n \\n #include \\\"nspr.h\\\"\\n #ifdef _M_IX86\\n@@ -180,15 +182,18 @@ PRBool EnsureImageHlpInitialized();\\n BOOL SymGetModuleInfoEspecial(HANDLE aProcess, DWORD aAddr, PIMAGEHLP_MODULE aModuleInfo, PIMAGEHLP_LINE aLineInfo);\\n \\n struct WalkStackData {\\n-  NS_WalkStackCallback callback;\\n   PRUint32 skipFrames;\\n-  void *closure;\\n   HANDLE thread;\\n   HANDLE process;\\n+  HANDLE eventStart;\\n+  HANDLE eventEnd;\\n+  void **pcs;\\n+  PRUint32 pc_size;\\n+  PRUint32 pc_count;\\n };\\n \\n void PrintError(char *prefix, WalkStackData* data);\\n-DWORD WINAPI  WalkStackThread(LPVOID data);\\n+unsigned int WINAPI WalkStackThread(void* data);\\n void WalkStackMain64(struct WalkStackData* data);\\n void WalkStackMain(struct WalkStackData* data);\\n \\n@@ -264,7 +269,8 @@ SYMGETLINEFROMADDRPROC64 _SymGetLineFromAddr64;\\n #define _SymGetLineFromAddr64 0\\n #endif\\n \\n-HANDLE hStackWalkMutex;\\n+DWORD gStackWalkThread;\\n+CRITICAL_SECTION gDbgHelpCS;\\n \\n PR_END_EXTERN_C\\n \\n@@ -297,16 +303,29 @@ EnsureImageHlpInitialized()\\n     if (gInitialized)\\n         return gInitialized;\\n \\n-    // Create a mutex with no initial owner.\\n-    hStackWalkMutex = CreateMutex(\\n-      NULL,                       // default security attributes\\n-      FALSE,                      // initially not owned\\n-      NULL);                      // unnamed mutex\\n-\\n-    if (hStackWalkMutex == NULL) {\\n-        PrintError(\\\"CreateMutex\\\");\\n+    // Hope that our first call doesn't happen during static\\n+    // initialization.  If it does, this CreateThread call won't\\n+    // actually start the thread until after the static initialization\\n+    // is done, which means we'll deadlock while waiting for it to\\n+    // process a stack.\\n+    HANDLE readyEvent = ::CreateEvent(NULL, FALSE /* auto-reset*/,\\n+                            FALSE /* initially non-signaled */, NULL);\\n+    unsigned int threadID;\\n+    HANDLE hStackWalkThread = (HANDLE)\\n+      _beginthreadex(NULL, 0, WalkStackThread, (void*)readyEvent,\\n+                     0, &threadID);\\n+    gStackWalkThread = threadID;\\n+    if (hStackWalkThread == NULL) {\\n+        PrintError(\\\"CreateThread\\\");\\n         return PR_FALSE;\\n     }\\n+    ::CloseHandle(hStackWalkThread);\\n+\\n+    // Wait for the thread's event loop to start before posting events to it.\\n+    ::WaitForSingleObject(readyEvent, INFINITE);\\n+    ::CloseHandle(readyEvent);\\n+\\n+    ::InitializeCriticalSection(&gDbgHelpCS);\\n \\n     HMODULE module = ::LoadLibrary(\\\"DBGHELP.DLL\\\");\\n     if (!module) {\\n@@ -415,75 +434,60 @@ WalkStackMain64(struct WalkStackData* data)\\n     frame64.AddrStack.Offset = context.SP;\\n     frame64.AddrFrame.Offset = context.RsBSP;\\n #else\\n-    PrintError(\\\"Unknown platform. No stack walking.\\\");\\n-    return;\\n+#error \\\"Should not have compiled this code\\\"\\n #endif\\n     frame64.AddrPC.Mode      = AddrModeFlat;\\n     frame64.AddrStack.Mode   = AddrModeFlat;\\n     frame64.AddrFrame.Mode   = AddrModeFlat;\\n     frame64.AddrReturn.Mode  = AddrModeFlat;\\n \\n-    // Now walk the stack and map the pc's to symbol names\\n+    // Now walk the stack\\n     while (1) {\\n \\n-        ok = 0;\\n-\\n-        // stackwalk is not threadsafe, so grab the lock.\\n-        DWORD dwWaitResult;\\n-        dwWaitResult = WaitForSingleObject(hStackWalkMutex, INFINITE);\\n-        if (dwWaitResult == WAIT_OBJECT_0) {\\n-\\n-            ok = _StackWalk64(\\n+        // debug routines are not threadsafe, so grab the lock.\\n+        EnterCriticalSection(&gDbgHelpCS);\\n+        ok = _StackWalk64(\\n #ifdef _M_AMD64\\n-              IMAGE_FILE_MACHINE_AMD64,\\n+          IMAGE_FILE_MACHINE_AMD64,\\n #elif defined _M_IA64\\n-              IMAGE_FILE_MACHINE_IA64,\\n+          IMAGE_FILE_MACHINE_IA64,\\n #elif defined _M_IX86\\n-              IMAGE_FILE_MACHINE_I386,\\n+          IMAGE_FILE_MACHINE_I386,\\n #else\\n-              0,\\n+#error \\\"Should not have compiled this code\\\"\\n #endif\\n-              myProcess,\\n-              myThread,\\n-              &frame64,\\n-              &context,\\n-              NULL,\\n-              _SymFunctionTableAccess64, // function table access routine\\n-              _SymGetModuleBase64,       // module base routine\\n-              0\\n-            );\\n-\\n-            ReleaseMutex(hStackWalkMutex);  // release our lock\\n-\\n-            if (ok)\\n-                addr = frame64.AddrPC.Offset;\\n-            else {\\n-                addr = 0;\\n-                PrintError(\\\"WalkStack64\\\");\\n-            }\\n+          myProcess,\\n+          myThread,\\n+          &frame64,\\n+          &context,\\n+          NULL,\\n+          _SymFunctionTableAccess64, // function table access routine\\n+          _SymGetModuleBase64,       // module base routine\\n+          0\\n+        );\\n+        LeaveCriticalSection(&gDbgHelpCS);\\n+\\n+        if (ok)\\n+            addr = frame64.AddrPC.Offset;\\n+        else {\\n+            addr = 0;\\n+            PrintError(\\\"WalkStack64\\\");\\n+        }\\n \\n-            if (!ok || (addr == 0)) {\\n-                break;\\n-            }\\n+        if (!ok || (addr == 0)) {\\n+            break;\\n+        }\\n \\n-            if (skip-- > 0) {\\n-                continue;\\n-            }\\n+        if (skip-- > 0) {\\n+            continue;\\n+        }\\n \\n-            (*data->callback)((void*)addr, data->closure);\\n+        if (data->pc_count < data->pc_size)\\n+            data->pcs[data->pc_count] = (void*)addr;\\n+        ++data->pc_count;\\n \\n-#if 0\\n-            // Stop walking when we get to kernel32.\\n-            if (strcmp(modInfo.ModuleName, \\\"kernel32\\\") == 0)\\n-                break;\\n-#else\\n-            if (frame64.AddrReturn.Offset == 0)\\n-                break;\\n-#endif\\n-        }\\n-        else {\\n-            PrintError(\\\"LockError64\\\");\\n-        } \\n+        if (frame64.AddrReturn.Offset == 0)\\n+            break;\\n     }\\n     return;\\n #endif\\n@@ -526,86 +530,98 @@ WalkStackMain(struct WalkStackData* data)\\n     return;\\n #endif\\n \\n-    // Now walk the stack and map the pc's to symbol names\\n+    // Now walk the stack\\n     while (1) {\\n \\n-        ok = 0;\\n-\\n         // debug routines are not threadsafe, so grab the lock.\\n-        DWORD dwWaitResult;\\n-        dwWaitResult = WaitForSingleObject(hStackWalkMutex, INFINITE);\\n-        if (dwWaitResult == WAIT_OBJECT_0) {\\n-\\n-            ok = _StackWalk(\\n-                IMAGE_FILE_MACHINE_I386,\\n-                myProcess,\\n-                myThread,\\n-                &frame,\\n-                &context,\\n-                0,                        // read process memory routine\\n-                _SymFunctionTableAccess,  // function table access routine\\n-                _SymGetModuleBase,        // module base routine\\n-                0                         // translate address routine\\n-              );\\n-\\n-            ReleaseMutex(hStackWalkMutex);  // release our lock\\n-\\n-            if (ok)\\n-                addr = frame.AddrPC.Offset;\\n-            else {\\n-                addr = 0;\\n-                PrintError(\\\"WalkStack\\\");\\n-            }\\n+        EnterCriticalSection(&gDbgHelpCS);\\n+        ok = _StackWalk(\\n+            IMAGE_FILE_MACHINE_I386,\\n+            myProcess,\\n+            myThread,\\n+            &frame,\\n+            &context,\\n+            0,                        // read process memory routine\\n+            _SymFunctionTableAccess,  // function table access routine\\n+            _SymGetModuleBase,        // module base routine\\n+            0                         // translate address routine\\n+          );\\n+        LeaveCriticalSection(&gDbgHelpCS);\\n+\\n+        if (ok)\\n+            addr = frame.AddrPC.Offset;\\n+        else {\\n+            addr = 0;\\n+            PrintError(\\\"WalkStack\\\");\\n+        }\\n \\n-            if (!ok || (addr == 0)) {\\n-                break;\\n-            }\\n+        if (!ok || (addr == 0)) {\\n+            break;\\n+        }\\n \\n-            if (skip-- > 0) {\\n-                continue;\\n-            }\\n+        if (skip-- > 0) {\\n+            continue;\\n+        }\\n \\n-            (*data->callback)((void*)addr, data->closure);\\n+        if (data->pc_count < data->pc_size)\\n+            data->pcs[data->pc_count] = (void*)addr;\\n+        ++data->pc_count;\\n \\n-#if 0\\n-            // Stop walking when we get to kernel32.dll.\\n-            if (strcmp(modInfo.ImageName, \\\"kernel32.dll\\\") == 0)\\n-                break;\\n-#else\\n-            if (frame.AddrReturn.Offset == 0)\\n-                break;\\n-#endif\\n-        }\\n-        else {\\n-            PrintError(\\\"LockError\\\");\\n-        }\\n-        \\n+        if (frame.AddrReturn.Offset == 0)\\n+            break;\\n     }\\n \\n     return;\\n \\n }\\n \\n-DWORD WINAPI\\n-WalkStackThread(LPVOID lpdata)\\n+unsigned int WINAPI\\n+WalkStackThread(void* aData)\\n {\\n-    struct WalkStackData *data = (WalkStackData *)lpdata;\\n-    DWORD ret ;\\n-\\n-    // Suspend the calling thread, dump his stack, and then resume him.\\n-    // He's currently waiting for us to finish so now should be a good time.\\n-    ret = ::SuspendThread( data->thread );\\n-    if (ret == -1) {\\n-        PrintError(\\\"ThreadSuspend\\\");\\n-    }\\n-    else {\\n-        if (_StackWalk64)\\n-            WalkStackMain64(data);\\n-        else\\n-            WalkStackMain(data);\\n-        ret = ::ResumeThread(data->thread);\\n-        if (ret == -1) {\\n-            PrintError(\\\"ThreadResume\\\");\\n+    BOOL msgRet;\\n+    MSG msg;\\n+\\n+    // Call PeekMessage to force creation of a message queue so that\\n+    // other threads can safely post events to us.\\n+    ::PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);\\n+\\n+    // and tell the thread that created us that we're ready.\\n+    HANDLE readyEvent = (HANDLE)aData;\\n+    ::SetEvent(readyEvent);\\n+\\n+    while ((msgRet = ::GetMessage(&msg, (HWND)-1, 0, 0)) != 0) {\\n+        if (msgRet == -1) {\\n+            PrintError(\\\"GetMessage\\\");\\n+        } else {\\n+            DWORD ret;\\n+\\n+            struct WalkStackData *data = (WalkStackData *)msg.lParam;\\n+\\n+            // Don't suspend the calling thread until it's waiting for\\n+            // us; otherwise the number of frames on the stack could vary.\\n+            ret = ::WaitForSingleObject(data->eventStart, INFINITE);\\n+            if (ret != WAIT_OBJECT_0)\\n+                PrintError(\\\"WaitForSingleObject\\\");\\n+\\n+            // Suspend the calling thread, dump his stack, and then resume him.\\n+            // He's currently waiting for us to finish so now should be a good time.\\n+            ret = ::SuspendThread( data->thread );\\n+            if (ret == -1) {\\n+                PrintError(\\\"ThreadSuspend\\\");\\n+            }\\n+            else {\\n+                if (_StackWalk64)\\n+                    WalkStackMain64(data);\\n+                else\\n+                    WalkStackMain(data);\\n+\\n+                ret = ::ResumeThread(data->thread);\\n+                if (ret == -1) {\\n+                    PrintError(\\\"ThreadResume\\\");\\n+                }\\n+            }\\n+\\n+            ::SetEvent(data->eventEnd);\\n         }\\n     }\\n \\n@@ -624,7 +640,7 @@ EXPORT_XPCOM_API(nsresult)\\n NS_StackWalk(NS_WalkStackCallback aCallback, PRUint32 aSkipFrames,\\n              void *aClosure)\\n {\\n-    HANDLE myProcess, myThread, walkerThread;\\n+    HANDLE myProcess, myThread;\\n     DWORD walkerReturn;\\n     struct WalkStackData data;\\n \\n@@ -650,24 +666,46 @@ NS_StackWalk(NS_WalkStackCallback aCallback, PRUint32 aSkipFrames,\\n         return NS_ERROR_FAILURE;\\n     }\\n \\n-    data.callback = aCallback;\\n     data.skipFrames = aSkipFrames;\\n-    data.closure = aClosure;\\n     data.thread = myThread;\\n     data.process = myProcess;\\n-    walkerThread = ::CreateThread( NULL, 0, WalkStackThread, (LPVOID) &data, 0, NULL ) ;\\n-    if (walkerThread) {\\n-        walkerReturn = ::WaitForSingleObject(walkerThread, 2000); // no timeout is never a good idea\\n-        if (walkerReturn != WAIT_OBJECT_0) {\\n-            PrintError(\\\"ThreadWait\\\");\\n-        }\\n-        ::CloseHandle(walkerThread);\\n-    }\\n-    else {\\n-        PrintError(\\\"ThreadCreate\\\");\\n+    data.eventStart = ::CreateEvent(NULL, FALSE /* auto-reset*/,\\n+                          FALSE /* initially non-signaled */, NULL);\\n+    data.eventEnd = ::CreateEvent(NULL, FALSE /* auto-reset*/,\\n+                        FALSE /* initially non-signaled */, NULL);\\n+    void *local_pcs[1024];\\n+    data.pcs = local_pcs;\\n+    data.pc_count = 0;\\n+    data.pc_size = NS_ARRAY_LENGTH(local_pcs);\\n+\\n+    ::PostThreadMessage(gStackWalkThread, WM_USER, 0, (LPARAM)&data);\\n+\\n+    walkerReturn = ::SignalObjectAndWait(data.eventStart,\\n+                       data.eventEnd, INFINITE, FALSE);\\n+    if (walkerReturn != WAIT_OBJECT_0)\\n+        PrintError(\\\"SignalObjectAndWait (1)\\\");\\n+    if (data.pc_count > data.pc_size) {\\n+        data.pcs = (void**) malloc(data.pc_count * sizeof(void*));\\n+        data.pc_size = data.pc_count;\\n+        data.pc_count = 0;\\n+        ::PostThreadMessage(gStackWalkThread, WM_USER, 0, (LPARAM)&data);\\n+        walkerReturn = ::SignalObjectAndWait(data.eventStart,\\n+                           data.eventEnd, INFINITE, FALSE);\\n+        if (walkerReturn != WAIT_OBJECT_0)\\n+            PrintError(\\\"SignalObjectAndWait (2)\\\");\\n     }\\n+\\n     ::CloseHandle(myThread);\\n     ::CloseHandle(myProcess);\\n+    ::CloseHandle(data.eventStart);\\n+    ::CloseHandle(data.eventEnd);\\n+\\n+    for (PRUint32 i = 0; i < data.pc_count; ++i)\\n+        (*aCallback)(data.pcs[i], aClosure);\\n+\\n+    if (data.pc_size > NS_ARRAY_LENGTH(local_pcs))\\n+        free(data.pcs);\\n+\\n     return NS_OK;\\n }\\n \\n@@ -916,10 +954,7 @@ NS_DescribeCodeAddress(void *aPC, nsCodeAddressDetails *aDetails)\\n     BOOL ok;\\n \\n     // debug routines are not threadsafe, so grab the lock.\\n-    DWORD dwWaitResult;\\n-    dwWaitResult = WaitForSingleObject(hStackWalkMutex, INFINITE);\\n-    if (dwWaitResult != WAIT_OBJECT_0)\\n-        return NS_ERROR_UNEXPECTED;\\n+    EnterCriticalSection(&gDbgHelpCS);\\n \\n #ifdef USING_WXP_VERSION\\n     if (_StackWalk64) {\\n@@ -1011,7 +1046,7 @@ NS_DescribeCodeAddress(void *aPC, nsCodeAddressDetails *aDetails)\\n         }\\n     }\\n \\n-    ReleaseMutex(hStackWalkMutex);  // release our lock\\n+    LeaveCriticalSection(&gDbgHelpCS); // release our lock\\n     return NS_OK;\\n }\\n \\n\""}