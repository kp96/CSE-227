{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basae62dbd\""},"diff":"\"ae62dbd Don't do ARGB->RGBA translation in clipboard/drag image handling. patch by 'Ili Butterfield. b=393336 r=cbarrett r=josh sr=pinkerton a=pav\\ndiff --git a/widget/src/cocoa/nsClipboard.mm b/widget/src/cocoa/nsClipboard.mm\\nindex e5ed29ef..d53e084 100644\\n--- a/widget/src/cocoa/nsClipboard.mm\\n+++ b/widget/src/cocoa/nsClipboard.mm\\n@@ -38,9 +38,7 @@\\n \\n #include \\\"nsCOMPtr.h\\\"\\n #include \\\"nsClipboard.h\\\"\\n-#include \\\"nsIClipboardOwner.h\\\"\\n #include \\\"nsString.h\\\"\\n-#include \\\"nsXPCOM.h\\\"\\n #include \\\"nsISupportsPrimitives.h\\\"\\n #include \\\"nsXPIDLString.h\\\"\\n #include \\\"nsPrimitiveHelpers.h\\\"\\n@@ -342,41 +340,47 @@ nsClipboard::PasteboardDictFromTransferable(nsITransferable* aTransferable)\\n       if ((stride % 4 != 0) || (height < 1) || (width < 1))\\n         continue;\\n \\n-      PRUint32* imageData = (PRUint32*)image->GetBits();\\n-\\n-      PRUint32* reorderedData = (PRUint32*)malloc(height * stride);\\n-      if (!reorderedData)\\n+      // Create a CGImageRef with the bits from the image, taking into account\\n+      // the alpha ordering and endianness of the machine so we don't have to\\n+      // touch the bits ourselves.\\n+      CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL,\\n+                                                                    image->GetBits(),\\n+                                                                    stride * height,\\n+                                                                    NULL);\\n+      CGColorSpaceRef colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);\\n+      CGImageRef imageRef = CGImageCreate(width,\\n+                                          height,\\n+                                          8,\\n+                                          32,\\n+                                          stride,\\n+                                          colorSpace,\\n+                                          kCGBitmapByteOrder32Host | kCGImageAlphaFirst,\\n+                                          dataProvider,\\n+                                          NULL,\\n+                                          0,\\n+                                          kCGRenderingIntentDefault);\\n+      CGDataProviderRelease(dataProvider);\\n+\\n+      // Convert the CGImageRef to TIFF data.\\n+      CFMutableDataRef tiffData = CFDataCreateMutable(kCFAllocatorDefault, 0);\\n+      CGImageDestinationRef destRef = CGImageDestinationCreateWithData(tiffData,\\n+                                                                       (CFStringRef)@\\\"public.tiff\\\",\\n+                                                                       1,\\n+                                                                       nil);\\n+      CGImageDestinationAddImage(destRef, imageRef, nil);\\n+      CGImageDestinationFinalize(destRef);\\n+\\n+      CGColorSpaceRelease(colorSpace);\\n+      CGImageRelease(imageRef);\\n+      CFRelease(destRef);\\n+\\n+      if (NS_FAILED(image->UnlockImagePixels(PR_FALSE))) {\\n+        CFRelease(tiffData);\\n         continue;\\n-\\n-      // We have to reorder data to have alpha last because only Tiger can handle\\n-      // alpha being first.\\n-      PRUint32 imageLength = ((stride * height) / 4);\\n-      for (PRUint32 i = 0; i < imageLength; i++) {\\n-        PRUint32 pixel = imageData[i];\\n-        reorderedData[i] = CFSwapInt32HostToBig((pixel << 8) | (pixel >> 24));\\n       }\\n \\n-      PRUint8* planes[2];\\n-      planes[0] = (PRUint8*)reorderedData;\\n-      planes[1] = nsnull;\\n-      NSBitmapImageRep* imageRep = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:planes\\n-                                                                           pixelsWide:width\\n-                                                                           pixelsHigh:height\\n-                                                                        bitsPerSample:8\\n-                                                                      samplesPerPixel:4\\n-                                                                             hasAlpha:YES\\n-                                                                             isPlanar:NO\\n-                                                                       colorSpaceName:NSDeviceRGBColorSpace\\n-                                                                          bytesPerRow:stride\\n-                                                                         bitsPerPixel:32];\\n-      NSData* tiffData = [imageRep TIFFRepresentationUsingCompression:NSTIFFCompressionNone factor:1.0];\\n-      [imageRep release];\\n-      free(reorderedData);\\n-\\n-      if (NS_FAILED(image->UnlockImagePixels(PR_FALSE)))\\n-        continue;\\n-\\n-      [pasteboardOutputDict setObject:tiffData forKey:NSTIFFPboardType];\\n+      [pasteboardOutputDict setObject:(NSMutableData*)tiffData forKey:NSTIFFPboardType];\\n+      CFRelease(tiffData);\\n     }\\n     else if (flavorStr.EqualsLiteral(kFilePromiseMime)) {\\n       [pasteboardOutputDict setObject:[NSArray arrayWithObject:@\\\"\\\"] forKey:NSFilesPromisePboardType];      \\n\""}