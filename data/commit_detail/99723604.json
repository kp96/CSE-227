{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas99723604\""},"diff":"\"99723604 Bug 394691. nsTArray should not do default initialization of POD elements. Also, switch nsAutoBuffer users to nsAutoTArray. patch by Chris Pearce, r=bsmedberg, sr=roc, a=bzbarsky\\ndiff --git a/browser/components/migration/src/nsSafariProfileMigrator.cpp b/browser/components/migration/src/nsSafariProfileMigrator.cpp\\nindex 935745e..909bb81 100644\\n--- a/browser/components/migration/src/nsSafariProfileMigrator.cpp\\n+++ b/browser/components/migration/src/nsSafariProfileMigrator.cpp\\n@@ -64,7 +64,7 @@\\n #include \\\"nsSafariProfileMigrator.h\\\"\\n #include \\\"nsToolkitCompsCID.h\\\"\\n #include \\\"nsNetUtil.h\\\"\\n-#include \\\"nsAutoBuffer.h\\\"\\n+#include \\\"nsTArray.h\\\"\\n \\n #include <Carbon/Carbon.h>\\n \\n@@ -311,12 +311,12 @@ GetDictionaryStringValue(CFDictionaryRef aDictionary, CFStringRef aKey,\\n {\\n   CFStringRef value = (CFStringRef)::CFDictionaryGetValue(aDictionary, aKey);\\n   if (value) {\\n-    nsAutoBuffer<UniChar, 1024> buffer;\\n+    nsAutoTArray<UniChar, 1024> buffer;\\n     CFIndex valueLength = ::CFStringGetLength(value);\\n-    buffer.EnsureElemCapacity(valueLength);\\n+    buffer.SetLength(valueLength);\\n \\n-    ::CFStringGetCharacters(value, CFRangeMake(0, valueLength), buffer.get());\\n-    aResult.Assign(buffer.get(), valueLength);\\n+    ::CFStringGetCharacters(value, CFRangeMake(0, valueLength), buffer.Elements());\\n+    aResult.Assign(buffer.Elements(), valueLength);\\n     return PR_TRUE;\\n   }\\n   return PR_FALSE;\\n@@ -328,12 +328,12 @@ GetDictionaryCStringValue(CFDictionaryRef aDictionary, CFStringRef aKey,\\n {\\n   CFStringRef value = (CFStringRef)::CFDictionaryGetValue(aDictionary, aKey);\\n   if (value) {\\n-    nsAutoBuffer<char, 1024> buffer;\\n+    nsAutoTArray<char, 1024> buffer;\\n     CFIndex valueLength = ::CFStringGetLength(value);\\n-    buffer.EnsureElemCapacity(valueLength + 1);\\n+    buffer.SetLength(valueLength + 1);\\n \\n-    if (::CFStringGetCString(value, buffer.get(), valueLength + 1, aEncoding)) {\\n-      aResult = buffer.get();\\n+    if (::CFStringGetCString(value, buffer.Elements(), valueLength + 1, aEncoding)) {\\n+      aResult = buffer.Elements();\\n       return PR_TRUE;\\n     }\\n   }\\n@@ -345,12 +345,12 @@ GetArrayStringValue(CFArrayRef aArray, PRInt32 aIndex, nsAString& aResult)\\n {\\n   CFStringRef value = (CFStringRef)::CFArrayGetValueAtIndex(aArray, aIndex);\\n   if (value) {\\n-    nsAutoBuffer<UniChar, 1024> buffer;\\n+    nsAutoTArray<UniChar, 1024> buffer;\\n     CFIndex valueLength = ::CFStringGetLength(value);\\n-    buffer.EnsureElemCapacity(valueLength);\\n+    buffer.SetLength(valueLength);\\n \\n-    ::CFStringGetCharacters(value, CFRangeMake(0, valueLength), buffer.get());\\n-    aResult.Assign(buffer.get(), valueLength);\\n+    ::CFStringGetCharacters(value, CFRangeMake(0, valueLength), buffer.Elements());\\n+    aResult.Assign(buffer.Elements(), valueLength);\\n     return PR_TRUE;\\n   }\\n   return PR_FALSE;\\ndiff --git a/embedding/components/printingui/src/mac/nsPrintingPromptServiceX.cpp b/embedding/components/printingui/src/mac/nsPrintingPromptServiceX.cpp\\nindex 039a9d4..f65b946 100644\\n--- a/embedding/components/printingui/src/mac/nsPrintingPromptServiceX.cpp\\n+++ b/embedding/components/printingui/src/mac/nsPrintingPromptServiceX.cpp\\n@@ -52,7 +52,7 @@\\n #include \\\"nsIPrintSettingsX.h\\\"\\n #include \\\"nsIDirectoryService.h\\\"\\n #include \\\"nsDirectoryServiceDefs.h\\\"\\n-#include \\\"nsAutoBuffer.h\\\"\\n+#include \\\"nsTArray.h\\\"\\n \\n #include \\\"nsPDECommon.h\\\"\\n \\n@@ -98,11 +98,11 @@ static CFDictionaryRef ExtractCustomSettingsDict(PMPrintSettings nativePrintSett\\n     \\n     OSStatus status = ::PMGetPrintSettingsExtendedData(nativePrintSettings, kAppPrintDialogAppOnlyKey, &bytesNeeded, NULL);\\n     if (status == noErr) {\\n-        nsAutoBuffer<UInt8, 512> dataBuffer;\\n-        if (dataBuffer.EnsureElemCapacity(bytesNeeded)) {           \\n-            status = ::PMGetPrintSettingsExtendedData(nativePrintSettings, kAppPrintDialogAppOnlyKey, &bytesNeeded, dataBuffer.get());\\n+        nsAutoTArray<UInt8, 512> dataBuffer;\\n+        if (dataBuffer.SetLength(bytesNeeded)) {           \\n+            status = ::PMGetPrintSettingsExtendedData(nativePrintSettings, kAppPrintDialogAppOnlyKey, &bytesNeeded, dataBuffer.Elements());\\n             if (status == noErr) {\\n-                CFDataRef xmlData = ::CFDataCreate(kCFAllocatorDefault, dataBuffer.get(), bytesNeeded);\\n+                CFDataRef xmlData = ::CFDataCreate(kCFAllocatorDefault, dataBuffer.Elements(), bytesNeeded);\\n                 if (xmlData) {\\n                     resultDict = (CFDictionaryRef)::CFPropertyListCreateFromXMLData(\\n                                                         kCFAllocatorDefault,\\n@@ -128,10 +128,10 @@ GetDictionaryStringValue(CFDictionaryRef aDictionary, CFStringRef aKey, nsAStrin\\n     {\\n         CFIndex stringLen = CFStringGetLength((CFStringRef)dictValue);\\n \\n-        nsAutoBuffer<UniChar, 256> stringBuffer;\\n-        if (stringBuffer.EnsureElemCapacity(stringLen + 1)) {\\n-            ::CFStringGetCharacters((CFStringRef)dictValue, CFRangeMake(0, stringLen), stringBuffer.get());\\n-            aResult.Assign(stringBuffer.get(), stringLen);\\n+        nsAutoTArray<UniChar, 256> stringBuffer;\\n+        if (stringBuffer.SetLength(stringLen + 1)) {\\n+            ::CFStringGetCharacters((CFStringRef)dictValue, CFRangeMake(0, stringLen), stringBuffer.Elements());\\n+            aResult.Assign(stringBuffer.Elements(), stringLen);\\n             return PR_TRUE;\\n         }\\n     }\\ndiff --git a/gfx/src/windows/nsFontMetricsWin.cpp b/gfx/src/windows/nsFontMetricsWin.cpp\\nindex 1256c34..d6fbf78 100644\\n--- a/gfx/src/windows/nsFontMetricsWin.cpp\\n+++ b/gfx/src/windows/nsFontMetricsWin.cpp\\n@@ -58,7 +58,7 @@\\n #include \\\"prprf.h\\\"\\n #include \\\"nsReadableUtils.h\\\"\\n #include \\\"nsUnicodeRange.h\\\"\\n-#include \\\"nsAutoBuffer.h\\\"\\n+#include \\\"nsTArray.h\\\"\\n \\n #define DEFAULT_TTF_SYMBOL_ENCODING \\\"windows-1252\\\"\\n #define IS_RTL_PRESENTATION_FORM(c) ((0xfb1d <= (c)) && ((c)<= 0xfefc))\\n@@ -283,8 +283,8 @@ static nsFontCleanupObserver *gFontCleanupObserver;\\n #undef CHAR_BUFFER_SIZE\\n #define CHAR_BUFFER_SIZE 1024\\n \\n-typedef nsAutoBuffer<char, CHAR_BUFFER_SIZE> nsAutoCharBuffer;\\n-typedef nsAutoBuffer<PRUnichar, CHAR_BUFFER_SIZE> nsAutoChar16Buffer;\\n+typedef nsAutoTArray<char, CHAR_BUFFER_SIZE> nsAutoCharBuffer;\\n+typedef nsAutoTArray<PRUnichar, CHAR_BUFFER_SIZE> nsAutoChar16Buffer;\\n \\n class nsFontSubset : public nsFontWin\\n {\\n@@ -701,10 +701,10 @@ GetNAME(HDC aDC, nsString* aName, PRBool* aIsSymbolEncoding = nsnull)\\n     return eGetName_OtherError;\\n   }\\n   nsAutoFontDataBuffer buffer;\\n-  if (!buffer.EnsureElemCapacity(len)) {\\n+  if (!buffer.SetLength(len)) {\\n     return eGetName_OtherError;\\n   }\\n-  PRUint8* buf = buffer.get();\\n+  PRUint8* buf = buffer.Elements();\\n \\n   DWORD newLen = GetFontData(aDC, NAME, 0, buf, len);\\n   if (newLen != len) {\\n@@ -805,10 +805,10 @@ GetSpaces(HDC aDC, PRBool* aIsCFFOutline, PRUint32* aMaxGlyph,\\n   if ((len == GDI_ERROR) || (!len)) {\\n     return NS_ERROR_FAILURE;\\n   }\\n-  if (!aIsSpace.EnsureElemCapacity(len)) {\\n+  if (!aIsSpace.SetLength(len)) {\\n     return NS_ERROR_OUT_OF_MEMORY;\\n   }\\n-  PRUint8* buf = aIsSpace.get();\\n+  PRUint8* buf = aIsSpace.Elements();\\n   DWORD newLen = GetFontData(aDC, LOCA, 0, buf, len);\\n   if (newLen != len) {\\n     return NS_ERROR_FAILURE;\\n@@ -1429,8 +1429,8 @@ ConvertUnicodeToGlyph(const PRUnichar* aSrc,  PRInt32 aSrcLength,\\n     return NS_ERROR_UNEXPECTED;\\n   }\\n \\n-  if (!aResult.EnsureElemCapacity(aDestLength)) return NS_ERROR_OUT_OF_MEMORY;\\n-  char* str = aResult.get();\\n+  if (!aResult.SetLength(aDestLength)) return NS_ERROR_OUT_OF_MEMORY;\\n+  char* str = aResult.Elements();\\n \\n   aConverter->Convert(aSrc, &aSrcLength, str, &aDestLength);\\n \\n@@ -1680,10 +1680,10 @@ nsFontMetricsWin::GetFontCCMAP(HDC aDC, const char* aShortName,\\n     return nsnull;\\n   }\\n   nsAutoFontDataBuffer buffer;\\n-  if (!buffer.EnsureElemCapacity(len)) {\\n+  if (!buffer.SetLength(len)) {\\n     return nsnull;\\n   }\\n-  PRUint8* buf = buffer.get();\\n+  PRUint8* buf = buffer.Elements();\\n   DWORD newLen = GetFontData(aDC, CMAP, 0, buf, len);\\n   if (newLen != len) {\\n     return nsnull;\\n@@ -1938,10 +1938,10 @@ GetGlyphIndices(HDC                 aDC,\\n     if ((len == GDI_ERROR) || (!len)) {\\n       return NS_ERROR_UNEXPECTED;\\n     }\\n-    if (!buffer.EnsureElemCapacity(len)) {\\n+    if (!buffer.SetLength(len)) {\\n       return NS_ERROR_OUT_OF_MEMORY;\\n     }\\n-    buf = buffer.get();\\n+    buf = buffer.Elements();\\n     DWORD newLen = GetFontData(aDC, CMAP, 0, buf, len);\\n     if (newLen != len) {\\n       return NS_ERROR_UNEXPECTED;\\n@@ -2034,10 +2034,10 @@ GetGlyphIndices(HDC                 aDC,\\n     PRUint16* idDelta = startCode + segCount;\\n     PRUint16* idRangeOffset = idDelta + segCount;\\n \\n-    if (!aResult.EnsureElemCapacity(aLength)) {\\n+    if (!aResult.SetLength(aLength)) {\\n       return NS_ERROR_OUT_OF_MEMORY;\\n     }\\n-    PRUnichar* result = aResult.get();\\n+    PRUnichar* result = aResult.Elements();\\n     for (i = 0; i < aLength; ++i) {\\n       result[i] = GetGlyphIndex(segCount, endCode, startCode,\\n                                 idRangeOffset, idDelta, end, \\n@@ -2146,7 +2146,7 @@ nsGlyphAgent::GetGlyphMetrics(HDC           aDC,\\n   if (0 == aGlyphIndex) { // caller doesn't know the glyph index, so find it\\n     nsAutoChar16Buffer buf;\\n     if (NS_SUCCEEDED(GetGlyphIndices(aDC, nsnull, &aChar, 1, buf)))\\n-      aGlyphIndex = *(buf.get());\\n+      aGlyphIndex = *(buf.Elements());\\n   }\\n   if (0 < aGlyphIndex) {\\n     return GetGlyphOutlineA(aDC, aGlyphIndex, GGO_METRICS | GGO_GLYPH_INDEX, aGlyphMetrics, 0, nsnull, &mMat);\\n@@ -4394,7 +4394,7 @@ nsFontWinUnicode::GetBoundingMetrics(HDC                aDC,\\n     }\\n   }\\n \\n-  return GetBoundingMetricsCommon(aDC, mOverhangCorrection, aString, aLength, aBoundingMetrics, buffer.get());\\n+  return GetBoundingMetricsCommon(aDC, mOverhangCorrection, aString, aLength, aBoundingMetrics, buffer.Elements());\\n }\\n \\n #ifdef NS_DEBUG\\n@@ -4433,9 +4433,9 @@ nsFontWinNonUnicode::GetWidth(HDC aDC, const PRUnichar* aString,\\n \\n   SIZE size;\\n   if (!mIsWide)\\n-    ::GetTextExtentPoint32A(aDC, buffer.get(), destLength, &size);\\n+    ::GetTextExtentPoint32A(aDC, buffer.Elements(), destLength, &size);\\n   else\\n-    ::GetTextExtentPoint32W(aDC, (const PRUnichar*) buffer.get(), destLength / 2, &size);\\n+    ::GetTextExtentPoint32W(aDC, (const PRUnichar*) buffer.Elements(), destLength / 2, &size);\\n   size.cx -= mOverhangCorrection;\\n \\n   return size.cx;\\n@@ -4455,9 +4455,9 @@ nsFontWinNonUnicode::DrawString(HDC aDC, PRInt32 aX, PRInt32 aY,\\n   }\\n \\n   if (!mIsWide)\\n-    NS_ExtTextOutA(aDC, this, aX, aY, 0, NULL, buffer.get(), aLength, NULL);\\n+    NS_ExtTextOutA(aDC, this, aX, aY, 0, NULL, buffer.Elements(), aLength, NULL);\\n   else \\n-    NS_ExtTextOutW(aDC, this, aX, aY, 0, NULL, (const PRUnichar*) buffer.get(), destLength / 2, NULL);\\n+    NS_ExtTextOutW(aDC, this, aX, aY, 0, NULL, (const PRUnichar*) buffer.Elements(), destLength / 2, NULL);\\n }\\n \\n #ifdef MOZ_MATHML\\n@@ -4486,7 +4486,7 @@ nsFontWinNonUnicode::GetBoundingMetrics(HDC                aDC,\\n     if (gGlyphAgent.GetState() != eGlyphAgent_UNICODE) {\\n       // we are on a platform that doesn't implement GetGlyphOutlineW() \\n       // we need to use glyph indices\\n-      rv = GetGlyphIndices(aDC, &mCMAP, (const PRUnichar*)buffer.get(), destLength / 2, buf);\\n+      rv = GetGlyphIndices(aDC, &mCMAP, (const PRUnichar*)buffer.Elements(), destLength / 2, buf);\\n       if (NS_FAILED(rv)) {\\n         return rv;\\n       }\\n@@ -4494,12 +4494,12 @@ nsFontWinNonUnicode::GetBoundingMetrics(HDC                aDC,\\n \\n     // buffer.mBuffer is now a pseudo-Unicode string so that we can use \\n     // GetBoundingMetricsCommon() also used by nsFontWinUnicode. \\n-    return  GetBoundingMetricsCommon(aDC, mOverhangCorrection, (const PRUnichar*)buffer.get(), \\n-              destLength / 2, aBoundingMetrics, buf.get());\\n+    return  GetBoundingMetricsCommon(aDC, mOverhangCorrection, (const PRUnichar*)buffer.Elements(), \\n+              destLength / 2, aBoundingMetrics, buf.Elements());\\n \\n   }\\n \\n-  return GetBoundingMetricsCommonA(aDC, mOverhangCorrection, buffer.get(), destLength, \\n+  return GetBoundingMetricsCommonA(aDC, mOverhangCorrection, buffer.Elements(), destLength, \\n                                    aBoundingMetrics);\\n }\\n \\n@@ -4544,11 +4544,11 @@ SubstituteChars(PRBool              aDisplayUnicode,\\n #ifdef WINCE\\n // Unicode backend on WINCE... Substitute nothing.\\n \\n-  if (!aResult.EnsureElemCapacity(aLength))\\n+  if (!aResult.SetLength(aLength))\\n     return NS_ERROR_OUT_OF_MEMORY;\\n \\n   *aCount = aLength;\\n-  memcpy(aResult.get(), aString, aLength * sizeof(PRUnichar));\\n+  memcpy(aResult.Elements(), aString, aLength * sizeof(PRUnichar));\\n   return NS_OK;\\n \\n #else\\n@@ -4582,10 +4582,10 @@ SubstituteChars(PRBool              aDisplayUnicode,\\n     if (NS_SUCCEEDED(res)) {\\n       *aCount = conv.Length();\\n       if (*aCount > 0) {\\n-        if (!aResult.EnsureElemCapacity(*aCount)) {\\n+        if (!aResult.SetLength(*aCount)) {\\n           return NS_ERROR_OUT_OF_MEMORY;\\n         }\\n-        result = aResult.get();\\n+        result = aResult.Elements();\\n         PRUnichar* u = result;\\n         const char* c = conv.get();\\n         for (; *c; ++c, ++u) {\\n@@ -4597,8 +4597,8 @@ SubstituteChars(PRBool              aDisplayUnicode,\\n   }\\n \\n   // we reach here if we couldn't transliterate, so fallback to question marks \\n-  if (!aResult.EnsureElemCapacity(aLength)) return NS_ERROR_OUT_OF_MEMORY;\\n-  result = aResult.get();\\n+  if (!aResult.SetLength(aLength)) return NS_ERROR_OUT_OF_MEMORY;\\n+  result = aResult.Elements();\\n   for (PRUint32 i = 0; i < aLength; i++) {\\n     result[i] = NS_REPLACEMENT_CHAR;\\n   }\\n@@ -4618,7 +4618,7 @@ nsFontWinSubstitute::GetWidth(HDC aDC, const PRUnichar* aString,\\n   if (NS_FAILED(rv) || !aLength) return 0;\\n \\n   SIZE size;\\n-  ::GetTextExtentPoint32W(aDC, buffer.get(), aLength, &size);\\n+  ::GetTextExtentPoint32W(aDC, buffer.Elements(), aLength, &size);\\n   size.cx -= mOverhangCorrection;\\n \\n   return size.cx;\\n@@ -4634,7 +4634,7 @@ nsFontWinSubstitute::DrawString(HDC aDC, PRInt32 aX, PRInt32 aY,\\n   nsresult rv = SubstituteChars(PR_FALSE, aString, aLength, buffer, &aLength);\\n   if (NS_FAILED(rv) || !aLength) return;\\n \\n-  NS_ExtTextOutW(aDC, this, aX, aY, 0, NULL, buffer.get(), aLength, NULL);\\n+  NS_ExtTextOutW(aDC, this, aX, aY, 0, NULL, buffer.Elements(), aLength, NULL);\\n }\\n \\n #ifdef MOZ_MATHML\\n@@ -4661,14 +4661,14 @@ nsFontWinSubstitute::GetBoundingMetrics(HDC                aDC,\\n   if (gGlyphAgent.GetState() != eGlyphAgent_UNICODE) {\\n     // we are on a platform that doesn't implement GetGlyphOutlineW() \\n     // we better get all glyph indices in one swoop\\n-    rv = GetGlyphIndices(aDC, &mCMAP, buffer.get(), aLength, buf);\\n+    rv = GetGlyphIndices(aDC, &mCMAP, buffer.Elements(), aLength, buf);\\n     if (NS_FAILED(rv)) {\\n       return rv;\\n     }\\n   }\\n \\n-  return GetBoundingMetricsCommon(aDC, mOverhangCorrection, buffer.get(), aLength, \\n-                                  aBoundingMetrics, buf.get());\\n+  return GetBoundingMetricsCommon(aDC, mOverhangCorrection, buffer.Elements(), aLength, \\n+                                  aBoundingMetrics, buf.Elements());\\n }\\n \\n #ifdef NS_DEBUG\\n@@ -4800,8 +4800,8 @@ nsFontSubset::Convert(const PRUnichar* aString, PRUint32 aLength,\\n   int nb = WideCharToMultiByte(mCodePage, 0, aString, aLength,\\n                                nsnull, 0, nsnull, nsnull);\\n \\n-  if (!nb || !aResult.EnsureElemCapacity(nb)) return;\\n-  char* buf = aResult.get();\\n+  if (!nb || !aResult.SetLength(nb)) return;\\n+  char* buf = aResult.Elements();\\n   // Convert the Unicode string to ANSI\\n   *aResultLength = WideCharToMultiByte(mCodePage, 0, aString, aLength,\\n                                        buf, nb, nsnull, nsnull);\\n@@ -4814,7 +4814,7 @@ nsFontSubset::GetWidth(HDC aDC, const PRUnichar* aString, PRUint32 aLength)\\n   Convert(aString, aLength, buffer, &aLength);\\n   if (aLength) {\\n     SIZE size;\\n-    ::GetTextExtentPoint32A(aDC, buffer.get(), aLength, &size);\\n+    ::GetTextExtentPoint32A(aDC, buffer.Elements(), aLength, &size);\\n     size.cx -= mOverhangCorrection;\\n     return size.cx;\\n   }\\n@@ -4828,7 +4828,7 @@ nsFontSubset::DrawString(HDC aDC, PRInt32 aX, PRInt32 aY,\\n   nsAutoCharBuffer buffer;\\n   Convert(aString, aLength, buffer, &aLength);\\n   if (aLength) {\\n-    NS_ExtTextOutA(aDC, this, aX, aY, 0, NULL, buffer.get(), aLength, NULL);\\n+    NS_ExtTextOutA(aDC, this, aX, aY, 0, NULL, buffer.Elements(), aLength, NULL);\\n   }\\n }\\n \\n@@ -4843,7 +4843,7 @@ nsFontSubset::GetBoundingMetrics(HDC                aDC,\\n   nsAutoCharBuffer buffer;\\n   Convert(aString, aLength, buffer, &aLength);\\n   if (aLength) {\\n-    return GetBoundingMetricsCommonA(aDC, mOverhangCorrection, buffer.get(), aLength, \\n+    return GetBoundingMetricsCommonA(aDC, mOverhangCorrection, buffer.Elements(), aLength, \\n                                      aBoundingMetrics);\\n   }\\n   return NS_OK;\\n@@ -4926,11 +4926,11 @@ nsFontSubsetSubstitute::Convert(const PRUnichar* aString, PRUint32 aLength,\\n   }\\n   if (!aLength) {\\n     // this is the case where the substitute string collapsed to nothingness\\n-    *(aResult.get()) = '\\\\0';\\n+    *(aResult.Elements()) = '\\\\0';\\n     *aResultLength = 0;\\n     return;\\n   }\\n-  nsFontSubset::Convert(buffer.get(), aLength, aResult, aResultLength);\\n+  nsFontSubset::Convert(buffer.Elements(), aLength, aResult, aResultLength);\\n }\\n \\n nsFontWinA::nsFontWinA(LOGFONT* aLogFont, HFONT aFont, PRUint16* aCCMap)\\ndiff --git a/gfx/thebes/public/gfxOS2Fonts.h b/gfx/thebes/public/gfxOS2Fonts.h\\nindex 79e3e6f..62723a7 100644\\n--- a/gfx/thebes/public/gfxOS2Fonts.h\\n+++ b/gfx/thebes/public/gfxOS2Fonts.h\\n@@ -49,7 +49,6 @@\\n #include \\\"cairo-ft.h\\\" // includes fontconfig.h, too\\n #include <freetype/tttables.h>\\n \\n-#include \\\"nsAutoBuffer.h\\\"\\n #include \\\"nsICharsetConverterManager.h\\\"\\n \\n class gfxOS2Font : public gfxFont {\\ndiff --git a/gfx/thebes/src/gfxWindowsFonts.cpp b/gfx/thebes/src/gfxWindowsFonts.cpp\\nindex 679d0ad..8111d5c 100644\\n--- a/gfx/thebes/src/gfxWindowsFonts.cpp\\n+++ b/gfx/thebes/src/gfxWindowsFonts.cpp\\n@@ -58,7 +58,7 @@\\n \\n #include <windows.h>\\n \\n-#include \\\"nsAutoBuffer.h\\\"\\n+#include \\\"nsTArray.h\\\"\\n #include \\\"nsUnicodeRange.h\\\"\\n #include \\\"nsUnicharUtils.h\\\"\\n \\n@@ -651,15 +651,15 @@ SetupTextRunFromGlyphs(gfxTextRun *aRun, WCHAR *aGlyphs, HDC aDC,\\n         return PR_FALSE;\\n \\n     SIZE size;\\n-    nsAutoBuffer<int,500> partialWidthArray;\\n-    if (!partialWidthArray.EnsureElemCapacity(length))\\n+    nsAutoTArray<int,500> partialWidthArray;\\n+    if (!partialWidthArray.SetLength(length))\\n         return PR_FALSE;\\n     BOOL success = GetTextExtentExPointI(aDC,\\n                                          (WORD*) aGlyphs,\\n                                          length,\\n                                          INT_MAX,\\n                                          NULL,\\n-                                         partialWidthArray.get(),\\n+                                         partialWidthArray.Elements(),\\n                                          &size);\\n     if (!success)\\n         return PR_FALSE;\\n@@ -701,14 +701,14 @@ gfxWindowsFontGroup::InitTextRunGDI(gfxContext *aContext, gfxTextRun *aRun,\\n     nsRefPtr<gfxWindowsFont> font = GetFontAt(0);\\n     DCFromContext dc(aContext);\\n     if (SetupDCFont(dc, font)) {\\n-        nsAutoBuffer<WCHAR,500> glyphArray;\\n-        if (!glyphArray.EnsureElemCapacity(aLength))\\n+        nsAutoTArray<WCHAR,500> glyphArray;\\n+        if (!glyphArray.SetLength(aLength))\\n             return;\\n \\n-        DWORD ret = GetGlyphIndicesA(dc, aString, aLength, (WORD*) glyphArray.get(),\\n+        DWORD ret = GetGlyphIndicesA(dc, aString, aLength, (WORD*) glyphArray.Elements(),\\n                                      GGI_MARK_NONEXISTING_GLYPHS);\\n         if (ret != GDI_ERROR &&\\n-            SetupTextRunFromGlyphs(aRun, glyphArray.get(), dc, font))\\n+            SetupTextRunFromGlyphs(aRun, glyphArray.Elements(), dc, font))\\n             return;\\n     }\\n \\n@@ -725,14 +725,14 @@ gfxWindowsFontGroup::InitTextRunGDI(gfxContext *aContext, gfxTextRun *aRun,\\n     nsRefPtr<gfxWindowsFont> font = GetFontAt(0);\\n     DCFromContext dc(aContext);\\n     if (SetupDCFont(dc, font)) {\\n-        nsAutoBuffer<WCHAR,500> glyphArray;\\n-        if (!glyphArray.EnsureElemCapacity(aLength))\\n+        nsAutoTArray<WCHAR,500> glyphArray;\\n+        if (!glyphArray.SetLength(aLength))\\n             return;\\n \\n-        DWORD ret = GetGlyphIndicesW(dc, aString, aLength, (WORD*) glyphArray.get(),\\n+        DWORD ret = GetGlyphIndicesW(dc, aString, aLength, (WORD*) glyphArray.Elements(),\\n                                      GGI_MARK_NONEXISTING_GLYPHS);\\n         if (ret != GDI_ERROR &&\\n-            SetupTextRunFromGlyphs(aRun, glyphArray.get(), dc, font))\\n+            SetupTextRunFromGlyphs(aRun, glyphArray.Elements(), dc, font))\\n             return;\\n     }\\n \\n@@ -886,9 +886,9 @@ public:\\n         mNumGlyphs(0), mMaxGlyphs((int)(1.5 * aLength) + 16),\\n         mFontSelected(PR_FALSE)\\n     {\\n-        mGlyphs.EnsureElemCapacity(mMaxGlyphs);\\n-        mClusters.EnsureElemCapacity(mItemLength + 1);\\n-        mAttr.EnsureElemCapacity(mMaxGlyphs);\\n+        mGlyphs.SetLength(mMaxGlyphs);\\n+        mClusters.SetLength(mItemLength + 1);\\n+        mAttr.SetLength(mMaxGlyphs);\\n     }\\n \\n     ~UniscribeItem() {\\n@@ -926,12 +926,12 @@ public:\\n             rv = ScriptShape(shapeDC, mCurrentFont->ScriptCache(),\\n                              str, mRangeLength,\\n                              mMaxGlyphs, &sa,\\n-                             mGlyphs.get(), mClusters.get(),\\n-                             mAttr.get(), &mNumGlyphs);\\n+                             mGlyphs.Elements(), mClusters.Elements(),\\n+                             mAttr.Elements(), &mNumGlyphs);\\n \\n             if (rv == E_OUTOFMEMORY) {\\n-                mGlyphs.AddElemCapacity(mMaxGlyphs);\\n-                mAttr.AddElemCapacity(mMaxGlyphs);\\n+                mGlyphs.SetLength(mMaxGlyphs);\\n+                mAttr.SetLength(mMaxGlyphs);\\n                 mMaxGlyphs *= 2;\\n                 continue;\\n             }\\n@@ -949,7 +949,7 @@ public:\\n             }\\n #ifdef DEBUG_pavlov\\n             if (rv == USP_E_SCRIPT_NOT_IN_FONT) {\\n-                ScriptGetCMap(mDC, mCurrentFont->ScriptCache(), str, mRangeString, 0, mGlyphs.get());\\n+                ScriptGetCMap(mDC, mCurrentFont->ScriptCache(), str, mRangeString, 0, mGlyphs.Elements());\\n                 PRUnichar foo[LF_FACESIZE+1];\\n                 GetTextFaceW(mDC, LF_FACESIZE, foo);\\n                 printf(\\\"bah\\\\n\\\");\\n@@ -989,16 +989,16 @@ public:\\n     HRESULT Place() {\\n         HRESULT rv;\\n \\n-        mOffsets.EnsureElemCapacity(mNumGlyphs);\\n-        mAdvances.EnsureElemCapacity(mNumGlyphs);\\n+        mOffsets.SetLength(mNumGlyphs);\\n+        mAdvances.SetLength(mNumGlyphs);\\n \\n         HDC placeDC = nsnull;\\n \\n         while (PR_TRUE) {\\n             rv = ScriptPlace(placeDC, mCurrentFont->ScriptCache(),\\n-                             mGlyphs.get(), mNumGlyphs,\\n-                             mAttr.get(), &mScriptItem->a,\\n-                             mAdvances.get(), mOffsets.get(), NULL);\\n+                             mGlyphs.Elements(), mNumGlyphs,\\n+                             mAttr.Elements(), &mScriptItem->a,\\n+                             mAdvances.Elements(), mOffsets.Elements(), NULL);\\n \\n             if (rv == E_PENDING) {\\n                 SelectFont();\\n@@ -1457,12 +1457,12 @@ private:\\n \\n #define AVERAGE_ITEM_LENGTH 40\\n \\n-    nsAutoBuffer<WORD, PRUint32(1.5 * AVERAGE_ITEM_LENGTH) + 16> mGlyphs;\\n-    nsAutoBuffer<WORD, AVERAGE_ITEM_LENGTH + 1> mClusters;\\n-    nsAutoBuffer<SCRIPT_VISATTR, PRUint32(1.5 * AVERAGE_ITEM_LENGTH) + 16> mAttr;\\n+    nsAutoTArray<WORD, PRUint32(1.5 * AVERAGE_ITEM_LENGTH) + 16> mGlyphs;\\n+    nsAutoTArray<WORD, AVERAGE_ITEM_LENGTH + 1> mClusters;\\n+    nsAutoTArray<SCRIPT_VISATTR, PRUint32(1.5 * AVERAGE_ITEM_LENGTH) + 16> mAttr;\\n  \\n-    nsAutoBuffer<GOFFSET, 2 * AVERAGE_ITEM_LENGTH> mOffsets;\\n-    nsAutoBuffer<int, 2 * AVERAGE_ITEM_LENGTH> mAdvances;\\n+    nsAutoTArray<GOFFSET, 2 * AVERAGE_ITEM_LENGTH> mOffsets;\\n+    nsAutoTArray<int, 2 * AVERAGE_ITEM_LENGTH> mAdvances;\\n \\n #undef AVERAGE_ITEM_LENGTH\\n \\ndiff --git a/intl/locale/src/nsLocaleService.cpp b/intl/locale/src/nsLocaleService.cpp\\nindex 180bc8d..6e8eea9 100644\\n--- a/intl/locale/src/nsLocaleService.cpp\\n+++ b/intl/locale/src/nsLocaleService.cpp\\n@@ -44,7 +44,7 @@\\n #include \\\"nsReadableUtils.h\\\"\\n #include \\\"nsCRT.h\\\"\\n #include \\\"prprf.h\\\"\\n-#include \\\"nsAutoBuffer.h\\\"\\n+#include \\\"nsTArray.h\\\"\\n \\n #include <ctype.h>\\n \\n@@ -265,16 +265,16 @@ nsLocaleService::nsLocaleService(void)\\n     CFStringRef userLocaleStr = ::CFLocaleGetIdentifier(userLocaleRef);\\n     ::CFRetain(userLocaleStr);\\n \\n-    nsAutoBuffer<UniChar, 32> buffer;\\n+    nsAutoTArray<UniChar, 32> buffer;\\n     int size = ::CFStringGetLength(userLocaleStr);\\n-    if (buffer.EnsureElemCapacity(size))\\n+    if (buffer.SetLength(size))\\n     {\\n         CFRange range = ::CFRangeMake(0, size);\\n-        ::CFStringGetCharacters(userLocaleStr, range, buffer.get());\\n-        buffer.get()[size] = 0;\\n+        ::CFStringGetCharacters(userLocaleStr, range, buffer.Elements());\\n+        buffer[size] = 0;\\n \\n         // Convert the locale string to the format that Mozilla expects\\n-        nsAutoString xpLocale(buffer.get());\\n+        nsAutoString xpLocale(buffer.Elements());\\n         xpLocale.ReplaceChar('_', '-');\\n \\n         nsresult rv = NewLocale(xpLocale, getter_AddRefs(mSystemLocale));\\ndiff --git a/modules/libpr0n/decoders/icon/mac/nsIconChannelCocoa.mm b/modules/libpr0n/decoders/icon/mac/nsIconChannelCocoa.mm\\nindex 19be7e1..1372afd 100644\\n--- a/modules/libpr0n/decoders/icon/mac/nsIconChannelCocoa.mm\\n+++ b/modules/libpr0n/decoders/icon/mac/nsIconChannelCocoa.mm\\n@@ -57,7 +57,7 @@\\n #include \\\"nsILocalFileMac.h\\\"\\n #include \\\"nsIFileURL.h\\\"\\n #include \\\"nsInt64.h\\\"\\n-#include \\\"nsAutoBuffer.h\\\"\\n+#include \\\"nsTArray.h\\\"\\n \\n #include <Cocoa/Cocoa.h>\\n \\n@@ -313,11 +313,11 @@ nsresult nsIconChannel::MakeInputStream(nsIInputStream** _retval, PRBool nonBloc\\n   \\n   // create our buffer\\n   PRInt32 bufferCapacity = 2 + desiredImageSize * desiredImageSize * 4;\\n-  nsAutoBuffer<PRUint8, 3 + 16 * 16 * 5> iconBuffer; // initial size is for 16x16\\n-  if (!iconBuffer.EnsureElemCapacity(bufferCapacity))\\n+  nsAutoTArray<PRUint8, 3 + 16 * 16 * 5> iconBuffer; // initial size is for 16x16\\n+  if (!iconBuffer.SetLength(bufferCapacity))\\n     return NS_ERROR_OUT_OF_MEMORY;\\n   \\n-  PRUint8* iconBufferPtr = iconBuffer.get();\\n+  PRUint8* iconBufferPtr = iconBuffer.Elements();\\n   \\n   // write header data into buffer\\n   *iconBufferPtr++ = desiredImageSize;\\n@@ -348,7 +348,7 @@ nsresult nsIconChannel::MakeInputStream(nsIInputStream** _retval, PRBool nonBloc\\n #endif\\n   }\\n \\n-  NS_ASSERTION(iconBufferPtr == iconBuffer.get() + bufferCapacity,\\n+  NS_ASSERTION(iconBufferPtr == iconBuffer.Elements() + bufferCapacity,\\n                \\\"buffer size miscalculation\\\");\\n   \\n   // Now, create a pipe and stuff our data into it\\n@@ -358,7 +358,7 @@ nsresult nsIconChannel::MakeInputStream(nsIInputStream** _retval, PRBool nonBloc\\n \\n   if (NS_SUCCEEDED(rv)) {\\n     PRUint32 written;\\n-    rv = outStream->Write((char*)iconBuffer.get(), bufferCapacity, &written);\\n+    rv = outStream->Write((char*)iconBuffer.Elements(), bufferCapacity, &written);\\n     if (NS_SUCCEEDED(rv))\\n       NS_IF_ADDREF(*_retval = inStream);\\n   }\\ndiff --git a/uriloader/exthandler/mac/nsOSHelperAppService.cpp b/uriloader/exthandler/mac/nsOSHelperAppService.cpp\\nindex 0e5016b..5e8fc8f 100644\\n--- a/uriloader/exthandler/mac/nsOSHelperAppService.cpp\\n+++ b/uriloader/exthandler/mac/nsOSHelperAppService.cpp\\n@@ -40,7 +40,7 @@\\n #include \\\"nsOSHelperAppService.h\\\"\\n #include \\\"nsISupports.h\\\"\\n #include \\\"nsString.h\\\"\\n-#include \\\"nsAutoBuffer.h\\\"\\n+#include \\\"nsTArray.h\\\"\\n #include \\\"nsXPIDLString.h\\\"\\n #include \\\"nsIURL.h\\\"\\n #include \\\"nsILocalFile.h\\\"\\n@@ -125,12 +125,12 @@ NS_IMETHODIMP nsOSHelperAppService::GetApplicationDescription(const nsACString&\\n           (CFStringRef)::CFBundleGetValueForInfoDictionaryKey(handlerBundle,\\n                                                               kCFBundleNameKey);\\n         if (bundleName) {\\n-          nsAutoBuffer<UniChar, 255> buffer;\\n+          nsAutoTArray<UniChar, 255> buffer;\\n           CFIndex bundleNameLength = ::CFStringGetLength(bundleName);\\n-          buffer.EnsureElemCapacity(bundleNameLength);\\n+          buffer.SetLength(bundleNameLength);\\n           ::CFStringGetCharacters(bundleName, CFRangeMake(0, bundleNameLength),\\n-                                  buffer.get());\\n-          _retval.Assign(buffer.get(), bundleNameLength);\\n+                                  buffer.Elements());\\n+          _retval.Assign(buffer.Elements(), bundleNameLength);\\n           rv = NS_OK;\\n         }\\n \\ndiff --git a/widget/src/os2/nsOS2Uni.cpp b/widget/src/os2/nsOS2Uni.cpp\\nindex 0b14aac..2230ff8 100644\\n--- a/widget/src/os2/nsOS2Uni.cpp\\n+++ b/widget/src/os2/nsOS2Uni.cpp\\n@@ -147,12 +147,12 @@ WideCharToMultiByte(int aCodePage, const PRUnichar* aSrc,\\n   if (NS_FAILED(uco->GetMaxLength(aSrc, aSrcLength, &aResultLength))) {\\n     return NS_ERROR_UNEXPECTED;\\n   }\\n-  if (!aResult.EnsureElemCapacity(aResultLength + 1))\\n+  if (!aResult.SetLength(aResultLength + 1))\\n     return NS_ERROR_OUT_OF_MEMORY;\\n-  char* str = aResult.get();\\n+  char* str = aResult.Elements();\\n \\n   rv = uco->Convert(aSrc, &aSrcLength, str, &aResultLength);\\n-  aResult.get()[aResultLength] = '\\\\0';\\n+  aResult[aResultLength] = '\\\\0';\\n   return rv;\\n }\\n \\n@@ -171,11 +171,11 @@ MultiByteToWideChar(int aCodePage, const char* aSrc,\\n   if (NS_FAILED(uco->GetMaxLength(aSrc, aSrcLength, &aResultLength))) {\\n     return NS_ERROR_UNEXPECTED;\\n   }\\n-  if (!aResult.EnsureElemCapacity(aResultLength + 1))\\n+  if (!aResult.SetLength(aResultLength + 1))\\n     return NS_ERROR_OUT_OF_MEMORY;\\n-  PRUnichar* str = aResult.get();\\n+  PRUnichar* str = aResult.Elements();\\n \\n   rv = uco->Convert(aSrc, &aSrcLength, str, &aResultLength);\\n-  aResult.get()[aResultLength] = '\\\\0';\\n+  aResult[aResultLength] = '\\\\0';\\n   return rv;\\n }\\ndiff --git a/widget/src/os2/nsOS2Uni.h b/widget/src/os2/nsOS2Uni.h\\nindex 65a8b2b..1069e08 100644\\n--- a/widget/src/os2/nsOS2Uni.h\\n+++ b/widget/src/os2/nsOS2Uni.h\\n@@ -40,7 +40,7 @@\\n #define INCL_WIN\\n #include <os2.h>\\n #include <uconv.h>\\n-#include \\\"nsAutoBuffer.h\\\"\\n+#include \\\"nsTArray.h\\\"\\n #include \\\"nsICharsetConverterManager.h\\\"\\n #include \\\"gfxCore.h\\\"\\n \\n@@ -58,8 +58,8 @@ private:\\n };\\n \\n #define CHAR_BUFFER_SIZE 1024\\n-typedef nsAutoBuffer<char, CHAR_BUFFER_SIZE> nsAutoCharBuffer;\\n-typedef nsAutoBuffer<PRUnichar, CHAR_BUFFER_SIZE> nsAutoChar16Buffer;\\n+typedef nsAutoTArray<char, CHAR_BUFFER_SIZE> nsAutoCharBuffer;\\n+typedef nsAutoTArray<PRUnichar, CHAR_BUFFER_SIZE> nsAutoChar16Buffer;\\n \\n nsresult WideCharToMultiByte(int aCodePage, const PRUnichar* aSrc,\\n                              PRInt32 aSrcLength, nsAutoCharBuffer& aResult,\\ndiff --git a/xpcom/ds/Makefile.in b/xpcom/ds/Makefile.in\\nindex 06524be..44e11c1 100644\\n--- a/xpcom/ds/Makefile.in\\n+++ b/xpcom/ds/Makefile.in\\n@@ -107,7 +107,6 @@ EXPORTS\\t\\t= \\\\\\n \\t\\tnsTextFormatter.h \\\\\\n \\t\\tnsValueArray.h \\\\\\n \\t\\tnsStringEnumerator.h \\\\\\n-\\t\\tnsAutoBuffer.h \\\\\\n \\t\\tnsHashPropertyBag.h \\\\\\n \\t\\tnsWhitespaceTokenizer.h \\\\\\n \\t\\t$(NULL)\\t\\t\\t\\ndiff --git a/xpcom/glue/nsTArray.h b/xpcom/glue/nsTArray.h\\nindex 372995e..e6b4516 100644\\n--- a/xpcom/glue/nsTArray.h\\n+++ b/xpcom/glue/nsTArray.h\\n@@ -180,7 +180,12 @@ class nsTArrayElementTraits {\\n   public:\\n     // Invoke the default constructor in place.\\n     static inline void Construct(E *e) {\\n-      new (static_cast<void *>(e)) E();\\n+      // Do NOT call \\\"E()\\\"! That triggers C++ \\\"default initialization\\\"\\n+      // which zeroes out POD (\\\"plain old data\\\") types such as regular ints.\\n+      // We don't want that because it can be a performance issue and people\\n+      // don't expect it; nsTArray should work like a regular C/C++ array in\\n+      // this respect.\\n+      new (static_cast<void *>(e)) E;\\n     }\\n     // Invoke the copy-constructor in place.\\n     template<class A>\\ndiff --git a/xpcom/io/nsLocalFileOSX.cpp b/xpcom/io/nsLocalFileOSX.cpp\\nindex 76c64ec..ab3e4a46 100644\\n--- a/xpcom/io/nsLocalFileOSX.cpp\\n+++ b/xpcom/io/nsLocalFileOSX.cpp\\n@@ -58,7 +58,7 @@\\n \\n #include \\\"MoreFilesX.h\\\"\\n #include \\\"FSCopyObject.h\\\"\\n-#include \\\"nsAutoBuffer.h\\\"\\n+#include \\\"nsTArray.h\\\"\\n #include \\\"nsTraceRefcntImpl.h\\\"\\n \\n // Mac Includes\\n@@ -483,7 +483,7 @@ NS_IMETHODIMP nsLocalFile::Create(PRUint32 type, PRUint32 permissions)\\n   CFURLRef pathURLRef = mBaseRef;\\n   FSRef pathFSRef;\\n   CFStringRef leafStrRef = nsnull;\\n-  nsAutoBuffer<UniChar, FILENAME_BUFFER_SIZE> buffer;\\n+  nsAutoTArray<UniChar, FILENAME_BUFFER_SIZE> buffer;\\n   Boolean success;\\n   \\n   // Work backwards through the path to find the last node which\\n@@ -494,11 +494,11 @@ NS_IMETHODIMP nsLocalFile::Create(PRUint32 type, PRUint32 permissions)\\n     if (!leafStrRef)\\n       break;\\n     CFIndex leafLen = ::CFStringGetLength(leafStrRef);\\n-    if (!buffer.EnsureElemCapacity(leafLen + 1))\\n+    if (!buffer.SetLength(leafLen + 1))\\n       break;\\n-    ::CFStringGetCharacters(leafStrRef, CFRangeMake(0, leafLen), buffer.get());\\n-    buffer.get()[leafLen] = '\\\\0';\\n-    nonExtantNodes.AppendString(nsString(nsDependentString(buffer.get())));\\n+    ::CFStringGetCharacters(leafStrRef, CFRangeMake(0, leafLen), buffer.Elements());\\n+    buffer[leafLen] = '\\\\0';\\n+    nonExtantNodes.AppendString(nsString(nsDependentString(buffer.Elements())));\\n     ::CFRelease(leafStrRef);\\n     leafStrRef = nsnull;\\n     \\n@@ -2499,12 +2499,12 @@ static void CopyUTF8toUTF16NFC(const nsACString& aSrc, nsAString& aResult)\\n     if (chars) \\n         aResult.Assign(chars, length);\\n     else {\\n-        nsAutoBuffer<UniChar, FILENAME_BUFFER_SIZE> buffer;\\n-        if (!buffer.EnsureElemCapacity(length))\\n+        nsAutoTArray<UniChar, FILENAME_BUFFER_SIZE> buffer;\\n+        if (!buffer.SetLength(length))\\n             CopyUTF8toUTF16(aSrc, aResult);\\n         else {\\n-            CFStringGetCharacters(inStr, CFRangeMake(0, length), buffer.get());\\n-            aResult.Assign(buffer.get(), length);\\n+            CFStringGetCharacters(inStr, CFRangeMake(0, length), buffer.Elements());\\n+            aResult.Assign(buffer.Elements(), length);\\n         }\\n     }\\n     CFRelease(inStr);\\ndiff --git a/xpcom/obsolete/nsFileSpecUnix.cpp b/xpcom/obsolete/nsFileSpecUnix.cpp\\nindex 9d7c298..8359e1c 100644\\n--- a/xpcom/obsolete/nsFileSpecUnix.cpp\\n+++ b/xpcom/obsolete/nsFileSpecUnix.cpp\\n@@ -50,7 +50,7 @@\\n #include \\\"xpcom-private.h\\\"\\n #include \\\"nsError.h\\\"\\n #include \\\"prio.h\\\"   /* for PR_Rename */\\n-#include \\\"nsAutoBuffer.h\\\"\\n+#include \\\"nsTArray.h\\\"\\n \\n #if defined(_SCO_DS)\\n #define _SVID3  /* for statvfs.h */\\n@@ -764,10 +764,10 @@ static void CopyUTF8toUTF16NFC(const nsACString& aSrc, nsAString& aResult)\\n     if (chars) \\n         aResult.Assign(chars, length);\\n     else {\\n-        nsAutoBuffer<UniChar, 512> buffer;\\n-        if (buffer.EnsureElemCapacity(length)) {\\n-            CFStringGetCharacters(inStr, CFRangeMake(0, length), buffer.get());\\n-            aResult.Assign(buffer.get(), length);\\n+        nsAutoTArray<UniChar, 512> buffer;\\n+        if (buffer.SetLength(length)) {\\n+            CFStringGetCharacters(inStr, CFRangeMake(0, length), buffer.Elements());\\n+            aResult.Assign(buffer.Elements(), length);\\n         }\\n         else \\n             CopyUTF8toUTF16(aSrc, aResult);\\n\""}