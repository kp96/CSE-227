{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basc2e4907\""},"diff":"\"c2e4907 Bug 394853: countHeap function for js shell and help() cleanup. r=brendan\\ndiff --git a/js/src/js.c b/js/src/js.c\\nindex 050cafd..f69b0f1 100644\\n--- a/js/src/js.c\\n+++ b/js/src/js.c\\n@@ -780,6 +780,163 @@ GCZeal(JSContext *cx, uintN argc, jsval *vp)\\n }\\n #endif /* JS_GC_ZEAL */\\n \\n+typedef struct JSCountHeapNode JSCountHeapNode;\\n+\\n+struct JSCountHeapNode {\\n+    void                *thing;\\n+    uint32              kind;\\n+    JSCountHeapNode     *next;\\n+};\\n+\\n+typedef struct JSCountHeapTracer {\\n+    JSTracer            base;\\n+    JSDHashTable        visited;\\n+    JSBool              ok;\\n+    JSCountHeapNode     *traceList;\\n+    JSCountHeapNode     *recycleList;\\n+} JSCountHeapTracer;\\n+\\n+static void\\n+CountHeapNotify(JSTracer *trc, void *thing, uint32 kind)\\n+{\\n+    JSCountHeapTracer *countTracer;\\n+    JSDHashEntryStub *entry;\\n+    JSCountHeapNode *node;\\n+\\n+    JS_ASSERT(trc->callback == CountHeapNotify);\\n+    countTracer = (JSCountHeapTracer *)trc;\\n+    if (!countTracer->ok)\\n+        return;\\n+\\n+    entry = (JSDHashEntryStub *)\\n+            JS_DHashTableOperate(&countTracer->visited, thing, JS_DHASH_ADD);\\n+    if (!entry) {\\n+        JS_ReportOutOfMemory(trc->context);\\n+        countTracer->ok = JS_FALSE;\\n+        return;\\n+    }\\n+    if (entry->key)\\n+        return;\\n+    entry->key = thing;\\n+\\n+    node = countTracer->recycleList;\\n+    if (node) {\\n+        countTracer->recycleList = node->next;\\n+    } else {\\n+        node = (JSCountHeapNode *) JS_malloc(trc->context, sizeof *node);\\n+        if (!node) {\\n+            countTracer->ok = JS_FALSE;\\n+            return;\\n+        }\\n+    }\\n+    node->thing = thing;\\n+    node->kind = kind;\\n+    node->next = countTracer->traceList;\\n+    countTracer->traceList = node;\\n+}\\n+\\n+static JSBool\\n+CountHeap(JSContext *cx, uintN argc, jsval *vp)\\n+{\\n+    void* startThing;\\n+    int32 startTraceKind;\\n+    jsval v;\\n+    int32 traceKind, i;\\n+    JSString *str;\\n+    char *bytes;\\n+    JSCountHeapTracer countTracer;\\n+    JSCountHeapNode *node;\\n+    size_t counter;\\n+\\n+    static const struct {\\n+        const char       *name;\\n+        int32             kind;\\n+    } traceKindNames[] = {\\n+        { \\\"all\\\",        -1                  },\\n+        { \\\"object\\\",     JSTRACE_OBJECT      },\\n+        { \\\"double\\\",     JSTRACE_DOUBLE      },\\n+        { \\\"string\\\",     JSTRACE_STRING      },\\n+        { \\\"function\\\",   JSTRACE_FUNCTION    },\\n+#if JS_HAS_XML_SUPPORT\\n+        { \\\"namespace\\\",  JSTRACE_NAMESPACE   },\\n+        { \\\"qname\\\",      JSTRACE_QNAME       },\\n+        { \\\"xml\\\",        JSTRACE_XML         },\\n+#endif\\n+    };\\n+\\n+    startThing = NULL;\\n+    startTraceKind = 0;\\n+    if (argc > 0) {\\n+        v = JS_ARGV(cx, vp)[0];\\n+        if (JSVAL_IS_TRACEABLE(v)) {\\n+            startThing = JSVAL_TO_TRACEABLE(v);\\n+            startTraceKind = JSVAL_TRACE_KIND(v);\\n+        } else if (v != JSVAL_NULL) {\\n+            fprintf(gErrFile,\\n+                    \\\"countHeap: argument 1 is not null or a heap-allocated \\\"\\n+                    \\\"thing\\\\n\\\");\\n+            return JS_FALSE;\\n+        }\\n+    }\\n+\\n+    traceKind = -1;\\n+    if (argc > 1) {\\n+        str = JS_ValueToString(cx, JS_ARGV(cx, vp)[1]);\\n+        if (!str)\\n+            return JS_FALSE;\\n+        bytes = JS_GetStringBytes(str);\\n+        if (!bytes)\\n+            return JS_FALSE;\\n+        for (i = 0; ;) {\\n+            if (strcmp(bytes, traceKindNames[i].name) == 0) {\\n+                traceKind = traceKindNames[i].kind;\\n+                break;\\n+            }\\n+            if (++i == JS_ARRAY_LENGTH(traceKindNames)) {\\n+                fprintf(gErrFile,\\n+                        \\\"countHeap: trace kind name '%s' is unknown\\\\n\\\",\\n+                        bytes);\\n+                return JS_FALSE;\\n+            }\\n+        }\\n+    }\\n+\\n+    JS_TRACER_INIT(&countTracer.base, cx, CountHeapNotify);\\n+    if (!JS_DHashTableInit(&countTracer.visited, JS_DHashGetStubOps(),\\n+                           NULL, sizeof(JSDHashEntryStub),\\n+                           JS_DHASH_DEFAULT_CAPACITY(100))) {\\n+        JS_ReportOutOfMemory(cx);\\n+        return JS_FALSE;\\n+    }\\n+    countTracer.ok = JS_TRUE;\\n+    countTracer.traceList = NULL;\\n+    countTracer.recycleList = NULL;\\n+\\n+    if (!startThing) {\\n+        JS_TraceRuntime(&countTracer.base);\\n+    } else {\\n+        JS_SET_TRACING_NAME(&countTracer.base, \\\"root\\\");\\n+        JS_CallTracer(&countTracer.base, startThing, startTraceKind);\\n+    }\\n+\\n+    counter = 0;\\n+    while ((node = countTracer.traceList) != NULL) {\\n+        if (traceKind == -1 || node->kind == traceKind)\\n+            counter++;\\n+        countTracer.traceList = node->next;\\n+        node->next = countTracer.recycleList;\\n+        countTracer.recycleList = node;\\n+        JS_TraceChildren(&countTracer.base, node->thing, node->kind);\\n+    }\\n+    while ((node = countTracer.recycleList) != NULL) {\\n+        countTracer.recycleList = node->next;\\n+        JS_free(cx, node);\\n+    }\\n+    JS_DHashTableFinish(&countTracer.visited);\\n+\\n+    return countTracer.ok && JS_NewNumberValue(cx, (jsdouble) counter, vp);\\n+}\\n+\\n static JSScript *\\n ValueToScript(JSContext *cx, jsval v)\\n {\\n@@ -1376,58 +1533,78 @@ DumpStats(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)\\n }\\n \\n static JSBool\\n-DumpHeap(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)\\n-{\\n-    char *fileName = NULL;\\n-    void* startThing = NULL;\\n-    uint32 startTraceKind = 0;\\n-    void *thingToFind = NULL;\\n-    size_t maxDepth = (size_t)-1;\\n-    void *thingToIgnore = NULL;\\n-    jsval *vp;\\n+DumpHeap(JSContext *cx, uintN argc, jsval *vp)\\n+{\\n+    char *fileName;\\n+    jsval v;\\n+    void* startThing;\\n+    uint32 startTraceKind;\\n+    const char *badTraceArg;\\n+    void *thingToFind;\\n+    size_t maxDepth;\\n+    void *thingToIgnore;\\n     FILE *dumpFile;\\n     JSBool ok;\\n \\n-    vp = &argv[0];\\n-    if (*vp != JSVAL_NULL && *vp != JSVAL_VOID) {\\n-        JSString *str;\\n+    fileName = NULL;\\n+    if (argc > 0) {\\n+        v = JS_ARGV(cx, vp)[0];\\n+        if (v != JSVAL_NULL) {\\n+            JSString *str;\\n \\n-        str = JS_ValueToString(cx, *vp);\\n-        if (!str)\\n-            return JS_FALSE;\\n-        *vp = STRING_TO_JSVAL(str);\\n-        fileName = JS_GetStringBytes(str);\\n+            str = JS_ValueToString(cx, v);\\n+            if (!str)\\n+                return JS_FALSE;\\n+            JS_ARGV(cx, vp)[0] = STRING_TO_JSVAL(str);\\n+            fileName = JS_GetStringBytes(str);\\n+        }\\n     }\\n \\n-    vp = &argv[1];\\n-    if (*vp != JSVAL_NULL && *vp != JSVAL_VOID) {\\n-        if (!JSVAL_IS_TRACEABLE(*vp))\\n+    startThing = NULL;\\n+    startTraceKind = 0;\\n+    if (argc > 1) {\\n+        v = JS_ARGV(cx, vp)[1];\\n+        if (JSVAL_IS_TRACEABLE(v)) {\\n+            startThing = JSVAL_TO_TRACEABLE(v);\\n+            startTraceKind = JSVAL_TRACE_KIND(v);\\n+        } else if (v != JSVAL_NULL) {\\n+            badTraceArg = \\\"start\\\";\\n             goto not_traceable_arg;\\n-        startThing = JSVAL_TO_TRACEABLE(*vp);\\n-        startTraceKind = JSVAL_TRACE_KIND(*vp);\\n+        }\\n     }\\n \\n-    vp = &argv[2];\\n-    if (*vp != JSVAL_NULL && *vp != JSVAL_VOID) {\\n-        if (!JSVAL_IS_TRACEABLE(*vp))\\n+    thingToFind = NULL;\\n+    if (argc > 2) {\\n+        v = JS_ARGV(cx, vp)[2];\\n+        if (JSVAL_IS_TRACEABLE(v)) {\\n+            thingToFind = JSVAL_TO_TRACEABLE(v);\\n+        } else if (v != JSVAL_NULL) {\\n+            badTraceArg = \\\"toFind\\\";\\n             goto not_traceable_arg;\\n-        thingToFind = JSVAL_TO_TRACEABLE(*vp);\\n+        }\\n     }\\n \\n-    vp = &argv[3];\\n-    if (*vp != JSVAL_NULL && *vp != JSVAL_VOID) {\\n-        uint32 depth;\\n+    maxDepth = (size_t)-1;\\n+    if (argc > 3) {\\n+        v = JS_ARGV(cx, vp)[3];\\n+        if (v != JSVAL_NULL) {\\n+            uint32 depth;\\n \\n-        if (!JS_ValueToECMAUint32(cx, *vp, &depth))\\n-            return JS_FALSE;\\n-        maxDepth = depth;\\n+            if (!JS_ValueToECMAUint32(cx, v, &depth))\\n+                return JS_FALSE;\\n+            maxDepth = depth;\\n+        }\\n     }\\n \\n-    vp = &argv[4];\\n-    if (*vp != JSVAL_NULL && *vp != JSVAL_VOID) {\\n-        if (!JSVAL_IS_TRACEABLE(*vp))\\n+    thingToIgnore = NULL;\\n+    if (argc > 4) {\\n+        v = JS_ARGV(cx, vp)[4];\\n+        if (JSVAL_IS_TRACEABLE(v)) {\\n+            thingToIgnore = JSVAL_TO_TRACEABLE(v);\\n+        } else if (v != JSVAL_NULL) {\\n+            badTraceArg = \\\"toIgnore\\\";\\n             goto not_traceable_arg;\\n-        thingToIgnore = JSVAL_TO_TRACEABLE(*vp);\\n+        }\\n     }\\n \\n     if (!fileName) {\\n@@ -1449,8 +1626,8 @@ DumpHeap(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)\\n \\n   not_traceable_arg:\\n     fprintf(gErrFile,\\n-            \\\"dumpHeap: argument %u is not null or a heap-allocated thing\\\\n\\\",\\n-            (unsigned)(vp - argv));\\n+            \\\"dumpHeap: argument '%s' is not null or a heap-allocated thing\\\\n\\\",\\n+            badTraceArg);\\n     return JS_FALSE;\\n }\\n \\n@@ -2242,6 +2419,7 @@ static JSFunctionSpec shell_functions[] = {\\n     JS_FS(\\\"help\\\",           Help,           0,0,0),\\n     JS_FS(\\\"quit\\\",           Quit,           0,0,0),\\n     JS_FN(\\\"gc\\\",             GC,             0,0,0,0),\\n+    JS_FN(\\\"countHeap\\\",      CountHeap,      0,0,0,0),\\n #ifdef JS_GC_ZEAL\\n     JS_FN(\\\"gczeal\\\",         GCZeal,         1,1,0,0),\\n #endif\\n@@ -2256,7 +2434,7 @@ static JSFunctionSpec shell_functions[] = {\\n #ifdef DEBUG\\n     JS_FS(\\\"dis\\\",            Disassemble,    1,0,0),\\n     JS_FS(\\\"dissrc\\\",         DisassWithSrc,  1,0,0),\\n-    JS_FS(\\\"dumpHeap\\\",       DumpHeap,       5,0,0),\\n+    JS_FN(\\\"dumpHeap\\\",       DumpHeap,       0,0,0,0),\\n     JS_FS(\\\"notes\\\",          Notes,          1,0,0),\\n     JS_FS(\\\"tracing\\\",        Tracing,        0,0,0),\\n     JS_FS(\\\"stats\\\",          DumpStats,      1,0,0),\\n@@ -2279,103 +2457,86 @@ static JSFunctionSpec shell_functions[] = {\\n     JS_FS_END\\n };\\n \\n-/* NOTE: These must be kept in sync with the above. */\\n-\\n-static char *shell_help_messages[] = {\\n-    \\\"version([number])      Get or set JavaScript version number\\\",\\n-    \\\"options([option ...])  Get or toggle JavaScript options\\\",\\n-    \\\"load(['foo.js' ...])   Load files named by string arguments\\\",\\n-    \\\"readline()             Read a single line from stdin\\\",\\n-    \\\"print([exp ...])       Evaluate and print expressions\\\",\\n-    \\\"help([name ...])       Display usage and help messages\\\",\\n-    \\\"quit()                 Quit the shell\\\",\\n-    \\\"gc()                   Run the garbage collector\\\",\\n+static const char shell_help_header[] =\\n+\\\"Command                  Description\\\\n\\\"\\n+\\\"=======                  ===========\\\\n\\\";\\n+\\n+static const char *const shell_help_messages[] = {\\n+\\\"version([number])        Get or set JavaScript version number\\\",\\n+\\\"options([option ...])    Get or toggle JavaScript options\\\",\\n+\\\"load(['foo.js' ...])     Load files named by string arguments\\\",\\n+\\\"readline()               Read a single line from stdin\\\",\\n+\\\"print([exp ...])         Evaluate and print expressions\\\",\\n+\\\"help([name ...])         Display usage and help messages\\\",\\n+\\\"quit()                   Quit the shell\\\",\\n+\\\"gc()                     Run the garbage collector\\\",\\n+\\\"countHeap([start[, kind]])\\\\n\\\"\\n+\\\"  Count the number of live GC things in the heap or things reachable from\\\\n\\\"\\n+\\\"  start when it is given and is not null. kind is either 'all' (default) to\\\\n\\\"\\n+\\\"  count all things or one of 'object', 'double', 'string', 'function',\\\\n\\\"\\n+\\\"  'qname', 'namespace', 'xml' to count only things of that kind\\\",\\n #ifdef JS_GC_ZEAL\\n-    \\\"gczeal(level)          How zealous the garbage collector should be\\\",\\n+\\\"gczeal(level)            How zealous the garbage collector should be\\\",\\n #endif\\n-    \\\"trap([fun, [pc,]] exp) Trap bytecode execution\\\",\\n-    \\\"untrap(fun[, pc])      Remove a trap\\\",\\n-    \\\"line2pc([fun,] line)   Map line number to PC\\\",\\n-    \\\"pc2line(fun[, pc])     Map PC to line number\\\",\\n-    \\\"stackQuota([number])   Query/set script stack quota\\\",\\n-    \\\"stringsAreUTF8()       Check if strings are UTF-8 encoded\\\",\\n-    \\\"testUTF8(mode)         Perform UTF-8 tests (modes are 1 to 4)\\\",\\n-    \\\"throwError()           Throw an error from JS_ReportError\\\",\\n+\\\"trap([fun, [pc,]] exp)   Trap bytecode execution\\\",\\n+\\\"untrap(fun[, pc])        Remove a trap\\\",\\n+\\\"line2pc([fun,] line)     Map line number to PC\\\",\\n+\\\"pc2line(fun[, pc])       Map PC to line number\\\",\\n+\\\"stackQuota([number])     Query/set script stack quota\\\",\\n+\\\"stringsAreUTF8()         Check if strings are UTF-8 encoded\\\",\\n+\\\"testUTF8(mode)           Perform UTF-8 tests (modes are 1 to 4)\\\",\\n+\\\"throwError()             Throw an error from JS_ReportError\\\",\\n #ifdef DEBUG\\n-    \\\"dis([fun])             Disassemble functions into bytecodes\\\",\\n-    \\\"dissrc([fun])          Disassemble functions with source lines\\\",\\n-    \\\"dumpHeap([fileName], [start], [toFind], [maxDepth], [toIgnore])\\\\n\\\"\\n-    \\\"                       Interface to JS_DumpHeap with output sent to file\\\",\\n-    \\\"notes([fun])           Show source notes for functions\\\",\\n-    \\\"tracing([toggle])      Turn tracing on or off\\\",\\n-    \\\"stats([string ...])    Dump 'arena', 'atom', 'global' stats\\\",\\n+\\\"dis([fun])               Disassemble functions into bytecodes\\\",\\n+\\\"dissrc([fun])            Disassemble functions with source lines\\\",\\n+\\\"dumpHeap([fileName[, start[, toFind[, maxDepth[, toIgnore]]]]])\\\\n\\\"\\n+\\\"  Interface to JS_DumpHeap with output sent to file\\\",\\n+\\\"notes([fun])             Show source notes for functions\\\",\\n+\\\"tracing([toggle])        Turn tracing on or off\\\",\\n+\\\"stats([string ...])      Dump 'arena', 'atom', 'global' stats\\\",\\n #endif\\n #ifdef TEST_EXPORT\\n-    \\\"xport(obj, id)         Export identified property from object\\\",\\n+\\\"xport(obj, property)     Export the given property of obj\\\",\\n #endif\\n #ifdef TEST_CVTARGS\\n-    \\\"cvtargs(b, c, ...)     Test JS_ConvertArguments\\\",\\n+\\\"cvtargs(arg1..., arg12)  Test argument formater\\\",\\n #endif\\n-    \\\"build()                Show build date and time\\\",\\n-    \\\"clear([obj])           Clear properties of object\\\",\\n-    \\\"intern(str)            Internalize str in the atom table\\\",\\n-    \\\"clone(fun[, scope])    Clone function object\\\",\\n-    \\\"seal(obj[, deep])      Seal object, or object graph if deep\\\",\\n-    \\\"getpda(obj)            Get the property descriptors for obj\\\",\\n-    \\\"getslx(obj)            Get script line extent\\\",\\n-    \\\"toint32(n)             Testing hook for JS_ValueToInt32\\\",\\n-    \\\"evalcx(s[, o])         Evaluate s in optional sandbox object o\\\\n\\\"\\n-    \\\"    if (s == '' && !o) return new o with eager standard classes\\\\n\\\"\\n-    \\\"    if (s == 'lazy' && !o) return new o with lazy standard classes\\\",\\n-    0\\n+\\\"build()                  Show build date and time\\\",\\n+\\\"clear([obj])             Clear properties of object\\\",\\n+\\\"intern(str)              Internalize str in the atom table\\\",\\n+\\\"clone(fun[, scope])      Clone function object\\\",\\n+\\\"seal(obj[, deep])        Seal object, or object graph if deep\\\",\\n+\\\"getpda(obj)              Get the property descriptors for obj\\\",\\n+\\\"getslx(obj)              Get script line extent\\\",\\n+\\\"toint32(n)               Testing hook for JS_ValueToInt32\\\",\\n+\\\"evalcx(s[, o])\\\\n\\\"\\n+\\\"  Evaluate s in optional sandbox object o\\\\n\\\"\\n+\\\"  if (s == '' && !o) return new o with eager standard classes\\\\n\\\"\\n+\\\"  if (s == 'lazy' && !o) return new o with lazy standard classes\\\",\\n };\\n \\n-static void\\n-ShowHelpHeader(void)\\n-{\\n-    fprintf(gOutFile, \\\"%-14s %-22s %s\\\\n\\\", \\\"Command\\\", \\\"Usage\\\", \\\"Description\\\");\\n-    fprintf(gOutFile, \\\"%-14s %-22s %s\\\\n\\\", \\\"=======\\\", \\\"=====\\\", \\\"===========\\\");\\n-}\\n+/* Help messages must match shell functions. */\\n+JS_STATIC_ASSERT(JS_ARRAY_LENGTH(shell_help_messages) + 1 ==\\n+                 JS_ARRAY_LENGTH(shell_functions));\\n \\n+#ifdef DEBUG\\n static void\\n-ShowHelpForCommand(uintN n)\\n+CheckHelpMessages()\\n {\\n-    fprintf(gOutFile, \\\"%-14.14s %s\\\\n\\\", shell_functions[n].name, shell_help_messages[n]);\\n-}\\n-\\n-static JSObject *\\n-split_setup(JSContext *cx)\\n-{\\n-    JSObject *outer, *inner, *arguments;\\n-\\n-    outer = split_create_outer(cx);\\n-    if (!outer)\\n-        return NULL;\\n-    JS_SetGlobalObject(cx, outer);\\n-\\n-    inner = split_create_inner(cx, outer);\\n-    if (!inner)\\n-        return NULL;\\n-\\n-    if (!JS_DefineFunctions(cx, inner, shell_functions))\\n-        return NULL;\\n-    JS_ClearScope(cx, outer);\\n+    const char *const *m;\\n+    const char *lp;\\n \\n-    /* Create a dummy arguments object. */\\n-    arguments = JS_NewArrayObject(cx, 0, NULL);\\n-    if (!arguments ||\\n-        !JS_DefineProperty(cx, inner, \\\"arguments\\\", OBJECT_TO_JSVAL(arguments),\\n-                           NULL, NULL, 0)) {\\n-        return NULL;\\n+    /* Each message must begin with \\\"function_name(\\\" prefix. */\\n+    for (m = shell_help_messages; m != JS_ARRAY_END(shell_help_messages); ++m) {\\n+        lp = strchr(*m, '(');\\n+        JS_ASSERT(lp);\\n+        JS_ASSERT(memcmp(shell_functions[m - shell_help_messages].name,\\n+                         *m, lp - *m) == 0);\\n     }\\n-\\n-#ifndef LAZY_STANDARD_CLASSES\\n-    if (!JS_InitStandardClasses(cx, inner))\\n-        return NULL;\\n-#endif\\n-\\n-    return inner;\\n }\\n+#else\\n+# define CheckHelpMessages() ((void) 0)\\n+#endif\\n \\n static JSBool\\n Help(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)\\n@@ -2389,9 +2550,9 @@ Help(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)\\n \\n     fprintf(gOutFile, \\\"%s\\\\n\\\", JS_GetImplementationVersion());\\n     if (argc == 0) {\\n-        ShowHelpHeader();\\n+        fputs(shell_help_header, gOutFile);\\n         for (i = 0; shell_functions[i].name; i++)\\n-            ShowHelpForCommand(i);\\n+            fprintf(gOutFile, \\\"%s\\\\n\\\", shell_help_messages[i]);\\n     } else {\\n         did_header = 0;\\n         for (i = 0; i < argc; i++) {\\n@@ -2411,10 +2572,10 @@ Help(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)\\n                     if (!strcmp(bytes, shell_functions[j].name)) {\\n                         if (!did_header) {\\n                             did_header = 1;\\n-                            ShowHelpHeader();\\n+                            fputs(shell_help_header, gOutFile);\\n                         }\\n                         did_something = 1;\\n-                        ShowHelpForCommand(j);\\n+                        fprintf(gOutFile, \\\"%s\\\\n\\\", shell_help_messages[j]);\\n                         break;\\n                     }\\n                 }\\n@@ -2431,6 +2592,40 @@ Help(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)\\n     return JS_TRUE;\\n }\\n \\n+static JSObject *\\n+split_setup(JSContext *cx)\\n+{\\n+    JSObject *outer, *inner, *arguments;\\n+\\n+    outer = split_create_outer(cx);\\n+    if (!outer)\\n+        return NULL;\\n+    JS_SetGlobalObject(cx, outer);\\n+\\n+    inner = split_create_inner(cx, outer);\\n+    if (!inner)\\n+        return NULL;\\n+\\n+    if (!JS_DefineFunctions(cx, inner, shell_functions))\\n+        return NULL;\\n+    JS_ClearScope(cx, outer);\\n+\\n+    /* Create a dummy arguments object. */\\n+    arguments = JS_NewArrayObject(cx, 0, NULL);\\n+    if (!arguments ||\\n+        !JS_DefineProperty(cx, inner, \\\"arguments\\\", OBJECT_TO_JSVAL(arguments),\\n+                           NULL, NULL, 0)) {\\n+        return NULL;\\n+    }\\n+\\n+#ifndef LAZY_STANDARD_CLASSES\\n+    if (!JS_InitStandardClasses(cx, inner))\\n+        return NULL;\\n+#endif\\n+\\n+    return inner;\\n+}\\n+\\n /*\\n  * Define a JS object called \\\"it\\\".  Give it class operations that printf why\\n  * they're being called for tutorial purposes.\\n@@ -3177,10 +3372,11 @@ main(int argc, char **argv, char **envp)\\n     JNIEnv *java_env;\\n #endif\\n \\n-    gStackBase = (jsuword)&stackDummy;\\n-\\n+    CheckHelpMessages();\\n     setlocale(LC_ALL, \\\"\\\");\\n \\n+    gStackBase = (jsuword)&stackDummy;\\n+\\n #ifdef XP_OS2\\n    /* these streams are normally line buffered on OS/2 and need a \\\\n, *\\n     * so we need to unbuffer then to get a reasonable prompt          */\\n\""}