{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas4a4c291\""},"diff":"\"4a4c291 Return conflicts from sync engine; change bookmarks serialization to use a flat dictionary keyed by guid, instead of a deep structure.\\ndiff --git a/services/sync/nsBookmarksSyncService.js b/services/sync/nsBookmarksSyncService.js\\nindex b955c9b..a095423 100644\\n--- a/services/sync/nsBookmarksSyncService.js\\n+++ b/services/sync/nsBookmarksSyncService.js\\n@@ -97,22 +97,145 @@ BookmarksSyncService.prototype = {\\n     var jsLoader = Cc[\\\"@mozilla.org/moz/jssubscript-loader;1\\\"].\\n       getService(Ci.mozIJSSubScriptLoader);\\n     jsLoader.loadSubScript(\\\"chrome://sync/content/sync-engine.js\\\", this._sync);\\n-    jsLoader.loadSubScript(\\\"chrome://browser/content/places/utils.js\\\", this._utils);\\n   },\\n \\n-  _applyCommands: function BSS__applyCommands(node, commandList) {\\n+  _wrapNode: function BSS__wrapNode(node) {\\n+    var items = {};\\n+    this._wrapNodeInternal(node, items);\\n+\\n+    // sanity check\\n+    var rootGuid = this._bms.getItemGUID(node.itemId);\\n+    for (var wanted in items) {\\n+      if (rootGuid == wanted)\\n+        continue;\\n+      var found = false;\\n+      for (var parent in items) {\\n+        if (items[parent].children && items[parent].children.indexOf(wanted) >= 0) {\\n+          found = true;\\n+          continue;\\n+        }\\n+      }\\n+      if (!found) {\\n+        LOG(\\\"wrapNode error: node has no parent (\\\" + wanted + \\\")\\\");\\n+      }\\n+    }\\n+\\n+    return items;\\n+  },\\n+\\n+  _wrapNodeInternal: function BSS__wrapNodeInternal(node, items) {\\n+    var guid = this._bms.getItemGUID(node.itemId);\\n+    var item = {\\\"type\\\": node.type};\\n+\\n+    if (node.type == node.RESULT_TYPE_FOLDER) {\\n+      node.QueryInterface(Ci.nsINavHistoryQueryResultNode);\\n+      var openState = node.containerOpen;\\n+      node.containerOpen = true;\\n+      var children = [];\\n+      for (var i = 0; i < node.childCount; i++) {\\n+        var child = node.getChild(i);\\n+        this._wrapNodeInternal(child, items);\\n+        children.push(this._bms.getItemGUID(child.itemId));\\n+      }\\n+      item[\\\"children\\\"] = children;\\n+      item[\\\"title\\\"] = node.title;\\n+      node.containerOpen = openState;\\n+    } else if (node.type == node.RESULT_TYPE_SEPARATOR) {\\n+    } else if (node.type == node.RESULT_TYPE_URI) {\\n+      // FIXME: need to verify that it's a bookmark, it could be a history result!\\n+      item[\\\"title\\\"] = node.title;\\n+      item[\\\"uri\\\"] = node.uri;\\n+    } else {\\n+      // what do we do?\\n+    }\\n+\\n+    items[guid] = item;\\n+  },\\n+\\n+  // find parent & index\\n+  // note that this._snapshot needs to be up-to-date!\\n+  _findItemParent: function BSS__findItemParent(itemGuid) {\\n+    var parent;\\n+    var index;\\n+    for (var item in this._snapshot) {\\n+      if (this._snapshot[item].children) {\\n+        index = this._snapshot[item].children.indexOf(itemGuid);\\n+        if (index >= 0) {\\n+          parent = item;\\n+          break;\\n+        }\\n+      }\\n+    }\\n+    return [parent, index];\\n+  },\\n+\\n+  _combineCommands: function BSS__combineCommands(commandList) {\\n+    var newList = [];\\n+    var lastObj;\\n+    if (newList.length)\\n+      lastObj = newList[newList.length - 1];\\n+\\n+    for (var i = 0; i < commandList.length; i++) {\\n+      LOG(\\\"Command: \\\" + uneval(commandList[i]) + \\\"\\\\n\\\");\\n+      var action = commandList[i].action;\\n+      var path = commandList[i].path;\\n+      var guid = path.shift();\\n+\\n+      // Note: this only works when the commands to be collapsed are\\n+      // contiguous in the array (this is ok right?)\\n+      if ((action == \\\"create\\\" || action == \\\"remove\\\") &&\\n+          (!newList.length ||\\n+           (lastObj && lastObj.guid != guid && lastObj.action != action))) {\\n+        // Avoid the commands that edit the parent's children property\\n+        if (path.length != 1)\\n+          continue;\\n+\\n+        let [parent, index] = this._findItemParent(guid);\\n+        if (!parent) {\\n+          LOG(\\\"Warning: item has no parent!\\\\n\\\");\\n+          continue;\\n+        }\\n+\\n+        newList.push({action: action,\\n+                      guid: guid,\\n+                      parentGuid: parent,\\n+                      index: index,\\n+                      data: this._snapshot[guid]});\\n+\\n+      } else if (action == \\\"edit\\\") {\\n+        // FIXME: will we never edit anything deeper?\\n+        if (path.length != 1) {\\n+          LOG(\\\"Warning: editing deep property - dropping\\\");\\n+          continue;\\n+        }\\n+\\n+        if (!newList.length ||\\n+            (lastObj && lastObj.guid != guid && lastObj.action != action))\\n+          newList.push({action: action, guid: guid});\\n+\\n+        var key = path[path.length - 1];\\n+        var value = this._snapshot[guid][key];\\n+        newList[newList.length - 1].data[key] = value;\\n+      }\\n+    }\\n+    LOG(\\\"Combined list:\\\\n\\\");\\n+    LOG(uneval(newList) + \\\"\\\\n\\\");\\n+    return newList;\\n+  },\\n+\\n+  _applyCommands: function BSS__applyCommands(commandList) {\\n     for (var i = 0; i < commandList.length; i++) {\\n       var command = commandList[i];\\n       LOG(\\\"Processing command: \\\" + uneval(command));\\n       switch (command[\\\"action\\\"]) {\\n       case \\\"create\\\":\\n-        this._createCommand(node, this._snapshot, command);\\n+        this._createCommand(command);\\n         break;\\n       case \\\"remove\\\":\\n-        this._removeCommand(node, command);\\n+        this._removeCommand(command);\\n         break;\\n       case \\\"edit\\\":\\n-        this._editCommand(node, command);\\n+        this._editCommand(command);\\n         break;\\n       default:\\n         LOG(\\\"unknown action in command: \\\" + command[\\\"action\\\"]);\\n@@ -121,53 +244,38 @@ BookmarksSyncService.prototype = {\\n     }\\n   },\\n \\n-  _nodeFromPath: function BSS__nodeFromPath (aNodeRoot, aPath) {\\n-    var node = aNodeRoot;\\n-    for (var i = 0; i < aPath.length; i = i + 2) {\\n-      if (aPath[i] != \\\"children\\\")\\n-        break;\\n-      node.QueryInterface(Ci.nsINavHistoryQueryResultNode);\\n-      var openState = node.containerOpen;\\n-      node.containerOpen = true;\\n-      node = node.getChild(aPath[i + 1]);\\n-      //node.containerOpen = openState; // fixme?\\n-    }\\n-    return node;\\n-  },\\n-\\n-  _createCommand: function BSS__createCommand(aNode, aJsonNode, aCommand) {\\n-    var path = aCommand[\\\"path\\\"];\\n-    if (path[path.length - 2] != \\\"children\\\")\\n-      path = aCommand[\\\"path\\\"].slice(0, path.length - 1);\\n-\\n-    var json = this._sync.pathToReference(aJsonNode, path);\\n-    if (json[\\\"_done\\\"] == true)\\n-      return;\\n-    json[\\\"_done\\\"] = true;\\n-\\n-    var index = path[path.length - 1];\\n-    var node = this._nodeFromPath(aNode, path.slice(0, path.length - 2));\\n-\\n-    switch (json[\\\"type\\\"]) {\\n+  _createCommand: function BSS__createCommand(command) {\\n+    var newId;\\n+    var parentId = this._bms.getItemIdForGUID(command.parentGuid);\\n+    switch (command.data.type) {\\n     case 0:\\n-      LOG(\\\"  -> creating a bookmark: '\\\" + json[\\\"title\\\"] + \\\"' -> \\\" + json[\\\"uri\\\"]);\\n-      this._bms.insertBookmark(node.itemId, makeURI(json[\\\"uri\\\"]), index, json[\\\"title\\\"]);\\n+      LOG(\\\"  -> creating a bookmark: '\\\" + command.data.title +\\n+          \\\"' -> \\\" + command.data.uri);\\n+      newId = this._bms.insertBookmark(parentId,\\n+                                       makeURI(command.data.uri),\\n+                                       command.index,\\n+                                       command.data.title);\\n       break;\\n     case 6:\\n-      LOG(\\\"  -> creating a folder: '\\\" + json[\\\"title\\\"] + \\\"'\\\");\\n-      this._bms.createFolder(node.itemId, json[\\\"title\\\"], index);\\n+      LOG(\\\"  -> creating a folder: '\\\" + command.data.title + \\\"'\\\");\\n+      newId = this._bms.createFolder(parentId,\\n+                                     command.data.title,\\n+                                     command.index);\\n       break;\\n     case 7:\\n       LOG(\\\"  -> creating a separator\\\");\\n-      this._bms.insertSeparator(node.itemId, index);\\n+      newId = this._bms.insertSeparator(parentId, command.index);\\n       break;\\n     default:\\n-      LOG(\\\"createCommand: Unknown item type: \\\" + json[\\\"type\\\"]);\\n+      LOG(\\\"createCommand: Unknown item type: \\\" + command.data.type);\\n       break;\\n     }\\n+    if (newId)\\n+      this._bms.setItemGUID(newId, command.guid);\\n   },\\n \\n-  _removeCommand: function BSS__removeCommand(node, command) {\\n+  _removeCommand: function BSS__removeCommand(command) {\\n+    var iid = this._bss.getItemIdForGUID(aCommand.guid);\\n     if (command[\\\"path\\\"].length == 0) {\\n       LOG(\\\"removing item\\\");\\n       switch (node.type) {\\n@@ -239,35 +347,6 @@ BookmarksSyncService.prototype = {\\n     return this._hsvc.executeQuery(query, this._hsvc.getNewQueryOptions()).root;\\n   },\\n \\n-  // FIXME: temp version here because we can't yet get to PlacesUtils.wrapNode\\n-  _wrapNode: function BSS__wrapNode(node) {\\n-    //var guid = this._bms.getItemGuid(node.itemId);\\n-    var item = {\\\"type\\\": node.type}; //,\\n-    //                \\\"guid\\\": guid};\\n-\\n-    if (node.type == node.RESULT_TYPE_FOLDER) {\\n-      node.QueryInterface(Ci.nsINavHistoryQueryResultNode);\\n-      var openState = node.containerOpen;\\n-      node.containerOpen = true;\\n-      var children = [];\\n-      for (var i = 0; i < node.childCount; i++) {\\n-        children.push(this._wrapNode(node.getChild(i)));\\n-      }\\n-      item[\\\"children\\\"] = children;\\n-      item[\\\"title\\\"] = node.title;\\n-      node.containerOpen = openState;\\n-    } else if (node.type == node.RESULT_TYPE_SEPARATOR) {\\n-    } else if (node.type == node.RESULT_TYPE_URI) {\\n-      // FIXME: need to verify that it's a bookmark, it could be a history result!\\n-      item[\\\"title\\\"] = node.title;\\n-      item[\\\"uri\\\"] = node.uri;\\n-    } else {\\n-      // what do we do?\\n-    }\\n-\\n-    return item;\\n-  },\\n-\\n   // 1) Fetch server deltas\\n   // 1.1) Construct current server status from snapshot + server deltas\\n   // 1.2) Generate single delta from snapshot -> current server status\\n@@ -306,6 +385,7 @@ BookmarksSyncService.prototype = {\\n       LOG(\\\"Latest server version: \\\" + server['version']);\\n \\n       // 2) Generate local deltas from snapshot -> current client status\\n+\\n       LOG(\\\"Generating local updates\\\");\\n       var localUpdates = this._sanitizeCommands(this._sync.detectUpdates(this._snapshot, localJson));\\n       if (!(server['status'] == 1 || localUpdates.length > 0)) {\\n@@ -314,35 +394,45 @@ BookmarksSyncService.prototype = {\\n       }\\n \\t  \\n       // 3) Reconcile client/server deltas and generate new deltas for them.\\n+\\n       var propagations = [server['updates'], localUpdates];\\n+      var conflicts;\\n+\\n       if (server['status'] == 1 && localUpdates.length > 0) {\\n         LOG(\\\"Reconciling updates\\\");\\n-        propagations = this._sync.reconcile([localUpdates, server['updates']]);\\n+        var ret = this._sync.reconcile([localUpdates, server['updates']]);\\n+        propagations = ret.propagations;\\n+        conflicts = ret.conflicts;\\n       }\\n+\\n+      LOG(\\\"\\\\n\\\" + uneval(conflicts) + \\\"\\\\n\\\");\\n \\t  \\n-\\t  if (!((propagations[0] && propagations[0].length > 0) || (propagations[1] && propagations[1].length > 0))) {\\n+      this._snapshotVersion = server['version'];\\n+\\n+      LOG(uneval(propagations));\\n+      if (!((propagations[0] && propagations[0].length > 0) ||\\n+            (propagations[1] && propagations[1].length > 0))) {\\n         this._snapshot = this._wrapNode(localBookmarks);\\n         LOG(\\\"Sync complete (2): no changes needed on client or server\\\");\\n         return;\\n-      } \\n-\\t  \\n-\\t this._snapshotVersion = server['version'];\\n+      }\\n \\n       // 3.1) Apply server changes to local store\\n       if (propagations[0] && propagations[0].length > 0) {\\n         LOG(\\\"Applying changes locally\\\");\\n         localBookmarks = this._getLocalBookmarks(); // fixme: wtf\\n         this._snapshot = this._wrapNode(localBookmarks);\\n-        // applyCommands changes the input commands, so we eval(uneval()) them to make a copy :-/\\n-   \\t    this._sync.applyCommands(this._snapshot, eval(uneval(propagations[0])));\\n-        this._applyCommands(localBookmarks, propagations[0]);\\n+        // Note: propagations[0] is changed by applyCommands, so we make a deep copy\\n+        this._sync.applyCommands(this._snapshot, eval(uneval(propagations[0])));\\n+        var combinedCommands = this._combineCommands(propagations[0]);\\n+        this._applyCommands(combinedCommands);\\n         this._snapshot = this._wrapNode(localBookmarks);\\n-\\t\\tthis._snapshotVersion = server['version'];\\n       }\\n \\n       // 3.2) Append server delta to the delta file and upload\\n       if (propagations[1] && propagations[1].length) {\\n         LOG(\\\"Uploading changes to server\\\");\\n+        this._snapshot = this._wrapNode(localBookmarks);\\n         this._snapshotVersion++;\\n         server['deltas'][this._snapshotVersion] = propagations[1];\\n         this._dav.PUT(\\\"bookmarks.delta\\\", uneval(server['deltas']), handlers);\\n@@ -353,7 +443,7 @@ BookmarksSyncService.prototype = {\\n         else\\n           LOG(\\\"Error: could not update deltas on server\\\");\\n       }\\n-\\t      LOG(\\\"Sync complete\\\");\\n+      LOG(\\\"Sync complete\\\");\\n     } finally {\\n       //this._dav.unlock(handlers);\\n       //data = yield;\\n\""}