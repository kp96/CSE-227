{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basc616621\""},"diff":"\"c616621 Bug 393796. Be more careful about verifying that an existing textrun is okay to be reused again after a change to the frame tree. r=smontagu\\ndiff --git a/layout/generic/nsTextFrameThebes.cpp b/layout/generic/nsTextFrameThebes.cpp\\nindex 2b394ad..6929f51 100644\\n--- a/layout/generic/nsTextFrameThebes.cpp\\n+++ b/layout/generic/nsTextFrameThebes.cpp\\n@@ -866,6 +866,7 @@ public:\\n     }\\n   }\\n   void ScanFrame(nsIFrame* aFrame);\\n+  PRBool IsTextRunValidForMappedFlows(gfxTextRun* aTextRun);\\n   void FlushFrames(PRBool aFlushLineBreaks);\\n   void ResetRunInfo() {\\n     mLastFrame = nsnull;\\n@@ -898,9 +899,8 @@ public:\\n   PRBool ContinueTextRunAcrossFrames(nsTextFrame* aFrame1, nsTextFrame* aFrame2);\\n \\n   // Like TextRunMappedFlow but with some differences. mStartFrame to mEndFrame\\n-  // are a sequence of in-flow frames. There can be multiple MappedFlows per\\n-  // content element; the frames in each MappedFlow all have the same style\\n-  // context.\\n+  // (exclusive) are a sequence of in-flow frames (if mEndFrame is null, then\\n+  // continuations starting from mStartFrame are a sequence of in-flow frames).\\n   struct MappedFlow {\\n     nsTextFrame* mStartFrame;\\n     nsTextFrame* mEndFrame;\\n@@ -910,9 +910,12 @@ public:\\n     // ancestor of mStartFrame and the previous text frame, or null if there\\n     // was no previous text frame on this line.\\n     nsIFrame*    mAncestorControllingInitialBreak;\\n-    PRInt32      mContentOffset;\\n-    PRInt32      mContentEndOffset;\\n     PRUint32     mTransformedTextOffset; // Only used inside BuildTextRunForFrames\\n+    \\n+    PRInt32 GetContentEnd() {\\n+      return mEndFrame ? mEndFrame->GetContentOffset()\\n+          : mStartFrame->GetContent()->GetText()->GetLength();\\n+    }\\n   };\\n \\n   class BreakSink : public nsILineBreakSink {\\n@@ -1234,6 +1237,26 @@ ExpandBuffer(PRUnichar* aDest, PRUint8* aSrc, PRUint32 aCount)\\n   return aDest;\\n }\\n \\n+PRBool BuildTextRunsScanner::IsTextRunValidForMappedFlows(gfxTextRun* aTextRun)\\n+{\\n+  if (aTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW)\\n+    return mMappedFlows.Length() == 1 &&\\n+      mMappedFlows[0].mStartFrame == static_cast<nsTextFrame*>(aTextRun->GetUserData()) &&\\n+      mMappedFlows[0].mEndFrame == nsnull;\\n+\\n+  TextRunUserData* userData = static_cast<TextRunUserData*>(aTextRun->GetUserData());\\n+  if (userData->mMappedFlowCount != PRInt32(mMappedFlows.Length()))\\n+    return PR_FALSE;\\n+  PRUint32 i;\\n+  for (i = 0; i < mMappedFlows.Length(); ++i) {\\n+    if (userData->mMappedFlows[i].mStartFrame != mMappedFlows[i].mStartFrame ||\\n+        PRInt32(userData->mMappedFlows[i].mContentLength) !=\\n+            mMappedFlows[i].GetContentEnd() - mMappedFlows[i].mStartFrame->GetContentOffset())\\n+      return PR_FALSE;\\n+  }\\n+  return PR_TRUE;\\n+}\\n+\\n /**\\n  * This gets called when we need to make a text run for the current list of\\n  * frames.\\n@@ -1245,11 +1268,9 @@ void BuildTextRunsScanner::FlushFrames(PRBool aFlushLineBreaks)\\n \\n   if (!mSkipIncompleteTextRuns && mCurrentFramesAllSameTextRun &&\\n       ((mCurrentFramesAllSameTextRun->GetFlags() & nsTextFrameUtils::TEXT_INCOMING_WHITESPACE) != 0) ==\\n-      mCurrentRunTrimLeadingWhitespace) {\\n+      mCurrentRunTrimLeadingWhitespace &&\\n+      IsTextRunValidForMappedFlows(mCurrentFramesAllSameTextRun)) {\\n     // Optimization: We do not need to (re)build the textrun.\\n-    // Note that if the textrun included all these frames and more, and something\\n-    // changed so that it can only cover these frames, then one of the frames\\n-    // at the boundary would have detected the change and nuked the textrun.\\n \\n     // Feed this run's text into the linebreaker to provide context. This also\\n     // updates mTrimNextRunLeadingWhitespace appropriately.\\n@@ -1285,6 +1306,15 @@ void BuildTextRunsScanner::AccumulateRunInfo(nsTextFrame* aFrame)\\n   mLastFrame = aFrame;\\n   mCommonAncestorWithLastFrame = aFrame;\\n \\n+  MappedFlow* mappedFlow = &mMappedFlows[mMappedFlows.Length() - 1];\\n+  NS_ASSERTION(mappedFlow->mStartFrame == aFrame ||\\n+               mappedFlow->GetContentEnd() == aFrame->GetContentOffset(),\\n+               \\\"Overlapping or discontiguous frames => BAD\\\");\\n+  mappedFlow->mEndFrame = static_cast<nsTextFrame*>(aFrame->GetNextContinuation());\\n+  if (mCurrentFramesAllSameTextRun != aFrame->GetTextRun()) {\\n+    mCurrentFramesAllSameTextRun = nsnull;\\n+  }\\n+\\n   if (mStartOfLine) {\\n     mLineBreakBeforeFrames.AppendElement(aFrame);\\n     mStartOfLine = PR_FALSE;\\n@@ -1344,7 +1374,8 @@ void BuildTextRunsScanner::ScanFrame(nsIFrame* aFrame)\\n   // First check if we can extend the current mapped frame block. This is common.\\n   if (mMappedFlows.Length() > 0) {\\n     MappedFlow* mappedFlow = &mMappedFlows[mMappedFlows.Length() - 1];\\n-    if (mappedFlow->mEndFrame == aFrame) {\\n+    if (mappedFlow->mEndFrame == aFrame &&\\n+        (aFrame->GetStateBits() & NS_FRAME_IS_FLUID_CONTINUATION)) {\\n       NS_ASSERTION(aFrame->GetType() == nsGkAtoms::textFrame,\\n                    \\\"Flow-sibling of a text frame is not a text frame?\\\");\\n \\n@@ -1353,15 +1384,7 @@ void BuildTextRunsScanner::ScanFrame(nsIFrame* aFrame)\\n       // This is almost always true:\\n       if (mLastFrame->GetStyleContext() == aFrame->GetStyleContext() &&\\n           !HasTerminalNewline(mLastFrame)) {\\n-        nsTextFrame* frame = static_cast<nsTextFrame*>(aFrame);\\n-        mappedFlow->mEndFrame = static_cast<nsTextFrame*>(frame->GetNextInFlow());\\n-        NS_ASSERTION(mappedFlow->mContentEndOffset == frame->GetContentOffset(),\\n-                     \\\"Overlapping or discontiguous frames => BAD\\\");\\n-        mappedFlow->mContentEndOffset = frame->GetContentEnd();\\n-        if (mCurrentFramesAllSameTextRun != frame->GetTextRun()) {\\n-          mCurrentFramesAllSameTextRun = nsnull;\\n-        }\\n-        AccumulateRunInfo(frame);\\n+        AccumulateRunInfo(static_cast<nsTextFrame*>(aFrame));\\n         return;\\n       }\\n     }\\n@@ -1371,8 +1394,15 @@ void BuildTextRunsScanner::ScanFrame(nsIFrame* aFrame)\\n   if (aFrame->GetType() == nsGkAtoms::textFrame) {\\n     nsTextFrame* frame = static_cast<nsTextFrame*>(aFrame);\\n \\n-    if (mLastFrame && !ContinueTextRunAcrossFrames(mLastFrame, frame)) {\\n-      FlushFrames(PR_FALSE);\\n+    if (mLastFrame) {\\n+      if (!ContinueTextRunAcrossFrames(mLastFrame, frame)) {\\n+        FlushFrames(PR_FALSE);\\n+      } else {\\n+        if (mLastFrame->GetContent() == frame->GetContent()) {\\n+          AccumulateRunInfo(frame);\\n+          return;\\n+        }\\n+      }\\n     }\\n \\n     MappedFlow* mappedFlow = mMappedFlows.AppendElement();\\n@@ -1380,22 +1410,14 @@ void BuildTextRunsScanner::ScanFrame(nsIFrame* aFrame)\\n       return;\\n \\n     mappedFlow->mStartFrame = frame;\\n-    mappedFlow->mEndFrame = static_cast<nsTextFrame*>(frame->GetNextInFlow());\\n     mappedFlow->mAncestorControllingInitialBreak = mCommonAncestorWithLastFrame;\\n-    mappedFlow->mContentOffset = frame->GetContentOffset();\\n-    mappedFlow->mContentEndOffset = frame->GetContentEnd();\\n     // This is temporary: it's overwritten in BuildTextRunForFrames\\n     mappedFlow->mTransformedTextOffset = 0;\\n-    mLastFrame = frame;\\n \\n     AccumulateRunInfo(frame);\\n     if (mMappedFlows.Length() == 1) {\\n       mCurrentFramesAllSameTextRun = frame->GetTextRun();\\n       mCurrentRunTrimLeadingWhitespace = mTrimNextRunLeadingWhitespace;\\n-    } else {\\n-      if (mCurrentFramesAllSameTextRun != frame->GetTextRun()) {\\n-        mCurrentFramesAllSameTextRun = nsnull;\\n-      }\\n     }\\n     return;\\n   }\\n@@ -1536,17 +1558,17 @@ BuildTextRunsScanner::BuildTextRunForFrames(void* aTextBuffer)\\n   // If the situation is particularly simple (and common) we don't need to\\n   // allocate userData.\\n   if (mMappedFlows.Length() == 1 && !mMappedFlows[0].mEndFrame &&\\n-      !mMappedFlows[0].mContentOffset) {\\n+      mMappedFlows[0].mStartFrame->GetContentOffset() == 0) {\\n     userData = &dummyData;\\n     dummyData.mMappedFlows = &dummyMappedFlow;\\n   } else {\\n     userData = static_cast<TextRunUserData*>\\n-                          (nsMemory::Alloc(sizeof(TextRunUserData) + mMappedFlows.Length()*sizeof(TextRunMappedFlow)));\\n+      (nsMemory::Alloc(sizeof(TextRunUserData) + mMappedFlows.Length()*sizeof(TextRunMappedFlow)));\\n     userData->mMappedFlows = reinterpret_cast<TextRunMappedFlow*>(userData + 1);\\n   }\\n+  userData->mMappedFlowCount = mMappedFlows.Length();\\n   userData->mLastFlowIndex = 0;\\n \\n-  PRUint32 finalMappedFlowCount = 0;\\n   PRUint32 currentTransformedTextOffset = 0;\\n \\n   PRUint32 nextBreakIndex = 0;\\n@@ -1582,29 +1604,20 @@ BuildTextRunsScanner::BuildTextRunForFrames(void* aTextBuffer)\\n     // Figure out what content is included in this flow.\\n     nsIContent* content = f->GetContent();\\n     const nsTextFragment* frag = content->GetText();\\n-    PRInt32 contentStart = mappedFlow->mContentOffset;\\n-    PRInt32 contentEnd = mappedFlow->mContentEndOffset;\\n+    PRInt32 contentStart = mappedFlow->mStartFrame->GetContentOffset();\\n+    PRInt32 contentEnd = mappedFlow->GetContentEnd();\\n     PRInt32 contentLength = contentEnd - contentStart;\\n \\n-    if (content == lastContent) {\\n-      NS_ASSERTION(endOfLastContent == contentStart,\\n-                   \\\"Gap or overlap in textframes mapping content?!\\\");\\n-      if (contentStart >= contentEnd)\\n-        continue;\\n-      userData->mMappedFlows[finalMappedFlowCount - 1].mContentLength += contentLength;\\n-    } else {\\n-      TextRunMappedFlow* newFlow = &userData->mMappedFlows[finalMappedFlowCount];\\n+    TextRunMappedFlow* newFlow = &userData->mMappedFlows[i];\\n+    newFlow->mStartFrame = mappedFlow->mStartFrame;\\n+    newFlow->mDOMOffsetToBeforeTransformOffset = builder.GetCharCount() -\\n+      mappedFlow->mStartFrame->GetContentOffset();\\n+    newFlow->mContentLength = contentLength;\\n \\n-      newFlow->mStartFrame = mappedFlow->mStartFrame;\\n-      newFlow->mDOMOffsetToBeforeTransformOffset = builder.GetCharCount() - mappedFlow->mContentOffset;\\n-      newFlow->mContentLength = contentLength;\\n-      ++finalMappedFlowCount;\\n-\\n-      while (nextBreakBeforeFrame && nextBreakBeforeFrame->GetContent() == content) {\\n-        textBreakPoints.AppendElement(\\n-            nextBreakBeforeFrame->GetContentOffset() + newFlow->mDOMOffsetToBeforeTransformOffset);\\n-        nextBreakBeforeFrame = GetNextBreakBeforeFrame(&nextBreakIndex);\\n-      }\\n+    while (nextBreakBeforeFrame && nextBreakBeforeFrame->GetContent() == content) {\\n+      textBreakPoints.AppendElement(\\n+          nextBreakBeforeFrame->GetContentOffset() + newFlow->mDOMOffsetToBeforeTransformOffset);\\n+      nextBreakBeforeFrame = GetNextBreakBeforeFrame(&nextBreakIndex);\\n     }\\n \\n     PRUint32 analysisFlags;\\n@@ -1666,12 +1679,6 @@ BuildTextRunsScanner::BuildTextRunForFrames(void* aTextBuffer)\\n     userData = nsnull;\\n     finalUserData = mMappedFlows[0].mStartFrame;\\n   } else {\\n-    userData = static_cast<TextRunUserData*>\\n-                          (nsMemory::Realloc(userData, sizeof(TextRunUserData) + finalMappedFlowCount*sizeof(TextRunMappedFlow)));\\n-    if (!userData)\\n-      return;\\n-    userData->mMappedFlows = reinterpret_cast<TextRunMappedFlow*>(userData + 1);\\n-    userData->mMappedFlowCount = finalMappedFlowCount;\\n     finalUserData = userData;\\n   }\\n \\n@@ -1862,7 +1869,7 @@ BuildTextRunsScanner::SetupBreakSinksForTextRun(gfxTextRun* aTextRun,\\n       - offset;\\n \\n     nsTextFrame* startFrame = mappedFlow->mStartFrame;\\n-    if (HasCompressedLeadingWhitespace(startFrame, mappedFlow->mContentEndOffset, iter)) {\\n+    if (HasCompressedLeadingWhitespace(startFrame, mappedFlow->GetContentEnd(), iter)) {\\n       mLineBreaker.AppendInvisibleWhitespace();\\n     }\\n \\n@@ -1902,7 +1909,8 @@ BuildTextRunsScanner::SetupBreakSinksForTextRun(gfxTextRun* aTextRun,\\n       }\\n     }\\n     \\n-    iter.AdvanceOriginal(mappedFlow->mContentEndOffset - mappedFlow->mContentOffset);\\n+    iter.AdvanceOriginal(mappedFlow->GetContentEnd() -\\n+            mappedFlow->mStartFrame->GetContentOffset());\\n   }\\n }\\n \\n@@ -1917,7 +1925,7 @@ BuildTextRunsScanner::AssignTextRun(gfxTextRun* aTextRun)\\n     nsTextFrame* endFrame = mappedFlow->mEndFrame;\\n     nsTextFrame* f;\\n     for (f = startFrame; f != endFrame;\\n-         f = static_cast<nsTextFrame*>(f->GetNextInFlow())) {\\n+         f = static_cast<nsTextFrame*>(f->GetNextContinuation())) {\\n #ifdef DEBUG_roc\\n       if (f->GetTextRun()) {\\n         gfxTextRun* textRun = f->GetTextRun();\\n\""}