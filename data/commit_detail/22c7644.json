{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas22c7644\""},"diff":"\"22c7644 Really fix the right-most column of trees b=306990 r=Enn sr+a=roc\\ndiff --git a/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp b/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp\\nindex 50cbcfb..3a157a4 100644\\n--- a/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp\\n+++ b/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp\\n@@ -149,6 +149,7 @@ nsTreeBodyFrame::nsTreeBodyFrame(nsIPresShell* aPresShell, nsStyleContext* aCont\\n  mTopRowIndex(0), \\n  mHorzPosition(0),\\n  mHorzWidth(0),\\n+ mAdjustWidth(0),\\n  mRowHeight(0),\\n  mIndentation(0),\\n  mStringWidth(-1),\\n@@ -773,6 +774,7 @@ FindScrollParts(nsIFrame* aCurrFrame, nsTreeBodyFrame::ScrollParts* aResult)\\n     nsIScrollableFrame* f;\\n     CallQueryInterface(aCurrFrame, &f);\\n     if (f) {\\n+      aResult->mColumnsFrame = aCurrFrame;\\n       aResult->mColumnsScrollableView = f->GetScrollableView();\\n     }\\n   }\\n@@ -805,7 +807,7 @@ FindScrollParts(nsIFrame* aCurrFrame, nsTreeBodyFrame::ScrollParts* aResult)\\n nsTreeBodyFrame::ScrollParts nsTreeBodyFrame::GetScrollParts()\\n {\\n   nsPresContext* presContext = PresContext();\\n-  ScrollParts result = { nsnull, nsnull, nsnull, nsnull, nsnull };\\n+  ScrollParts result = { nsnull, nsnull, nsnull, nsnull, nsnull, nsnull };\\n   nsIContent* baseElement = GetBaseElement();\\n   nsIFrame* treeFrame =\\n     baseElement ? presContext->PresShell()->GetPrimaryFrameFor(baseElement) : nsnull;\\n@@ -865,8 +867,8 @@ nsTreeBodyFrame::CheckOverflow(const ScrollParts& aParts)\\n     verticalOverflowChanged = PR_TRUE;\\n   }\\n \\n-  if (aParts.mColumnsScrollableView) {\\n-    nsRect bounds = aParts.mColumnsScrollableView->View()->GetBounds();\\n+  if (aParts.mColumnsFrame) {\\n+    nsRect bounds = aParts.mColumnsFrame->GetRect();\\n     if (bounds.width != 0) {\\n       /* Ignore overflows that are less than half a pixel. Yes these happen\\n          all over the place when flex boxes are compressed real small. \\n@@ -929,9 +931,9 @@ nsTreeBodyFrame::InvalidateScrollbars(const ScrollParts& aParts)\\n     ENSURE_TRUE(weakFrame.IsAlive());\\n   }\\n \\n-  if (aParts.mHScrollbar && aParts.mColumnsScrollableView) {\\n+  if (aParts.mHScrollbar && aParts.mColumnsFrame) {\\n     // And now Horizontal scrollbar\\n-    nsRect bounds = aParts.mColumnsScrollableView->View()->GetBounds();\\n+    nsRect bounds = aParts.mColumnsFrame->GetRect();\\n     nsAutoString maxposStr;\\n \\n     maxposStr.AppendInt(mHorzWidth > bounds.width ? mHorzWidth - bounds.width : 0);\\n@@ -2438,12 +2440,15 @@ nsTreeBodyFrame::CalcHorzWidth(const ScrollParts& aParts)\\n   }\\n \\n   // If no horz scrolling periphery is present, then just\\n-  // return the width of the main box\\n+  // return the width of the columns\\n   if (width == 0) {\\n-    CalcInnerBox();\\n-    width = mInnerBox.width;\\n+    width = aParts.mColumnsFrame->GetRect().width;\\n   }\\n \\n+  // Compute the adjustment to the last column. This varies depending on the\\n+  // visibility of the columnpicker and the scrollbar.\\n+  mAdjustWidth = mRect.width - aParts.mColumnsFrame->GetRect().width;\\n+\\n   return width;\\n }\\n \\n@@ -3768,6 +3773,9 @@ NS_IMETHODIMP nsTreeBodyFrame::EnsureCellIsVisible(PRInt32 aRow, nsITreeColumn*\\n   rv = col->GetWidthInTwips(this, &columnWidth);\\n   if(NS_FAILED(rv)) return rv;\\n \\n+  if (!col->GetNext())\\n+    columnWidth -= mAdjustWidth; // this is one case we don't want to adjust\\n+\\n   // If the start of the column is before the\\n   // start of the horizontal view, then scroll\\n   if (columnPos < mHorzPosition)\\n@@ -3950,7 +3958,7 @@ nsTreeBodyFrame::ScrollHorzInternal(const ScrollParts& aParts, PRInt32 aPosition\\n   if (aPosition < 0 || aPosition > mHorzWidth)\\n     return NS_OK;\\n \\n-  nsRect bounds = aParts.mColumnsScrollableView->View()->GetBounds();\\n+  nsRect bounds = aParts.mColumnsFrame->GetRect();\\n   if (aPosition > (mHorzWidth - bounds.width)) \\n     aPosition = mHorzWidth - bounds.width;\\n \\ndiff --git a/layout/xul/base/src/tree/src/nsTreeBodyFrame.h b/layout/xul/base/src/tree/src/nsTreeBodyFrame.h\\nindex fdbcbf8..b8e4ae2 100644\\n--- a/layout/xul/base/src/tree/src/nsTreeBodyFrame.h\\n+++ b/layout/xul/base/src/tree/src/nsTreeBodyFrame.h\\n@@ -123,12 +123,14 @@ public:\\n   NS_IMETHOD DidSetStyleContext();\\n \\n   friend nsIFrame* NS_NewTreeBodyFrame(nsIPresShell* aPresShell);\\n+  friend class nsTreeColumn;\\n \\n   struct ScrollParts {\\n     nsIScrollbarFrame* mVScrollbar;\\n     nsIContent*        mVScrollbarContent;\\n     nsIScrollbarFrame* mHScrollbar;\\n     nsIContent*        mHScrollbarContent;\\n+    nsIFrame*          mColumnsFrame;\\n     nsIScrollableView* mColumnsScrollableView;\\n   };\\n \\n@@ -444,6 +446,9 @@ protected: // Data Members\\n   // Our desired horizontal width (the width for which we actually have tree\\n   // columns).\\n   nscoord mHorzWidth;\\n+  // The amount by which to adjust the width of the last cell.\\n+  // This depends on whether or not the columnpicker and scrollbars are present.\\n+  nscoord mAdjustWidth;\\n \\n   // Cached heights and indent info.\\n   nsRect mInnerBox;\\ndiff --git a/layout/xul/base/src/tree/src/nsTreeColumns.cpp b/layout/xul/base/src/tree/src/nsTreeColumns.cpp\\nindex 04ef3fd..fd9a9e79 100644\\n--- a/layout/xul/base/src/tree/src/nsTreeColumns.cpp\\n+++ b/layout/xul/base/src/tree/src/nsTreeColumns.cpp\\n@@ -48,8 +48,7 @@\\n #include \\\"nsIDOMClassInfo.h\\\"\\n #include \\\"nsINodeInfo.h\\\"\\n #include \\\"nsContentUtils.h\\\"\\n-\\n-static NS_DEFINE_CID(kTreeColumnImplCID, NS_TREECOLUMN_IMPL_CID);\\n+#include \\\"nsTreeBodyFrame.h\\\"\\n \\n // Column class that caches all the info about our column.\\n nsTreeColumn::nsTreeColumn(nsTreeColumns* aColumns, nsIContent* aContent)\\n@@ -88,7 +87,7 @@ NS_IMPL_ADDREF(nsTreeColumn)\\n NS_IMPL_RELEASE(nsTreeColumn)\\n \\n nsIFrame*\\n-nsTreeColumn::GetFrame(nsIFrame* aBodyFrame)\\n+nsTreeColumn::GetFrame(nsTreeBodyFrame* aBodyFrame)\\n {\\n   NS_PRECONDITION(aBodyFrame, \\\"null frame?\\\");\\n \\n@@ -114,7 +113,7 @@ nsTreeColumn::GetFrame()\\n }\\n \\n nsresult\\n-nsTreeColumn::GetRect(nsIFrame* aBodyFrame, nscoord aY, nscoord aHeight, nsRect* aResult)\\n+nsTreeColumn::GetRect(nsTreeBodyFrame* aBodyFrame, nscoord aY, nscoord aHeight, nsRect* aResult)\\n {\\n   nsIFrame* frame = GetFrame(aBodyFrame);\\n   if (!frame) {\\n@@ -125,11 +124,13 @@ nsTreeColumn::GetRect(nsIFrame* aBodyFrame, nscoord aY, nscoord aHeight, nsRect*\\n   *aResult = frame->GetRect();\\n   aResult->y = aY;\\n   aResult->height = aHeight;\\n+  if (!GetNext())\\n+    aResult->width += aBodyFrame->mAdjustWidth;\\n   return NS_OK;\\n }\\n \\n nsresult\\n-nsTreeColumn::GetXInTwips(nsIFrame* aBodyFrame, nscoord* aResult)\\n+nsTreeColumn::GetXInTwips(nsTreeBodyFrame* aBodyFrame, nscoord* aResult)\\n {\\n   nsIFrame* frame = GetFrame(aBodyFrame);\\n   if (!frame) {\\n@@ -141,7 +142,7 @@ nsTreeColumn::GetXInTwips(nsIFrame* aBodyFrame, nscoord* aResult)\\n }\\n \\n nsresult\\n-nsTreeColumn::GetWidthInTwips(nsIFrame* aBodyFrame, nscoord* aResult)\\n+nsTreeColumn::GetWidthInTwips(nsTreeBodyFrame* aBodyFrame, nscoord* aResult)\\n {\\n   nsIFrame* frame = GetFrame(aBodyFrame);\\n   if (!frame) {\\n@@ -149,6 +150,8 @@ nsTreeColumn::GetWidthInTwips(nsIFrame* aBodyFrame, nscoord* aResult)\\n     return NS_ERROR_FAILURE;\\n   }\\n   *aResult = frame->GetRect().width;\\n+  if (!GetNext())\\n+    *aResult += aBodyFrame->mAdjustWidth;\\n   return NS_OK;\\n }\\n \\ndiff --git a/layout/xul/base/src/tree/src/nsTreeColumns.h b/layout/xul/base/src/tree/src/nsTreeColumns.h\\nindex a7e649b..3148430 100644\\n--- a/layout/xul/base/src/tree/src/nsTreeColumns.h\\n+++ b/layout/xul/base/src/tree/src/nsTreeColumns.h\\n@@ -62,17 +62,17 @@ public:\\n \\n protected:\\n   nsIFrame* GetFrame();\\n-  nsIFrame* GetFrame(nsIFrame* aBodyFrame);\\n+  nsIFrame* GetFrame(nsTreeBodyFrame* aBodyFrame);\\n \\n   /**\\n    * Returns a rect with x and width taken from the frame's rect and specified\\n    * y and height. May fail in case there's no frame for the column.\\n    */\\n-  nsresult GetRect(nsIFrame* aBodyFrame, nscoord aY, nscoord aHeight,\\n+  nsresult GetRect(nsTreeBodyFrame* aBodyFrame, nscoord aY, nscoord aHeight,\\n                    nsRect* aResult);\\n \\n-  nsresult GetXInTwips(nsIFrame* aBodyFrame, nscoord* aResult);\\n-  nsresult GetWidthInTwips(nsIFrame* aBodyFrame, nscoord* aResult);\\n+  nsresult GetXInTwips(nsTreeBodyFrame* aBodyFrame, nscoord* aResult);\\n+  nsresult GetWidthInTwips(nsTreeBodyFrame* aBodyFrame, nscoord* aResult);\\n \\n   void SetColumns(nsTreeColumns* aColumns) { mColumns = aColumns; }\\n \\n\""}