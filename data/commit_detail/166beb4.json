{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas166beb4\""},"diff":"\"166beb4 bug 387273. Incorrect starting offset exposed when selection spans multiple objects. r=surkov, r=david.bolter, a=dsicore\\ndiff --git a/accessible/src/html/nsHyperTextAccessible.cpp b/accessible/src/html/nsHyperTextAccessible.cpp\\nindex e2fb613..9d939a9 100644\\n--- a/accessible/src/html/nsHyperTextAccessible.cpp\\n+++ b/accessible/src/html/nsHyperTextAccessible.cpp\\n@@ -58,6 +58,7 @@\\n #include \\\"nsIFrame.h\\\"\\n #include \\\"nsIInterfaceRequestorUtils.h\\\"\\n #include \\\"nsIPlaintextEditor.h\\\"\\n+#include \\\"nsISelection2.h\\\"\\n #include \\\"nsIServiceManager.h\\\"\\n #include \\\"nsTextFragment.h\\\"\\n #include \\\"gfxSkipChars.h\\\"\\n@@ -105,7 +106,12 @@ nsresult nsHyperTextAccessible::QueryInterface(REFNSIID aIID, void** aInstancePt\\n     if (aIID.Equals(NS_GET_IID(nsIAccessibleHyperText))) {\\n       if (role == nsIAccessibleRole::ROLE_ENTRY ||\\n           role == nsIAccessibleRole::ROLE_PASSWORD_TEXT) {\\n-        return NS_ERROR_NO_INTERFACE;\\n+        nsCOMPtr<nsIEditor> editor;\\n+        GetAssociatedEditor(getter_AddRefs(editor));\\n+        nsCOMPtr<nsIPlaintextEditor> peditor(do_QueryInterface(editor));\\n+        if (peditor) {\\n+          return NS_ERROR_NO_INTERFACE; // No embedded objects ever in plain text\\n+        }\\n       }\\n       *aInstancePtr = static_cast<nsIAccessibleHyperText*>(this);\\n       NS_ADDREF_THIS();\\n@@ -533,7 +539,8 @@ NS_IMETHODIMP nsHyperTextAccessible::GetCharacterAtOffset(PRInt32 aOffset, PRUni\\n \\n nsresult nsHyperTextAccessible::DOMPointToHypertextOffset(nsIDOMNode* aNode, PRInt32 aNodeOffset,\\n                                                           PRInt32* aHyperTextOffset,\\n-                                                          nsIAccessible **aFinalAccessible)\\n+                                                          nsIAccessible **aFinalAccessible,\\n+                                                          PRBool aIsEndOffset)\\n {\\n   // Turn a DOM Node and offset into an offset into this hypertext.\\n   // On failure, return null. On success, return the DOM node which contains the offset.\\n@@ -609,10 +616,19 @@ nsresult nsHyperTextAccessible::DOMPointToHypertextOffset(nsIDOMNode* aNode, PRI\\n     // <div>abc<h1>def</h1>ghi</div>\\n     // If the passed-in DOM point was not on a direct child of the hypertext, we will\\n     // return the offset for that entire hypertext\\n-    // If the offset was after the first character of the passed in object, we will now use 1 for\\n+    if (aIsEndOffset) {\\n+      // Not inclusive, the indicated char comes at index before this offset\\n+      // If the end offset is after the first character of the passed in object, use 1 for\\n     // addTextOffset, to put us after the embedded object char. We'll only treat the offset as\\n     // before the embedded object char if we end at the very beginning of the child.\\n     addTextOffset = addTextOffset > 0;\\n+    }\\n+    else {\\n+      // Start offset, inclusive\\n+      // Make sure the offset lands on the embedded object character in order to indicate\\n+      // the true inner offset is inside the subtree for that link\\n+      addTextOffset = (TextLength(descendantAccessible) == addTextOffset) ? 1 : 0;\\n+    }\\n     descendantAccessible = parentAccessible;\\n   }  \\n \\n@@ -699,7 +715,9 @@ nsHyperTextAccessible::GetRelativeOffset(nsIPresShell *aPresShell,\\n   NS_ENSURE_TRUE(resultNode, -1);\\n \\n   nsCOMPtr<nsIAccessible> finalAccessible;\\n-  rv = DOMPointToHypertextOffset(resultNode, pos.mContentOffset, &hyperTextOffset, getter_AddRefs(finalAccessible));\\n+  rv = DOMPointToHypertextOffset(resultNode, pos.mContentOffset, &hyperTextOffset,\\n+                                 getter_AddRefs(finalAccessible),\\n+                                 aDirection == eDirNext);\\n   // If finalAccessible == nsnull, then DOMPointToHypertextOffset() searched through the hypertext\\n   // children without finding the node/offset position\\n   NS_ENSURE_SUCCESS(rv, -1);\\n@@ -1371,49 +1389,89 @@ NS_IMETHODIMP nsHyperTextAccessible::GetCaretOffset(PRInt32 *aCaretOffset)\\n   return DOMPointToHypertextOffset(caretNode, caretOffset, aCaretOffset);\\n }\\n \\n-nsresult nsHyperTextAccessible::GetSelections(nsISelectionController **aSelCon, nsISelection **aDomSel)\\n+nsresult nsHyperTextAccessible::GetSelections(nsISelectionController **aSelCon,\\n+                                              nsISelection **aDomSel,\\n+                                              nsCOMArray<nsIDOMRange>* aRanges)\\n {\\n+  if (!mDOMNode) {\\n+    return NS_ERROR_FAILURE;\\n+  }\\n   if (aSelCon) {\\n     *aSelCon = nsnull;\\n   }\\n   if (aDomSel) {\\n     *aDomSel = nsnull;\\n   }\\n+  if (aRanges) {\\n+    aRanges->Clear();\\n+  }\\n   \\n+  nsCOMPtr<nsISelection> domSel;\\n+  nsCOMPtr<nsISelectionController> selCon;\\n+\\n   nsCOMPtr<nsIEditor> editor;\\n   GetAssociatedEditor(getter_AddRefs(editor));\\n-  if (editor) {\\n+  nsCOMPtr<nsIPlaintextEditor> peditor(do_QueryInterface(editor));\\n+  if (peditor) {\\n+    // Case 1: plain text editor\\n+    // This is for form controls which have their own\\n+    // selection controller separate from the document, for example\\n+    // HTML:input, HTML:textarea, XUL:textbox, etc.\\n     if (aSelCon) {\\n-      editor->GetSelectionController(aSelCon);\\n+      editor->GetSelectionController(getter_AddRefs(selCon));\\n       NS_ENSURE_TRUE(*aSelCon, NS_ERROR_FAILURE);\\n     }\\n \\n-    if (aDomSel) {\\n-      editor->GetSelection(aDomSel);\\n-      NS_ENSURE_TRUE(*aDomSel, NS_ERROR_FAILURE);\\n+    editor->GetSelection(getter_AddRefs(domSel));\\n+    NS_ENSURE_TRUE(domSel, NS_ERROR_FAILURE);\\n     }\\n+  else {\\n+    // Case 2: rich content subtree (can be rich editor)\\n+    // This uses the selection controller from the entire document\\n+    nsIFrame *frame = GetFrame();\\n+    NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);\\n \\n-    return NS_OK;\\n+    // Get the selection and selection controller\\n+    frame->GetSelectionController(GetPresContext(),\\n+                                  getter_AddRefs(selCon));\\n+    NS_ENSURE_TRUE(selCon, NS_ERROR_FAILURE);\\n+    selCon->GetSelection(nsISelectionController::SELECTION_NORMAL,\\n+                         getter_AddRefs(domSel));\\n+    NS_ENSURE_TRUE(domSel, NS_ERROR_FAILURE);\\n   }\\n \\n-  nsIFrame *frame = GetFrame();\\n-  NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);\\n-\\n-  // Get the selection and selection controller\\n-  nsCOMPtr<nsISelectionController> selCon;\\n-  frame->GetSelectionController(GetPresContext(),\\n-                                getter_AddRefs(selCon));\\n-  NS_ENSURE_TRUE(selCon, NS_ERROR_FAILURE);\\n   if (aSelCon) {\\n     NS_ADDREF(*aSelCon = selCon);\\n   }\\n-\\n   if (aDomSel) {\\n-    nsCOMPtr<nsISelection> domSel;\\n-    selCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(domSel));\\n-    NS_ENSURE_TRUE(domSel, NS_ERROR_FAILURE);\\n     NS_ADDREF(*aDomSel = domSel);\\n   }\\n+  if (aRanges) {\\n+    nsCOMPtr<nsISelection2> selection2(do_QueryInterface(domSel));\\n+    NS_ENSURE_TRUE(selection2, NS_ERROR_FAILURE);\\n+\\n+    nsCOMPtr<nsIDOMNodeList> childNodes;\\n+    nsresult rv = mDOMNode->GetChildNodes(getter_AddRefs(childNodes));\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    PRUint32 numChildren; \\n+    rv = childNodes->GetLength(&numChildren);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    rv = selection2->GetRangesForIntervalCOMArray(mDOMNode, 0,\\n+                                                  mDOMNode, numChildren,\\n+                                                  PR_TRUE, aRanges);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    // Remove collapsed ranges\\n+    PRInt32 numRanges = aRanges->Count();\\n+    for (PRInt32 count = 0; count < numRanges; count ++) {\\n+      PRBool isCollapsed;\\n+      (*aRanges)[count]->GetCollapsed(&isCollapsed);\\n+      if (isCollapsed) {\\n+        aRanges->RemoveObjectAt(count);\\n+        -- numRanges;\\n+        -- count;\\n+      }\\n+    }\\n+  }\\n \\n   return NS_OK;\\n }\\n@@ -1424,18 +1482,13 @@ nsresult nsHyperTextAccessible::GetSelections(nsISelectionController **aSelCon,\\n NS_IMETHODIMP nsHyperTextAccessible::GetSelectionCount(PRInt32 *aSelectionCount)\\n {\\n   nsCOMPtr<nsISelection> domSel;\\n-  nsresult rv = GetSelections(nsnull, getter_AddRefs(domSel));\\n+  nsCOMArray<nsIDOMRange> ranges;\\n+  nsresult rv = GetSelections(nsnull, nsnull, &ranges);\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n-  PRBool isSelectionCollapsed;\\n-  rv = domSel->GetIsCollapsed(&isSelectionCollapsed);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n+  *aSelectionCount = ranges.Count();\\n \\n-  if (isSelectionCollapsed) {\\n-    *aSelectionCount = 0;\\n-    return NS_OK;\\n-  }\\n-  return domSel->GetRangeCount(aSelectionCount);\\n+  return NS_OK;\\n }\\n \\n /*\\n@@ -1446,35 +1499,49 @@ NS_IMETHODIMP nsHyperTextAccessible::GetSelectionBounds(PRInt32 aSelectionNum, P\\n   *aStartOffset = *aEndOffset = 0;\\n \\n   nsCOMPtr<nsISelection> domSel;\\n-  nsresult rv = GetSelections(nsnull, getter_AddRefs(domSel));\\n+  nsCOMArray<nsIDOMRange> ranges;\\n+  nsresult rv = GetSelections(nsnull, getter_AddRefs(domSel), &ranges);\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n-  PRInt32 rangeCount;\\n-  domSel->GetRangeCount(&rangeCount);\\n+  PRInt32 rangeCount = ranges.Count();\\n   if (aSelectionNum < 0 || aSelectionNum >= rangeCount)\\n     return NS_ERROR_INVALID_ARG;\\n \\n-  nsCOMPtr<nsIDOMRange> range;\\n-  rv = domSel->GetRangeAt(aSelectionNum, getter_AddRefs(range));\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n+  nsCOMPtr<nsIDOMRange> range = ranges[aSelectionNum];\\n \\n+  // Get start point\\n   nsCOMPtr<nsIDOMNode> startNode;\\n   range->GetStartContainer(getter_AddRefs(startNode));\\n   PRInt32 startOffset;\\n   range->GetStartOffset(&startOffset);\\n-  rv = DOMPointToHypertextOffset(startNode, startOffset, aStartOffset);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n \\n+  // Get end point\\n   nsCOMPtr<nsIDOMNode> endNode;\\n   range->GetEndContainer(getter_AddRefs(endNode));\\n   PRInt32 endOffset;\\n   range->GetEndOffset(&endOffset);\\n-  if (startNode == endNode && startOffset == endOffset) {\\n-    // Shortcut for collapsed selection case (caret)\\n-    *aEndOffset = *aStartOffset;\\n-    return NS_OK;\\n+\\n+  PRInt16 rangeCompareResult;\\n+  rv = range->CompareBoundaryPoints(nsIDOMRange::START_TO_END, range, &rangeCompareResult);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  if (rangeCompareResult < 0) {\\n+    // Make sure start is before end, by swapping offsets\\n+    // This occurs when the user selects backwards in the text\\n+    startNode.swap(endNode);\\n+    PRInt32 tempOffset = startOffset;\\n+    startOffset = endOffset;\\n+    endOffset = tempOffset;\\n+  }\\n+\\n+  nsCOMPtr<nsIAccessible> startAccessible;\\n+  rv = DOMPointToHypertextOffset(startNode, startOffset, aStartOffset, getter_AddRefs(startAccessible));\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+  if (!startAccessible) {\\n+    *aStartOffset = 0; // Could not find start point within this hypertext, so starts before\\n   }\\n-  return DOMPointToHypertextOffset(endNode, endOffset, aEndOffset);\\n+\\n+  return DOMPointToHypertextOffset(endNode, endOffset, aEndOffset, nsnull, PR_TRUE);\\n }\\n \\n /*\\ndiff --git a/accessible/src/html/nsHyperTextAccessible.h b/accessible/src/html/nsHyperTextAccessible.h\\nindex 4a7a247..8d09a34 100644\\n--- a/accessible/src/html/nsHyperTextAccessible.h\\n+++ b/accessible/src/html/nsHyperTextAccessible.h\\n@@ -110,10 +110,18 @@ public:\\n     *                                      contained the offset, if it is within\\n     *                                      the current nsHyperTextAccessible,\\n     *                                      otherwise it is set to nsnull.\\n+    * @param aIsEndOffset - if PR_TRUE, then then this offset is not inclusive. The character\\n+    *                       indicated by the offset returned is at [offset - 1]. This means\\n+    *                       if the passed-in offset is really in a descendant, then the offset returned\\n+    *                       will come just after the relevant embedded object characer.\\n+    *                       If PR_FALSE, then the offset is inclusive. The character indicated\\n+    *                       by the offset returned is at [offset]. If the passed-in offset in inside a\\n+    *                       descendant, then the returned offset will be on the relevant embedded object char.\\n     */\\n   nsresult DOMPointToHypertextOffset(nsIDOMNode* aNode, PRInt32 aNodeOffset,\\n                                      PRInt32 *aHypertextOffset,\\n-                                     nsIAccessible **aFinalAccessible = nsnull);\\n+                                     nsIAccessible **aFinalAccessible = nsnull,\\n+                                     PRBool aIsEndOffset = PR_FALSE);\\n \\n protected:\\n   /*\\n@@ -184,7 +192,16 @@ protected:\\n   nsIntRect GetBoundsForString(nsIFrame *aFrame, PRUint32 aStartRenderedOffset, PRUint32 aEndRenderedOffset);\\n \\n   // Selection helpers\\n-  nsresult GetSelections(nsISelectionController **aSelCon, nsISelection **aDomSel);\\n+\\n+  /**\\n+   * Get the relevant selection interfaces and ranges for the current hyper text\\n+   * @param aSelCon      The selection controller for the current hyper text, or nsnull if not needed\\n+   * @param aDomSel      The selection interface for the current hyper text, or nsnull if not needed\\n+   * @param aRanges      The selected ranges within the current subtree, or nsnull if not needed\\n+   */\\n+  nsresult GetSelections(nsISelectionController **aSelCon,\\n+                         nsISelection **aDomSel = nsnull,\\n+                         nsCOMArray<nsIDOMRange>* aRanges = nsnull);\\n   nsresult SetSelectionRange(PRInt32 aStartPos, PRInt32 aEndPos);\\n };\\n \\n\""}