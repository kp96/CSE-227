{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas77dadd7\""},"diff":"\"77dadd7 Bug 393657. GetARIAState() called twice when we get a state. r=surkov, a=dsicore\\ndiff --git a/accessible/src/base/nsAccessible.cpp b/accessible/src/base/nsAccessible.cpp\\nindex a645737..01c5b71 100644\\n--- a/accessible/src/base/nsAccessible.cpp\\n+++ b/accessible/src/base/nsAccessible.cpp\\n@@ -993,7 +993,7 @@ PRBool nsAccessible::IsVisible(PRBool *aIsOffscreen)\\n   return isVisible;\\n }\\n \\n-NS_IMETHODIMP\\n+nsresult\\n nsAccessible::GetState(PRUint32 *aState, PRUint32 *aExtraState)\\n {\\n   *aState = 0;\\n@@ -1051,45 +1051,6 @@ nsAccessible::GetState(PRUint32 *aState, PRUint32 *aExtraState)\\n     *aState |= nsIAccessibleStates::STATE_OFFSCREEN;\\n   }\\n \\n-  if (!aExtraState)\\n-    return NS_OK;\\n-\\n-  PRUint32 state = *aState;\\n-  nsresult rv = GetARIAState(&state);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  nsIFrame *frame = GetFrame();\\n-  if (frame) {\\n-    const nsStyleDisplay* display = frame->GetStyleDisplay();\\n-    if (display && display->mOpacity == 1.0f &&\\n-        !(state & nsIAccessibleStates::STATE_INVISIBLE)) {\\n-      *aExtraState |= nsIAccessibleStates::EXT_STATE_OPAQUE;\\n-    }\\n-\\n-    const nsStyleXUL *xulStyle = frame->GetStyleXUL();\\n-    if (xulStyle) {\\n-      // In XUL all boxes are either vertical or horizontal\\n-      if (xulStyle->mBoxOrient == NS_STYLE_BOX_ORIENT_VERTICAL) {\\n-        *aExtraState |= nsIAccessibleStates::EXT_STATE_VERTICAL;\\n-      }\\n-      else {\\n-        *aExtraState |= nsIAccessibleStates::EXT_STATE_HORIZONTAL;\\n-      }\\n-    }\\n-  }\\n-\\n-  // XXX We can remove this hack once we support RDF-based role & state maps\\n-  if (mRoleMapEntry && (mRoleMapEntry->role == nsIAccessibleRole::ROLE_ENTRY ||\\n-      mRoleMapEntry->role == nsIAccessibleRole::ROLE_PASSWORD_TEXT)) {\\n-    if (content->AttrValueIs(kNameSpaceID_WAIProperties , nsAccessibilityAtoms::multiline,\\n-                             nsAccessibilityAtoms::_true, eCaseMatters)) {\\n-      *aExtraState |= nsIAccessibleStates::EXT_STATE_MULTI_LINE;\\n-    }\\n-    else {\\n-      *aExtraState |= nsIAccessibleStates::EXT_STATE_SINGLE_LINE;\\n-    }\\n-  }\\n-\\n   return NS_OK;\\n }\\n \\n@@ -2048,7 +2009,7 @@ NS_IMETHODIMP nsAccessible::GetFinalRole(PRUint32 *aRole)\\n     if (*aRole == nsIAccessibleRole::ROLE_ENTRY) {\\n       nsCOMPtr<nsIContent> content = do_QueryInterface(mDOMNode);\\n       if (content && \\n-          content->AttrValueIs(kNameSpaceID_WAIProperties , nsAccessibilityAtoms::secret,\\n+          content->AttrValueIs(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::secret,\\n                                nsAccessibilityAtoms::_true, eCaseMatters)) {\\n         // For entry field with aaa:secret=\\\"true\\\"\\n         *aRole = nsIAccessibleRole::ROLE_PASSWORD_TEXT;\\n@@ -2306,6 +2267,39 @@ nsAccessible::GetFinalState(PRUint32 *aState, PRUint32 *aExtraState)\\n         *aExtraState &= ~nsIAccessibleStates::STATE_COLLAPSED;\\n       } \\n     }\\n+    nsIFrame *frame = GetFrame();\\n+    if (frame) {\\n+      const nsStyleDisplay* display = frame->GetStyleDisplay();\\n+      if (display && display->mOpacity == 1.0f &&\\n+          !(*aState & nsIAccessibleStates::STATE_INVISIBLE)) {\\n+        *aExtraState |= nsIAccessibleStates::EXT_STATE_OPAQUE;\\n+      }\\n+\\n+      const nsStyleXUL *xulStyle = frame->GetStyleXUL();\\n+      if (xulStyle) {\\n+        // In XUL all boxes are either vertical or horizontal\\n+        if (xulStyle->mBoxOrient == NS_STYLE_BOX_ORIENT_VERTICAL) {\\n+          *aExtraState |= nsIAccessibleStates::EXT_STATE_VERTICAL;\\n+        }\\n+        else {\\n+          *aExtraState |= nsIAccessibleStates::EXT_STATE_HORIZONTAL;\\n+        }\\n+      }\\n+    }\\n+\\n+    // XXX We can remove this hack once we support RDF-based role & state maps\\n+    if (mRoleMapEntry && (mRoleMapEntry->role == nsIAccessibleRole::ROLE_ENTRY ||\\n+        mRoleMapEntry->role == nsIAccessibleRole::ROLE_PASSWORD_TEXT)) {\\n+      nsCOMPtr<nsIContent> content = do_QueryInterface(mDOMNode);\\n+      NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);\\n+      if (content->AttrValueIs(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::multiline,\\n+                               nsAccessibilityAtoms::_true, eCaseMatters)) {\\n+        *aExtraState |= nsIAccessibleStates::EXT_STATE_MULTI_LINE;\\n+      }\\n+      else {\\n+        *aExtraState |= nsIAccessibleStates::EXT_STATE_SINGLE_LINE;\\n+      }\\n+    }\\n   }\\n \\n   return NS_OK;\\ndiff --git a/accessible/src/base/nsAccessible.h b/accessible/src/base/nsAccessible.h\\nindex 39a10d4..3f1ba92 100644\\n--- a/accessible/src/base/nsAccessible.h\\n+++ b/accessible/src/base/nsAccessible.h\\n@@ -123,7 +123,7 @@ public:\\n    * second argument is omitted then second bit field of accessible state won't\\n    * be calculated.\\n    */\\n-  NS_IMETHOD GetState(PRUint32 *aState, PRUint32 *aExtraState);\\n+  nsresult GetState(PRUint32 *aState, PRUint32 *aExtraState);\\n \\n   /**\\n    * Returns attributes for accessible without explicitly setted ARIA\\n\""}