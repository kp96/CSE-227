{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bascc3c82a\""},"diff":"\"cc3c82a Bug 397436 - \\\"Add SVN version information support for symbolstore.py\\\". r=luser, a=bzbarsky.\\ndiff --git a/toolkit/crashreporter/tools/symbolstore.py b/toolkit/crashreporter/tools/symbolstore.py\\nindex 94bc55c..52dd1fe 100755\\n--- a/toolkit/crashreporter/tools/symbolstore.py\\n+++ b/toolkit/crashreporter/tools/symbolstore.py\\n@@ -21,6 +21,7 @@\\n #\\n # Contributor(s):\\n # Ted Mielczarek <ted.mielczarek@gmail.com>\\n+# Ben Turner <mozilla@songbirdnest.com>\\n #\\n # Alternatively, the contents of this file may be used under the terms of\\n # either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n@@ -59,39 +60,177 @@ import re\\n import shutil\\n from optparse import OptionParser\\n \\n-# Utility functions\\n+# Utility classes\\n \\n-def GetCVSRevision(file):\\n-    \\\"\\\"\\\"Given a full path to a file, look in CVS/Entries\\n-    for the CVS revision number\\\"\\\"\\\"\\n-    (path, filename) = os.path.split(file)\\n-    entries = os.path.join(path, \\\"CVS\\\", \\\"Entries\\\")\\n-    if not os.path.isfile(entries):\\n+class VCSFileInfo:\\n+    \\\"\\\"\\\" A base class for version-controlled file information. Ensures that the\\n+        following attributes are generated only once (successfully):\\n+\\n+            self.root\\n+            self.revision\\n+            self.filename\\n+\\n+        The attributes are generated by a single call to the GetRoot,\\n+        GetRevision, and GetFilename methods. Those methods are explicitly not\\n+        implemented here and must be implemented in derived classes. \\\"\\\"\\\"\\n+\\n+    def __init__(self, file):\\n+        if not file:\\n+            raise ValueError\\n+        self.file = file\\n+\\n+    def __getattr__(self, name):\\n+        \\\"\\\"\\\" __getattr__ is only called for attributes that are not set on self,\\n+            so setting self.[attr] will prevent future calls to the GetRoot,\\n+            GetRevision, and GetFilename methods. We don't set the values on\\n+            failure on the off chance that a future call might succeed. \\\"\\\"\\\"\\n+\\n+        if name == \\\"root\\\":\\n+            root = self.GetRoot()\\n+            if root:\\n+                self.root = root\\n+            return root\\n+\\n+        elif name == \\\"revision\\\":\\n+            revision = self.GetRevision()\\n+            if revision:\\n+                self.revision = revision\\n+            return revision\\n+\\n+        elif name == \\\"filename\\\":\\n+            filename = self.GetFilename()\\n+            if filename:\\n+                self.filename = filename\\n+            return filename\\n+\\n+        raise AttributeError\\n+\\n+    def GetRoot(self):\\n+        \\\"\\\"\\\" This method should return the repository root for the file or 'None'\\n+            on failure. \\\"\\\"\\\"\\n+        raise NotImplementedError\\n+\\n+    def GetRevision(self):\\n+        \\\"\\\"\\\" This method should return the revision number for the file or 'None'\\n+            on failure. \\\"\\\"\\\"\\n+        raise NotImplementedError\\n+\\n+    def GetFilename(self):\\n+        \\\"\\\"\\\" This method should return the repository-specific filename for the\\n+            file or 'None' on failure. \\\"\\\"\\\"\\n+        raise NotImplementedError\\n+\\n+class CVSFileInfo(VCSFileInfo):\\n+    \\\"\\\"\\\" A class to maintiain version information for files in a CVS repository.\\n+        Derived from VCSFileInfo. \\\"\\\"\\\"\\n+\\n+    def __init__(self, file, srcdir):\\n+        VCSFileInfo.__init__(self, file)\\n+        self.srcdir = srcdir\\n+\\n+    def GetRoot(self):\\n+        (path, filename) = os.path.split(self.file)\\n+        root = os.path.join(path, \\\"CVS\\\", \\\"Root\\\")\\n+        if not os.path.isfile(root):\\n+            return None\\n+        f = open(root, \\\"r\\\")\\n+        root_name = f.readline().strip()\\n+        f.close()\\n+        parts = root_name.split(\\\"@\\\")\\n+        if len(parts) > 1:\\n+            # we don't want the extra colon\\n+            return parts[1].replace(\\\":\\\",\\\"\\\")\\n+        print >> sys.stderr, \\\"Failed to get CVS Root for %s\\\" % filename\\n         return None\\n-    f = open(entries, \\\"r\\\")\\n-    for line in f:\\n-        parts = line.split(\\\"/\\\")\\n-        if len(parts) > 1 and parts[1] == filename:\\n-            return parts[2]\\n-    print >> sys.stderr, \\\"Failed to get CVS Revision for %s\\\" % filename\\n-    return None\\n-\\n-def GetCVSRoot(file):\\n-    \\\"\\\"\\\"Given a full path to a file, look in CVS/Root\\n-    for the CVS Root\\\"\\\"\\\"\\n-    (path, filename) = os.path.split(file)\\n-    root = os.path.join(path, \\\"CVS\\\", \\\"Root\\\")\\n-    if not os.path.isfile(root):\\n+\\n+    def GetRevision(self):\\n+        (path, filename) = os.path.split(self.file)\\n+        entries = os.path.join(path, \\\"CVS\\\", \\\"Entries\\\")\\n+        if not os.path.isfile(entries):\\n+            return None\\n+        f = open(entries, \\\"r\\\")\\n+        for line in f:\\n+            parts = line.split(\\\"/\\\")\\n+            if len(parts) > 1 and parts[1] == filename:\\n+                return parts[2]\\n+        print >> sys.stderr, \\\"Failed to get CVS Revision for %s\\\" % filename\\n         return None\\n-    f = open(root, \\\"r\\\")\\n-    root_name = f.readline().strip()\\n-    f.close()\\n-    parts = root_name.split(\\\"@\\\")\\n-    if len(parts) > 1:\\n-        # we don't want the extra colon\\n-        return parts[1].replace(\\\":\\\",\\\"\\\")\\n-    print >> sys.stderr, \\\"Failed to get CVS Root for %s\\\" % filename\\n-    return None\\n+\\n+    def GetFilename(self):\\n+        file = self.file\\n+        if self.revision and self.root:\\n+            if self.srcdir:\\n+                # strip the base path off\\n+                # but we actually want the last dir in srcdir\\n+                file = os.path.normpath(file)\\n+                # the lower() is to handle win32+vc8, where\\n+                # the source filenames come out all lowercase,\\n+                # but the srcdir can be mixed case\\n+                if file.lower().startswith(self.srcdir.lower()):\\n+                    file = file[len(self.srcdir):]\\n+                (head, tail) = os.path.split(self.srcdir)\\n+                if tail == \\\"\\\":\\n+                    tail = os.path.basename(head)\\n+                file = tail + file\\n+            return \\\"cvs:%s:%s:%s\\\" % (self.root, file, self.revision)\\n+        return file\\n+\\n+class SVNFileInfo(VCSFileInfo):\\n+    url = None\\n+    repo = None\\n+    svndata = {}\\n+\\n+    def __init__(self, file):\\n+        \\\"\\\"\\\" We only want to run subversion's info tool once so pull all the data\\n+            here. \\\"\\\"\\\"\\n+\\n+        VCSFileInfo.__init__(self, file)\\n+\\n+        if os.path.isfile(file):\\n+            _regex = re.compile(r'^(.+):\\\\s(.+)$')\\n+\\n+            command = os.popen(\\\"svn info %s\\\" % file, \\\"r\\\")\\n+            for line in command:\\n+                match = _regex.match(line.strip())\\n+                if match:\\n+                    key = match.group(1)\\n+                    if key in [\\\"Repository Root\\\", \\\"Revision\\\", \\\"URL\\\"]:\\n+                        self.svndata[key] = match.group(2)\\n+\\n+            exitStatus = command.close()\\n+            if exitStatus:\\n+              print >> sys.stderr, \\\"Failed to get SVN info for %s\\\" % file\\n+\\n+    def GetRoot(self):\\n+        key = \\\"Repository Root\\\"\\n+        if key in self.svndata:\\n+            match = re.match(r'^\\\\w+:\\\\/+(\\\\S+)', self.svndata[key])\\n+            if match:\\n+                return match.group(1)\\n+        print >> sys.stderr, \\\"Failed to get SVN Root for %s\\\" % self.file\\n+        return None\\n+\\n+    def GetRevision(self):\\n+        key = \\\"Revision\\\"\\n+        if key in self.svndata:\\n+            return self.svndata[key]\\n+        print >> sys.stderr, \\\"Failed to get SVN Revision for %s\\\" % self.file\\n+        return None\\n+\\n+    def GetFilename(self):\\n+        if self.root and self.revision:\\n+            if \\\"URL\\\" in self.svndata and \\\"Repository Root\\\" in self.svndata:\\n+                url, repo = self.svndata[\\\"URL\\\"], self.svndata[\\\"Repository Root\\\"]\\n+                file = url[len(repo) + 1:]\\n+            return \\\"svn:%s:%s:%s\\\" % (self.root, file, self.revision)\\n+        print >> sys.stderr, \\\"Failed to get SVN Filename for %s\\\" % self.file\\n+        return self.file\\n+\\n+# Utility functions\\n+\\n+# A cache of files for which VCS info has already been determined. Used to\\n+# prevent extra filesystem activity or process launching.\\n+vcsFileInfoCache = {}\\n \\n def GetVCSFilename(file, srcdir):\\n     \\\"\\\"\\\"Given a full path to a file, and the top source directory,\\n@@ -104,30 +243,24 @@ def GetVCSFilename(file, srcdir):\\n     (path, filename) = os.path.split(file)\\n     if path == '' or filename == '':\\n         return file\\n-    \\n-    cvsdir = os.path.join(path, \\\"CVS\\\")\\n-    if os.path.isdir(cvsdir):\\n-        rev = GetCVSRevision(file)\\n-        root = GetCVSRoot(file)\\n-        if rev is not None and root is not None:\\n-            if srcdir is not None:\\n-                # strip the base path off\\n-                # but we actually want the last dir in srcdir\\n-                file = os.path.normpath(file)\\n-                # the lower() is to handle win32+vc8, where\\n-                # the source filenames come out all lowercase,\\n-                # but the srcdir can be mixed case\\n-                if file.lower().startswith(srcdir.lower()):\\n-                    file = file[len(srcdir):]\\n-                (head, tail) = os.path.split(srcdir)\\n-                if tail == \\\"\\\":\\n-                    tail = os.path.basename(head)\\n-                file = tail + file\\n-            # we want forward slashes on win32 paths\\n-            file = file.replace(\\\"\\\\\\\\\\\", \\\"/\\\")\\n-            return \\\"cvs:%s:%s:%s\\\" % (root, file, rev)\\n-    file = file.replace(\\\"\\\\\\\\\\\", \\\"/\\\")\\n-    return file\\n+\\n+    fileInfo = None\\n+    if file in vcsFileInfoCache:\\n+        # Already cached this info, use it.\\n+        fileInfo = vcsFileInfoCache[file]\\n+    else:\\n+        if os.path.isdir(os.path.join(path, \\\"CVS\\\")):\\n+            fileInfo = CVSFileInfo(file, srcdir)\\n+        elif os.path.isdir(os.path.join(path, \\\".svn\\\")) or \\\\\\n+             os.path.isdir(os.path.join(path, \\\"_svn\\\")):\\n+            fileInfo = SVNFileInfo(file);\\n+        vcsFileInfoCache[file] = fileInfo\\n+\\n+    if fileInfo:\\n+        file = fileInfo.filename\\n+\\n+    # we want forward slashes on win32 paths\\n+    return file.replace(\\\"\\\\\\\\\\\", \\\"/\\\")\\n \\n def GetPlatformSpecificDumper(**kwargs):\\n     \\\"\\\"\\\"This function simply returns a instance of a subclass of Dumper\\n@@ -194,7 +327,7 @@ class Dumper:\\n             return self.ProcessFile(file_or_dir)\\n         # maybe it doesn't exist?\\n         return False\\n-    \\n+\\n     def ProcessDir(self, dir):\\n         \\\"\\\"\\\"Process all the valid files in this directory.  Valid files\\n         are determined by calling ShouldProcess.\\\"\\\"\\\"\\n@@ -206,7 +339,7 @@ class Dumper:\\n                     if not self.ProcessFile(fullpath):\\n                         result = False\\n         return result\\n-    \\n+\\n     def ProcessFile(self, file):\\n         \\\"\\\"\\\"Dump symbols from this file into a symbol file, stored\\n         in the proper directory structure in  |symbol_path|.\\\"\\\"\\\"\\n@@ -269,6 +402,8 @@ class Dumper:\\n # logic to determine what files to extract symbols from.\\n \\n class Dumper_Win32(Dumper):\\n+    fixedFilenameCaseCache = {}\\n+\\n     def ShouldProcess(self, file):\\n         \\\"\\\"\\\"This function will allow processing of pdb files that have dll\\n         or exe files with the same base name next to them.\\\"\\\"\\\"\\n@@ -277,19 +412,29 @@ class Dumper_Win32(Dumper):\\n             if os.path.isfile(path + \\\".exe\\\") or os.path.isfile(path + \\\".dll\\\"):\\n                 return True\\n         return False\\n-    \\n+\\n     def FixFilenameCase(self, file):\\n         \\\"\\\"\\\"Recent versions of Visual C++ put filenames into\\n         PDB files as all lowercase.  If the file exists\\n         on the local filesystem, fix it.\\\"\\\"\\\"\\n+\\n+        # Use a cached version if we have one.\\n+        if file in self.fixedFilenameCaseCache:\\n+            return self.fixedFilenameCaseCache[file]\\n+\\n+        result = file\\n+\\n         (path, filename) = os.path.split(file)\\n-        if not os.path.isdir(path):\\n-            return file\\n-        lc_filename = filename.lower()\\n-        for f in os.listdir(path):\\n-            if f.lower() == lc_filename:\\n-                return os.path.join(path, f)\\n-        return file\\n+        if os.path.isdir(path):\\n+            lc_filename = filename.lower()\\n+            for f in os.listdir(path):\\n+                if f.lower() == lc_filename:\\n+                    result = os.path.join(path, f)\\n+                    break\\n+\\n+        # Cache the corrected version to avoid future filesystem hits.\\n+        self.fixedFilenameCaseCache[file] = result\\n+        return result\\n \\n class Dumper_Linux(Dumper):\\n     def ShouldProcess(self, file):\\n\""}