{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas84f84a4\""},"diff":"\"84f84a4 Bug 396209 - \\\"Allow applications to specify a profile directory from application.ini\\\". r=luser, a=bsmedberg. Also fixes bugs 396486, 396199, and 386164.\\ndiff --git a/profile/dirserviceprovider/src/nsProfileLock.cpp b/profile/dirserviceprovider/src/nsProfileLock.cpp\\nindex 3b5f7b9..deb7e8b 100644\\n--- a/profile/dirserviceprovider/src/nsProfileLock.cpp\\n+++ b/profile/dirserviceprovider/src/nsProfileLock.cpp\\n@@ -561,17 +561,17 @@ nsresult nsProfileLock::Lock(nsILocalFile* aProfileDir,\\n     }\\n \\n #elif defined(XP_WIN)\\n-    nsCAutoString filePath;\\n-    rv = lockFile->GetNativePath(filePath);\\n+    nsAutoString filePath;\\n+    rv = lockFile->GetPath(filePath);\\n     if (NS_FAILED(rv))\\n         return rv;\\n-    mLockFileHandle = CreateFile(filePath.get(),\\n-                                 GENERIC_READ | GENERIC_WRITE,\\n-                                 0, // no sharing - of course\\n-                                 nsnull,\\n-                                 OPEN_ALWAYS,\\n-                                 FILE_FLAG_DELETE_ON_CLOSE,\\n-                                 nsnull);\\n+    mLockFileHandle = CreateFileW(filePath.get(),\\n+                                  GENERIC_READ | GENERIC_WRITE,\\n+                                  0, // no sharing - of course\\n+                                  nsnull,\\n+                                  OPEN_ALWAYS,\\n+                                  FILE_FLAG_DELETE_ON_CLOSE,\\n+                                  nsnull);\\n     if (mLockFileHandle == INVALID_HANDLE_VALUE) {\\n         // XXXbsmedberg: provide a profile-unlocker here!\\n         return NS_ERROR_FILE_ACCESS_DENIED;\\ndiff --git a/toolkit/crashreporter/client/crashreporter.cpp b/toolkit/crashreporter/client/crashreporter.cpp\\nindex 569795a..56953a4e 100644\\n--- a/toolkit/crashreporter/client/crashreporter.cpp\\n+++ b/toolkit/crashreporter/client/crashreporter.cpp\\n@@ -413,9 +413,22 @@ int main(int argc, char** argv)\\n       return 0;\\n     }\\n \\n-    string product = queryParameters[\\\"ProductName\\\"];\\n-    string vendor = queryParameters[\\\"Vendor\\\"];\\n-    if (!UIGetSettingsPath(vendor, product, gSettingsPath)) {\\n+    // Hopefully the settings path exists in the environment. Try that before\\n+    // asking the platform-specific code to guess.\\n+    static const char kDataDirKey[] = \\\"MOZ_CRASHREPORTER_DATA_DIRECTORY\\\";\\n+    const char *settingsPath = getenv(kDataDirKey);\\n+    if (settingsPath && *settingsPath) {\\n+      gSettingsPath = settingsPath;\\n+    }\\n+    else {\\n+      string product = queryParameters[\\\"ProductName\\\"];\\n+      string vendor = queryParameters[\\\"Vendor\\\"];\\n+      if (!UIGetSettingsPath(vendor, product, gSettingsPath)) {\\n+        gSettingsPath.clear();\\n+      }\\n+    }\\n+\\n+    if (gSettingsPath.empty() || !UIEnsurePathExists(gSettingsPath)) {\\n       UIError(gStrings[ST_ERROR_NOSETTINGSPATH]);\\n       return 0;\\n     }\\ndiff --git a/toolkit/crashreporter/client/crashreporter_linux.cpp b/toolkit/crashreporter/client/crashreporter_linux.cpp\\nindex 671cfa5c..390920b 100644\\n--- a/toolkit/crashreporter/client/crashreporter_linux.cpp\\n+++ b/toolkit/crashreporter/client/crashreporter_linux.cpp\\n@@ -296,7 +296,7 @@ static void TryInitGnome()\\n   gnomeuiLib = dlopen(\\\"libgnomeui-2.so.0\\\", RTLD_LAZY);\\n   if (!gnomeuiLib)\\n     return;\\n- \\n+\\n   _gnome_program_init_fn gnome_program_init =\\n     (_gnome_program_init_fn)(dlsym(gnomeLib, \\\"gnome_program_init\\\"));\\n   _libgnomeui_module_info_get_fn libgnomeui_module_info_get =\\n@@ -495,7 +495,7 @@ bool UIGetSettingsPath(const string& vendor,\\n                        string& settingsPath)\\n {\\n   char* home = getenv(\\\"HOME\\\");\\n-  \\n+\\n   if (!home)\\n     return false;\\n \\n@@ -504,14 +504,14 @@ bool UIGetSettingsPath(const string& vendor,\\n   if (!vendor.empty()) {\\n     string lc_vendor;\\n     std::transform(vendor.begin(), vendor.end(), back_inserter(lc_vendor),\\n-\\t\\t   (int(*)(int)) std::tolower);\\n+                   (int(*)(int)) std::tolower);\\n     settingsPath += lc_vendor + \\\"/\\\";\\n   }\\n   string lc_product;\\n   std::transform(product.begin(), product.end(), back_inserter(lc_product),\\n-\\t\\t (int(*)(int)) std::tolower);\\n+                 (int(*)(int)) std::tolower);\\n   settingsPath += lc_product + \\\"/Crash Reports\\\";\\n-  return UIEnsurePathExists(settingsPath);\\n+  return true;\\n }\\n \\n bool UIEnsurePathExists(const string& path)\\n@@ -553,4 +553,3 @@ std::ofstream* UIOpenWrite(const string& filename)\\n {\\n   return new std::ofstream(filename.c_str(), std::ios::out);\\n }\\n-\\ndiff --git a/toolkit/crashreporter/client/crashreporter_osx.mm b/toolkit/crashreporter/client/crashreporter_osx.mm\\nindex becfb20..24c94ed 100644\\n--- a/toolkit/crashreporter/client/crashreporter_osx.mm\\n+++ b/toolkit/crashreporter/client/crashreporter_osx.mm\\n@@ -494,9 +494,6 @@ bool UIGetSettingsPath(const string& vendor,\\n \\n   settingsPath = [destPath UTF8String];\\n \\n-  if (!UIEnsurePathExists(settingsPath))\\n-    return false;\\n-\\n   return true;\\n }\\n \\ndiff --git a/toolkit/crashreporter/client/crashreporter_win.cpp b/toolkit/crashreporter/client/crashreporter_win.cpp\\nindex a92f636..5cffd66 100644\\n--- a/toolkit/crashreporter/client/crashreporter_win.cpp\\n+++ b/toolkit/crashreporter/client/crashreporter_win.cpp\\n@@ -697,9 +697,11 @@ void UIShowCrashUI(const string& dumpFile,\\n   }\\n \\n   if (gQueryParameters.find(L\\\"Vendor\\\") != gQueryParameters.end()) {\\n-    gCrashReporterKey = L\\\"Software\\\\\\\\\\\" +\\n-                        gQueryParameters[L\\\"Vendor\\\"] +\\n-                        L\\\"\\\\\\\\Crash Reporter\\\";\\n+    gCrashReporterKey = L\\\"Software\\\\\\\\\\\";\\n+    if (!gQueryParameters[L\\\"Vendor\\\"].empty()) {\\n+      gCrashReporterKey += gQueryParameters[L\\\"Vendor\\\"] + L\\\"\\\\\\\\\\\";\\n+    }\\n+    gCrashReporterKey += gQueryParameters[L\\\"Name\\\"] + L\\\"\\\\\\\\Crash Reporter\\\";\\n   }\\n \\n   gRestartArgs = restartArgs;\\n@@ -749,8 +751,6 @@ bool UIGetSettingsPath(const string& vendor,\\n     }\\n     PathAppend(path, UTF8ToWide(product).c_str());\\n     PathAppend(path, L\\\"Crash Reports\\\");\\n-    // in case it doesn't exist\\n-    CreateDirectory(path, NULL);\\n     settings_path = WideToUTF8(path);\\n     return true;\\n   }\\ndiff --git a/toolkit/crashreporter/nsExceptionHandler.cpp b/toolkit/crashreporter/nsExceptionHandler.cpp\\nindex eeab50f..2abd3d8 100755\\n--- a/toolkit/crashreporter/nsExceptionHandler.cpp\\n+++ b/toolkit/crashreporter/nsExceptionHandler.cpp\\n@@ -212,7 +212,7 @@ bool MinidumpCallback(const XP_CHAR* dump_path,\\n     }\\n #endif\\n   }\\n-  \\n+\\n #if defined(XP_WIN32)\\n   XP_CHAR cmdLine[CMDLINE_SIZE];\\n   size = CMDLINE_SIZE;\\n@@ -484,7 +484,7 @@ typedef nsresult (*InitDataFunc)(nsACString&);\\n // Attempt to read aFile's contents into aContents, if aFile\\n // does not exist, create it and initialize its contents\\n // by calling aInitFunc for the data.\\n-static nsresult \\n+static nsresult\\n GetOrInit(nsIFile* aDir, const nsACString& filename,\\n           nsACString& aContents, InitDataFunc aInitFunc)\\n {\\n@@ -537,7 +537,7 @@ InitUserID(nsACString& aUserID)\\n   CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);\\n   if (!uuid)\\n     return NS_ERROR_FAILURE;\\n-  \\n+\\n   CFUUIDBytes bytes = CFUUIDGetUUIDBytes(uuid);\\n   memcpy(&id, &bytes, sizeof(nsID));\\n \\n@@ -553,7 +553,7 @@ InitUserID(nsACString& aUserID)\\n \\n   nsCAutoString id_str(id.ToString());\\n   aUserID = Substring(id_str, 1, id_str.Length()-2);\\n-  \\n+\\n   return NS_OK;\\n }\\n \\n@@ -566,7 +566,7 @@ InitInstallTime(nsACString& aInstallTime)\\n   char buf[16];\\n   sprintf(buf, \\\"%ld\\\", t);\\n   aInstallTime = buf;\\n-  \\n+\\n   return NS_OK;\\n }\\n \\n@@ -594,6 +594,28 @@ nsresult SetupExtraData(nsILocalFile* aAppDataDirectory,\\n     NS_ENSURE_SUCCESS(rv, rv);\\n   }\\n \\n+  // Save this path in the environment for the crash reporter application.\\n+  nsCAutoString dataDirEnv(\\\"MOZ_CRASHREPORTER_DATA_DIRECTORY=\\\");\\n+\\n+#if defined(XP_WIN32)\\n+  nsAutoString dataDirectoryPath;\\n+  rv = dataDirectory->GetPath(dataDirectoryPath);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  AppendUTF16toUTF8(dataDirectoryPath, dataDirEnv);\\n+#else\\n+  nsCAutoString dataDirectoryPath;\\n+  rv = dataDirectory->GetNativePath(dataDirectoryPath);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  dataDirEnv.Append(dataDirectoryPath);\\n+#endif\\n+\\n+  char* env = ToNewCString(dataDirEnv);\\n+  NS_ENSURE_TRUE(env, NS_ERROR_OUT_OF_MEMORY);\\n+\\n+  PR_SetEnv(env);\\n+\\n   nsCAutoString data;\\n   if(NS_SUCCEEDED(GetOrInit(dataDirectory, NS_LITERAL_CSTRING(\\\"UserID\\\"),\\n                             data, InitUserID)))\\n@@ -668,7 +690,7 @@ static void ReplaceChar(nsCString& str, const nsACString& character,\\n                         const nsACString& replacement)\\n {\\n   nsCString::const_iterator start, end;\\n-  \\n+\\n   str.BeginReading(start);\\n   str.EndReading(end);\\n \\n@@ -713,7 +735,7 @@ nsresult AnnotateCrashReport(const nsACString &key, const nsACString &data)\\n     return NS_ERROR_INVALID_ARG;\\n \\n   nsCString escapedData(data);\\n-  \\n+\\n   // escape backslashes\\n   ReplaceChar(escapedData, NS_LITERAL_CSTRING(\\\"\\\\\\\\\\\"),\\n               NS_LITERAL_CSTRING(\\\"\\\\\\\\\\\\\\\\\\\"));\\ndiff --git a/toolkit/xre/nsAppData.cpp b/toolkit/xre/nsAppData.cpp\\nindex affc231..e7a5f6b 100644\\n--- a/toolkit/xre/nsAppData.cpp\\n+++ b/toolkit/xre/nsAppData.cpp\\n@@ -78,6 +78,7 @@ ScopedAppData::ScopedAppData(const nsXREAppData* aAppData)\\n   SetAllocatedString(this->buildID, aAppData->buildID);\\n   SetAllocatedString(this->ID, aAppData->ID);\\n   SetAllocatedString(this->copyright, aAppData->copyright);\\n+  SetAllocatedString(this->profile, aAppData->profile);\\n   SetStrongPtr(this->directory, aAppData->directory);\\n   this->flags = aAppData->flags;\\n \\n@@ -100,6 +101,7 @@ ScopedAppData::~ScopedAppData()\\n   SetAllocatedString(this->buildID, nsnull);\\n   SetAllocatedString(this->ID, nsnull);\\n   SetAllocatedString(this->copyright, nsnull);\\n+  SetAllocatedString(this->profile, nsnull);\\n \\n   NS_IF_RELEASE(this->directory);\\n \\n@@ -208,6 +210,7 @@ XRE_ParseAppData(nsILocalFile* aINIFile, nsXREAppData *aAppData)\\n     { \\\"App\\\", \\\"BuildID\\\",   &aAppData->buildID },\\n     { \\\"App\\\", \\\"ID\\\",        &aAppData->ID },\\n     { \\\"App\\\", \\\"Copyright\\\", &aAppData->copyright },\\n+    { \\\"App\\\", \\\"Profile\\\",   &aAppData->profile },\\n     { nsnull }\\n   };\\n   ReadStrings(parser, strings);\\ndiff --git a/toolkit/xre/nsXREDirProvider.cpp b/toolkit/xre/nsXREDirProvider.cpp\\nindex 6d6a944..63827a0 100644\\n--- a/toolkit/xre/nsXREDirProvider.cpp\\n+++ b/toolkit/xre/nsXREDirProvider.cpp\\n@@ -62,13 +62,14 @@\\n #include \\\"nsCOMArray.h\\\"\\n #include \\\"nsArrayEnumerator.h\\\"\\n #include \\\"nsEnumeratorUtils.h\\\"\\n+#include \\\"nsReadableUtils.h\\\"\\n \\n #include <stdlib.h>\\n \\n #ifdef XP_WIN\\n #include <windows.h>\\n #include <shlobj.h>\\n-// This is not defined by VC6. \\n+// This is not defined by VC6.\\n #ifndef CSIDL_LOCAL_APPDATA\\n #define CSIDL_LOCAL_APPDATA             0x001C\\n #endif\\n@@ -132,7 +133,7 @@ nsXREDirProvider::SetProfile(nsIFile* aDir, nsIFile* aLocalDir)\\n   NS_ASSERTION(aDir && aLocalDir, \\\"We don't support no-profile apps yet!\\\");\\n \\n   nsresult rv;\\n-  \\n+\\n   rv = EnsureDirectoryExists(aDir);\\n   if (NS_FAILED(rv))\\n     return rv;\\n@@ -507,7 +508,7 @@ nsXREDirProvider::GetFiles(const char* aProperty, nsISimpleEnumerator** aResult)\\n \\n static void\\n LoadExtensionDirectories(nsINIParser &parser,\\n-                         const char *aSection, \\n+                         const char *aSection,\\n                          nsCOMArray<nsIFile> &aDirectories)\\n {\\n   nsresult rv;\\n@@ -583,7 +584,7 @@ nsXREDirProvider::LoadAppBundleDirs()\\n   nsresult rv = mXULAppDir->Clone(getter_AddRefs(dir));\\n   if (NS_FAILED(rv))\\n     return;\\n-  \\n+\\n   dir->AppendNative(NS_LITERAL_CSTRING(\\\"distribution\\\"));\\n   dir->AppendNative(NS_LITERAL_CSTRING(\\\"bundles\\\"));\\n \\n@@ -633,7 +634,7 @@ nsXREDirProvider::GetFilesInternal(const char* aProperty,\\n \\n   if (!strcmp(aProperty, XRE_EXTENSIONS_DIR_LIST)) {\\n     nsCOMArray<nsIFile> directories;\\n-    \\n+\\n     static const char *const kAppendNothing[] = { nsnull };\\n \\n     LoadBundleDirectories();\\n@@ -712,7 +713,7 @@ nsXREDirProvider::GetFilesInternal(const char* aProperty,\\n                       manifests);\\n \\n     rv = NS_NewArrayEnumerator(aResult, manifests);\\n-  }  \\n+  }\\n   else if (!strcmp(aProperty, NS_SKIN_MANIFESTS_FILE_LIST)) {\\n     nsCOMArray<nsIFile> manifests;\\n \\n@@ -850,29 +851,26 @@ nsXREDirProvider::DoShutdown()\\n   }\\n }\\n \\n-static void \\n-GetProfileFolderName(char* aProfileFolderName, const char* aSource)\\n-{\\n-  const char* reading = aSource;\\n-\\n-  while (*reading) {\\n-    *aProfileFolderName = tolower(*reading);\\n-    ++aProfileFolderName; ++reading;\\n-  }\\n-  *aProfileFolderName = '\\\\0';\\n-}\\n-\\n #ifdef XP_WIN\\n static nsresult\\n-GetShellFolderPath(int folder, char result[MAXPATHLEN])\\n+GetShellFolderPath(int folder, nsAString& _retval)\\n {\\n   LPITEMIDLIST pItemIDList = NULL;\\n \\n+  PRUnichar* buf;\\n+  PRUint32 bufLength = _retval.GetMutableData(&buf, MAXPATHLEN);\\n+  NS_ENSURE_TRUE(bufLength >= MAXPATHLEN, NS_ERROR_OUT_OF_MEMORY);\\n+\\n   nsresult rv;\\n   if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, folder, &pItemIDList)) &&\\n-      SUCCEEDED(SHGetPathFromIDList(pItemIDList, result))) {\\n+      SHGetPathFromIDListW(pItemIDList, buf)) {\\n+    // We're going to use wcslen (wcsnlen not available in msvc7.1) so make\\n+    // sure to null terminate.\\n+    buf[bufLength - 1] = L'\\\\0';\\n+    _retval.SetLength(wcslen(buf));\\n     rv = NS_OK;\\n   } else {\\n+    _retval.SetLength(0);\\n     rv = NS_ERROR_NOT_AVAILABLE;\\n   }\\n \\n@@ -885,18 +883,23 @@ nsresult\\n nsXREDirProvider::GetUpdateRootDir(nsIFile* *aResult)\\n {\\n   nsCOMPtr<nsIFile> appDir = GetAppDir();\\n-  nsCAutoString appPath;\\n-  nsresult rv = appDir->GetNativePath(appPath);\\n+\\n+  nsAutoString appPath;\\n+  nsresult rv = appDir->GetPath(appPath);\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n   // AppDir may be a short path. Convert to long path to make sure\\n   // the consistency of the update folder location\\n-  nsCString longPath;\\n-  char *buf;\\n-  longPath.GetMutableData(&buf, MAXPATHLEN);\\n-  DWORD len = GetLongPathName(appPath.get(), buf, MAXPATHLEN);\\n+  nsString longPath;\\n+  PRUnichar* buf;\\n+\\n+  PRUint32 bufLength = longPath.GetMutableData(&buf, MAXPATHLEN);\\n+  NS_ENSURE_TRUE(bufLength >= MAXPATHLEN, NS_ERROR_OUT_OF_MEMORY);\\n+\\n+  DWORD len = GetLongPathNameW(appPath.get(), buf, bufLength);\\n+\\n   // Failing GetLongPathName() is not fatal.\\n-  if (len <= 0 || len >= MAXPATHLEN)\\n+  if (len <= 0 || len >= bufLength)\\n     longPath.Assign(appPath);\\n   else\\n     longPath.SetLength(len);\\n@@ -904,25 +907,24 @@ nsXREDirProvider::GetUpdateRootDir(nsIFile* *aResult)\\n   // Use <UserLocalDataDir>\\\\updates\\\\<relative path to app dir from\\n   // Program Files> if app dir is under Program Files to avoid the\\n   // folder virtualization mess on Windows Vista\\n-  char programFiles[MAXPATHLEN];\\n+  nsAutoString programFiles;\\n   rv = GetShellFolderPath(CSIDL_PROGRAM_FILES, programFiles);\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n-  PRUint32 programFilesLen = strlen(programFiles);\\n-  programFiles[programFilesLen++] = '\\\\\\\\';\\n-  programFiles[programFilesLen] = '\\\\0';\\n+  programFiles.AppendLiteral(\\\"\\\\\\\\\\\");\\n+  PRUint32 programFilesLen = programFiles.Length();\\n \\n   if (longPath.Length() < programFilesLen)\\n     return NS_ERROR_FAILURE;\\n \\n-  if (_strnicmp(programFiles, longPath.get(), programFilesLen) != 0)\\n+  if (_wcsnicmp(programFiles.get(), longPath.get(), programFilesLen) != 0)\\n     return NS_ERROR_FAILURE;\\n \\n   nsCOMPtr<nsILocalFile> updRoot;\\n   rv = GetUserLocalDataDirectory(getter_AddRefs(updRoot));\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n-  rv = updRoot->AppendRelativeNativePath(Substring(longPath, programFilesLen));\\n+  rv = updRoot->AppendRelativePath(Substring(longPath, programFilesLen));\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n   NS_ADDREF(*aResult = updRoot);\\n@@ -988,11 +990,11 @@ nsXREDirProvider::GetUserDataDirectory(nsILocalFile** aFile, PRBool aLocal)\\n   if (aLocal) {\\n     folderType = kCachedDataFolderType;\\n   } else {\\n-#ifdef MOZ_THUNDERBIRD \\n+#ifdef MOZ_THUNDERBIRD\\n     folderType = kDomainLibraryFolderType;\\n #else\\n     folderType = kApplicationSupportFolderType;\\n-#endif \\n+#endif\\n   }\\n   OSErr err = ::FSFindFolder(kUserDomain, folderType, kCreateFolder, &fsRef);\\n   NS_ENSURE_FALSE(err, NS_ERROR_FAILURE);\\n@@ -1006,39 +1008,16 @@ nsXREDirProvider::GetUserDataDirectory(nsILocalFile** aFile, PRBool aLocal)\\n   rv = dirFileMac->InitWithFSRef(&fsRef);\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n-  // Note that MacOS ignores the vendor when creating the profile hierarchy - all\\n-  // application preferences directories live alongside one another in \\n-  // ~/Library/Application Support/\\n-  rv = dirFileMac->AppendNative(nsDependentCString(gAppData->name));\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n+  localDir = do_QueryInterface(dirFileMac, &rv);\\n #elif defined(XP_WIN)\\n-  char path[MAXPATHLEN];\\n-\\n-  // CSIDL_LOCAL_APPDATA is only defined on newer versions of Windows.  If the\\n-  // OS does not understand it, then we'll fallback to the regular APPDATA\\n-  // location.  If neither is defined, then we fallback to the Windows folder.\\n-\\n+  nsString path;\\n   if (aLocal)\\n     rv = GetShellFolderPath(CSIDL_LOCAL_APPDATA, path);\\n   if (!aLocal || NS_FAILED(rv))\\n     rv = GetShellFolderPath(CSIDL_APPDATA, path);\\n-\\n-  if (NS_FAILED(rv) && !GetWindowsDirectory(path, sizeof(path))) {\\n-    NS_WARNING(\\\"Aaah, no windows directory!\\\");\\n-    return NS_ERROR_FAILURE;\\n-  }\\n-\\n-  rv = NS_NewNativeLocalFile(nsDependentCString(path),\\n-                             PR_TRUE, getter_AddRefs(localDir));\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  if (gAppData->vendor) {\\n-    rv = localDir->AppendNative(nsDependentCString(gAppData->vendor));\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n-  }\\n-  rv = localDir->AppendNative(nsDependentCString(gAppData->name));\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n+  rv = NS_NewLocalFile(path, PR_TRUE, getter_AddRefs(localDir));\\n #elif defined(XP_OS2)\\n #if 0 /* For OS/2 we want to always use MOZILLA_HOME */\\n   // we want an environment variable of the form\\n@@ -1061,15 +1040,6 @@ nsXREDirProvider::GetUserDataDirectory(nsILocalFile** aFile, PRBool aLocal)\\n     *strrchr(appDir, '\\\\\\\\') = '\\\\0';\\n     rv = NS_NewNativeLocalFile(nsDependentCString(appDir), PR_TRUE, getter_AddRefs(localDir));\\n   }\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  if (gAppData->vendor) {\\n-    rv = localDir->AppendNative(nsDependentCString(gAppData->vendor));\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n-  }\\n-  rv = localDir->AppendNative(nsDependentCString(gAppData->name));\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n #elif defined(XP_BEOS)\\n   char appDir[MAXPATHLEN];\\n   if (find_directory(B_USER_SETTINGS_DIRECTORY, NULL, true, appDir, MAXPATHLEN))\\n@@ -1081,15 +1051,6 @@ nsXREDirProvider::GetUserDataDirectory(nsILocalFile** aFile, PRBool aLocal)\\n \\n   rv = NS_NewNativeLocalFile(nsDependentCString(appDir), PR_TRUE,\\n                              getter_AddRefs(localDir));\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  if (gAppData->vendor) {\\n-    rv = localDir->AppendNative(nsDependentCString(gAppData->vendor));\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n-  }\\n-  rv = localDir->AppendNative(nsDependentCString(gAppData->name));\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n #elif defined(XP_UNIX)\\n   const char* homeDir = getenv(\\\"HOME\\\");\\n   if (!homeDir || !*homeDir)\\n@@ -1097,32 +1058,13 @@ nsXREDirProvider::GetUserDataDirectory(nsILocalFile** aFile, PRBool aLocal)\\n \\n   rv = NS_NewNativeLocalFile(nsDependentCString(homeDir), PR_TRUE,\\n                              getter_AddRefs(localDir));\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n- \\n-  char* appNameFolder = nsnull;\\n-  char profileFolderName[MAXPATHLEN] = \\\".\\\";\\n- \\n-  // Offset 1 for the outermost folder to make it hidden (i.e. using the \\\".\\\")\\n-  char* writing = profileFolderName + 1;\\n-  if (gAppData->vendor) {\\n-    GetProfileFolderName(writing, gAppData->vendor);\\n-    \\n-    rv = localDir->AppendNative(nsDependentCString(profileFolderName));\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n- \\n-    char temp[MAXPATHLEN];\\n-    GetProfileFolderName(temp, gAppData->name);\\n-    appNameFolder = temp;\\n-  }\\n-  else {\\n-    GetProfileFolderName(writing, gAppData->name);\\n-    appNameFolder = profileFolderName;\\n-  }\\n-  rv = localDir->AppendNative(nsDependentCString(appNameFolder));\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n #else\\n-#error dont_know_how_to_get_product_dir_on_your_platform\\n+#error \\\"Don't know how to get product dir on your platform\\\"\\n #endif\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  rv = AppendProfilePath(localDir);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n \\n #ifdef DEBUG_jungshik\\n   nsCAutoString cwd;\\n@@ -1132,8 +1074,7 @@ nsXREDirProvider::GetUserDataDirectory(nsILocalFile** aFile, PRBool aLocal)\\n   rv = EnsureDirectoryExists(localDir);\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n-  *aFile = localDir;\\n-  NS_ADDREF(*aFile);\\n+  NS_ADDREF(*aFile = localDir);\\n   return NS_OK;\\n }\\n \\n@@ -1165,10 +1106,10 @@ nsXREDirProvider::EnsureProfileFileExists(nsIFile *aFile)\\n {\\n   nsresult rv;\\n   PRBool exists;\\n-    \\n+\\n   rv = aFile->Exists(&exists);\\n   if (NS_FAILED(rv) || exists) return;\\n-  \\n+\\n   nsCAutoString leafName;\\n   rv = aFile->GetNativeLeafName(leafName);\\n   if (NS_FAILED(rv)) return;\\n@@ -1179,7 +1120,7 @@ nsXREDirProvider::EnsureProfileFileExists(nsIFile *aFile)\\n \\n   rv = defaultsFile->AppendNative(leafName);\\n   if (NS_FAILED(rv)) return;\\n-  \\n+\\n   defaultsFile->CopyToNative(mProfileDir, EmptyCString());\\n }\\n \\n@@ -1196,10 +1137,107 @@ nsXREDirProvider::GetProfileDefaultsDir(nsIFile* *aResult)\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n   rv = defaultsDir->AppendNative(NS_LITERAL_CSTRING(\\\"defaults\\\"));\\n-  rv |= defaultsDir->AppendNative(NS_LITERAL_CSTRING(\\\"profile\\\"));\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  rv = defaultsDir->AppendNative(NS_LITERAL_CSTRING(\\\"profile\\\"));\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n   NS_ADDREF(*aResult = defaultsDir);\\n   return NS_OK;\\n }\\n \\n+nsresult\\n+nsXREDirProvider::AppendProfilePath(nsIFile* aFile)\\n+{\\n+  NS_ASSERTION(aFile, \\\"Null pointer!\\\");\\n+\\n+  nsresult rv;\\n+\\n+#if defined (XP_MACOSX)\\n+  if (gAppData->profile) {\\n+    rv = AppendProfileString(aFile, gAppData->profile);\\n+  }\\n+  else {\\n+    // Note that MacOS ignores the vendor when creating the profile hierarchy -\\n+    // all application preferences directories live alongside one another in\\n+    // ~/Library/Application Support/\\n+    rv = aFile->AppendNative(nsDependentCString(gAppData->name));\\n+  }\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+#elif defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS)\\n+  if (gAppData->profile) {\\n+    rv = AppendProfileString(aFile, gAppData->profile);\\n+  }\\n+  else {\\n+    if (gAppData->vendor) {\\n+      rv = aFile->AppendNative(nsDependentCString(gAppData->vendor));\\n+      NS_ENSURE_SUCCESS(rv, rv);\\n+    }\\n+    rv = aFile->AppendNative(nsDependentCString(gAppData->name));\\n+  }\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+#elif defined(XP_UNIX)\\n+  // Make it hidden (i.e. using the \\\".\\\")\\n+  nsCAutoString folder(\\\".\\\");\\n+\\n+  if (gAppData->profile) {\\n+    // Skip any leading path characters\\n+    const char* profileStart = gAppData->profile;\\n+    while (*profileStart == '/' || *profileStart == '\\\\\\\\')\\n+      profileStart++;\\n+\\n+    // On the off chance that someone wanted their folder to be hidden don't\\n+    // let it become \\\"..\\\"\\n+    if (*profileStart == '.')\\n+      profileStart++;\\n+\\n+    folder.Append(profileStart);\\n+    ToLowerCase(folder);\\n+\\n+    rv = AppendProfileString(aFile, folder.BeginReading());\\n+  }\\n+  else {\\n+    if (gAppData->vendor) {\\n+      folder.Append(gAppData->vendor);\\n+      ToLowerCase(folder);\\n+\\n+      rv = aFile->AppendNative(folder);\\n+      NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+      folder.Truncate();\\n+    }\\n+\\n+    folder.Append(gAppData->name);\\n+    ToLowerCase(folder);\\n+\\n+    rv = aFile->AppendNative(folder);\\n+  }\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+#else\\n+#error \\\"Don't know how to get profile path on your platform\\\"\\n+#endif\\n+  return NS_OK;\\n+}\\n+\\n+nsresult\\n+nsXREDirProvider::AppendProfileString(nsIFile* aFile, const char* aPath)\\n+{\\n+  NS_ASSERTION(aFile, \\\"Null file!\\\");\\n+  NS_ASSERTION(aPath, \\\"Null path!\\\");\\n+\\n+  nsCAutoString pathDup(aPath);\\n+\\n+  char* path = pathDup.BeginWriting();\\n+\\n+  nsresult rv;\\n+  char* subdir;\\n+  while ((subdir = NS_strtok(\\\"/\\\\\\\\\\\", &path))) {\\n+    rv = aFile->AppendNative(nsDependentCString(subdir));\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+  }\\n+\\n+  return NS_OK;\\n+}\\ndiff --git a/toolkit/xre/nsXREDirProvider.h b/toolkit/xre/nsXREDirProvider.h\\nindex b4563ea..dc3618e 100644\\n--- a/toolkit/xre/nsXREDirProvider.h\\n+++ b/toolkit/xre/nsXREDirProvider.h\\n@@ -86,7 +86,7 @@ public:\\n \\n   /* make sure you clone it, if you need to do stuff to it */\\n   nsIFile* GetGREDir() { return mGREDir; }\\n-  nsIFile* GetAppDir() { \\n+  nsIFile* GetAppDir() {\\n     if (mXULAppDir)\\n       return mXULAppDir;\\n     return mGREDir;\\n@@ -119,6 +119,14 @@ protected:\\n   static nsresult EnsureDirectoryExists(nsIFile* aDirectory);\\n   void EnsureProfileFileExists(nsIFile* aFile);\\n \\n+  // Determine the profile path within the UAppData directory. This is different\\n+  // on every major platform.\\n+  static nsresult AppendProfilePath(nsIFile* aFile);\\n+\\n+  // Internal helper that splits a path into components using the '/' and '\\\\\\\\'\\n+  // delimiters.\\n+  static inline nsresult AppendProfileString(nsIFile* aFile, const char* aPath);\\n+\\n   // Calculate all bundle directories, including distribution bundles,\\n   // extensions, and themes\\n   void LoadBundleDirectories();\\ndiff --git a/toolkit/xre/nsXULAppAPI.h b/toolkit/xre/nsXULAppAPI.h\\nindex 00f0760..cc5adc4 100644\\n--- a/toolkit/xre/nsXULAppAPI.h\\n+++ b/toolkit/xre/nsXULAppAPI.h\\n@@ -94,7 +94,7 @@ struct nsXREAppData\\n    */\\n   const char *version;\\n \\n-  /** \\n+  /**\\n    * The application's build identifier, e.g. \\\"2004051604\\\"\\n    */\\n   const char *buildID;\\n@@ -138,6 +138,23 @@ struct nsXREAppData\\n    * The server URL to send crash reports to.\\n    */\\n   const char *crashReporterURL;\\n+\\n+  /**\\n+   * The profile directory that will be used. Optional (may be null). Must not\\n+   * be the empty string, must be ASCII. The path is split into components\\n+   * along the path separator characters '/' and '\\\\'.\\n+   *\\n+   * The application data directory (\\\"UAppData\\\", see below) is normally\\n+   * composed as follows, where $HOME is platform-specific:\\n+   *\\n+   *   UAppData = $HOME[/$vendor]/$name\\n+   *\\n+   * If present, the 'profile' string will be used instead of the combination of\\n+   * vendor and name as follows:\\n+   *\\n+   *   UAppData = $HOME/$profile\\n+   */\\n+  const char *profile;\\n };\\n \\n /**\\n@@ -164,11 +181,33 @@ struct nsXREAppData\\n   \\\"@mozilla.org/xre/app-info;1\\\"\\n \\n /**\\n- * A directory service key which provides the platform-correct\\n- * \\\"application data\\\" directory.\\n- * Windows: Documents and Settings\\\\<User>\\\\Application Data\\\\<Vendor>\\\\<Application>\\n- * Unix: ~/.<vendor>/<application>\\n- * Mac: ~/Library/Application Supports/<Application>\\n+ * A directory service key which provides the platform-correct \\\"application\\n+ * data\\\" directory as follows, where $name and $vendor are as defined above and\\n+ * $vendor is optional:\\n+ *\\n+ * Windows:\\n+ *   HOME = Documents and Settings\\\\$USER\\\\Application Data\\n+ *   UAppData = $HOME[\\\\$vendor]\\\\$name\\n+ *\\n+ * Unix:\\n+ *   HOME = ~\\n+ *   UAppData = $HOME/.[$vendor/]$name\\n+ *\\n+ * Mac:\\n+ *   HOME = ~\\n+ *   UAppData = $HOME/Library/Application Support/$name\\n+ *\\n+ * Note that the \\\"profile\\\" member above will change the value of UAppData as\\n+ * follows:\\n+ *\\n+ * Windows:\\n+ *   UAppData = $HOME\\\\$profile\\n+ *\\n+ * Unix:\\n+ *   UAppData = $HOME/.$profile\\n+ *\\n+ * Mac:\\n+ *   UAppData = $HOME/Library/Application Support/$profile\\n  */\\n #define XRE_USER_APP_DATA_DIR \\\"UAppData\\\"\\n \\n@@ -222,7 +261,7 @@ struct nsXREAppData\\n  *\\n  * @return         A native result code suitable for returning from main().\\n  *\\n- * @note           If the binary is linked against the  standalone XPCOM glue,\\n+ * @note           If the binary is linked against the standalone XPCOM glue,\\n  *                 XPCOMGlueStartup() should be called before this method.\\n  *\\n  * @note           XXXbsmedberg Nobody uses the glue yet, but there is a\\n\""}