{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas7574aa1\""},"diff":"\"7574aa1 Bug 386229 - \\\"Setting cursor with GIF, PNG or XBM doesn't work\\\" [p=alfredkayser@nl.ibm.com (Alfred Kayser) r=emaijala sr=tor a1.9=stuart]\\ndiff --git a/widget/src/windows/nsWindow.cpp b/widget/src/windows/nsWindow.cpp\\nindex 7cc1d97..d1a11f6 100644\\n--- a/widget/src/windows/nsWindow.cpp\\n+++ b/widget/src/windows/nsWindow.cpp\\n@@ -2534,71 +2534,58 @@ NS_METHOD nsWindow::SetCursor(nsCursor aCursor)\\n }\\n \\n static PRUint8* Data32BitTo1Bit(PRUint8* aImageData,\\n-                                PRUint32 aImageBytesPerRow,\\n                                 PRUint32 aWidth, PRUint32 aHeight)\\n {\\n   // We need (aWidth + 7) / 8 bytes plus zero-padding up to a multiple of\\n   // 4 bytes for each row (HBITMAP requirement). Bug 353553.\\n   PRUint32 outBpr = ((aWidth + 31) / 8) & ~3;\\n-  \\n-  PRUint8* outData = new PRUint8[outBpr * aHeight];\\n+\\n+  // Allocate and clear mask buffer\\n+  PRUint8* outData = (PRUint8*)PR_Calloc(outBpr, aHeight);\\n   if (!outData)\\n     return NULL;\\n \\n-  PRUint8 *outRow = outData,\\n-          *imageRow = aImageData;\\n-\\n+  PRInt32 *imageRow = (PRInt32*)aImageData;\\n   for (PRUint32 curRow = 0; curRow < aHeight; curRow++) {\\n-    PRUint8 *irow = imageRow;\\n-    PRUint8 *nextOutRow = outRow + outBpr;\\n-    PRUint8 alphaPixels = 0;\\n-    PRUint8 offset = 7;\\n-\\n+    PRUint8 *outRow = outData + curRow * outBpr;\\n+    PRUint8 mask = 0x80;\\n     for (PRUint32 curCol = 0; curCol < aWidth; curCol++) {\\n-      if (imageRow[3] > 0)\\n-        alphaPixels |= (1 << offset);\\n-      imageRow += 4;\\n-        \\n-      if (offset == 0) {\\n-        *outRow++ = alphaPixels;\\n-        offset = 7;\\n-        alphaPixels = 0;\\n-      } else {\\n-        offset--;\\n+      // Use sign bit to test for transparency, as alpha byte is highest byte\\n+      if (*imageRow++ < 0)\\n+        *outRow |= mask;\\n+\\n+      mask >>= 1;\\n+      if (!mask) {\\n+        outRow ++;\\n+        mask = 0x80;\\n       }\\n     }\\n-    if (offset != 7)\\n-      *outRow++ = alphaPixels;\\n-\\n-    imageRow = irow + aImageBytesPerRow;\\n-    while (outRow != nextOutRow)\\n-      *outRow++ = 0; // padding\\n   }\\n \\n   return outData;\\n }\\n \\n-// static\\n-HBITMAP nsWindow::DataToBitmap(PRUint8* aImageData,\\n-                               PRUint32 aWidth,\\n-                               PRUint32 aHeight,\\n-                               PRUint32 aDepth)\\n+/**\\n+ * Convert the given image data to a HBITMAP. If the requested depth is\\n+ * 32 bit and the OS supports translucency, a bitmap with an alpha channel\\n+ * will be returned.\\n+ *\\n+ * @param aImageData The image data to convert. Must use the format accepted\\n+ *                   by CreateDIBitmap.\\n+ * @param aWidth     With of the bitmap, in pixels.\\n+ * @param aHeight    Height of the image, in pixels.\\n+ * @param aDepth     Image depth, in bits. Should be one of 1, 24 and 32.\\n+ *\\n+ * @return The HBITMAP representing the image. Caller should call\\n+ *         DeleteObject when done with the bitmap.\\n+ *         On failure, NULL will be returned.\\n+ */\\n+static HBITMAP DataToBitmap(PRUint8* aImageData,\\n+                            PRUint32 aWidth,\\n+                            PRUint32 aHeight,\\n+                            PRUint32 aDepth)\\n {\\n-  if (aDepth == 8 || aDepth == 4) {\\n-    NS_WARNING(\\\"nsWindow::DataToBitmap can't handle 4 or 8 bit images\\\");\\n-    return NULL;\\n-  }\\n-\\n-  // dc must be a CreateCompatibleDC.\\n-  // GetDC, cursors, 1 bit masks, and Win9x do not mix for some reason.\\n-  HDC dc = ::CreateCompatibleDC(NULL);\\n-  \\n-  // force dc into color/bw mode\\n-  int planes = ::GetDeviceCaps(dc, PLANES);\\n-  int bpp = (aDepth == 1) ? 1 : ::GetDeviceCaps(dc, BITSPIXEL);\\n-\\n-  HBITMAP tBitmap = ::CreateBitmap(1, 1, planes, bpp, NULL);\\n-  HBITMAP oldbits = (HBITMAP)::SelectObject(dc, tBitmap);\\n+  HDC dc = ::GetDC(NULL);\\n \\n #ifndef WINCE\\n   if (aDepth == 32 && IsCursorTranslucencySupported()) {\\n@@ -2627,15 +2614,13 @@ HBITMAP nsWindow::DataToBitmap(PRUint8* aImageData,\\n                                    aImageData,\\n                                    reinterpret_cast<CONST BITMAPINFO*>(&head),\\n                                    DIB_RGB_COLORS);\\n-\\n-    ::SelectObject(dc, oldbits);\\n-    ::DeleteObject(tBitmap);\\n-    ::DeleteDC(dc);\\n+    ::ReleaseDC(NULL, dc);\\n     return bmp;\\n   }\\n #endif\\n \\n-  BITMAPINFOHEADER head = { 0 };\\n+  char reserved_space[sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * 2];\\n+  BITMAPINFOHEADER& head = *(BITMAPINFOHEADER*)reserved_space;\\n \\n   head.biSize = sizeof(BITMAPINFOHEADER);\\n   head.biWidth = aWidth;\\n@@ -2649,11 +2634,8 @@ HBITMAP nsWindow::DataToBitmap(PRUint8* aImageData,\\n   head.biClrUsed = 0;\\n   head.biClrImportant = 0;\\n   \\n-  char reserved_space[sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * 2];\\n   BITMAPINFO& bi = *(BITMAPINFO*)reserved_space;\\n \\n-  bi.bmiHeader = head;\\n-\\n   if (aDepth == 1) {\\n     RGBQUAD black = { 0, 0, 0, 0 };\\n     RGBQUAD white = { 255, 255, 255, 0 };\\n@@ -2663,10 +2645,7 @@ HBITMAP nsWindow::DataToBitmap(PRUint8* aImageData,\\n   }\\n \\n   HBITMAP bmp = ::CreateDIBitmap(dc, &head, CBM_INIT, aImageData, &bi, DIB_RGB_COLORS);\\n-\\n-  ::SelectObject(dc, oldbits);\\n-  ::DeleteObject(tBitmap);\\n-  ::DeleteDC(dc);\\n+  ::ReleaseDC(NULL, dc);\\n   return bmp;\\n }\\n \\n@@ -2688,18 +2667,13 @@ NS_IMETHODIMP nsWindow::SetCursor(imgIContainer* aCursor,\\n   frame->GetWidth(&width);\\n   frame->GetHeight(&height);\\n \\n-  // Reject cursors greater than 128 pixels in some direction, to prevent\\n+  // Reject cursors greater than 128 pixels in either direction, to prevent\\n   // spoofing.\\n   // XXX ideally we should rescale. Also, we could modify the API to\\n   // allow trusted content to set larger cursors.\\n   if (width > 128 || height > 128)\\n     return NS_ERROR_NOT_AVAILABLE;\\n \\n-  PRUint32 bpr;\\n-  gfx_format format;\\n-  frame->GetImageBytesPerRow(&bpr);\\n-  frame->GetFormat(&format);\\n-\\n   frame->LockImageData();\\n \\n   PRUint32 dataLen;\\n@@ -2710,44 +2684,15 @@ NS_IMETHODIMP nsWindow::SetCursor(imgIContainer* aCursor,\\n     return rv;\\n   }\\n \\n-  /* flip the image so that it is stored bottom-up */\\n-  PRUint8 *bottomUpData = (PRUint8*)malloc(dataLen);\\n-  if (!bottomUpData) {\\n-    frame->UnlockImageData();\\n-    return NS_ERROR_OUT_OF_MEMORY;\\n-  }\\n-\\n-  if (format == gfxIFormats::RGB_A8 || format == gfxIFormats::BGR_A8) {\\n-    for (PRInt32 i = 0; i < height; ++i) {\\n-      PRUint32 srcOffset = i * bpr;\\n-      PRUint32 dstOffset = dataLen - (bpr * (i + 1));\\n-      PRUint32 *srcRow = (PRUint32*)(data + srcOffset);\\n-      PRUint32 *dstRow = (PRUint32*)(bottomUpData + dstOffset);\\n-      memcpy(dstRow, srcRow, bpr);\\n-    }\\n-  } else {\\n-    for (PRInt32 i = 0; i < height; ++i) {\\n-      PRUint32 srcOffset = i * bpr;\\n-      PRUint32 dstOffset = dataLen - (bpr * (i + 1));\\n-      PRUint32 *srcRow = (PRUint32*)(data + srcOffset);\\n-      PRUint32 *dstRow = (PRUint32*)(bottomUpData + dstOffset);\\n-      for (PRInt32 x = 0; x < width; ++x) {\\n-        dstRow[x] = (srcRow[x] & 0xFFFFFF) | (0xFF << 24);\\n-      }\\n-    }\\n-  }\\n+  HBITMAP bmp = DataToBitmap(data, width, -height, 32);\\n+  PRUint8* a1data = Data32BitTo1Bit(data, width, height);\\n   frame->UnlockImageData();\\n-\\n-  PRUint8* a1data = Data32BitTo1Bit(bottomUpData, bpr, width, height);\\n   if (!a1data) {\\n-    free(bottomUpData);\\n     return NS_ERROR_FAILURE;\\n   }\\n \\n-  HBITMAP bmp = DataToBitmap(bottomUpData, width, height, 32);\\n-  HBITMAP mbmp = DataToBitmap(a1data, width, height, 1);\\n-  free(bottomUpData);\\n-  delete[] a1data;\\n+  HBITMAP mbmp = DataToBitmap(a1data, width, -height, 1);\\n+  PR_Free(a1data);\\n \\n   ICONINFO info = {0};\\n   info.fIcon = FALSE;\\ndiff --git a/widget/src/windows/nsWindow.h b/widget/src/windows/nsWindow.h\\nindex 7c2d819..ff07270 100644\\n--- a/widget/src/windows/nsWindow.h\\n+++ b/widget/src/windows/nsWindow.h\\n@@ -481,26 +481,6 @@ protected:\\n   static HCURSOR        gHCursor;\\n   static imgIContainer* gCursorImgContainer;\\n \\n-  /**\\n-   * Convert the given image data to a HBITMAP. If the requested depth is\\n-   * 32 bit and the OS supports translucency, a bitmap with an alpha channel\\n-   * will be returned.\\n-   *\\n-   * @param aImageData The image data to convert. Must use the format accepted\\n-   *                   by CreateDIBitmap.\\n-   * @param aWidth     With of the bitmap, in pixels.\\n-   * @param aHeight    Height of the image, in pixels.\\n-   * @param aDepth     Image depth, in bits. Should be one of 1, 24 and 32.\\n-   *\\n-   * @return The HBITMAP representing the image. Caller should call\\n-   *         DeleteObject when done with the bitmap.\\n-   *         On failure, NULL will be returned.\\n-   */\\n-  static HBITMAP DataToBitmap(PRUint8* aImageData,\\n-                              PRUint32 aWidth,\\n-                              PRUint32 aHeight,\\n-                              PRUint32 aDepth);\\n-\\n #ifdef ACCESSIBILITY\\n   static BOOL gIsAccessibilityOn;\\n   static HINSTANCE gmAccLib;\\n\""}