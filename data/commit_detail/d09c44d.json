{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basd09c44d\""},"diff":"\"d09c44d Bug 348748 - Cleanup from the handful of patches which have landed since the initial landing that have readded cast macros; I intend to remove the rest of the instances Very Soon, all but certainly before the M8 freeze, so the macro definitions can be removed, again all but certainly before the M8 freeze, if people are okay with them being removed.  Still r=bsmedberg, a=no-functionality-change\\ndiff --git a/dom/src/offline/nsDOMOfflineLoadStatusList.cpp b/dom/src/offline/nsDOMOfflineLoadStatusList.cpp\\nindex be0e313..590c23d 100644\\n--- a/dom/src/offline/nsDOMOfflineLoadStatusList.cpp\\n+++ b/dom/src/offline/nsDOMOfflineLoadStatusList.cpp\\n@@ -221,8 +221,8 @@ nsDOMOfflineLoadStatusList::FindWrapper(nsIDOMLoadStatus *aStatus,\\n                                         PRUint32 *index)\\n {\\n   for (int i = 0; i < mItems.Count(); i++) {\\n-    nsDOMOfflineLoadStatus *item = NS_STATIC_CAST(nsDOMOfflineLoadStatus*,\\n-                                                  mItems[i]);\\n+    nsDOMOfflineLoadStatus *item = static_cast<nsDOMOfflineLoadStatus*>\\n+                                              (mItems[i]);\\n     if (item->Implementation() == aStatus) {\\n       *index = i;\\n       return mItems[i];\\n@@ -484,7 +484,7 @@ nsDOMOfflineLoadStatusList::SendLoadEvent(const nsAString &aEventName,\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n   NotifyEventListeners(aListeners,\\n-                       NS_STATIC_CAST(nsIDOMLoadStatusEvent*, event));\\n+                       static_cast<nsIDOMLoadStatusEvent*>(event));\\n \\n   return NS_OK;\\n }\\ndiff --git a/gfx/thebes/src/gfxAtsuiFonts.cpp b/gfx/thebes/src/gfxAtsuiFonts.cpp\\nindex 075339b..24f6f89 100644\\n--- a/gfx/thebes/src/gfxAtsuiFonts.cpp\\n+++ b/gfx/thebes/src/gfxAtsuiFonts.cpp\\n@@ -321,7 +321,7 @@ CreateFontFallbacksFromFontList(nsTArray< nsRefPtr<gfxFont> > *aFonts,\\n     nsAutoTArray<ATSUFontID,16> fids;\\n \\n     for (unsigned int i = 0; i < aFonts->Length(); i++) {\\n-        gfxAtsuiFont* atsuiFont = NS_STATIC_CAST(gfxAtsuiFont*, aFonts->ElementAt(i).get());\\n+        gfxAtsuiFont* atsuiFont = static_cast<gfxAtsuiFont*>(aFonts->ElementAt(i).get());\\n         fids.AppendElement(atsuiFont->GetATSUFontID());\\n     }\\n     status = ::ATSUSetObjFontFallbacks(*aFallbacks, fids.Length(), fids.Elements(), aMethod);\\ndiff --git a/js/src/xpconnect/src/XPCWrapper.h b/js/src/xpconnect/src/XPCWrapper.h\\nindex 68c128f..6600ae5 100644\\n--- a/js/src/xpconnect/src/XPCWrapper.h\\n+++ b/js/src/xpconnect/src/XPCWrapper.h\\n@@ -167,8 +167,8 @@ public:\\n     if ((flags & JSRESOLVE_ASSIGNING) &&\\n         (::JS_GetOptions(cx) & JSOPTION_PRIVATE_IS_NSISUPPORTS)) {\\n       nsCOMPtr<nsIXPCScriptNotify> scriptNotify = \\n-        do_QueryInterface(NS_STATIC_CAST(nsISupports*,\\n-                                         JS_GetContextPrivate(cx)));\\n+        do_QueryInterface(static_cast<nsISupports*>\\n+                                     (JS_GetContextPrivate(cx)));\\n       if (scriptNotify) {\\n         return NS_SUCCEEDED(scriptNotify->PreserveWrapper(wn));\\n       }\\ndiff --git a/js/src/xpconnect/src/xpcvariant.cpp b/js/src/xpconnect/src/xpcvariant.cpp\\nindex 7749f47..9cc6016 100644\\n--- a/js/src/xpconnect/src/xpcvariant.cpp\\n+++ b/js/src/xpconnect/src/xpcvariant.cpp\\n@@ -641,7 +641,7 @@ VARIANT_DONE:\\n         if(type == nsIDataType::VTYPE_INTERFACE ||\\n            type == nsIDataType::VTYPE_INTERFACE_IS)\\n         {\\n-            nsISupports *src = NS_REINTERPRET_CAST(nsISupports *, xpctvar.val.p);\\n+            nsISupports *src = reinterpret_cast<nsISupports *>(xpctvar.val.p);\\n             if(nsXPCWrappedJSClass::IsWrappedJS(src))\\n             {\\n                 // First QI the wrapper to the right interface.\\ndiff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp\\nindex 5ff85f1..0887153 100644\\n--- a/layout/generic/nsBlockFrame.cpp\\n+++ b/layout/generic/nsBlockFrame.cpp\\n@@ -608,7 +608,7 @@ static void ReparentFrame(nsIFrame* aFrame, nsIFrame* aOldParent,\\n /* virtual */ void\\n nsBlockFrame::MarkIntrinsicWidthsDirty()\\n {\\n-  nsBlockFrame* dirtyBlock = NS_STATIC_CAST(nsBlockFrame*, GetFirstContinuation());\\n+  nsBlockFrame* dirtyBlock = static_cast<nsBlockFrame*>(GetFirstContinuation());\\n   dirtyBlock->mMinWidth = NS_INTRINSIC_WIDTH_UNKNOWN;\\n   dirtyBlock->mPrefWidth = NS_INTRINSIC_WIDTH_UNKNOWN;\\n   dirtyBlock->AddStateBits(NS_BLOCK_NEEDS_BIDI_RESOLUTION);\\n@@ -639,7 +639,7 @@ nsBlockFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)\\n   ResolveBidi();\\n   InlineMinWidthData data;\\n   for (nsBlockFrame* curFrame = this; curFrame;\\n-       curFrame = NS_STATIC_CAST(nsBlockFrame*, curFrame->GetNextContinuation())) {\\n+       curFrame = static_cast<nsBlockFrame*>(curFrame->GetNextContinuation())) {\\n     for (line_iterator line = curFrame->begin_lines(), line_end = curFrame->end_lines();\\n       line != line_end; ++line)\\n     {\\n@@ -710,7 +710,7 @@ nsBlockFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)\\n   ResolveBidi();\\n   InlinePrefWidthData data;\\n   for (nsBlockFrame* curFrame = this; curFrame;\\n-       curFrame = NS_STATIC_CAST(nsBlockFrame*, curFrame->GetNextContinuation())) {\\n+       curFrame = static_cast<nsBlockFrame*>(curFrame->GetNextContinuation())) {\\n     for (line_iterator line = curFrame->begin_lines(), line_end = curFrame->end_lines();\\n          line != line_end; ++line)\\n     {\\n@@ -6616,8 +6616,8 @@ nsBlockFrame::ResolveBidi()\\n     return NS_ERROR_NULL_POINTER;\\n \\n   for (nsBlockFrame* curFrame = this;\\n-       curFrame; curFrame = NS_STATIC_CAST(nsBlockFrame*,\\n-                                           curFrame->GetNextContinuation())) {\\n+       curFrame; curFrame = static_cast<nsBlockFrame*>\\n+                                       (curFrame->GetNextContinuation())) {\\n     if (!curFrame->mLines.empty()) {\\n       nsresult rv = bidiUtils->Resolve(curFrame,\\n                                        curFrame->mLines.front()->mFirstChild,\\ndiff --git a/xpcom/ds/nsAtomTable.cpp b/xpcom/ds/nsAtomTable.cpp\\nindex 9756fc4..6bfc3d8 100644\\n--- a/xpcom/ds/nsAtomTable.cpp\\n+++ b/xpcom/ds/nsAtomTable.cpp\\n@@ -339,8 +339,8 @@ PR_STATIC_CALLBACK(PRBool)\\n AtomTableInitEntry(PLDHashTable *table, PLDHashEntryHdr *entry,\\n                    const void *key)\\n {\\n-  AtomTableEntry *he = NS_STATIC_CAST(AtomTableEntry*, entry);\\n-  const AtomTableEntry *strKey = NS_STATIC_CAST(const AtomTableEntry*, key);\\n+  AtomTableEntry *he = static_cast<AtomTableEntry*>(entry);\\n+  const AtomTableEntry *strKey = static_cast<const AtomTableEntry*>(key);\\n \\n   he->mLength = strKey->getLength();\\n \\ndiff --git a/xpcom/ds/nsCppSharedAllocator.h b/xpcom/ds/nsCppSharedAllocator.h\\nindex d40facd..d9095c0 100644\\n--- a/xpcom/ds/nsCppSharedAllocator.h\\n+++ b/xpcom/ds/nsCppSharedAllocator.h\\n@@ -2,7 +2,6 @@\\n #define nsCppSharedAllocator_h__\\n \\n #include \\\"nsMemory.h\\\"     // for |nsMemory|\\n-#include \\\"nscore.h\\\"       // for |NS_XXX_CAST|\\n #include NEW_H\\t\\t\\t\\t\\t// to allow placement |new|\\n \\n \\ndiff --git a/xpcom/glue/nsCOMPtr.h b/xpcom/glue/nsCOMPtr.h\\nindex f9415ca..a294eb2 100644\\n--- a/xpcom/glue/nsCOMPtr.h\\n+++ b/xpcom/glue/nsCOMPtr.h\\n@@ -67,7 +67,7 @@\\n \\n #ifndef nscore_h___\\n #include \\\"nscore.h\\\"\\n-  // for |NS_..._CAST|, |NS_COM_GLUE|\\n+  // for |NS_COM_GLUE|\\n #endif\\n \\n \\ndiff --git a/xpcom/io/nsScriptableInputStream.cpp b/xpcom/io/nsScriptableInputStream.cpp\\nindex 8bf3846..5570daf 100644\\n--- a/xpcom/io/nsScriptableInputStream.cpp\\n+++ b/xpcom/io/nsScriptableInputStream.cpp\\n@@ -220,13 +220,13 @@ nsScriptableInputStream::ReadBoolean(PRBool* aBoolean)\\n NS_IMETHODIMP\\n nsScriptableInputStream::Read8(PRUint8* aVal)\\n {\\n-  return ReadFully(sizeof *aVal, NS_REINTERPRET_CAST(char*, aVal));\\n+  return ReadFully(sizeof *aVal, reinterpret_cast<char*>(aVal));\\n }\\n \\n NS_IMETHODIMP\\n nsScriptableInputStream::Read16(PRUint16* aVal)\\n {\\n-  nsresult rv = ReadFully(sizeof *aVal, NS_REINTERPRET_CAST(char*, aVal));\\n+  nsresult rv = ReadFully(sizeof *aVal, reinterpret_cast<char*>(aVal));\\n   NS_ENSURE_SUCCESS(rv, rv);\\n   *aVal = NS_SWAP16(*aVal);\\n   return NS_OK;\\n@@ -235,7 +235,7 @@ nsScriptableInputStream::Read16(PRUint16* aVal)\\n NS_IMETHODIMP\\n nsScriptableInputStream::Read32(PRUint32* aVal)\\n {\\n-  nsresult rv = ReadFully(sizeof *aVal, NS_REINTERPRET_CAST(char*, aVal));\\n+  nsresult rv = ReadFully(sizeof *aVal, reinterpret_cast<char*>(aVal));\\n   NS_ENSURE_SUCCESS(rv, rv);\\n   *aVal = NS_SWAP32(*aVal);\\n   return NS_OK;\\n@@ -246,7 +246,7 @@ nsScriptableInputStream::ReadFloat(float* aFloat)\\n {\\n   NS_ASSERTION(sizeof(float) == sizeof (PRUint32),\\n                \\\"False assumption about sizeof(float)\\\");\\n-  return Read32(NS_REINTERPRET_CAST(PRUint32*, aFloat));\\n+  return Read32(reinterpret_cast<PRUint32*>(aFloat));\\n }\\n \\n NS_IMETHODIMP\\n@@ -255,18 +255,18 @@ nsScriptableInputStream::ReadDouble(double* aDouble)\\n   NS_ASSERTION(sizeof(double) == sizeof(PRUint64),\\n                \\\"False assumption about sizeof(double)\\\");\\n \\n-  nsresult rv = ReadFully(sizeof(double), NS_REINTERPRET_CAST(char*, aDouble));\\n+  nsresult rv = ReadFully(sizeof(double), reinterpret_cast<char*>(aDouble));\\n \\n   NS_ENSURE_SUCCESS(rv, rv);\\n-  PRUint64 i = NS_SWAP64(*NS_REINTERPRET_CAST(PRUint64*, aDouble));\\n-  *aDouble = *NS_REINTERPRET_CAST(double*, &i);\\n+  PRUint64 i = NS_SWAP64(*reinterpret_cast<PRUint64*>(aDouble));\\n+  *aDouble = *reinterpret_cast<double*>(&i);\\n   return NS_OK;\\n }\\n \\n NS_IMETHODIMP\\n nsScriptableInputStream::ReadByteArray(PRUint32 aCount, PRUint8 **aBytes)\\n {\\n-  char* s = NS_REINTERPRET_CAST(char*, NS_Alloc(aCount));\\n+  char* s = reinterpret_cast<char*>(NS_Alloc(aCount));\\n   NS_ENSURE_TRUE(s, NS_ERROR_OUT_OF_MEMORY);\\n \\n   PRUint32 bytesRead;\\ndiff --git a/xpcom/io/nsScriptableOutputStream.cpp b/xpcom/io/nsScriptableOutputStream.cpp\\nindex c269355..5881a1c 100644\\n--- a/xpcom/io/nsScriptableOutputStream.cpp\\n+++ b/xpcom/io/nsScriptableOutputStream.cpp\\n@@ -195,7 +195,7 @@ nsScriptableOutputStream::WriteFloat(float aFloat)\\n {\\n   NS_ASSERTION(sizeof(float) == sizeof (PRUint32),\\n                \\\"False assumption about sizeof(float)\\\");\\n-  return Write32(*NS_REINTERPRET_CAST(PRUint32*, &aFloat));\\n+  return Write32(*reinterpret_cast<PRUint32*>(&aFloat));\\n }\\n \\n NS_IMETHODIMP\\n@@ -204,8 +204,8 @@ nsScriptableOutputStream::WriteDouble(double aDouble)\\n   NS_ASSERTION(sizeof(double) == sizeof(PRUint64),\\n                \\\"False assumption about sizeof(double)\\\");\\n \\n-  PRUint64 val = NS_SWAP64(*NS_REINTERPRET_CAST(PRUint64*, &aDouble));\\n-  return WriteFully(NS_REINTERPRET_CAST(char*, &val), sizeof val);\\n+  PRUint64 val = NS_SWAP64(*reinterpret_cast<PRUint64*>(&aDouble));\\n+  return WriteFully(reinterpret_cast<char*>(&val), sizeof val);\\n }\\n \\n NS_IMETHODIMP\\ndiff --git a/xpcom/string/doc/string-guide.html b/xpcom/string/doc/string-guide.html\\nindex 41dbd21..d954fe6 100644\\n--- a/xpcom/string/doc/string-guide.html\\n+++ b/xpcom/string/doc/string-guide.html\\n@@ -906,8 +906,8 @@ a synonym for <span class=\\\"code\\\">unsigned short</span> under Metrowerks.  We kno\\n current version of VC++ also makes these types equivalent.  In theory,\\n though, the types are distinct even when they are the same size and\\n shape.  By using real <span class=\\\"code\\\">wchar_t</span> support, we are forced to recognize\\n-the distinction and navigate it appropriately with <span class=\\\"code\\\">reinterpret_cast</span>\\n-(via <span class=\\\"code\\\">NS_REINTERPRET_CAST</span>).  The win here is that we aren't caught by\\n+the distinction and navigate it appropriately with <span class=\\\"code\\\">reinterpret_cast</span>.\\n+The win here is that we aren't caught by\\n compiler changes that suddenly make some set of compilers compliant\\n and therefore break our code.  We will add an autoconf test that lets\\n UNIX compilers opt in to our string scheme when they have an\\n\""}