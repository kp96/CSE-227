{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas753a14c\""},"diff":"\"753a14c Bug 393368: new API to limit heap consumption by stack-like data structures used by compiler, decompiler and interpreter.\\ndiff --git a/js/src/js.c b/js/src/js.c\\nindex 1de9fee..85959da 100644\\n--- a/js/src/js.c\\n+++ b/js/src/js.c\\n@@ -98,8 +98,10 @@ size_t gStackChunkSize = 8192;\\n \\n /* Assume that we can not use more than 5e5 bytes of C stack by default. */\\n static size_t gMaxStackSize = 500000;\\n-\\n static jsuword gStackBase;\\n+\\n+static size_t gScriptStackQuota = JS_DEFAULT_SCRIPT_STACK_QUOTA;\\n+\\n int gExitCode = 0;\\n JSBool gQuitting = JS_FALSE;\\n FILE *gErrFile = NULL;\\n@@ -1750,6 +1752,21 @@ StringsAreUTF8(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,\\n     return JS_TRUE;\\n }\\n \\n+static JSBool\\n+StackQuota(JSContext *cx, uintN argc, jsval *vp)\\n+{\\n+    uint32 n;\\n+\\n+    if (argc == 0)\\n+        return JS_NewNumberValue(cx, (double) gScriptStackQuota, vp);\\n+    if (!JS_ValueToECMAUint32(cx, JS_ARGV(cx, vp)[0], &n))\\n+        return JS_FALSE;\\n+    gScriptStackQuota = n;\\n+    JS_SetScriptStackQuota(cx, gScriptStackQuota);\\n+    JS_SET_RVAL(cx, vp, JSVAL_VOID);\\n+    return JS_TRUE;\\n+}\\n+\\n static const char* badUTF8 = \\\"...\\\\xC0...\\\";\\n static const char* bigUTF8 = \\\"...\\\\xFB\\\\xBF\\\\xBF\\\\xBF\\\\xBF...\\\";\\n static const jschar badSurrogate[] = { 'A', 'B', 'C', 0xDEEE, 'D', 'E', 0 };\\n@@ -2222,6 +2239,7 @@ static JSFunctionSpec shell_functions[] = {\\n     JS_FS(\\\"untrap\\\",         Untrap,         2,0,0),\\n     JS_FS(\\\"line2pc\\\",        LineToPC,       0,0,0),\\n     JS_FS(\\\"pc2line\\\",        PCToLine,       0,0,0),\\n+    JS_FN(\\\"stackQuota\\\",     StackQuota,     0,0,0,0),\\n     JS_FS(\\\"stringsAreUTF8\\\", StringsAreUTF8, 0,0,0),\\n     JS_FS(\\\"testUTF8\\\",       TestUTF8,       1,0,0),\\n     JS_FS(\\\"throwError\\\",     ThrowError,     0,0,0),\\n@@ -2269,6 +2287,7 @@ static char *shell_help_messages[] = {\\n     \\\"untrap(fun[, pc])      Remove a trap\\\",\\n     \\\"line2pc([fun,] line)   Map line number to PC\\\",\\n     \\\"pc2line(fun[, pc])     Map PC to line number\\\",\\n+    \\\"stackQuota([number])   Query/set script stack quota\\\",\\n     \\\"stringsAreUTF8()       Check if strings are UTF-8 encoded\\\",\\n     \\\"testUTF8(mode)         Perform UTF-8 tests (modes are 1 to 4)\\\",\\n     \\\"throwError()           Throw an error from JS_ReportError\\\",\\n@@ -3122,6 +3141,17 @@ snarf(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)\\n \\n #endif /* NARCISSUS */\\n \\n+JSBool\\n+ContextCallback(JSContext *cx, uintN contextOp)\\n+{\\n+    if (contextOp == JSCONTEXT_NEW) {\\n+        JS_SetErrorReporter(cx, my_ErrorReporter);\\n+        JS_SetVersion(cx, JSVERSION_LATEST);\\n+        JS_SetScriptStackQuota(cx, gScriptStackQuota);\\n+    }\\n+    return JS_TRUE;\\n+}\\n+\\n int\\n main(int argc, char **argv, char **envp)\\n {\\n@@ -3157,12 +3187,11 @@ main(int argc, char **argv, char **envp)\\n     rt = JS_NewRuntime(64L * 1024L * 1024L);\\n     if (!rt)\\n         return 1;\\n+    JS_SetContextCallback(rt, ContextCallback);\\n \\n     cx = JS_NewContext(rt, gStackChunkSize);\\n     if (!cx)\\n         return 1;\\n-    JS_SetErrorReporter(cx, my_ErrorReporter);\\n-    JS_SetVersion(cx, JSVERSION_LATEST);\\n \\n #ifdef JS_THREADSAFE\\n     JS_BeginRequest(cx);\\ndiff --git a/js/src/jsapi.c b/js/src/jsapi.c\\nindex f36f596..c3748b3 100644\\n--- a/js/src/jsapi.c\\n+++ b/js/src/jsapi.c\\n@@ -2540,6 +2540,12 @@ JS_SetThreadStackLimit(JSContext *cx, jsuword limitAddr)\\n     cx->stackLimit = limitAddr;\\n }\\n \\n+JS_PUBLIC_API(void)\\n+JS_SetScriptStackQuota(JSContext *cx, size_t quota)\\n+{\\n+    cx->scriptStackQuota = quota;\\n+}\\n+\\n /************************************************************************/\\n \\n JS_PUBLIC_API(void)\\n@@ -4334,8 +4340,10 @@ CompileTokenStream(JSContext *cx, JSObject *obj, JSTokenStream *ts,\\n     JSScript *script;\\n \\n     eof = JS_FALSE;\\n-    JS_INIT_ARENA_POOL(&codePool, \\\"code\\\", 1024, sizeof(jsbytecode));\\n-    JS_INIT_ARENA_POOL(&notePool, \\\"note\\\", 1024, sizeof(jssrcnote));\\n+    JS_INIT_ARENA_POOL(&codePool, \\\"code\\\", 1024, sizeof(jsbytecode),\\n+                       &cx->scriptStackQuota);\\n+    JS_INIT_ARENA_POOL(&notePool, \\\"note\\\", 1024, sizeof(jssrcnote),\\n+                       &cx->scriptStackQuota);\\n     js_InitParseContext(cx, &pc);\\n     JS_ASSERT(!ts->parseContext);\\n     ts->parseContext = &pc;\\ndiff --git a/js/src/jsapi.h b/js/src/jsapi.h\\nindex 0521383..937562a 100644\\n--- a/js/src/jsapi.h\\n+++ b/js/src/jsapi.h\\n@@ -1162,6 +1162,21 @@ JS_GetExternalStringGCType(JSRuntime *rt, JSString *str);\\n extern JS_PUBLIC_API(void)\\n JS_SetThreadStackLimit(JSContext *cx, jsuword limitAddr);\\n \\n+/*\\n+ * Set the quota on the number of bytes that stack-like data structures can\\n+ * use when the runtime compiles and executes scripts. These structures\\n+ * consume heap space, so JS_SetThreadStackLimit does not bound their size.\\n+ * The default quota is 32MB which is quite generous.\\n+ *\\n+ * The function must be called before any script compilation or execution API\\n+ * calls, i.e. either immediately after JS_NewContext or from JSCONTEXT_NEW\\n+ * context callback.\\n+ */\\n+extern JS_PUBLIC_API(void)\\n+JS_SetScriptStackQuota(JSContext *cx, size_t quota);\\n+\\n+#define JS_DEFAULT_SCRIPT_STACK_QUOTA   ((size_t) 0x2000000)\\n+\\n /************************************************************************/\\n \\n /*\\ndiff --git a/js/src/jsarena.c b/js/src/jsarena.c\\nindex 2d60b4e..fea0801 100644\\n--- a/js/src/jsarena.c\\n+++ b/js/src/jsarena.c\\n@@ -62,7 +62,7 @@ static JSArenaStats *arena_stats_list;\\n \\n JS_PUBLIC_API(void)\\n JS_INIT_NAMED_ARENA_POOL(JSArenaPool *pool, const char *name, size_t size,\\n-                         size_t align)\\n+                         size_t align, size_t *quotap)\\n {\\n     if (align == 0)\\n         align = JS_ARENA_DEFAULT_ALIGN;\\n@@ -72,6 +72,7 @@ JS_INIT_NAMED_ARENA_POOL(JSArenaPool *pool, const char *name, size_t size,\\n         JS_ARENA_ALIGN(pool, &pool->first + 1);\\n     pool->current = &pool->first;\\n     pool->arenasize = size;\\n+    pool->quotap = quotap;\\n #ifdef JS_ARENAMETER\\n     memset(&pool->stats, 0, sizeof pool->stats);\\n     pool->stats.name = strdup(name);\\n@@ -156,9 +157,19 @@ JS_ArenaAllocate(JSArenaPool *pool, size_t nb)\\n             gross = hdrsz + JS_MAX(nb, pool->arenasize);\\n             if (gross < nb)\\n                 return NULL;\\n-            b = (JSArena *) malloc(gross);\\n-            if (!b)\\n-                return NULL;\\n+            if (pool->quotap) {\\n+                if (gross > *pool->quotap)\\n+                    return NULL;\\n+                b = (JSArena *) malloc(gross);\\n+                if (!b)\\n+                    return NULL;\\n+                *pool->quotap -= gross;\\n+            } else {\\n+                b = (JSArena *) malloc(gross);\\n+                if (!b)\\n+                    return NULL;\\n+            }\\n+\\n             b->next = NULL;\\n             b->limit = (jsuword)b + gross;\\n             JS_COUNT_ARENA(pool,++);\\n@@ -189,7 +200,7 @@ JS_PUBLIC_API(void *)\\n JS_ArenaRealloc(JSArenaPool *pool, void *p, size_t size, size_t incr)\\n {\\n     JSArena **ap, *a, *b;\\n-    jsuword boff, aoff, extra, hdrsz, gross;\\n+    jsuword boff, aoff, extra, hdrsz, gross, growth;\\n \\n     /*\\n      * Use the oversized-single-allocation header to avoid searching for ap.\\n@@ -212,9 +223,19 @@ JS_ArenaRealloc(JSArenaPool *pool, void *p, size_t size, size_t incr)\\n     hdrsz = sizeof *a + extra + pool->mask;     /* header and alignment slop */\\n     gross = hdrsz + aoff;\\n     JS_ASSERT(gross > aoff);\\n-    a = (JSArena *) realloc(a, gross);\\n-    if (!a)\\n-        return NULL;\\n+    if (pool->quotap) {\\n+        growth = gross - (a->limit - (jsuword) a);\\n+        if (growth > *pool->quotap)\\n+            return NULL;\\n+        a = (JSArena *) realloc(a, gross);\\n+        if (!a)\\n+            return NULL;\\n+        *pool->quotap -= growth;\\n+    } else {\\n+        a = (JSArena *) realloc(a, gross);\\n+        if (!a)\\n+            return NULL;\\n+    }\\n #ifdef JS_ARENAMETER\\n     pool->stats.nreallocs++;\\n #endif\\n@@ -290,6 +311,8 @@ FreeArenaList(JSArenaPool *pool, JSArena *head)\\n \\n     do {\\n         *ap = a->next;\\n+        if (pool->quotap)\\n+            *pool->quotap += a->limit - (jsuword) a;\\n         JS_CLEAR_ARENA(a);\\n         JS_COUNT_ARENA(pool,--);\\n         free(a);\\n@@ -374,6 +397,8 @@ JS_ArenaFreeAllocation(JSArenaPool *pool, void *p, size_t size)\\n         JS_ASSERT(GET_HEADER(pool, b) == &a->next);\\n         SET_HEADER(pool, b, ap);\\n     }\\n+    if (pool->quotap)\\n+        *pool->quotap += a->limit - (jsuword) a;\\n     JS_CLEAR_ARENA(a);\\n     JS_COUNT_ARENA(pool,--);\\n     free(a);\\ndiff --git a/js/src/jsarena.h b/js/src/jsarena.h\\nindex f75ec9f..8affbfe 100644\\n--- a/js/src/jsarena.h\\n+++ b/js/src/jsarena.h\\n@@ -88,17 +88,19 @@ struct JSArenaPool {\\n     JSArena     *current;       /* arena from which to allocate space */\\n     size_t      arenasize;      /* net exact size of a new arena */\\n     jsuword     mask;           /* alignment mask (power-of-2 - 1) */\\n+    size_t      *quotap;        /* pointer to the quota on pool allocation\\n+                                   size or null if pool is unlimited */\\n #ifdef JS_ARENAMETER\\n     JSArenaStats stats;\\n #endif\\n };\\n \\n #ifdef JS_ARENAMETER\\n-#define JS_INIT_NAMED_ARENA_POOL(pool, name, size, align)                     \\\\\\n-    JS_InitArenaPool(pool, name, size, align)\\n+#define JS_INIT_NAMED_ARENA_POOL(pool, name, size, align, quotap)             \\\\\\n+    JS_InitArenaPool(pool, name, size, align, quotap)\\n #else\\n-#define JS_INIT_NAMED_ARENA_POOL(pool, name, size, align)                     \\\\\\n-    JS_InitArenaPool(pool, size, align)\\n+#define JS_INIT_NAMED_ARENA_POOL(pool, name, size, align, quotap)             \\\\\\n+    JS_InitArenaPool(pool, size, align, quotap)\\n #endif\\n \\n /*\\n@@ -110,14 +112,15 @@ struct JSArenaPool {\\n #define JS_ARENA_ALIGN(pool, n) (((jsuword)(n) + JS_ARENA_CONST_ALIGN_MASK)   \\\\\\n                                  & ~(jsuword)JS_ARENA_CONST_ALIGN_MASK)\\n \\n-#define JS_INIT_ARENA_POOL(pool, name, size)                                  \\\\\\n-    JS_INIT_NAMED_ARENA_POOL(pool, name, size, JS_ARENA_CONST_ALIGN_MASK + 1)\\n+#define JS_INIT_ARENA_POOL(pool, name, size, quotap)                          \\\\\\n+    JS_INIT_NAMED_ARENA_POOL(pool, name, size, JS_ARENA_CONST_ALIGN_MASK + 1, \\\\\\n+                             quotap)\\n \\n #else\\n #define JS_ARENA_ALIGN(pool, n) (((jsuword)(n) + (pool)->mask) & ~(pool)->mask)\\n \\n-#define JS_INIT_ARENA_POOL(pool, name, size, align)                           \\\\\\n-    JS_INIT_NAMED_ARENA_POOL(pool, name, size, align)\\n+#define JS_INIT_ARENA_POOL(pool, name, size, align, quotap)                   \\\\\\n+    JS_INIT_NAMED_ARENA_POOL(pool, name, size, align, quotap)\\n \\n #endif\\n \\n@@ -235,7 +238,7 @@ struct JSArenaPool {\\n  */\\n extern JS_PUBLIC_API(void)\\n JS_INIT_NAMED_ARENA_POOL(JSArenaPool *pool, const char *name, size_t size,\\n-                         size_t align);\\n+                         size_t align, size_t *quotap);\\n \\n /*\\n  * Free the arenas in pool.  The user may continue to allocate from pool\\ndiff --git a/js/src/jscntxt.c b/js/src/jscntxt.c\\nindex 58d76fa..d4db418 100644\\n--- a/js/src/jscntxt.c\\n+++ b/js/src/jscntxt.c\\n@@ -229,6 +229,7 @@ js_NewContext(JSRuntime *rt, size_t stackChunkSize)\\n #if JS_STACK_GROWTH_DIRECTION > 0\\n     cx->stackLimit = (jsuword)-1;\\n #endif\\n+    cx->scriptStackQuota = JS_DEFAULT_SCRIPT_STACK_QUOTA;\\n #ifdef JS_THREADSAFE\\n     JS_INIT_CLIST(&cx->threadLinks);\\n     js_SetContextThread(cx);\\n@@ -259,8 +260,10 @@ js_NewContext(JSRuntime *rt, size_t stackChunkSize)\\n      * done by js_DestroyContext).\\n      */\\n     cx->version = JSVERSION_DEFAULT;\\n-    JS_INIT_ARENA_POOL(&cx->stackPool, \\\"stack\\\", stackChunkSize, sizeof(jsval));\\n-    JS_INIT_ARENA_POOL(&cx->tempPool, \\\"temp\\\", 1024, sizeof(jsdouble));\\n+    JS_INIT_ARENA_POOL(&cx->stackPool, \\\"stack\\\", stackChunkSize, sizeof(jsval),\\n+                       &cx->scriptStackQuota);\\n+    JS_INIT_ARENA_POOL(&cx->tempPool, \\\"temp\\\", 1024, sizeof(jsdouble),\\n+                       &cx->scriptStackQuota);\\n \\n     if (!js_InitRegExpStatics(cx, &cx->regExpStatics)) {\\n         js_DestroyContext(cx, JSDCM_NEW_FAILED);\\ndiff --git a/js/src/jscntxt.h b/js/src/jscntxt.h\\nindex e8cce7a..edf9f87 100644\\n--- a/js/src/jscntxt.h\\n+++ b/js/src/jscntxt.h\\n@@ -689,9 +689,12 @@ struct JSContext {\\n     JSPackedBool        throwing;           /* is there a pending exception? */\\n     jsval               exception;          /* most-recently-thrown exception */\\n \\n-    /* Limit pointer for checking stack consumption during recursion. */\\n+    /* Limit pointer for checking native stack consumption during recursion. */\\n     jsuword             stackLimit;\\n \\n+    /* Quota on the size of arenas used to compile and execute scripts. */\\n+    size_t              scriptStackQuota;\\n+\\n     /* Data shared by threads in an address space. */\\n     JSRuntime           *runtime;\\n \\ndiff --git a/js/src/jsopcode.c b/js/src/jsopcode.c\\nindex 0d5064e..6f62b85 100644\\n--- a/js/src/jsopcode.c\\n+++ b/js/src/jsopcode.c\\n@@ -673,7 +673,7 @@ JS_NEW_PRINTER(JSContext *cx, const char *name, uintN indent, JSBool pretty)\\n     if (!jp)\\n         return NULL;\\n     INIT_SPRINTER(cx, &jp->sprinter, &jp->pool, 0);\\n-    JS_INIT_ARENA_POOL(&jp->pool, name, 256, 1);\\n+    JS_INIT_ARENA_POOL(&jp->pool, name, 256, 1, &cx->scriptStackQuota);\\n     jp->indent = indent & ~JS_IN_GROUP_CONTEXT;\\n     jp->pretty = pretty;\\n     jp->grouped = (indent & JS_IN_GROUP_CONTEXT) != 0;\\ndiff --git a/js/src/jsparse.c b/js/src/jsparse.c\\nindex 339fecb..31d3954 100644\\n--- a/js/src/jsparse.c\\n+++ b/js/src/jsparse.c\\n@@ -879,8 +879,10 @@ js_CompileFunctionBody(JSContext *cx, JSTokenStream *ts, JSFunction *fun)\\n     JSObject *funobj;\\n     JSParseNode *pn;\\n \\n-    JS_INIT_ARENA_POOL(&codePool, \\\"code\\\", 1024, sizeof(jsbytecode));\\n-    JS_INIT_ARENA_POOL(&notePool, \\\"note\\\", 1024, sizeof(jssrcnote));\\n+    JS_INIT_ARENA_POOL(&codePool, \\\"code\\\", 1024, sizeof(jsbytecode),\\n+                       &cx->scriptStackQuota);\\n+    JS_INIT_ARENA_POOL(&notePool, \\\"note\\\", 1024, sizeof(jssrcnote),\\n+                       &cx->scriptStackQuota);\\n     js_InitParseContext(cx, &pc);\\n     JS_ASSERT(!ts->parseContext);\\n     ts->parseContext = &pc;\\ndiff --git a/js/src/jsregexp.c b/js/src/jsregexp.c\\nindex db463c0..4257a95 100644\\n--- a/js/src/jsregexp.c\\n+++ b/js/src/jsregexp.c\\n@@ -3382,7 +3382,8 @@ js_ExecuteRegExp(JSContext *cx, JSRegExp *re, JSString *str, size_t *indexp,\\n     gData.start = start;\\n     gData.skipped = 0;\\n \\n-    JS_INIT_ARENA_POOL(&gData.pool, \\\"RegExpPool\\\", 8096, 4);\\n+    JS_INIT_ARENA_POOL(&gData.pool, \\\"RegExpPool\\\", 8096, 4,\\n+                       &cx->scriptStackQuota);\\n     x = InitMatch(cx, &gData, re, length);\\n \\n     if (!x) {\\ndiff --git a/js/src/jsscope.c b/js/src/jsscope.c\\nindex e6fe574..7578536 100644\\n--- a/js/src/jsscope.c\\n+++ b/js/src/jsscope.c\\n@@ -1950,7 +1950,7 @@ js_InitPropertyTree(JSRuntime *rt)\\n         return JS_FALSE;\\n     }\\n     JS_INIT_ARENA_POOL(&rt->propertyArenaPool, \\\"properties\\\",\\n-                       256 * sizeof(JSScopeProperty), sizeof(void *));\\n+                       256 * sizeof(JSScopeProperty), sizeof(void *), NULL);\\n     return JS_TRUE;\\n }\\n \\n\""}