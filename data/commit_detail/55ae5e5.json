{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas55ae5e5\""},"diff":"\"55ae5e5 Fix crash bug 393517.  r+sr=roc, a=dbaron\\ndiff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp\\nindex 879a340..5cda87c 100644\\n--- a/layout/base/nsCSSFrameConstructor.cpp\\n+++ b/layout/base/nsCSSFrameConstructor.cpp\\n@@ -440,6 +440,28 @@ GetFieldSetAreaFrame(nsIFrame* aFieldsetFrame)\\n }\\n \\n //----------------------------------------------------------------------\\n+\\n+static PRBool\\n+IsInlineOutside(nsIFrame* aFrame)\\n+{\\n+  return aFrame->GetStyleDisplay()->IsInlineOutside();\\n+}\\n+\\n+/**\\n+ * True if aFrame is an actual inline frame in the sense of non-replaced\\n+ * display:inline CSS boxes.  In other words, it can be affected by {ib}\\n+ * splitting and can contain first-letter frames.  Basically, this is either an\\n+ * inline frame (positioned or otherwise) or an line frame (this last because\\n+ * it can contain first-letter and because inserting blocks in the middle of it\\n+ * needs to terminate it).\\n+ */\\n+static PRBool\\n+IsInlineFrame(const nsIFrame* aFrame)\\n+{\\n+  return aFrame->IsFrameOfType(nsIFrame::eLineParticipant);\\n+}\\n+\\n+//----------------------------------------------------------------------\\n //\\n // When inline frames get weird and have block frames in them, we\\n // annotate them to help us respond to incremental content changes\\n@@ -463,6 +485,20 @@ static nsIFrame* GetSpecialSibling(nsIFrame* aFrame)\\n }\\n \\n static nsIFrame*\\n+GetIBSplitSpecialPrevSibling(nsIFrame* aFrame)\\n+{\\n+  NS_PRECONDITION(IsFrameSpecial(aFrame) && !IsInlineFrame(aFrame),\\n+                  \\\"Shouldn't call this\\\");\\n+  \\n+  // We only store the \\\"special sibling\\\" annotation with the first\\n+  // frame in the continuation chain. Walk back to find that frame now.  \\n+  return\\n+    static_cast<nsIFrame*>\\n+    (aFrame->GetFirstContinuation()->\\n+       GetProperty(nsGkAtoms::IBSplitSpecialPrevSibling));\\n+}\\n+\\n+static nsIFrame*\\n GetLastSpecialSibling(nsIFrame* aFrame)\\n {\\n   for (nsIFrame *frame = aFrame, *next; ; frame = next) {\\n@@ -530,28 +566,6 @@ GetIBContainingBlockFor(nsIFrame* aFrame)\\n \\n //----------------------------------------------------------------------\\n \\n-static PRBool\\n-IsInlineOutside(nsIFrame* aFrame)\\n-{\\n-  return aFrame->GetStyleDisplay()->IsInlineOutside();\\n-}\\n-\\n-/**\\n- * True if aFrame is an actual inline frame in the sense of non-replaced\\n- * display:inline CSS boxes.  In other words, it can be affected by {ib}\\n- * splitting and can contain first-letter frames.  Basically, this is either an\\n- * inline frame (positioned or otherwise) or an line frame (this last because\\n- * it can contain first-letter and because inserting blocks in the middle of it\\n- * needs to terminate it).\\n- */\\n-static PRBool\\n-IsInlineFrame(const nsIFrame* aFrame)\\n-{\\n-  return aFrame->IsFrameOfType(nsIFrame::eLineParticipant);\\n-}\\n-\\n-//----------------------------------------------------------------------\\n-\\n // Block/inline frame construction logic. We maintain a few invariants here:\\n //\\n // 1. Block frames contain block and inline frames.\\n@@ -600,13 +614,11 @@ FindLastBlock(nsIFrame* aKid)\\n  * (if the real parent has NS_FRAME_IS_SPECIAL).\\n  */\\n inline void\\n-MarkIBSpecialPrevSibling(nsPresContext* aPresContext,\\n-                         nsIFrame *aAnonymousFrame,\\n+MarkIBSpecialPrevSibling(nsIFrame *aAnonymousFrame,\\n                          nsIFrame *aSpecialParent)\\n {\\n-  aPresContext->PropertyTable()->SetProperty(aAnonymousFrame,\\n-                                      nsGkAtoms::IBSplitSpecialPrevSibling,\\n-                                             aSpecialParent, nsnull, nsnull);\\n+  aAnonymousFrame->SetProperty(nsGkAtoms::IBSplitSpecialPrevSibling,\\n+                               aSpecialParent, nsnull, nsnull);\\n }\\n \\n // -----------------------------------------------------------\\n@@ -7933,11 +7945,7 @@ nsCSSFrameConstructor::AppendFrames(nsFrameConstructorState&       aState,\\n       nsIContent* content = nsnull;\\n       nsStyleContext* styleContext = nsnull;\\n       if (!inlineSibling) {\\n-        nsIFrame* firstInline =\\n-          static_cast<nsIFrame*>\\n-                     (aState.mPresContext->PropertyTable()->\\n-                      GetProperty(parentFrame->GetFirstContinuation(),\\n-                                  nsGkAtoms::IBSplitSpecialPrevSibling));\\n+        nsIFrame* firstInline = GetIBSplitSpecialPrevSibling(parentFrame);\\n         NS_ASSERTION(firstInline, \\\"How did that happen?\\\");\\n \\n         content = firstInline->GetContent();\\n@@ -12447,7 +12455,7 @@ nsCSSFrameConstructor::ConstructInline(nsFrameConstructorState& aState,\\n   // reframed instead.\\n   SetFrameIsSpecial(aNewFrame, blockFrame);\\n   SetFrameIsSpecial(blockFrame, inlineFrame);\\n-  MarkIBSpecialPrevSibling(aState.mPresContext, blockFrame, aNewFrame);\\n+  MarkIBSpecialPrevSibling(blockFrame, aNewFrame);\\n \\n #ifdef DEBUG\\n   if (gNoisyInlineConstruction) {\\n@@ -12652,8 +12660,27 @@ nsCSSFrameConstructor::WipeContainingBlock(nsFrameConstructorState& aState,\\n     // aFrame is the block in an {ib} split.  Check that we're not\\n     // messing up either end of it.\\n     if (aIsAppend) {\\n-      // Will be handled in AppendFrames()\\n-      return PR_FALSE;\\n+      // Will be handled in AppendFrames(), unless we have floats that we can't\\n+      // move out because there might be no float containing block to move them\\n+      // into.\\n+      if (!aState.mFloatedItems.childList) {\\n+        return PR_FALSE;\\n+      }\\n+\\n+      // Walk up until we get a float containing block that's not part of an\\n+      // {ib} split, since otherwise we might have to ship floats out of it\\n+      // too.\\n+      nsIFrame* floatContainer = aFrame;\\n+      do {\\n+        floatContainer =\\n+          GetFloatContainingBlock(GetIBSplitSpecialPrevSibling(floatContainer));\\n+        if (!floatContainer) {\\n+          break;\\n+        }\\n+        if (!IsFrameSpecial(floatContainer)) {\\n+          return PR_FALSE;\\n+        }\\n+      } while (1);\\n     }\\n     \\n     if (aPrevSibling && !aPrevSibling->GetNextSibling()) {\\n\""}