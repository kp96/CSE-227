{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas18a9bbe\""},"diff":"\"18a9bbe Set the script's filename correctly and don't treat the lack of a filename as a failure. bug 391470, r+sr=bzbarsky\\ndiff --git a/dom/public/nsIScriptTimeoutHandler.h b/dom/public/nsIScriptTimeoutHandler.h\\nindex b02e950..1ac0363 100644\\n--- a/dom/public/nsIScriptTimeoutHandler.h\\n+++ b/dom/public/nsIScriptTimeoutHandler.h\\n@@ -68,6 +68,8 @@ public:\\n   virtual const PRUnichar *GetHandlerText() = 0;\\n \\n   // Get the location of the script.\\n+  // Note: The memory pointed to by aFileName is owned by the\\n+  // nsIScriptTimeoutHandler and should not be freed by the caller.\\n   virtual void GetLocation(const char **aFileName, PRUint32 *aLineNo) = 0;\\n \\n   // If a script object, get the argv suitable for passing back to the\\ndiff --git a/dom/src/base/nsJSTimeoutHandler.cpp b/dom/src/base/nsJSTimeoutHandler.cpp\\nindex e1f49c1..b2dd3e8 100644\\n--- a/dom/src/base/nsJSTimeoutHandler.cpp\\n+++ b/dom/src/base/nsJSTimeoutHandler.cpp\\n@@ -285,6 +285,12 @@ nsJSScriptTimeoutHandler::Init(nsIScriptContext *aContext, PRBool *aIsInterval,\\n     }\\n \\n     mExpr = expr;\\n+\\n+    // Get the calling location.\\n+    const char *filename;\\n+    if (nsJSUtils::GetCallingLocation(cx, &filename, &mLineNo)) {\\n+      mFileName.Assign(filename);\\n+    }\\n   } else if (funobj) {\\n     if (!::JS_AddNamedRoot(cx, &mFunObj, \\\"timeout.mFunObj\\\")) {\\n       return NS_ERROR_OUT_OF_MEMORY;\\n@@ -301,10 +307,12 @@ nsJSScriptTimeoutHandler::Init(nsIScriptContext *aContext, PRBool *aIsInterval,\\n     if (NS_FAILED(rv)) {\\n       return NS_ERROR_OUT_OF_MEMORY;\\n     }\\n+\\n     PRUint32 dummy;\\n     jsval *jsargv = nsnull;\\n     nsCOMPtr<nsIJSArgArray> jsarray(do_QueryInterface(array));\\n     jsarray->GetArgs(&dummy, reinterpret_cast<void **>(&jsargv));\\n+\\n     // must have worked - we own the impl! :)\\n     NS_ASSERTION(jsargv, \\\"No argv!\\\");\\n     for (PRInt32 i = 2; (PRUint32)i < argc; ++i) {\\n@@ -312,17 +320,6 @@ nsJSScriptTimeoutHandler::Init(nsIScriptContext *aContext, PRBool *aIsInterval,\\n     }\\n     // final arg slot remains null, array has rooted vals.\\n     mArgv = array;\\n-\\n-    // Get the calling location.\\n-    const char *filename;\\n-    if (nsJSUtils::GetCallingLocation(cx, &filename, &mLineNo)) {\\n-      mFileName.Assign(filename);\\n-\\n-      if (mFileName.IsEmpty()) {\\n-        return NS_ERROR_OUT_OF_MEMORY;\\n-      }\\n-    }\\n-\\n   } else {\\n     NS_WARNING(\\\"No func and no expr - why are we here?\\\");\\n   }\\n\""}