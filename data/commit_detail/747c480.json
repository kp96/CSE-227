{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas747c480\""},"diff":"\"747c480 Adding npruntime scriptability sample. A dumb sample, but it's all we've got an I have no time to make it better now. Not part of the build.\\ndiff --git a/modules/plugin/samples/npruntime/Makefile.in b/modules/plugin/samples/npruntime/Makefile.in\\nnew file mode 100644\\nindex 0000000..f5de94f\\n--- /dev/null\\n+++ b/modules/plugin/samples/npruntime/Makefile.in\\n@@ -0,0 +1,68 @@\\n+############################################################################\\n+## Makefile.in (Generic SANE Plugin Tree)\\n+##\\n+## The contents of this file are subject to the Mozilla Public\\n+## License Version 1.1 (the \\\"License\\\"); you may not use this file\\n+## except in compliance with the License. You may obtain a copy of\\n+## the License at http://www.mozilla.org/MPL/\\n+##\\n+## Software distributed under the License is distributed on an \\\"AS\\n+## IS\\\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\\n+## implied. See the License for the specific language governing\\n+## rights and limitations under the License.\\n+## Contributor(s): \\n+##\\n+##   Rusty Lynch <rusty.lynch@intel.com>\\n+############################################################################\\n+\\n+DEPTH\\t\\t= ../../../..\\n+topsrcdir\\t= @top_srcdir@\\n+srcdir\\t\\t= @srcdir@\\n+VPATH\\t\\t= @srcdir@\\n+\\n+include $(DEPTH)/config/autoconf.mk\\n+\\n+MODULE\\t\\t= plugin\\n+LIBRARY_NAME\\t= nprt\\n+ifeq ($(OS_ARCH),WINNT)\\n+RESFILE\\t\\t= nprt.res\\n+DEFFILE\\t\\t= $(srcdir)/nprt.def\\n+endif\\n+\\n+# plugins should always be shared, even in the \\\"static\\\" build\\n+FORCE_SHARED_LIB = 1\\n+\\n+# Force use of PIC\\n+FORCE_USE_PIC\\t= 1\\n+\\n+NO_DIST_INSTALL\\t= 1\\n+NO_INSTALL = 1\\n+\\n+CPPSRCS = \\\\\\n+\\tnp_entry.cpp\\t\\t\\\\\\n+\\tnpn_gate.cpp\\t\\t\\\\\\n+\\tnpp_gate.cpp\\t\\t\\\\\\n+\\tplugin.cpp\\t\\t\\\\\\n+\\t$(NULL)\\n+\\n+REQUIRES = \\\\\\n+\\t\\tplugin\\t\\t\\\\\\n+\\t\\tjava\\t\\t\\\\\\n+\\t\\t$(NULL)\\n+\\n+LOCAL_INCLUDES  = -I$(srcdir)/.. -I$(srcdir)/../../public \\\\\\n+\\t\\t  -I/usr/lib/glib/include \\n+\\n+include $(topsrcdir)/config/rules.mk\\n+\\n+install-plugin: $(SHARED_LIBRARY)\\n+ifdef SHARED_LIBRARY\\n+\\t$(INSTALL) $(SHARED_LIBRARY) $(DIST)/bin/plugins\\n+endif\\n+\\n+libs:: install-plugin\\n+\\n+install:: $(SHARED_LIBRARY)\\n+ifdef SHARED_LIBRARY\\n+\\t$(SYSINSTALL) $(IFLAGS2) $< $(DESTDIR)$(mozappdir)/plugins\\n+endif\\ndiff --git a/modules/plugin/samples/npruntime/np_entry.cpp b/modules/plugin/samples/npruntime/np_entry.cpp\\nnew file mode 100644\\nindex 0000000..4a2d66b\\n--- /dev/null\\n+++ b/modules/plugin/samples/npruntime/np_entry.cpp\\n@@ -0,0 +1,189 @@\\n+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: NPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Netscape Public License\\n+ * Version 1.1 (the \\\"License\\\"); you may not use this file except in\\n+ * compliance with the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/NPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is mozilla.org code.\\n+ *\\n+ * The Initial Developer of the Original Code is \\n+ * Netscape Communications Corporation.\\n+ * Portions created by the Initial Developer are Copyright (C) 1998\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or \\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the NPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the NPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+\\n+//////////////////////////////////////////////////////////////\\n+//\\n+// Main plugin entry point implementation\\n+//\\n+#include \\\"npapi.h\\\"\\n+#include \\\"npupp.h\\\"\\n+\\n+#ifndef HIBYTE\\n+#define HIBYTE(x) ((((uint32)(x)) & 0xff00) >> 8)\\n+#endif\\n+\\n+NPNetscapeFuncs NPNFuncs;\\n+\\n+#ifdef XP_WIN\\n+\\n+NPError OSCALL NP_GetEntryPoints(NPPluginFuncs* pFuncs)\\n+{\\n+  if(pFuncs == NULL)\\n+    return NPERR_INVALID_FUNCTABLE_ERROR;\\n+\\n+  if(pFuncs->size < sizeof(NPPluginFuncs))\\n+    return NPERR_INVALID_FUNCTABLE_ERROR;\\n+\\n+  pFuncs->version       = (NP_VERSION_MAJOR << 8) | NP_VERSION_MINOR;\\n+  pFuncs->newp          = NPP_New;\\n+  pFuncs->destroy       = NPP_Destroy;\\n+  pFuncs->setwindow     = NPP_SetWindow;\\n+  pFuncs->newstream     = NPP_NewStream;\\n+  pFuncs->destroystream = NPP_DestroyStream;\\n+  pFuncs->asfile        = NPP_StreamAsFile;\\n+  pFuncs->writeready    = NPP_WriteReady;\\n+  pFuncs->write         = NPP_Write;\\n+  pFuncs->print         = NPP_Print;\\n+  pFuncs->event         = NPP_HandleEvent;\\n+  pFuncs->urlnotify     = NPP_URLNotify;\\n+  pFuncs->getvalue      = NPP_GetValue;\\n+  pFuncs->setvalue      = NPP_SetValue;\\n+  pFuncs->javaClass     = NULL;\\n+\\n+  return NPERR_NO_ERROR;\\n+}\\n+\\n+#endif /* XP_WIN */\\n+\\n+char *NPP_GetMIMEDescription();\\n+\\n+char *\\n+NP_GetMIMEDescription()\\n+{\\n+  return NPP_GetMIMEDescription();\\n+}\\n+\\n+NPError\\n+NP_GetValue(void* future, NPPVariable variable, void *value)\\n+{\\n+  return NPP_GetValue((NPP_t *)future, variable, value);\\n+}\\n+\\n+NPError OSCALL\\n+NP_Initialize(NPNetscapeFuncs* pFuncs\\n+#ifdef XP_UNIX\\n+              , NPPluginFuncs* pluginFuncs\\n+#endif\\n+              )\\n+{\\n+  if(pFuncs == NULL)\\n+    return NPERR_INVALID_FUNCTABLE_ERROR;\\n+\\n+  if(HIBYTE(pFuncs->version) > NP_VERSION_MAJOR)\\n+    return NPERR_INCOMPATIBLE_VERSION_ERROR;\\n+\\n+  if(pFuncs->size < sizeof(NPNetscapeFuncs))\\n+    return NPERR_INVALID_FUNCTABLE_ERROR;\\n+\\n+  NPNFuncs.size                    = pFuncs->size;\\n+  NPNFuncs.version                 = pFuncs->version;\\n+  NPNFuncs.geturlnotify            = pFuncs->geturlnotify;\\n+  NPNFuncs.geturl                  = pFuncs->geturl;\\n+  NPNFuncs.posturlnotify           = pFuncs->posturlnotify;\\n+  NPNFuncs.posturl                 = pFuncs->posturl;\\n+  NPNFuncs.requestread             = pFuncs->requestread;\\n+  NPNFuncs.newstream               = pFuncs->newstream;\\n+  NPNFuncs.write                   = pFuncs->write;\\n+  NPNFuncs.destroystream           = pFuncs->destroystream;\\n+  NPNFuncs.status                  = pFuncs->status;\\n+  NPNFuncs.uagent                  = pFuncs->uagent;\\n+  NPNFuncs.memalloc                = pFuncs->memalloc;\\n+  NPNFuncs.memfree                 = pFuncs->memfree;\\n+  NPNFuncs.memflush                = pFuncs->memflush;\\n+  NPNFuncs.reloadplugins           = pFuncs->reloadplugins;\\n+  NPNFuncs.getJavaEnv              = pFuncs->getJavaEnv;\\n+  NPNFuncs.getJavaPeer             = pFuncs->getJavaPeer;\\n+  NPNFuncs.getvalue                = pFuncs->getvalue;\\n+  NPNFuncs.setvalue                = pFuncs->setvalue;\\n+  NPNFuncs.invalidaterect          = pFuncs->invalidaterect;\\n+  NPNFuncs.invalidateregion        = pFuncs->invalidateregion;\\n+  NPNFuncs.forceredraw             = pFuncs->forceredraw;\\n+  NPNFuncs.getstringidentifier     = pFuncs->getstringidentifier;\\n+  NPNFuncs.getstringidentifiers    = pFuncs->getstringidentifiers;\\n+  NPNFuncs.getintidentifier        = pFuncs->getintidentifier;\\n+  NPNFuncs.identifierisstring      = pFuncs->identifierisstring;\\n+  NPNFuncs.utf8fromidentifier      = pFuncs->utf8fromidentifier;\\n+  NPNFuncs.intfromidentifier       = pFuncs->intfromidentifier;\\n+  NPNFuncs.createobject            = pFuncs->createobject;\\n+  NPNFuncs.retainobject            = pFuncs->retainobject;\\n+  NPNFuncs.releaseobject           = pFuncs->releaseobject;\\n+  NPNFuncs.invoke                  = pFuncs->invoke;\\n+  NPNFuncs.invokeDefault           = pFuncs->invokeDefault;\\n+  NPNFuncs.evaluate                = pFuncs->evaluate;\\n+  NPNFuncs.getproperty             = pFuncs->getproperty;\\n+  NPNFuncs.setproperty             = pFuncs->setproperty;\\n+  NPNFuncs.removeproperty          = pFuncs->removeproperty;\\n+  NPNFuncs.hasproperty             = pFuncs->hasproperty;\\n+  NPNFuncs.hasmethod               = pFuncs->hasmethod;\\n+  NPNFuncs.releasevariantvalue     = pFuncs->releasevariantvalue;\\n+  NPNFuncs.setexception            = pFuncs->setexception;\\n+\\n+#ifdef XP_UNIX\\n+  /*\\n+   * Set up the plugin function table that Netscape will use to\\n+   * call us.  Netscape needs to know about our version and size\\n+   * and have a UniversalProcPointer for every function we\\n+   * implement.\\n+   */\\n+  pluginFuncs->version    = (NP_VERSION_MAJOR << 8) + NP_VERSION_MINOR;\\n+  pluginFuncs->size       = sizeof(NPPluginFuncs);\\n+  pluginFuncs->newp       = NewNPP_NewProc(NPP_New);\\n+  pluginFuncs->destroy    = NewNPP_DestroyProc(NPP_Destroy);\\n+  pluginFuncs->setwindow  = NewNPP_SetWindowProc(NPP_SetWindow);\\n+  pluginFuncs->newstream  = NewNPP_NewStreamProc(NPP_NewStream);\\n+  pluginFuncs->destroystream = NewNPP_DestroyStreamProc(NPP_DestroyStream);\\n+  pluginFuncs->asfile     = NewNPP_StreamAsFileProc(NPP_StreamAsFile);\\n+  pluginFuncs->writeready = NewNPP_WriteReadyProc(NPP_WriteReady);\\n+  pluginFuncs->write      = NewNPP_WriteProc(NPP_Write);\\n+  pluginFuncs->print      = NewNPP_PrintProc(NPP_Print);\\n+  pluginFuncs->urlnotify  = NewNPP_URLNotifyProc(NPP_URLNotify);\\n+  pluginFuncs->event      = NULL;\\n+  pluginFuncs->getvalue   = NewNPP_GetValueProc(NPP_GetValue);\\n+#ifdef OJI\\n+  pluginFuncs->javaClass  = NPP_GetJavaClass();\\n+#endif\\n+\\n+  NPP_Initialize();\\n+#endif\\n+\\n+  return NPERR_NO_ERROR;\\n+}\\n+\\n+NPError OSCALL NP_Shutdown()\\n+{\\n+  return NPERR_NO_ERROR;\\n+}\\ndiff --git a/modules/plugin/samples/npruntime/npn_gate.cpp b/modules/plugin/samples/npruntime/npn_gate.cpp\\nnew file mode 100644\\nindex 0000000..821e150\\n--- /dev/null\\n+++ b/modules/plugin/samples/npruntime/npn_gate.cpp\\n@@ -0,0 +1,334 @@\\n+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: NPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Netscape Public License\\n+ * Version 1.1 (the \\\"License\\\"); you may not use this file except in\\n+ * compliance with the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/NPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is mozilla.org code.\\n+ *\\n+ * The Initial Developer of the Original Code is \\n+ * Netscape Communications Corporation.\\n+ * Portions created by the Initial Developer are Copyright (C) 1998\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or \\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the NPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the NPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+\\n+////////////////////////////////////////////////////////////\\n+//\\n+// Implementation of Netscape entry points (NPN_*)\\n+//\\n+#include \\\"npapi.h\\\"\\n+#include \\\"npupp.h\\\"\\n+\\n+#ifndef HIBYTE\\n+#define HIBYTE(x) ((((uint32)(x)) & 0xff00) >> 8)\\n+#endif\\n+\\n+#ifndef LOBYTE\\n+#define LOBYTE(W) ((W) & 0xFF)\\n+#endif\\n+\\n+extern NPNetscapeFuncs NPNFuncs;\\n+\\n+void NPN_Version(int* plugin_major, int* plugin_minor, int* netscape_major, int* netscape_minor)\\n+{\\n+  *plugin_major   = NP_VERSION_MAJOR;\\n+  *plugin_minor   = NP_VERSION_MINOR;\\n+  *netscape_major = HIBYTE(NPNFuncs.version);\\n+  *netscape_minor = LOBYTE(NPNFuncs.version);\\n+}\\n+\\n+NPError NPN_GetURLNotify(NPP instance, const char *url, const char *target, void* notifyData)\\n+{\\n+\\tint navMinorVers = NPNFuncs.version & 0xFF;\\n+  NPError rv = NPERR_NO_ERROR;\\n+\\n+  if( navMinorVers >= NPVERS_HAS_NOTIFICATION )\\n+\\t\\trv = NPNFuncs.geturlnotify(instance, url, target, notifyData);\\n+\\telse\\n+\\t\\trv = NPERR_INCOMPATIBLE_VERSION_ERROR;\\n+\\n+  return rv;\\n+}\\n+\\n+NPError NPN_GetURL(NPP instance, const char *url, const char *target)\\n+{\\n+  NPError rv = NPNFuncs.geturl(instance, url, target);\\n+  return rv;\\n+}\\n+\\n+NPError NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file, void* notifyData)\\n+{\\n+\\tint navMinorVers = NPNFuncs.version & 0xFF;\\n+  NPError rv = NPERR_NO_ERROR;\\n+\\n+\\tif( navMinorVers >= NPVERS_HAS_NOTIFICATION )\\n+\\t\\trv = NPNFuncs.posturlnotify(instance, url, window, len, buf, file, notifyData);\\n+\\telse\\n+\\t\\trv = NPERR_INCOMPATIBLE_VERSION_ERROR;\\n+\\n+  return rv;\\n+}\\n+\\n+NPError NPN_PostURL(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file)\\n+{\\n+  NPError rv = NPNFuncs.posturl(instance, url, window, len, buf, file);\\n+  return rv;\\n+} \\n+\\n+NPError NPN_RequestRead(NPStream* stream, NPByteRange* rangeList)\\n+{\\n+  NPError rv = NPNFuncs.requestread(stream, rangeList);\\n+  return rv;\\n+}\\n+\\n+NPError NPN_NewStream(NPP instance, NPMIMEType type, const char* target, NPStream** stream)\\n+{\\n+\\tint navMinorVersion = NPNFuncs.version & 0xFF;\\n+\\n+  NPError rv = NPERR_NO_ERROR;\\n+\\n+\\tif( navMinorVersion >= NPVERS_HAS_STREAMOUTPUT )\\n+\\t\\trv = NPNFuncs.newstream(instance, type, target, stream);\\n+\\telse\\n+\\t\\trv = NPERR_INCOMPATIBLE_VERSION_ERROR;\\n+\\n+  return rv;\\n+}\\n+\\n+int32 NPN_Write(NPP instance, NPStream *stream, int32 len, void *buffer)\\n+{\\n+\\tint navMinorVersion = NPNFuncs.version & 0xFF;\\n+  int32 rv = 0;\\n+\\n+  if( navMinorVersion >= NPVERS_HAS_STREAMOUTPUT )\\n+\\t\\trv = NPNFuncs.write(instance, stream, len, buffer);\\n+\\telse\\n+\\t\\trv = -1;\\n+\\n+  return rv;\\n+}\\n+\\n+NPError NPN_DestroyStream(NPP instance, NPStream* stream, NPError reason)\\n+{\\n+\\tint navMinorVersion = NPNFuncs.version & 0xFF;\\n+  NPError rv = NPERR_NO_ERROR;\\n+\\n+  if( navMinorVersion >= NPVERS_HAS_STREAMOUTPUT )\\n+\\t\\trv = NPNFuncs.destroystream(instance, stream, reason);\\n+\\telse\\n+\\t\\trv = NPERR_INCOMPATIBLE_VERSION_ERROR;\\n+\\n+  return rv;\\n+}\\n+\\n+void NPN_Status(NPP instance, const char *message)\\n+{\\n+  NPNFuncs.status(instance, message);\\n+}\\n+\\n+const char* NPN_UserAgent(NPP instance)\\n+{\\n+  const char * rv = NULL;\\n+  rv = NPNFuncs.uagent(instance);\\n+  return rv;\\n+}\\n+\\n+void* NPN_MemAlloc(uint32 size)\\n+{\\n+  void * rv = NULL;\\n+  rv = NPNFuncs.memalloc(size);\\n+  return rv;\\n+}\\n+\\n+void NPN_MemFree(void* ptr)\\n+{\\n+  NPNFuncs.memfree(ptr);\\n+}\\n+\\n+uint32 NPN_MemFlush(uint32 size)\\n+{\\n+  uint32 rv = NPNFuncs.memflush(size);\\n+  return rv;\\n+}\\n+\\n+void NPN_ReloadPlugins(NPBool reloadPages)\\n+{\\n+  NPNFuncs.reloadplugins(reloadPages);\\n+}\\n+\\n+JRIEnv* NPN_GetJavaEnv(void)\\n+{\\n+  JRIEnv * rv = NULL;\\n+\\trv = NPNFuncs.getJavaEnv();\\n+  return rv;\\n+}\\n+\\n+jref NPN_GetJavaPeer(NPP instance)\\n+{\\n+  jref rv;\\n+\\trv = NPNFuncs.getJavaPeer(instance);\\n+  return rv;\\n+}\\n+\\n+NPError NPN_GetValue(NPP instance, NPNVariable variable, void *value)\\n+{\\n+  NPError rv = NPNFuncs.getvalue(instance, variable, value);\\n+  return rv;\\n+}\\n+\\n+NPError NPN_SetValue(NPP instance, NPPVariable variable, void *value)\\n+{\\n+  NPError rv = NPNFuncs.setvalue(instance, variable, value);\\n+  return rv;\\n+}\\n+\\n+void NPN_InvalidateRect(NPP instance, NPRect *invalidRect)\\n+{\\n+  NPNFuncs.invalidaterect(instance, invalidRect);\\n+}\\n+\\n+void NPN_InvalidateRegion(NPP instance, NPRegion invalidRegion)\\n+{\\n+  NPNFuncs.invalidateregion(instance, invalidRegion);\\n+}\\n+\\n+void NPN_ForceRedraw(NPP instance)\\n+{\\n+  NPNFuncs.forceredraw(instance);\\n+}\\n+\\n+NPIdentifier NPN_GetStringIdentifier(const NPUTF8 *name)\\n+{\\n+  return NPNFuncs.getstringidentifier(name);\\n+}\\n+\\n+void NPN_GetStringIdentifiers(const NPUTF8 **names, uint32_t nameCount,\\n+                              NPIdentifier *identifiers)\\n+{\\n+  return NPNFuncs.getstringidentifiers(names, nameCount, identifiers);\\n+}\\n+\\n+NPIdentifier NPN_GetStringIdentifier(int32_t intid)\\n+{\\n+  return NPNFuncs.getintidentifier(intid);\\n+}\\n+\\n+bool NPN_IdentifierIsString(NPIdentifier identifier)\\n+{\\n+  return NPNFuncs.identifierisstring(identifier);\\n+}\\n+\\n+NPUTF8 *NPN_UTF8FromIdentifier(NPIdentifier identifier)\\n+{\\n+  return NPNFuncs.utf8fromidentifier(identifier);\\n+}\\n+\\n+int32_t NPN_IntFromIdentifier(NPIdentifier identifier)\\n+{\\n+  return NPNFuncs.intfromidentifier(identifier);\\n+}\\n+\\n+NPObject *NPN_CreateObject(NPP npp, NPClass *aClass)\\n+{\\n+  return NPNFuncs.createobject(npp, aClass);\\n+}\\n+\\n+NPObject *NPN_RetainObject(NPObject *obj)\\n+{\\n+  return NPNFuncs.retainobject(obj);\\n+}\\n+\\n+void NPN_ReleaseObject(NPObject *obj)\\n+{\\n+  return NPNFuncs.releaseobject(obj);\\n+}\\n+\\n+bool NPN_Invoke(NPP npp, NPObject* obj, NPIdentifier methodName,\\n+                const NPVariant *args, uint32_t argCount, NPVariant *result)\\n+{\\n+  return NPNFuncs.invoke(npp, obj, methodName, args, argCount, result);\\n+}\\n+\\n+bool NPN_InvokeDefault(NPP npp, NPObject* obj, const NPVariant *args,\\n+                       uint32_t argCount, NPVariant *result)\\n+{\\n+  return NPNFuncs.invokeDefault(npp, obj, args, argCount, result);\\n+}\\n+\\n+bool NPN_Evaluate(NPP npp, NPObject* obj, NPString *script,\\n+                  NPVariant *result)\\n+{\\n+  return NPNFuncs.evaluate(npp, obj, script, result);\\n+}\\n+\\n+bool NPN_GetProperty(NPP npp, NPObject* obj, NPIdentifier propertyName,\\n+                     NPVariant *result)\\n+{\\n+  return NPNFuncs.getproperty(npp, obj, propertyName, result);\\n+}\\n+\\n+bool NPN_SetProperty(NPP npp, NPObject* obj, NPIdentifier propertyName,\\n+                     const NPVariant *value)\\n+{\\n+  return NPNFuncs.setproperty(npp, obj, propertyName, value);\\n+}\\n+\\n+bool NPN_RemoveProperty(NPP npp, NPObject* obj, NPIdentifier propertyName)\\n+{\\n+  return NPNFuncs.removeproperty(npp, obj, propertyName);\\n+}\\n+\\n+bool NPN_Enumerate(NPP npp, NPObject *obj, NPIdentifier **identifier,\\n+                   uint32_t *count)\\n+{\\n+  return NPNFuncs.enumerate(npp, obj, identifier, count);\\n+}\\n+\\n+bool NPN_Construct(NPP npp, NPObject *obj, const NPVariant *args,\\n+                   uint32_t argCount, NPVariant *result)\\n+{\\n+  return NPNFuncs.construct(npp, obj, args, argCount, result);\\n+}\\n+\\n+bool NPN_HasProperty(NPP npp, NPObject* obj, NPIdentifier propertyName)\\n+{\\n+  return NPNFuncs.hasproperty(npp, obj, propertyName);\\n+}\\n+\\n+bool NPN_HasMethod(NPP npp, NPObject* obj, NPIdentifier methodName)\\n+{\\n+  return NPNFuncs.hasmethod(npp, obj, methodName);\\n+}\\n+\\n+void NPN_ReleaseVariantValue(NPVariant *variant)\\n+{\\n+  NPNFuncs.releasevariantvalue(variant);\\n+}\\n+\\n+void NPN_SetException(NPObject* obj, const NPUTF8 *message)\\n+{\\n+  NPNFuncs.setexception(obj, message);\\n+}\\ndiff --git a/modules/plugin/samples/npruntime/npp_gate.cpp b/modules/plugin/samples/npruntime/npp_gate.cpp\\nnew file mode 100644\\nindex 0000000..0765117\\n--- /dev/null\\n+++ b/modules/plugin/samples/npruntime/npp_gate.cpp\\n@@ -0,0 +1,280 @@\\n+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: NPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Netscape Public License\\n+ * Version 1.1 (the \\\"License\\\"); you may not use this file except in\\n+ * compliance with the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/NPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is mozilla.org code.\\n+ *\\n+ * The Initial Developer of the Original Code is \\n+ * Netscape Communications Corporation.\\n+ * Portions created by the Initial Developer are Copyright (C) 1998\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or \\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the NPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the NPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+\\n+////////////////////////////////////////////////////////////\\n+//\\n+// Implementation of plugin entry points (NPP_*)\\n+// most are just empty stubs for this particular plugin \\n+//\\n+#include \\\"plugin.h\\\"\\n+\\n+char*\\n+NPP_GetMIMEDescription(void)\\n+{\\n+  return \\\"application/mozilla-npruntime-scriptable-plugin:.foo:Scriptability Demo Plugin\\\";\\n+}\\n+\\n+\\n+\\n+NPError NPP_Initialize(void)\\n+{\\n+  return NPERR_NO_ERROR;\\n+}\\n+\\n+void NPP_Shutdown(void)\\n+{\\n+}\\n+\\n+// here the plugin creates an instance of our CPlugin object which \\n+// will be associated with this newly created plugin instance and \\n+// will do all the neccessary job\\n+NPError NPP_New(NPMIMEType pluginType,\\n+                NPP instance,\\n+                uint16 mode,\\n+                int16 argc,\\n+                char* argn[],\\n+                char* argv[],\\n+                NPSavedData* saved)\\n+{   \\n+  if(instance == NULL)\\n+    return NPERR_INVALID_INSTANCE_ERROR;\\n+\\n+  NPError rv = NPERR_NO_ERROR;\\n+\\n+  CPlugin * pPlugin = new CPlugin(instance);\\n+  if(pPlugin == NULL)\\n+    return NPERR_OUT_OF_MEMORY_ERROR;\\n+\\n+  instance->pdata = (void *)pPlugin;\\n+  return rv;\\n+}\\n+\\n+// here is the place to clean up and destroy the CPlugin object\\n+NPError NPP_Destroy (NPP instance, NPSavedData** save)\\n+{\\n+  if(instance == NULL)\\n+    return NPERR_INVALID_INSTANCE_ERROR;\\n+\\n+  NPError rv = NPERR_NO_ERROR;\\n+\\n+  CPlugin * pPlugin = (CPlugin *)instance->pdata;\\n+  if(pPlugin != NULL) {\\n+    pPlugin->shut();\\n+    delete pPlugin;\\n+  }\\n+  return rv;\\n+}\\n+\\n+// during this call we know when the plugin window is ready or\\n+// is about to be destroyed so we can do some gui specific\\n+// initialization and shutdown\\n+NPError NPP_SetWindow (NPP instance, NPWindow* pNPWindow)\\n+{    \\n+  if(instance == NULL)\\n+    return NPERR_INVALID_INSTANCE_ERROR;\\n+\\n+  NPError rv = NPERR_NO_ERROR;\\n+\\n+  if(pNPWindow == NULL)\\n+    return NPERR_GENERIC_ERROR;\\n+\\n+  CPlugin * pPlugin = (CPlugin *)instance->pdata;\\n+\\n+  if(pPlugin == NULL) \\n+    return NPERR_GENERIC_ERROR;\\n+\\n+  // window just created\\n+  if(!pPlugin->isInitialized() && (pNPWindow->window != NULL)) { \\n+    if(!pPlugin->init(pNPWindow)) {\\n+      delete pPlugin;\\n+      pPlugin = NULL;\\n+      return NPERR_MODULE_LOAD_FAILED_ERROR;\\n+    }\\n+  }\\n+\\n+  // window goes away\\n+  if((pNPWindow->window == NULL) && pPlugin->isInitialized())\\n+    return NPERR_NO_ERROR;\\n+\\n+  // window resized\\n+  if(pPlugin->isInitialized() && (pNPWindow->window != NULL))\\n+    return NPERR_NO_ERROR;\\n+\\n+  // this should not happen, nothing to do\\n+  if((pNPWindow->window == NULL) && !pPlugin->isInitialized())\\n+    return NPERR_NO_ERROR;\\n+\\n+  return rv;\\n+}\\n+\\n+// ==============================\\n+// ! Scriptability related code !\\n+// ==============================\\n+//\\n+// here the plugin is asked by Mozilla to tell if it is scriptable\\n+// we should return a valid interface id and a pointer to \\n+// nsScriptablePeer interface which we should have implemented\\n+// and which should be defined in the corressponding *.xpt file\\n+// in the bin/components folder\\n+NPError\\tNPP_GetValue(NPP instance, NPPVariable variable, void *value)\\n+{\\n+  if(instance == NULL)\\n+    return NPERR_INVALID_INSTANCE_ERROR;\\n+\\n+  NPError rv = NPERR_NO_ERROR;\\n+\\n+  if(instance == NULL)\\n+    return NPERR_GENERIC_ERROR;\\n+\\n+  CPlugin * plugin = (CPlugin *)instance->pdata;\\n+  if(plugin == NULL)\\n+    return NPERR_GENERIC_ERROR;\\n+\\n+  switch (variable) {\\n+  case NPPVpluginNameString:\\n+    *((char **)value) = \\\"NPRuntimeTest\\\";\\n+    break;\\n+  case NPPVpluginDescriptionString:\\n+    *((char **)value) = \\\"NPRuntime scriptability API test plugin\\\";\\n+    break;\\n+  case NPPVpluginScriptableNPObject:\\n+    *(NPObject **)value = plugin->GetScriptableObject();\\n+    break;\\n+  default:\\n+    rv = NPERR_GENERIC_ERROR;\\n+  }\\n+\\n+  return rv;\\n+}\\n+\\n+NPError NPP_NewStream(NPP instance,\\n+                      NPMIMEType type,\\n+                      NPStream* stream, \\n+                      NPBool seekable,\\n+                      uint16* stype)\\n+{\\n+  if(instance == NULL)\\n+    return NPERR_INVALID_INSTANCE_ERROR;\\n+\\n+  NPError rv = NPERR_NO_ERROR;\\n+  return rv;\\n+}\\n+\\n+int32 NPP_WriteReady (NPP instance, NPStream *stream)\\n+{\\n+  if(instance == NULL)\\n+    return NPERR_INVALID_INSTANCE_ERROR;\\n+\\n+  int32 rv = 0x0fffffff;\\n+  return rv;\\n+}\\n+\\n+int32 NPP_Write (NPP instance, NPStream *stream, int32 offset, int32 len, void *buffer)\\n+{   \\n+  if(instance == NULL)\\n+    return NPERR_INVALID_INSTANCE_ERROR;\\n+\\n+  int32 rv = len;\\n+  return rv;\\n+}\\n+\\n+NPError NPP_DestroyStream (NPP instance, NPStream *stream, NPError reason)\\n+{\\n+  if(instance == NULL)\\n+    return NPERR_INVALID_INSTANCE_ERROR;\\n+\\n+  NPError rv = NPERR_NO_ERROR;\\n+  return rv;\\n+}\\n+\\n+void NPP_StreamAsFile (NPP instance, NPStream* stream, const char* fname)\\n+{\\n+  if(instance == NULL)\\n+    return;\\n+}\\n+\\n+void NPP_Print (NPP instance, NPPrint* printInfo)\\n+{\\n+  if(instance == NULL)\\n+    return;\\n+}\\n+\\n+void NPP_URLNotify(NPP instance, const char* url, NPReason reason, void* notifyData)\\n+{\\n+  if(instance == NULL)\\n+    return;\\n+}\\n+\\n+NPError NPP_SetValue(NPP instance, NPNVariable variable, void *value)\\n+{\\n+  if(instance == NULL)\\n+    return NPERR_INVALID_INSTANCE_ERROR;\\n+\\n+  NPError rv = NPERR_NO_ERROR;\\n+  return rv;\\n+}\\n+\\n+int16\\tNPP_HandleEvent(NPP instance, void* event)\\n+{\\n+  if(instance == NULL)\\n+    return 0;\\n+\\n+  int16 rv = 0;\\n+  CPlugin * pPlugin = (CPlugin *)instance->pdata;\\n+  if (pPlugin)\\n+    rv = pPlugin->handleEvent(event);\\n+\\n+  return rv;\\n+}\\n+\\n+jref NPP_GetJavaClass (void)\\n+{\\n+  return NULL;\\n+}\\n+\\n+NPObject *NPP_GetScriptableInstance(NPP instance)\\n+{\\n+  if(!instance)\\n+    return 0;\\n+\\n+  NPObject *npobj = 0;\\n+  CPlugin * pPlugin = (CPlugin *)instance->pdata;\\n+  if (!pPlugin)\\n+    npobj = pPlugin->GetScriptableObject();\\n+\\n+  return npobj;\\n+}\\ndiff --git a/modules/plugin/samples/npruntime/nprt.def b/modules/plugin/samples/npruntime/nprt.def\\nnew file mode 100644\\nindex 0000000..3aabd9c\\n--- /dev/null\\n+++ b/modules/plugin/samples/npruntime/nprt.def\\n@@ -0,0 +1,6 @@\\n+LIBRARY   NPRT\\n+\\n+EXPORTS\\n+\\tNP_GetEntryPoints   @1\\n+\\tNP_Initialize       @2\\n+\\tNP_Shutdown         @3\\ndiff --git a/modules/plugin/samples/npruntime/nprt.rc b/modules/plugin/samples/npruntime/nprt.rc\\nnew file mode 100644\\nindex 0000000..c1384c8\\n--- /dev/null\\n+++ b/modules/plugin/samples/npruntime/nprt.rc\\n@@ -0,0 +1,112 @@\\n+//Microsoft Developer Studio generated resource script.\\n+//\\n+#include \\\"resource.h\\\"\\n+\\n+#define APSTUDIO_READONLY_SYMBOLS\\n+/////////////////////////////////////////////////////////////////////////////\\n+//\\n+// Generated from the TEXTINCLUDE 2 resource.\\n+//\\n+#include \\\"afxres.h\\\"\\n+\\n+/////////////////////////////////////////////////////////////////////////////\\n+#undef APSTUDIO_READONLY_SYMBOLS\\n+\\n+/////////////////////////////////////////////////////////////////////////////\\n+// English (U.S.) resources\\n+\\n+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)\\n+#ifdef _WIN32\\n+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US\\n+#pragma code_page(1252)\\n+#endif //_WIN32\\n+\\n+#ifndef _MAC\\n+/////////////////////////////////////////////////////////////////////////////\\n+//\\n+// Version\\n+//\\n+\\n+VS_VERSION_INFO VERSIONINFO\\n+ FILEVERSION 1,0,0,1\\n+ PRODUCTVERSION 1,0,0,1\\n+ FILEFLAGSMASK 0x3fL\\n+#ifdef _DEBUG\\n+ FILEFLAGS 0x1L\\n+#else\\n+ FILEFLAGS 0x0L\\n+#endif\\n+ FILEOS 0x40004L\\n+ FILETYPE 0x2L\\n+ FILESUBTYPE 0x0L\\n+BEGIN\\n+    BLOCK \\\"StringFileInfo\\\"\\n+    BEGIN\\n+        BLOCK \\\"040904e4\\\"\\n+        BEGIN\\n+            VALUE \\\"Comments\\\", \\\"\\\\0\\\"\\n+            VALUE \\\"CompanyName\\\", \\\" \\\\0\\\"\\n+            VALUE \\\"FileDescription\\\", \\\"nprt\\\\0\\\"\\n+            VALUE \\\"FileExtents\\\", \\\"rts\\\\0\\\"\\n+            VALUE \\\"FileOpenName\\\", \\\"nprt\\\\0\\\"\\n+            VALUE \\\"FileVersion\\\", \\\"1, 0, 0, 1\\\\0\\\"\\n+            VALUE \\\"InternalName\\\", \\\"nprt\\\\0\\\"\\n+            VALUE \\\"LegalCopyright\\\", \\\"Copyright ï¿½ 1999\\\\0\\\"\\n+            VALUE \\\"LegalTrademarks\\\", \\\"\\\\0\\\"\\n+            VALUE \\\"MIMEType\\\", \\\"application/mozilla-npruntime-scriptable-plugin\\\\0\\\"\\n+            VALUE \\\"OriginalFilename\\\", \\\"nprt.dll\\\\0\\\"\\n+            VALUE \\\"PrivateBuild\\\", \\\"\\\\0\\\"\\n+            VALUE \\\"ProductName\\\", \\\"npruntime scriptable example plugin\\\\0\\\"\\n+            VALUE \\\"ProductVersion\\\", \\\"1, 0, 0, 1\\\\0\\\"\\n+            VALUE \\\"SpecialBuild\\\", \\\"\\\\0\\\"\\n+        END\\n+    END\\n+    BLOCK \\\"VarFileInfo\\\"\\n+    BEGIN\\n+        VALUE \\\"Translation\\\", 0x409, 1252\\n+    END\\n+END\\n+\\n+#endif    // !_MAC\\n+\\n+\\n+#ifdef APSTUDIO_INVOKED\\n+/////////////////////////////////////////////////////////////////////////////\\n+//\\n+// TEXTINCLUDE\\n+//\\n+\\n+1 TEXTINCLUDE DISCARDABLE \\n+BEGIN\\n+    \\\"resource.h\\\\0\\\"\\n+END\\n+\\n+2 TEXTINCLUDE DISCARDABLE \\n+BEGIN\\n+    \\\"#include \\\"\\\"afxres.h\\\"\\\"\\\\r\\\\n\\\"\\n+    \\\"\\\\0\\\"\\n+END\\n+\\n+3 TEXTINCLUDE DISCARDABLE \\n+BEGIN\\n+    \\\"\\\\r\\\\n\\\"\\n+    \\\"\\\\0\\\"\\n+END\\n+\\n+#endif    // APSTUDIO_INVOKED\\n+\\n+#endif    // English (U.S.) resources\\n+/////////////////////////////////////////////////////////////////////////////\\n+\\n+\\n+\\n+#ifndef APSTUDIO_INVOKED\\n+/////////////////////////////////////////////////////////////////////////////\\n+//\\n+// Generated from the TEXTINCLUDE 3 resource.\\n+//\\n+\\n+\\n+/////////////////////////////////////////////////////////////////////////////\\n+#endif    // not APSTUDIO_INVOKED\\n+\\ndiff --git a/modules/plugin/samples/npruntime/plugin.cpp b/modules/plugin/samples/npruntime/plugin.cpp\\nnew file mode 100644\\nindex 0000000..fffdad9\\n--- /dev/null\\n+++ b/modules/plugin/samples/npruntime/plugin.cpp\\n@@ -0,0 +1,767 @@\\n+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: NPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Netscape Public License\\n+ * Version 1.1 (the \\\"License\\\"); you may not use this file except in\\n+ * compliance with the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/NPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is mozilla.org code.\\n+ *\\n+ * The Initial Developer of the Original Code is \\n+ * Netscape Communications Corporation.\\n+ * Portions created by the Initial Developer are Copyright (C) 1998\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or \\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the NPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the NPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+\\n+//////////////////////////////////////////////////\\n+//\\n+// CPlugin class implementation\\n+//\\n+#ifdef XP_WIN\\n+#include <windows.h>\\n+#include <windowsx.h>\\n+#endif\\n+\\n+#ifdef XP_MAC\\n+#include <TextEdit.h>\\n+#endif\\n+\\n+#ifdef XP_UNIX\\n+#include <string.h>\\n+#endif\\n+\\n+#include \\\"plugin.h\\\"\\n+#include \\\"npupp.h\\\"\\n+\\n+static NPIdentifier sFoo_id;\\n+static NPIdentifier sBar_id;\\n+static NPIdentifier sDocument_id;\\n+static NPIdentifier sBody_id;\\n+static NPIdentifier sCreateElement_id;\\n+static NPIdentifier sCreateTextNode_id;\\n+static NPIdentifier sAppendChild_id;\\n+static NPIdentifier sPluginType_id;\\n+static NPObject *sWindowObj;\\n+\\n+// Helper class that can be used to map calls to the NPObject hooks\\n+// into virtual methods on instances of classes that derive from this\\n+// class.\\n+class ScriptablePluginObjectBase : public NPObject\\n+{\\n+public:\\n+  ScriptablePluginObjectBase(NPP npp)\\n+    : mNpp(npp)\\n+  {\\n+  }\\n+\\n+  virtual ~ScriptablePluginObjectBase()\\n+  {\\n+  }\\n+\\n+  // Virtual NPObject hooks called through this base class. Override\\n+  // as you see fit.\\n+  virtual void Invalidate();\\n+  virtual bool HasMethod(NPIdentifier name);\\n+  virtual bool Invoke(NPIdentifier name, const NPVariant *args,\\n+                      uint32_t argCount, NPVariant *result);\\n+  virtual bool InvokeDefault(const NPVariant *args, uint32_t argCount,\\n+                             NPVariant *result);\\n+  virtual bool HasProperty(NPIdentifier name);\\n+  virtual bool GetProperty(NPIdentifier name, NPVariant *result);\\n+  virtual bool SetProperty(NPIdentifier name, const NPVariant *value);\\n+  virtual bool RemoveProperty(NPIdentifier name);\\n+  virtual bool Enumerate(NPIdentifier **identifier, uint32_t *count);\\n+  virtual bool Construct(const NPVariant *args, uint32_t argCount,\\n+                         NPVariant *result);\\n+\\n+public:\\n+  static void _Deallocate(NPObject *npobj);\\n+  static void _Invalidate(NPObject *npobj);\\n+  static bool _HasMethod(NPObject *npobj, NPIdentifier name);\\n+  static bool _Invoke(NPObject *npobj, NPIdentifier name,\\n+                      const NPVariant *args, uint32_t argCount,\\n+                      NPVariant *result);\\n+  static bool _InvokeDefault(NPObject *npobj, const NPVariant *args,\\n+                             uint32_t argCount, NPVariant *result);\\n+  static bool _HasProperty(NPObject * npobj, NPIdentifier name);\\n+  static bool _GetProperty(NPObject *npobj, NPIdentifier name,\\n+                           NPVariant *result);\\n+  static bool _SetProperty(NPObject *npobj, NPIdentifier name,\\n+                           const NPVariant *value);\\n+  static bool _RemoveProperty(NPObject *npobj, NPIdentifier name);\\n+  static bool _Enumerate(NPObject *npobj, NPIdentifier **identifier,\\n+                         uint32_t *count);\\n+  static bool _Construct(NPObject *npobj, const NPVariant *args,\\n+                         uint32_t argCount, NPVariant *result);\\n+\\n+protected:\\n+  NPP mNpp;\\n+};\\n+\\n+#define DECLARE_NPOBJECT_CLASS_WITH_BASE(_class, ctor)                        \\\\\\n+static NPClass s##_class##_NPClass = {                                        \\\\\\n+  NP_CLASS_STRUCT_VERSION_CTOR,                                               \\\\\\n+  ctor,                                                                       \\\\\\n+  ScriptablePluginObjectBase::_Deallocate,                                    \\\\\\n+  ScriptablePluginObjectBase::_Invalidate,                                    \\\\\\n+  ScriptablePluginObjectBase::_HasMethod,                                     \\\\\\n+  ScriptablePluginObjectBase::_Invoke,                                        \\\\\\n+  ScriptablePluginObjectBase::_InvokeDefault,                                 \\\\\\n+  ScriptablePluginObjectBase::_HasProperty,                                   \\\\\\n+  ScriptablePluginObjectBase::_GetProperty,                                   \\\\\\n+  ScriptablePluginObjectBase::_SetProperty,                                   \\\\\\n+  ScriptablePluginObjectBase::_RemoveProperty,                                \\\\\\n+  ScriptablePluginObjectBase::_Enumerate,                                     \\\\\\n+  ScriptablePluginObjectBase::_Construct                                      \\\\\\n+}\\n+\\n+#define GET_NPOBJECT_CLASS(_class) &s##_class##_NPClass\\n+\\n+void\\n+ScriptablePluginObjectBase::Invalidate()\\n+{\\n+}\\n+\\n+bool\\n+ScriptablePluginObjectBase::HasMethod(NPIdentifier name)\\n+{\\n+  return false;\\n+}\\n+\\n+bool\\n+ScriptablePluginObjectBase::Invoke(NPIdentifier name, const NPVariant *args,\\n+                                   uint32_t argCount, NPVariant *result)\\n+{\\n+  return false;\\n+}\\n+\\n+bool\\n+ScriptablePluginObjectBase::InvokeDefault(const NPVariant *args,\\n+                                          uint32_t argCount, NPVariant *result)\\n+{\\n+  return false;\\n+}\\n+\\n+bool\\n+ScriptablePluginObjectBase::HasProperty(NPIdentifier name)\\n+{\\n+  return false;\\n+}\\n+\\n+bool\\n+ScriptablePluginObjectBase::GetProperty(NPIdentifier name, NPVariant *result)\\n+{\\n+  return false;\\n+}\\n+\\n+bool\\n+ScriptablePluginObjectBase::SetProperty(NPIdentifier name,\\n+                                        const NPVariant *value)\\n+{\\n+  if (name == sBar_id) {\\n+    printf (\\\"bar set\\\\n\\\");\\n+\\n+    return true;\\n+  }\\n+\\n+  return false;\\n+}\\n+\\n+bool\\n+ScriptablePluginObjectBase::RemoveProperty(NPIdentifier name)\\n+{\\n+  return false;\\n+}\\n+\\n+bool\\n+ScriptablePluginObjectBase::Enumerate(NPIdentifier **identifier,\\n+                                      uint32_t *count)\\n+{\\n+  return false;\\n+}\\n+\\n+bool\\n+ScriptablePluginObjectBase::Construct(const NPVariant *args, uint32_t argCount,\\n+                                      NPVariant *result)\\n+{\\n+  return false;\\n+}\\n+\\n+// static\\n+void\\n+ScriptablePluginObjectBase::_Deallocate(NPObject *npobj)\\n+{\\n+  // Call the virtual destructor.\\n+  delete (ScriptablePluginObjectBase *)npobj;\\n+}\\n+\\n+// static\\n+void\\n+ScriptablePluginObjectBase::_Invalidate(NPObject *npobj)\\n+{\\n+  ((ScriptablePluginObjectBase *)npobj)->Invalidate();\\n+}\\n+\\n+// static\\n+bool\\n+ScriptablePluginObjectBase::_HasMethod(NPObject *npobj, NPIdentifier name)\\n+{\\n+  return ((ScriptablePluginObjectBase *)npobj)->HasMethod(name);\\n+}\\n+\\n+// static\\n+bool\\n+ScriptablePluginObjectBase::_Invoke(NPObject *npobj, NPIdentifier name,\\n+                                    const NPVariant *args, uint32_t argCount,\\n+                                    NPVariant *result)\\n+{\\n+  return ((ScriptablePluginObjectBase *)npobj)->Invoke(name, args, argCount,\\n+                                                       result);\\n+}\\n+\\n+// static\\n+bool\\n+ScriptablePluginObjectBase::_InvokeDefault(NPObject *npobj,\\n+                                           const NPVariant *args,\\n+                                           uint32_t argCount,\\n+                                           NPVariant *result)\\n+{\\n+  return ((ScriptablePluginObjectBase *)npobj)->InvokeDefault(args, argCount,\\n+                                                              result);\\n+}\\n+\\n+// static\\n+bool\\n+ScriptablePluginObjectBase::_HasProperty(NPObject * npobj, NPIdentifier name)\\n+{\\n+  return ((ScriptablePluginObjectBase *)npobj)->HasProperty(name);\\n+}\\n+\\n+// static\\n+bool\\n+ScriptablePluginObjectBase::_GetProperty(NPObject *npobj, NPIdentifier name,\\n+                                         NPVariant *result)\\n+{\\n+  return ((ScriptablePluginObjectBase *)npobj)->GetProperty(name, result);\\n+}\\n+\\n+// static\\n+bool\\n+ScriptablePluginObjectBase::_SetProperty(NPObject *npobj, NPIdentifier name,\\n+                                         const NPVariant *value)\\n+{\\n+  return ((ScriptablePluginObjectBase *)npobj)->SetProperty(name, value);\\n+}\\n+\\n+// static\\n+bool\\n+ScriptablePluginObjectBase::_RemoveProperty(NPObject *npobj, NPIdentifier name)\\n+{\\n+  return ((ScriptablePluginObjectBase *)npobj)->RemoveProperty(name);\\n+}\\n+\\n+// static\\n+bool\\n+ScriptablePluginObjectBase::_Enumerate(NPObject *npobj,\\n+                                       NPIdentifier **identifier,\\n+                                       uint32_t *count)\\n+{\\n+  return ((ScriptablePluginObjectBase *)npobj)->Enumerate(identifier, count);\\n+}\\n+\\n+// static\\n+bool\\n+ScriptablePluginObjectBase::_Construct(NPObject *npobj, const NPVariant *args,\\n+                                       uint32_t argCount, NPVariant *result)\\n+{\\n+  return ((ScriptablePluginObjectBase *)npobj)->Construct(args, argCount,\\n+                                                          result);\\n+}\\n+\\n+\\n+class ConstructablePluginObject : public ScriptablePluginObjectBase\\n+{\\n+public:\\n+  ConstructablePluginObject(NPP npp)\\n+    : ScriptablePluginObjectBase(npp)\\n+  {\\n+  }\\n+\\n+  virtual bool Construct(const NPVariant *args, uint32_t argCount,\\n+                         NPVariant *result);\\n+};\\n+\\n+static NPObject *\\n+AllocateConstructablePluginObject(NPP npp, NPClass *aClass)\\n+{\\n+  return new ConstructablePluginObject(npp);\\n+}\\n+\\n+DECLARE_NPOBJECT_CLASS_WITH_BASE(ConstructablePluginObject,\\n+                                 AllocateConstructablePluginObject);\\n+\\n+bool\\n+ConstructablePluginObject::Construct(const NPVariant *args, uint32_t argCount,\\n+                                     NPVariant *result)\\n+{\\n+  printf(\\\"Creating new ConstructablePluginObject!\\\\n\\\");\\n+\\n+  NPObject *myobj =\\n+    NPN_CreateObject(mNpp, GET_NPOBJECT_CLASS(ConstructablePluginObject));\\n+  if (!myobj)\\n+    return false;\\n+\\n+  OBJECT_TO_NPVARIANT(myobj, *result);\\n+\\n+  return true;\\n+}\\n+\\n+class ScriptablePluginObject : public ScriptablePluginObjectBase\\n+{\\n+public:\\n+  ScriptablePluginObject(NPP npp)\\n+    : ScriptablePluginObjectBase(npp)\\n+  {\\n+  }\\n+\\n+  virtual bool HasMethod(NPIdentifier name);\\n+  virtual bool HasProperty(NPIdentifier name);\\n+  virtual bool GetProperty(NPIdentifier name, NPVariant *result);\\n+  virtual bool Invoke(NPIdentifier name, const NPVariant *args,\\n+                      uint32_t argCount, NPVariant *result);\\n+  virtual bool InvokeDefault(const NPVariant *args, uint32_t argCount,\\n+                             NPVariant *result);\\n+};\\n+\\n+static NPObject *\\n+AllocateScriptablePluginObject(NPP npp, NPClass *aClass)\\n+{\\n+  return new ScriptablePluginObject(npp);\\n+}\\n+\\n+DECLARE_NPOBJECT_CLASS_WITH_BASE(ScriptablePluginObject,\\n+                                 AllocateScriptablePluginObject);\\n+\\n+bool\\n+ScriptablePluginObject::HasMethod(NPIdentifier name)\\n+{\\n+  return name == sFoo_id;\\n+}\\n+\\n+bool\\n+ScriptablePluginObject::HasProperty(NPIdentifier name)\\n+{\\n+  return (name == sBar_id ||\\n+          name == sPluginType_id);\\n+}\\n+\\n+bool\\n+ScriptablePluginObject::GetProperty(NPIdentifier name, NPVariant *result)\\n+{\\n+  VOID_TO_NPVARIANT(*result);\\n+\\n+  if (name == sBar_id) {\\n+    static int a = 17;\\n+\\n+    INT32_TO_NPVARIANT(a, *result);\\n+\\n+    a += 5;\\n+\\n+    return true;\\n+  }\\n+\\n+  if (name == sPluginType_id) {\\n+    NPObject *myobj =\\n+      NPN_CreateObject(mNpp, GET_NPOBJECT_CLASS(ConstructablePluginObject));\\n+    if (!myobj) {\\n+      return false;\\n+    }\\n+\\n+    OBJECT_TO_NPVARIANT(myobj, *result);\\n+\\n+    return true;\\n+  }\\n+\\n+  return true;\\n+}\\n+\\n+bool\\n+ScriptablePluginObject::Invoke(NPIdentifier name, const NPVariant *args,\\n+                               uint32_t argCount, NPVariant *result)\\n+{\\n+  if (name == sFoo_id) {\\n+    printf (\\\"foo called!\\\\n\\\");\\n+\\n+    NPVariant docv;\\n+    NPN_GetProperty(mNpp, sWindowObj, sDocument_id, &docv);\\n+\\n+    NPObject *doc = NPVARIANT_TO_OBJECT(docv);\\n+\\n+    NPVariant strv;\\n+    STRINGZ_TO_NPVARIANT(\\\"div\\\", strv);\\n+\\n+    NPVariant divv;\\n+    NPN_Invoke(mNpp, doc, sCreateElement_id, &strv, 1, &divv);\\n+\\n+    STRINGZ_TO_NPVARIANT(\\\"I'm created by a plugin!\\\", strv);\\n+\\n+    NPVariant textv;\\n+    NPN_Invoke(mNpp, doc, sCreateTextNode_id, &strv, 1, &textv);\\n+\\n+    NPVariant v;\\n+    NPN_Invoke(mNpp, NPVARIANT_TO_OBJECT(divv), sAppendChild_id, &textv, 1,\\n+               &v);\\n+    NPN_ReleaseVariantValue(&v);\\n+\\n+    NPN_ReleaseVariantValue(&textv);\\n+\\n+    NPVariant bodyv;\\n+    NPN_GetProperty(mNpp, doc, sBody_id, &bodyv);\\n+\\n+    NPN_Invoke(mNpp, NPVARIANT_TO_OBJECT(bodyv), sAppendChild_id, &divv, 1,\\n+               &v);\\n+    NPN_ReleaseVariantValue(&v);\\n+\\n+    NPN_ReleaseVariantValue(&divv);\\n+    NPN_ReleaseVariantValue(&bodyv);\\n+\\n+    NPN_ReleaseVariantValue(&docv);\\n+\\n+    STRINGZ_TO_NPVARIANT(strdup(\\\"foo return val\\\"), *result);\\n+\\n+    return PR_TRUE;\\n+  }\\n+\\n+  return PR_FALSE;\\n+}\\n+\\n+bool\\n+ScriptablePluginObject::InvokeDefault(const NPVariant *args, uint32_t argCount,\\n+                                      NPVariant *result)\\n+{\\n+  printf (\\\"ScriptablePluginObject default method called!\\\\n\\\");\\n+\\n+  STRINGZ_TO_NPVARIANT(strdup(\\\"default method return val\\\"), *result);\\n+\\n+  return PR_TRUE;\\n+}\\n+\\n+CPlugin::CPlugin(NPP pNPInstance) :\\n+  m_pNPInstance(pNPInstance),\\n+  m_pNPStream(NULL),\\n+  m_bInitialized(FALSE),\\n+  m_pScriptableObject(NULL)\\n+{\\n+#ifdef XP_WIN\\n+  m_hWnd = NULL;\\n+#endif\\n+\\n+  NPN_GetValue(m_pNPInstance, NPNVWindowNPObject, &sWindowObj);\\n+\\n+  NPIdentifier n = NPN_GetStringIdentifier(\\\"foof\\\");\\n+\\n+  sFoo_id = NPN_GetStringIdentifier(\\\"foo\\\");\\n+  sBar_id = NPN_GetStringIdentifier(\\\"bar\\\");\\n+  sDocument_id = NPN_GetStringIdentifier(\\\"document\\\");\\n+  sBody_id = NPN_GetStringIdentifier(\\\"body\\\");\\n+  sCreateElement_id = NPN_GetStringIdentifier(\\\"createElement\\\");\\n+  sCreateTextNode_id = NPN_GetStringIdentifier(\\\"createTextNode\\\");\\n+  sAppendChild_id = NPN_GetStringIdentifier(\\\"appendChild\\\");\\n+  sPluginType_id = NPN_GetStringIdentifier(\\\"PluginType\\\");\\n+\\n+  NPVariant v;\\n+  INT32_TO_NPVARIANT(46, v);\\n+\\n+  NPN_SetProperty(m_pNPInstance, sWindowObj, n, &v);\\n+\\n+  NPVariant rval;\\n+  NPN_GetProperty(m_pNPInstance, sWindowObj, n, &rval);\\n+\\n+  if (NPVARIANT_IS_INT32(rval)) {\\n+    printf(\\\"rval = %d\\\\n\\\", NPVARIANT_TO_INT32(rval));\\n+  }\\n+\\n+  n = NPN_GetStringIdentifier(\\\"document\\\");\\n+\\n+  if (!NPN_IdentifierIsString(n)) {\\n+    NPString str;\\n+    str.utf8characters = \\\"alert('NPN_IdentifierIsString() test failed!');\\\";\\n+    str.utf8length = strlen(str.utf8characters);\\n+\\n+    NPN_Evaluate(m_pNPInstance, sWindowObj, &str, NULL);\\n+  }\\n+\\n+  NPObject *doc;\\n+\\n+  NPN_GetProperty(m_pNPInstance, sWindowObj, n, &rval);\\n+\\n+  if (NPVARIANT_IS_OBJECT(rval) && (doc = NPVARIANT_TO_OBJECT(rval))) {\\n+    n = NPN_GetStringIdentifier(\\\"title\\\");\\n+\\n+    NPN_GetProperty(m_pNPInstance, doc, n, &rval);\\n+\\n+    if (NPVARIANT_IS_STRING(rval)) {\\n+      printf (\\\"title = %s\\\\n\\\", NPVARIANT_TO_STRING(rval).utf8characters);\\n+\\n+      NPN_ReleaseVariantValue(&rval);\\n+    }\\n+\\n+    n = NPN_GetStringIdentifier(\\\"plugindoc\\\");\\n+\\n+    OBJECT_TO_NPVARIANT(doc, v);\\n+    NPN_SetProperty(m_pNPInstance, sWindowObj, n, &v);\\n+\\n+    NPString str;\\n+    str.utf8characters = \\\"document.getElementById('result').innerHTML += '<p>' + 'NPN_Evaluate() test, document = ' + this + '</p>';\\\";\\n+    str.utf8length = strlen(str.utf8characters);\\n+\\n+    NPN_Evaluate(m_pNPInstance, doc, &str, NULL);\\n+\\n+    NPN_ReleaseObject(doc);\\n+  }\\n+\\n+  NPVariant barval;\\n+  NPN_GetProperty(m_pNPInstance, sWindowObj, sBar_id, &barval);\\n+\\n+  NPVariant arg;\\n+  OBJECT_TO_NPVARIANT(sWindowObj, arg);\\n+\\n+  NPN_InvokeDefault(m_pNPInstance, NPVARIANT_TO_OBJECT(barval), &arg, 1,\\n+                    &rval);\\n+\\n+  if (NPVARIANT_IS_INT32(rval) && NPVARIANT_TO_INT32(rval) == 4) {\\n+    printf (\\\"Default function call SUCCEEDED!\\\\n\\\");\\n+  } else {\\n+    printf (\\\"Default function call FAILED!\\\\n\\\");\\n+  }\\n+\\n+  NPN_ReleaseVariantValue(&barval);\\n+  NPN_ReleaseVariantValue(&rval);\\n+\\n+\\n+#if 0\\n+  n = NPN_GetStringIdentifier(\\\"prompt\\\");\\n+\\n+  NPVariant vars[3];\\n+  STRINGZ_TO_NPVARIANT(\\\"foo\\\", vars[0]);\\n+  STRINGZ_TO_NPVARIANT(\\\"bar\\\", vars[1]);\\n+  STRINGZ_TO_NPVARIANT(\\\"foof\\\", vars[2]);\\n+\\n+  NPN_Invoke(sWindowObj, n, vars, 3, &rval);\\n+\\n+  if (NPVARIANT_IS_STRING(rval)) {\\n+    printf (\\\"prompt returned '%s'\\\\n\\\", NPVARIANT_TO_STRING(rval).utf8characters);\\n+  }\\n+\\n+  NPN_ReleaseVariantValue(&rval);\\n+#endif\\n+\\n+  NPObject *myobj =\\n+    NPN_CreateObject(m_pNPInstance,\\n+                     GET_NPOBJECT_CLASS(ScriptablePluginObject));\\n+\\n+  n = NPN_GetStringIdentifier(\\\"pluginobj\\\");\\n+\\n+  OBJECT_TO_NPVARIANT(myobj, v);\\n+  NPN_SetProperty(m_pNPInstance, sWindowObj, n, &v);\\n+\\n+  NPN_GetProperty(m_pNPInstance, sWindowObj, n, &rval);\\n+\\n+  printf (\\\"Object set/get test \\\");\\n+\\n+  if (NPVARIANT_IS_OBJECT(rval) && NPVARIANT_TO_OBJECT(rval) == myobj) {\\n+    printf (\\\"succeeded!\\\\n\\\");\\n+  } else {\\n+    printf (\\\"FAILED!\\\\n\\\");\\n+  }\\n+\\n+  NPN_ReleaseVariantValue(&rval);\\n+  NPN_ReleaseObject(myobj);\\n+\\n+  const char *ua = NPN_UserAgent(m_pNPInstance);\\n+  strcpy(m_String, ua);\\n+}\\n+\\n+CPlugin::~CPlugin()\\n+{\\n+  if (sWindowObj)\\n+    NPN_ReleaseObject(sWindowObj);\\n+  if (m_pScriptableObject)\\n+    NPN_ReleaseObject(m_pScriptableObject);\\n+\\n+  sWindowObj = 0;\\n+}\\n+\\n+#ifdef XP_WIN\\n+static LRESULT CALLBACK PluginWinProc(HWND, UINT, WPARAM, LPARAM);\\n+static WNDPROC lpOldProc = NULL;\\n+#endif\\n+\\n+NPBool CPlugin::init(NPWindow* pNPWindow)\\n+{\\n+  if(pNPWindow == NULL)\\n+    return FALSE;\\n+\\n+#ifdef XP_WIN\\n+  m_hWnd = (HWND)pNPWindow->window;\\n+  if(m_hWnd == NULL)\\n+    return FALSE;\\n+\\n+  // subclass window so we can intercept window messages and\\n+  // do our drawing to it\\n+  lpOldProc = SubclassWindow(m_hWnd, (WNDPROC)PluginWinProc);\\n+\\n+  // associate window with our CPlugin object so we can access \\n+  // it in the window procedure\\n+  SetWindowLong(m_hWnd, GWL_USERDATA, (LONG)this);\\n+#endif\\n+\\n+  m_Window = pNPWindow;\\n+\\n+  m_bInitialized = TRUE;\\n+  return TRUE;\\n+}\\n+\\n+void CPlugin::shut()\\n+{\\n+#ifdef XP_WIN\\n+  // subclass it back\\n+  SubclassWindow(m_hWnd, lpOldProc);\\n+  m_hWnd = NULL;\\n+#endif\\n+\\n+  m_bInitialized = FALSE;\\n+}\\n+\\n+NPBool CPlugin::isInitialized()\\n+{\\n+  return m_bInitialized;\\n+}\\n+\\n+int16 CPlugin::handleEvent(void* event)\\n+{\\n+#ifdef XP_MAC\\n+  NPEvent* ev = (NPEvent*)event;\\n+  if (m_Window) {\\n+    Rect box = { m_Window->y, m_Window->x,\\n+                 m_Window->y + m_Window->height, m_Window->x + m_Window->width };\\n+    if (ev->what == updateEvt) {\\n+      ::TETextBox(m_String, strlen(m_String), &box, teJustCenter);\\n+    }\\n+  }\\n+#endif\\n+  return 0;\\n+}\\n+\\n+// this will force to draw a version string in the plugin window\\n+void CPlugin::showVersion()\\n+{\\n+  const char *ua = NPN_UserAgent(m_pNPInstance);\\n+  strcpy(m_String, ua);\\n+\\n+#ifdef XP_WIN\\n+  InvalidateRect(m_hWnd, NULL, TRUE);\\n+  UpdateWindow(m_hWnd);\\n+#endif\\n+\\n+  if (m_Window) {\\n+    NPRect r =\\n+      {\\n+        (uint16)m_Window->y, (uint16)m_Window->x,\\n+        (uint16)(m_Window->y + m_Window->height),\\n+        (uint16)(m_Window->x + m_Window->width)\\n+      };\\n+\\n+    NPN_InvalidateRect(m_pNPInstance, &r);\\n+  }\\n+}\\n+\\n+// this will clean the plugin window\\n+void CPlugin::clear()\\n+{\\n+  strcpy(m_String, \\\"\\\");\\n+\\n+#ifdef XP_WIN\\n+  InvalidateRect(m_hWnd, NULL, TRUE);\\n+  UpdateWindow(m_hWnd);\\n+#endif\\n+}\\n+\\n+void CPlugin::getVersion(char* *aVersion)\\n+{\\n+  const char *ua = NPN_UserAgent(m_pNPInstance);\\n+  char*& version = *aVersion;\\n+  version = (char*)NPN_MemAlloc(1 + strlen(ua));\\n+  if (version)\\n+    strcpy(version, ua);\\n+}\\n+\\n+NPObject *\\n+CPlugin::GetScriptableObject()\\n+{\\n+  if (!m_pScriptableObject) {\\n+    m_pScriptableObject =\\n+      NPN_CreateObject(m_pNPInstance,\\n+                       GET_NPOBJECT_CLASS(ScriptablePluginObject));\\n+  }\\n+\\n+  if (m_pScriptableObject) {\\n+    NPN_RetainObject(m_pScriptableObject);\\n+  }\\n+\\n+  return m_pScriptableObject;\\n+}\\n+\\n+#ifdef XP_WIN\\n+static LRESULT CALLBACK PluginWinProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)\\n+{\\n+  switch (msg) {\\n+    case WM_PAINT:\\n+      {\\n+        // draw a frame and display the string\\n+        PAINTSTRUCT ps;\\n+        HDC hdc = BeginPaint(hWnd, &ps);\\n+        RECT rc;\\n+        GetClientRect(hWnd, &rc);\\n+        FrameRect(hdc, &rc, GetStockBrush(BLACK_BRUSH));\\n+        CPlugin * p = (CPlugin *)GetWindowLong(hWnd, GWL_USERDATA);\\n+        if(p) {\\n+          if (p->m_String[0] == 0) {\\n+            strcpy(\\\"foo\\\", p->m_String);\\n+          }\\n+\\n+          DrawText(hdc, p->m_String, strlen(p->m_String), &rc, DT_SINGLELINE | DT_CENTER | DT_VCENTER);\\n+        }\\n+\\n+        EndPaint(hWnd, &ps);\\n+      }\\n+      break;\\n+    default:\\n+      break;\\n+  }\\n+\\n+  return DefWindowProc(hWnd, msg, wParam, lParam);\\n+}\\n+#endif\\ndiff --git a/modules/plugin/samples/npruntime/plugin.h b/modules/plugin/samples/npruntime/plugin.h\\nnew file mode 100644\\nindex 0000000..70decab\\n--- /dev/null\\n+++ b/modules/plugin/samples/npruntime/plugin.h\\n@@ -0,0 +1,80 @@\\n+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: NPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Netscape Public License\\n+ * Version 1.1 (the \\\"License\\\"); you may not use this file except in\\n+ * compliance with the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/NPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is mozilla.org code.\\n+ *\\n+ * The Initial Developer of the Original Code is \\n+ * Netscape Communications Corporation.\\n+ * Portions created by the Initial Developer are Copyright (C) 1998\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or \\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the NPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the NPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+\\n+#ifndef __PLUGIN_H__\\n+#define __PLUGIN_H__\\n+\\n+#include \\\"npapi.h\\\"\\n+#include \\\"npruntime.h\\\"\\n+\\n+class CPlugin\\n+{\\n+private:\\n+  NPP m_pNPInstance;\\n+\\n+#ifdef XP_WIN\\n+  HWND m_hWnd; \\n+#endif\\n+\\n+  NPWindow * m_Window;\\n+  \\n+  NPStream * m_pNPStream;\\n+  NPBool m_bInitialized;\\n+\\n+  NPObject *m_pScriptableObject;\\n+\\n+public:\\n+  char m_String[128];\\n+\\n+public:\\n+  CPlugin(NPP pNPInstance);\\n+  ~CPlugin();\\n+\\n+  NPBool init(NPWindow* pNPWindow);\\n+  void shut();\\n+  NPBool isInitialized();\\n+  \\n+  int16 handleEvent(void* event);\\n+\\n+  void showVersion();\\n+  void clear();\\n+  void getVersion(char* *aVersion);\\n+\\n+  NPObject *GetScriptableObject();\\n+};\\n+\\n+#endif // __PLUGIN_H__\\ndiff --git a/modules/plugin/samples/npruntime/resource.h b/modules/plugin/samples/npruntime/resource.h\\nnew file mode 100644\\nindex 0000000..43f7ebf\\n--- /dev/null\\n+++ b/modules/plugin/samples/npruntime/resource.h\\n@@ -0,0 +1,20 @@\\n+//{{NO_DEPENDENCIES}}\\n+// Microsoft Developer Studio generated include file.\\n+// Used by np4xscr.rc\\n+//\\n+#define IDD_MAIN                        101\\n+#define IDC_BUTTON_GO                   1002\\n+#define IDC_STATIC_UA                   1003\\n+#define IDC_BUTTON1                     1005\\n+#define IDC_BUTTON_DONT                 1005\\n+\\n+// Next default values for new objects\\n+// \\n+#ifdef APSTUDIO_INVOKED\\n+#ifndef APSTUDIO_READONLY_SYMBOLS\\n+#define _APS_NEXT_RESOURCE_VALUE        102\\n+#define _APS_NEXT_COMMAND_VALUE         40001\\n+#define _APS_NEXT_CONTROL_VALUE         1006\\n+#define _APS_NEXT_SYMED_VALUE           101\\n+#endif\\n+#endif\\ndiff --git a/modules/plugin/samples/npruntime/test.html b/modules/plugin/samples/npruntime/test.html\\nnew file mode 100644\\nindex 0000000..8bded7e\\n--- /dev/null\\n+++ b/modules/plugin/samples/npruntime/test.html\\n@@ -0,0 +1,61 @@\\n+<HTML>\\n+<HEAD>\\n+<TITLE>Scriptable Plug-in Test</TITLE>\\n+</HEAD>\\n+<BODY id=\\\"bodyId\\\">\\n+\\n+<center>\\n+<h1>Sample Scriptable Plug-in </h1>\\n+</center>\\n+\\n+This page contains a testcase which demonstrates the work of\\n+scriptable 4.x style Navigator plug-in with Mozilla. The example\\n+plug-in occupies the area right below this text, and you should see a\\n+frame the plug-in draws around its window. Below the plug-in window\\n+there are two buttons. Clicking on the buttons will result in calling\\n+native plugin methods from JavaScript. Show Version will instruct the\\n+plug-in to retrieve the Mozilla user agent string and display it in\\n+the plug-in window, Clear button will call plug-in method to erase the\\n+window.\\n+\\n+<br><br>\\n+\\n+<center>\\n+\\n+<script>\\n+function bar(arg)\\n+{\\n+  document.getElementById(\\\"result\\\").innerHTML += \\\"<p>\\\" + \\\"function bar(\\\" + arg + \\\") called!\\\" + \\\"</p>\\\";\\n+\\n+  return 4;\\n+}\\n+</script>\\n+\\n+<div id=\\\"result\\\">\\n+<p>results go here:</p>\\n+</div>\\n+\\n+<embed id=\\\"embed1\\\" type=\\\"application/mozilla-npruntime-scriptable-plugin\\\" width=600 height=40><br>\\n+\\n+<embed type=\\\"application/x-java-mozilla-npruntime-scriptable-plugin\\\" style=\\\"display: block; width: 50%; height: 100px;\\\"><br>\\n+\\n+<script>\\n+var embed1 = document.getElementById('embed1');\\n+</script>\\n+\\n+<br>\\n+<form name=\\\"formname\\\">\\n+<input type=button value=\\\"Call pluginobj.foo()\\\" onclick='alert(pluginobj.foo())'>\\n+<input type=button value=\\\"alert(pluginobj.bar)\\\" onclick='alert(pluginobj.bar)'>\\n+<input type=button value=\\\"alert(pluginobj('foo'))\\\" onclick='alert(pluginobj(\\\"foo\\\"))'>\\n+<br>\\n+<input type=button value=\\\"alert(embed1.bar)\\\" onclick='alert(embed1.bar)'>\\n+<input type=button value=\\\"alert(embed1.foo())\\\" onclick='alert(embed1.foo())'>\\n+<input type=button value=\\\"alert(embed1())\\\" onclick='alert(embed1())'>\\n+<input type=button value=\\\"embed1.bar='foo'\\\" onclick='embed1.bar=\\\"foo\\\";'>\\n+</form>\\n+\\n+</center>\\n+\\n+</BODY>\\n+</HTML>\\n\""}