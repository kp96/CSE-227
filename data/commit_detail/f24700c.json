{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basf24700c\""},"diff":"\"f24700c OS/2 build bustage as a result of 32649 - once files are moved, this should build\\ndiff --git a/widget/src/os2/nsPrintOS2.cpp b/widget/src/os2/nsPrintOS2.cpp\\nnew file mode 100644\\nindex 0000000..0ce619d\\n--- /dev/null\\n+++ b/widget/src/os2/nsPrintOS2.cpp\\n@@ -0,0 +1,467 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is the Mozilla OS/2 libraries.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * John Fairhurst, <john_fairhurst@iname.com>.\\n+ * Portions created by the Initial Developer are Copyright (C) 1999\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *   Pierre Phaneuf <pp@ludusdesign.com>\\n+ *   Peter Weilbacher <mozilla@weilbacher.org>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either of the GNU General Public License Version 2 or later (the \\\"GPL\\\"),\\n+ * or the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+\\n+#include \\\"nsPrintOS2.h\\\"\\n+\\n+#include \\\"nsOS2Uni.h\\\"\\n+\\n+#include <stdlib.h>\\n+\\n+//---------------------------------------------------------------------------\\n+// OS/2 Printing   - was in libprint.cpp\\n+//---------------------------------------------------------------------------\\n+static HMODULE hmodRes;\\n+\\n+#define SHIFT_PTR(ptr,offset) ( *((LONG*)&ptr) += offset )\\n+\\n+\\n+class PRTQUEUE\\n+{\\n+public:\\n+   PRTQUEUE (const PRQINFO3* pPQI3)  { InitWithPQI3 (pPQI3); }\\n+   PRTQUEUE (const PRTQUEUE& PQInfo);\\n+  ~PRTQUEUE (void) { free (mpPQI3); }\\n+\\n+   PRQINFO3& PQI3 () const { return *mpPQI3; }\\n+   const char* DriverName () const { return mDriverName; }\\n+   const char* DeviceName () const { return mDeviceName; }\\n+   const char* PrinterName() const { return mPrinterName; }\\n+   const char* QueueName  () const { return mpPQI3->pszComment; }\\n+   \\n+private:\\n+   PRTQUEUE& operator = (const PRTQUEUE& z);        // prevent copying\\n+   void InitWithPQI3 (const PRQINFO3* pInfo);\\n+\\n+   PRQINFO3* mpPQI3;\\n+   unsigned  mPQI3BufSize;\\n+   char mDriverName  [DRIV_NAME_SIZE + 1];          // Driver name\\n+   char mDeviceName  [DRIV_DEVICENAME_SIZE + 1];    // Device name\\n+   char mPrinterName [PRINTERNAME_SIZE + 1];        // Printer name\\n+};\\n+\\n+\\n+PRTQUEUE::PRTQUEUE (const PRTQUEUE& PQInfo)\\n+{\\n+   mPQI3BufSize = PQInfo.mPQI3BufSize;\\n+   mpPQI3 = (PRQINFO3*)malloc (mPQI3BufSize);\\n+   memcpy (mpPQI3, PQInfo.mpPQI3, mPQI3BufSize);    // Copy entire buffer\\n+\\n+   long Diff = (long)mpPQI3 - (long)PQInfo.mpPQI3;  // Calculate the difference between addresses\\n+   SHIFT_PTR (mpPQI3->pszName,       Diff);         // Modify internal pointers accordingly\\n+   SHIFT_PTR (mpPQI3->pszSepFile,    Diff);\\n+   SHIFT_PTR (mpPQI3->pszPrProc,     Diff);\\n+   SHIFT_PTR (mpPQI3->pszParms,      Diff);\\n+   SHIFT_PTR (mpPQI3->pszComment,    Diff);\\n+   SHIFT_PTR (mpPQI3->pszPrinters,   Diff);\\n+   SHIFT_PTR (mpPQI3->pszDriverName, Diff);\\n+   SHIFT_PTR (mpPQI3->pDriverData,   Diff);\\n+\\n+   strcpy (mDriverName, PQInfo.mDriverName);\\n+   strcpy (mDeviceName, PQInfo.mDeviceName);\\n+   strcpy (mPrinterName, PQInfo.mPrinterName);\\n+}\\n+\\n+void PRTQUEUE::InitWithPQI3(const PRQINFO3* pInfo)\\n+{\\n+   // Make local copy of PPRQINFO3 object\\n+   ULONG SizeNeeded;\\n+   ::SplQueryQueue (NULL, pInfo->pszName, 3, NULL, 0, &SizeNeeded);\\n+   mpPQI3 = (PRQINFO3*)malloc (SizeNeeded);\\n+   ::SplQueryQueue (NULL, pInfo->pszName, 3, mpPQI3, SizeNeeded, &SizeNeeded);\\n+\\n+   mPQI3BufSize = SizeNeeded;\\n+\\n+   PCHAR sep = strchr (pInfo->pszDriverName, '.');\\n+\\n+   if (sep)\\n+   {\\n+      *sep = '\\\\0';\\n+      strcpy (mDriverName, pInfo->pszDriverName);\\n+      strcpy (mDeviceName, sep + 1);\\n+      *sep = '.';\\n+   } else\\n+   {\\n+      strcpy (mDriverName, pInfo->pszDriverName);\\n+      mDeviceName [0] = '\\\\0';\\n+   }\\n+\\n+\\n+   sep = strchr (pInfo->pszPrinters, ',');\\n+\\n+   if (sep)\\n+   {\\n+      *sep = '\\\\0';\\n+      strcpy (mPrinterName, pInfo->pszPrinters);\\n+      *sep = '.';\\n+   } else\\n+   {\\n+      strcpy (mPrinterName, pInfo->pszPrinters);\\n+   }\\n+}\\n+\\n+\\n+//===========================================================================\\n+\\n+PRINTDLG::PRINTDLG()\\n+{\\n+  mQueueCount = 0;\\n+\\n+  ULONG TotalQueues = 0;\\n+  ULONG MemNeeded = 0;\\n+  SPLERR rc;\\n+  \\n+  rc = ::SplEnumQueue(NULL, 3, NULL, 0, &mQueueCount, &TotalQueues, &MemNeeded, NULL);\\n+  PRQINFO3* pPQI3Buf = (PRQINFO3*) malloc (MemNeeded);\\n+  rc = ::SplEnumQueue(NULL, 3, pPQI3Buf, MemNeeded, &mQueueCount, &TotalQueues, &MemNeeded, NULL);\\n+\\n+  if (mQueueCount > MAX_PRINT_QUEUES)\\n+    mQueueCount = MAX_PRINT_QUEUES;\\n+\\n+  ULONG defaultQueue = 0;\\n+  for (ULONG cnt = 0; cnt < mQueueCount; cnt++) {\\n+    if (pPQI3Buf[cnt].fsType & PRQ3_TYPE_APPDEFAULT)\\n+      defaultQueue = cnt;\\n+    mPQBuf[cnt] = new PRTQUEUE(&pPQI3Buf[cnt]);\\n+  }\\n+\\n+  // move the entry for the default printer to index 0 (if necessary)\\n+  if (defaultQueue > 0) {\\n+    PRTQUEUE* temp = mPQBuf[0];\\n+    mPQBuf[0] = mPQBuf[defaultQueue];\\n+    mPQBuf[defaultQueue] = temp;\\n+  }\\n+\\n+  free(pPQI3Buf);\\n+}\\n+\\n+PRINTDLG::~PRINTDLG()\\n+{\\n+  for (ULONG index = 0; index < mQueueCount; index++)\\n+    delete mPQBuf[index];\\n+}\\n+\\n+void PRINTDLG::RefreshPrintQueue()\\n+{\\n+  ULONG newQueueCount = 0;\\n+  ULONG TotalQueues = 0;\\n+  ULONG MemNeeded = 0;\\n+  SPLERR rc;\\n+  \\n+  rc = ::SplEnumQueue(NULL, 3, NULL, 0, &newQueueCount, &TotalQueues, &MemNeeded, NULL);\\n+  PRQINFO3* pPQI3Buf = (PRQINFO3*)malloc(MemNeeded);\\n+  rc = ::SplEnumQueue(NULL, 3, pPQI3Buf, MemNeeded, &newQueueCount, &TotalQueues, &MemNeeded, NULL);\\n+\\n+  if (newQueueCount > MAX_PRINT_QUEUES)\\n+    newQueueCount = MAX_PRINT_QUEUES;\\n+\\n+  PRTQUEUE* tmpBuf[MAX_PRINT_QUEUES];\\n+\\n+  ULONG defaultQueue = 0;\\n+  for (ULONG cnt = 0; cnt < newQueueCount; cnt++) {\\n+    if (pPQI3Buf[cnt].fsType & PRQ3_TYPE_APPDEFAULT)\\n+      defaultQueue = cnt;\\n+\\n+    BOOL found = FALSE;\\n+    for (ULONG index = 0; index < mQueueCount && !found; index++) {\\n+       //Compare printer from requeried list with what's already in Mozilla's printer list(mPQBuf)\\n+       //If printer is already there, use current properties; otherwise create a new printer in list\\n+       if (mPQBuf[index] != 0) {\\n+         if ((strcmp(pPQI3Buf[cnt].pszPrinters, mPQBuf[index]->PrinterName()) == 0) && \\n+             (strcmp(pPQI3Buf[cnt].pszDriverName, mPQBuf[index]->PQI3().pszDriverName) == 0)) {\\n+           found = TRUE;\\n+           tmpBuf[cnt] = mPQBuf[index];\\n+           mPQBuf[index] = 0;\\n+         }\\n+       }\\n+    }\\n+    if (!found) \\n+       tmpBuf[cnt] = new PRTQUEUE(&pPQI3Buf[cnt]); \\n+  }\\n+\\n+  for (ULONG index = 0; index < newQueueCount; index++) {\\n+    if (mPQBuf[index] != 0)\\n+      delete(mPQBuf[index]);\\n+    mPQBuf[index] = tmpBuf[index];\\n+  }\\n+\\n+  if (mQueueCount > newQueueCount)\\n+    for (ULONG index = newQueueCount; index < mQueueCount; index++)\\n+       if (mPQBuf[index] != 0)\\n+         delete(mPQBuf[index]);\\n+\\n+  mQueueCount = newQueueCount;\\n+\\n+  // move the entry for the default printer to index 0 (if necessary)\\n+  if (defaultQueue > 0) {\\n+    PRTQUEUE* temp = mPQBuf[0];\\n+    mPQBuf[0] = mPQBuf[defaultQueue];\\n+    mPQBuf[defaultQueue] = temp;\\n+  }\\n+\\n+  free(pPQI3Buf);\\n+}\\n+\\n+ULONG PRINTDLG::GetNumPrinters()\\n+{\\n+   return mQueueCount;\\n+}\\n+\\n+void PRINTDLG::GetPrinter(ULONG printerNdx, char** printerName)\\n+{\\n+   if (printerNdx >= mQueueCount)\\n+      return;\\n+ \\n+   nsCAutoString pName(mPQBuf[printerNdx]->QueueName());\\n+ \\n+   pName.ReplaceChar('\\\\r', ' ');\\n+   pName.StripChars(\\\"\\\\n\\\");\\n+   *printerName = ToNewCString(pName);\\n+}\\n+\\n+PRTQUEUE* PRINTDLG::SetPrinterQueue(ULONG printerNdx)\\n+{\\n+   PRTQUEUE *pPQ = NULL;\\n+\\n+   if (printerNdx >= mQueueCount)\\n+      return NULL;\\n+\\n+   pPQ = mPQBuf[printerNdx];\\n+\\n+   return new PRTQUEUE(*pPQ);\\n+}\\n+\\n+LONG PRINTDLG::GetPrintDriverSize(ULONG printerNdx)\\n+{\\n+   return mPQBuf[printerNdx]->PQI3().pDriverData->cb;\\n+}\\n+\\n+PDRIVDATA PRINTDLG::GetPrintDriver(ULONG printerNdx)\\n+{\\n+   if (printerNdx >= mQueueCount)\\n+      return NULL;\\n+\\n+   return mPQBuf[printerNdx]->PQI3().pDriverData;\\n+}\\n+\\n+HDC PRINTDLG::GetDCHandle(ULONG printerNdx)\\n+{\\n+    HDC hdc = 0;\\n+    DEVOPENSTRUC dop;\\n+\\n+    dop.pszLogAddress      = 0; \\n+    dop.pszDriverName      = (char *)mPQBuf[printerNdx]->DriverName();\\n+    dop.pdriv              = mPQBuf[printerNdx]->PQI3().pDriverData;\\n+    dop.pszDataType        = 0; \\n+    dop.pszComment         = 0;\\n+    dop.pszQueueProcName   = 0;     \\n+    dop.pszQueueProcParams = 0;   \\n+    dop.pszSpoolerParams   = 0;     \\n+    dop.pszNetworkParams   = 0;     \\n+\\n+    hdc = ::DevOpenDC(0, OD_INFO, \\\"*\\\", 9, (PDEVOPENDATA) &dop, NULLHANDLE);\\n+    return hdc;\\n+}\\n+\\n+char* PRINTDLG::GetDriverType(ULONG printerNdx)\\n+{\\n+  return (char *)mPQBuf[printerNdx]->DriverName ();\\n+}\\n+\\n+BOOL PRINTDLG::ShowProperties(ULONG printerNdx)\\n+{\\n+    BOOL          rc = FALSE;\\n+    LONG          devrc = FALSE;\\n+    PDRIVDATA     pOldDrivData;\\n+    PDRIVDATA     pNewDrivData = NULL;\\n+    LONG          buflen;\\n+\\n+/* check size of buffer required for job properties */\\n+    buflen = DevPostDeviceModes( 0 /*hab*/,\\n+                                 NULL,\\n+                                 mPQBuf[printerNdx]->DriverName (),\\n+                                 mPQBuf[printerNdx]->DeviceName (),\\n+                                 mPQBuf[printerNdx]->PrinterName (),\\n+                                 DPDM_POSTJOBPROP);\\n+\\n+/* return error to caller */\\n+    if (buflen <= 0)\\n+        return(buflen);\\n+\\n+/* allocate some memory for larger job properties and */\\n+/* return error to caller */\\n+\\n+    if (buflen != mPQBuf[printerNdx]->PQI3().pDriverData->cb)\\n+    {\\n+        if (DosAllocMem((PPVOID)&pNewDrivData,buflen,fALLOC))\\n+            return(FALSE); // DPDM_ERROR\\n+    \\n+/* copy over old data so driver can use old job */\\n+/* properties as base for job properties dialog */\\n+        pOldDrivData = mPQBuf[printerNdx]->PQI3().pDriverData;\\n+        mPQBuf[printerNdx]->PQI3().pDriverData = pNewDrivData;\\n+        memcpy( (PSZ)pNewDrivData, (PSZ)pOldDrivData, pOldDrivData->cb );\\n+    }\\n+\\n+/* display job properties dialog and get updated */\\n+/* job properties from driver */\\n+\\n+    devrc = DevPostDeviceModes( 0 /*hab*/,\\n+                                mPQBuf[printerNdx]->PQI3().pDriverData,\\n+                                mPQBuf[printerNdx]->DriverName (),\\n+                                mPQBuf[printerNdx]->DeviceName (),\\n+                                mPQBuf[printerNdx]->PrinterName (),\\n+                                DPDM_POSTJOBPROP);\\n+    rc = (devrc != DPDM_ERROR);\\n+    return rc;\\n+}\\n+\\n+/****************************************************************************/\\n+/*  Job management                                                          */\\n+/****************************************************************************/\\n+\\n+HDC PrnOpenDC( PRTQUEUE *pInfo, PSZ pszApplicationName, int copies, int destination, char *file )\\n+{\\n+   HDC hdc = 0;\\n+   PSZ pszLogAddress;\\n+   PSZ pszDataType;\\n+   LONG dcType;\\n+   DEVOPENSTRUC dop;\\n+\\n+   if (!pInfo || !pszApplicationName)\\n+      return hdc;\\n+\\n+   if ( destination ) {\\n+      pszLogAddress = pInfo->PQI3 ().pszName;\\n+      pszDataType = \\\"PM_Q_STD\\\";\\n+      if ( destination == 2 )\\n+         dcType = OD_METAFILE;\\n+      else\\n+         dcType = OD_QUEUED;\\n+   } else {\\n+      if (file && *file)\\n+         pszLogAddress = (PSZ) file;\\n+      else    \\n+         pszLogAddress = \\\"FILE\\\";\\n+      pszDataType = \\\"PM_Q_RAW\\\";\\n+      dcType = OD_DIRECT;\\n+   } \\n+\\n+   dop.pszLogAddress      = pszLogAddress; \\n+   dop.pszDriverName      = (char*)pInfo->DriverName ();\\n+   dop.pdriv              = pInfo->PQI3 ().pDriverData;\\n+   dop.pszDataType        = pszDataType; \\n+   dop.pszComment         = pszApplicationName;\\n+   dop.pszQueueProcName   = pInfo->PQI3 ().pszPrProc;     \\n+   dop.pszQueueProcParams = 0;\\n+   dop.pszSpoolerParams   = 0;     \\n+   dop.pszNetworkParams   = 0;     \\n+\\n+   hdc = ::DevOpenDC( 0, dcType, \\\"*\\\", 9, (PDEVOPENDATA) &dop, NULLHANDLE);\\n+\\n+#ifdef DEBUG\\n+   if (hdc == 0)\\n+   {\\n+      ULONG ErrorCode = ERRORIDERROR (::WinGetLastError (0));\\n+      printf (\\\"!ERROR! - Can't open DC for printer %04lX\\\\a\\\\n\\\", ErrorCode);\\n+   }   \\n+#endif\\n+\\n+   return hdc;\\n+}\\n+\\n+/* find the selected form */\\n+BOOL PrnQueryHardcopyCaps( HDC hdc, PHCINFO pHCInfo)\\n+{\\n+   BOOL rc = FALSE;\\n+\\n+   if( hdc && pHCInfo)\\n+   {\\n+      PHCINFO pBuffer;\\n+      long    lAvail, i;\\n+\\n+      /* query how many forms are available */\\n+      lAvail = ::DevQueryHardcopyCaps( hdc, 0, 0, NULL);\\n+\\n+      pBuffer = (PHCINFO) malloc( lAvail * sizeof(HCINFO));\\n+\\n+      ::DevQueryHardcopyCaps( hdc, 0, lAvail, pBuffer);\\n+\\n+      for( i = 0; i < lAvail; i++)\\n+         if( pBuffer[ i].flAttributes & HCAPS_CURRENT)\\n+         {\\n+            memcpy( pHCInfo, pBuffer + i, sizeof(HCINFO));\\n+            rc = TRUE;\\n+            break;\\n+         }\\n+\\n+      free( pBuffer);\\n+   }\\n+\\n+   return rc;\\n+}\\n+\\n+\\n+/****************************************************************************/\\n+/*  Library-level data and functions    -Printing                           */\\n+/****************************************************************************/\\n+\\n+BOOL PrnInitialize( HMODULE hmodResources)\\n+{\\n+   hmodRes = hmodResources;\\n+   return TRUE;\\n+}\\n+\\n+BOOL PrnTerminate()\\n+{\\n+   /* nop for now, may do something eventually */\\n+   return TRUE;\\n+}\\n+\\n+BOOL PrnClosePrinter( PRTQUEUE *pPrintQueue)\\n+{\\n+   BOOL rc = FALSE;\\n+\\n+   if (pPrintQueue)\\n+   {\\n+      delete pPrintQueue;\\n+      rc = TRUE;\\n+   }\\n+\\n+   return rc;\\n+}\\n+\\ndiff --git a/widget/src/os2/nsPrintOS2.h b/widget/src/os2/nsPrintOS2.h\\nnew file mode 100644\\nindex 0000000..9f6babd\\n--- /dev/null\\n+++ b/widget/src/os2/nsPrintOS2.h\\n@@ -0,0 +1,99 @@\\n+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is mozilla.org code.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Netscape Communications Corporation.\\n+ * Portions created by the Initial Developer are Copyright (C) 1998\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *   John Fairhurst <john_fairhurst@iname.com>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either of the GNU General Public License Version 2 or later (the \\\"GPL\\\"),\\n+ * or the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+\\n+#ifndef nsPrintOS2_h___\\n+#define nsPrintOS2_h___\\n+\\n+#define INCL_PM\\n+#define INCL_DOS\\n+#define INCL_DOSERRORS\\n+#define INCL_SPLDOSPRINT\\n+#define INCL_DEV\\n+#define INCL_DEVDJP\\n+#define INCL_GRE_DEVICE\\n+#include <os2.h>\\n+#include <pmddim.h>\\n+\\n+//---------------------------------------------------------------------------\\n+// OS/2 Printing   - was in libprint\\n+//---------------------------------------------------------------------------\\n+// Library init and term; job properties per queue are cached during run.\\n+BOOL PrnInitialize(HMODULE hmodResources);\\n+BOOL PrnTerminate(void);\\n+\\n+// opaque type to describe a print queue (printer)\\n+class PRTQUEUE;\\n+\\n+#define MAX_PRINT_QUEUES  (128)\\n+\\n+class PRINTDLG\\n+{\\n+public:\\n+   PRINTDLG();\\n+  ~PRINTDLG();\\n+   void      RefreshPrintQueue();\\n+   ULONG     GetNumPrinters();\\n+   void      GetPrinter(ULONG printerNdx, char** printerName);\\n+   PRTQUEUE* SetPrinterQueue(ULONG printerNdx);\\n+   LONG      GetPrintDriverSize(ULONG printerNdx);\\n+   PDRIVDATA GetPrintDriver(ULONG printerNdx);\\n+   HDC       GetDCHandle(ULONG printerNdx);\\n+   char*     GetDriverType(ULONG printerNdx);\\n+   BOOL      ShowProperties(ULONG printerNdx);\\n+\\n+private:\\n+  ULONG      mQueueCount;\\n+  PRTQUEUE*  mPQBuf[MAX_PRINT_QUEUES];\\n+};\\n+\\n+\\n+// Release app. resources associated with a printer\\n+BOOL PrnClosePrinter( PRTQUEUE *pPrintQueue);\\n+\\n+// Get a DC for the selected printer.  Must supply the application name.\\n+HDC PrnOpenDC( PRTQUEUE *pPrintQueue, PSZ pszApplicationName, int copies, int destination, char *file);\\n+\\n+// Get the hardcopy caps for the selected form\\n+BOOL PrnQueryHardcopyCaps( HDC hdc, PHCINFO pHCInfo);\\n+\\n+// Abort the current job started with PrnStartJob().\\n+BOOL PrnAbortJob( HDC hdc);\\n+\\n+\\n+\\n+#endif\\n\""}