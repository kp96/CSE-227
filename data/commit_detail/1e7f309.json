{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas1e7f309\""},"diff":"\"1e7f309 Bug 384810 - DM should restore the database state gracefully after a crash.  r=mano\\ndiff --git a/browser/components/sessionstore/src/nsSessionStore.js b/browser/components/sessionstore/src/nsSessionStore.js\\nindex 00de359..a84f202 100644\\n--- a/browser/components/sessionstore/src/nsSessionStore.js\\n+++ b/browser/components/sessionstore/src/nsSessionStore.js\\n@@ -1627,41 +1627,9 @@ SessionStoreService.prototype = {\\n    * Restart incomplete downloads\\n    */\\n   retryDownloads: function sss_retryDownloads() {\\n-    var ioService = Cc[\\\"@mozilla.org/network/io-service;1\\\"].\\n-                    getService(Ci.nsIIOService);\\n+    // The download manager cleans up after itself when it is created.\\n     var dlManager = Cc[\\\"@mozilla.org/download-manager;1\\\"].\\n                     getService(Ci.nsIDownloadManager);\\n-    \\n-    function AsyncDownloadRetrier(aDlId) {\\n-      this._dlId = aDlId;\\n-      this._dlManager = dlManager;\\n-    }\\n-    AsyncDownloadRetrier.prototype = {\\n-      onStartRequest: function(aRequest, aContext) { },\\n-      onStopRequest: function(aRequest, aContext, aStatus) {\\n-        if (Components.isSuccessCode(aStatus))\\n-          this._dlManager.retryDownload(this._dlId);\\n-      }\\n-    };\\n-    \\n-    var stmt = dlManager.DBConnection.\\n-                         createStatement(\\\"SELECT id, source \\\" +\\n-                                         \\\"FROM moz_downloads \\\" +\\n-                                         \\\"WHERE state = ?1\\\");\\n-    stmt.bindInt32Parameter(0, Ci.nsIDownloadManager.DOWNLOAD_DOWNLOADING);\\n-\\n-    // restart all downloads that were in progress before the crash\\n-    // and which are currently available through the network\\n-    while (stmt.executeStep()) {\\n-      var dlId = stmt.getInt64(0);\\n-      var url = stmt.getUTF8String(1);\\n-      \\n-      var linkChecker = Cc[\\\"@mozilla.org/network/urichecker;1\\\"].\\n-                        createInstance(Ci.nsIURIChecker);\\n-      linkChecker.init(ioService.newURI(url, null, null));\\n-      linkChecker.loadFlags = Ci.nsIRequest.LOAD_BACKGROUND;\\n-      linkChecker.asyncCheck(new AsyncDownloadRetrier(dlId), null);\\n-    }\\n   },\\n \\n /* ........ Disk Access .............. */\\ndiff --git a/toolkit/components/downloads/src/nsDownloadManager.cpp b/toolkit/components/downloads/src/nsDownloadManager.cpp\\nindex ae96135..7e00536 100644\\n--- a/toolkit/components/downloads/src/nsDownloadManager.cpp\\n+++ b/toolkit/components/downloads/src/nsDownloadManager.cpp\\n@@ -70,6 +70,7 @@\\n #include \\\"nsIPropertyBag2.h\\\"\\n #include \\\"nsIHttpChannel.h\\\"\\n #include \\\"nsIDownloadManagerUI.h\\\"\\n+#include \\\"nsTArray.h\\\"\\n \\n #ifdef XP_WIN\\n #include <shlobj.h>\\n@@ -485,6 +486,62 @@ nsDownloadManager::ImportDownloadHistory()\\n   return NS_OK;\\n }\\n \\n+nsresult\\n+nsDownloadManager::RestoreDatabaseState()\\n+{\\n+  // First, we get all the downloads that are supposedly active, but are not\\n+  // really because we crashed.\\n+  nsCOMPtr<mozIStorageStatement> stmt;\\n+  nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(\\n+    \\\"SELECT id \\\"\\n+    \\\"FROM moz_downloads \\\"\\n+    \\\"WHERE state = ?1 \\\"\\n+    \\\"OR state = ?2 \\\"\\n+    \\\"OR state = ?3\\\"), getter_AddRefs(stmt));\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  rv = stmt->BindInt32Parameter(0, nsIDownloadManager::DOWNLOAD_NOTSTARTED);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+  rv = stmt->BindInt32Parameter(1, nsIDownloadManager::DOWNLOAD_QUEUED);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+  rv = stmt->BindInt32Parameter(2, nsIDownloadManager::DOWNLOAD_DOWNLOADING);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  // Next, we iterate through them storing them in an array\\n+  nsTArray<PRUint32> ids;\\n+  PRBool hasResults;\\n+  while (NS_SUCCEEDED(stmt->ExecuteStep(&hasResults)) && hasResults)\\n+    (void)ids.AppendElement(stmt->AsInt32(0));\\n+\\n+  rv = stmt->Reset();\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  // Third, change all of those downloads to a failed state so we will be able\\n+  // to retry them.\\n+  rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(\\n+    \\\"UPDATE moz_downloads \\\"\\n+    \\\"SET state = ?1 \\\"\\n+    \\\"WHERE state = ?2 \\\"\\n+    \\\"OR state = ?3 \\\"\\n+    \\\"OR state = ?4\\\"), getter_AddRefs(stmt));\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  rv = stmt->BindInt32Parameter(0, nsIDownloadManager::DOWNLOAD_FAILED);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+  rv = stmt->BindInt32Parameter(1, nsIDownloadManager::DOWNLOAD_NOTSTARTED);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+  rv = stmt->BindInt32Parameter(2, nsIDownloadManager::DOWNLOAD_QUEUED);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+  rv = stmt->BindInt32Parameter(3, nsIDownloadManager::DOWNLOAD_DOWNLOADING);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  // Finally, let's retry all of those downloads\\n+  for (nsTArray<PRUint32>::size_type i = 0; i < ids.Length(); i++)\\n+    (void)RetryDownload(ids[i]);\\n+\\n+  return NS_OK;\\n+}\\n+\\n PRInt64\\n nsDownloadManager::AddDownloadToDB(const nsAString &aName,\\n                                    const nsACString &aSource,\\n@@ -550,6 +607,9 @@ nsDownloadManager::Init()\\n   if (doImport)\\n     ImportDownloadHistory();\\n \\n+  rv = RestoreDatabaseState();\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n   nsCOMPtr<nsIStringBundleService> bundleService =\\n     do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);\\n   NS_ENSURE_SUCCESS(rv, rv);\\ndiff --git a/toolkit/components/downloads/src/nsDownloadManager.h b/toolkit/components/downloads/src/nsDownloadManager.h\\nindex 3456e03..17b77ee 100644\\n--- a/toolkit/components/downloads/src/nsDownloadManager.h\\n+++ b/toolkit/components/downloads/src/nsDownloadManager.h\\n@@ -97,6 +97,7 @@ protected:\\n   nsresult InitDB(PRBool *aDoImport);\\n   nsresult CreateTable();\\n   nsresult ImportDownloadHistory();\\n+  nsresult RestoreDatabaseState();\\n   nsresult GetDownloadFromDB(PRUint32 aID, nsDownload **retVal);\\n \\n   inline nsresult AddToCurrentDownloads(nsDownload *aDl)\\n\""}