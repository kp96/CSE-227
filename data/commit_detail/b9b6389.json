{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basb9b6389\""},"diff":"\"b9b6389 fix for bug #318168, tab browsing improvements such as: 1)  when we have \\\"too many\\\" tabs in a window, allow the user to scroll through the tabs. 2)  add events for when adding and removing tabs initial patch by mconnor.  final patch r=mconnor\\ndiff --git a/browser/base/content/tabbrowser.xml b/browser/base/content/tabbrowser.xml\\nindex b94fda5..3590b48 100644\\n--- a/browser/base/content/tabbrowser.xml\\n+++ b/browser/base/content/tabbrowser.xml\\n@@ -106,7 +106,7 @@\\n             <xul:tab selected=\\\"true\\\" validate=\\\"never\\\"\\n                      onerror=\\\"this.parentNode.parentNode.parentNode.parentNode.addToMissedIconCache(this.getAttribute('image'));\\n                               this.removeAttribute('image');\\\"\\n-                     maxwidth=\\\"250\\\" width=\\\"0\\\" minwidth=\\\"30\\\" flex=\\\"100\\\"\\n+                     maxwidth=\\\"250\\\" width=\\\"0\\\" minwidth=\\\"140\\\" flex=\\\"100\\\"\\n                      class=\\\"tabbrowser-tab\\\" label=\\\"&untitledTab;\\\" crop=\\\"end\\\"/>\\n           </xul:tabs>\\n         </xul:hbox>\\n@@ -1083,6 +1083,10 @@\\n             if (!this.mTabbedMode)\\n               this.enterTabbedMode();\\n \\n+            // if we're adding tabs, we're past interrupt mode, ditch the owner\\n+            if (this.mCurrentTab.owner)\\n+              this.mCurrentTab.owner = null;\\n+\\n             var t = document.createElementNS(\\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\",\\n                                              \\\"tab\\\");\\n \\n@@ -1095,13 +1099,17 @@\\n \\n             t.setAttribute(\\\"crop\\\", \\\"end\\\");\\n             t.maxWidth = 250;\\n-            t.minWidth = 30;\\n+            t.minWidth = 140;\\n             t.width = 0;\\n             t.setAttribute(\\\"flex\\\", \\\"100\\\");\\n             t.setAttribute(\\\"validate\\\", \\\"never\\\");\\n             t.setAttribute(\\\"onerror\\\", \\\"this.parentNode.parentNode.parentNode.parentNode.addToMissedIconCache(this.getAttribute('image')); this.removeAttribute('image');\\\");\\n             t.className = \\\"tabbrowser-tab\\\";\\n+            \\n             this.mTabContainer.appendChild(t);\\n+            // invalidate cache, because mTabContainer is about to change\\n+            this._browsers = null; \\n+\\n             // If this new tab is owned by another, assert that relationship\\n             if (aOwner !== undefined && aOwner !== null) {\\n               t.owner = aOwner;\\n@@ -1178,6 +1186,13 @@\\n               b.loadURIWithFlags(aURI, flags, aReferrerURI, aCharset, aPostData);\\n             }\\n \\n+            // Dispatch a new tab notification.  We do this once we're\\n+            // entirely done, so that things are in a consistent state\\n+            // even if the event listener opens or closes tabs.\\n+            var evt = document.createEvent(\\\"Events\\\");\\n+            evt.initEvent(\\\"TabOpen\\\", true, false);\\n+            t.dispatchEvent(evt);\\n+\\n             return t;\\n           ]]>\\n         </body>\\n@@ -1291,6 +1306,14 @@\\n             if (ds.contentViewer && !ds.contentViewer.permitUnload())\\n               return;\\n \\n+            // We're committed to closing the tab now.  \\n+            // Dispatch a notification.\\n+            // We dispatch it before any teardown so that event listeners can\\n+            // inspect the tab that's about to close.\\n+            var evt = document.createEvent(\\\"Events\\\");\\n+            evt.initEvent(\\\"TabClose\\\", true, false);\\n+            aTab.dispatchEvent(evt);\\n+\\n             if (l == 1) {\\n               // add a new blank tab to replace the one being closed\\n               // (this ensures that the remaining tab is as good as new)\\n@@ -1358,6 +1381,8 @@\\n \\n             // Remove the tab\\n             this.mTabContainer.removeChild(oldTab);\\n+            // invalidate cache, because mTabContainer is about to change\\n+            this._browsers = null; \\n             this.mPanelContainer.removeChild(oldBrowser.parentNode);\\n \\n             // Find the tab to select\\n@@ -1432,8 +1457,8 @@\\n         <body>\\n           <![CDATA[\\n             if (aEvent.button == 0 &&\\n-                // Only capture clicks on tabbox.xml's <spacer>\\n-                aEvent.originalTarget.localName == \\\"spacer\\\") {\\n+                aEvent.originalTarget.localName == \\\"box\\\") {\\n+              // xxx this needs to check that we're in the empty area of the tabstrip\\n               var e = document.createEvent(\\\"Events\\\");\\n               e.initEvent(\\\"NewTab\\\", true, true);\\n               this.dispatchEvent(e);\\n@@ -1581,30 +1606,114 @@\\n         <parameter name=\\\"aDragSession\\\"/>\\n         <body>\\n           <![CDATA[\\n-            if (aDragSession.canDrop && aDragSession.sourceNode &&\\n-                aDragSession.sourceNode.parentNode == this.mTabContainer) {\\n+            if (aDragSession.canDrop && aDragSession.sourceNode) {\\n+              // autoscroll the tab strip if we drag over the autorepeat\\n+              // buttons, even if we aren't dragging a tab, but then\\n+              // return to avoid drawing the drop indicator\\n+              var isTabDrag = (aDragSession.sourceNode.parentNode == this.mTabContainer);\\n+              var pixelsToScroll = 0;\\n+              var tabStrip = this.mTabContainer.mTabstrip;\\n+              if (aEvent.originalTarget.localName == \\\"autorepeatbutton\\\") {\\n+                if (aEvent.originalTarget.getAttribute(\\\"class\\\") == \\n+                    \\\"autorepeatbutton-up\\\")\\n+                  pixelsToScroll = tabStrip.scrollIncrement * -1;\\n+                else\\n+                  pixelsToScroll = tabStrip.scrollIncrement;\\n+                tabStrip.scrollByPixels(pixelsToScroll);\\n+              }\\n+\\n+              if (!isTabDrag)\\n+                return;\\n+\\n               var newIndex = this.getNewIndex(aEvent);\\n \\n               var ib = this.mTabDropIndicatorBar;\\n               var ind = ib.firstChild;\\n               ib.setAttribute('dragging','true');\\n \\n-              if (window.getComputedStyle(this.parentNode, null).direction == \\\"ltr\\\") {\\n+              var tabStripBoxObject = tabStrip.scrollBoxObject;\\n+              var halfIndWidth = Math.floor((ind.boxObject.width + 1) / 2);\\n+              if (window.getComputedStyle(this.parentNode, null)\\n+                        .direction == \\\"ltr\\\") {\\n+                var newMarginLeft;\\n+                var minMarginLeft = tabStripBoxObject.x - halfIndWidth;\\n+                // make sure we don't place the tab drop indicator past the\\n+                // edge, or the containing box will flex and stretch\\n+                // the tab drop indicator bar, which will flex the url bar.  \\n+                // XXX todo\\n+                // just use first value if you can figure out how to get\\n+                // the tab drop indicator to crop instead of flex and stretch\\n+                // the tab drop indicator bar.\\n+                var maxMarginLeft = Math.min(\\n+                  (minMarginLeft + tabStripBoxObject.width), \\n+                  (ib.boxObject.x + ib.boxObject.width - ind.boxObject.width));\\n+\\n+                // if we are scrolling, put the drop indicator at the edge\\n+                // so that it doesn't jump while scrolling\\n+                if (pixelsToScroll > 0)\\n+                  newMarginLeft = maxMarginLeft;\\n+                else if (pixelsToScroll < 0)\\n+                  newMarginLeft = minMarginLeft;\\n+                else {\\n                 if (newIndex == this.mTabs.length) {\\n-                  ind.style.marginLeft = this.mTabs[newIndex-1].boxObject.x +\\n-                                         this.mTabs[newIndex-1].boxObject.width - this.boxObject.x - 7 + 'px';\\n+                    newMarginLeft = this.mTabs[newIndex-1].boxObject.screenX +\\n+                                    this.mTabs[newIndex-1].boxObject.width - \\n+                                    this.boxObject.screenX - halfIndWidth;\\n                 } else {\\n-                  ind.style.marginLeft = this.mTabs[newIndex].boxObject.x - this.boxObject.x - 7 + 'px';\\n+                    newMarginLeft = this.mTabs[newIndex].boxObject.screenX - \\n+                                    this.boxObject.screenX - halfIndWidth;\\n                 }\\n+\\n+                  // ensure we never place the drop indicator beyond\\n+                  // our limits\\n+                  if (newMarginLeft < minMarginLeft)\\n+                    newMarginLeft = minMarginLeft;\\n+                  else if (newMarginLeft > maxMarginLeft)\\n+                    newMarginLeft = maxMarginLeft;\\n+                }\\n+                ind.style.marginLeft = newMarginLeft + 'px';\\n               } else {\\n+                var newMarginRight;\\n+                var minMarginRight = tabStripBoxObject.x - halfIndWidth;\\n+                // make sure we don't place the tab drop indicator past the\\n+                // edge, or the containing box will flex and stretch\\n+                // the tab drop indicator bar, which will flex the url bar.  \\n+                // XXX todo\\n+                // just use first value if you can figure out how to get\\n+                // the tab drop indicator to crop instead of flex and stretch\\n+                // the tab drop indicator bar.\\n+                var maxMarginRight = Math.min(\\n+                  (minMarginRight + tabStripBoxObject.width), \\n+                  (ib.boxObject.x + ib.boxObject.width - ind.boxObject.width));\\n+\\n+                // if we are scrolling, put the drop indicator at the edge\\n+                // so that it doesn't jump while scrolling\\n+                if (pixelsToScroll > 0)\\n+                  newMarginRight = maxMarginRight;\\n+                else if (pixelsToScroll < 0)\\n+                  newMarginRight = minMarginRight;\\n+                else {\\n                 if (newIndex == this.mTabs.length) {\\n-                  ind.style.marginRight = this.boxObject.width + this.boxObject.x -\\n-                                          this.mTabs[newIndex-1].boxObject.x + 'px';\\n+                    newMarginRight = this.boxObject.width + \\n+                                     this.boxObject.screenX -\\n+                                     this.mTabs[newIndex-1].boxObject.screenX -\\n+                                     halfIndWidth;\\n                 } else {\\n-                  ind.style.marginRight = this.boxObject.width + this.boxObject.x -\\n-                                          this.mTabs[newIndex].boxObject.x -\\n-                                          this.mTabs[newIndex].boxObject.width + 'px';\\n+                    newMarginRight = this.boxObject.width + \\n+                                     this.boxObject.screenX -\\n+                                     this.mTabs[newIndex].boxObject.screenX -\\n+                                     this.mTabs[newIndex].boxObject.width -\\n+                                     halfIndWidth;\\n+                  }\\n+\\n+                  // ensure we never place the drop indicator beyond\\n+                  // our limits\\n+                  if (newMarginRight < minMarginRight)\\n+                    newMarginRight = minMarginRight;\\n+                  else if (newMarginRight > maxMarginRight)\\n+                    newMarginRight = maxMarginRight;\\n                 }\\n+                ind.style.marginRight = newMarginRight + 'px';\\n               }\\n             }\\n           ]]>\\n@@ -1696,15 +1805,24 @@\\n           this.mTabFilters.splice(aIndex, 0, this.mTabFilters.splice(aTab._tPos, 1)[0]);\\n           this.mTabListeners.splice(aIndex, 0, this.mTabListeners.splice(aTab._tPos, 1)[0]);\\n \\n+          var oldPosition = aTab._tPos;\\n+\\n           aIndex = aIndex < aTab._tPos ? aIndex: aIndex+1;\\n           this.mCurrentTab.selected = false;\\n           this.mTabContainer.insertBefore(aTab, this.mTabContainer.childNodes[aIndex]);\\n+          // invalidate cache, because mTabContainer is about to change\\n+          this._browsers = null;\\n \\n           var i;\\n           for (i = 0; i < this.mTabContainer.childNodes.length; i++) {\\n             this.mTabContainer.childNodes[i]._tPos = i;\\n           }\\n           this.mCurrentTab.selected = true;\\n+\\n+          var evt = document.createEvent(\\\"UIEvents\\\");\\n+          evt.initUIEvent(\\\"TabMove\\\", true, false, window, oldPosition);\\n+          aTab.dispatchEvent(evt);\\n+\\n           return aTab;\\n         ]]>\\n         </body>\\n@@ -1717,11 +1835,11 @@\\n             var i;\\n             if (window.getComputedStyle(this.parentNode, null).direction == \\\"ltr\\\") {\\n               for (i = aEvent.target.localName == \\\"tab\\\" ? aEvent.target._tPos : 0; i < this.mTabs.length; i++)\\n-                if (aEvent.clientX < this.mTabs[i].boxObject.x + this.mTabs[i].boxObject.width / 2)\\n+                if (aEvent.screenX < this.mTabs[i].boxObject.screenX + this.mTabs[i].boxObject.width / 2) \\n                   return i;\\n             } else {\\n                for (i = aEvent.target.localName == \\\"tab\\\" ? aEvent.target._tPos : 0; i < this.mTabs.length; i++)\\n-                if (aEvent.clientX > this.mTabs[i].boxObject.x + this.mTabs[i].boxObject.width / 2)\\n+                if (aEvent.screenX > this.mTabs[i].boxObject.screenX + this.mTabs[i].boxObject.width / 2)\\n                   return i;\\n             }\\n \\n@@ -2264,9 +2382,13 @@\\n   <binding id=\\\"tabbrowser-tabs\\\"\\n            extends=\\\"chrome://global/content/bindings/tabbox.xml#tabs\\\">\\n     <content>\\n-      <xul:hbox flex=\\\"1\\\" style=\\\"min-width: 1px;\\\">\\n+      <xul:arrowscrollbox anonid=\\\"arrowscrollbox\\\" orient=\\\"horizontal\\\" flex=\\\"1\\\" style=\\\"min-width: 1px;\\\" clicktoscroll=\\\"true\\\">\\n         <children includes=\\\"tab\\\"/>\\n-        <xul:spacer class=\\\"tabs-right\\\" flex=\\\"1\\\"/>\\n+      </xul:arrowscrollbox>\\n+      <xul:hbox class=\\\"tabs-closebutton-box\\\" align=\\\"center\\\" pack=\\\"end\\\" anonid=\\\"tabstrip-closebutton\\\">\\n+        <xul:toolbarbutton ondblclick=\\\"event.stopPropagation();\\\"\\n+                           class=\\\"close-button tabs-closebutton\\\"\\n+                           oncommand=\\\"this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.removeCurrentTab()\\\"/>\\n       </xul:hbox>\\n     </content>\\n     <implementation>\\n@@ -2276,20 +2398,32 @@\\n             getService(Components.interfaces.nsIPrefBranch2);\\n         try {\\n           this.mTabClipWidth = pb2.getIntPref(\\\"browser.tabs.tabClipWidth\\\");\\n+          this.mCloseButtons = pb2.getIntPref(\\\"browser.tabs.closeButtons\\\");\\n         }\\n         catch (e) {\\n         }\\n \\n         this._updateDisableBackgroundClose();\\n+        this.adjustTabstrip(false);\\n+\\n         pb2.addObserver(\\\"browser.tabs.disableBackgroundClose\\\", this._prefObserver, true);\\n+        pb2.addObserver(\\\"browser.tabs.closeButtons\\\", this._prefObserver, true);\\n \\n         var self = this;\\n         function onResize() {\\n-          self.adjustCloseButtons(1);\\n+          self.adjustTabstrip(false);\\n         }\\n         window.addEventListener(\\\"resize\\\", onResize, false);\\n       </constructor>\\n \\n+      <field name=\\\"mTabstrip\\\">\\n+        document.getAnonymousElementByAttribute(this, \\\"anonid\\\", \\\"arrowscrollbox\\\");\\n+      </field>\\n+\\n+      <field name=\\\"mTabstripClosebutton\\\">\\n+        document.getAnonymousElementByAttribute(this, \\\"anonid\\\", \\\"tabstrip-closebutton\\\");\\n+      </field>\\n+\\n       <method name=\\\"_updateDisableBackgroundClose\\\">\\n         <body><![CDATA[\\n           var prefs =\\n@@ -2306,13 +2440,26 @@\\n           }\\n         ]]></body>\\n       </method>\\n+\\n       <field name=\\\"_prefObserver\\\">({\\n         tabbox: this,\\n   \\n         observe: function(subject, topic, data)\\n         {\\n-          if (topic == \\\"nsPref:changed\\\")\\n-            this.tabbox._updateDisableBackgroundClose();\\n+          if (topic == \\\"nsPref:changed\\\") {\\n+            switch (data) {\\n+            case \\\"browser.tabs.disableBackgroundClose\\\":\\n+              this._updateDisableBackgroundClose();\\n+              break;\\n+            case \\\"browser.tabs.closeButtons\\\":\\n+              var pb2 =\\n+                  Components.classes['@mozilla.org/preferences-service;1'].\\n+                  getService(Components.interfaces.nsIPrefBranch2);\\n+              this.mCloseButtons = pb2.getIntPref(\\\"browser.tabs.closeButtons\\\");\\n+              this.adjustTabstrip(false);\\n+              break;\\n+            }\\n+          }\\n         },\\n   \\n         QueryInterface : function(aIID)\\n@@ -2325,44 +2472,97 @@\\n         }\\n         });\\n       </field>\\n-      <field name=\\\"mTabClipWidth\\\">140</field>\\n-      <method name=\\\"adjustCloseButtons\\\">\\n-        <parameter name=\\\"aNumTabs\\\"/>\\n+      <field name=\\\"mTabClipWidth\\\">130</field>\\n+      <field name=\\\"mCloseButtons\\\">1</field>\\n+\\n+      <method name=\\\"adjustTabstrip\\\">\\n+        <parameter name=\\\"aRemovingTab\\\"/>\\n         <body><![CDATA[\\n-          // aNumTabs is the number of tabs that need to be present to cause\\n-          // the close button on the last visible tab to disappear when the\\n-          // pref for \\\"always show the tab bar, even when only one tab is open\\\"\\n-          // is set.\\n-          // When tabs are being removed from the tab strip, and the number of\\n-          // open tabs approaches 1 (i.e. when the number of open tabs is 2\\n-          // and one is removed), we need to set an attribute on the tabstrip\\n-          // that will cause the close button on the last item to be hidden.\\n-          // When tabs are being added to the tab strip - the number of open\\n-          // tabs is increasing (i.e. the number of open tabs is 1 and one is\\n-          // added) then we need to remove the attribute on the tab strip which\\n-          // will cause the close button to be shown on all tabs.\\n-          try {\\n-            if (this.childNodes.length == aNumTabs)\\n-              this.setAttribute(\\\"singlechild\\\", \\\"true\\\");\\n+          // modes for tabstrip\\n+          // 0 - activetab  = close button on active tab only\\n+          // 1 - alltabs    = close buttons on all tabs\\n+          // 2 - noclose    = no close buttons at all\\n+          // 3 - closeatend = close button at the end of the tabstrip\\n+          switch (this.mCloseButtons) {\\n+          case 0:\\n+            // TabClose fires before the tab closes, so if we have two tabs\\n+            // and we're removing the tab we should go to no closebutton\\n+            if ((aRemovingTab && this.childNodes.length == 2) ||\\n+                this.childNodes.length == 1)\\n+              this.setAttribute(\\\"closebuttons\\\", \\\"noclose\\\");\\n             else\\n-              this.removeAttribute(\\\"singlechild\\\");\\n-\\n+              this.setAttribute(\\\"closebuttons\\\", \\\"activetab\\\");\\n+            break;\\n+          case 1:\\n+            try {\\n+              // if we have only one tab, hide the closebutton\\n+              if ((aRemovingTab && this.childNodes.length == 2) ||\\n+                  this.childNodes.length == 1)\\n+                this.setAttribute(\\\"closebuttons\\\", \\\"noclose\\\");\\n+              else {\\n             var width = this.firstChild.boxObject.width;\\n             // 0 width is an invalid value and indicates an item without display,\\n             // so ignore.\\n             if (width > this.mTabClipWidth || width == 0)\\n-              this.removeAttribute(\\\"tiny\\\");\\n+                  this.setAttribute(\\\"closebuttons\\\", \\\"alltabs\\\");\\n             else\\n-              this.setAttribute(\\\"tiny\\\", \\\"true\\\");\\n+                  this.setAttribute(\\\"closebuttons\\\", \\\"activetab\\\");\\n+              }\\n           }\\n           catch (e) {\\n           }\\n+            break;\\n+          case 2:\\n+          case 3:\\n+            this.setAttribute(\\\"closebuttons\\\", \\\"noclose\\\");\\n+            break;\\n+          }\\n+          this.mTabstripClosebutton.collapsed = this.mCloseButtons != 3;\\n+          if (aRemovingTab) {\\n+            // if we're at the end of the tabstrip, we need to ensure \\n+            // that we stay completely scrolled to the end\\n+            // this is a hack to determine if that's where we are already\\n+            var tabWidth = this.firstChild.boxObject.width;\\n+            var scrollPos = {};\\n+            this.mTabstrip.scrollBoxObject.getPosition(scrollPos, {});\\n+            if (scrollPos.value + this.mTabstrip.boxObject.width > tabWidth * (this.childNodes.length - 1))\\n+              this.mTabstrip.scrollByPixels(-1 * this.firstChild.boxObject.width);\\n+          }\\n+        ]]></body>\\n+      </method>\\n+        \\n+      <field name=\\\"_mPrefs\\\">null</field>\\n+      <property name=\\\"mPrefs\\\" readonly=\\\"true\\\">\\n+        <getter>\\n+        <![CDATA[\\n+          if (!this._mPrefs) {\\n+            this._mPrefs =\\n+              Components.classes['@mozilla.org/preferences-service;1'].\\n+              getService(Components.interfaces.nsIPrefBranch2);\\n+          }\\n+          return this._mPrefs;\\n+        ]]>\\n+        </getter>\\n+      </property>\\n+        \\n+      <method name=\\\"_handleTabSelect\\\">\\n+        <body><![CDATA[\\n+          this.mTabstrip.scrollBoxObject.ensureElementIsVisible(this.selectedItem);\\n+        ]]></body>\\n+      </method>\\n+        \\n+      <method name=\\\"_handleUnderflow\\\">\\n+        <body><![CDATA[\\n+          this.mTabstrip.scrollBoxObject.scrollBy(-2400, 0);\\n         ]]></body>\\n       </method>\\n     </implementation>\\n+\\n     <handlers>\\n-      <handler event=\\\"DOMNodeInserted\\\" action=\\\"this.adjustCloseButtons(1);\\\"/>\\n-      <handler event=\\\"DOMNodeRemoved\\\" action=\\\"this.adjustCloseButtons(2);\\\"/>\\n+      <handler event=\\\"TabOpen\\\"   action=\\\"this.adjustTabstrip(false);\\\"/>\\n+      <handler event=\\\"TabClose\\\"  action=\\\"this.adjustTabstrip(true);\\\"/>\\n+      <handler event=\\\"TabSelect\\\" action=\\\"this._handleTabSelect()\\\"/>\\n+      <handler event=\\\"underflow\\\" action=\\\"this._handleUnderflow()\\\"/>\\n     </handlers>\\n   </binding>\\n \\ndiff --git a/browser/themes/pinstripe/browser/tabbrowser/tabbrowserBindings.xml b/browser/themes/pinstripe/browser/tabbrowser/tabbrowserBindings.xml\\nindex 5cfd17a..301ae86 100644\\n--- a/browser/themes/pinstripe/browser/tabbrowser/tabbrowserBindings.xml\\n+++ b/browser/themes/pinstripe/browser/tabbrowser/tabbrowserBindings.xml\\n@@ -59,9 +59,13 @@\\n             <xul:stack>\\n               <xul:spacer class=\\\"tabs-left\\\"/>\\n             </xul:stack>\\n-            <xul:hbox flex=\\\"1\\\" style=\\\"min-width: 1px;\\\">\\n+            <xul:arrowscrollbox anonid=\\\"arrowscrollbox\\\" orient=\\\"horizontal\\\" flex=\\\"1\\\" style=\\\"min-width: 1px;\\\">\\n               <children/>\\n-              <xul:spacer class=\\\"tabs-right\\\" flex=\\\"1\\\"/>\\n+            </xul:arrowscrollbox>\\n+            <xul:hbox class=\\\"tabs-closebutton-box\\\" align=\\\"center\\\" pack=\\\"end\\\" anonid=\\\"tabstrip-closebutton\\\">\\n+              <xul:toolbarbutton ondblclick=\\\"event.stopPropagation();\\\"\\n+                           class=\\\"close-button tabs-closebutton\\\"\\n+                           oncommand=\\\"this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.removeCurrentTab()\\\"/>\\n             </xul:hbox>\\n           </xul:hbox>\\n           <xul:spacer class=\\\"tabs-bottom-spacer\\\"/>\\n\""}