{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas8b88b41\""},"diff":"\"8b88b41 Bug 393970 - \\\"Grid columns don't line up if one <rows> block is scrollable\\\" (patch #3) [p=trev.moz@adblockplus.org (Wladimir Palant) r+sr+a1.9=roc]\\ndiff --git a/layout/xul/base/Makefile.in b/layout/xul/base/Makefile.in\\nindex 5494a87..99d2ec7 100644\\n--- a/layout/xul/base/Makefile.in\\n+++ b/layout/xul/base/Makefile.in\\n@@ -44,5 +44,9 @@ include $(DEPTH)/config/autoconf.mk\\n \\n DIRS\\t\\t= public src\\n \\n+ifdef MOZ_MOCHITEST\\n+DIRS\\t\\t+= test\\n+endif\\n+\\n include $(topsrcdir)/config/rules.mk\\n \\ndiff --git a/layout/xul/base/src/grid/nsGridRowLeafLayout.cpp b/layout/xul/base/src/grid/nsGridRowLeafLayout.cpp\\nindex d4b54ba..a3a5cbb 100644\\n--- a/layout/xul/base/src/grid/nsGridRowLeafLayout.cpp\\n+++ b/layout/xul/base/src/grid/nsGridRowLeafLayout.cpp\\n@@ -143,46 +143,46 @@ nsGridRowLeafLayout::PopulateBoxSizes(nsIBox* aBox, nsBoxLayoutState& aState, ns\\n   // If we are a row lets change the sizes to match our columns. If we are a column then do the opposite\\n   // and make them match or rows.\\n   if (grid) {\\n-   nsGridRow* column;\\n-   PRInt32 count = grid->GetColumnCount(isHorizontal); \\n-   nsBoxSize* start = nsnull;\\n-   nsBoxSize* last = nsnull;\\n-   nsBoxSize* current = nsnull;\\n-   nsIBox* child = aBox->GetChildBox();\\n-   for (int i=0; i < count; i++)\\n-   {\\n-     column = grid->GetColumnAt(i,isHorizontal); \\n-\\n-     // make sure the value was computed before we use it.\\n-     // !isHorizontal is passed in to invert the behavior of these methods.\\n-     nscoord pref =\\n-       grid->GetPrefRowHeight(aState, i, !isHorizontal); // GetPrefColumnWidth\\n-     nscoord min = \\n-       grid->GetMinRowHeight(aState, i, !isHorizontal);  // GetMinColumnWidth\\n-     nscoord max = \\n-       grid->GetMaxRowHeight(aState, i, !isHorizontal);  // GetMaxColumnWidth\\n-     nscoord flex =\\n-       grid->GetRowFlex(aState, i, !isHorizontal);       // GetColumnFlex\\n-     nscoord left  = 0;\\n-     nscoord right  = 0;\\n-     grid->GetRowOffsets(aState, i, left, right, !isHorizontal); // GetColumnOffsets\\n-     nsIBox* box = column->GetBox();\\n-     PRBool collapsed = PR_FALSE;\\n-     nscoord topMargin = column->mTopMargin;\\n-     nscoord bottomMargin = column->mBottomMargin;\\n-\\n-     if (box) \\n-       collapsed = box->IsCollapsed(aState);\\n-\\n-     pref = pref - (left + right);\\n-     if (pref < 0)\\n-       pref = 0;\\n-\\n-     // if this is the first or last column. Take into account that\\n-     // our row could have a border that could affect our left or right\\n-     // padding from our columns. If the row has padding subtract it.\\n-     // would should always be able to garentee that our margin is smaller\\n-     // or equal to our left or right\\n+    nsGridRow* column;\\n+    PRInt32 count = grid->GetColumnCount(isHorizontal); \\n+    nsBoxSize* start = nsnull;\\n+    nsBoxSize* last = nsnull;\\n+    nsBoxSize* current = nsnull;\\n+    nsIBox* child = aBox->GetChildBox();\\n+    for (int i=0; i < count; i++)\\n+    {\\n+      column = grid->GetColumnAt(i,isHorizontal); \\n+\\n+      // make sure the value was computed before we use it.\\n+      // !isHorizontal is passed in to invert the behavior of these methods.\\n+      nscoord pref =\\n+        grid->GetPrefRowHeight(aState, i, !isHorizontal); // GetPrefColumnWidth\\n+      nscoord min = \\n+        grid->GetMinRowHeight(aState, i, !isHorizontal);  // GetMinColumnWidth\\n+      nscoord max = \\n+        grid->GetMaxRowHeight(aState, i, !isHorizontal);  // GetMaxColumnWidth\\n+      nscoord flex =\\n+        grid->GetRowFlex(aState, i, !isHorizontal);       // GetColumnFlex\\n+      nscoord left  = 0;\\n+      nscoord right  = 0;\\n+      grid->GetRowOffsets(aState, i, left, right, !isHorizontal); // GetColumnOffsets\\n+      nsIBox* box = column->GetBox();\\n+      PRBool collapsed = PR_FALSE;\\n+      nscoord topMargin = column->mTopMargin;\\n+      nscoord bottomMargin = column->mBottomMargin;\\n+\\n+      if (box) \\n+        collapsed = box->IsCollapsed(aState);\\n+\\n+      pref = pref - (left + right);\\n+      if (pref < 0)\\n+        pref = 0;\\n+\\n+      // if this is the first or last column. Take into account that\\n+      // our row could have a border that could affect our left or right\\n+      // padding from our columns. If the row has padding subtract it.\\n+      // would should always be able to garentee that our margin is smaller\\n+      // or equal to our left or right\\n       PRInt32 firstIndex = 0;\\n       PRInt32 lastIndex = 0;\\n       nsGridRow* firstRow = nsnull;\\n@@ -216,33 +216,33 @@ nsGridRowLeafLayout::PopulateBoxSizes(nsIBox* aBox, nsBoxLayoutState& aState, ns\\n            right -= offset.bottom;\\n         }\\n       }\\n-    \\n-     // initialize the box size here \\n-     nsBox::BoundsCheck(min, pref, max);\\n-   \\n-     current = new (aState) nsBoxSize();\\n-     current->pref = pref;\\n-     current->min = min;\\n-     current->max = max;\\n-     current->flex = flex;\\n-     current->bogus = column->mIsBogus;\\n-     current->left = left + topMargin;\\n-     current->right = right + bottomMargin;\\n-     current->collapsed = collapsed;\\n-\\n-     if (!start) {\\n+\\n+      // initialize the box size here \\n+      nsBox::BoundsCheck(min, pref, max);\\n+\\n+      current = new (aState) nsBoxSize();\\n+      current->pref = pref;\\n+      current->min = min;\\n+      current->max = max;\\n+      current->flex = flex;\\n+      current->bogus = column->mIsBogus;\\n+      current->left = left + topMargin;\\n+      current->right = right + bottomMargin;\\n+      current->collapsed = collapsed;\\n+\\n+      if (!start) {\\n         start = current;\\n         last = start;\\n-     } else {\\n+      } else {\\n         last->next = current;\\n         last = current;\\n-     }\\n+      }\\n \\n-     if (child && !column->mIsBogus)\\n-       child = child->GetNextBox();\\n+      if (child && !column->mIsBogus)\\n+        child = child->GetNextBox();\\n \\n-   }\\n-   aBoxSizes = start;\\n+    }\\n+    aBoxSizes = start;\\n   }\\n \\n   nsSprocketLayout::PopulateBoxSizes(aBox, aState, aBoxSizes, aComputedBoxSizes, aMinSize, aMaxSize, aFlexes);\\n@@ -258,49 +258,51 @@ nsGridRowLeafLayout::ComputeChildSizes(nsIBox* aBox,\\n   // see if we are in a scrollable frame. If we are then there could be scrollbars present\\n   // if so we need to subtract them out to make sure our columns line up.\\n   if (aBox) {\\n-     PRBool isHorizontal = aBox->IsHorizontal();\\n-\\n-     // go up the parent chain looking for scrollframes\\n-     aBox = aBox->GetParentBox();\\n-     nsIBox* scrollbox = nsGrid::GetScrollBox(aBox);\\n-       \\n-       nsCOMPtr<nsIScrollableFrame> scrollable = do_QueryInterface(scrollbox);\\n-       if (scrollable) {\\n-          nsMargin scrollbarSizes = scrollable->GetActualScrollbarSizes();\\n-\\n-          nsRect ourRect(scrollbox->GetRect());\\n-          nsMargin padding(0,0,0,0);\\n-          scrollbox->GetBorderAndPadding(padding);\\n-          ourRect.Deflate(padding);\\n-\\n-          nscoord diff;\\n-          if (isHorizontal) {\\n-            diff = scrollbarSizes.left + scrollbarSizes.right;\\n-          } else {\\n-            diff = scrollbarSizes.top + scrollbarSizes.bottom;\\n-          }\\n-\\n-          if (diff > 0) {\\n-            aGivenSize += diff;\\n-\\n-            nsSprocketLayout::ComputeChildSizes(aBox, aState, aGivenSize, aBoxSizes, aComputedBoxSizes);\\n-\\n-            aGivenSize -= diff;\\n-\\n-            nsComputedBoxSize* s    = aComputedBoxSizes;\\n-            nsComputedBoxSize* last = aComputedBoxSizes;\\n-            while(s)\\n-            {\\n-              last = s;\\n-              s = s->next;\\n-            }\\n-  \\n-            if (last) \\n-                last->size -= diff;                         \\n-          }\\n-       }\\n+    PRBool isHorizontal = aBox->IsHorizontal();\\n+\\n+    // go up the parent chain looking for scrollframes\\n+    nscoord diff = 0;\\n+    nsCOMPtr<nsIGridPart> parent;\\n+    nsIBox* parentBox;\\n+    GetParentGridPart(aBox, &parentBox, getter_AddRefs(parent));\\n+    while (parentBox) {\\n+      nsIBox* scrollbox = nsGrid::GetScrollBox(parentBox);\\n+      nsCOMPtr<nsIScrollableFrame> scrollable = do_QueryInterface(scrollbox);\\n+      if (scrollable) {\\n+        nsMargin scrollbarSizes = scrollable->GetActualScrollbarSizes();\\n+\\n+        if (isHorizontal) {\\n+          diff += scrollbarSizes.left + scrollbarSizes.right;\\n+        } else {\\n+          diff += scrollbarSizes.top + scrollbarSizes.bottom;\\n+        }\\n+      }\\n+\\n+      GetParentGridPart(parentBox, &parentBox, getter_AddRefs(parent));\\n+    }\\n+\\n+    if (diff > 0) {\\n+      aGivenSize += diff;\\n+\\n+      nsSprocketLayout::ComputeChildSizes(aBox, aState, aGivenSize, aBoxSizes, aComputedBoxSizes);\\n+\\n+      aGivenSize -= diff;\\n+\\n+      nsComputedBoxSize* s    = aComputedBoxSizes;\\n+      nsComputedBoxSize* last = aComputedBoxSizes;\\n+      while(s)\\n+      {\\n+        last = s;\\n+        s = s->next;\\n+      }\\n+\\n+      if (last) \\n+        last->size -= diff;                         \\n+\\n+      return;\\n+    }\\n   }\\n-      \\n+\\n   nsSprocketLayout::ComputeChildSizes(aBox, aState, aGivenSize, aBoxSizes, aComputedBoxSizes);\\n \\n }\\ndiff --git a/layout/xul/base/test/Makefile.in b/layout/xul/base/test/Makefile.in\\nnew file mode 100644\\nindex 0000000..677cbe8\\n--- /dev/null\\n+++ b/layout/xul/base/test/Makefile.in\\n@@ -0,0 +1,51 @@\\n+#\\n+# ***** BEGIN LICENSE BLOCK *****\\n+# Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+#\\n+# The contents of this file are subject to the Mozilla Public License Version\\n+# 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+# the License. You may obtain a copy of the License at\\n+# http://www.mozilla.org/MPL/\\n+#\\n+# Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+# for the specific language governing rights and limitations under the\\n+# License.\\n+#\\n+# The Original Code is mozilla.org code.\\n+#\\n+# The Initial Developer of the Original Code is\\n+# Wladimir Palant.\\n+# Portions created by the Initial Developer are Copyright (C) 2007\\n+# the Initial Developer. All Rights Reserved.\\n+#\\n+# Contributor(s):\\n+#\\n+# Alternatively, the contents of this file may be used under the terms of\\n+# either of the GNU General Public License Version 2 or later (the \\\"GPL\\\"),\\n+# or the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+# in which case the provisions of the GPL or the LGPL are applicable instead\\n+# of those above. If you wish to allow use of your version of this file only\\n+# under the terms of either the GPL or the LGPL, and not to allow others to\\n+# use your version of this file under the terms of the MPL, indicate your\\n+# decision by deleting the provisions above and replace them with the notice\\n+# and other provisions required by the GPL or the LGPL. If you do not delete\\n+# the provisions above, a recipient may use your version of this file under\\n+# the terms of any one of the MPL, the GPL or the LGPL.\\n+#\\n+# ***** END LICENSE BLOCK *****\\n+\\n+DEPTH\\t\\t= ../../../..\\n+topsrcdir\\t= @top_srcdir@\\n+srcdir\\t\\t= @srcdir@\\n+VPATH\\t\\t= @srcdir@\\n+relativesrcdir  = layout/xul/base/test\\n+\\n+include $(DEPTH)/config/autoconf.mk\\n+include $(topsrcdir)/config/rules.mk\\n+\\n+_TEST_FILES = \\ttest_bug393970.xul \\\\\\n+\\t\\t$(NULL)\\n+\\n+libs:: $(_TEST_FILES)\\n+\\t$(INSTALL) $^ $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)\\ndiff --git a/layout/xul/base/test/test_bug393970.xul b/layout/xul/base/test/test_bug393970.xul\\nnew file mode 100644\\nindex 0000000..ba6d5f1\\n--- /dev/null\\n+++ b/layout/xul/base/test/test_bug393970.xul\\n@@ -0,0 +1,86 @@\\n+<?xml version=\\\"1.0\\\"?>\\n+<?xml-stylesheet href=\\\"chrome://global/skin\\\" type=\\\"text/css\\\"?>\\n+<?xml-stylesheet href=\\\"/tests/SimpleTest/test.css\\\" type=\\\"text/css\\\"?>\\n+<?xml-stylesheet href=\\\"data:text/css,description {border: 1px solid black; padding: 2px;}\\\" type=\\\"text/css\\\"?>\\n+<!--\\n+https://bugzilla.mozilla.org/show_bug.cgi?id=393970\\n+-->\\n+<window title=\\\"Mozilla Bug 393970\\\"\\n+  xmlns=\\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\">\\n+  <script type=\\\"application/javascript\\\" src=\\\"/MochiKit/packed.js\\\" />\\n+  <script type=\\\"application/javascript\\\" src=\\\"/tests/SimpleTest/SimpleTest.js\\\"/>\\n+\\n+  <!-- test resuls are displayed in the html:body -->\\n+  <body xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\\n+  <a href=\\\"https://bugzilla.mozilla.org/show_bug.cgi?id=393970\\\"\\n+     target=\\\"_blank\\\">Mozilla Bug 393970</a>\\n+  </body>\\n+\\n+  <grid flex=\\\"1\\\" style=\\\"visibility: hidden;\\\">\\n+    <columns>\\n+      <column flex=\\\"1\\\"/>\\n+      <column flex=\\\"2\\\"/>\\n+      <column flex=\\\"3\\\"/>\\n+    </columns>\\n+    <rows id=\\\"rows1\\\">\\n+      <row>\\n+        <description id=\\\"cell11\\\">test1</description>\\n+        <description id=\\\"cell12\\\">test2</description>\\n+        <description id=\\\"cell13\\\">test3</description>\\n+      </row>\\n+      <rows id=\\\"rows2\\\" flex=\\\"1\\\">\\n+        <row>\\n+          <description id=\\\"cell21\\\">test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1</description>\\n+          <description id=\\\"cell22\\\">test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2</description>\\n+          <description id=\\\"cell23\\\">test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3</description>\\n+        </row>\\n+        <rows id=\\\"rows3\\\">\\n+          <row>\\n+            <description id=\\\"cell31\\\">test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1 test1</description>\\n+            <description id=\\\"cell32\\\">test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2 test2</description>\\n+            <description id=\\\"cell33\\\">test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3 test3</description>\\n+          </row>\\n+        </rows>\\n+      </rows>\\n+    </rows>\\n+  </grid>\\n+\\n+  <!-- test code goes here -->\\n+  <script type=\\\"application/javascript\\\"><![CDATA[\\n+    /** Test for Bug 393970 **/\\n+\\n+    var tests = [\\n+      'overflow-x: hidden; overflow-y: hidden;',\\n+      'overflow-x: scroll; overflow-y: hidden;',\\n+      'overflow-x: hidden; overflow-y: scroll;',\\n+      'overflow-x: scroll; overflow-y: scroll;',\\n+    ];\\n+    var currentTest = -1;\\n+\\n+    function runNextTest() {\\n+      currentTest++;\\n+      if (currentTest >= tests.length) {\\n+        SimpleTest.finish();\\n+        return;\\n+      }\\n+\\n+      $(\\\"rows2\\\").setAttribute(\\\"style\\\", tests[currentTest]);\\n+      setTimeout(checkPositions, 0, tests[currentTest]);\\n+    }\\n+\\n+    function checkPositions(variant) {\\n+      for (var col = 1; col <= 3; col++) {\\n+        is($('cell1' + col).boxObject.x, $('cell2' + col).boxObject.x, \\\"Cells (1,\\\" + col + \\\") and (2,\\\" + col + \\\") line up horizontally (with \\\" + variant + \\\")\\\");\\n+        is($('cell2' + col).boxObject.x, $('cell3' + col).boxObject.x, \\\"Cells (2,\\\" + col + \\\") and (3,\\\" + col + \\\") line up horizontally (with \\\" + variant + \\\")\\\");\\n+      }\\n+      for (var row = 1; row <= 3; row++) {\\n+        is($('cell' + row + '1').boxObject.y, $('cell' + row + '2').boxObject.y, \\\"Cells (\\\" + row + \\\",1) and (\\\" + row + \\\",2) line up vertically (with \\\" + variant + \\\")\\\");\\n+        is($('cell' + row + '2').boxObject.y, $('cell' + row + '3').boxObject.y, \\\"Cells (\\\" + row + \\\",2) and (\\\" + row + \\\",3) line up vertically (with \\\" + variant + \\\")\\\");\\n+      }\\n+      runNextTest();\\n+    }\\n+ \\n+    addLoadEvent(runNextTest);\\n+    SimpleTest.waitForExplicitFinish()\\n+   ]]></script>\\n+</window>\\n\""}