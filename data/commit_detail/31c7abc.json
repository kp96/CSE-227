{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas31c7abc\""},"diff":"\"31c7abc 393624 check for unexpected status codes when resuming downloads r+sr+a=bz\\ndiff --git a/netwerk/protocol/http/src/nsHttpChannel.cpp b/netwerk/protocol/http/src/nsHttpChannel.cpp\\nindex 8648891..c0c6904 100644\\n--- a/netwerk/protocol/http/src/nsHttpChannel.cpp\\n+++ b/netwerk/protocol/http/src/nsHttpChannel.cpp\\n@@ -856,16 +856,6 @@ nsHttpChannel::ProcessResponse()\\n             rv = ProcessNormal();\\n         }\\n         break;\\n-    case 412: // Precondition failed\\n-    case 416: // Invalid range\\n-        if (mResuming) {\\n-            LOG((\\\"Resuming and got %i status, aborting [this=%p]\\\\n\\\",\\n-                 httpStatus, this));\\n-            Cancel(NS_ERROR_ENTITY_CHANGED);\\n-            rv = CallOnStartRequest();\\n-            break;\\n-        }\\n-        // fall through\\n     default:\\n         rv = ProcessNormal();\\n         break;\\n@@ -924,6 +914,13 @@ nsHttpChannel::ProcessNormal()\\n             // If creating an entity id is not possible -> error\\n             Cancel(NS_ERROR_NOT_RESUMABLE);\\n         }\\n+        else if (mResponseHead->Status() != 206) {\\n+            // Probably 404 Not Found, 412 Precondition Failed or\\n+            // 416 Invalid Range -> error\\n+            LOG((\\\"Unexpected response status while resuming, aborting [this=%p]\\\\n\\\",\\n+                 this));\\n+            Cancel(NS_ERROR_ENTITY_CHANGED);\\n+        }\\n         // If we were passed an entity id, verify it's equal to the server's\\n         else if (!mEntityID.IsEmpty()) {\\n             if (!mEntityID.Equals(id)) {\\ndiff --git a/netwerk/test/unit/head_channels.js b/netwerk/test/unit/head_channels.js\\nindex b78fba0..bff60a6 100644\\n--- a/netwerk/test/unit/head_channels.js\\n+++ b/netwerk/test/unit/head_channels.js\\n@@ -21,6 +21,8 @@ function read_stream(stream, count) {\\n   return data.join('');\\n }\\n \\n+const CL_EXPECT_FAILURE = 0x1;\\n+\\n /**\\n  * A stream listener that calls a callback function with a specified\\n  * context and the received data when the channel is loaded.\\n@@ -29,14 +31,16 @@ function read_stream(stream, count) {\\n  *   void closure(in nsIRequest request, in ACString data, in JSObject context);\\n  *\\n  * This listener makes sure that various parts of the channel API are\\n- * implemented correctly and that the channel's status is a success code.\\n+ * implemented correctly and that the channel's status is a success code\\n+ * (you can pass CL_EXPECT_FAILURE as flags to allow a failure code)\\n  *\\n  * Note that it also requires a valid content length on the channel and\\n  * is thus not fully generic.\\n  */\\n-function ChannelListener(closure, ctx) {\\n+function ChannelListener(closure, ctx, flags) {\\n   this._closure = closure;\\n   this._closurectx = ctx;\\n+  this._flags = flags;\\n }\\n ChannelListener.prototype = {\\n   _closure: null,\\n@@ -72,6 +76,8 @@ ChannelListener.prototype = {\\n       do_throw(\\\"onDataAvailable after onStopRequest event!\\\");\\n     if (!request.isPending())\\n       do_throw(\\\"request reports itself as not pending from onStartRequest!\\\");\\n+    if (this._flags & CL_EXPECT_FAILURE)\\n+      do_throw(\\\"Got data despite expecting a failure\\\");\\n \\n     this._buffer = this._buffer.concat(read_stream(stream, count));\\n   },\\n@@ -82,13 +88,17 @@ ChannelListener.prototype = {\\n     if (this._got_onstoprequest)\\n       do_throw(\\\"Got second onStopRequest event!\\\");\\n     this._got_onstoprequest = true;\\n-    if (!Components.isSuccessCode(status))\\n+    var success = Components.isSuccessCode(status);\\n+    if ((this._flags & CL_EXPECT_FAILURE) && success)\\n+      do_throw(\\\"Should have failed to load URL (status is \\\" + status.toString(16) + \\\")\\\");\\n+    else if (!(this._flags & CL_EXPECT_FAILURE) && !success)\\n       do_throw(\\\"Failed to load URL: \\\" + status.toString(16));\\n     if (status != request.status)\\n       do_throw(\\\"request.status does not match status arg to onStopRequest!\\\");\\n     if (request.isPending())\\n       do_throw(\\\"request reports itself as pending from onStopRequest!\\\");\\n-    if (this._contentLen != -1 && this._buffer.length != this._contentLen)\\n+    if (!(this._flags & CL_EXPECT_FAILURE) &&\\n+        this._contentLen != -1 && this._buffer.length != this._contentLen)\\n       do_throw(\\\"did not read nsIChannel.contentLength number of bytes!\\\");\\n \\n     this._closure(request, this._buffer, this._closurectx);\\ndiff --git a/netwerk/test/unit/test_resumable_channel.js b/netwerk/test/unit/test_resumable_channel.js\\nnew file mode 100644\\nindex 0000000..d33e413\\n--- /dev/null\\n+++ b/netwerk/test/unit/test_resumable_channel.js\\n@@ -0,0 +1,230 @@\\n+/* Tests various aspects of nsIResumableChannel in combination with HTTP */\\n+\\n+do_import_script(\\\"netwerk/test/httpserver/httpd.js\\\");\\n+\\n+var httpserver = null;\\n+\\n+const NS_ERROR_ENTITY_CHANGED = 0x804b0020;\\n+const NS_ERROR_NOT_RESUMABLE = 0x804b0019;\\n+\\n+const rangeBody = \\\"Body of the range request handler.\\\\r\\\\n\\\";\\n+\\n+function make_channel(url, callback, ctx) {\\n+  var ios = Cc[\\\"@mozilla.org/network/io-service;1\\\"].\\n+            getService(Ci.nsIIOService);\\n+  return ios.newChannel(url, \\\"\\\", null);\\n+}\\n+\\n+function AuthPrompt2() {\\n+}\\n+\\n+AuthPrompt2.prototype = {\\n+  user: \\\"guest\\\",\\n+  pass: \\\"guest\\\",\\n+\\n+  QueryInterface: function authprompt2_qi(iid) {\\n+    if (iid.equals(Components.interfaces.nsISupports) ||\\n+        iid.equals(Components.interfaces.nsIAuthPrompt2))\\n+      return this;\\n+    throw Components.results.NS_ERROR_NO_INTERFACE;\\n+  },\\n+\\n+  promptAuth:\\n+    function ap2_promptAuth(channel, level, authInfo)\\n+  {\\n+    authInfo.username = this.user;\\n+    authInfo.password = this.pass;\\n+    return true;\\n+  },\\n+\\n+  asyncPromptAuth: function ap2_async(chan, cb, ctx, lvl, info) {\\n+    do_throw(\\\"not implemented yet\\\")\\n+  }\\n+};\\n+\\n+function Requestor() {\\n+}\\n+\\n+Requestor.prototype = {\\n+  QueryInterface: function requestor_qi(iid) {\\n+    if (iid.equals(Components.interfaces.nsISupports) ||\\n+        iid.equals(Components.interfaces.nsIInterfaceRequestor))\\n+      return this;\\n+    throw Components.results.NS_ERROR_NO_INTERFACE;\\n+  },\\n+\\n+  getInterface: function requestor_gi(iid) {\\n+    if (iid.equals(Components.interfaces.nsIAuthPrompt2)) {\\n+      // Allow the prompt to store state by caching it here\\n+      if (!this.prompt2)\\n+        this.prompt2 = new AuthPrompt2();\\n+      return this.prompt2;\\n+    }\\n+\\n+    throw Components.results.NS_ERROR_NO_INTERFACE;\\n+  },\\n+\\n+  prompt2: null\\n+};\\n+\\n+function run_test() {\\n+  dump(\\\"*** run_test\\\\n\\\");\\n+  httpserver = new nsHttpServer();\\n+  httpserver.registerPathHandler(\\\"/auth\\\", authHandler);\\n+  httpserver.registerPathHandler(\\\"/range\\\", rangeHandler);\\n+\\n+  var entityID;\\n+\\n+  function get_entity_id(request, data, ctx) {\\n+    do_check_true(request instanceof Ci.nsIResumableChannel,\\n+                  \\\"must be a resumable channel\\\");\\n+    entityID = request.entityID;\\n+    dump(\\\"*** entity id = \\\" + entityID + \\\"\\\\n\\\");\\n+\\n+    // Try a non-resumable URL (responds with 200)\\n+    var chan = make_channel(\\\"http://localhost:4444/\\\");\\n+    chan.nsIResumableChannel.resumeAt(1, entityID);\\n+    chan.asyncOpen(new ChannelListener(try_resume, null, CL_EXPECT_FAILURE), null);\\n+  }\\n+  function try_resume(request, data, ctx) {\\n+    do_check_eq(request.status, NS_ERROR_NOT_RESUMABLE);\\n+\\n+    // Try a successful resume\\n+    var chan = make_channel(\\\"http://localhost:4444/range\\\");\\n+    chan.nsIResumableChannel.resumeAt(1, entityID);\\n+    chan.asyncOpen(new ChannelListener(success, null), null);\\n+  }\\n+\\n+  function success(request, data, ctx) {\\n+    do_check_true(request.nsIHttpChannel.requestSucceeded);\\n+    do_check_eq(data, rangeBody.substring(1));\\n+\\n+    // Authentication (no password; working resume)\\n+    // (should not give us any data)\\n+    var chan = make_channel(\\\"http://localhost:4444/range\\\");\\n+    chan.nsIResumableChannel.resumeAt(1, entityID);\\n+    chan.nsIHttpChannel.setRequestHeader(\\\"X-Need-Auth\\\", \\\"true\\\", false);\\n+    chan.asyncOpen(new ChannelListener(test_auth_nopw, null, CL_EXPECT_FAILURE), null);\\n+  }\\n+\\n+  function test_auth_nopw(request, data, ctx) {\\n+    do_check_false(request.nsIHttpChannel.requestSucceeded);\\n+    do_check_eq(request.status, NS_ERROR_ENTITY_CHANGED);\\n+\\n+    // Authentication + not working resume\\n+    var chan = make_channel(\\\"http://localhost:4444/auth\\\");\\n+    chan.nsIResumableChannel.resumeAt(1, entityID);\\n+    chan.notificationCallbacks = new Requestor();\\n+    chan.asyncOpen(new ChannelListener(test_auth, null, CL_EXPECT_FAILURE), null);\\n+  }\\n+  function test_auth(request, data, ctx) {\\n+    do_check_eq(request.status, NS_ERROR_NOT_RESUMABLE);\\n+    do_check_true(request.nsIHttpChannel.responseStatus < 300);\\n+\\n+    // Authentication + working resume\\n+    var chan = make_channel(\\\"http://localhost:4444/range\\\");\\n+    chan.nsIResumableChannel.resumeAt(1, entityID);\\n+    chan.notificationCallbacks = new Requestor();\\n+    chan.nsIHttpChannel.setRequestHeader(\\\"X-Need-Auth\\\", \\\"true\\\", false);\\n+    chan.asyncOpen(new ChannelListener(test_auth_resume, null), null);\\n+  }\\n+\\n+  function test_auth_resume(request, data, ctx) {\\n+    do_check_eq(data, rangeBody.substring(1));\\n+    do_check_true(request.nsIHttpChannel.requestSucceeded);\\n+\\n+    // 404 page (same content length as real content)\\n+    var chan = make_channel(\\\"http://localhost:4444/range\\\");\\n+    chan.nsIResumableChannel.resumeAt(1, entityID);\\n+    chan.nsIHttpChannel.setRequestHeader(\\\"X-Want-404\\\", \\\"true\\\", false);\\n+    chan.asyncOpen(new ChannelListener(test_404, null, CL_EXPECT_FAILURE), null);\\n+  }\\n+\\n+  function test_404(request, data, ctx) {\\n+    do_check_eq(request.status, NS_ERROR_ENTITY_CHANGED);\\n+\\n+    httpserver.stop();\\n+    do_test_finished();\\n+  }\\n+\\n+  httpserver.start(4444);\\n+  var chan = make_channel(\\\"http://localhost:4444/range\\\");\\n+  chan.asyncOpen(new ChannelListener(get_entity_id, null), null);\\n+  do_test_pending();\\n+}\\n+\\n+// HANDLERS\\n+\\n+function handleAuth(metadata, response) {\\n+  // btoa(\\\"guest:guest\\\"), but that function is not available here\\n+  var expectedHeader = \\\"Basic Z3Vlc3Q6Z3Vlc3Q=\\\";\\n+\\n+  var body;\\n+  if (metadata.hasHeader(\\\"Authorization\\\") &&\\n+      metadata.getHeader(\\\"Authorization\\\") == expectedHeader)\\n+  {\\n+    response.setStatusLine(metadata.httpVersion, 200, \\\"OK, authorized\\\");\\n+    response.setHeader(\\\"WWW-Authenticate\\\", 'Basic realm=\\\"secret\\\"', false);\\n+\\n+    return true;\\n+  }\\n+  else\\n+  {\\n+    // didn't know guest:guest, failure\\n+    response.setStatusLine(metadata.httpVersion, 401, \\\"Unauthorized\\\");\\n+    response.setHeader(\\\"WWW-Authenticate\\\", 'Basic realm=\\\"secret\\\"', false);\\n+\\n+    return false;\\n+  }\\n+}\\n+\\n+// /auth\\n+function authHandler(metadata, response) {\\n+  response.setHeader(\\\"Content-Type\\\", \\\"text/html\\\", false);\\n+  body = handleAuth(metadata, response) ? \\\"success\\\" : \\\"failure\\\";\\n+  response.bodyOutputStream.write(body, body.length);\\n+}\\n+\\n+// /range\\n+function rangeHandler(metadata, response) {\\n+  response.setHeader(\\\"Content-Type\\\", \\\"text/html\\\", false);\\n+\\n+  if (metadata.hasHeader(\\\"X-Need-Auth\\\")) {\\n+    if (!handleAuth(metadata, response)) {\\n+      body = \\\"auth failed\\\";\\n+      response.bodyOutputStream.write(body, body.length);\\n+      return;\\n+    }\\n+  }\\n+\\n+  if (metadata.hasHeader(\\\"X-Want-404\\\")) {\\n+    response.setStatusLine(metadata.httpVersion, 404, \\\"Not Found\\\");\\n+    body = rangeBody;\\n+    response.bodyOutputStream.write(body, body.length);\\n+    return;\\n+  }\\n+\\n+  var body = rangeBody;\\n+\\n+  if (metadata.hasHeader(\\\"Range\\\")) {\\n+    // Syntax: bytes=[from]-[to] (we don't support multiple ranges)\\n+    var matches = metadata.getHeader(\\\"Range\\\").match(/^\\\\s*bytes=(\\\\d+)?-(\\\\d+)?\\\\s*$/);\\n+    var from = (matches[1] === undefined) ? 0 : matches[1];\\n+    var to = (matches[2] === undefined) ? rangeBody.length - 1 : matches[2];\\n+    if (from >= rangeBody.length) {\\n+      response.setStatusLine(metadata.httpVersion, 416, \\\"Start pos too high\\\");\\n+      response.setHeader(\\\"Content-Range\\\", \\\"*/\\\" + rangeBody.length);\\n+      return;\\n+    }\\n+    body = body.substring(from, to + 1);\\n+    if (body.length != rangeBody.length) {\\n+      response.setStatusLine(metadata.httpVersion, 206, \\\"Partial Content\\\");\\n+      response.setHeader(\\\"Content-Range\\\", from + \\\"-\\\" + to + \\\"/\\\" + rangeBody.length);\\n+    }\\n+  }\\n+\\n+  response.bodyOutputStream.write(body, body.length);\\n+}\\n+\\n+\\n+\\n\""}