{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basd304927\""},"diff":"\"d304927 Bug 394551: no JS frames for fast native calls. r=brendan\\ndiff --git a/js/src/jsapi.c b/js/src/jsapi.c\\nindex c3748b3..d046a48 100644\\n--- a/js/src/jsapi.c\\n+++ b/js/src/jsapi.c\\n@@ -4136,7 +4136,6 @@ js_generic_fast_native_method_dispatcher(JSContext *cx, uintN argc, jsval *vp)\\n     jsval fsv;\\n     JSFunctionSpec *fs;\\n     JSObject *tmp;\\n-    JSStackFrame *fp;\\n \\n     if (!JS_GetReservedSlot(cx, JSVAL_TO_OBJECT(*vp), 0, &fsv))\\n         return JS_FALSE;\\n@@ -4171,13 +4170,8 @@ js_generic_fast_native_method_dispatcher(JSContext *cx, uintN argc, jsval *vp)\\n      * Follow Function.prototype.apply and .call by using the global object as\\n      * the 'this' param if no args.\\n      */\\n-    fp = cx->fp;\\n-    JS_ASSERT((fp->flags & JSFRAME_IN_FAST_CALL) || fp->argv == vp + 2);\\n     if (!js_ComputeThis(cx, vp + 2))\\n         return JS_FALSE;\\n-    if (!(fp->flags & JSFRAME_IN_FAST_CALL))\\n-        fp->thisp = JSVAL_TO_OBJECT(vp[1]);\\n-\\n     /*\\n      * Protect against argc underflowing. By calling js_ComputeThis, we made\\n      * it as if the static was called with one parameter, the explicit |this|\\n@@ -4197,8 +4191,6 @@ js_generic_native_method_dispatcher(JSContext *cx, JSObject *obj,\\n     JSFunctionSpec *fs;\\n     JSObject *tmp;\\n \\n-    JS_ASSERT(!(cx->fp->flags & JSFRAME_IN_FAST_CALL));\\n-\\n     if (!JS_GetReservedSlot(cx, JSVAL_TO_OBJECT(argv[-2]), 0, &fsv))\\n         return JS_FALSE;\\n     fs = (JSFunctionSpec *) JSVAL_TO_PRIVATE(fsv);\\n@@ -4961,7 +4953,6 @@ JS_IsRunning(JSContext *cx)\\n JS_PUBLIC_API(JSBool)\\n JS_IsConstructing(JSContext *cx)\\n {\\n-    JS_ASSERT(!cx->fp || !(cx->fp->flags & JSFRAME_IN_FAST_CALL));\\n     return cx->fp && (cx->fp->flags & JSFRAME_CONSTRUCTING);\\n }\\n \\n@@ -4971,7 +4962,6 @@ JS_IsAssigning(JSContext *cx)\\n     JSStackFrame *fp;\\n     jsbytecode *pc;\\n \\n-    JS_ASSERT(!cx->fp || !(cx->fp->flags & JSFRAME_IN_FAST_CALL));\\n     for (fp = cx->fp; fp && !fp->script; fp = fp->down)\\n         continue;\\n     if (!fp || !(pc = fp->pc))\\n@@ -4997,7 +4987,6 @@ JS_SaveFrameChain(JSContext *cx)\\n     if (!fp)\\n         return fp;\\n \\n-    JS_ASSERT(!(fp->flags & JSFRAME_IN_FAST_CALL));\\n     JS_ASSERT(!fp->dormantNext);\\n     fp->dormantNext = cx->dormantFrameChain;\\n     cx->dormantFrameChain = fp;\\ndiff --git a/js/src/jsarray.c b/js/src/jsarray.c\\nindex 8d0feaf..d1fb5df 100644\\n--- a/js/src/jsarray.c\\n+++ b/js/src/jsarray.c\\n@@ -1762,29 +1762,23 @@ typedef enum ArrayExtraMode {\\n static JSBool\\n array_extra(JSContext *cx, ArrayExtraMode mode, uintN argc, jsval *vp)\\n {\\n-    enum { ELEM, TEMP, RVAL, NROOTS };\\n-    jsval *argv, roots[NROOTS], *sp, *origsp, *oldsp;\\n     JSObject *obj;\\n-    JSBool ok, cond, hole;\\n     jsuint length, newlen;\\n+    jsval *argv, *elemroot, *invokevp, *sp;\\n+    JSBool ok, cond, hole;\\n     JSObject *callable, *thisp, *newarr;\\n     jsint start, end, step, i;\\n-    JSTempValueRooter tvr;\\n     void *mark;\\n-    JSStackFrame *fp;\\n-\\n-    /* Hoist the explicit local root address computation. */\\n-    argv = vp + 2;\\n \\n     obj = JSVAL_TO_OBJECT(vp[1]);\\n-    ok = js_GetLengthProperty(cx, obj, &length);\\n-    if (!ok)\\n+    if (!js_GetLengthProperty(cx, obj, &length))\\n         return JS_FALSE;\\n \\n     /*\\n      * First, get or compute our callee, so that we error out consistently\\n      * when passed a non-callable object.\\n      */\\n+    argv = vp + 2;\\n     callable = js_ValueToCallableObject(cx, &argv[0], JSV2F_SEARCH_STACK);\\n     if (!callable)\\n         return JS_FALSE;\\n@@ -1798,8 +1792,6 @@ array_extra(JSContext *cx, ArrayExtraMode mode, uintN argc, jsval *vp)\\n     newarr = NULL;\\n #endif\\n     start = 0, end = length, step = 1;\\n-    memset(roots, 0, sizeof roots);\\n-    JS_PUSH_TEMP_ROOT(cx, NROOTS, roots, &tvr);\\n \\n     switch (mode) {\\n       case REDUCE_RIGHT:\\n@@ -1809,24 +1801,21 @@ array_extra(JSContext *cx, ArrayExtraMode mode, uintN argc, jsval *vp)\\n         if (length == 0 && argc == 1) {\\n             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,\\n                                  JSMSG_EMPTY_ARRAY_REDUCE);\\n-            ok = JS_FALSE;\\n-            goto early_out;\\n+            return JS_FALSE;\\n         }\\n         if (argc >= 2) {\\n-            roots[RVAL] = argv[1];\\n+            *vp = argv[1];\\n         } else {\\n             do {\\n-                ok = GetArrayElement(cx, obj, start, &hole, &roots[RVAL]);\\n-                if (!ok)\\n-                    goto early_out;\\n+                if (!GetArrayElement(cx, obj, start, &hole, vp))\\n+                    return JS_FALSE;\\n                 start += step;\\n             } while (hole && start != end);\\n \\n             if (hole && start == end) {\\n                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,\\n                                      JSMSG_EMPTY_ARRAY_REDUCE);\\n-                ok = JS_FALSE;\\n-                goto early_out;\\n+                return JS_FALSE;\\n             }\\n         }\\n         break;\\n@@ -1834,87 +1823,80 @@ array_extra(JSContext *cx, ArrayExtraMode mode, uintN argc, jsval *vp)\\n       case FILTER:\\n         newlen = (mode == MAP) ? length : 0;\\n         newarr = js_NewArrayObject(cx, newlen, NULL);\\n-        if (!newarr) {\\n-            ok = JS_FALSE;\\n-            goto early_out;\\n-        }\\n-        roots[RVAL] = OBJECT_TO_JSVAL(newarr);\\n+        if (!newarr)\\n+            return JS_FALSE;\\n+        *vp = OBJECT_TO_JSVAL(newarr);\\n         break;\\n       case SOME:\\n-        roots[RVAL] = JSVAL_FALSE;\\n+        *vp = JSVAL_FALSE;\\n         break;\\n       case EVERY:\\n-        roots[RVAL] = JSVAL_TRUE;\\n+        *vp = JSVAL_TRUE;\\n         break;\\n       case FOREACH:\\n+        *vp = JSVAL_VOID;\\n         break;\\n     }\\n \\n     if (length == 0)\\n-        goto early_out;\\n+        return JS_TRUE;\\n \\n     if (argc > 1 && !REDUCE_MODE(mode)) {\\n-        ok = js_ValueToObject(cx, argv[1], &thisp);\\n-        if (!ok)\\n-            goto early_out;\\n+        if (!js_ValueToObject(cx, argv[1], &thisp))\\n+            return JS_FALSE;\\n         argv[1] = OBJECT_TO_JSVAL(thisp);\\n     } else {\\n         thisp = NULL;\\n     }\\n \\n     /*\\n-     * For all but REDUCE, we call with 3 args (value, index, array), plus\\n-     * room for rval.  REDUCE requires 4 args (accum, value, index, array).\\n+     * For all but REDUCE, we call with 3 args (value, index, array). REDUCE\\n+     * requires 4 args (accum, value, index, array).\\n      */\\n     argc = 3 + REDUCE_MODE(mode);\\n-    origsp = js_AllocStack(cx, 2 + argc + 1, &mark);\\n-    if (!origsp) {\\n-        ok = JS_FALSE;\\n-        goto early_out;\\n-    }\\n+    elemroot = js_AllocStack(cx, 1 + 2 + argc, &mark);\\n+    if (!elemroot)\\n+        return JS_FALSE;\\n \\n-    /* Lift current frame to include our args. */\\n-    fp = cx->fp;\\n-    oldsp = fp->sp;\\n+    /* From this point the control must flow through out:. */\\n+    ok = JS_TRUE;\\n+    invokevp = elemroot + 1;\\n \\n     for (i = start; i != end; i += step) {\\n-        ok = (JS_CHECK_OPERATION_LIMIT(cx, JSOW_JUMP) &&\\n-              GetArrayElement(cx, obj, i, &hole, &roots[ELEM]));\\n+        ok = JS_CHECK_OPERATION_LIMIT(cx, JSOW_JUMP) &&\\n+             GetArrayElement(cx, obj, i, &hole, elemroot);\\n         if (!ok)\\n-            break;\\n+            goto out;\\n         if (hole)\\n             continue;\\n \\n         /*\\n          * Push callable and 'this', then args. We must do this for every\\n-         * iteration around the loop since js_Invoke uses origsp[0] for return\\n-         * value storage, while some native functions use origsp[1] for local\\n+         * iteration around the loop since js_Invoke uses spbase[0] for return\\n+         * value storage, while some native functions use spbase[1] for local\\n          * rooting.\\n          */\\n-        sp = origsp;\\n+        sp = invokevp;\\n         *sp++ = OBJECT_TO_JSVAL(callable);\\n         *sp++ = OBJECT_TO_JSVAL(thisp);\\n         if (REDUCE_MODE(mode))\\n-            *sp++ = roots[RVAL];\\n-        *sp++ = roots[ELEM];\\n+            *sp++ = *vp;\\n+        *sp++ = *elemroot;\\n         *sp++ = INT_TO_JSVAL(i);\\n         *sp++ = OBJECT_TO_JSVAL(obj);\\n \\n         /* Do the call. */\\n-        fp->sp = sp;\\n-        ok = js_Invoke(cx, argc, JSINVOKE_INTERNAL);\\n-        roots[TEMP] = fp->sp[-1];\\n-        fp->sp = oldsp;\\n+        ok = js_Invoke(cx, argc, invokevp, JSINVOKE_INTERNAL);\\n         if (!ok)\\n             break;\\n \\n         if (mode > MAP) {\\n-            if (roots[TEMP] == JSVAL_NULL) {\\n+            if (*invokevp == JSVAL_NULL) {\\n                 cond = JS_FALSE;\\n-            } else if (JSVAL_IS_BOOLEAN(roots[TEMP])) {\\n-                cond = JSVAL_TO_BOOLEAN(roots[TEMP]);\\n+            } else if (JSVAL_IS_BOOLEAN(*invokevp)) {\\n+                cond = JSVAL_TO_BOOLEAN(*invokevp);\\n             } else {\\n-                ok = js_ValueToBoolean(cx, roots[TEMP], &cond);\\n+                ok = js_ValueToBoolean(cx, *invokevp, &cond);\\n                 if (!ok)\\n                     goto out;\\n             }\\n@@ -1925,30 +1907,30 @@ array_extra(JSContext *cx, ArrayExtraMode mode, uintN argc, jsval *vp)\\n             break;\\n           case REDUCE:\\n           case REDUCE_RIGHT:\\n-            roots[RVAL] = roots[TEMP];\\n+            *vp = *invokevp;\\n             break;\\n           case MAP:\\n-            ok = SetArrayElement(cx, newarr, i, roots[TEMP]);\\n+            ok = SetArrayElement(cx, newarr, i, *invokevp);\\n             if (!ok)\\n                 goto out;\\n             break;\\n           case FILTER:\\n             if (!cond)\\n                 break;\\n-            /* The filter passed roots[ELEM], so push it onto our result. */\\n-            ok = SetArrayElement(cx, newarr, newlen++, roots[ELEM]);\\n+            /* The filter passed *elemroot, so push it onto our result. */\\n+            ok = SetArrayElement(cx, newarr, newlen++, *elemroot);\\n             if (!ok)\\n                 goto out;\\n             break;\\n           case SOME:\\n             if (cond) {\\n-                roots[RVAL] = JSVAL_TRUE;\\n+                *vp = JSVAL_TRUE;\\n                 goto out;\\n             }\\n             break;\\n           case EVERY:\\n             if (!cond) {\\n-                roots[RVAL] = JSVAL_FALSE;\\n+                *vp = JSVAL_FALSE;\\n                 goto out;\\n             }\\n             break;\\n@@ -1959,9 +1941,6 @@ array_extra(JSContext *cx, ArrayExtraMode mode, uintN argc, jsval *vp)\\n     js_FreeStack(cx, mark);\\n     if (ok && mode == FILTER)\\n         ok = js_SetLengthProperty(cx, newarr, newlen);\\n-  early_out:\\n-    *vp = roots[RVAL];\\n-    JS_POP_TEMP_ROOT(cx, &tvr);\\n     return ok;\\n }\\n \\ndiff --git a/js/src/jsdbgapi.c b/js/src/jsdbgapi.c\\nindex 8e6ef22..6d2f533 100644\\n--- a/js/src/jsdbgapi.c\\n+++ b/js/src/jsdbgapi.c\\n@@ -545,11 +545,16 @@ js_watch_set(JSContext *cx, JSObject *obj, jsval id, jsval *vp)\\n                  * identify the guilty party.  So that the watcher appears to\\n                  * be active to obj_eval and other such code, point frame.pc\\n                  * at the JSOP_STOP at the end of the script.\\n+                 *\\n+                 * The pseudo-frame is not created for fast natives as they\\n+                 * are treated as interpreter frame extensions and always\\n+                 * trusted.\\n                  */\\n                 JSObject *closure;\\n                 JSClass *clasp;\\n                 JSFunction *fun;\\n                 JSScript *script;\\n+                JSBool injectFrame;\\n                 uintN nslots;\\n                 jsval smallv[5];\\n                 jsval *argv;\\n@@ -569,56 +574,66 @@ js_watch_set(JSContext *cx, JSObject *obj, jsval id, jsval *vp)\\n                 }\\n \\n                 nslots = 2;\\n+                injectFrame = JS_TRUE;\\n                 if (fun) {\\n                     nslots += FUN_MINARGS(fun);\\n-                    if (!FUN_INTERPRETED(fun))\\n+                    if (!FUN_INTERPRETED(fun)) {\\n                         nslots += fun->u.n.extra;\\n+                        injectFrame = !(fun->flags & JSFUN_FAST_NATIVE);\\n+                    }\\n                 }\\n \\n-                if (nslots <= JS_ARRAY_LENGTH(smallv)) {\\n-                    argv = smallv;\\n-                } else {\\n-                    argv = (jsval *) JS_malloc(cx, nslots * sizeof(jsval));\\n-                    if (!argv) {\\n-                        DBG_LOCK(rt);\\n-                        DropWatchPointAndUnlock(cx, wp, JSWP_HELD);\\n-                        return JS_FALSE;\\n+                if (injectFrame) {\\n+                    if (nslots <= JS_ARRAY_LENGTH(smallv)) {\\n+                        argv = smallv;\\n+                    } else {\\n+                        argv = (jsval *) JS_malloc(cx, nslots * sizeof(jsval));\\n+                        if (!argv) {\\n+                            DBG_LOCK(rt);\\n+                            DropWatchPointAndUnlock(cx, wp, JSWP_HELD);\\n+                            return JS_FALSE;\\n+                        }\\n                     }\\n-                }\\n \\n-                argv[0] = OBJECT_TO_JSVAL(closure);\\n-                argv[1] = JSVAL_NULL;\\n-                memset(argv + 2, 0, (nslots - 2) * sizeof(jsval));\\n+                    argv[0] = OBJECT_TO_JSVAL(closure);\\n+                    argv[1] = JSVAL_NULL;\\n+                    memset(argv + 2, 0, (nslots - 2) * sizeof(jsval));\\n \\n-                memset(&frame, 0, sizeof(frame));\\n-                frame.script = script;\\n-                if (script) {\\n-                    JS_ASSERT(script->length >= JSOP_STOP_LENGTH);\\n-                    frame.pc = script->code + script->length\\n-                             - JSOP_STOP_LENGTH;\\n-                }\\n-                frame.callee = closure;\\n-                frame.fun = fun;\\n-                frame.argv = argv + 2;\\n-                frame.down = cx->fp;\\n-                frame.scopeChain = OBJ_GET_PARENT(cx, closure);\\n+                    memset(&frame, 0, sizeof(frame));\\n+                    frame.script = script;\\n+                    if (script) {\\n+                        JS_ASSERT(script->length >= JSOP_STOP_LENGTH);\\n+                        frame.pc = script->code + script->length\\n+                                   - JSOP_STOP_LENGTH;\\n+                    }\\n+                    frame.callee = closure;\\n+                    frame.fun = fun;\\n+                    frame.argv = argv + 2;\\n+                    frame.down = cx->fp;\\n+                    frame.scopeChain = OBJ_GET_PARENT(cx, closure);\\n \\n-                cx->fp = &frame;\\n+                    cx->fp = &frame;\\n+                }\\n+#ifdef __GNUC__\\n+                else\\n+                    argv = NULL;    /* suppress bogus gcc warnings */\\n+#endif\\n                 ok = !wp->setter ||\\n                      ((sprop->attrs & JSPROP_SETTER)\\n                       ? js_InternalCall(cx, obj, OBJECT_TO_JSVAL(wp->setter),\\n                                         1, vp, vp)\\n                       : wp->setter(cx, OBJ_THIS_OBJECT(cx, obj), userid, vp));\\n-\\n-                /* Evil code can cause us to have an arguments object. */\\n-                if (frame.callobj)\\n-                    ok &= js_PutCallObject(cx, &frame);\\n-                if (frame.argsobj)\\n-                    ok &= js_PutArgsObject(cx, &frame);\\n-\\n-                cx->fp = frame.down;\\n-                if (argv != smallv)\\n-                    JS_free(cx, argv);\\n+                if (injectFrame) {\\n+                    /* Evil code can cause us to have an arguments object. */\\n+                    if (frame.callobj)\\n+                        ok &= js_PutCallObject(cx, &frame);\\n+                    if (frame.argsobj)\\n+                        ok &= js_PutArgsObject(cx, &frame);\\n+\\n+                    cx->fp = frame.down;\\n+                    if (argv != smallv)\\n+                        JS_free(cx, argv);\\n+                }\\n             }\\n             DBG_LOCK(rt);\\n             return DropWatchPointAndUnlock(cx, wp, JSWP_HELD) && ok;\\ndiff --git a/js/src/jsfun.c b/js/src/jsfun.c\\nindex 9bcdc91..64f7be1 100644\\n--- a/js/src/jsfun.c\\n+++ b/js/src/jsfun.c\\n@@ -1059,8 +1059,6 @@ fun_getProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)\\n         break;\\n \\n       case FUN_CALLER:\\n-        while (fp && (fp->flags & JSFRAME_SKIP_CALLER) && fp->down)\\n-            fp = fp->down;\\n         if (fp && fp->down && fp->down->fun)\\n             *vp = OBJECT_TO_JSVAL(fp->down->callee);\\n         else\\n@@ -1590,11 +1588,9 @@ static JSBool\\n fun_call(JSContext *cx, uintN argc, jsval *vp)\\n {\\n     JSObject *obj;\\n-    jsval fval, *argv, *sp, *oldsp;\\n+    jsval fval, *argv, *invokevp;\\n     JSString *str;\\n     void *mark;\\n-    uintN i;\\n-    JSStackFrame *fp;\\n     JSBool ok;\\n \\n     obj = JSVAL_TO_OBJECT(vp[1]);\\n@@ -1632,28 +1628,17 @@ fun_call(JSContext *cx, uintN argc, jsval *vp)\\n     }\\n \\n     /* Allocate stack space for fval, obj, and the args. */\\n-    sp = js_AllocStack(cx, 2 + argc, &mark);\\n-    if (!sp)\\n+    invokevp = js_AllocStack(cx, 2 + argc, &mark);\\n+    if (!invokevp)\\n         return JS_FALSE;\\n \\n     /* Push fval, obj, and the args. */\\n-    *sp++ = fval;\\n-    *sp++ = OBJECT_TO_JSVAL(obj);\\n-    for (i = 0; i < argc; i++)\\n-        *sp++ = argv[i];\\n+    invokevp[0] = fval;\\n+    invokevp[1] = OBJECT_TO_JSVAL(obj);\\n+    memcpy(invokevp + 2, argv, argc * sizeof *argv);\\n \\n-    /* Lift current frame to include the args and do the call. */\\n-    fp = cx->fp;\\n-    oldsp = fp->sp;\\n-    fp->sp = sp;\\n-    ok = js_Invoke(cx, argc,\\n-                   (fp->flags & JSFRAME_IN_FAST_CALL)\\n-                   ? JSINVOKE_INTERNAL\\n-                   : JSINVOKE_INTERNAL | JSINVOKE_SKIP_CALLER);\\n-\\n-    /* Store rval and pop stack back to our frame's sp. */\\n-    *vp = fp->sp[-1];\\n-    fp->sp = oldsp;\\n+    ok = js_Invoke(cx, argc, invokevp, JSINVOKE_INTERNAL);\\n+    *vp = *invokevp;\\n     js_FreeStack(cx, mark);\\n     return ok;\\n }\\n@@ -1662,13 +1647,12 @@ static JSBool\\n fun_apply(JSContext *cx, uintN argc, jsval *vp)\\n {\\n     JSObject *obj, *aobj;\\n-    jsval fval, *sp, *oldsp;\\n+    jsval fval, *invokevp, *sp;\\n     JSString *str;\\n     jsuint length;\\n     JSBool arraylike, ok;\\n     void *mark;\\n     uintN i;\\n-    JSStackFrame *fp;\\n \\n     if (argc == 0) {\\n         /* Will get globalObject as 'this' and no other arguments. */\\n@@ -1727,11 +1711,12 @@ fun_apply(JSContext *cx, uintN argc, jsval *vp)\\n \\n     /* Allocate stack space for fval, obj, and the args. */\\n     argc = (uintN)JS_MIN(length, ARRAY_INIT_LIMIT - 1);\\n-    sp = js_AllocStack(cx, 2 + argc, &mark);\\n-    if (!sp)\\n+    invokevp = js_AllocStack(cx, 2 + argc, &mark);\\n+    if (!invokevp)\\n         return JS_FALSE;\\n \\n     /* Push fval, obj, and aobj's elements as args. */\\n+    sp = invokevp;\\n     *sp++ = fval;\\n     *sp++ = OBJECT_TO_JSVAL(obj);\\n     for (i = 0; i < argc; i++) {\\n@@ -1741,18 +1726,8 @@ fun_apply(JSContext *cx, uintN argc, jsval *vp)\\n         sp++;\\n     }\\n \\n-    /* Lift current frame to include the args and do the call. */\\n-    fp = cx->fp;\\n-    oldsp = fp->sp;\\n-    fp->sp = sp;\\n-    ok = js_Invoke(cx, argc,\\n-                   (fp->flags & JSFRAME_IN_FAST_CALL)\\n-                   ? JSINVOKE_INTERNAL\\n-                   : JSINVOKE_INTERNAL | JSINVOKE_SKIP_CALLER);\\n-\\n-    /* Store rval and pop stack back to our frame's sp. */\\n-    *vp = fp->sp[-1];\\n-    fp->sp = oldsp;\\n+    ok = js_Invoke(cx, argc, invokevp, JSINVOKE_INTERNAL);\\n+    *vp = *invokevp;\\n out:\\n     js_FreeStack(cx, mark);\\n     return ok;\\n@@ -1765,8 +1740,7 @@ fun_applyConstructor(JSContext *cx, uintN argc, jsval *vp)\\n     JSObject *aobj;\\n     uintN length, i;\\n     void *mark;\\n-    jsval *sp, *newsp, *oldsp;\\n-    JSStackFrame *fp;\\n+    jsval *invokevp, *sp;\\n     JSBool ok;\\n \\n     if (JSVAL_IS_PRIMITIVE(vp[2]) ||\\n@@ -1783,12 +1757,11 @@ fun_applyConstructor(JSContext *cx, uintN argc, jsval *vp)\\n \\n     if (length >= ARRAY_INIT_LIMIT)\\n         length = ARRAY_INIT_LIMIT - 1;\\n-    newsp = sp = js_AllocStack(cx, 2 + length, &mark);\\n-    if (!sp)\\n+    invokevp = js_AllocStack(cx, 2 + length, &mark);\\n+    if (!invokevp)\\n         return JS_FALSE;\\n \\n-    fp = cx->fp;\\n-    oldsp = fp->sp;\\n+    sp = invokevp;\\n     *sp++ = vp[1];\\n     *sp++ = JSVAL_NULL; /* This is filled automagically. */\\n     for (i = 0; i < length; i++) {\\n@@ -1798,12 +1771,8 @@ fun_applyConstructor(JSContext *cx, uintN argc, jsval *vp)\\n         sp++;\\n     }\\n \\n-    oldsp = fp->sp;\\n-    fp->sp = sp;\\n-    ok = js_InvokeConstructor(cx, newsp, length);\\n-\\n-    *vp = fp->sp[-1];\\n-    fp->sp = oldsp;\\n+    ok = js_InvokeConstructor(cx, invokevp, length);\\n+    *vp = *invokevp;\\n out:\\n     js_FreeStack(cx, mark);\\n     return ok;\\n@@ -2358,9 +2327,7 @@ js_ReportIsNotFunction(JSContext *cx, jsval *vp, uintN flags)\\n     }\\n \\n     js_ReportValueError3(cx, error,\\n-                         (fp &&\\n-                          !(fp->flags & JSFRAME_IN_FAST_CALL) &&\\n-                          fp->spbase <= vp && vp < fp->sp)\\n+                         (fp && fp->spbase <= vp && vp < fp->sp)\\n                          ? vp - fp->sp\\n                          : (flags & JSV2F_SEARCH_STACK)\\n                          ? JSDVG_SEARCH_STACK\\ndiff --git a/js/src/jsgc.c b/js/src/jsgc.c\\nindex 56d4751..b1ee60c 100644\\n--- a/js/src/jsgc.c\\n+++ b/js/src/jsgc.c\\n@@ -2205,8 +2205,7 @@ gc_lock_traversal(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 num,\\n void\\n js_TraceStackFrame(JSTracer *trc, JSStackFrame *fp)\\n {\\n-    uintN depth, nslots, minargs;\\n-    jsval *vp;\\n+    uintN nslots, minargs, skip;\\n \\n     if (fp->callobj)\\n         JS_CALL_OBJECT_TRACER(trc, fp->callobj, \\\"call\\\");\\n@@ -2221,11 +2220,9 @@ js_TraceStackFrame(JSTracer *trc, JSStackFrame *fp)\\n              * Don't mark what has not been pushed yet, or what has been\\n              * popped already.\\n              */\\n-            depth = fp->script->depth;\\n-            nslots = (JS_UPTRDIFF(fp->sp, fp->spbase)\\n-                      < depth * sizeof(jsval))\\n-                     ? (uintN)(fp->sp - fp->spbase)\\n-                     : depth;\\n+            JS_ASSERT(JS_UPTRDIFF(fp->sp, fp->spbase) <=\\n+                      fp->script->depth * sizeof(jsval));\\n+            nslots = (uintN) (fp->sp - fp->spbase);\\n             TRACE_JSVALS(trc, nslots, fp->spbase, \\\"operand\\\");\\n         }\\n     }\\n@@ -2239,32 +2236,20 @@ js_TraceStackFrame(JSTracer *trc, JSStackFrame *fp)\\n         JS_CALL_OBJECT_TRACER(trc, fp->callee, \\\"callee\\\");\\n \\n     if (fp->argv) {\\n-        /* Trace argv including callee and thisp slots. */\\n         nslots = fp->argc;\\n+        skip = 0;\\n         if (fp->fun) {\\n             minargs = FUN_MINARGS(fp->fun);\\n             if (minargs > nslots)\\n                 nslots = minargs;\\n-            if (!FUN_INTERPRETED(fp->fun))\\n+            if (!FUN_INTERPRETED(fp->fun)) {\\n+                JS_ASSERT(!(fp->fun->flags & JSFUN_FAST_NATIVE));\\n                 nslots += fp->fun->u.n.extra;\\n-        }\\n-        nslots += 2;\\n-        vp = fp->argv - 2;\\n-        if (fp->down && fp->down->spbase) {\\n-            /*\\n-             * Avoid unnecessary tracing in the common case when args overlaps\\n-             * with the stack segment of the previous frame. That segment is\\n-             * traced via the above spbase code and, when sp > spbase + depth,\\n-             * during tracing of the stack headers in js_TraceContext.\\n-             */\\n-            if (JS_UPTRDIFF(vp, fp->down->spbase) <\\n-                JS_UPTRDIFF(fp->down->sp, fp->down->spbase)) {\\n-                JS_ASSERT((size_t)nslots >= (size_t)(fp->down->sp - vp));\\n-                nslots -= (uintN)(fp->down->sp - vp);\\n-                vp = fp->down->sp;\\n             }\\n+            if (fp->fun->flags & JSFRAME_ROOTED_ARGV)\\n+                skip = 2 + fp->argc;\\n         }\\n-        TRACE_JSVALS(trc, nslots, vp, \\\"arg\\\");\\n+        TRACE_JSVALS(trc, 2 + nslots - skip, fp->argv - 2 + skip, \\\"operand\\\");\\n     }\\n     JS_CALL_VALUE_TRACER(trc, fp->rval, \\\"rval\\\");\\n     if (fp->vars)\\ndiff --git a/js/src/jsinterp.c b/js/src/jsinterp.c\\nindex cff9d4b..e9765a3 100644\\n--- a/js/src/jsinterp.c\\n+++ b/js/src/jsinterp.c\\n@@ -81,13 +81,9 @@\\n  */\\n #define PUSH(v)         (*sp++ = (v))\\n #define POP()           (*--sp)\\n-#ifdef DEBUG\\n #define SAVE_SP(fp)                                                           \\\\\\n     (JS_ASSERT((fp)->script || !(fp)->spbase || (sp) == (fp)->spbase),        \\\\\\n      (fp)->sp = sp)\\n-#else\\n-#define SAVE_SP(fp)     ((fp)->sp = sp)\\n-#endif\\n #define RESTORE_SP(fp)  (sp = (fp)->sp)\\n \\n /*\\n@@ -265,6 +261,35 @@\\n         v = sp[n];                                                            \\\\\\n     JS_END_MACRO\\n \\n+/*\\n+ * Check if the current arena has enough space to fit nslots after sp and, if\\n+ * so, reserve the necessary space.\\n+ */\\n+static JSBool\\n+AllocateAfterSP(JSContext *cx, jsval *sp, uintN nslots)\\n+{\\n+    uintN surplus;\\n+    jsval *sp2;\\n+\\n+    JS_ASSERT((jsval *) cx->stackPool.current->base <= sp);\\n+    JS_ASSERT(sp <= (jsval *) cx->stackPool.current->avail);\\n+    surplus = (jsval *) cx->stackPool.current->avail - sp;\\n+    if (nslots <= surplus)\\n+        return JS_TRUE;\\n+\\n+    /*\\n+     * No room before current->avail, check if the arena has enough space to\\n+     * fit the missing slots before the limit.\\n+     */\\n+    if (nslots > (size_t) ((jsval *) cx->stackPool.current->limit - sp))\\n+        return JS_FALSE;\\n+\\n+    JS_ARENA_ALLOCATE_CAST(sp2, jsval *, &cx->stackPool,\\n+                           (nslots - surplus) * sizeof(jsval));\\n+    JS_ASSERT(sp2 == sp + surplus);\\n+    return JS_TRUE;\\n+}\\n+\\n JS_FRIEND_API(jsval *)\\n js_AllocRawStack(JSContext *cx, uintN nslots, void **markp)\\n {\\n@@ -291,10 +316,9 @@ js_FreeRawStack(JSContext *cx, void *mark)\\n JS_FRIEND_API(jsval *)\\n js_AllocStack(JSContext *cx, uintN nslots, void **markp)\\n {\\n-    jsval *sp, *vp, *end;\\n+    jsval *sp;\\n     JSArena *a;\\n     JSStackHeader *sh;\\n-    JSStackFrame *fp;\\n \\n     /* Callers don't check for zero nslots: we do to avoid empty segments. */\\n     if (nslots == 0) {\\n@@ -316,24 +340,9 @@ js_AllocStack(JSContext *cx, uintN nslots, void **markp)\\n         a->avail -= 2 * sizeof(jsval);\\n     } else {\\n         /*\\n-         * Need a new stack segment, so we must initialize unused slots in the\\n-         * current frame.  See js_GC, just before marking the \\\"operand\\\" jsvals,\\n-         * where we scan from fp->spbase to fp->sp or through fp->script->depth\\n-         * (whichever covers fewer slots).\\n+         * Need a new stack segment, so allocate and push a stack segment\\n+         * header from the 2 extra slots.\\n          */\\n-        fp = cx->fp;\\n-        if (fp && fp->script && fp->spbase) {\\n-#ifdef DEBUG\\n-            jsuword depthdiff = fp->script->depth * sizeof(jsval);\\n-            JS_ASSERT(JS_UPTRDIFF(fp->sp, fp->spbase) <= depthdiff);\\n-            JS_ASSERT(JS_UPTRDIFF(*markp, fp->spbase) >= depthdiff);\\n-#endif\\n-            end = fp->spbase + fp->script->depth;\\n-            for (vp = fp->sp; vp < end; vp++)\\n-                *vp = JSVAL_VOID;\\n-        }\\n-\\n-        /* Allocate and push a stack segment header from the 2 extra slots. */\\n         sh = (JSStackHeader *)sp;\\n         sh->nslots = nslots;\\n         sh->down = cx->stackHeaders;\\n@@ -604,9 +613,9 @@ js_ComputeThis(JSContext *cx, jsval *argv)\\n #if JS_HAS_NO_SUCH_METHOD\\n \\n static JSBool\\n-NoSuchMethod(JSContext *cx, JSStackFrame *fp, jsval *vp, uint32 flags,\\n-             uintN argc)\\n+NoSuchMethod(JSContext *cx, uintN argc, jsval *vp, uint32 flags)\\n {\\n+    JSStackFrame *fp;\\n     JSObject *thisp, *argsobj;\\n     JSAtom *atom;\\n     jsval *sp, roots[3];\\n@@ -618,6 +627,7 @@ NoSuchMethod(JSContext *cx, JSStackFrame *fp, jsval *vp, uint32 flags,\\n     /* NB: js_ComputeThis or equivalent must have been called already. */\\n     JS_ASSERT(JSVAL_IS_PRIMITIVE(vp[0]));\\n     JS_ASSERT(!JSVAL_IS_PRIMITIVE(vp[1]));\\n+    fp = cx->fp;\\n     RESTORE_SP(fp);\\n \\n     /* From here on, control must flow through label out: to return. */\\n@@ -1029,11 +1039,6 @@ LogCall(JSContext *cx, jsval callee, uintN argc, jsval *argv)\\n # define ASSERT_NOT_THROWING(cx) /* nothing */\\n #endif\\n \\n-#define START_FAST_CALL(fp) (JS_ASSERT(!((fp)->flags & JSFRAME_IN_FAST_CALL)),\\\\\\n-                             (fp)->flags |= JSFRAME_IN_FAST_CALL)\\n-#define END_FAST_CALL(fp)   (JS_ASSERT((fp)->flags & JSFRAME_IN_FAST_CALL),   \\\\\\n-                             (fp)->flags &= ~JSFRAME_IN_FAST_CALL)\\n-\\n /*\\n  * We check if the function accepts a primitive value as |this|. For that we\\n  * use a table that maps value's tag into the corresponding function flag.\\n@@ -1065,12 +1070,12 @@ static const uint16 PrimitiveTestFlags[] = {\\n  * when done.  Then push the return value.\\n  */\\n JS_FRIEND_API(JSBool)\\n-js_Invoke(JSContext *cx, uintN argc, uintN flags)\\n+js_Invoke(JSContext *cx, uintN argc, jsval *vp, uintN flags)\\n {\\n     void *mark;\\n-    JSStackFrame *fp, frame;\\n-    jsval *sp, *newsp, *limit;\\n-    jsval *vp, v;\\n+    JSStackFrame frame;\\n+    jsval *sp, *argv, *newvp;\\n+    jsval v;\\n     JSObject *funobj, *parent;\\n     JSBool ok;\\n     JSClass *clasp;\\n@@ -1078,24 +1083,21 @@ js_Invoke(JSContext *cx, uintN argc, uintN flags)\\n     JSNative native;\\n     JSFunction *fun;\\n     JSScript *script;\\n-    uintN nslots, nvars, nalloc, surplus;\\n+    uintN nslots, nvars, i;\\n+    uint32 rootedArgsFlag;\\n     JSInterpreterHook hook;\\n     void *hookData;\\n \\n-    /* Mark the top of stack and load frequently-used registers. */\\n-    mark = JS_ARENA_MARK(&cx->stackPool);\\n-    fp = cx->fp;\\n-    sp = fp->sp;\\n+    /* [vp .. vp + 2 + argc) must belong to the last JS stack arena. */\\n+    JS_ASSERT((jsval *) cx->stackPool.current->base <= vp);\\n+    JS_ASSERT(vp + 2 + argc <= (jsval *) cx->stackPool.current->avail);\\n \\n     /*\\n-     * Set vp to the callee value's stack slot (it's where rval goes).\\n-     * Once vp is set, control should flow through label out2: to return.\\n-     * Set frame.rval early so native class and object ops can throw and\\n-     * return false, causing a goto out2 with ok set to false.\\n+     * Mark the top of stack and load frequently-used registers. After this\\n+     * point the control should flow through label out2: to return.\\n      */\\n-    vp = sp - (2 + argc);\\n+    mark = JS_ARENA_MARK(&cx->stackPool);\\n     v = *vp;\\n-    frame.rval = JSVAL_VOID;\\n \\n     /*\\n      * A callee must be an object reference, unless its 'this' parameter\\n@@ -1110,10 +1112,8 @@ js_Invoke(JSContext *cx, uintN argc, uintN flags)\\n      */\\n     if (JSVAL_IS_PRIMITIVE(v)) {\\n #if JS_HAS_NO_SUCH_METHOD\\n-        if (fp->script && !(flags & JSINVOKE_INTERNAL)) {\\n-            ok = NoSuchMethod(cx, fp, vp, flags, argc);\\n-            if (ok)\\n-                frame.rval = *vp;\\n+        if (cx->fp && cx->fp->script && !(flags & JSINVOKE_INTERNAL)) {\\n+            ok = NoSuchMethod(cx, argc, vp, flags);\\n             goto out2;\\n         }\\n #endif\\n@@ -1170,8 +1170,8 @@ js_Invoke(JSContext *cx, uintN argc, uintN flags)\\n have_fun:\\n         /* Get private data and set derived locals from it. */\\n         fun = (JSFunction *) OBJ_GET_PRIVATE(cx, funobj);\\n-        nalloc = FUN_MINARGS(fun);\\n-        nslots = (nalloc > argc) ? nalloc - argc : 0;\\n+        nslots = FUN_MINARGS(fun);\\n+        nslots = (nslots > argc) ? nslots - argc : 0;\\n         if (FUN_INTERPRETED(fun)) {\\n             native = NULL;\\n             script = fun->u.i.script;\\n@@ -1189,14 +1189,12 @@ have_fun:\\n         } else if (!JSVAL_IS_OBJECT(vp[1])) {\\n             JS_ASSERT(!(flags & JSINVOKE_CONSTRUCT));\\n             if (PRIMITIVE_THIS_TEST(fun, vp[1]))\\n-                goto init_frame;\\n+                goto init_slots;\\n         }\\n     }\\n \\n     if (flags & JSINVOKE_CONSTRUCT) {\\n-        /* Default return value for a constructor is the new object. */\\n         JS_ASSERT(!JSVAL_IS_PRIMITIVE(vp[1]));\\n-        frame.rval = vp[1];\\n     } else {\\n         /*\\n          * We must call js_ComputeThis in case we are not called from the\\n@@ -1208,9 +1206,80 @@ have_fun:\\n             goto out2;\\n     }\\n \\n-  init_frame:\\n+  init_slots:\\n+    argv = vp + 2;\\n+    sp = argv + argc;\\n+\\n+    rootedArgsFlag = JSFRAME_ROOTED_ARGV;\\n+    if (nslots != 0) {\\n+        /*\\n+         * The extra slots required by the function must be continues with the\\n+         * arguments. Thus, when the last arena does not have room to fit\\n+         * nslots right after sp and AllocateAfterSP fails, we have to copy\\n+         * [vp..vp+2+argc) slots and clear rootedArgsFlag to root the copy.\\n+         */\\n+        if (!AllocateAfterSP(cx, sp, nslots)) {\\n+            rootedArgsFlag = 0;\\n+            newvp = js_AllocRawStack(cx, 2 + argc + nslots, NULL);\\n+            if (!newvp) {\\n+                ok = JS_FALSE;\\n+                goto out2;\\n+            }\\n+            memcpy(newvp, vp, (2 + argc) * sizeof(jsval));\\n+            argv = newvp + 2;\\n+            sp = argv + argc;\\n+        }\\n+\\n+        /* Push void to initialize missing args. */\\n+        i = nslots;\\n+        do {\\n+            PUSH(JSVAL_VOID);\\n+        } while (--i != 0);\\n+    }\\n+\\n+    if (native && fun && (fun->flags & JSFUN_FAST_NATIVE)) {\\n+        JSTempValueRooter tvr;\\n+#ifdef DEBUG_NOT_THROWING\\n+        JSBool alreadyThrowing = cx->throwing;\\n+#endif\\n+#if JS_HAS_LVALUE_RETURN\\n+        /* Set by JS_SetCallReturnValue2, used to return reference types. */\\n+        cx->rval2set = JS_FALSE;\\n+#endif\\n+        /* Root the extra slots that are not covered by [vp..vp+2+argc). */\\n+        i = rootedArgsFlag ? 2 + argc : 0;\\n+        JS_PUSH_TEMP_ROOT(cx, 2 + argc + nslots - i, argv - 2 + i, &tvr);\\n+        ok = ((JSFastNative) native)(cx, argc, argv - 2);\\n+        JS_POP_TEMP_ROOT(cx, &tvr);\\n+\\n+        JS_RUNTIME_METER(cx->runtime, nativeCalls);\\n+#ifdef DEBUG_NOT_THROWING\\n+        if (ok && !alreadyThrowing)\\n+            ASSERT_NOT_THROWING(cx);\\n+#endif\\n+        goto out2;\\n+    }\\n+\\n+    /* Now allocate stack space for local variables of interpreted function. */\\n+    if (nvars) {\\n+        if (!AllocateAfterSP(cx, sp, nvars)) {\\n+            /* NB: Discontinuity between argv and vars. */\\n+            sp = js_AllocRawStack(cx, nvars, NULL);\\n+            if (!sp) {\\n+                ok = JS_FALSE;\\n+                goto out2;\\n+            }\\n+        }\\n+\\n+        /* Push void to initialize local variables. */\\n+        i = nvars;\\n+        do {\\n+            PUSH(JSVAL_VOID);\\n+        } while (--i != 0);\\n+    }\\n+\\n     /*\\n-     * Initialize the rest of frame, except for sp (set by SAVE_SP later).\\n+     * Initialize the frame, except for sp (set by SAVE_SP later).\\n      *\\n      * To set thisp we use an explicit cast and not JSVAL_TO_OBJECT, as vp[1]\\n      * can be a primitive value here for those native functions specified with\\n@@ -1223,17 +1292,20 @@ have_fun:\\n     frame.callee = funobj;\\n     frame.fun = fun;\\n     frame.argc = argc;\\n-    frame.argv = sp - argc;\\n+    frame.argv = argv;\\n+\\n+    /* Default return value for a constructor is the new object. */\\n+    frame.rval = (flags & JSINVOKE_CONSTRUCT) ? vp[1] : JSVAL_VOID;\\n     frame.nvars = nvars;\\n-    frame.vars = sp;\\n-    frame.down = fp;\\n+    frame.vars = sp - nvars;\\n+    frame.down = cx->fp;\\n     frame.annotation = NULL;\\n     frame.scopeChain = NULL;    /* set below for real, after cx->fp is set */\\n     frame.pc = NULL;\\n     frame.spbase = NULL;\\n     frame.sharpDepth = 0;\\n     frame.sharpArray = NULL;\\n-    frame.flags = flags;\\n+    frame.flags = flags | rootedArgsFlag;\\n     frame.dormantNext = NULL;\\n     frame.xmlNamespace = NULL;\\n     frame.blockChain = NULL;\\n@@ -1245,77 +1317,6 @@ have_fun:\\n     hook = cx->debugHooks->callHook;\\n     hookData = NULL;\\n \\n-    /* Check for argument slots required by the function. */\\n-    if (nslots) {\\n-        /* All arguments must be contiguous, so we may have to copy actuals. */\\n-        nalloc = nslots;\\n-        limit = (jsval *) cx->stackPool.current->limit;\\n-        JS_ASSERT((jsval *) cx->stackPool.current->base <= sp && sp <= limit);\\n-        if (sp + nslots > limit) {\\n-            /* Hit end of arena: we have to copy argv[-2..(argc+nslots-1)]. */\\n-            nalloc += 2 + argc;\\n-        } else {\\n-            /* Take advantage of surplus slots in the caller's frame depth. */\\n-            JS_ASSERT((jsval *)mark >= sp);\\n-            surplus = (jsval *)mark - sp;\\n-            nalloc -= surplus;\\n-        }\\n-\\n-        /* Check whether we have enough space in the caller's frame. */\\n-        if ((intN)nalloc > 0) {\\n-            /* Need space for actuals plus missing formals minus surplus. */\\n-            newsp = js_AllocRawStack(cx, nalloc, NULL);\\n-            if (!newsp) {\\n-                ok = JS_FALSE;\\n-                goto out;\\n-            }\\n-\\n-            /* If we couldn't allocate contiguous args, copy actuals now. */\\n-            if (newsp != mark) {\\n-                JS_ASSERT(sp + nslots > limit);\\n-                JS_ASSERT(2 + argc + nslots == nalloc);\\n-                *newsp++ = vp[0];\\n-                *newsp++ = vp[1];\\n-                if (argc)\\n-                    memcpy(newsp, frame.argv, argc * sizeof(jsval));\\n-                frame.argv = newsp;\\n-                sp = frame.vars = newsp + argc;\\n-            }\\n-        }\\n-\\n-        /* Advance frame.vars to make room for the missing args. */\\n-        frame.vars += nslots;\\n-\\n-        /* Push void to initialize missing args. */\\n-        do {\\n-            PUSH(JSVAL_VOID);\\n-        } while (--nslots != 0);\\n-    }\\n-    JS_ASSERT(nslots == 0);\\n-\\n-    /* Now allocate stack space for local variables. */\\n-    if (nvars) {\\n-        JS_ASSERT((jsval *)cx->stackPool.current->avail >= frame.vars);\\n-        surplus = (jsval *)cx->stackPool.current->avail - frame.vars;\\n-        if (surplus < nvars) {\\n-            newsp = js_AllocRawStack(cx, nvars, NULL);\\n-            if (!newsp) {\\n-                ok = JS_FALSE;\\n-                goto out;\\n-            }\\n-            if (newsp != sp) {\\n-                /* NB: Discontinuity between argv and vars. */\\n-                sp = frame.vars = newsp;\\n-            }\\n-        }\\n-\\n-        /* Push void to initialize local variables. */\\n-        do {\\n-            PUSH(JSVAL_VOID);\\n-        } while (--nvars != 0);\\n-    }\\n-    JS_ASSERT(nvars == 0);\\n-\\n     /* Store the current sp in frame before calling fun. */\\n     SAVE_SP(&frame);\\n \\n@@ -1335,23 +1336,20 @@ have_fun:\\n #endif\\n \\n         /* If native, use caller varobj and scopeChain for eval. */\\n-        frame.varobj = fp->varobj;\\n-        frame.scopeChain = fp->scopeChain;\\n+        if (cx->fp) {\\n+            frame.varobj = cx->fp->varobj;\\n+            frame.scopeChain = cx->fp->scopeChain;\\n+        } else {\\n+            frame.varobj = NULL;\\n+            frame.scopeChain = NULL;\\n+        }\\n \\n         /* But ensure that we have a scope chain. */\\n         if (!frame.scopeChain)\\n             frame.scopeChain = parent;\\n \\n-        if (fun && (fun->flags & JSFUN_FAST_NATIVE)) {\\n-            /*\\n-             * Note the lack of START/END_FAST_CALL bracketing here. Unlike\\n-             * the other JSFastNative call (see the JSOP_CALL special case in\\n-             * js_Interpret), we have a full stack frame for this call.\\n-             */\\n-            ok = ((JSFastNative) native)(cx, argc, frame.argv - 2);\\n-            frame.rval = frame.argv[-2];\\n-        } else {\\n #ifdef DEBUG_brendan\\n+        {\\n             static FILE *fp;\\n             if (!fp) {\\n                 fp = fopen(\\\"/tmp/slow-natives.dump\\\", \\\"w\\\");\\n@@ -1374,9 +1372,9 @@ have_fun:\\n                         ? JS_GetFunctionName(fun)\\n                         : \\\"???\\\");\\n             }\\n-#endif\\n-            ok = native(cx, frame.thisp, argc, frame.argv, &frame.rval);\\n         }\\n+#endif\\n+        ok = native(cx, frame.thisp, argc, frame.argv, &frame.rval);\\n \\n         JS_RUNTIME_METER(cx->runtime, nativeCalls);\\n #ifdef DEBUG_NOT_THROWING\\n@@ -1418,24 +1416,16 @@ out:\\n     if (frame.argsobj)\\n         ok &= js_PutArgsObject(cx, &frame);\\n \\n+    *vp = frame.rval;\\n+\\n     /* Restore cx->fp now that we're done releasing frame objects. */\\n-    cx->fp = fp;\\n+    cx->fp = frame.down;\\n \\n out2:\\n     /* Pop everything we may have allocated off the stack. */\\n     JS_ARENA_RELEASE(&cx->stackPool, mark);\\n-\\n-    /* Store the return value and restore sp just above it. */\\n-    *vp = frame.rval;\\n-    fp->sp = vp + 1;\\n-\\n-    /*\\n-     * Store the location of the JSOP_CALL or JSOP_EVAL that generated the\\n-     * return value, but only if this is an external (compiled from script\\n-     * source) call that has stack budget for the generating pc.\\n-     */\\n-    if (fp->script && !(flags & JSINVOKE_INTERNAL))\\n-        vp[-(intN)fp->script->depth] = (jsval)fp->pc;\\n+    if (!ok)\\n+        *vp = JSVAL_NULL;\\n     return ok;\\n \\n bad:\\n@@ -1448,33 +1438,20 @@ JSBool\\n js_InternalInvoke(JSContext *cx, JSObject *obj, jsval fval, uintN flags,\\n                   uintN argc, jsval *argv, jsval *rval)\\n {\\n-    JSStackFrame *fp, *oldfp, frame;\\n-    jsval *oldsp, *sp;\\n+    jsval *invokevp;\\n     void *mark;\\n-    uintN i;\\n     JSBool ok;\\n \\n-    fp = oldfp = cx->fp;\\n-    if (!fp) {\\n-        memset(&frame, 0, sizeof frame);\\n-        cx->fp = fp = &frame;\\n-    }\\n-    oldsp = fp->sp;\\n-    sp = js_AllocStack(cx, 2 + argc, &mark);\\n-    if (!sp) {\\n-        ok = JS_FALSE;\\n-        goto out;\\n-    }\\n+    invokevp = js_AllocStack(cx, 2 + argc, &mark);\\n+    if (!invokevp)\\n+        return JS_FALSE;\\n \\n-    PUSH(fval);\\n-    PUSH(OBJECT_TO_JSVAL(obj));\\n-    for (i = 0; i < argc; i++)\\n-        PUSH(argv[i]);\\n-    SAVE_SP(fp);\\n-    ok = js_Invoke(cx, argc, flags | JSINVOKE_INTERNAL);\\n-    if (ok) {\\n-        RESTORE_SP(fp);\\n+    invokevp[0] = fval;\\n+    invokevp[1] = OBJECT_TO_JSVAL(obj);\\n+    memcpy(invokevp + 2, argv, argc * sizeof *argv);\\n \\n+    ok = js_Invoke(cx, argc, invokevp, flags | JSINVOKE_INTERNAL);\\n+    if (ok) {\\n         /*\\n          * Store *rval in the a scoped local root if a scope is open, else in\\n          * the lastInternalResult pigeon-hole GC root, solely so users of\\n@@ -1482,7 +1459,7 @@ js_InternalInvoke(JSContext *cx, JSObject *obj, jsval fval, uintN flags,\\n          * example) callers do not need to manage roots for local, temporary\\n          * references to such results.\\n          */\\n-        *rval = POP_OPND();\\n+        *rval = *invokevp;\\n         if (JSVAL_IS_GCTHING(*rval) && *rval != JSVAL_NULL) {\\n             if (cx->localRootStack) {\\n                 if (js_PushLocalRoot(cx, cx->localRootStack, *rval) < 0)\\n@@ -1494,11 +1471,6 @@ js_InternalInvoke(JSContext *cx, JSObject *obj, jsval fval, uintN flags,\\n     }\\n \\n     js_FreeStack(cx, mark);\\n-out:\\n-    fp->sp = oldsp;\\n-    if (oldfp != fp)\\n-        cx->fp = oldfp;\\n-\\n     return ok;\\n }\\n \\n@@ -1956,7 +1928,7 @@ js_InvokeConstructor(JSContext *cx, jsval *vp, uintN argc)\\n \\n     /* Now we have an object with a constructor method; call it. */\\n     vp[1] = OBJECT_TO_JSVAL(obj);\\n-    if (!js_Invoke(cx, argc, JSINVOKE_CONSTRUCT)) {\\n+    if (!js_Invoke(cx, argc, vp, JSINVOKE_CONSTRUCT)) {\\n         cx->weakRoots.newborn[GCX_OBJECT] = NULL;\\n         return JS_FALSE;\\n     }\\n@@ -3516,7 +3488,8 @@ interrupt:\\n             ok = js_InvokeConstructor(cx, vp, argc);\\n             if (!ok)\\n                 goto out;\\n-            RESTORE_SP(fp);\\n+            sp = vp + 1;\\n+            vp[-depth] = (jsval)pc;\\n             LOAD_INTERRUPT_HANDLER(cx);\\n             obj = JSVAL_TO_OBJECT(*vp);\\n             len = js_CodeSpec[op].length;\\n@@ -4088,7 +4061,12 @@ interrupt:\\n                         if (sp + nargs > fp->spbase + depth)\\n                             goto do_invoke;\\n                         do {\\n-                            PUSH(JSVAL_VOID);\\n+                            /*\\n+                             * Use PUSH_OPND to set the proper pc values for\\n+                             * the extra arguments. The decompiler relies on\\n+                             * this.\\n+                             */\\n+                            PUSH_OPND(JSVAL_VOID);\\n                         } while (--nargs != 0);\\n                         SAVE_SP(fp);\\n                     }\\n@@ -4096,9 +4074,7 @@ interrupt:\\n                     JS_ASSERT(!JSVAL_IS_PRIMITIVE(vp[1]) ||\\n                               PRIMITIVE_THIS_TEST(fun, vp[1]));\\n \\n-                    START_FAST_CALL(fp);\\n                     ok = ((JSFastNative) fun->u.n.native)(cx, argc, vp);\\n-                    END_FAST_CALL(fp);\\n                     if (!ok)\\n                         goto out;\\n                     sp = vp + 1;\\n@@ -4108,8 +4084,9 @@ interrupt:\\n             }\\n \\n           do_invoke:\\n-            ok = js_Invoke(cx, argc, 0);\\n-            RESTORE_SP(fp);\\n+            ok = js_Invoke(cx, argc, vp, 0);\\n+            sp = vp + 1;\\n+            vp[-depth] = (jsval)pc;\\n             LOAD_INTERRUPT_HANDLER(cx);\\n             if (!ok)\\n                 goto out;\\n@@ -4146,8 +4123,10 @@ interrupt:\\n           BEGIN_CASE(JSOP_SETCALL)\\n             argc = GET_ARGC(pc);\\n             SAVE_SP_AND_PC(fp);\\n-            ok = js_Invoke(cx, argc, 0);\\n-            RESTORE_SP(fp);\\n+            vp = sp - argc - 2;\\n+            ok = js_Invoke(cx, argc, vp, 0);\\n+            sp = vp + 1;\\n+            vp[-depth] = (jsval)pc;\\n             LOAD_INTERRUPT_HANDLER(cx);\\n             if (!ok)\\n                 goto out;\\ndiff --git a/js/src/jsinterp.h b/js/src/jsinterp.h\\nindex 65dd998..073d6da 100644\\n--- a/js/src/jsinterp.h\\n+++ b/js/src/jsinterp.h\\n@@ -95,24 +95,21 @@ typedef struct JSInlineFrame {\\n /* JS stack frame flags. */\\n #define JSFRAME_CONSTRUCTING  0x01  /* frame is for a constructor invocation */\\n #define JSFRAME_INTERNAL      0x02  /* internal call, not invoked by a script */\\n-#define JSFRAME_SKIP_CALLER   0x04  /* skip one link when evaluating f.caller\\n-                                       for this invocation of f */\\n-#define JSFRAME_ASSIGNING     0x08  /* a complex (not simplex JOF_ASSIGNING) op\\n+#define JSFRAME_ASSIGNING     0x04  /* a complex (not simplex JOF_ASSIGNING) op\\n                                        is currently assigning to a property */\\n-#define JSFRAME_DEBUGGER      0x10  /* frame for JS_EvaluateInStackFrame */\\n-#define JSFRAME_EVAL          0x20  /* frame for obj_eval */\\n-#define JSFRAME_SPECIAL       0x30  /* special evaluation frame flags */\\n-#define JSFRAME_COMPILING     0x40  /* frame is being used by compiler */\\n-#define JSFRAME_COMPILE_N_GO  0x80  /* compiler-and-go mode, can optimize name\\n+#define JSFRAME_DEBUGGER      0x08  /* frame for JS_EvaluateInStackFrame */\\n+#define JSFRAME_EVAL          0x10  /* frame for obj_eval */\\n+#define JSFRAME_SPECIAL       0x18  /* special evaluation frame flags */\\n+#define JSFRAME_COMPILING     0x20  /* frame is being used by compiler */\\n+#define JSFRAME_COMPILE_N_GO  0x40  /* compiler-and-go mode, can optimize name\\n                                        references based on scope chain */\\n-#define JSFRAME_SCRIPT_OBJECT 0x100 /* compiling source for a Script object */\\n-#define JSFRAME_YIELDING      0x200 /* js_Interpret dispatched JSOP_YIELD */\\n-#define JSFRAME_FILTERING     0x400 /* XML filtering predicate expression */\\n-#define JSFRAME_ITERATOR      0x800 /* trying to get an iterator for for-in */\\n-#define JSFRAME_POP_BLOCKS   0x1000 /* scope chain contains blocks to pop */\\n-#define JSFRAME_GENERATOR    0x2000 /* frame belongs to generator-iterator */\\n-#define JSFRAME_IN_FAST_CALL 0x4000 /* calling frame is calling a fast native */\\n-#define JSFRAME_DID_SET_RVAL 0x8000 /* fast native used JS_SET_RVAL(cx, vp) */\\n+#define JSFRAME_SCRIPT_OBJECT 0x80  /* compiling source for a Script object */\\n+#define JSFRAME_YIELDING      0x100 /* js_Interpret dispatched JSOP_YIELD */\\n+#define JSFRAME_FILTERING     0x200 /* XML filtering predicate expression */\\n+#define JSFRAME_ITERATOR      0x400 /* trying to get an iterator for for-in */\\n+#define JSFRAME_POP_BLOCKS    0x800 /* scope chain contains blocks to pop */\\n+#define JSFRAME_GENERATOR    0x1000 /* frame belongs to generator-iterator */\\n+#define JSFRAME_ROOTED_ARGV  0x2000 /* frame.argv is rooted by the caller */\\n \\n #define JSFRAME_OVERRIDE_SHIFT 24   /* override bit-set params; see jsfun.c */\\n #define JSFRAME_OVERRIDE_BITS  8\\n@@ -178,11 +175,15 @@ js_ComputeThis(JSContext *cx, jsval *argv);\\n \\n /*\\n  * NB: js_Invoke requires that cx is currently running JS (i.e., that cx->fp\\n- * is non-null), and that the callee, |this| parameter, and actual arguments\\n- * are already pushed on the stack under cx->fp->sp.\\n+ * is non-null), and that vp points to the callee, |this| parameter, and\\n+ * actual arguments of the call. [vp .. vp + 2 + argc) must belong to the last\\n+ * JS stack segment that js_AllocStack or js_AllocRawStack allocated. The\\n+ * function may use the space available after vp + 2 + argc in the stack\\n+ * segment for temporaries so the caller should not use that space for values\\n+ * that must be preserved across the call.\\n  */\\n extern JS_FRIEND_API(JSBool)\\n-js_Invoke(JSContext *cx, uintN argc, uintN flags);\\n+js_Invoke(JSContext *cx, uintN argc, jsval *vp, uintN flags);\\n \\n /*\\n  * Consolidated js_Invoke flags simply rename certain JSFRAME_* flags, so that\\n@@ -199,7 +200,6 @@ js_Invoke(JSContext *cx, uintN argc, uintN flags);\\n  */\\n #define JSINVOKE_CONSTRUCT      JSFRAME_CONSTRUCTING\\n #define JSINVOKE_INTERNAL       JSFRAME_INTERNAL\\n-#define JSINVOKE_SKIP_CALLER    JSFRAME_SKIP_CALLER\\n #define JSINVOKE_ITERATOR       JSFRAME_ITERATOR\\n \\n /*\\ndiff --git a/js/src/jsiter.c b/js/src/jsiter.c\\nindex 8fe22ed..54dcfa9 100644\\n--- a/js/src/jsiter.c\\n+++ b/js/src/jsiter.c\\n@@ -802,7 +802,7 @@ js_NewGenerator(JSContext *cx, JSStackFrame *fp)\\n     /* Copy remaining state (XXX sharp* and xml* should be local vars). */\\n     gen->frame.sharpDepth = 0;\\n     gen->frame.sharpArray = NULL;\\n-    gen->frame.flags = fp->flags | JSFRAME_GENERATOR;\\n+    gen->frame.flags = (fp->flags & ~JSFRAME_ROOTED_ARGV) | JSFRAME_GENERATOR;\\n     gen->frame.dormantNext = NULL;\\n     gen->frame.xmlNamespace = NULL;\\n     gen->frame.blockChain = NULL;\\ndiff --git a/js/src/jsstr.c b/js/src/jsstr.c\\nindex 9340390..b29ef44 100644\\n--- a/js/src/jsstr.c\\n+++ b/js/src/jsstr.c\\n@@ -1391,9 +1391,8 @@ find_replen(JSContext *cx, ReplaceData *rdata, size_t *sizep)\\n     lambda = rdata->lambda;\\n     if (lambda) {\\n         uintN argc, i, j, m, n, p;\\n-        jsval *sp, *oldsp, rval;\\n+        jsval *invokevp, *sp;\\n         void *mark;\\n-        JSStackFrame *fp;\\n         JSBool ok;\\n \\n         /*\\n@@ -1415,11 +1414,12 @@ find_replen(JSContext *cx, ReplaceData *rdata, size_t *sizep)\\n          */\\n         p = rdata->base.regexp->parenCount;\\n         argc = 1 + p + 2;\\n-        sp = js_AllocStack(cx, 2 + argc, &mark);\\n-        if (!sp)\\n+        invokevp = js_AllocStack(cx, 2 + argc, &mark);\\n+        if (!invokevp)\\n             return JS_FALSE;\\n \\n         /* Push lambda and its 'this' parameter. */\\n+        sp = invokevp;\\n         *sp++ = OBJECT_TO_JSVAL(lambda);\\n         *sp++ = OBJECT_TO_JSVAL(OBJ_GET_PARENT(cx, lambda));\\n \\n@@ -1463,21 +1463,14 @@ find_replen(JSContext *cx, ReplaceData *rdata, size_t *sizep)\\n         *sp++ = INT_TO_JSVAL((jsint)cx->regExpStatics.leftContext.length);\\n         *sp++ = STRING_TO_JSVAL(rdata->base.str);\\n \\n-        /* Lift current frame to include the args and do the call. */\\n-        fp = cx->fp;\\n-        oldsp = fp->sp;\\n-        fp->sp = sp;\\n-        ok = js_Invoke(cx, argc, JSINVOKE_INTERNAL);\\n-        rval = fp->sp[-1];\\n-        fp->sp = oldsp;\\n-\\n+        ok = js_Invoke(cx, argc, invokevp, JSINVOKE_INTERNAL);\\n         if (ok) {\\n             /*\\n              * NB: we count on the newborn string root to hold any string\\n              * created by this js_ValueToString that would otherwise be GC-\\n              * able, until we use rdata->repstr in do_replace.\\n              */\\n-            repstr = js_ValueToString(cx, rval);\\n+            repstr = js_ValueToString(cx, *invokevp);\\n             if (!repstr) {\\n                 ok = JS_FALSE;\\n             } else {\\ndiff --git a/js/src/xpconnect/src/xpcwrappedjsclass.cpp b/js/src/xpconnect/src/xpcwrappedjsclass.cpp\\nindex 2bc6080..faacc2b 100644\\n--- a/js/src/xpconnect/src/xpcwrappedjsclass.cpp\\n+++ b/js/src/xpconnect/src/xpcwrappedjsclass.cpp\\n@@ -1022,7 +1022,7 @@ nsXPCWrappedJSClass::CallMethod(nsXPCWrappedJS* wrapper, uint16 methodIndex,\\n                                 const XPTMethodDescriptor* info,\\n                                 nsXPTCMiniVariant* nativeParams)\\n {\\n-    jsval* stackbase;\\n+    jsval* stackbase = nsnull;\\n     jsval* sp = nsnull;\\n     uint8 i;\\n     uint8 argc=0;\\n@@ -1440,26 +1440,8 @@ pre_call_clean_up:\\n     {\\n         if(!JSVAL_IS_PRIMITIVE(fval))\\n         {\\n-            // Lift current frame (or make new one) to include the args\\n-            // and do the call.\\n-            JSStackFrame *fp, *oldfp, frame;\\n-            jsval *oldsp;\\n-\\n-            fp = oldfp = cx->fp;\\n-            if(!fp)\\n-            {\\n-                memset(&frame, 0, sizeof frame);\\n-                cx->fp = fp = &frame;\\n-            }\\n-            oldsp = fp->sp;\\n-            fp->sp = sp;\\n-\\n-            success = js_Invoke(cx, argc, JSINVOKE_INTERNAL);\\n-\\n-            result = fp->sp[-1];\\n-            fp->sp = oldsp;\\n-            if(oldfp != fp)\\n-                cx->fp = oldfp;\\n+            success = js_Invoke(cx, argc, stackbase, JSINVOKE_INTERNAL);\\n+            result = *stackbase;\\n         }\\n         else\\n         {\\n\""}