{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas672757f\""},"diff":"\"672757f Bug 385891: Removal of non-Cairo code from nsFrame.cpp and nsObjectFrame.cpp, p=alfredkayser, r/sr/a=dbaron\\ndiff --git a/layout/base/Makefile.in b/layout/base/Makefile.in\\nindex d8d9174..5f2a0a2 100644\\n--- a/layout/base/Makefile.in\\n+++ b/layout/base/Makefile.in\\n@@ -79,22 +79,15 @@ REQUIRES\\t= xpcom \\\\\\n \\t\\t  accessibility \\\\\\n \\t\\t  shistory \\\\\\n \\t\\t  caps \\\\\\n+\\t\\t  thebes \\\\\\n+\\t\\t  cairo \\\\\\n \\t\\t  $(NULL)\\n \\n-ifdef MOZ_ENABLE_CAIRO_GFX\\n-REQUIRES += thebes cairo\\n-endif\\n \\n XPIDLSRCS\\t= \\\\\\n \\t\\tnsIStyleSheetService.idl\\t\\\\\\n \\t\\t$(NULL)\\n \\n-ifndef MOZ_ENABLE_CAIRO_GFX\\n-XPIDLSRCS\\t+= \\\\\\n-\\t\\tnsISelectionImageService.idl\\t\\\\\\n-\\t\\t$(NULL)\\n-endif\\n-\\n EXPORTS\\t\\t= \\\\\\n \\t\\tnsBidi.h \\\\\\n \\t\\tnsBidiPresUtils.h \\\\\\n@@ -183,8 +176,6 @@ LOCAL_INCLUDES += \\\\\\n         -I$(srcdir)/../svg/base/src\\n endif\\n \\n-ifdef MOZ_ENABLE_CAIRO_GFX\\n CXXFLAGS += $(MOZ_CAIRO_CFLAGS)\\n-endif\\n \\n DEFINES += -D_IMPL_NS_LAYOUT\\ndiff --git a/layout/base/nsISelectionImageService.idl b/layout/base/nsISelectionImageService.idl\\ndeleted file mode 100644\\nindex cc60370..0000000\\n--- a/layout/base/nsISelectionImageService.idl\\n+++ /dev/null\\n@@ -1,61 +0,0 @@\\n-/* -*- Mode: IDL; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-\\n- *\\n- * ***** BEGIN LICENSE BLOCK *****\\n- * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n- *\\n- * The contents of this file are subject to the Mozilla Public License Version\\n- * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n- * the License. You may obtain a copy of the License at\\n- * http://www.mozilla.org/MPL/\\n- *\\n- * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n- * for the specific language governing rights and limitations under the\\n- * License.\\n- *\\n- * The Original Code is the Mozilla browser.\\n- *\\n- * The Initial Developer of the Original Code is\\n- * Netscape Communications, Inc.\\n- * Portions created by the Initial Developer are Copyright (C) 1999\\n- * the Initial Developer. All Rights Reserved.\\n- *\\n- * Contributor(s):\\n- *\\n- * Alternatively, the contents of this file may be used under the terms of\\n- * either of the GNU General Public License Version 2 or later (the \\\"GPL\\\"),\\n- * or the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n- * in which case the provisions of the GPL or the LGPL are applicable instead\\n- * of those above. If you wish to allow use of your version of this file only\\n- * under the terms of either the GPL or the LGPL, and not to allow others to\\n- * use your version of this file under the terms of the MPL, indicate your\\n- * decision by deleting the provisions above and replace them with the notice\\n- * and other provisions required by the GPL or the LGPL. If you do not delete\\n- * the provisions above, a recipient may use your version of this file under\\n- * the terms of any one of the MPL, the GPL or the LGPL.\\n- *\\n- * ***** END LICENSE BLOCK ***** */\\n-\\n-#include \\\"nsISupports.idl\\\"\\n-\\n-%{ C++\\n-class imgIContainer;\\n-%}\\n-\\n-[ptr] native imgIContainer(imgIContainer);\\n-\\n-\\n-[uuid(f6f68e3c-f078-4235-bf71-53d180c37d26)]\\n-interface nsISelectionImageService : nsISupports\\n-{\\n-\\t/**\\n-\\t* the current image is marked as invalid\\n-\\t*/\\n-\\tvoid reset();\\n-\\n-\\t/**\\n-\\t* retrieve the image for alpha blending\\n-\\t*/\\n-\\tvoid getImage(in short selectionValue, out imgIContainer container);\\n-\\n-};\\ndiff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp\\nindex 71b0042..bde693e 100644\\n--- a/layout/base/nsPresContext.cpp\\n+++ b/layout/base/nsPresContext.cpp\\n@@ -92,9 +92,7 @@\\n \\n //needed for resetting of image service color\\n #include \\\"nsLayoutCID.h\\\"\\n-#ifndef MOZ_CAIRO_GFX\\n-#include \\\"nsISelectionImageService.h\\\"\\n-#endif\\n+\\n static nscolor\\n MakeColorPref(const char *colstr)\\n {\\n@@ -155,7 +153,6 @@ destroy_loads(const void * aKey, nsCOMPtr<nsImageLoader>& aData, void* closure)\\n \\n static NS_DEFINE_CID(kLookAndFeelCID,  NS_LOOKANDFEEL_CID);\\n #include \\\"nsContentCID.h\\\"\\n-static NS_DEFINE_CID(kSelectionImageService, NS_SELECTIONIMAGESERVICE_CID);\\n \\n   // NOTE! nsPresContext::operator new() zeroes out all members, so don't\\n   // bother initializing members to 0.\\n@@ -1390,18 +1387,6 @@ nsPresContext::SysColorChangedInternal()\\n   // they may be using system colors\\n   GetDocumentColorPreferences();\\n \\n-#ifndef MOZ_CAIRO_GFX\\n-  // Clear out all of the style data since it may contain RGB values\\n-  // which originated from system colors.\\n-  nsCOMPtr<nsISelectionImageService> imageService;\\n-  nsresult result;\\n-  imageService = do_GetService(kSelectionImageService, &result);\\n-  if (NS_SUCCEEDED(result) && imageService)\\n-  {\\n-    imageService->Reset();\\n-  }\\n-#endif\\n-\\n   // We need to do a full reflow (and view update) here. Clearing the style\\n   // data without reflowing/updating views will lead to incorrect change hints\\n   // later, because when generating change hints, any style structs which have\\ndiff --git a/layout/build/nsLayoutCID.h b/layout/build/nsLayoutCID.h\\nindex 3877543..4c7f58b 100644\\n--- a/layout/build/nsLayoutCID.h\\n+++ b/layout/build/nsLayoutCID.h\\n@@ -198,10 +198,6 @@\\n #define NS_LAYOUT_HISTORY_STATE_CID \\\\\\n { 0x5c5af390, 0x34be, 0x11d5, { 0xa0, 0x3b, 0x00, 0x10, 0xa4, 0xef, 0x48, 0xc9 } }\\n \\n-// {9d1001b1-e59a-456b-99dc-cc3f1283236e}\\n-#define NS_SELECTIONIMAGESERVICE_CID \\\\\\n-{ 0x9d1001b1, 0xe59a, 0x456b, { 0x99, 0xdc, 0xcc, 0x3f, 0x12, 0x83, 0x23, 0x6e } }\\n-\\n // {E14B66F6-BFC5-11d2-B57E-00105AA83B2F}\\n #define NS_CARET_CID \\\\\\n { 0xe14b66f6, 0xbfc5, 0x11d2, { 0xb5, 0x7e, 0x0, 0x10, 0x5a, 0xa8, 0x3b, 0x2f } }\\ndiff --git a/layout/build/nsLayoutModule.cpp b/layout/build/nsLayoutModule.cpp\\nindex cc9ec9a..f31a166 100644\\n--- a/layout/build/nsLayoutModule.cpp\\n+++ b/layout/build/nsLayoutModule.cpp\\n@@ -96,9 +96,6 @@\\n #include \\\"nsSyncLoadService.h\\\"\\n #include \\\"nsBox.h\\\"\\n #include \\\"nsIFrameTraversal.h\\\"\\n-#ifndef MOZ_CAIRO_GFX\\n-#include \\\"nsISelectionImageService.h\\\"\\n-#endif\\n #include \\\"nsLayoutCID.h\\\"\\n #include \\\"nsILanguageAtomService.h\\\"\\n #include \\\"nsStyleSheetService.h\\\"\\n@@ -398,10 +395,6 @@ nsresult NS_NewCanvasRenderingContext2D(nsIDOMCanvasRenderingContext2D** aResult\\n \\n nsresult NS_CreateFrameTraversal(nsIFrameTraversal** aResult);\\n \\n-#ifndef MOZ_CAIRO_GFX\\n-nsresult NS_NewSelectionImageService(nsISelectionImageService** aResult);\\n-#endif\\n-\\n nsresult NS_NewSelection(nsFrameSelection** aResult);\\n nsresult NS_NewDomSelection(nsISelection** aResult);\\n nsresult NS_NewDocumentViewer(nsIDocumentViewer** aResult);\\n@@ -464,11 +457,7 @@ NS_GENERIC_FACTORY_CONSTRUCTOR(inCSSValueSearch)\\n NS_GENERIC_FACTORY_CONSTRUCTOR(inDOMUtils)\\n #endif\\n \\n-#ifndef MOZ_CAIRO_GFX\\n-MAKE_CTOR(CreateSelectionImageService,  nsISelectionImageService,NS_NewSelectionImageService)\\n-#endif\\n-MAKE_CTOR(CreateCaret,                  nsICaret,               NS_NewCaret)\\n-\\n+MAKE_CTOR(CreateCaret,                    nsICaret,                    NS_NewCaret)\\n MAKE_CTOR(CreateNameSpaceManager,         nsINameSpaceManager,         NS_GetNameSpaceManager)\\n MAKE_CTOR(CreateEventListenerManager,     nsIEventListenerManager,     NS_NewEventListenerManager)\\n MAKE_CTOR(CreateDOMEventGroup,            nsIDOMEventGroup,            NS_NewDOMEventGroup)\\n@@ -485,7 +474,7 @@ MAKE_CTOR(CreateImageDocument,            nsIDocument,                 NS_NewIma\\n MAKE_CTOR(CreateCSSParser,                nsICSSParser,                NS_NewCSSParser)\\n MAKE_CTOR(CreateCSSLoader,                nsICSSLoader,                NS_NewCSSLoader)\\n MAKE_CTOR(CreateDOMSelection,             nsISelection,                NS_NewDomSelection)\\n-MAKE_CTOR(CreateSelection,                nsFrameSelection,                 NS_NewSelection)\\n+MAKE_CTOR(CreateSelection,                nsFrameSelection,            NS_NewSelection)\\n MAKE_CTOR(CreateRange,                    nsIDOMRange,                 NS_NewRange)\\n MAKE_CTOR(CreateRangeUtils,               nsIRangeUtils,               NS_NewRangeUtils)\\n MAKE_CTOR(CreateContentIterator,          nsIContentIterator,          NS_NewContentIterator)\\n@@ -804,13 +793,6 @@ static const nsModuleComponentInfo gComponents[] = {\\n     nsnull,\\n     CreateNewFrameTraversal },\\n \\n-#ifndef MOZ_CAIRO_GFX\\n-  { \\\"selection image storage\\\",\\n-    NS_SELECTIONIMAGESERVICE_CID,\\n-    nsnull,\\n-    CreateSelectionImageService },\\n-#endif\\n-\\n   { \\\"caret\\\",\\n     NS_CARET_CID,\\n     \\\"@mozilla.org/layout/caret;1\\\",\\ndiff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp\\nindex a788b21..60691d14 100644\\n--- a/layout/generic/nsFrame.cpp\\n+++ b/layout/generic/nsFrame.cpp\\n@@ -106,9 +106,6 @@\\n \\n // For triple-click pref\\n #include \\\"nsIServiceManager.h\\\"\\n-#ifndef MOZ_CAIRO_GFX\\n-#include \\\"nsISelectionImageService.h\\\"\\n-#endif\\n #include \\\"imgIContainer.h\\\"\\n #include \\\"imgIRequest.h\\\"\\n #include \\\"gfxIImageFrame.h\\\"\\n@@ -123,11 +120,8 @@\\n #include \\\"nsBlockFrame.h\\\"\\n #include \\\"nsDisplayList.h\\\"\\n \\n-#ifdef MOZ_CAIRO_GFX\\n #include \\\"gfxContext.h\\\"\\n-#endif\\n \\n-static NS_DEFINE_CID(kSelectionImageService, NS_SELECTIONIMAGESERVICE_CID);\\n static NS_DEFINE_CID(kLookAndFeelCID,  NS_LOOKANDFEEL_CID);\\n static NS_DEFINE_CID(kWidgetCID, NS_CHILD_CID);\\n \\n@@ -285,153 +279,6 @@ nsIFrameDebug::RootFrameList(nsPresContext* aPresContext, FILE* out, PRInt32 aIn\\n #endif\\n // end nsIFrameDebug\\n \\n-#ifndef MOZ_CAIRO_GFX\\n-// frame image selection drawing service implementation\\n-class SelectionImageService : public nsISelectionImageService\\n-{\\n-public:\\n-  SelectionImageService();\\n-  virtual ~SelectionImageService();\\n-  NS_DECL_ISUPPORTS\\n-  NS_DECL_NSISELECTIONIMAGESERVICE\\n-private:\\n-  nsresult CreateImage(nscolor aImageColor, imgIContainer *aContainer);\\n-  nsCOMPtr<imgIContainer> mContainer;\\n-  nsCOMPtr<imgIContainer> mDisabledContainer;\\n-};\\n-\\n-NS_IMPL_ISUPPORTS1(SelectionImageService, nsISelectionImageService)\\n-\\n-SelectionImageService::SelectionImageService()\\n-{\\n-}\\n-\\n-SelectionImageService::~SelectionImageService()\\n-{\\n-}\\n-\\n-NS_IMETHODIMP\\n-SelectionImageService::GetImage(PRInt16 aSelectionValue, imgIContainer **aContainer)\\n-{\\n-  *aContainer = nsnull;\\n-\\n-  nsCOMPtr<imgIContainer>* container = &mContainer;\\n-  nsILookAndFeel::nsColorID colorID;\\n-  if (aSelectionValue == nsISelectionController::SELECTION_ON) {\\n-    colorID = nsILookAndFeel::eColor_TextSelectBackground;\\n-  } else if (aSelectionValue == nsISelectionController::SELECTION_ATTENTION) {\\n-    colorID = nsILookAndFeel::eColor_TextSelectBackgroundAttention;\\n-  } else {\\n-    container = &mDisabledContainer;\\n-    colorID = nsILookAndFeel::eColor_TextSelectBackgroundDisabled;\\n-  }\\n-\\n-  if (!*container) {\\n-    nsresult result;\\n-    *container = do_CreateInstance(\\\"@mozilla.org/image/container;1\\\", &result);\\n-    if (NS_FAILED(result))\\n-      return result;\\n-\\n-    nscolor color = NS_RGB(255, 255, 255);\\n-    nsCOMPtr<nsILookAndFeel> look = do_GetService(kLookAndFeelCID);\\n-    if (look)\\n-      look->GetColor(colorID, color);\\n-    CreateImage(color, *container);\\n-  }\\n-\\n-  *aContainer = *container; \\n-  NS_ADDREF(*aContainer);\\n-  return NS_OK;\\n-}\\n-\\n-NS_IMETHODIMP\\n-SelectionImageService::Reset()\\n-{\\n-  mContainer = 0;\\n-  mDisabledContainer = 0;\\n-  return NS_OK;\\n-}\\n-\\n-#define SEL_IMAGE_WIDTH 32\\n-#define SEL_IMAGE_HEIGHT 32\\n-#define SEL_ALPHA_AMOUNT 128\\n-\\n-nsresult\\n-SelectionImageService::CreateImage(nscolor aImageColor, imgIContainer *aContainer)\\n-{\\n-  if (aContainer)\\n-  {\\n-    nsresult result = aContainer->Init(SEL_IMAGE_WIDTH,SEL_IMAGE_HEIGHT,nsnull);\\n-    if (NS_SUCCEEDED(result))\\n-    {\\n-      nsCOMPtr<gfxIImageFrame> image = do_CreateInstance(\\\"@mozilla.org/gfx/image/frame;2\\\",&result);\\n-      if (NS_SUCCEEDED(result) && image)\\n-      {\\n-        image->Init(0, 0, SEL_IMAGE_WIDTH, SEL_IMAGE_HEIGHT, gfxIFormats::RGB_A8, 24);\\n-        aContainer->AppendFrame(image);\\n-\\n-        PRUint32 bpr, abpr;\\n-        image->GetImageBytesPerRow(&bpr);\\n-        image->GetAlphaBytesPerRow(&abpr);\\n-\\n-        //it's better to temporarily go after heap than put big data on stack\\n-        unsigned char *row_data = (unsigned char *)malloc(bpr);\\n-        if (!row_data)\\n-          return NS_ERROR_OUT_OF_MEMORY;\\n-        unsigned char *alpha = (unsigned char *)malloc(abpr);\\n-        if (!alpha)\\n-        {\\n-          free (row_data);\\n-          return NS_ERROR_OUT_OF_MEMORY;\\n-        }\\n-        unsigned char *data = row_data;\\n-\\n-        PRInt16 i;\\n-        for (i = 0; i < SEL_IMAGE_WIDTH; i++)\\n-        {\\n-#if defined(XP_WIN) || defined(XP_OS2)\\n-          *data++ = NS_GET_B(aImageColor);\\n-          *data++ = NS_GET_G(aImageColor);\\n-          *data++ = NS_GET_R(aImageColor);\\n-#else\\n-#if defined(XP_MAC) || defined(XP_MACOSX)\\n-          *data++ = 0;\\n-#endif\\n-          *data++ = NS_GET_R(aImageColor);\\n-          *data++ = NS_GET_G(aImageColor);\\n-          *data++ = NS_GET_B(aImageColor);\\n-#endif\\n-        }\\n-\\n-        memset((void *)alpha, SEL_ALPHA_AMOUNT, abpr);\\n-\\n-        for (i = 0; i < SEL_IMAGE_HEIGHT; i++)\\n-        {\\n-          image->SetAlphaData(alpha, abpr, i*abpr);\\n-          image->SetImageData(row_data,  bpr, i*bpr);\\n-        }\\n-        free(row_data);\\n-        free(alpha);\\n-        return NS_OK;\\n-      }\\n-    } \\n-  }\\n-  return NS_ERROR_FAILURE;\\n-}\\n-\\n-\\n-nsresult NS_NewSelectionImageService(nsISelectionImageService** aResult)\\n-{\\n-  *aResult = new SelectionImageService;\\n-  if (!*aResult)\\n-    return NS_ERROR_OUT_OF_MEMORY;\\n-  NS_ADDREF(*aResult);\\n-  return NS_OK;\\n-}\\n-#endif /* MOZ_CAIRO_GFX */\\n-\\n-//end selection service\\n-\\n void\\n nsWeakFrame::Init(nsIFrame* aFrame)\\n {\\n@@ -910,22 +757,6 @@ private:\\n void nsDisplaySelectionOverlay::Paint(nsDisplayListBuilder* aBuilder,\\n      nsIRenderingContext* aCtx, const nsRect& aDirtyRect)\\n {\\n-#ifndef MOZ_CAIRO_GFX\\n-  nsCOMPtr<nsISelectionImageService> imageService\\n-      = do_GetService(kSelectionImageService);\\n-  if (!imageService)\\n-    return;\\n-\\n-\\n-  nsCOMPtr<imgIContainer> container;\\n-  imageService->GetImage(mSelectionValue, getter_AddRefs(container));\\n-  if (!container)\\n-    return;\\n-  \\n-  nsRect rect(aBuilder->ToReferenceFrame(mFrame), mFrame->GetSize());\\n-  rect.IntersectRect(rect, aDirtyRect);\\n-  aCtx->DrawTile(container, 0, 0, &rect);\\n-#else\\n   nscolor color = NS_RGB(255, 255, 255);\\n   \\n   nsILookAndFeel::nsColorID colorID;\\n@@ -955,7 +786,6 @@ void nsDisplaySelectionOverlay::Paint(nsDisplayListBuilder* aBuilder,\\n   ctx->NewPath();\\n   ctx->Rectangle(gfxRect(rect.x, rect.y, rect.width, rect.height), PR_TRUE);\\n   ctx->Fill();\\n-#endif\\n }\\n \\n /********************************************************\\ndiff --git a/layout/generic/nsObjectFrame.cpp b/layout/generic/nsObjectFrame.cpp\\nindex 2e694ed..44062e3 100644\\n--- a/layout/generic/nsObjectFrame.cpp\\n+++ b/layout/generic/nsObjectFrame.cpp\\n@@ -124,9 +124,7 @@\\n \\n #include \\\"nsThreadUtils.h\\\"\\n \\n-#ifdef MOZ_CAIRO_GFX\\n #include \\\"gfxContext.h\\\"\\n-#endif\\n \\n // accessibility support\\n #ifdef ACCESSIBILITY\\n@@ -1228,8 +1226,6 @@ nsObjectFrame::PaintPlugin(nsIRenderingContext& aRenderingContext,\\n        * to tell the plugin where it is, we dispatch a NPWindow through\\n        * |HandleEvent| to tell the plugin when its window moved\\n        */\\n-\\n-#ifdef MOZ_CAIRO_GFX\\n       nsRefPtr<gfxContext> ctx = (gfxContext*)aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_THEBES_CONTEXT);\\n       gfxMatrix ctxMatrix = ctx->CurrentMatrix();\\n       if (ctxMatrix.HasNonTranslation()) {\\n@@ -1259,11 +1255,6 @@ nsObjectFrame::PaintPlugin(nsIRenderingContext& aRenderingContext,\\n       POINT origViewportOrigin;\\n       GetViewportOrgEx(hdc, &origViewportOrigin);\\n       SetViewportOrgEx(hdc, origViewportOrigin.x + (int) xoff, origViewportOrigin.y + (int) yoff, NULL);\\n-#else\\n-      nsTransform2D* rcTransform;\\n-      aRenderingContext.GetCurrentTransform(rcTransform);\\n-      rcTransform->GetTranslationCoord(&origin.x, &origin.y);\\n-#endif\\n \\n       if ((window->x != origin.x) || (window->y != origin.y)) {\\n         window->x = origin.x;\\n@@ -1322,11 +1313,8 @@ nsObjectFrame::PaintPlugin(nsIRenderingContext& aRenderingContext,\\n       // frame origin and plugin origin are not the same\\n       mInstanceOwner->Paint(aDirtyRect, hdc);\\n \\n-#ifdef MOZ_CAIRO_GFX\\n       RestoreDC(hdc, -1);\\n-\\n       surf->MarkDirty();\\n-#endif\\n     }\\n   }\\n #endif\\n\""}