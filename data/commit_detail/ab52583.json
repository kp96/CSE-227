{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basab52583\""},"diff":"\"ab52583 Fix problem with focused widget occasionally not allowing keyboard input. b=354768 r=josh sr=roc\\ndiff --git a/widget/src/cocoa/nsWindowMap.mm b/widget/src/cocoa/nsWindowMap.mm\\nindex bff19e3..e5e55eb 100644\\n--- a/widget/src/cocoa/nsWindowMap.mm\\n+++ b/widget/src/cocoa/nsWindowMap.mm\\n@@ -140,36 +140,79 @@\\n   [super dealloc];\\n }\\n \\n+// As best I can tell, if the notification's object has a corresponding\\n+// top-level widget (an nsCocoaWindow object), it has a delegate (set in\\n+// nsCocoaWindow::StandardCreate()) that responds to sendFocusEvent:, and\\n+// otherwise not (Camino doesn't use top-level widgets (nsCocoaWindow\\n+// objects) -- only child widgets (nsChildView objects)).\\n+//\\n+// If we're using top-level widgets, we need to send them both kinds of\\n+// focus event (NS_GOTFOCUS and NS_ACTIVATE, which by convention are sent in\\n+// that order) -- otherwise text input can (under unusual circumstances) stop\\n+// working in the currently focused child widget (see bmo bug 354768).\\n+//\\n+// When we send focus events to a top-level widget, they get propagated\\n+// (via nsWebShellWindow::HandleEvent(), indirectly) to a child widget (an\\n+// nsChildView object) -- so in principle we shouldn't have to send them to\\n+// child widgets here.  But I've found that, unless I also send at least an\\n+// NS_GOTFOCUS event directly to the currently focused child widget, it's\\n+// easy to get blinking I-bar cursors in multiple text input fields\\n+// (particularly if one of them is the Google search box).  On other platforms\\n+// (e.g. Windows and GTK2), NS_ACTIVATE events are only sent (directly) to\\n+// top-level widgets -- so we do the same here.  Not sending them directly\\n+// to child widgets also avoids \\\"win is null\\\" assertions on debug builds\\n+// (see bug 354768 comments 55 and 58).\\n - (void)windowBecameKey:(NSNotification*)inNotification\\n {\\n   NSWindow* window = (NSWindow*)[inNotification object];\\n-  id firstResponder = [window firstResponder];\\n-  if ([firstResponder isKindOfClass:[ChildView class]]) {\\n-    [firstResponder viewsWindowDidBecomeKey];\\n-  }\\n-  else {\\n-    id delegate = [window delegate];\\n-    if ([delegate respondsToSelector:@selector(sendFocusEvent:)]) {\\n-      [delegate sendFocusEvent:NS_GOTFOCUS];\\n-      [delegate sendFocusEvent:NS_ACTIVATE];\\n+  id delegate = [window delegate];\\n+  if (delegate && [delegate respondsToSelector:@selector(sendFocusEvent:)]) {\\n+    [delegate sendFocusEvent:NS_GOTFOCUS];\\n+    [delegate sendFocusEvent:NS_ACTIVATE];\\n+    id firstResponder = [window firstResponder];\\n+    if ([firstResponder isKindOfClass:[ChildView class]]) {\\n+      BOOL isMozWindow = [window respondsToSelector:@selector(setSuppressMakeKeyFront:)];\\n+      if (isMozWindow)\\n+        [window setSuppressMakeKeyFront:YES];\\n+      [firstResponder sendFocusEvent:NS_GOTFOCUS];\\n+      if (isMozWindow)\\n+        [window setSuppressMakeKeyFront:NO];\\n     }\\n+  } else {\\n+    id firstResponder = [window firstResponder];\\n+    if ([firstResponder isKindOfClass:[ChildView class]])\\n+      [firstResponder viewsWindowDidBecomeKey];\\n   }\\n }\\n \\n+// See comments above windowBecameKey:\\n+//\\n+// If we're using top-level widgets (nsCocoaWindow objects), we send them\\n+// NS_DEACTIVATE events (which propagate to child widgets (nsChildView\\n+// objects) via nsWebShellWindow::HandleEvent()).  Sending NS_LOSTFOCUS\\n+// events to top-level widgets currently has no effect (nsWebShellWindow::\\n+// HandleEvent(), which processes focus events sent to top-level widgets,\\n+// doesn't have a section for NS_LOSTFOCUS).  But on general principles we\\n+// send them anyway.\\n+//\\n+// On other platforms (e.g. Windows and GTK2), NS_DEACTIVATE events are only\\n+// sent (directly) to top-level widgets.  And (as noted above) these events\\n+// propagate to child widgets when they're sent to top-level widgets.  But if\\n+// we don't send them again, blinking I-bar cursors can appear in multiple\\n+// text input fields.  Since we also need to send NS_LOSTFOCUS events and\\n+// call nsTSMManager::CommitIME(), we just always call through to ChildView\\n+// viewsWindowDidResignKey (whether or not we're using top-level widgets).\\n - (void)windowResignedKey:(NSNotification*)inNotification\\n {\\n   NSWindow* window = (NSWindow*)[inNotification object];\\n+  id delegate = [window delegate];\\n+  if (delegate && [delegate respondsToSelector:@selector(sendFocusEvent:)]) {\\n+    [delegate sendFocusEvent:NS_DEACTIVATE];\\n+    [delegate sendFocusEvent:NS_LOSTFOCUS];\\n+  }\\n   id firstResponder = [window firstResponder];\\n-  if ([firstResponder isKindOfClass:[ChildView class]]) {\\n+  if ([firstResponder isKindOfClass:[ChildView class]])\\n     [firstResponder viewsWindowDidResignKey];\\n-  }\\n-  else {\\n-    id delegate = [window delegate];\\n-    if ([delegate respondsToSelector:@selector(sendFocusEvent:)]) {\\n-      [delegate sendFocusEvent:NS_LOSTFOCUS];\\n-      [delegate sendFocusEvent:NS_DEACTIVATE];\\n-    }\\n-  }\\n }\\n \\n - (void)windowWillClose:(NSNotification*)inNotification\\n\""}