{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basb499049\""},"diff":"\"b499049 Fix race saving/restoring malloc hooks by going back to overriding malloc, etc., plus some additional cleanup.  b=392009  r+a1.9=brendan\\ndiff --git a/tools/trace-malloc/lib/nsTraceMalloc.c b/tools/trace-malloc/lib/nsTraceMalloc.c\\nindex 6e6079d..952405a 100644\\n--- a/tools/trace-malloc/lib/nsTraceMalloc.c\\n+++ b/tools/trace-malloc/lib/nsTraceMalloc.c\\n@@ -88,9 +88,11 @@\\n #pragma GCC visibility push(default)\\n #endif\\n extern __ptr_t __libc_malloc(size_t);\\n+extern __ptr_t __libc_calloc(size_t, size_t);\\n extern __ptr_t __libc_realloc(__ptr_t, size_t);\\n extern void    __libc_free(__ptr_t);\\n extern __ptr_t __libc_memalign(size_t, size_t);\\n+extern __ptr_t __libc_valloc(size_t);\\n #ifdef WRAP_SYSTEM_INCLUDES\\n #pragma GCC visibility pop\\n #endif\\n@@ -147,8 +149,11 @@ static char      *sdlogname = NULL; /* filename for shutdown leak log */\\n  * the performance cost of repeated TM_TLS_GET_DATA calls when\\n  * trace-malloc is disabled (which is not as bad as the locking we used\\n  * to have).\\n+ *\\n+ * It must default to zero, since it can be tested by the Linux malloc\\n+ * hooks before NS_TraceMallocStartup sets it.\\n  */\\n-static uint32 tracing_enabled = 1;\\n+static uint32 tracing_enabled = 0;\\n \\n /*\\n  * This lock must be held while manipulating the calltree, the\\n@@ -157,18 +162,33 @@ static uint32 tracing_enabled = 1;\\n  * Callers should not *enter* the lock without checking suppress_tracing\\n  * first; otherwise they risk trying to re-enter on the same thread.\\n  */\\n-#define TM_ENTER_LOCK()                                                       \\\\\\n+#define TM_ENTER_LOCK(t)                                                      \\\\\\n     PR_BEGIN_MACRO                                                            \\\\\\n+        PR_ASSERT(t->suppress_tracing != 0);                                  \\\\\\n         if (tmlock)                                                           \\\\\\n             PR_Lock(tmlock);                                                  \\\\\\n     PR_END_MACRO\\n \\n-#define TM_EXIT_LOCK()                                                        \\\\\\n+#define TM_EXIT_LOCK(t)                                                       \\\\\\n     PR_BEGIN_MACRO                                                            \\\\\\n+        PR_ASSERT(t->suppress_tracing != 0);                                  \\\\\\n         if (tmlock)                                                           \\\\\\n             PR_Unlock(tmlock);                                                \\\\\\n     PR_END_MACRO\\n \\n+#define TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t)                                 \\\\\\n+    PR_BEGIN_MACRO                                                            \\\\\\n+        t->suppress_tracing++;                                                \\\\\\n+        TM_ENTER_LOCK(t);                                                     \\\\\\n+    PR_END_MACRO\\n+\\n+#define TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t)                                \\\\\\n+    PR_BEGIN_MACRO                                                            \\\\\\n+        TM_EXIT_LOCK(t);                                                      \\\\\\n+        t->suppress_tracing--;                                                \\\\\\n+    PR_END_MACRO\\n+\\n+\\n /*\\n  * Thread-local storage.\\n  *\\n@@ -576,7 +596,7 @@ static PLHashTable *filenames = NULL;\\n static PLHashTable *methods = NULL;\\n \\n static callsite *\\n-calltree(void **stack, size_t num_stack_entries)\\n+calltree(void **stack, size_t num_stack_entries, tm_thread *t)\\n {\\n     logfile *fp = logfp;\\n     void *pc;\\n@@ -598,7 +618,7 @@ calltree(void **stack, size_t num_stack_entries)\\n      * that we need to in this function, because it makes some calls\\n      * that could lock in the system's shared library loader.\\n      */\\n-    TM_ENTER_LOCK();\\n+    TM_ENTER_LOCK(t);\\n \\n     maxstack = (num_stack_entries > tmstats.calltree_maxstack);\\n     if (maxstack) {\\n@@ -672,9 +692,9 @@ calltree(void **stack, size_t num_stack_entries)\\n          * and then filling in the descriptions for any that hadn't been\\n          * described already.  But this is easier for now.\\n          */\\n-        TM_EXIT_LOCK();\\n+        TM_EXIT_LOCK(t);\\n         rv = NS_DescribeCodeAddress(pc, &details);\\n-        TM_ENTER_LOCK();\\n+        TM_ENTER_LOCK(t);\\n         if (NS_FAILED(rv)) {\\n             tmstats.dladdr_failures++;\\n             goto fail;\\n@@ -862,11 +882,11 @@ calltree(void **stack, size_t num_stack_entries)\\n     if (maxstack)\\n         calltree_maxstack_top = site;\\n \\n-    TM_EXIT_LOCK();\\n+    TM_EXIT_LOCK(t);\\n     return site;\\n \\n   fail:\\n-    TM_EXIT_LOCK();\\n+    TM_EXIT_LOCK(t);\\n     return NULL;\\n }\\n \\n@@ -941,15 +961,15 @@ backtrace(tm_thread *t, int skip)\\n         return NULL;\\n     }\\n \\n-    site = calltree(info->buffer, info->entries);\\n+    site = calltree(info->buffer, info->entries, t);\\n \\n-    TM_ENTER_LOCK();\\n+    TM_ENTER_LOCK(t);\\n     tmstats.backtrace_calls++;\\n     if (!site) {\\n         tmstats.backtrace_failures++;\\n         PR_ASSERT(tmstats.backtrace_failures < 100);\\n     }\\n-    TM_EXIT_LOCK();\\n+    TM_EXIT_LOCK(t);\\n \\n     t->suppress_tracing--;\\n     return site;\\n@@ -1082,121 +1102,173 @@ ShutdownHooker(void)\\n \\n #elif defined(XP_UNIX)\\n \\n-static __ptr_t (*old_malloc_hook)(size_t size, __const __malloc_ptr_t caller);\\n-static __ptr_t (*old_realloc_hook)(__ptr_t ptr, size_t size, __const __malloc_ptr_t caller);\\n-static __ptr_t (*old_memalign_hook)(size_t boundary, size_t size, __const __malloc_ptr_t caller);\\n-static void (*old_free_hook)(__ptr_t ptr, __const __malloc_ptr_t caller);\\n+/*\\n+ * We can't use glibc's malloc hooks because they can't be used in a\\n+ * threadsafe manner.  They require unsetting the hooks to call into the\\n+ * original malloc implementation, and then resetting them when the\\n+ * original implementation returns.  If another thread calls the same\\n+ * allocation function while the hooks are unset, we have no chance to\\n+ * intercept the call.\\n+ */\\n \\n-static __ptr_t\\n-my_malloc_hook(size_t size, __const __malloc_ptr_t caller)\\n+NS_EXTERNAL_VIS_(__ptr_t)\\n+malloc(size_t size)\\n {\\n-    tm_thread *t;\\n     PRUint32 start, end;\\n     __ptr_t ptr;\\n+    tm_thread *t;\\n+\\n+    if (!tracing_enabled || !PR_Initialized() ||\\n+        (t = tm_get_thread())->suppress_tracing != 0) {\\n+        return __libc_malloc(size);\\n+    }\\n \\n-    PR_ASSERT(tracing_enabled);\\n-    t = tm_get_thread();\\n     t->suppress_tracing++;\\n-    __malloc_hook = old_malloc_hook;\\n     start = PR_IntervalNow();\\n     ptr = __libc_malloc(size);\\n     end = PR_IntervalNow();\\n-    __malloc_hook = my_malloc_hook;\\n     t->suppress_tracing--;\\n+\\n     MallocCallback(ptr, size, start, end, t);\\n+\\n     return ptr;\\n }\\n \\n-static __ptr_t\\n-my_realloc_hook(__ptr_t oldptr, size_t size, __const __malloc_ptr_t caller)\\n+NS_EXTERNAL_VIS_(__ptr_t)\\n+calloc(size_t count, size_t size)\\n {\\n-    tm_thread *t;\\n     PRUint32 start, end;\\n     __ptr_t ptr;\\n+    tm_thread *t;\\n+\\n+    if (!tracing_enabled || !PR_Initialized() ||\\n+        (t = tm_get_thread())->suppress_tracing != 0) {\\n+        return __libc_calloc(count, size);\\n+    }\\n \\n-    PR_ASSERT(tracing_enabled);\\n-    t = tm_get_thread();\\n     t->suppress_tracing++;\\n-    __realloc_hook = old_realloc_hook;\\n     start = PR_IntervalNow();\\n+    ptr = __libc_calloc(count, size);\\n+    end = PR_IntervalNow();\\n+    t->suppress_tracing--;\\n \\n-    /*\\n-     * __libc_realloc(NULL, size) recurs into my_malloc_hook, so it's\\n-     * important that we've incremented t->suppress_tracing here.\\n-     */\\n+    CallocCallback(ptr, count, size, start, end, t);\\n+\\n+    return ptr;\\n+}\\n+\\n+NS_EXTERNAL_VIS_(__ptr_t)\\n+realloc(__ptr_t oldptr, size_t size)\\n+{\\n+    PRUint32 start, end;\\n+    __ptr_t ptr;\\n+    tm_thread *t;\\n+\\n+    if (!tracing_enabled || !PR_Initialized() ||\\n+        (t = tm_get_thread())->suppress_tracing != 0) {\\n+        return __libc_realloc(oldptr, size);\\n+    }\\n+\\n+    t->suppress_tracing++;\\n+    start = PR_IntervalNow();\\n     ptr = __libc_realloc(oldptr, size);\\n     end = PR_IntervalNow();\\n-    __realloc_hook = my_realloc_hook;\\n     t->suppress_tracing--;\\n+\\n+    /* FIXME bug 392008: We could race with reallocation of oldptr. */\\n     ReallocCallback(oldptr, ptr, size, start, end, t);\\n+\\n     return ptr;\\n }\\n \\n-static __ptr_t\\n-my_memalign_hook(size_t boundary, size_t size, __const __malloc_ptr_t caller)\\n+NS_EXTERNAL_VIS_(void*)\\n+valloc(size_t size)\\n {\\n-    tm_thread *t;\\n     PRUint32 start, end;\\n     __ptr_t ptr;\\n+    tm_thread *t;\\n+\\n+    if (!tracing_enabled || !PR_Initialized() ||\\n+        (t = tm_get_thread())->suppress_tracing != 0) {\\n+        return __libc_valloc(size);\\n+    }\\n \\n-    PR_ASSERT(tracing_enabled);\\n-    t = tm_get_thread();\\n     t->suppress_tracing++;\\n-    __memalign_hook = old_memalign_hook;\\n     start = PR_IntervalNow();\\n-    ptr = __libc_memalign(boundary, size);\\n+    ptr = __libc_valloc(size);\\n     end = PR_IntervalNow();\\n-    __memalign_hook = my_memalign_hook;\\n     t->suppress_tracing--;\\n+\\n     MallocCallback(ptr, size, start, end, t);\\n+\\n     return ptr;\\n }\\n \\n-static void\\n-my_free_hook(__ptr_t ptr, __const __malloc_ptr_t caller)\\n+NS_EXTERNAL_VIS_(void*)\\n+memalign(size_t boundary, size_t size)\\n {\\n-    tm_thread *t;\\n     PRUint32 start, end;\\n+    __ptr_t ptr;\\n+    tm_thread *t;\\n+\\n+    if (!tracing_enabled || !PR_Initialized() ||\\n+        (t = tm_get_thread())->suppress_tracing != 0) {\\n+        return __libc_memalign(boundary, size);\\n+    }\\n \\n-    PR_ASSERT(tracing_enabled);\\n-    t = tm_get_thread();\\n     t->suppress_tracing++;\\n-    __free_hook = old_free_hook;\\n     start = PR_IntervalNow();\\n-    __libc_free(ptr);\\n+    ptr = __libc_memalign(boundary, size);\\n     end = PR_IntervalNow();\\n-    __free_hook = my_free_hook;\\n     t->suppress_tracing--;\\n-    FreeCallback(ptr, start, end, t);\\n+\\n+    MallocCallback(ptr, size, start, end, t);\\n+\\n+    return ptr;\\n }\\n \\n-static void\\n-StartupHooker(void)\\n+NS_EXTERNAL_VIS_(int)\\n+posix_memalign(void **memptr, size_t alignment, size_t size)\\n {\\n-    PR_ASSERT(__malloc_hook != my_malloc_hook);\\n+    __ptr_t ptr = memalign(alignment, size);\\n+    if (!ptr)\\n+        return ENOMEM;\\n+    *memptr = ptr;\\n+    return 0;\\n+}\\n \\n-    old_malloc_hook = __malloc_hook;\\n-    old_realloc_hook = __realloc_hook;\\n-    old_memalign_hook = __memalign_hook;\\n-    old_free_hook = __free_hook;\\n+NS_EXTERNAL_VIS_(void)\\n+free(__ptr_t ptr)\\n+{\\n+    PRUint32 start, end;\\n+    tm_thread *t;\\n+\\n+    if (!tracing_enabled || !PR_Initialized() ||\\n+        (t = tm_get_thread())->suppress_tracing != 0) {\\n+        __libc_free(ptr);\\n+        return;\\n+    }\\n \\n-    __malloc_hook = my_malloc_hook;\\n-    __realloc_hook = my_realloc_hook;\\n-    __memalign_hook = my_memalign_hook;\\n-    __free_hook = my_free_hook;\\n+    t->suppress_tracing++;\\n+    start = PR_IntervalNow();\\n+    __libc_free(ptr);\\n+    end = PR_IntervalNow();\\n+    t->suppress_tracing--;\\n+\\n+    /* FIXME bug 392008: We could race with reallocation of ptr. */\\n+\\n+    FreeCallback(ptr, start, end, t);\\n }\\n \\n-static void\\n-ShutdownHooker(void)\\n+NS_EXTERNAL_VIS_(void)\\n+cfree(void *ptr)\\n {\\n-    PR_ASSERT(__malloc_hook == my_malloc_hook);\\n-\\n-    __malloc_hook = old_malloc_hook;\\n-    __realloc_hook = old_realloc_hook;\\n-    __memalign_hook = old_memalign_hook;\\n-    __free_hook = old_free_hook;\\n+    free(ptr);\\n }\\n \\n+#define StartupHooker()                 PR_BEGIN_MACRO PR_END_MACRO\\n+#define ShutdownHooker()                PR_BEGIN_MACRO PR_END_MACRO\\n+\\n #elif defined(XP_WIN32)\\n \\n /* See nsWinTraceMalloc.cpp. */\\n@@ -1217,7 +1289,7 @@ PR_IMPLEMENT(void)\\n NS_TraceMallocStartup(int logfd)\\n {\\n     /* We must be running on the primordial thread. */\\n-    PR_ASSERT(tracing_enabled == 1);\\n+    PR_ASSERT(tracing_enabled == 0);\\n     PR_ASSERT(logfp == &default_logfile);\\n     tracing_enabled = (logfd >= 0);\\n \\n@@ -1445,13 +1517,11 @@ NS_TraceMallocDisable(void)\\n     if (tracing_enabled == 0)\\n         return;\\n \\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);\\n     for (fp = logfile_list; fp; fp = fp->next)\\n         flush_logfile(fp);\\n     sample = --tracing_enabled;\\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);\\n     if (sample == 0)\\n         ShutdownHooker();\\n }\\n@@ -1462,11 +1532,9 @@ NS_TraceMallocEnable(void)\\n     tm_thread *t = tm_get_thread();\\n     uint32 sample;\\n \\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);\\n     sample = ++tracing_enabled;\\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);\\n     if (sample == 1)\\n         StartupHooker();\\n }\\n@@ -1478,23 +1546,20 @@ NS_TraceMallocChangeLogFD(int fd)\\n     struct stat sb;\\n     tm_thread *t = tm_get_thread();\\n \\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);\\n     oldfp = logfp;\\n     if (oldfp->fd != fd) {\\n         flush_logfile(oldfp);\\n         fp = get_logfile(fd);\\n         if (!fp) {\\n-            TM_EXIT_LOCK();\\n-            t->suppress_tracing--;\\n+            TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);\\n             return -2;\\n         }\\n         if (fd >= 0 && fstat(fd, &sb) == 0 && sb.st_size == 0)\\n             log_header(fd);\\n         logfp = fp;\\n     }\\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);\\n     return oldfp->fd;\\n }\\n \\n@@ -1524,8 +1589,7 @@ NS_TraceMallocCloseLogFD(int fd)\\n     logfile *fp;\\n     tm_thread *t = tm_get_thread();\\n \\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);\\n \\n     fp = get_logfile(fd);\\n     if (fp) {\\n@@ -1556,8 +1620,7 @@ NS_TraceMallocCloseLogFD(int fd)\\n         }\\n     }\\n \\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);\\n     close(fd);\\n }\\n \\n@@ -1573,8 +1636,7 @@ NS_TraceMallocLogTimestamp(const char *caption)\\n #endif\\n     tm_thread *t = tm_get_thread();\\n \\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);\\n \\n     fp = logfp;\\n     log_byte(fp, TM_EVENT_TIMESTAMP);\\n@@ -1591,8 +1653,7 @@ NS_TraceMallocLogTimestamp(const char *caption)\\n #endif\\n     log_string(fp, caption);\\n \\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);\\n }\\n \\n static PRIntn\\n@@ -1651,8 +1712,7 @@ NS_TraceMallocDumpAllocations(const char *pathname)\\n \\n     tm_thread *t = tm_get_thread();\\n \\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);\\n \\n     ofp = fopen(pathname, WRITE_FLAGS);\\n     if (ofp) {\\n@@ -1666,8 +1726,7 @@ NS_TraceMallocDumpAllocations(const char *pathname)\\n         rv = -1;\\n     }\\n \\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);\\n \\n     return rv;\\n }\\n@@ -1678,14 +1737,12 @@ NS_TraceMallocFlushLogfiles(void)\\n     logfile *fp;\\n     tm_thread *t = tm_get_thread();\\n \\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);\\n \\n     for (fp = logfile_list; fp; fp = fp->next)\\n         flush_logfile(fp);\\n \\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);\\n }\\n \\n PR_IMPLEMENT(void)\\n@@ -1697,8 +1754,7 @@ NS_TrackAllocation(void* ptr, FILE *ofp)\\n     fprintf(ofp, \\\"Trying to track %p\\\\n\\\", (void*) ptr);\\n     setlinebuf(ofp);\\n \\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);\\n     if (get_allocations()) {\\n         alloc = (allocation*)\\n                 *PL_HashTableRawLookup(allocations, hash_pointer(ptr), ptr);\\n@@ -1709,8 +1765,7 @@ NS_TrackAllocation(void* ptr, FILE *ofp)\\n             fprintf(ofp, \\\"Not tracking %p\\\\n\\\", (void*) ptr);\\n         }\\n     }\\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);\\n }\\n \\n PR_IMPLEMENT(void)\\n@@ -1725,8 +1780,7 @@ MallocCallback(void *ptr, size_t size, PRUint32 start, PRUint32 end, tm_thread *\\n \\n     site = backtrace(t, 2);\\n \\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);\\n     tmstats.malloc_calls++;\\n     if (!ptr) {\\n         tmstats.malloc_failures++;\\n@@ -1745,8 +1799,7 @@ MallocCallback(void *ptr, size_t size, PRUint32 start, PRUint32 end, tm_thread *\\n             }\\n         }\\n     }\\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);\\n }\\n \\n PR_IMPLEMENT(void)\\n@@ -1761,8 +1814,7 @@ CallocCallback(void *ptr, size_t count, size_t size, PRUint32 start, PRUint32 en\\n \\n     site = backtrace(t, 2);\\n \\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);\\n     tmstats.calloc_calls++;\\n     if (!ptr) {\\n         tmstats.calloc_failures++;\\n@@ -1782,8 +1834,7 @@ CallocCallback(void *ptr, size_t count, size_t size, PRUint32 start, PRUint32 en\\n             }\\n         }\\n     }\\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);\\n }\\n \\n PR_IMPLEMENT(void)\\n@@ -1802,8 +1853,7 @@ ReallocCallback(void * oldptr, void *ptr, size_t size,\\n \\n     site = backtrace(t, 2);\\n \\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);\\n     tmstats.realloc_calls++;\\n     oldsite = NULL;\\n     oldsize = 0;\\n@@ -1867,8 +1917,7 @@ ReallocCallback(void * oldptr, void *ptr, size_t size,\\n             }\\n         }\\n     }\\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);\\n }\\n \\n PR_IMPLEMENT(void)\\n@@ -1881,8 +1930,7 @@ FreeCallback(void * ptr, PRUint32 start, PRUint32 end, tm_thread *t)\\n     if (!tracing_enabled || t->suppress_tracing != 0)\\n         return;\\n \\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);\\n     tmstats.free_calls++;\\n     if (!ptr) {\\n         tmstats.null_free_calls++;\\n@@ -1907,8 +1955,7 @@ FreeCallback(void * ptr, PRUint32 start, PRUint32 end, tm_thread *t)\\n             }\\n         }\\n     }\\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);\\n }\\n \\n #endif /* NS_TRACE_MALLOC */\\ndiff --git a/tools/trace-malloc/lib/nsWinTraceMalloc.cpp b/tools/trace-malloc/lib/nsWinTraceMalloc.cpp\\nindex 054e290..aea5e0c 100644\\n--- a/tools/trace-malloc/lib/nsWinTraceMalloc.cpp\\n+++ b/tools/trace-malloc/lib/nsWinTraceMalloc.cpp\\n@@ -121,6 +121,7 @@ void __cdecl dhw_free( void* p )\\n     DHW_ORIGINAL(FREE_, getFreeHooker())(p);\\n     PRUint32 end = PR_IntervalNow();\\n     --t->suppress_tracing;\\n+    /* FIXME bug 392008: We could race with reallocation of p. */\\n     FreeCallback(p, start, end, t);\\n }\\n \\n@@ -140,6 +141,7 @@ void * __cdecl dhw_realloc(void * pin, size_t size)\\n     void* pout = DHW_ORIGINAL(REALLOC_, getReallocHooker())(pin, size);\\n     PRUint32 end = PR_IntervalNow();\\n     --t->suppress_tracing;\\n+    /* FIXME bug 392008: We could race with reallocation of pin. */\\n     ReallocCallback(pin, pout, size, start, end, t);\\n     return pout;\\n }\\n\""}