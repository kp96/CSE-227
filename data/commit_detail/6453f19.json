{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas6453f19\""},"diff":"\"6453f19 Bug 125928 - \\\"HTML composition converted to PlainText fails to strip spaces before hard breaks with format=flowed\\\" [p=andrit@ukr.net (Andriy Tkachuk) r=mscott r=BenB sr=bzbarsky (NPOFx)]\\ndiff --git a/content/base/src/nsPlainTextSerializer.cpp b/content/base/src/nsPlainTextSerializer.cpp\\nindex 577b453..a96590b 100644\\n--- a/content/base/src/nsPlainTextSerializer.cpp\\n+++ b/content/base/src/nsPlainTextSerializer.cpp\\n@@ -1570,8 +1570,12 @@ nsPlainTextSerializer::OutputQuotesAndIndent(PRBool stripTrailingSpaces /* = PR_\\n  * line wrapping, indentation, whitespace compression and other things.\\n  */\\n void\\n-nsPlainTextSerializer::Write(const nsAString& aString)\\n+nsPlainTextSerializer::Write(const nsAString& aStr)\\n {\\n+  // XXX Copy necessary to use nsString methods and gain\\n+  // access to underlying buffer\\n+  nsAutoString str(aStr);\\n+\\n #ifdef DEBUG_wrapping\\n   printf(\\\"Write(%s): wrap col = %d\\\\n\\\",\\n          NS_ConvertUTF16toUTF8(aString).get(), mWrapColumn);\\n@@ -1580,17 +1584,32 @@ nsPlainTextSerializer::Write(const nsAString& aString)\\n   PRInt32 bol = 0;\\n   PRInt32 newline;\\n   \\n-  PRInt32 totLen = aString.Length();\\n+  PRInt32 totLen = str.Length();\\n \\n   // If the string is empty, do nothing:\\n   if (totLen <= 0) return;\\n \\n+  // For Flowed text change nbsp-ses to spaces at end of lines to allow them\\n+  // to be cut off along with usual spaces if required. (bug #125928)\\n+  if (mFlags & nsIDocumentEncoder::OutputFormatFlowed) {\\n+    PRUnichar nbsp = 160;\\n+    for (PRUint32 i = totLen-1; i >= 0; i--) {\\n+      PRUnichar c = str[i];\\n+      if ('\\\\n' == c || '\\\\r' == c || ' ' == c || '\\\\t' == c)\\n+        continue;\\n+      if (nbsp == c)\\n+        str.Replace(i, 1, ' ');\\n+      else\\n+        break;\\n+    }\\n+  }\\n+\\n   // We have two major codepaths here. One that does preformatted text and one\\n   // that does normal formatted text. The one for preformatted text calls\\n   // Output directly while the other code path goes through AddToLine.\\n   if ((mPreFormatted && !mWrapColumn) || IsInPre()\\n       || ((((!mQuotesPreformatted && mSpanLevel > 0) || mDontWrapAnyQuotes))\\n-          && mEmptyLines >= 0 && aString.First() == PRUnichar('>'))) {\\n+          && mEmptyLines >= 0 && str.First() == PRUnichar('>'))) {\\n     // No intelligent wrapping.\\n \\n     // This mustn't be mixed with intelligent wrapping without clearing\\n@@ -1610,8 +1629,8 @@ nsPlainTextSerializer::Write(const nsAString& aString)\\n \\n       // Find one of '\\\\n' or '\\\\r' using iterators since nsAString\\n       // doesn't have the old FindCharInSet function.\\n-      nsAString::const_iterator iter;           aString.BeginReading(iter);\\n-      nsAString::const_iterator done_searching; aString.EndReading(done_searching);\\n+      nsAString::const_iterator iter;           str.BeginReading(iter);\\n+      nsAString::const_iterator done_searching; str.EndReading(done_searching);\\n       iter.advance(bol); \\n       PRInt32 new_newline = bol;\\n       newline = kNotFound;\\n@@ -1627,7 +1646,7 @@ nsPlainTextSerializer::Write(const nsAString& aString)\\n       // Done searching\\n       if(newline == kNotFound) {\\n         // No new lines.\\n-        nsAutoString stringpart(Substring(aString, bol, totLen - bol));\\n+        nsAutoString stringpart(Substring(str, bol, totLen - bol));\\n         if(!stringpart.IsEmpty()) {\\n           PRUnichar lastchar = stringpart[stringpart.Length()-1];\\n           if((lastchar == '\\\\t') || (lastchar == ' ') ||\\n@@ -1645,7 +1664,9 @@ nsPlainTextSerializer::Write(const nsAString& aString)\\n       } \\n       else {\\n         // There is a newline\\n-        nsAutoString stringpart(Substring(aString, bol, newline-bol));\\n+        nsAutoString stringpart(Substring(str, bol, newline-bol));\\n+        if (mFlags & nsIDocumentEncoder::OutputFormatFlowed)\\n+          stringpart.Trim(\\\" \\\", PR_FALSE, PR_TRUE, PR_TRUE);\\n         mInWhitespace = PR_TRUE;\\n         mCurrentLine.Assign(stringpart);\\n         outputLineBreak = PR_TRUE;\\n@@ -1682,10 +1703,6 @@ nsPlainTextSerializer::Write(const nsAString& aString)\\n     return;\\n   }\\n \\n-  // XXX Copy necessary to use nsString methods and gain\\n-  // access to underlying buffer\\n-  nsAutoString str(aString);\\n-\\n   // Intelligent handling of text\\n   // If needed, strip out all \\\"end of lines\\\"\\n   // and multiple whitespace between words\\n\""}