{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basf537b79\""},"diff":"\"f537b79 Bug 389498 - <mask> not rendered correctly when scrolling. r=longsonr, sr+a=roc\\ndiff --git a/layout/svg/base/src/nsSVGMaskFrame.cpp b/layout/svg/base/src/nsSVGMaskFrame.cpp\\nindex 4fcfc62..b1012a1 100644\\n--- a/layout/svg/base/src/nsSVGMaskFrame.cpp\\n+++ b/layout/svg/base/src/nsSVGMaskFrame.cpp\\n@@ -168,6 +168,7 @@ nsSVGMaskFrame::ComputeMaskAlpha(nsSVGRenderState *aContext,\\n     return nsnull;\\n \\n   nsRefPtr<gfxASurface> surface = pattern->GetSurface();\\n+  surface->SetDeviceOffset(gfxPoint(0,0));\\n \\n   gfxRect clipExtents = gfx->GetClipExtents();\\n \\n@@ -197,7 +198,7 @@ nsSVGMaskFrame::ComputeMaskAlpha(nsSVGRenderState *aContext,\\n \\n   gfxContext transferCtx(image);\\n   transferCtx.SetOperator(gfxContext::OPERATOR_SOURCE);\\n-  transferCtx.SetSource(surface, -clipExtents.pos);\\n+  transferCtx.SetSource(surface);\\n   transferCtx.Paint();\\n \\n   PRUint8 *data   = image->Data();\\ndiff --git a/layout/svg/base/src/nsSVGUtils.cpp b/layout/svg/base/src/nsSVGUtils.cpp\\nindex 186f749..d4e49701 100644\\n--- a/layout/svg/base/src/nsSVGUtils.cpp\\n+++ b/layout/svg/base/src/nsSVGUtils.cpp\\n@@ -1456,6 +1456,29 @@ nsSVGUtils::CanOptimizeOpacity(nsIFrame *aFrame)\\n   return PR_FALSE;\\n }\\n \\n+#ifdef DEBUG\\n+void\\n+nsSVGUtils::WritePPM(const char *fname, gfxImageSurface *aSurface)\\n+{\\n+  FILE *f = fopen(fname, \\\"wb\\\");\\n+  if (!f)\\n+    return;\\n+\\n+  gfxIntSize size = aSurface->GetSize();\\n+  fprintf(f, \\\"P6\\\\n%d %d\\\\n255\\\\n\\\", size.width, size.height);\\n+  unsigned char *data = aSurface->Data();\\n+  PRInt32 stride = aSurface->Stride();\\n+  for (int y=0; y<size.height; y++) {\\n+    for (int x=0; x<size.width; x++) {\\n+      fwrite(data + y * stride + 4 * x + GFX_ARGB32_OFFSET_R, 1, 1, f);\\n+      fwrite(data + y * stride + 4 * x + GFX_ARGB32_OFFSET_G, 1, 1, f);\\n+      fwrite(data + y * stride + 4 * x + GFX_ARGB32_OFFSET_B, 1, 1, f);\\n+    }\\n+  }\\n+  fclose(f);\\n+}\\n+#endif\\n+\\n // ----------------------------------------------------------------------\\n \\n nsSVGRenderState::nsSVGRenderState(nsIRenderingContext *aContext) :\\ndiff --git a/layout/svg/base/src/nsSVGUtils.h b/layout/svg/base/src/nsSVGUtils.h\\nindex b0469a5..9245a31 100644\\n--- a/layout/svg/base/src/nsSVGUtils.h\\n+++ b/layout/svg/base/src/nsSVGUtils.h\\n@@ -69,6 +69,7 @@ class nsAttrValue;\\n class gfxContext;\\n class gfxASurface;\\n class nsIRenderingContext;\\n+class gfxImageSurface;\\n struct gfxRect;\\n struct gfxMatrix;\\n struct gfxSize;\\n@@ -383,6 +384,11 @@ public:\\n   static PRBool\\n   CanOptimizeOpacity(nsIFrame *aFrame);\\n \\n+#ifdef DEBUG\\n+  static void\\n+  WritePPM(const char *fname, gfxImageSurface *aSurface);\\n+#endif\\n+\\n private:\\n   /* Computational (nil) surfaces */\\n   static gfxASurface *mThebesComputationalSurface;\\n\""}