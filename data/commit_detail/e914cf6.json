{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Base914cf6\""},"diff":"\"e914cf6 bug 362682.  relanding linux text goodness. patch by myself and Behdad Esfahbod <mozilla@behdad.org>. r=vlad\\ndiff --git a/config/system-headers b/config/system-headers\\nindex c40e1dc..b195469 100644\\n--- a/config/system-headers\\n+++ b/config/system-headers\\n@@ -213,6 +213,7 @@ Gdiplus.h\\n gdk/gdkevents.h\\n gdk/gdk.h\\n gdk/gdkkeysyms.h\\n+gdk/gdkpango.h\\n gdk/gdkprivate.h\\n gdk/gdkregion.h\\n gdk/gdkwindow.h\\n@@ -505,6 +506,7 @@ PALM_CMN.H\\n pango-engine.h\\n pango-glyph.h\\n pango-modules.h\\n+pango/pangocairo.h\\n pango/pangofc-decoder.h\\n pango/pangofc-font.h\\n pango/pangofc-fontmap.h\\n@@ -513,6 +515,7 @@ pango/pango-fontmap.h\\n pango/pango.h\\n pango/pangoxft.h\\n pango/pangox.h\\n+pango/pango-utils.h\\n pango-types.h\\n pascal.h\\n Patches.h\\ndiff --git a/configure.in b/configure.in\\nindex 0d410f7..5c52f67 100644\\n--- a/configure.in\\n+++ b/configure.in\\n@@ -116,7 +116,8 @@ PERL_VERSION=5.006\\n LIBART_VERSION=2.3.4\\n CAIRO_VERSION=1.4.2\\n GLITZ_VERSION=0.4.0\\n-GTK2_VERSION=1.3.7\\n+PANGO_VERSION=1.10.0\\n+GTK2_VERSION=1.8.0\\n MAKE_VERSION=3.78\\n WINDRES_VERSION=2.14.90\\n W32API_VERSION=3.8\\n@@ -4567,7 +4568,7 @@ fi\\n if test \\\"$COMPILE_ENVIRONMENT\\\"; then\\n if test \\\"$MOZ_ENABLE_GTK2\\\"\\n then\\n-    PKG_CHECK_MODULES(MOZ_GTK2, gtk+-2.0 >= 1.3.7 gdk-x11-2.0 glib-2.0 gobject-2.0)\\n+    PKG_CHECK_MODULES(MOZ_GTK2, gtk+-2.0 >= $GTK2_VERSION gdk-x11-2.0 glib-2.0 gobject-2.0)\\n fi\\n fi # COMPILE_ENVIRONMENT\\n \\n@@ -4782,7 +4783,7 @@ if test \\\"$MOZ_ENABLE_XFT\\\"\\n then\\n     AC_DEFINE(MOZ_ENABLE_XFT)\\n     PKG_CHECK_MODULES(MOZ_XFT, xft)\\n-    PKG_CHECK_MODULES(_PANGOCHK, pango >= 1.1.0)\\n+    PKG_CHECK_MODULES(_PANGOCHK, pango >= $PANGO_VERSION)\\n fi\\n \\n AC_SUBST(MOZ_ENABLE_XFT)\\n@@ -4799,12 +4800,7 @@ MOZ_ARG_ENABLE_BOOL(pango,\\n \\n if test \\\"$MOZ_ENABLE_PANGO\\\" && test -z \\\"$MOZ_ENABLE_CAIRO_GFX\\\"\\n then\\n-    AC_DEFINE(MOZ_ENABLE_PANGO)\\n-    PKG_CHECK_MODULES(MOZ_PANGO, pangoxft >= 1.6.0)\\n-\\n-    AC_SUBST(MOZ_ENABLE_PANGO)\\n-    AC_SUBST(MOZ_PANGO_CFLAGS)\\n-    AC_SUBST(MOZ_PANGO_LIBS)\\n+    AC_MSG_ERROR([Cairo gfx is required for Pango font rendering])\\n fi\\n \\n if test \\\"$MOZ_ENABLE_GTK2\\\" && test \\\"$MOZ_ENABLE_CAIRO_GFX\\\"\\n@@ -4820,13 +4816,7 @@ fi\\n if test \\\"$MOZ_ENABLE_PANGO\\\" && test \\\"$MOZ_ENABLE_CAIRO_GFX\\\"\\n then\\n     AC_DEFINE(MOZ_ENABLE_PANGO)\\n-    dnl PKG_CHECK_MODULES(MOZ_PANGO, pango >= 1.10.0 pangocairo >= 1.10.0)\\n-    if test \\\"$MOZ_X11\\\"; then\\n-        PKG_CHECK_MODULES(MOZ_PANGO, pango >= 1.6.0 pangoft2 >= 1.6.0 pangoxft >= 1.6.0)\\n-    else\\n-        PKG_CHECK_MODULES(MOZ_PANGO, pango >= 1.6.0 pangoft2 >= 1.6.0)\\n-    fi\\n-\\n+    PKG_CHECK_MODULES(MOZ_PANGO, pango >= $PANGO_VERSION pangocairo >= $PANGO_VERSION pangoft2 >= $PANGO_VERSION)\\n     AC_SUBST(MOZ_ENABLE_PANGO)\\n     AC_SUBST(MOZ_PANGO_CFLAGS)\\n     AC_SUBST(MOZ_PANGO_LIBS)\\ndiff --git a/gfx/thebes/public/gfxPangoFonts.h b/gfx/thebes/public/gfxPangoFonts.h\\nindex a90ff13..f0a63d7 100644\\n--- a/gfx/thebes/public/gfxPangoFonts.h\\n+++ b/gfx/thebes/public/gfxPangoFonts.h\\n@@ -44,14 +44,15 @@\\n #include \\\"gfxFont.h\\\"\\n \\n #include <pango/pango.h>\\n-#include <X11/Xft/Xft.h>\\n \\n-// Control when we use Xft directly, bypassing Pango\\n-// Enable this to use Xft to glyph-convert 8bit-only textruns, but use Pango\\n+// Control when we bypass Pango\\n+// Enable this to use FreeType to glyph-convert 8bit-only textruns, but use Pango\\n // to shape any textruns with non-8bit characters\\n-#define ENABLE_XFT_FAST_PATH_8BIT\\n-// Enable this to use Xft to glyph-convert all textruns\\n-// #define ENABLE_XFT_FAST_PATH_ALWAYS\\n+// XXX\\n+#define ENABLE_FAST_PATH_8BIT\\n+// Enable this to bypass Pango shaping for all textruns.  Don't expect\\n+// anything other than simple Latin work though!\\n+//#define ENABLE_FAST_PATH_ALWAYS\\n \\n #include \\\"nsDataHashtable.h\\\"\\n #include \\\"nsClassHashtable.h\\\"\\n@@ -70,17 +71,15 @@ public:\\n \\n     virtual const gfxFont::Metrics& GetMetrics();\\n \\n-    PangoFontDescription *GetPangoFontDescription() { RealizeFont(); return mPangoFontDesc; }\\n-    PangoContext *GetPangoContext() { RealizeFont(); return mPangoCtx; }\\n+    PangoFontDescription *GetPangoFontDescription() { if (!mPangoFontDesc) RealizeFont(); return mPangoFontDesc; }\\n+    PangoContext *GetPangoContext() { if (!mPangoFontDesc) RealizeFont(); return mPangoCtx; }\\n \\n     void GetMozLang(nsACString &aMozLang);\\n     void GetActualFontFamily(nsACString &aFamily);\\n \\n-    XftFont *GetXftFont () { RealizeXftFont (); return mXftFont; }\\n-    PangoFont *GetPangoFont() { RealizePangoFont(); return mPangoFont; }\\n-    gfxFloat GetAdjustedSize() { RealizeFont(); return mAdjustedSize; }\\n+    PangoFont *GetPangoFont() { if (!mPangoFont) RealizePangoFont(); return mPangoFont; }\\n+    gfxFloat GetAdjustedSize() { if (!mPangoFontDesc) RealizeFont(); return mAdjustedSize; }\\n \\n-    PRBool HasGlyph(const PRUint32 aChar);\\n     PRUint32 GetGlyph(const PRUint32 aChar);\\n \\n     virtual nsString GetUniqueName();\\n@@ -95,9 +94,7 @@ protected:\\n     PangoFontDescription *mPangoFontDesc;\\n     PangoContext *mPangoCtx;\\n \\n-    XftFont *mXftFont;\\n     PangoFont *mPangoFont;\\n-    PangoFont *mGlyphTestingFont;\\n     cairo_scaled_font_t *mCairoFont;\\n \\n     PRBool   mHasMetrics;\\n@@ -106,7 +103,6 @@ protected:\\n     gfxFloat mAdjustedSize;\\n \\n     void RealizeFont(PRBool force = PR_FALSE);\\n-    void RealizeXftFont(PRBool force = PR_FALSE);\\n     void RealizePangoFont(PRBool aForce = PR_FALSE);\\n     void GetCharSize(const char aChar, gfxSize& aInkSize, gfxSize& aLogSize,\\n                      PRUint32 *aGlyphID = nsnull);\\n@@ -124,7 +120,7 @@ public:\\n \\n     virtual gfxFontGroup *Copy(const gfxFontStyle *aStyle);\\n \\n-    // Create and initialize a textrun using Pango (or Xft)\\n+    // Create and initialize a textrun using Pango\\n     virtual gfxTextRun *MakeTextRun(const PRUnichar *aString, PRUint32 aLength,\\n                                     const Parameters *aParams, PRUint32 aFlags);\\n     virtual gfxTextRun *MakeTextRun(const PRUint8 *aString, PRUint32 aLength,\\n@@ -146,8 +142,8 @@ protected:\\n      * but stored in UTF16 format)\\n      */\\n     void InitTextRun(gfxTextRun *aTextRun, const gchar *aUTF8Text,\\n-                     PRUint32 aUTF8Length, PRUint32 aUTF8HeaderLength,\\n-                     PRBool aTake8BitPath);\\n+                     PRUint32 aUTF8Length, PRBool aTake8BitPath);\\n+\\n     // Returns NS_ERROR_FAILURE if there's a missing glyph\\n     nsresult SetGlyphs(gfxTextRun *aTextRun, gfxPangoFont *aFont,\\n                        const gchar *aUTF8, PRUint32 aUTF8Length,\\n@@ -158,11 +154,11 @@ protected:\\n                               const gchar *aUTF8, PRUint32 aUTF8Length,\\n                               PRUint32 *aUTF16Offset);\\n     void CreateGlyphRunsItemizing(gfxTextRun *aTextRun,\\n-                                  const gchar *aUTF8, PRUint32 aUTF8Length,\\n-                                  PRUint32 aUTF8HeaderLength);\\n-#if defined(ENABLE_XFT_FAST_PATH_8BIT) || defined(ENABLE_XFT_FAST_PATH_ALWAYS)\\n-    void CreateGlyphRunsXft(gfxTextRun *aTextRun,\\n-                            const gchar *aUTF8, PRUint32 aUTF8Length);\\n+                                  const gchar *aUTF8, PRUint32 aUTF8Length);\\n+#if defined(ENABLE_FAST_PATH_8BIT) || defined(ENABLE_FAST_PATH_ALWAYS)\\n+    PRBool CanTakeFastPath(PRUint32 aFlags);\\n+    void CreateGlyphRunsFast(gfxTextRun *aTextRun,\\n+                             const gchar *aUTF8, PRUint32 aUTF8Length);\\n #endif\\n \\n     static PRBool FontCallback (const nsAString& fontName,\\n@@ -212,30 +208,4 @@ private:\\n     nsClassHashtable<nsUint32HashKey,  gfxPangoFontWrapper> mPangoFonts;\\n };\\n \\n-// XXX we should remove this class, because this class is used only in |HasGlyph| of gfxPangoFont.\\n-// But it can use fontconfig directly after bug 366664.\\n-class gfxPangoFontNameMap\\n-{\\n-public:\\n-    gfxPangoFontNameMap();\\n-    ~gfxPangoFontNameMap();\\n-\\n-    static gfxPangoFontNameMap* GetPangoFontNameMap() {\\n-        if (!sPangoFontNameMap)\\n-            sPangoFontNameMap = new gfxPangoFontNameMap();\\n-        return sPangoFontNameMap;\\n-    }\\n-    static void Shutdown() {\\n-        if (sPangoFontNameMap)\\n-            delete sPangoFontNameMap;\\n-        sPangoFontNameMap = nsnull;\\n-    }\\n-\\n-    void Put(const nsACString &aName, PangoFont *aPangoFont);\\n-    PangoFont* Get(const nsACString &aName);\\n-\\n-private:\\n-    static gfxPangoFontNameMap *sPangoFontNameMap;\\n-    nsClassHashtable<nsCStringHashKey, gfxPangoFontWrapper> mPangoFonts;\\n-};\\n #endif /* GFX_PANGOFONTS_H */\\ndiff --git a/gfx/thebes/public/gfxPlatformGtk.h b/gfx/thebes/public/gfxPlatformGtk.h\\nindex 0177304..4c7eafd 100644\\n--- a/gfx/thebes/public/gfxPlatformGtk.h\\n+++ b/gfx/thebes/public/gfxPlatformGtk.h\\n@@ -79,7 +79,7 @@ public:\\n         if (sDPI == -1) {\\n             InitDPI();\\n         }\\n-        NS_ASSERTION(sDPI != 0, \\\"Something is wrong\\\");\\n+        NS_ASSERTION(sDPI > 0, \\\"Something is wrong\\\");\\n         return sDPI;\\n     }\\n \\ndiff --git a/gfx/thebes/src/cairo-xlib-utils.c b/gfx/thebes/src/cairo-xlib-utils.c\\nindex 69cccf2..a7d9333 100644\\n--- a/gfx/thebes/src/cairo-xlib-utils.c\\n+++ b/gfx/thebes/src/cairo-xlib-utils.c\\n@@ -40,6 +40,7 @@\\n #include \\\"cairo-xlib.h\\\"\\n #include <stdlib.h>\\n \\n+#include <stdint.h>\\n #if   HAVE_STDINT_H\\n #include <stdint.h>\\n #elif HAVE_INTTYPES_H\\ndiff --git a/gfx/thebes/src/gfxPangoFonts.cpp b/gfx/thebes/src/gfxPangoFonts.cpp\\nindex 1696cd1..cf7b7e4 100644\\n--- a/gfx/thebes/src/gfxPangoFonts.cpp\\n+++ b/gfx/thebes/src/gfxPangoFonts.cpp\\n@@ -21,6 +21,7 @@\\n  * Contributor(s):\\n  *   Vladimir Vukicevic <vladimir@mozilla.com>\\n  *   Masayuki Nakano <masayuki@d-toybox.com>\\n+ *   Behdad Esfahbod <behdad@gnome.org>\\n  *\\n  * based on nsFontMetricsPango.cpp by\\n  *   Christopher Blizzard <blizzard@mozilla.org>\\n@@ -39,11 +40,6 @@\\n  *\\n  * ***** END LICENSE BLOCK ***** */\\n \\n-#ifdef XP_BEOS\\n-#define THEBES_USE_PANGO_CAIRO\\n-#endif\\n-\\n-#define PANGO_ENABLE_ENGINE\\n #define PANGO_ENABLE_BACKEND\\n \\n #include \\\"prtypes.h\\\"\\n@@ -62,45 +58,38 @@\\n #include \\\"nsPromiseFlatString.h\\\"\\n \\n #include \\\"gfxContext.h\\\"\\n+#include \\\"gfxPlatformGtk.h\\\"\\n #include \\\"gfxPangoFonts.h\\\"\\n \\n #include \\\"nsCRT.h\\\"\\n \\n-#include \\\"cairo.h\\\"\\n-\\n-#ifndef THEBES_USE_PANGO_CAIRO\\n-#include <gdk/gdk.h>\\n-#include <gdk/gdkx.h>\\n-#include <gdk/gdkpango.h>\\n-\\n-\\n #include <freetype/tttables.h>\\n-#include <fontconfig/fontconfig.h>\\n \\n-#include <pango/pango-font.h>\\n-#include <pango/pangoxft.h>\\n-\\n-#include \\\"cairo-ft.h\\\"\\n-\\n-#include \\\"gfxPlatformGtk.h\\\"\\n-\\n-#else // THEBES_USE_PANGO_CAIRO\\n+#include <cairo.h>\\n+#include <cairo-ft.h>\\n \\n+#include <pango/pango.h>\\n+#include <pango/pango-utils.h>\\n #include <pango/pangocairo.h>\\n+#include <pango/pangofc-fontmap.h>\\n \\n-#endif // THEBES_USE_PANGO_CAIRO\\n+#include <gdk/gdkpango.h>\\n \\n #include <math.h>\\n \\n #define FLOAT_PANGO_SCALE ((gfxFloat)PANGO_SCALE)\\n \\n-#define IS_MISSING_GLYPH(g) (((g) & 0x10000000) || (g) == 0x0FFFFFFF)\\n+#ifndef PANGO_GLYPH_UNKNOWN_FLAG\\n+#define PANGO_GLYPH_UNKNOWN_FLAG ((PangoGlyph)0x10000000)\\n+#endif\\n+#ifndef PANGO_GLYPH_EMPTY\\n+#define PANGO_GLYPH_EMPTY           ((PangoGlyph)0)\\n+#endif\\n+#define IS_MISSING_GLYPH(g) (((g) & PANGO_GLYPH_UNKNOWN_FLAG) || (g) == PANGO_GLYPH_EMPTY)\\n \\n static PangoLanguage *GetPangoLanguage(const nsACString& aLangGroup);\\n-static void GetMozLanguage(const PangoLanguage *aLang, nsACString &aMozLang);\\n \\n /* static */ gfxPangoFontCache* gfxPangoFontCache::sPangoFontCache = nsnull;\\n-/* static */ gfxPangoFontNameMap* gfxPangoFontNameMap::sPangoFontNameMap = nsnull;\\n \\n /**\\n  ** gfxPangoFontGroup\\n@@ -166,6 +155,7 @@ gfxPangoFontGroup::gfxPangoFontGroup (const nsAString& families,\\n \\n     // XXX If there are no actual fonts, we should use dummy family.\\n     // Pango will resolve from this.\\n+    // behdad: yep, looks good.\\n     if (familyArray.Count() == 0) {\\n         // printf(\\\"%s(%s)\\\\n\\\", NS_ConvertUTF16toUTF8(families).get(),\\n         //                    aStyle->langGroup.get());\\n@@ -194,82 +184,12 @@ gfxPangoFontGroup::Copy(const gfxFontStyle *aStyle)\\n  ** gfxPangoFont\\n  **/\\n \\n-// Glue to avoid build/runtime dependencies on Pango > 1.6,\\n-// because we like living in 1999\\n-\\n-#ifndef THEBES_USE_PANGO_CAIRO\\n-static void\\n-(* PTR_pango_font_description_set_absolute_size)(PangoFontDescription*, double)\\n-    = nsnull;\\n-\\n-static void InitPangoLib()\\n-{\\n-    static PRBool initialized = PR_FALSE;\\n-    if (initialized)\\n-        return;\\n-    initialized = PR_TRUE;\\n-\\n-    g_type_init();\\n-\\n-    PRLibrary *pangoLib = nsnull;\\n-    PTR_pango_font_description_set_absolute_size =\\n-        (void (*)(PangoFontDescription*, double))\\n-        PR_FindFunctionSymbolAndLibrary(\\\"pango_font_description_set_absolute_size\\\",\\n-                                        &pangoLib);\\n-    if (pangoLib)\\n-        PR_UnloadLibrary(pangoLib);\\n-\\n-    PRLibrary *xftLib = nsnull;\\n-    int *xft_max_freetype_files_ptr = nsnull;\\n-    xft_max_freetype_files_ptr = (int*) PR_FindSymbolAndLibrary(\\\"XftMaxFreeTypeFiles\\\", &xftLib);\\n-    if (xft_max_freetype_files_ptr && *xft_max_freetype_files_ptr < 50)\\n-        *xft_max_freetype_files_ptr = 50;\\n-    if (xftLib)\\n-        PR_UnloadLibrary(xftLib);\\n-}\\n-\\n-static void\\n-ShutdownPangoLib()\\n-{\\n-}\\n-\\n-static void\\n-MOZ_pango_font_description_set_absolute_size(PangoFontDescription *desc,\\n-                                             double size)\\n-{\\n-    if (PTR_pango_font_description_set_absolute_size) {\\n-        PTR_pango_font_description_set_absolute_size(desc, size);\\n-    } else {\\n-        pango_font_description_set_size(desc,\\n-                                        (gint)(size * 72.0 /\\n-                                               gfxPlatformGtk::DPI()));\\n-    }\\n-}\\n-#else\\n-static inline void InitPangoLib()\\n-{\\n-}\\n-\\n-static inline void ShutdownPangoLib()\\n-{\\n-}\\n-\\n-static inline void\\n-MOZ_pango_font_description_set_absolute_size(PangoFontDescription *desc, double size)\\n-{\\n-    pango_font_description_set_absolute_size(desc, size);\\n-}\\n-#endif\\n-\\n gfxPangoFont::gfxPangoFont(const nsAString &aName,\\n                            const gfxFontStyle *aFontStyle)\\n     : gfxFont(aName, aFontStyle),\\n-    mPangoFontDesc(nsnull), mPangoCtx(nsnull),\\n-    mXftFont(nsnull), mPangoFont(nsnull), mGlyphTestingFont(nsnull),\\n-    mCairoFont(nsnull), mHasMetrics(PR_FALSE),\\n-    mAdjustedSize(0)\\n+    mPangoFontDesc(nsnull), mPangoCtx(nsnull), mPangoFont(nsnull),\\n+    mCairoFont(nsnull), mHasMetrics(PR_FALSE), mAdjustedSize(0)\\n {\\n-    InitPangoLib();\\n }\\n \\n gfxPangoFont::~gfxPangoFont()\\n@@ -280,9 +200,6 @@ gfxPangoFont::~gfxPangoFont()\\n     if (mPangoFont)\\n         g_object_unref(mPangoFont);\\n \\n-    if (mGlyphTestingFont)\\n-        g_object_unref(mGlyphTestingFont);\\n-\\n     if (mPangoFontDesc)\\n         pango_font_description_free(mPangoFontDesc);\\n \\n@@ -293,9 +210,12 @@ gfxPangoFont::~gfxPangoFont()\\n /* static */ void\\n gfxPangoFont::Shutdown()\\n {\\n-    ShutdownPangoLib();\\n     gfxPangoFontCache::Shutdown();\\n-    gfxPangoFontNameMap::Shutdown();\\n+\\n+    PangoFontMap *fontmap = pango_cairo_font_map_get_default ();\\n+    if (PANGO_IS_FC_FONT_MAP (fontmap))\\n+\\tpango_fc_font_map_shutdown (PANGO_FC_FONT_MAP (fontmap));\\n+\\n }\\n \\n static PangoStyle\\n@@ -375,28 +295,24 @@ gfxPangoFont::RealizeFont(PRBool force)\\n     if (mPangoFont) {\\n         g_object_unref(mPangoFont);\\n         mPangoFont = nsnull;\\n-        mXftFont = nsnull;\\n-        // XXX we don't need to reset mGlyphTestingFont\\n     }\\n \\n     mPangoFontDesc = pango_font_description_new();\\n \\n     pango_font_description_set_family(mPangoFontDesc, NS_ConvertUTF16toUTF8(mName).get());\\n     gfxFloat size = mAdjustedSize ? mAdjustedSize : GetStyle()->size;\\n-    MOZ_pango_font_description_set_absolute_size(mPangoFontDesc, size * PANGO_SCALE);\\n+    pango_font_description_set_absolute_size(mPangoFontDesc, size * PANGO_SCALE);\\n     pango_font_description_set_style(mPangoFontDesc, ThebesStyleToPangoStyle(GetStyle()));\\n     pango_font_description_set_weight(mPangoFontDesc, ThebesStyleToPangoWeight(GetStyle()));\\n \\n     //printf (\\\"%s, %f, %d, %d\\\\n\\\", NS_ConvertUTF16toUTF8(mName).get(), GetStyle()->size, ThebesStyleToPangoStyle(GetStyle()), ThebesStyleToPangoWeight(GetStyle()));\\n-#ifndef THEBES_USE_PANGO_CAIRO\\n-    mPangoCtx = pango_xft_get_context(GDK_DISPLAY(), 0);\\n-    gdk_pango_context_set_colormap(mPangoCtx, gdk_rgb_get_cmap());\\n-#else\\n-    mPangoCtx = pango_cairo_font_map_create_context(PANGO_CAIRO_FONT_MAP(pango_cairo_font_map_get_default()));\\n-#endif\\n+    mPangoCtx = gdk_pango_context_get ();\\n \\n-    if (!GetStyle()->langGroup.IsEmpty())\\n-        pango_context_set_language(mPangoCtx, GetPangoLanguage(GetStyle()->langGroup));\\n+    if (!GetStyle()->langGroup.IsEmpty()) {\\n+        PangoLanguage *lang = GetPangoLanguage(GetStyle()->langGroup);\\n+        if (lang)\\n+            pango_context_set_language(mPangoCtx, lang);\\n+    }\\n \\n     pango_context_set_font_description(mPangoCtx, mPangoFontDesc);\\n \\n@@ -417,20 +333,6 @@ gfxPangoFont::RealizeFont(PRBool force)\\n }\\n \\n void\\n-gfxPangoFont::RealizeXftFont(PRBool force)\\n-{\\n-    // already realized?\\n-    if (!force && mXftFont)\\n-        return;\\n-    if (GDK_DISPLAY() == 0) {\\n-        mXftFont = nsnull;\\n-        return;\\n-    }\\n-\\n-    mXftFont = pango_xft_font_get_font(GetPangoFont());\\n-}\\n-\\n-void\\n gfxPangoFont::RealizePangoFont(PRBool aForce)\\n {\\n     if (!aForce && mPangoFont)\\n@@ -438,7 +340,6 @@ gfxPangoFont::RealizePangoFont(PRBool aForce)\\n     if (mPangoFont) {\\n         g_object_unref(mPangoFont);\\n         mPangoFont = nsnull;\\n-        mXftFont = nsnull;\\n     }\\n     RealizeFont();\\n     gfxPangoFontCache *cache = gfxPangoFontCache::GetPangoFontCache();\\n@@ -451,19 +352,6 @@ gfxPangoFont::RealizePangoFont(PRBool aForce)\\n     if (!mPangoFont)\\n         return; // Error\\n     cache->Put(mPangoFontDesc, mPangoFont);\\n-\\n-    if (mGlyphTestingFont)\\n-        return;\\n-\\n-    // Append this to font name map\\n-    gfxPangoFontNameMap *fontNameMap = gfxPangoFontNameMap::GetPangoFontNameMap();\\n-    if (!fontNameMap)\\n-        return; // Error\\n-    NS_ConvertUTF16toUTF8 name(mName);\\n-    mGlyphTestingFont = fontNameMap->Get(name);\\n-    if (mGlyphTestingFont)\\n-        return;\\n-    fontNameMap->Put(name, mPangoFont);\\n }\\n \\n void\\n@@ -520,89 +408,6 @@ gfxPangoFont::GetMetrics()\\n     if (mHasMetrics)\\n         return mMetrics;\\n \\n-#ifndef THEBES_USE_PANGO_CAIRO\\n-    float val;\\n-\\n-    XftFont *xftFont = GetXftFont(); // RealizeFont is called here.\\n-    if (!xftFont)\\n-        return mMetrics;        // XXX error\\n-\\n-    FT_Face face = XftLockFace(xftFont);\\n-    if (!face)\\n-        return mMetrics;        // XXX error\\n-\\n-    int size;\\n-    PangoFcFont *fcfont = PANGO_FC_FONT(mPangoFont);\\n-    if (FcPatternGetInteger(fcfont->font_pattern, FC_PIXEL_SIZE, 0, &size) != FcResultMatch)\\n-        size = 12;\\n-    mMetrics.emHeight = PR_MAX(1, size);\\n-\\n-    mMetrics.maxAscent = xftFont->ascent;\\n-    mMetrics.maxDescent = xftFont->descent;\\n-\\n-    double lineHeight = mMetrics.maxAscent + mMetrics.maxDescent;\\n-\\n-    if (lineHeight > mMetrics.emHeight)\\n-        mMetrics.internalLeading = lineHeight - mMetrics.emHeight;\\n-    else\\n-        mMetrics.internalLeading = 0;\\n-    mMetrics.externalLeading = 0;\\n-\\n-    mMetrics.maxHeight = lineHeight;\\n-    mMetrics.emAscent = mMetrics.maxAscent * mMetrics.emHeight / lineHeight;\\n-    mMetrics.emDescent = mMetrics.emHeight - mMetrics.emAscent;\\n-    mMetrics.maxAdvance = xftFont->max_advance_width;\\n-\\n-    gfxSize isz, lsz;\\n-    GetCharSize(' ', isz, lsz, &mSpaceGlyph);\\n-    mMetrics.spaceWidth = lsz.width;\\n-\\n-    // XXX do some FcCharSetHasChar work here to make sure\\n-    // we have an \\\"x\\\"\\n-    GetCharSize('x', isz, lsz);\\n-    mMetrics.xHeight = isz.height;\\n-    mMetrics.aveCharWidth = isz.width;\\n-\\n-    val = CONVERT_DESIGN_UNITS_TO_PIXELS(face->underline_position,\\n-                                         face->size->metrics.y_scale);\\n-    if (!val)\\n-        val = - PR_MAX(1, floor(0.1 * xftFont->height + 0.5));\\n-\\n-    mMetrics.underlineOffset = val;\\n-\\n-    val = CONVERT_DESIGN_UNITS_TO_PIXELS(face->underline_thickness,\\n-                                         face->size->metrics.y_scale);\\n-    if (!val)\\n-        val = floor(0.05 * xftFont->height + 0.5);\\n-\\n-    mMetrics.underlineSize = PR_MAX(1, val);\\n-\\n-    TT_OS2 *os2 = (TT_OS2 *) FT_Get_Sfnt_Table(face, ft_sfnt_os2);\\n-\\n-    if (os2 && os2->ySuperscriptYOffset) {\\n-        val = CONVERT_DESIGN_UNITS_TO_PIXELS(os2->ySuperscriptYOffset,\\n-                                             face->size->metrics.y_scale);\\n-        mMetrics.superscriptOffset = PR_MAX(1, val);\\n-    } else {\\n-        mMetrics.superscriptOffset = mMetrics.xHeight;\\n-    }\\n-\\n-    // mSubscriptOffset\\n-    if (os2 && os2->ySubscriptYOffset) {\\n-        val = CONVERT_DESIGN_UNITS_TO_PIXELS(os2->ySubscriptYOffset,\\n-                                             face->size->metrics.y_scale);\\n-        // some fonts have the incorrect sign. \\n-        val = (val < 0) ? -val : val;\\n-        mMetrics.subscriptOffset = PR_MAX(1, val);\\n-    } else {\\n-        mMetrics.subscriptOffset = mMetrics.xHeight;\\n-    }\\n-\\n-    mMetrics.strikeoutOffset = mMetrics.xHeight / 2.0;\\n-    mMetrics.strikeoutSize = mMetrics.underlineSize;\\n-\\n-    XftUnlockFace(xftFont);\\n-#else\\n     /* pango_cairo case; try to get all the metrics from pango itself */\\n     PangoFont *font = GetPangoFont(); // RealizeFont is called here.\\n \\n@@ -627,7 +432,8 @@ gfxPangoFont::GetMetrics()\\n     mMetrics.emAscent = mMetrics.maxAscent * mMetrics.emHeight / lineHeight;\\n     mMetrics.emDescent = mMetrics.emHeight - mMetrics.emAscent;\\n \\n-    mMetrics.maxAdvance = pango_font_metrics_get_approximate_char_width(pfm) / FLOAT_PANGO_SCALE; // XXX\\n+    // XXX should we move this down, get max-advance from FT_Face?\\n+    mMetrics.maxAdvance = pango_font_metrics_get_approximate_char_width(pfm) / FLOAT_PANGO_SCALE;\\n \\n     gfxSize isz, lsz;\\n     GetCharSize(' ', isz, lsz, &mSpaceGlyph);\\n@@ -643,14 +449,43 @@ gfxPangoFont::GetMetrics()\\n     mMetrics.strikeoutOffset = pango_font_metrics_get_strikethrough_position(pfm) / FLOAT_PANGO_SCALE;\\n     mMetrics.strikeoutSize = pango_font_metrics_get_strikethrough_thickness(pfm) / FLOAT_PANGO_SCALE;\\n \\n-    // these are specified by the so-called OS2 SFNT info, but\\n-    // pango doesn't expose this to us.  This really sucks,\\n-    // so we just assume it's the xHeight\\n-    mMetrics.superscriptOffset = mMetrics.xHeight;\\n-    mMetrics.subscriptOffset = mMetrics.xHeight;\\n+    FT_Face face = NULL;\\n+    if (PANGO_IS_FC_FONT (font))\\n+      face = pango_fc_font_lock_face (PANGO_FC_FONT (font));\\n+\\n+    if (face) {\\n+\\n+\\tfloat val;\\n+\\n+        TT_OS2 *os2 = (TT_OS2 *) FT_Get_Sfnt_Table(face, ft_sfnt_os2);\\n+    \\n+        if (os2 && os2->ySuperscriptYOffset) {\\n+            val = CONVERT_DESIGN_UNITS_TO_PIXELS(os2->ySuperscriptYOffset,\\n+                                                 face->size->metrics.y_scale);\\n+            mMetrics.superscriptOffset = PR_MAX(1, val);\\n+        } else {\\n+            mMetrics.superscriptOffset = mMetrics.xHeight;\\n+        }\\n+    \\n+        // mSubscriptOffset\\n+        if (os2 && os2->ySubscriptYOffset) {\\n+            val = CONVERT_DESIGN_UNITS_TO_PIXELS(os2->ySubscriptYOffset,\\n+                                                 face->size->metrics.y_scale);\\n+            // some fonts have the incorrect sign. \\n+            val = (val < 0) ? -val : val;\\n+            mMetrics.subscriptOffset = PR_MAX(1, val);\\n+        } else {\\n+            mMetrics.subscriptOffset = mMetrics.xHeight;\\n+        }\\n+\\n+    } else {\\n+\\n+\\tmMetrics.superscriptOffset = mMetrics.xHeight;\\n+\\tmMetrics.subscriptOffset = mMetrics.xHeight;\\n+    }\\n+\\n \\n     pango_font_metrics_unref (pfm);\\n-#endif\\n \\n #if 0\\n     fprintf (stderr, \\\"Font: %s\\\\n\\\", NS_ConvertUTF16toUTF8(mName).get());\\n@@ -665,66 +500,13 @@ gfxPangoFont::GetMetrics()\\n     return mMetrics;\\n }\\n \\n-// XXX we should replace this to |pango_is_zero_width| after we don't support pre pango 1.10\\n-static PRBool MOZ_pango_is_zero_width(PRUint32 aChar)\\n-{\\n-    if (aChar == 0x00AD)\\n-        return PR_TRUE;\\n-    if (aChar < 0x200B)\\n-        return PR_FALSE;\\n-    if (aChar <= 0x200F || aChar == 0x2028)\\n-        return PR_TRUE;\\n-    if (aChar < 0x202A)\\n-        return PR_FALSE;\\n-    if (aChar <= 0x202E)\\n-        return PR_TRUE;\\n-    if (aChar < 0x2060)\\n-        return PR_FALSE;\\n-    if (aChar <= 0x2063 || aChar == 0xFEFF)\\n-        return PR_TRUE;\\n-    return PR_FALSE;\\n-}\\n-PRBool\\n-gfxPangoFont::HasGlyph(PRUint32 aChar)\\n-{\\n-    // Ensure that null character should be missing.\\n-    if (aChar == 0)\\n-        return PR_FALSE;\\n-\\n-    if (MOZ_pango_is_zero_width(aChar))\\n-        return PR_TRUE;\\n-\\n-    PangoFont *font = nsnull;\\n-    if (mPangoFont)\\n-        font = mPangoFont;\\n-    else if (mGlyphTestingFont)\\n-        font = mGlyphTestingFont;\\n-    else {\\n-        gfxPangoFontNameMap *fontNameMap = gfxPangoFontNameMap::GetPangoFontNameMap();\\n-        NS_ENSURE_TRUE(fontNameMap, PR_FALSE);\\n-        // XXX in a prinsiple, we need to add weight and style for the key.\\n-        // But this method should be independent from pango for the performance.\\n-        // For the temporary, the name is enough for the key. The members of\\n-        // a font-family should have same glyphs.\\n-        NS_ConvertUTF16toUTF8 name(mName);\\n-        mGlyphTestingFont = fontNameMap->Get(name);\\n-        if (!mGlyphTestingFont) {\\n-            font = GetPangoFont();\\n-            NS_ENSURE_TRUE(font, PR_FALSE);\\n-        } else\\n-            font = mGlyphTestingFont;\\n-    }\\n-    return pango_fc_font_has_char(PANGO_FC_FONT(font), aChar) ? PR_TRUE : PR_FALSE;\\n-}\\n-\\n PRUint32\\n gfxPangoFont::GetGlyph(const PRUint32 aChar)\\n {\\n     // Ensure that null character should be missing.\\n     if (aChar == 0)\\n         return 0;\\n-    RealizePangoFont();\\n-    return pango_fc_font_get_glyph(PANGO_FC_FONT(mPangoFont), aChar);\\n+    return pango_fc_font_get_glyph(PANGO_FC_FONT(GetPangoFont()), aChar);\\n }\\n \\n nsString\\n@@ -732,16 +514,9 @@ gfxPangoFont::GetUniqueName()\\n {\\n     PangoFont *font = GetPangoFont();\\n     PangoFontDescription *desc = pango_font_describe(font);\\n+    pango_font_description_unset_fields (desc, PANGO_FONT_MASK_SIZE);\\n     char *str = pango_font_description_to_string(desc);\\n-\\n-    // chop off the trailing size, e.g. \\\"Albany AMT 15.359375\\\" -> \\\"Albany AMT\\\"\\n-    PRUint32 end = strlen(str);\\n-    while (end > 0) {\\n-        --end;\\n-        if (str[end] == ' ')\\n-            break;\\n-    }\\n-    str[end] = 0;\\n+    pango_font_description_free (desc);\\n \\n     nsString result;\\n     CopyUTF8toUTF16(str, result);\\n@@ -749,32 +524,6 @@ gfxPangoFont::GetUniqueName()\\n     return result;\\n }\\n \\n-static const char *sCJKLangGroup[] = {\\n-    \\\"ja\\\",\\n-    \\\"ko\\\",\\n-    \\\"zh-CN\\\",\\n-    \\\"zh-HK\\\",\\n-    \\\"zh-TW\\\"\\n-};\\n-\\n-#define COUNT_OF_CJK_LANG_GROUP 5\\n-#define CJK_LANG_JA    sCJKLangGroup[0]\\n-#define CJK_LANG_KO    sCJKLangGroup[1]\\n-#define CJK_LANG_ZH_CN sCJKLangGroup[2]\\n-#define CJK_LANG_ZH_HK sCJKLangGroup[3]\\n-#define CJK_LANG_ZH_TW sCJKLangGroup[4]\\n-\\n-static PRInt32\\n-GetCJKLangGroupIndex(const char *aLangGroup)\\n-{\\n-    PRInt32 i;\\n-    for (i = 0; i < COUNT_OF_CJK_LANG_GROUP; i++) {\\n-        if (!PL_strcasecmp(aLangGroup, sCJKLangGroup[i]))\\n-            return i;\\n-    }\\n-    return -1;\\n-}\\n-\\n /**\\n  ** gfxTextRun\\n  * \\n@@ -788,19 +537,6 @@ GetCJKLangGroupIndex(const char *aLangGroup)\\n  * \\n  **/\\n \\n-/**\\n- * We use this to append an LTR or RTL Override character to the start of the\\n- * string. This forces Pango to honour our direction even if there are neutral characters\\n- * in the string.\\n- */\\n-static PRInt32 AppendDirectionalIndicatorUTF8(PRBool aIsRTL, nsACString& aString)\\n-{\\n-    static const PRUnichar overrides[2][2] =\\n-      { { 0x202d, 0 }, { 0x202e, 0 }}; // LRO, RLO\\n-    AppendUTF16toUTF8(overrides[aIsRTL], aString);\\n-    return 3; // both overrides map to 3 bytes in UTF8\\n-}\\n-\\n gfxTextRun *\\n gfxPangoFontGroup::MakeTextRun(const PRUint8 *aString, PRUint32 aLength,\\n                                const Parameters *aParams, PRUint32 aFlags)\\n@@ -812,35 +548,33 @@ gfxPangoFontGroup::MakeTextRun(const PRUint8 *aString, PRUint32 aLength,\\n \\n     PRBool isRTL = run->IsRightToLeft();\\n     if ((aFlags & TEXT_IS_ASCII) && !isRTL) {\\n-        // We don't need to send an override character here, the characters must be all\\n-        // LTR\\n         const gchar *utf8Chars = reinterpret_cast<const gchar*>(aString);\\n-        InitTextRun(run, utf8Chars, aLength, 0, PR_TRUE);\\n+        InitTextRun(run, utf8Chars, aLength, PR_TRUE);\\n     } else {\\n+        // this is really gross...\\n         const char *chars = reinterpret_cast<const char*>(aString);\\n-        // XXX this could be more efficient.\\n-        // Although chars in not necessarily ASCII (as it may point to the low\\n-        // bytes of any UCS-2 characters < 256), NS_ConvertASCIItoUTF16 seems\\n-        // to DTRT.\\n         NS_ConvertASCIItoUTF16 unicodeString(chars, aLength);\\n-        nsCAutoString utf8;\\n-        PRInt32 headerLen = AppendDirectionalIndicatorUTF8(isRTL, utf8);\\n-        AppendUTF16toUTF8(unicodeString, utf8);\\n-        InitTextRun(run, utf8.get(), utf8.Length(), headerLen, PR_TRUE);\\n+        NS_ConvertUTF16toUTF8 utf8String(unicodeString);\\n+        InitTextRun(run, utf8String.get(), utf8String.Length(), PR_TRUE);\\n     }\\n     run->FetchGlyphExtents(aParams->mContext);\\n     return run;\\n }\\n \\n-static PRBool\\n-CanTakeFastPath(PRUint32 aFlags)\\n+#if defined(ENABLE_FAST_PATH_8BIT)\\n+PRBool\\n+gfxPangoFontGroup::CanTakeFastPath(PRUint32 aFlags)\\n {\\n+    if (!PANGO_IS_FC_FONT (GetFontAt(0)->GetPangoFont ()))\\n+        return FALSE;\\n+\\n     // Can take fast path only if OPTIMIZE_SPEED is set and IS_RTL isn't\\n     // We need to always use Pango for RTL text, in case glyph mirroring is required\\n     return (aFlags &\\n             (gfxTextRunFactory::TEXT_OPTIMIZE_SPEED | gfxTextRunFactory::TEXT_IS_RTL)) ==\\n         gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;\\n }\\n+#endif\\n \\n gfxTextRun *\\n gfxPangoFontGroup::MakeTextRun(const PRUnichar *aString, PRUint32 aLength,\\n@@ -852,11 +586,10 @@ gfxPangoFontGroup::MakeTextRun(const PRUnichar *aString, PRUint32 aLength,\\n \\n     run->RecordSurrogates(aString);\\n \\n-    nsCAutoString utf8;\\n-    PRInt32 headerLen = AppendDirectionalIndicatorUTF8(run->IsRightToLeft(), utf8);\\n-    AppendUTF16toUTF8(Substring(aString, aString + aLength), utf8);\\n+    NS_ConvertUTF16toUTF8 utf8(aString, aLength);\\n     PRBool is8Bit = PR_FALSE;\\n-#if defined(ENABLE_XFT_FAST_PATH_8BIT)\\n+\\n+#if defined(ENABLE_FAST_PATH_8BIT)\\n     if (CanTakeFastPath(aFlags)) {\\n         PRUint32 allBits = 0;\\n         PRUint32 i;\\n@@ -866,22 +599,21 @@ gfxPangoFontGroup::MakeTextRun(const PRUnichar *aString, PRUint32 aLength,\\n         is8Bit = (allBits & 0xFF00) == 0;\\n     }\\n #endif\\n-    InitTextRun(run, utf8.get(), utf8.Length(), headerLen, is8Bit);\\n+    InitTextRun(run, utf8.get(), utf8.Length(), is8Bit);\\n     run->FetchGlyphExtents(aParams->mContext);\\n     return run;\\n }\\n \\n void\\n gfxPangoFontGroup::InitTextRun(gfxTextRun *aTextRun, const gchar *aUTF8Text,\\n-                               PRUint32 aUTF8Length, PRUint32 aUTF8HeaderLength,\\n-                               PRBool aTake8BitPath)\\n+                               PRUint32 aUTF8Length, PRBool aTake8BitPath)\\n {\\n-#if defined(ENABLE_XFT_FAST_PATH_ALWAYS)\\n-    CreateGlyphRunsXft(aTextRun, aUTF8Text + aUTF8HeaderLength, aUTF8Length - aUTF8HeaderLength);\\n+#if defined(ENABLE_FAST_PATH_ALWAYS)\\n+    CreateGlyphRunsFast(aTextRun, aUTF8Text, aUTF8Length);\\n #else\\n-#if defined(ENABLE_XFT_FAST_PATH_8BIT)\\n+#if defined(ENABLE_FAST_PATH_8BIT)\\n     if (aTake8BitPath && CanTakeFastPath(aTextRun->GetFlags())) {\\n-        CreateGlyphRunsXft(aTextRun, aUTF8Text + aUTF8HeaderLength, aUTF8Length - aUTF8HeaderLength);\\n+        CreateGlyphRunsFast(aTextRun, aUTF8Text, aUTF8Length);\\n         return;\\n     }\\n #endif\\n@@ -890,13 +622,20 @@ gfxPangoFontGroup::InitTextRun(gfxTextRun *aTextRun, const gchar *aUTF8Text,\\n                                (aTextRun->IsRightToLeft()\\n                                   ? PANGO_DIRECTION_RTL : PANGO_DIRECTION_LTR));\\n \\n-    CreateGlyphRunsItemizing(aTextRun, aUTF8Text, aUTF8Length, aUTF8HeaderLength);\\n+    CreateGlyphRunsItemizing(aTextRun, aUTF8Text, aUTF8Length);\\n #endif\\n }\\n \\n static cairo_scaled_font_t*\\n CreateScaledFont(cairo_t *aCR, cairo_matrix_t *aCTM, PangoFont *aPangoFont)\\n {\\n+#if 0\\n+//XXX enalbe this #if defined(PANGO_VERSION_CHECK) && PANGO_VERSION_CHECK(1,17,5)\\n+    // Lets just use pango_cairo_font_get_scaled_font() for now.  it's only\\n+    // available in pango 1.17.x though :(\\n+    return cairo_scaled_font_reference (pango_cairo_font_get_scaled_font (PANGO_CAIRO_FONT (aPangoFont)));\\n+#else\\n+\\n     // XXX is this safe really? We should probably check the font type or something.\\n     // XXX does this really create the same font that Pango used for measurement?\\n     // We probably need to work harder here. We should pay particular attention\\n@@ -915,6 +654,7 @@ CreateScaledFont(cairo_t *aCR, cairo_matrix_t *aCTM, PangoFont *aPangoFont)\\n     cairo_font_options_destroy(fontOptions);\\n     cairo_font_face_destroy(face);\\n     return scaledFont;\\n+#endif\\n }\\n \\n PRBool\\n@@ -954,6 +694,8 @@ SetupClusterBoundaries(gfxTextRun* aTextRun, const gchar *aUTF8, PRUint32 aUTF8L\\n     if (aTextRun->GetFlags() & gfxTextRunFactory::TEXT_IS_8BIT) {\\n         // 8-bit text doesn't have clusters.\\n         // XXX is this true in all languages???\\n+\\t// behdad: don't think so.  Czech for example IIRC has a\\n+\\t// 'ch' grapheme.\\n         return;\\n     }\\n \\n@@ -1183,8 +925,9 @@ gfxPangoFontGroup::SetGlyphs(gfxTextRun *aTextRun, gfxPangoFont *aFont,\\n             gunichar ch = g_utf8_get_char(clusterUTF8);\\n             do { // Does pango ever provide more than one glyph in the cluster\\n                  // if there is a missing glyph?\\n+\\t\\t // behdad: yes\\n                 if (IS_MISSING_GLYPH(glyphs[glyphIndex].glyph)) {\\n-                    if (MOZ_pango_is_zero_width(ch)) {\\n+                    if (pango_is_zero_width(ch)) {\\n                         // the zero width characters returns empty glyph ID at shaping,\\n                         // we should override it if the font has the character.\\n                         glyphs[glyphIndex].glyph = aFont->GetGlyph(' ');\\n@@ -1244,15 +987,15 @@ gfxPangoFontGroup::SetMissingGlyphs(gfxTextRun *aTextRun,\\n     return NS_OK;\\n }\\n \\n-#if defined(ENABLE_XFT_FAST_PATH_8BIT) || defined(ENABLE_XFT_FAST_PATH_ALWAYS)\\n+#if defined(ENABLE_FAST_PATH_8BIT) || defined(ENABLE_FAST_PATH_ALWAYS)\\n void\\n-gfxPangoFontGroup::CreateGlyphRunsXft(gfxTextRun *aTextRun,\\n-                                      const gchar *aUTF8, PRUint32 aUTF8Length)\\n+gfxPangoFontGroup::CreateGlyphRunsFast(gfxTextRun *aTextRun,\\n+                                       const gchar *aUTF8, PRUint32 aUTF8Length)\\n {\\n     const gchar *p = aUTF8;\\n-    Display *dpy = GDK_DISPLAY();\\n     gfxPangoFont *font = GetFontAt(0);\\n-    XftFont *xfont = font->GetXftFont();\\n+    PangoFont *pangofont = font->GetPangoFont();\\n+    PangoFcFont *fcfont = PANGO_FC_FONT (pangofont);\\n     PRUint32 utf16Offset = 0;\\n     gfxTextRun::CompressedGlyph g;\\n     const PRUint32 appUnitsPerDevUnit = aTextRun->GetAppUnitsPerDevUnit();\\n@@ -1273,14 +1016,11 @@ gfxPangoFontGroup::CreateGlyphRunsXft(gfxTextRun *aTextRun,\\n             aTextRun->SetMissingGlyph(utf16Offset, 0);\\n         } else {\\n             NS_ASSERTION(!IsInvalidChar(ch), \\\"Invalid char detected\\\");\\n-            FT_UInt glyph = XftCharIndex(dpy, xfont, ch);\\n-            XGlyphInfo info;\\n-            XftGlyphExtents(dpy, xfont, &glyph, 1, &info);\\n-            if (info.yOff > 0) {\\n-                NS_WARNING(\\\"vertical offsets not supported\\\");\\n-            }\\n+            FT_UInt glyph = pango_fc_font_get_glyph (fcfont, ch);\\n+            PangoRectangle rect;\\n+            pango_font_get_glyph_extents (pangofont, glyph, NULL, &rect);\\n \\n-            PRInt32 advance = info.xOff*appUnitsPerDevUnit;\\n+            PRInt32 advance = PANGO_PIXELS (rect.width * appUnitsPerDevUnit);\\n             if (advance >= 0 &&\\n                 gfxTextRun::CompressedGlyph::IsSimpleAdvance(advance) &&\\n                 gfxTextRun::CompressedGlyph::IsSimpleGlyphID(glyph)) {\\n@@ -1314,320 +1054,93 @@ gfxPangoFontGroup::CreateGlyphRunsXft(gfxTextRun *aTextRun,\\n }\\n #endif\\n \\n-class FontSelector\\n+void \\n+gfxPangoFontGroup::CreateGlyphRunsItemizing(gfxTextRun *aTextRun,\\n+                                            const gchar *aUTF8, PRUint32 aUTF8Length)\\n {\\n-public:\\n-    FontSelector(const gchar *aString, PRInt32 aLength,\\n-                 gfxPangoFontGroup *aGroup, gfxTextRun *aTextRun,\\n-                 PangoItem *aItem, PRUint32 aUTF16Offset, PRPackedBool aIsRTL) :\\n-        mItem(aItem),\\n-        mGroup(aGroup), mTextRun(aTextRun), mString(aString),\\n-        mFontIndex(0), mLength(aLength), mUTF16Offset(aUTF16Offset),\\n-        mTriedPrefFonts(0), mTriedOtherFonts(0), mIsRTL(aIsRTL)\\n-    {\\n-        for (PRUint32 i = 0; i < mGroup->FontListLength(); ++i)\\n-            mFonts.AppendElement(mGroup->GetFontAt(i));\\n-        mSpaceWidth = NS_lround(mGroup->GetFontAt(0)->GetMetrics().spaceWidth * FLOAT_PANGO_SCALE);\\n-    }\\n-    \\n-    nsresult Run()\\n-    {\\n-        return InitSegments(mString, mLength);\\n-    }\\n \\n-    PRUint32 GetUTF16Offset() { return mUTF16Offset; }\\n+    PangoContext *context = gdk_pango_context_get ();\\n \\n-    static PRBool ExistsFont(FontSelector *aFs,\\n-                             const nsAString &aName) {\\n-        PRUint32 len = aFs->mFonts.Length();\\n-        for (PRUint32 i = 0; i < len; ++i) {\\n-            if (aName.Equals(aFs->mFonts[i]->GetName()))\\n-                return PR_TRUE;\\n-        }\\n-        return PR_FALSE;\\n-    }\\n-\\n-    static PRBool AddFontCallback(const nsAString &aName,\\n-                                  const nsACString &aGenericName,\\n-                                  void *closure) {\\n-        if (aName.IsEmpty())\\n-            return PR_TRUE;\\n-\\n-        FontSelector *fs = static_cast<FontSelector*>(closure);\\n-\\n-        // XXX do something better than this to remove dups\\n-        if (ExistsFont(fs, aName))\\n-            return PR_TRUE;\\n+    PangoFontDescription *fontDesc = pango_font_description_new();\\n \\n-        nsRefPtr<gfxPangoFont> font = GetOrMakeFont(aName, fs->mGroup->GetStyle());\\n-        if (font) {\\n-            fs->mFonts.AppendElement(font);\\n-        }\\n+    // these should be FontEntries or something similar rather than gfxPangoFonts...\\n+    nsString fontList;\\n \\n-        return PR_TRUE;\\n+    for (PRUint32 i = 0; i < mFonts.Length(); i++) {\\n+        fontList.Append(mFonts[i]->GetName());\\n+        fontList.Append(NS_LITERAL_STRING(\\\", \\\"));\\n     }\\n \\n-private:\\n-    PangoItem *mItem;\\n+    PangoLanguage *lang = GetPangoLanguage(GetStyle()->langGroup);\\n \\n-    nsTArray< nsRefPtr<gfxPangoFont> > mFonts;\\n+    pango_font_description_set_family(fontDesc, NS_ConvertUTF16toUTF8(fontList).get());\\n+    pango_font_description_set_absolute_size(fontDesc, GetStyle()->size * PANGO_SCALE);\\n+    pango_font_description_set_style(fontDesc, ThebesStyleToPangoStyle(GetStyle()));\\n+    pango_font_description_set_weight(fontDesc, ThebesStyleToPangoWeight(GetStyle()));\\n \\n-    gfxPangoFontGroup *mGroup;\\n-    gfxTextRun   *mTextRun;\\n-    const char        *mString; // UTF-8\\n-    PRUint32           mFontIndex;\\n-    PRInt32            mLength;\\n-    PRUint32           mUTF16Offset;\\n-    PRUint32           mSpaceWidth;\\n+    pango_context_set_font_description(context, fontDesc);\\n \\n-    PRPackedBool mTriedPrefFonts;\\n-    PRPackedBool mTriedOtherFonts;\\n-    PRPackedBool mIsRTL;\\n+    // we should set this to null if we don't have a text language from the page...\\n+    // except that we almost always have something...\\n+    pango_context_set_language(context, lang);\\n \\n-    nsresult InitSegments(const gchar *aUTF8, PRUint32 aLength) {\\n-        if (aLength == 0)\\n-            return NS_OK;\\n-        const gchar *start = aUTF8;\\n-        const gchar *last = start + aLength;\\n+    PangoDirection dir = aTextRun->IsRightToLeft() ? PANGO_DIRECTION_RTL : PANGO_DIRECTION_LTR;\\n+    GList *items = pango_itemize_with_base_dir(context, dir, aUTF8, 0, aUTF8Length, nsnull, nsnull);\\n \\n-RetryNextFont:\\n-        nsRefPtr<gfxPangoFont> font = GetNextFont();\\n-\\n-        // If we cannot found the font that has the current character glyph,\\n-        // we should return default font's missing data.\\n-        if (!font)\\n-            return AppendMissingSegment(start, last - start);\\n-\\n-        nsresult rv;\\n-        for (const gchar *c = start; c < last;) {\\n-            // find the first missing glyph\\n-            gunichar u = g_utf8_get_char(c);\\n-            if (font->HasGlyph(PRUint32(u))) {\\n-                c = g_utf8_next_char(c);\\n-                continue;\\n-            }\\n-\\n-            // find the next point that can be renderd with current font\\n-            const gchar *missingStart = c;\\n-            const gchar *next;\\n-            for (next = g_utf8_next_char(missingStart); next < last; next = g_utf8_next_char(next)) {\\n-                u = g_utf8_get_char(next);\\n-                if (font->HasGlyph(PRUint32(u)))\\n-                    break;\\n-            }\\n-\\n-            // current font has 0 glyphs for current segment, try with next font\\n-            if (missingStart == start && next == last)\\n-                goto RetryNextFont;\\n-\\n-            // create the segment for found glyphs\\n-            rv = AppendSegment(font, start, missingStart - start);\\n-            NS_ENSURE_SUCCESS(rv, rv);\\n+    PRUint32 utf16Offset = 0;\\n+    PRBool isRTL = aTextRun->IsRightToLeft();\\n+    GList *pos = items;\\n+    for (; pos && pos->data; pos = pos->next) {\\n+        PangoItem *item = (PangoItem *)pos->data;\\n+        NS_ASSERTION(isRTL == item->analysis.level % 2, \\\"RTL assumption mismatch\\\");\\n \\n-            // init the missing glyphs with remains fonts.\\n-            PRUint32 fontIndex = mFontIndex;\\n-            rv = InitSegments(missingStart, next - missingStart);\\n-            mFontIndex = fontIndex;\\n-            NS_ENSURE_SUCCESS(rv, rv);\\n+        PRUint32 offset = item->offset;\\n+        PRUint32 length = item->length;\\n \\n-            start = c = next;\\n-        }\\n+        // need to append glyph runs here.\\n+        PangoGlyphString *glyphString = pango_glyph_string_new();\\n+        if (!glyphString)\\n+            return; // OOM\\n \\n-        rv = AppendSegment(font, start, last - start);\\n-        NS_ENSURE_SUCCESS(rv, rv);\\n-        return NS_OK;\\n-    }\\n+        pango_shape(aUTF8 + offset, length, &item->analysis, glyphString);\\n \\n-    nsresult AppendSegment(gfxPangoFont* aFont, const gchar *aUTF8, PRUint32 aLength) {\\n-        if (aLength == 0)\\n-            return NS_OK;\\n+        /* look up the gfxPangoFont from the PangoFont */\\n+        // XXX we need a function to do this.. until then do this\\n+        // behdad: use g_object_[sg]et_qdata() for it.\\n+        PangoFontDescription *d = pango_font_describe(item->analysis.font);\\n+        nsRefPtr<gfxPangoFont> font = GetOrMakeFont(NS_ConvertUTF8toUTF16(pango_font_description_get_family(d)), GetStyle());\\n \\n-        PangoFont* pf = aFont->GetPangoFont();\\n+        //printf(\\\"Using %s\\\\n\\\", pango_font_description_get_family(d));\\n \\n-        PangoGlyphString *glyphString = pango_glyph_string_new();\\n-        if (!glyphString)\\n-            return NS_ERROR_OUT_OF_MEMORY;\\n-        PangoFont *tmpFont = mItem->analysis.font;\\n-        mItem->analysis.font = pf;\\n-        pango_shape(aUTF8, aLength, &mItem->analysis, glyphString);\\n-        mItem->analysis.font = tmpFont;\\n+        pango_font_description_free(d);\\n+        SetupClusterBoundaries(aTextRun, aUTF8 + offset, length, utf16Offset, &item->analysis);\\n \\n-        nsresult rv = mTextRun->AddGlyphRun(aFont, mUTF16Offset);\\n+        nsresult rv = aTextRun->AddGlyphRun(font, utf16Offset, PR_TRUE);\\n         if (NS_FAILED(rv)) {\\n             NS_ERROR(\\\"AddGlyphRun Failed\\\");\\n             pango_glyph_string_free(glyphString);\\n-            return rv;\\n+            return;\\n         }\\n-        PRUint32 utf16Offset = mUTF16Offset;\\n-        rv = mGroup->SetGlyphs(mTextRun, aFont, aUTF8, aLength,\\n-                               &utf16Offset, glyphString, mSpaceWidth, PR_FALSE);\\n-        pango_glyph_string_free(glyphString);\\n-        NS_ENSURE_SUCCESS(rv, rv);\\n \\n-        mUTF16Offset = utf16Offset;\\n-        return NS_OK;\\n-    }\\n-\\n-    nsresult AppendMissingSegment(const gchar *aUTF8, PRUint32 aLength) {\\n-        if (aLength == 0)\\n-            return NS_OK;\\n+        PRUint32 spaceWidth = NS_lround(font->GetMetrics().spaceWidth * FLOAT_PANGO_SCALE);\\n \\n-        nsresult rv = mTextRun->AddGlyphRun(mFonts[0], mUTF16Offset);\\n-        NS_ENSURE_SUCCESS(rv, rv);\\n-        PRUint32 utf16Offset = mUTF16Offset;\\n-        rv = mGroup->SetMissingGlyphs(mTextRun, aUTF8, aLength, &utf16Offset);\\n-        NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-        mUTF16Offset = utf16Offset;\\n-        return NS_OK;\\n-    }\\n+        rv = SetGlyphs(aTextRun, font, aUTF8 + offset, length, &utf16Offset, glyphString, spaceWidth, PR_FALSE);\\n \\n-    gfxPangoFont *GetNextFont() {\\n-TRY_AGAIN_HOPE_FOR_THE_BEST_2:\\n-        if (mFontIndex < mFonts.Length()) {\\n-            return mFonts[mFontIndex++];\\n-        } else if (!mTriedPrefFonts) {\\n-            mTriedPrefFonts = PR_TRUE;\\n-            nsCAutoString mozLang;\\n-            GetMozLanguage(mItem->analysis.language, mozLang);\\n-            if (!mozLang.IsEmpty()) {\\n-                PRInt32 index = GetCJKLangGroupIndex(mozLang.get());\\n-                if (index >= 0)\\n-                    AppendCJKPrefFonts();\\n-                else\\n-                    AppendPrefFonts(mozLang.get());\\n-            } else {\\n-                NS_ConvertUTF8toUTF16 str(mString);\\n-                PRBool appenedCJKFonts = PR_FALSE;\\n-                for (PRUint32 i = 0; i < str.Length(); ++i) {\\n-                    const PRUnichar ch = str[i];\\n-                    PRUint32 unicodeRange = FindCharUnicodeRange(ch);\\n-\\n-                    /* special case CJK */\\n-                    if (unicodeRange == kRangeSetCJK) {\\n-                        if (!appenedCJKFonts) {\\n-                            appenedCJKFonts = PR_TRUE;\\n-                            AppendCJKPrefFonts();\\n-                        }\\n-                    } else {\\n-                        const char *langGroup =\\n-                            LangGroupFromUnicodeRange(unicodeRange);\\n-                        if (langGroup)\\n-                            AppendPrefFonts(langGroup);\\n-                    }\\n-                }\\n-            }\\n-            goto TRY_AGAIN_HOPE_FOR_THE_BEST_2;\\n-        } else if (!mTriedOtherFonts) {\\n-            mTriedOtherFonts = PR_TRUE;\\n-            // XXX we should try by all system fonts\\n-            goto TRY_AGAIN_HOPE_FOR_THE_BEST_2;\\n-        }\\n-        return nsnull;\\n+        pango_glyph_string_free(glyphString);\\n     }\\n \\n-    void AppendPrefFonts(const char *aLangGroup) {\\n-        NS_ASSERTION(aLangGroup, \\\"aLangGroup is null\\\");\\n-        gfxPlatform *platform = gfxPlatform::GetPlatform();\\n-        nsString fonts;\\n-        platform->GetPrefFonts(aLangGroup, fonts);\\n-        if (fonts.IsEmpty())\\n-            return;\\n-        gfxFontGroup::ForEachFont(fonts, nsDependentCString(aLangGroup),\\n-                                  FontSelector::AddFontCallback, this);\\n-        return;\\n-   }\\n-\\n-   void AppendCJKPrefFonts() {\\n-       nsCOMPtr<nsIPrefService> prefs =\\n-           do_GetService(NS_PREFSERVICE_CONTRACTID);\\n-       if (!prefs)\\n-           return;\\n-\\n-       nsCOMPtr<nsIPrefBranch> prefBranch;\\n-       prefs->GetBranch(0, getter_AddRefs(prefBranch));\\n-       if (!prefBranch)\\n-           return;\\n-\\n-       // Add the accept languages.\\n-       nsXPIDLCString list;\\n-       nsresult rv = prefBranch->GetCharPref(\\\"intl.accept_languages\\\",\\n-                                             getter_Copies(list));\\n-       if (NS_SUCCEEDED(rv) && !list.IsEmpty()) {\\n-           const char kComma = ',';\\n-           const char *p, *p_end;\\n-           list.BeginReading(p);\\n-           list.EndReading(p_end);\\n-           while (p < p_end) {\\n-               while (nsCRT::IsAsciiSpace(*p)) {\\n-                   if (++p == p_end)\\n-                       break;\\n-               }\\n-               if (p == p_end)\\n-                   break;\\n-               const char *start = p;\\n-               while (++p != p_end && *p != kComma)\\n-                   /* nothing */ ;\\n-               nsCAutoString lang(Substring(start, p));\\n-               lang.CompressWhitespace(PR_FALSE, PR_TRUE);\\n-               PRInt32 index = GetCJKLangGroupIndex(lang.get());\\n-               if (index >= 0)\\n-                   AppendPrefFonts(sCJKLangGroup[index]);\\n-               p++;\\n-           }\\n-       }\\n-\\n-       // XXX I think that we should append system locale here if it is CJK.\\n-\\n-       // last resort...\\n-       AppendPrefFonts(CJK_LANG_JA);\\n-       AppendPrefFonts(CJK_LANG_KO);\\n-       AppendPrefFonts(CJK_LANG_ZH_CN);\\n-       AppendPrefFonts(CJK_LANG_ZH_HK);\\n-       AppendPrefFonts(CJK_LANG_ZH_TW);\\n-    }\\n-};\\n+    if (items)\\n+        g_list_free(items);\\n \\n-void \\n-gfxPangoFontGroup::CreateGlyphRunsItemizing(gfxTextRun *aTextRun,\\n-                                            const gchar *aUTF8, PRUint32 aUTF8Length,\\n-                                            PRUint32 aUTF8HeaderLen)\\n-{\\n-    GList *items = pango_itemize(GetFontAt(0)->GetPangoContext(), aUTF8, 0,\\n-                                 aUTF8Length, nsnull, nsnull);\\n-    \\n-    PRUint32 utf16Offset = 0;\\n-    PRBool isRTL = aTextRun->IsRightToLeft();\\n-    GList *pos = items;\\n-    for (; pos && pos->data; pos = pos->next) {\\n-        PangoItem *item = (PangoItem *)pos->data;\\n-        NS_ASSERTION(isRTL == item->analysis.level % 2, \\\"RTL assumption mismatch\\\");\\n+    pango_font_description_free(fontDesc);\\n \\n-        PRUint32 offset = item->offset;\\n-        PRUint32 length = item->length;\\n-        if (offset < aUTF8HeaderLen) {\\n-            if (offset + length <= aUTF8HeaderLen) {\\n-                pango_item_free(item);\\n-                continue;\\n-            }\\n-            length -= aUTF8HeaderLen - offset;\\n-            offset = aUTF8HeaderLen;\\n-        }\\n-        \\n-        SetupClusterBoundaries(aTextRun, aUTF8 + offset, length, utf16Offset, &item->analysis);\\n-        FontSelector fs(aUTF8 + offset, length, this, aTextRun, item, utf16Offset, isRTL);\\n-        fs.Run(); // appends GlyphRuns\\n-        utf16Offset = fs.GetUTF16Offset();\\n-        pango_item_free(item);\\n-    }\\n+    g_object_unref(context);\\n \\n-    NS_ASSERTION(utf16Offset == aTextRun->GetLength(),\\n-                 \\\"Didn't resolve all characters\\\");\\n-  \\n-    if (items)\\n-        g_list_free(items);\\n+    aTextRun->SortGlyphRuns();\\n }\\n \\n+\\n+\\n /**\\n  ** language group helpers\\n  **/\\n@@ -1696,7 +1209,7 @@ GetPangoLanguage(const nsACString& cname)\\n     else if (langGroup->PangoLang) \\n         return pango_language_from_string(langGroup->PangoLang);\\n \\n-    return pango_language_from_string(\\\"en\\\");\\n+    return nsnull;\\n }\\n \\n // See pango-script-lang-table.h in pango.\\n@@ -1880,38 +1393,7 @@ static const MozPangoLangGroup PangoAllLangGroup[] = {\\n     { \\\"x-western\\\",      \\\"zu\\\"    },\\n };\\n \\n-#define NUM_PANGO_ALL_LANG_GROUPS (sizeof (PangoAllLangGroup) / \\\\\\n-                                   sizeof (PangoAllLangGroup[0]))\\n-\\n-/* static */\\n-void\\n-GetMozLanguage(const PangoLanguage *aLang, nsACString &aMozLang)\\n-{\\n-    aMozLang.Truncate();\\n-    if (!aLang)\\n-        return;\\n-\\n-    nsCAutoString lang(pango_language_to_string(aLang));\\n-    if (lang.IsEmpty() || lang.Equals(\\\"xx\\\"))\\n-        return;\\n-\\n-    while (1) {\\n-        for (PRUint32 i = 0; i < NUM_PANGO_ALL_LANG_GROUPS; ++i) {\\n-            if (lang.Equals(PangoAllLangGroup[i].PangoLang)) {\\n-                if (PangoAllLangGroup[i].mozLangGroup)\\n-                    aMozLang.Assign(PangoAllLangGroup[i].mozLangGroup);\\n-                return;\\n-            }\\n-        }\\n-\\n-        PRInt32 hyphen = lang.FindChar('-');\\n-        if (hyphen != kNotFound) {\\n-            lang.Cut(hyphen, lang.Length());\\n-            continue;\\n-        }\\n-        break;\\n-    }\\n-}\\n+#define NUM_PANGO_ALL_LANG_GROUPS (G_N_ELEMENTS (PangoAllLangGroup))\\n \\n gfxPangoFontCache::gfxPangoFontCache()\\n {\\n@@ -1945,39 +1427,3 @@ gfxPangoFontCache::Get(const PangoFontDescription *aFontDesc)\\n     g_object_ref(font);\\n     return font;\\n }\\n-\\n-gfxPangoFontNameMap::gfxPangoFontNameMap()\\n-{\\n-    mPangoFonts.Init(100);\\n-}\\n-\\n-gfxPangoFontNameMap::~gfxPangoFontNameMap()\\n-{\\n-}\\n-\\n-void\\n-gfxPangoFontNameMap::Put(const nsACString &aName, PangoFont *aPangoFont)\\n-{\\n-    nsCAutoString key(aName);\\n-    ToLowerCase(key);\\n-    gfxPangoFontWrapper *value;\\n-    if (!mPangoFonts.Get(key, &value)) {\\n-        value = new gfxPangoFontWrapper(aPangoFont);\\n-        if (!value)\\n-            return;\\n-        mPangoFonts.Put(key, value);\\n-    }\\n-}\\n-\\n-PangoFont*\\n-gfxPangoFontNameMap::Get(const nsACString &aName)\\n-{\\n-    nsCAutoString key(aName);\\n-    ToLowerCase(key);\\n-    gfxPangoFontWrapper *value;\\n-    if (!mPangoFonts.Get(key, &value))\\n-        return nsnull;\\n-    PangoFont *font = value->Get();\\n-    g_object_ref(font);\\n-    return font;\\n-}\\ndiff --git a/gfx/thebes/src/gfxPlatformGtk.cpp b/gfx/thebes/src/gfxPlatformGtk.cpp\\nindex 4d5f4e0..826f997 100644\\n--- a/gfx/thebes/src/gfxPlatformGtk.cpp\\n+++ b/gfx/thebes/src/gfxPlatformGtk.cpp\\n@@ -60,12 +60,6 @@\\n \\n #include <fontconfig/fontconfig.h>\\n \\n-#ifndef THEBES_USE_PANGO_CAIRO\\n-#include <pango/pangoxft.h>\\n-#endif // THEBES_USE_PANGO_CAIRO\\n-\\n-#include <pango/pango-font.h>\\n-\\n #include \\\"nsMathUtils.h\\\"\\n \\n #include \\\"lcms.h\\\"\\n@@ -89,6 +83,8 @@ gfxPlatformGtk::gfxPlatformGtk()\\n #endif\\n     if (!sFontconfigUtils)\\n         sFontconfigUtils = gfxFontconfigUtils::GetFontconfigUtils();\\n+\\n+    InitDPI();\\n }\\n \\n gfxPlatformGtk::~gfxPlatformGtk()\\n@@ -98,10 +94,6 @@ gfxPlatformGtk::~gfxPlatformGtk()\\n \\n     gfxPangoFont::Shutdown();\\n \\n-#ifndef THEBES_USE_PANGO_CAIRO\\n-    pango_xft_shutdown_display(GDK_DISPLAY(), 0);\\n-#endif\\n-\\n #if 0\\n     // It would be nice to do this (although it might need to be after\\n     // the cairo shutdown that happens in ~gfxPlatform).  It even looks\\n@@ -278,93 +270,17 @@ gfxPlatformGtk::CreateFontGroup(const nsAString &aFamilies,\\n     return new gfxPangoFontGroup(aFamilies, aStyle);\\n }\\n \\n-static PRInt32\\n-GetXftDPI()\\n-{\\n-  char *val = XGetDefault(GDK_DISPLAY(), \\\"Xft\\\", \\\"dpi\\\");\\n-  if (val) {\\n-    char *e;\\n-    double d = strtod(val, &e);\\n-\\n-    if (e != val)\\n-      return NS_lround(d);\\n-  }\\n-\\n-  return -1;\\n-}\\n-\\n-static PRInt32\\n-GetDPIFromPangoFont()\\n-{\\n-#ifndef THEBES_USE_PANGO_CAIRO\\n-    PangoContext* ctx = pango_xft_get_context(GDK_DISPLAY(), 0);\\n-    gdk_pango_context_set_colormap(ctx, gdk_rgb_get_cmap());\\n-#else\\n-    PangoContext* ctx =\\n-        pango_cairo_font_map_create_context(\\n-          PANGO_CAIRO_FONT_MAP(pango_cairo_font_map_get_default()));\\n-#endif\\n-\\n-    if (!ctx) {\\n-        return 0;\\n-    }\\n-\\n-    double dblDPI = 0.0f;\\n-    GList *items = nsnull;\\n-    PangoItem *item = nsnull;\\n-    PangoFcFont *fcfont = nsnull;\\n-    \\n-    PangoAttrList *al = pango_attr_list_new();\\n-\\n-    if (!al) {\\n-        goto cleanup;\\n-    }\\n-\\n-    // Just using the string \\\"a\\\" because we need _some_ text.\\n-    items = pango_itemize(ctx, \\\"a\\\", 0, 1, al, NULL);\\n-\\n-    if (!items) {\\n-        goto cleanup;\\n-    }\\n-\\n-    item = (PangoItem*)items->data;\\n-\\n-    if (!item) {\\n-        goto cleanup;\\n-    }\\n-\\n-    fcfont = PANGO_FC_FONT(item->analysis.font);\\n-\\n-    if (!fcfont) {\\n-        goto cleanup;\\n-    }\\n-\\n-    FcPatternGetDouble(fcfont->font_pattern, FC_DPI, 0, &dblDPI);\\n-\\n- cleanup:   \\n-    if (al)\\n-        pango_attr_list_unref(al);\\n-    if (item)\\n-        pango_item_free(item);\\n-    if (items)\\n-        g_list_free(items);\\n-    if (ctx)\\n-        g_object_unref(ctx);\\n-\\n-    return NS_lround(dblDPI);\\n-}\\n-\\n /* static */\\n void\\n gfxPlatformGtk::InitDPI()\\n {\\n-    sDPI = GetXftDPI();\\n+    PangoContext *context = gdk_pango_context_get ();\\n+    sDPI = pango_cairo_context_get_resolution (context);\\n+    g_object_unref (context);\\n+\\n     if (sDPI <= 0) {\\n-        sDPI = GetDPIFromPangoFont();\\n-        if (sDPI <= 0) {\\n-            // Fall back to something sane\\n-            sDPI = 96;\\n-        }\\n+\\t// Fall back to something sane\\n+\\tsDPI = 96;\\n     }\\n }\\n \\n\""}