{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas5e31bd0\""},"diff":"\"5e31bd0 Bug 367673, Handle width-computation arithmetic with nscoord_MAX. r=roc sr=roc a1.9=roc\\ndiff --git a/gfx/public/nsCoord.h b/gfx/public/nsCoord.h\\nindex e90259a..00874c1 100644\\n--- a/gfx/public/nsCoord.h\\n+++ b/gfx/public/nsCoord.h\\n@@ -122,6 +122,103 @@ inline nscoord NSCoordDivide(nscoord aCoord, PRInt32 aVal) {\\n }\\n \\n /**\\n+ * Returns a + b, capping the sum to nscoord_MAX.\\n+ *\\n+ * This function assumes that neither argument is nscoord_MIN.\\n+ *\\n+ * Note: If/when we start using floats for nscoords, this function won't be as\\n+ * necessary.  Normal float addition correctly handles adding with infinity,\\n+ * assuming we aren't adding nscoord_MIN. (-infinity)\\n+ */\\n+inline nscoord\\n+NSCoordSaturatingAdd(nscoord a, nscoord b)\\n+{\\n+  VERIFY_COORD(a);\\n+  VERIFY_COORD(b);\\n+  NS_ASSERTION(a != nscoord_MIN && b != nscoord_MIN,\\n+               \\\"NSCoordSaturatingAdd got nscoord_MIN as argument\\\");\\n+\\n+#ifdef NS_COORD_IS_FLOAT\\n+  // Float math correctly handles a+b, given that neither is -infinity.\\n+  return a + b;\\n+#else\\n+  if (a == nscoord_MAX || b == nscoord_MAX) {\\n+    // infinity + anything = anything + infinity = infinity\\n+    return nscoord_MAX;\\n+  } else {\\n+    // a + b = a + b\\n+    NS_ASSERTION(a < nscoord_MAX && b < nscoord_MAX,\\n+                 \\\"Doing nscoord addition with values > nscoord_MAX\\\");\\n+    NS_ASSERTION((PRInt64)a + (PRInt64)b < (PRInt64)nscoord_MAX,\\n+                 \\\"nscoord addition will reach or pass nscoord_MAX\\\");\\n+    NS_ASSERTION((PRInt64)a + (PRInt64)b > (PRInt64)nscoord_MIN,\\n+                 \\\"nscoord addition will reach or pass nscoord_MIN\\\");\\n+\\n+    // Cap the result, just in case we're dealing with numbers near nscoord_MAX\\n+    return PR_MIN(nscoord_MAX, a + b);\\n+  }\\n+#endif\\n+}\\n+\\n+/**\\n+ * Returns a - b, gracefully handling cases involving nscoord_MAX.\\n+ * This function assumes that neither argument is nscoord_MIN.\\n+ *\\n+ * The behavior is as follows:\\n+ *\\n+ *  a)  infinity - infinity -> infMinusInfResult\\n+ *  b)  N - infinity        -> 0  (unexpected -- triggers NOTREACHED)\\n+ *  c)  infinity - N        -> infinity\\n+ *  d)  N1 - N2             -> N1 - N2\\n+ *\\n+ * Note: For float nscoords, cases (c) and (d) are handled by normal float\\n+ * math.  We still need to explicitly specify the behavior for cases (a)\\n+ * and (b), though.  (Under normal float math, those cases would return NaN\\n+ * and -infinity, respectively.)\\n+ */\\n+inline nscoord \\n+NSCoordSaturatingSubtract(nscoord a, nscoord b, \\n+                          nscoord infMinusInfResult)\\n+{\\n+  VERIFY_COORD(a);\\n+  VERIFY_COORD(b);\\n+  NS_ASSERTION(a != nscoord_MIN && b != nscoord_MIN,\\n+               \\\"NSCoordSaturatingSubtract got nscoord_MIN as argument\\\");\\n+\\n+  if (b == nscoord_MAX) {\\n+    if (a == nscoord_MAX) {\\n+      // case (a)\\n+      return infMinusInfResult;\\n+    } else {\\n+      // case (b)\\n+      NS_NOTREACHED(\\\"Attempted to subtract [n - nscoord_MAX]\\\");\\n+      return 0;\\n+    }\\n+  } else {\\n+#ifdef NS_COORD_IS_FLOAT\\n+    // case (c) and (d) for floats.  (float math handles both)\\n+    return a - b;\\n+#else\\n+    if (a == nscoord_MAX) {\\n+      // case (c) for integers\\n+      return nscoord_MAX;\\n+    } else {\\n+      // case (d) for integers\\n+      NS_ASSERTION(a < nscoord_MAX && b < nscoord_MAX,\\n+                   \\\"Doing nscoord subtraction with values > nscoord_MAX\\\");\\n+      NS_ASSERTION((PRInt64)a - (PRInt64)b < (PRInt64)nscoord_MAX,\\n+                   \\\"nscoord subtraction will reach or pass nscoord_MAX\\\");\\n+      NS_ASSERTION((PRInt64)a - (PRInt64)b > (PRInt64)nscoord_MIN,\\n+                   \\\"nscoord subtraction will reach or pass nscoord_MIN\\\");\\n+\\n+      // Cap the result, in case we're dealing with numbers near nscoord_MAX\\n+      return PR_MIN(nscoord_MAX, a - b);\\n+    }\\n+  }\\n+#endif\\n+}\\n+\\n+/**\\n  * Convert an nscoord to a PRInt32. This *does not* do rounding because\\n  * coords are never fractional. They can be out of range, so this does\\n  * clamp out of bounds coord values to PR_INT32_MIN and PR_INT32_MAX.\\ndiff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp\\nindex 08c4c0e..a46beff 100644\\n--- a/layout/base/nsLayoutUtils.cpp\\n+++ b/layout/base/nsLayoutUtils.cpp\\n@@ -1508,7 +1508,7 @@ nsLayoutUtils::IntrinsicForContainer(nsIRenderingContext *aRenderingContext,\\n \\n   if (boxSizing == NS_STYLE_BOX_SIZING_PADDING) {\\n     min += coordOutsideWidth;\\n-    result += coordOutsideWidth;\\n+    result = NSCoordSaturatingAdd(result, coordOutsideWidth);\\n     pctTotal += pctOutsideWidth;\\n \\n     coordOutsideWidth = 0;\\n@@ -1519,7 +1519,7 @@ nsLayoutUtils::IntrinsicForContainer(nsIRenderingContext *aRenderingContext,\\n \\n   if (boxSizing == NS_STYLE_BOX_SIZING_BORDER) {\\n     min += coordOutsideWidth;\\n-    result += coordOutsideWidth;\\n+    result = NSCoordSaturatingAdd(result, coordOutsideWidth);\\n     pctTotal += pctOutsideWidth;\\n \\n     coordOutsideWidth = 0;\\n@@ -1530,7 +1530,7 @@ nsLayoutUtils::IntrinsicForContainer(nsIRenderingContext *aRenderingContext,\\n   pctOutsideWidth += offsets.hPctMargin;\\n \\n   min += coordOutsideWidth;\\n-  result += coordOutsideWidth;\\n+  result = NSCoordSaturatingAdd(result, coordOutsideWidth);\\n   pctTotal += pctOutsideWidth;\\n \\n   nscoord w;\\ndiff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp\\nindex 7025762..758d880 100644\\n--- a/layout/generic/nsFrame.cpp\\n+++ b/layout/generic/nsFrame.cpp\\n@@ -2790,8 +2790,9 @@ nsFrame::AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,\\n {\\n   aData->trailingWhitespace = 0;\\n   aData->skipWhitespace = PR_FALSE;\\n-  aData->currentLine += nsLayoutUtils::IntrinsicForContainer(aRenderingContext,\\n-                            this, nsLayoutUtils::PREF_WIDTH);\\n+  nscoord myPref = nsLayoutUtils::IntrinsicForContainer(aRenderingContext, \\n+                       this, nsLayoutUtils::PREF_WIDTH);\\n+  aData->currentLine = NSCoordSaturatingAdd(aData->currentLine, myPref);\\n }\\n \\n void\\ndiff --git a/layout/tables/BasicTableLayoutStrategy.cpp b/layout/tables/BasicTableLayoutStrategy.cpp\\nindex f565931..9eb291c 100644\\n--- a/layout/tables/BasicTableLayoutStrategy.cpp\\n+++ b/layout/tables/BasicTableLayoutStrategy.cpp\\n@@ -219,7 +219,7 @@ GetWidthInfo(nsIRenderingContext *aRenderingContext,\\n         // XXX Should we ignore percentage padding?\\n         nscoord add = offsets.hPadding + offsets.hBorder;\\n         minCoord += add;\\n-        prefCoord += add;\\n+        prefCoord = NSCoordSaturatingAdd(prefCoord, add);\\n     }\\n \\n     return CellWidthInfo(minCoord, prefCoord, prefPercent, hasSpecifiedWidth);\\n@@ -490,8 +490,10 @@ BasicTableLayoutStrategy::ComputeColumnIntrinsicWidths(nsIRenderingContext* aRen\\n                     NSToCoordRound(float(minWithinPref) * minRatio);\\n                 nscoord allocatedMinOutsidePref =\\n                     NSToCoordRound(float(minOutsidePref) * coordRatio);\\n-                nscoord allocatedPref =\\n-                    NSToCoordRound(float(info.prefCoord) * coordRatio);\\n+                nscoord allocatedPref = \\n+                    (info.prefCoord == nscoord_MAX ? \\n+                     nscoord_MAX : \\n+                     NSToCoordRound(float(info.prefCoord) * coordRatio));\\n                 nscoord spanMin = scolFrame->GetMinCoord() +\\n                         allocatedMinWithinPref + allocatedMinOutsidePref;\\n                 nscoord spanPref = scolFrame->GetPrefCoord() + allocatedPref;\\n@@ -503,7 +505,9 @@ BasicTableLayoutStrategy::ComputeColumnIntrinsicWidths(nsIRenderingContext* aRen\\n                 // passed from the totals.\\n                 minWithinPref -= allocatedMinWithinPref;\\n                 minOutsidePref -= allocatedMinOutsidePref;\\n-                info.prefCoord -= allocatedPref;\\n+                info.prefCoord = NSCoordSaturatingSubtract(info.prefCoord, \\n+                                                           allocatedPref,\\n+                                                           nscoord_MAX);\\n                 info.prefPercent -= allocatedPct;\\n                 totalSPref -= scolFrame->GetPrefCoord();\\n                 totalSMin -= scolFrame->GetMinCoord();\\n@@ -521,7 +525,8 @@ BasicTableLayoutStrategy::ComputeColumnIntrinsicWidths(nsIRenderingContext* aRen\\n             NS_ASSERTION(totalSPref == 0 && totalSMin == 0 &&\\n                          totalSNonPctPref == 0 && nonPctCount == 0 &&\\n                          minOutsidePref == 0 && minWithinPref == 0 &&\\n-                         info.prefCoord == 0 &&\\n+                         (info.prefCoord == 0 || \\n+                          info.prefCoord == nscoord_MAX) &&\\n                          (info.prefPercent == 0.0f || !spanHasNonPct),\\n                          \\\"didn't subtract all that we added\\\");\\n         } while ((item = item->next));\\n@@ -593,7 +598,7 @@ BasicTableLayoutStrategy::ComputeIntrinsicWidths(nsIRenderingContext* aRendering\\n             add += spacing;\\n         }\\n         min += colFrame->GetMinCoord();\\n-        pref += colFrame->GetPrefCoord();\\n+        pref = NSCoordSaturatingAdd(pref, colFrame->GetPrefCoord());\\n \\n         // Percentages are of the table, so we have to reverse them for\\n         // intrinsic widths.\\n@@ -640,8 +645,8 @@ BasicTableLayoutStrategy::ComputeIntrinsicWidths(nsIRenderingContext* aRendering\\n     // border-spacing isn't part of the basis for percentages\\n     if (colCount > 0) {\\n         min += add;\\n-        pref += add;\\n-        pref_pct_expand += add;\\n+        pref = NSCoordSaturatingAdd(pref, add);\\n+        pref_pct_expand = NSCoordSaturatingAdd(pref_pct_expand, add);\\n     }\\n \\n     mMinWidth = min;\\n@@ -749,6 +754,7 @@ BasicTableLayoutStrategy::ComputeColumnWidths(const nsHTMLReflowState& aReflowSt\\n             total_flex_pref = 0,\\n             total_fixed_pref = 0;\\n     float total_pct = 0.0f; // 0.0f to 1.0f\\n+    PRInt32 numInfiniteWidthCols = 0;\\n \\n     PRInt32 col;\\n     for (col = 0; col < colCount; ++col) {\\n@@ -769,19 +775,26 @@ BasicTableLayoutStrategy::ComputeColumnWidths(const nsHTMLReflowState& aReflowSt\\n             guess_pref += val;\\n         } else {\\n             nscoord pref_width = colFrame->GetPrefCoord();\\n-            guess_pref += pref_width;\\n+            if (pref_width == nscoord_MAX) {\\n+                numInfiniteWidthCols++;\\n+            }\\n+            guess_pref = NSCoordSaturatingAdd(guess_pref, pref_width);\\n             guess_min_pct += min_width;\\n             if (colFrame->GetHasSpecifiedCoord()) {\\n                 // we'll add on the rest of guess_min_spec outside the\\n                 // loop\\n-                guess_min_spec += pref_width - min_width;\\n-                total_fixed_pref += pref_width;\\n+                nscoord delta = NSCoordSaturatingSubtract(pref_width, \\n+                                                          min_width, 0);\\n+                guess_min_spec = NSCoordSaturatingAdd(guess_min_spec, delta);\\n+                total_fixed_pref = NSCoordSaturatingAdd(total_fixed_pref, \\n+                                                        pref_width);\\n             } else {\\n-                total_flex_pref += pref_width;\\n+                total_flex_pref = NSCoordSaturatingAdd(total_flex_pref,\\n+                                                       pref_width);\\n             }\\n         }\\n     }\\n-    guess_min_spec += guess_min_pct;\\n+    guess_min_spec = NSCoordSaturatingAdd(guess_min_spec, guess_min_pct);\\n \\n     // Determine what we're flexing:\\n     enum Loop2Type {\\n@@ -812,13 +825,18 @@ BasicTableLayoutStrategy::ComputeColumnWidths(const nsHTMLReflowState& aReflowSt\\n         } else if (width < guess_min_spec) {\\n             l2t = FLEX_FIXED_SMALL;\\n             space = width - guess_min_pct;\\n-            basis.c = guess_min_spec - guess_min_pct;\\n+            basis.c = NSCoordSaturatingSubtract(guess_min_spec, guess_min_pct,\\n+                                                nscoord_MAX);\\n         } else {\\n             l2t = FLEX_FLEX_SMALL;\\n             space = width - guess_min_spec;\\n-            basis.c = guess_pref - guess_min_spec;\\n+            basis.c = NSCoordSaturatingSubtract(guess_pref, guess_min_spec,\\n+                                                nscoord_MAX);\\n         }\\n     } else {\\n+        // Note: Shouldn't have to check for nscoord_MAX in this case, because\\n+        // width should be much less than nscoord_MAX, and being here means\\n+        // guess_pref is no larger than width.\\n         space = width - guess_pref;\\n         if (total_flex_pref > 0) {\\n             l2t = FLEX_FLEX_LARGE;\\n@@ -903,11 +921,30 @@ BasicTableLayoutStrategy::ComputeColumnWidths(const nsHTMLReflowState& aReflowSt\\n                     NS_ASSERTION(col_width == colFrame->GetPrefCoord(),\\n                                  \\\"wrong width assigned\\\");\\n                     nscoord col_min = colFrame->GetMinCoord();\\n-                    nscoord pref_minus_min = col_width - col_min;\\n+                    nscoord pref_minus_min = \\n+                        NSCoordSaturatingSubtract(col_width, col_min, 0);\\n                     col_width = col_width_before_adjust = col_min;\\n                     if (pref_minus_min != 0) {\\n                         float c = float(space) / float(basis.c);\\n-                        basis.c -= pref_minus_min;\\n+                        // If we have infinite-width cols, then the standard\\n+                        // adjustment to col_width using 'c' won't work,\\n+                        // because basis.c and pref_minus_min are both\\n+                        // nscoord_MAX and will cancel each other out in the\\n+                        // col_width adjustment (making us assign all the\\n+                        // space to the first inf-width col).  To correct for\\n+                        // this, we'll also divide by numInfiniteWidthCols to\\n+                        // spread the space equally among the inf-width cols.\\n+                        if (numInfiniteWidthCols) {\\n+                            if (colFrame->GetPrefCoord() == nscoord_MAX) {\\n+                                c = c / float(numInfiniteWidthCols);\\n+                                numInfiniteWidthCols--;\\n+                            } else {\\n+                                c = 0.0f;\\n+                            }\\n+                        }\\n+                        basis.c = NSCoordSaturatingSubtract(basis.c, \\n+                                                            pref_minus_min,\\n+                                                            nscoord_MAX);\\n                         col_width += NSToCoordRound(\\n                             float(pref_minus_min) * c);\\n                     }\\n@@ -971,7 +1008,7 @@ BasicTableLayoutStrategy::ComputeColumnWidths(const nsHTMLReflowState& aReflowSt\\n     NS_ASSERTION(space == 0 &&\\n                  ((l2t == FLEX_PCT_LARGE)\\n                     ? (-0.001f < basis.f && basis.f < 0.001f)\\n-                    : (basis.c == 0)),\\n+                    : (basis.c == 0 || basis.c == nscoord_MAX)),\\n                  \\\"didn't subtract all that we added\\\");\\n #ifdef DEBUG_TABLE_STRATEGY\\n     printf(\\\"ComputeColumnWidths final\\\\n\\\");\\n\""}