{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basdeef8b8\""},"diff":"\"deef8b8 backout patch for Bug 373462, Bug 385322\\ndiff --git a/content/base/src/nsXMLHttpRequest.cpp b/content/base/src/nsXMLHttpRequest.cpp\\nindex 40e3c9d..01a99f5 100644\\n--- a/content/base/src/nsXMLHttpRequest.cpp\\n+++ b/content/base/src/nsXMLHttpRequest.cpp\\n@@ -56,7 +56,6 @@\\n #include \\\"prprf.h\\\"\\n #include \\\"nsIDOMEventListener.h\\\"\\n #include \\\"nsIJSContextStack.h\\\"\\n-#include \\\"nsJSEnvironment.h\\\"\\n #include \\\"nsIScriptSecurityManager.h\\\"\\n #include \\\"nsWeakPtr.h\\\"\\n #include \\\"nsICharsetAlias.h\\\"\\n@@ -1777,7 +1776,6 @@ nsXMLHttpRequest::RequestCompleted()\\n     ChangeState(XML_HTTP_REQUEST_OPENED);\\n   }\\n \\n-  nsJSContext::MaybeCC(PR_FALSE);\\n   return rv;\\n }\\n \\n@@ -2320,7 +2318,6 @@ nsXMLHttpRequest::Error(nsIDOMEvent* aEvent)\\n     NotifyEventListeners(errorEventListeners, event);\\n   }\\n \\n-  nsJSContext::MaybeCC(PR_FALSE);\\n   return NS_OK;\\n }\\n \\ndiff --git a/dom/src/base/nsJSEnvironment.cpp b/dom/src/base/nsJSEnvironment.cpp\\nindex 3776230..db881ff 100644\\n--- a/dom/src/base/nsJSEnvironment.cpp\\n+++ b/dom/src/base/nsJSEnvironment.cpp\\n@@ -154,26 +154,8 @@ static PRLogModuleInfo* gJSDiagnostics;\\n \\n #define JAVASCRIPT nsIProgrammingLanguage::JAVASCRIPT\\n \\n-// The max number of delayed cycle collects..\\n-#define NS_MAX_DELAYED_CCOLLECT     45\\n-// The max number of user interaction notifications in inactive state before\\n-// we try to call cycle collector more aggressively.\\n-#define NS_CC_SOFT_LIMIT_INACTIVE   6\\n-// The max number of user interaction notifications in active state before\\n-// we try to call cycle collector more aggressively.\\n-#define NS_CC_SOFT_LIMIT_ACTIVE     12\\n-// When higher probability MaybeCC is used, the number of sDelayedCCollectCount\\n-// is multiplied with this number.\\n-#define NS_PROBABILITY_MULTIPLIER   3\\n-// Cycle collector should never run more often than this value\\n-#define NS_MIN_CC_INTERVAL          10000 // ms\\n-\\n // if you add statics here, add them to the list in nsJSRuntime::Startup\\n \\n-static PRUint32 sDelayedCCollectCount;\\n-static PRUint32 sCCollectCount;\\n-static PRTime sPreviousCCTime;\\n-static PRBool sPreviousCCDidCollect;\\n static nsITimer *sGCTimer;\\n static PRBool sReadyForGC;\\n \\n@@ -217,75 +199,6 @@ static nsICollation *gCollation;\\n \\n static nsIUnicodeDecoder *gDecoder;\\n \\n-// nsUserActivityObserver observes user-interaction-active and\\n-// user-interaction-inactive notifications. It counts the number of\\n-// notifications and if the number is bigger than NS_CC_SOFT_LIMIT_ACTIVE\\n-// (in case the current notification is user-interaction-active) or\\n-// NS_CC_SOFT_LIMIT_INACTIVE (current notification is user-interaction-inactive)\\n-// MaybeCC is called with aHigherParameter set to PR_TRUE, otherwise PR_FALSE.\\n-//\\n-// When moving from active state to inactive, nsJSContext::CC() is called\\n-// unless the timer related to page load is active.\\n-\\n-class nsUserActivityObserver : public nsIObserver\\n-{\\n-public:\\n-  nsUserActivityObserver()\\n-  : mUserActivityCounter(0), mOldCCollectCount(0), mUserIsActive(PR_FALSE) {}\\n-  NS_DECL_ISUPPORTS\\n-  NS_DECL_NSIOBSERVER\\n-private:\\n-  PRUint32 mUserActivityCounter;\\n-  PRUint32 mOldCCollectCount;\\n-  PRBool   mUserIsActive;\\n-};\\n-\\n-NS_IMPL_ISUPPORTS1(nsUserActivityObserver, nsIObserver)\\n-\\n-NS_IMETHODIMP\\n-nsUserActivityObserver::Observe(nsISupports* aSubject, const char* aTopic,\\n-                                const PRUnichar* aData)\\n-{\\n-  if (mOldCCollectCount != sCCollectCount) {\\n-    mOldCCollectCount = sCCollectCount;\\n-    // Cycle collector was called between user interaction notifications, so\\n-    // we can reset the counter.\\n-    mUserActivityCounter = 0;\\n-  }\\n-  PRBool higherProbability = PR_FALSE;\\n-  ++mUserActivityCounter;\\n-  if (!strcmp(aTopic, \\\"user-interaction-inactive\\\")) {\\n-#ifdef DEBUG_smaug\\n-    printf(\\\"user-interaction-inactive\\\\n\\\");\\n-#endif\\n-    if (mUserIsActive) {\\n-      mUserIsActive = PR_FALSE;\\n-      if (!sGCTimer) {\\n-        nsJSContext::CC();\\n-        return NS_OK;\\n-      }\\n-    }\\n-    higherProbability = (mUserActivityCounter > NS_CC_SOFT_LIMIT_INACTIVE);\\n-  } else if (!strcmp(aTopic, \\\"user-interaction-active\\\")) {\\n-#ifdef DEBUG_smaug\\n-    printf(\\\"user-interaction-active\\\\n\\\");\\n-#endif\\n-    mUserIsActive = PR_TRUE;\\n-    higherProbability = (mUserActivityCounter > NS_CC_SOFT_LIMIT_ACTIVE);\\n-  } else if (!strcmp(aTopic, \\\"xpcom-shutdown\\\")) {\\n-    nsCOMPtr<nsIObserverService> obs =\\n-      do_GetService(\\\"@mozilla.org/observer-service;1\\\");\\n-    if (obs) {\\n-      obs->RemoveObserver(this, \\\"user-interaction-active\\\");\\n-      obs->RemoveObserver(this, \\\"user-interaction-inactive\\\");\\n-      obs->RemoveObserver(this, \\\"xpcom-shutdown\\\");\\n-    }\\n-    return NS_OK;\\n-  }\\n-  nsJSContext::MaybeCC(higherProbability);\\n-  return NS_OK;\\n-}\\n-\\n /****************************************************************\\n  ************************** AutoFree ****************************\\n  ****************************************************************/\\n@@ -3307,50 +3220,6 @@ nsJSContext::PreserveWrapper(nsIXPConnectWrappedNative *aWrapper)\\n   return nsDOMClassInfo::PreserveNodeWrapper(aWrapper);\\n }\\n \\n-//static\\n-void\\n-nsJSContext::CC()\\n-{\\n-#ifdef DEBUG_smaug\\n-  printf(\\\"Will run cycle collector\\\\n\\\");\\n-#endif\\n-  sPreviousCCTime = PR_Now();\\n-  sDelayedCCollectCount = 0;\\n-  ++sCCollectCount;\\n-  // nsCycleCollector_collect() will run a ::JS_GC() indirectly, so\\n-  // we do not explicitly call ::JS_GC() here.\\n-  sPreviousCCDidCollect = nsCycleCollector_collect();\\n-#ifdef DEBUG_smaug\\n-  printf(\\\"%s\\\\n\\\", sPreviousCCDidCollect ?\\n-                   \\\"Cycle collector did collect nodes\\\" :\\n-                   \\\"Cycle collector did not collect nodes\\\");\\n-#endif\\n-}\\n-\\n-//static\\n-void\\n-nsJSContext::MaybeCC(PRBool aHigherProbability)\\n-{\\n-  ++sDelayedCCollectCount;\\n-  // Increase the probability also if the previous call to cycle collector\\n-  // collected something.\\n-  if (aHigherProbability || sPreviousCCDidCollect) {\\n-    sDelayedCCollectCount *= NS_PROBABILITY_MULTIPLIER;\\n-  }\\n-\\n-  if (!sGCTimer && (sDelayedCCollectCount > NS_MAX_DELAYED_CCOLLECT)) {\\n-    if ((PR_Now() - sPreviousCCTime) >=\\n-        PRTime(NS_MIN_CC_INTERVAL * PR_USEC_PER_MSEC)) {\\n-      nsJSContext::CC();\\n-    }\\n-#ifdef DEBUG_smaug\\n-    else {\\n-      printf(\\\"Running cycle collector was delayed: NS_MIN_CC_INTERVAL\\\\n\\\");\\n-    }\\n-#endif\\n-  }\\n-}\\n-\\n NS_IMETHODIMP\\n nsJSContext::Notify(nsITimer *timer)\\n {\\n@@ -3369,7 +3238,9 @@ nsJSContext::Notify(nsITimer *timer)\\n     // loading and move on as if they weren't.\\n     sPendingLoadCount = 0;\\n \\n-    nsJSContext::MaybeCC(PR_TRUE);\\n+    // nsCycleCollector_collect() will run a ::JS_GC() indirectly,\\n+    // so we do not explicitly call ::JS_GC() here. \\n+    nsCycleCollector_collect();\\n   } else {\\n     FireGCTimer(PR_TRUE);\\n   }\\n@@ -3402,7 +3273,9 @@ nsJSContext::LoadEnd()\\n     NS_RELEASE(sGCTimer);\\n     sLoadInProgressGCTimer = PR_FALSE;\\n \\n-    nsJSContext::MaybeCC(PR_TRUE);\\n+    // nsCycleCollector_collect() will run a ::JS_GC() indirectly, so\\n+    // we do not explicitly call ::JS_GC() here.\\n+    nsCycleCollector_collect();\\n   }\\n }\\n \\n@@ -3429,7 +3302,9 @@ nsJSContext::FireGCTimer(PRBool aLoadInProgress)\\n     // timer.\\n     sLoadInProgressGCTimer = PR_FALSE;\\n \\n-    nsJSContext::MaybeCC(PR_TRUE);\\n+    // nsCycleCollector_collect() will run a ::JS_GC() indirectly, so\\n+    // we do not explicitly call ::JS_GC() here.\\n+    nsCycleCollector_collect();\\n \\n     return;\\n   }\\n@@ -3538,10 +3413,6 @@ void\\n nsJSRuntime::Startup()\\n {\\n   // initialize all our statics, so that we can restart XPCOM\\n-  sDelayedCCollectCount = 0;\\n-  sCCollectCount = 0;\\n-  sPreviousCCTime = 0;\\n-  sPreviousCCDidCollect = PR_FALSE;\\n   sGCTimer = nsnull;\\n   sReadyForGC = PR_FALSE;\\n   sLoadInProgressGCTimer = PR_FALSE;\\n@@ -3676,15 +3547,6 @@ nsJSRuntime::Init()\\n   MaxScriptRunTimePrefChangedCallback(\\\"dom.max_chrome_script_run_time\\\",\\n                                       nsnull);\\n \\n-  nsCOMPtr<nsIObserverService> obs =\\n-    do_GetService(\\\"@mozilla.org/observer-service;1\\\", &rv);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-  nsIObserver* activityObserver = new nsUserActivityObserver();\\n-  NS_ENSURE_TRUE(activityObserver, NS_ERROR_OUT_OF_MEMORY);\\n-  obs->AddObserver(activityObserver, \\\"user-interaction-inactive\\\", PR_FALSE);\\n-  obs->AddObserver(activityObserver, \\\"user-interaction-active\\\", PR_FALSE);\\n-  obs->AddObserver(activityObserver, \\\"xpcom-shutdown\\\", PR_FALSE);\\n-\\n   rv = CallGetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &sSecurityManager);\\n \\n   sIsInitialized = NS_SUCCEEDED(rv);\\ndiff --git a/dom/src/base/nsJSEnvironment.h b/dom/src/base/nsJSEnvironment.h\\nindex 2662e0f..01d0187 100644\\n--- a/dom/src/base/nsJSEnvironment.h\\n+++ b/dom/src/base/nsJSEnvironment.h\\n@@ -170,24 +170,6 @@ public:\\n   static void LoadStart();\\n   static void LoadEnd();\\n \\n-  // CC does always call cycle collector and it also updates the counters\\n-  // that MaybeCC uses.\\n-  static void CC();\\n-\\n-  // MaybeCC calls cycle collector if certain conditions are fulfilled.\\n-  // The conditions are:\\n-  // - The timer related to page load (sGCTimer) must not be active.\\n-  // - At least NS_MIN_CC_INTERVAL milliseconds must have elapsed since the\\n-  //   previous cycle collector call.\\n-  // - Certain number of MaybeCC calls have occurred.\\n-  //   The number of needed MaybeCC calls depends on the aHigherProbability\\n-  //   parameter. If the parameter is true, probability for calling cycle\\n-  //   collector rises increasingly. If the parameter is all the time false,\\n-  //   at least NS_MAX_DELAYED_CCOLLECT MaybeCC calls are needed.\\n-  //   If the previous call to cycle collector did collect something,\\n-  //   MaybeCC works effectively as if aHigherProbability was true.\\n-  static void MaybeCC(PRBool aHigherProbability);\\n-\\n protected:\\n   nsresult InitializeExternalClasses();\\n   nsresult InitializeLiveConnectClasses(JSObject *aGlobalObj);\\ndiff --git a/dom/src/base/nsWindowRoot.cpp b/dom/src/base/nsWindowRoot.cpp\\nindex aa30af0..3ffdd6b 100644\\n--- a/dom/src/base/nsWindowRoot.cpp\\n+++ b/dom/src/base/nsWindowRoot.cpp\\n@@ -54,49 +54,10 @@\\n #include \\\"nsString.h\\\"\\n #include \\\"nsEventDispatcher.h\\\"\\n #include \\\"nsIProgrammingLanguage.h\\\"\\n-#include \\\"nsIObserverService.h\\\"\\n-#include \\\"nsServiceManagerUtils.h\\\"\\n-#include \\\"nsITimer.h\\\"\\n-#include \\\"nsCycleCollectionParticipant.h\\\"\\n \\n-#define NS_USER_INTERACTION_INTERVAL 5000 // ms\\n+#include \\\"nsCycleCollectionParticipant.h\\\"\\n \\n static NS_DEFINE_CID(kEventListenerManagerCID,    NS_EVENTLISTENERMANAGER_CID);\\n-static PRUint32 gMouseOrKeyboardEventCounter = 0;\\n-static PRUint32 gWindowRootCount = 0;\\n-static nsITimer* gUserInteractionTimer = nsnull;\\n-static nsITimerCallback* gUserInteractionTimerCallback = nsnull;\\n-\\n-class nsUITimerCallback : public nsITimerCallback\\n-{\\n-public:\\n-  nsUITimerCallback() : mPreviousCount(0) {}\\n-  NS_DECL_ISUPPORTS\\n-  NS_DECL_NSITIMERCALLBACK\\n-private:\\n-  PRUint32 mPreviousCount;\\n-};\\n-\\n-NS_IMPL_ISUPPORTS1(nsUITimerCallback, nsITimerCallback)\\n-\\n-// If aTimer is nsnull, this method always sends \\\"user-interaction-inactive\\\"\\n-// notification.\\n-NS_IMETHODIMP\\n-nsUITimerCallback::Notify(nsITimer* aTimer)\\n-{\\n-  nsresult rv;\\n-  nsCOMPtr<nsIObserverService> obs =\\n-      do_GetService(\\\"@mozilla.org/observer-service;1\\\", &rv);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-  if ((gMouseOrKeyboardEventCounter == mPreviousCount) || !aTimer) {\\n-    gMouseOrKeyboardEventCounter = 0;\\n-    obs->NotifyObservers(nsnull, \\\"user-interaction-inactive\\\", nsnull);\\n-  } else {\\n-    obs->NotifyObservers(nsnull, \\\"user-interaction-active\\\", nsnull);\\n-  }\\n-  mPreviousCount = gMouseOrKeyboardEventCounter;\\n-  return NS_OK;\\n-}\\n \\n nsWindowRoot::nsWindowRoot(nsIDOMWindow* aWindow)\\n {\\n@@ -110,20 +71,6 @@ nsWindowRoot::nsWindowRoot(nsIDOMWindow* aWindow)\\n   AddEventListener(NS_LITERAL_STRING(\\\"focus\\\"), focusListener, PR_TRUE);\\n   AddEventListener(NS_LITERAL_STRING(\\\"blur\\\"), focusListener, PR_TRUE);\\n   mRefCnt.decr(static_cast<nsIDOMEventTarget*>(this));\\n-\\n-  if (gWindowRootCount == 0) {\\n-    gUserInteractionTimerCallback = new nsUITimerCallback();\\n-    if (gUserInteractionTimerCallback) {\\n-      NS_ADDREF(gUserInteractionTimerCallback);\\n-      CallCreateInstance(\\\"@mozilla.org/timer;1\\\", &gUserInteractionTimer);\\n-      if (gUserInteractionTimer) {\\n-        gUserInteractionTimer->InitWithCallback(gUserInteractionTimerCallback,\\n-                                                NS_USER_INTERACTION_INTERVAL,\\n-                                                nsITimer::TYPE_REPEATING_SLACK);\\n-      }\\n-    }\\n-  }\\n-  ++gWindowRootCount;\\n }\\n \\n nsWindowRoot::~nsWindowRoot()\\n@@ -131,18 +78,6 @@ nsWindowRoot::~nsWindowRoot()\\n   if (mListenerManager) {\\n     mListenerManager->Disconnect();\\n   }\\n-\\n-  --gWindowRootCount;\\n-  if (gWindowRootCount == 0) {\\n-    if (gUserInteractionTimerCallback) {\\n-      gUserInteractionTimerCallback->Notify(nsnull);\\n-      NS_RELEASE(gUserInteractionTimerCallback);\\n-    }\\n-    if (gUserInteractionTimer) {\\n-      gUserInteractionTimer->Cancel();\\n-      NS_RELEASE(gUserInteractionTimer);\\n-    }\\n-  }\\n }\\n \\n NS_IMPL_CYCLE_COLLECTION_2(nsWindowRoot, mListenerManager, mFocusController)\\n@@ -312,21 +247,6 @@ nsWindowRoot::PreHandleEvent(nsEventChainPreVisitor& aVisitor)\\n   aVisitor.mForceContentDispatch = PR_TRUE; //FIXME! Bug 329119\\n   // To keep mWindow alive\\n   aVisitor.mItemData = mWindow;\\n-  if (NS_IS_TRUSTED_EVENT(aVisitor.mEvent) &&\\n-      ((aVisitor.mEvent->eventStructType == NS_MOUSE_EVENT  &&\\n-        static_cast<nsMouseEvent*>(aVisitor.mEvent)->reason ==\\n-          nsMouseEvent::eReal) ||\\n-       aVisitor.mEvent->eventStructType == NS_MOUSE_SCROLL_EVENT ||\\n-       aVisitor.mEvent->eventStructType == NS_KEY_EVENT)) {\\n-    if (gMouseOrKeyboardEventCounter == 0) {\\n-      nsCOMPtr<nsIObserverService> obs =\\n-        do_GetService(\\\"@mozilla.org/observer-service;1\\\");\\n-      if (obs) {\\n-        obs->NotifyObservers(nsnull, \\\"user-interaction-active\\\", nsnull);\\n-      }\\n-    }\\n-    ++gMouseOrKeyboardEventCounter;\\n-  }\\n   return NS_OK;\\n }\\n \\ndiff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp\\nindex b362041..3bfbcea 100644\\n--- a/xpcom/base/nsCycleCollector.cpp\\n+++ b/xpcom/base/nsCycleCollector.cpp\\n@@ -869,7 +869,7 @@ struct nsCycleCollector\\n     PRBool Forget(nsISupports *n);\\n     void Allocated(void *n, size_t sz);\\n     void Freed(void *n);\\n-    PRBool Collect(PRUint32 aTryCollections = 1);\\n+    void Collect(PRUint32 aTryCollections = 1);\\n     void Shutdown();\\n \\n #ifdef DEBUG_CC\\n@@ -2021,10 +2021,9 @@ nsCycleCollector::Freed(void *n)\\n }\\n #endif\\n \\n-PRBool\\n+void\\n nsCycleCollector::Collect(PRUint32 aTryCollections)\\n {\\n-    PRBool didCollect = PR_FALSE;\\n #if defined(DEBUG_CC) && !defined(__MINGW32__)\\n     if (!mParams.mDoNothing && mParams.mHookMalloc)\\n         InitMemHook();\\n@@ -2032,7 +2031,7 @@ nsCycleCollector::Collect(PRUint32 aTryCollections)\\n \\n     // This can legitimately happen in a few cases. See bug 383651.\\n     if (mCollectionInProgress)\\n-        return didCollect;\\n+        return;\\n \\n #ifdef COLLECT_TIME_DEBUG\\n     printf(\\\"cc: Starting nsCycleCollector::Collect(%d)\\\\n\\\", aTryCollections);\\n@@ -2169,11 +2168,8 @@ nsCycleCollector::Collect(PRUint32 aTryCollections)\\n                 // mBuf.GetSize() == 0 check above), we should stop\\n                 // repeating collections if we didn't collect anything\\n                 // this time.\\n-                if (!collected) {\\n+                if (!collected)\\n                     aTryCollections = 0;\\n-                } else {\\n-                    didCollect = PR_TRUE;\\n-                }\\n             }\\n \\n #ifdef DEBUG_CC\\n@@ -2198,7 +2194,6 @@ nsCycleCollector::Collect(PRUint32 aTryCollections)\\n #ifdef DEBUG_CC\\n     ExplainLiveExpectedGarbage();\\n #endif\\n-    return didCollect;\\n }\\n \\n void\\n@@ -2599,10 +2594,11 @@ NS_CycleCollectorForget(nsISupports *n)\\n }\\n \\n \\n-PRBool\\n+void \\n nsCycleCollector_collect()\\n {\\n-    return sCollector ? sCollector->Collect() : PR_FALSE;\\n+    if (sCollector)\\n+        sCollector->Collect();\\n }\\n \\n nsresult \\ndiff --git a/xpcom/base/nsCycleCollector.h b/xpcom/base/nsCycleCollector.h\\nindex ac8ceb5..0809ee6 100644\\n--- a/xpcom/base/nsCycleCollector.h\\n+++ b/xpcom/base/nsCycleCollector.h\\n@@ -66,8 +66,7 @@ struct nsCycleCollectionLanguageRuntime\\n NS_COM void nsCycleCollector_suspectCurrent(nsISupports *n);\\n // NS_COM PRBool nsCycleCollector_forget(nsISupports *n);\\n nsresult nsCycleCollector_startup();\\n-// Returns PR_TRUE if some nodes were collected.\\n-NS_COM PRBool nsCycleCollector_collect();\\n+NS_COM void nsCycleCollector_collect();\\n void nsCycleCollector_shutdown();\\n \\n #ifdef DEBUG\\n\""}