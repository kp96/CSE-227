{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas1b61f82\""},"diff":"\"1b61f82 fix for bug #394527:  livemark feed URIs should show up as \\\"bookmarked\\\" (gold star on) in the url bar and in url bar autocomplete search results for performance: when searching previous autocomplete results, we don't need to regenerate the hash tables (of livemark item ids and livemark feed URIs). when searching previous autocomplete results, if we find any, tell the front end immediately, instead of waiting for our first db query to return. r=dietrich, a=mconnor for m8\\ndiff --git a/browser/base/content/browser-places.js b/browser/base/content/browser-places.js\\nindex 3e44474..67c5314 100644\\n--- a/browser/base/content/browser-places.js\\n+++ b/browser/base/content/browser-places.js\\n@@ -771,7 +771,8 @@ var PlacesStarButton = {\\n       return;\\n \\n     var uri = getBrowser().currentURI;\\n-    this._starred = uri && (PlacesUtils.getMostRecentBookmarkForURI(uri) != -1);\\n+    this._starred = uri && (PlacesUtils.getMostRecentBookmarkForURI(uri) != -1 ||\\n+                            PlacesUtils.getMostRecentFolderForFeedURI(uri) != -1);\\n     if (this._starred)\\n       starIcon.setAttribute(\\\"starred\\\", \\\"true\\\");\\n     else\\ndiff --git a/browser/components/places/content/utils.js b/browser/components/places/content/utils.js\\nindex 91ea449..90173b3 100644\\n--- a/browser/components/places/content/utils.js\\n+++ b/browser/components/places/content/utils.js\\n@@ -51,6 +51,7 @@ Components.utils.import(\\\"resource://gre/modules/JSON.jsm\\\");\\n const LOAD_IN_SIDEBAR_ANNO = \\\"bookmarkProperties/loadInSidebar\\\";\\n const DESCRIPTION_ANNO = \\\"bookmarkProperties/description\\\";\\n const POST_DATA_ANNO = \\\"URIProperties/POSTData\\\";\\n+const LMANNO_FEEDURI = \\\"livemark/feedURI\\\";\\n \\n #ifdef XP_MACOSX\\n // On Mac OSX, the transferable system converts \\\"\\\\r\\\\n\\\" to \\\"\\\\n\\\\n\\\", where we\\n@@ -398,7 +399,7 @@ var PlacesUtils = {\\n   */\\n   nodeIsLivemarkContainer: function PU_nodeIsLivemarkContainer(aNode) {\\n     return this.nodeIsFolder(aNode) &&\\n-           this.annotations.itemHasAnnotation(aNode.itemId, \\\"livemark/feedURI\\\");\\n+           this.annotations.itemHasAnnotation(aNode.itemId, LMANNO_FEEDURI);\\n   },\\n \\n  /**\\n@@ -1507,12 +1508,24 @@ var PlacesUtils = {\\n         return bk;\\n       var grandparent = this.bookmarks.getFolderIdForItem(parent);\\n       if (grandparent != this.tagRootId &&\\n-          !this.annotations.itemHasAnnotation(parent, \\\"livemark/feedURI\\\"))\\n+          !this.annotations.itemHasAnnotation(parent, LMANNO_FEEDURI))\\n         return bk;\\n     }\\n     return -1;\\n   },\\n \\n+  getMostRecentFolderForFeedURI:\\n+  function PU_getMostRecentFolderForFeedURI(aURI) {\\n+    var feedSpec = aURI.spec\\n+    var annosvc = this.annotations;\\n+    var livemarks = annosvc.getItemsWithAnnotation(LMANNO_FEEDURI, {});\\n+    for (var i = 0; i < livemarks.length; i++) {\\n+      if (annosvc.getItemAnnotation(livemarks[i], LMANNO_FEEDURI) == feedSpec)\\n+        return livemarks[i];\\n+    }\\n+    return -1;\\n+  },\\n+\\n   getURLsForContainerNode: function PU_getURLsForContainerNode(aNode) {\\n     let urls = [];\\n     if (this.nodeIsFolder(aNode) && asQuery(aNode).queryOptions.excludeItems) {\\ndiff --git a/toolkit/components/places/src/nsNavHistory.h b/toolkit/components/places/src/nsNavHistory.h\\nindex 0fb5d7f..d287b57 100644\\n--- a/toolkit/components/places/src/nsNavHistory.h\\n+++ b/toolkit/components/places/src/nsNavHistory.h\\n@@ -580,7 +580,8 @@ protected:\\n   PRTime mCurrentOldestVisit;\\n   PRBool mFirstChunk;\\n \\n-  nsDataHashtable<nsTrimInt64HashKey, PRBool> mLivemarkFeedItemIds;  \\n+  nsDataHashtable<nsTrimInt64HashKey, PRBool> mLivemarkFeedItemIds;\\n+  nsDataHashtable<nsStringHashKey, PRBool> mLivemarkFeedURIs;\\n   nsCOMPtr<mozIStorageStatement> mLivemarkFeedsQuery;\\n \\n   nsresult AutoCompleteTypedSearch();\\ndiff --git a/toolkit/components/places/src/nsNavHistoryAutoComplete.cpp b/toolkit/components/places/src/nsNavHistoryAutoComplete.cpp\\nindex a261f59..cbedb9e 100644\\n--- a/toolkit/components/places/src/nsNavHistoryAutoComplete.cpp\\n+++ b/toolkit/components/places/src/nsNavHistoryAutoComplete.cpp\\n@@ -84,6 +84,9 @@ nsNavHistory::InitAutoComplete()\\n   if (!mLivemarkFeedItemIds.Init(128))\\n     return NS_ERROR_OUT_OF_MEMORY;\\n \\n+  if (!mLivemarkFeedURIs.Init(128))\\n+    return NS_ERROR_OUT_OF_MEMORY;\\n+\\n   return NS_OK;\\n }\\n \\n@@ -97,9 +100,9 @@ nsresult\\n nsNavHistory::CreateAutoCompleteQueries()\\n {\\n   nsCString sql = NS_LITERAL_CSTRING(\\n-    \\\"SELECT annos.item_id FROM moz_anno_attributes attrs \\\"\\n-    \\\"JOIN moz_items_annos annos WHERE attrs.name = \\\\\\\"\\\" LMANNO_FEEDURI \\\"\\\\\\\" \\\"\\n-    \\\"AND attrs.id = annos.anno_attribute_id;\\\");\\n+    \\\"SELECT annos.item_id, annos.content FROM moz_anno_attributes attrs \\\" \\n+    \\\"JOIN moz_items_annos annos ON attrs.id = annos.anno_attribute_id \\\"\\n+    \\\"WHERE attrs.name = \\\\\\\"\\\" LMANNO_FEEDURI \\\"\\\\\\\";\\\");\\n   nsresult rv = mDBConn->CreateStatement(sql, getter_AddRefs(mLivemarkFeedsQuery));\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n@@ -279,18 +282,30 @@ nsNavHistory::StartSearch(const nsAString & aSearchString,\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n   mCurrentResultURLs.Clear();\\n-  mLivemarkFeedItemIds.Clear();\\n \\n-  // find all the items that have the \\\"livemark/feedURI\\\" annotation\\n-  // and save off their item ids.  when doing autocomplete, \\n-  // if a result's parent item id matches a saved item id, the result\\n-  // it is not really a bookmark, but a rss feed item.\\n-  mozStorageStatementScoper scope(mLivemarkFeedsQuery);\\n-  PRBool hasMore = PR_FALSE;\\n-  while (NS_SUCCEEDED(mLivemarkFeedsQuery->ExecuteStep(&hasMore)) && hasMore) {\\n-    PRInt64 itemId = 0;\\n-    mLivemarkFeedsQuery->GetInt64(0, &itemId);\\n-    mLivemarkFeedItemIds.Put(itemId, PR_TRUE);\\n+  // if we are searching through our previous results,\\n+  // we don't need to regenerate these hash tables\\n+  if (!searchPrevious) {\\n+    mLivemarkFeedItemIds.Clear();\\n+    mLivemarkFeedURIs.Clear();\\n+\\n+    // find all the items that have the \\\"livemark/feedURI\\\" annotation\\n+    // and save off their item ids and URIs. when doing autocomplete, \\n+    // if a result's parent item id matches a saved item id, the result\\n+    // it is not really a bookmark, but a rss feed item.\\n+    // if a results URI matches a saved URI, the result is a bookmark,\\n+    // so we should show the star.\\n+    mozStorageStatementScoper scope(mLivemarkFeedsQuery);\\n+    PRBool hasMore = PR_FALSE;\\n+    while (NS_SUCCEEDED(mLivemarkFeedsQuery->ExecuteStep(&hasMore)) && hasMore) {\\n+      PRInt64 itemId = 0;\\n+      mLivemarkFeedsQuery->GetInt64(0, &itemId);\\n+      mLivemarkFeedItemIds.Put(itemId, PR_TRUE);\\n+      nsAutoString feedURI;\\n+      // no need to worry about duplicates.\\n+      mLivemarkFeedsQuery->GetString(1, feedURI);\\n+      mLivemarkFeedURIs.Put(feedURI, PR_TRUE);\\n+    }\\n   }\\n \\n   // Search through the previous result\\n@@ -335,6 +350,15 @@ nsNavHistory::StartSearch(const nsAString & aSearchString,\\n         }\\n       }\\n     }\\n+    // if we found some results, announce them now instead of waiting\\n+    // to do the first db search.\\n+    PRUint32 count;\\n+    mCurrentResult->GetMatchCount(&count); \\n+\\n+    if (count > 0) {\\n+      mCurrentResult->SetSearchResult(nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING);\\n+      mCurrentResult->SetDefaultIndex(0);\\n+    }\\n   }\\n   else if (!mCurrentSearchString.IsEmpty()) {\\n     // reset to mCurrentChunkEndTime \\n@@ -424,9 +448,11 @@ nsresult nsNavHistory::AutoCompleteTypedSearch()\\n     dbSelectStatement->GetInt64(kAutoCompleteIndex_ParentId, &parentId);\\n \\n     PRBool dummy;\\n-    // don't show rss feed items as bookmarked\\n-    PRBool isBookmark = (itemId != 0) && \\n-                        !mLivemarkFeedItemIds.Get(parentId, &dummy);\\n+    // don't show rss feed items as bookmarked,\\n+    // but do show rss feed URIs as bookmarked.\\n+    PRBool isBookmark = (itemId != 0 && \\n+                         !mLivemarkFeedItemIds.Get(parentId, &dummy)) ||\\n+                        mLivemarkFeedURIs.Get(entryURL, &dummy);   \\n \\n     nsCAutoString imageSpec;\\n     faviconService->GetFaviconSpecForIconString(\\n@@ -548,9 +574,11 @@ nsNavHistory::AutoCompleteFullHistorySearch()\\n     NS_ENSURE_SUCCESS(rv, rv);\\n \\n     PRBool dummy;\\n-    // don't show rss feed items as bookmarked\\n-    PRBool isBookmark = (itemId != 0) && \\n-                        !mLivemarkFeedItemIds.Get(parentId, &dummy);\\n+    // don't show rss feed items as bookmarked,\\n+    // but do show rss feed URIs as bookmarked.\\n+    PRBool isBookmark = (itemId != 0 && \\n+                         !mLivemarkFeedItemIds.Get(parentId, &dummy)) ||\\n+                         mLivemarkFeedURIs.Get(entryURL, &dummy);  \\n \\n     // prevent duplicates.  this can happen when chunking as we\\n     // may have already seen this URL from an earlier chunk of time\\n\""}