{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basdf57784\""},"diff":"\"df57784 flesh out new sync engine - cleanup needed\\ndiff --git a/services/sync/nsBookmarksSyncService.js b/services/sync/nsBookmarksSyncService.js\\nindex 46a719c..037b34f 100644\\n--- a/services/sync/nsBookmarksSyncService.js\\n+++ b/services/sync/nsBookmarksSyncService.js\\n@@ -71,12 +71,6 @@ BookmarksSyncService.prototype = {\\n   // DAVCollection object\\n   _dav: null,\\n \\n-  // sync.js\\n-  _sync: {},\\n-\\n-  // PlacesUtils\\n-  _utils: {},\\n-\\n   // Last synced tree\\n   // FIXME: this should be serialized to disk\\n   _snapshot: {},\\n@@ -93,10 +87,6 @@ BookmarksSyncService.prototype = {\\n     catch (ex) { /* use defaults */ }\\n     LOG(\\\"Bookmarks sync server: \\\" + serverUrl);\\n     this._dav = new DAVCollection(serverUrl);\\n-\\n-    var jsLoader = Cc[\\\"@mozilla.org/moz/jssubscript-loader;1\\\"].\\n-      getService(Ci.mozIJSSubScriptLoader);\\n-    jsLoader.loadSubScript(\\\"chrome://sync/content/sync-engine.js\\\", this._sync);\\n   },\\n \\n   _wrapNode: function BSS__wrapNode(node) {\\n@@ -272,7 +262,7 @@ BookmarksSyncService.prototype = {\\n       curItem = parent.getChild(command.data.index);\\n \\n     if (this._compareItems(curItem, command.data)) {\\n-      LOG(\\\" -> skipping item (already exists)\\\");\\n+      LOG(\\\" -> FIXME - skipping item (already exists)\\\");\\n       this._bms.setItemGUID(curItem.itemId, command.guid);\\n       return;\\n     }\\n@@ -369,6 +359,17 @@ BookmarksSyncService.prototype = {\\n     return ret;\\n   },\\n \\n+  _nodeParents: function BSS__nodeParents(guid, tree) {\\n+    return this._nodeParentsInt(guid, tree, []);\\n+  },\\n+\\n+  _nodeParentsInt: function BSS__nodeParentsInt(guid, tree, parents) {\\n+    if (tree[guid].parentGuid == null)\\n+      return parents;\\n+    parents.push(tree[guid].parentGuid);\\n+    return this._nodeParentsInt(tree[guid].parentGuid, tree, parents);\\n+  },\\n+\\n   _detectUpdates: function BSS__detectUpdates(a, b) {\\n     let cmds = [];\\n     for (let guid in a) {\\n@@ -378,19 +379,133 @@ BookmarksSyncService.prototype = {\\n           continue;\\n         if (edits == {}) // no changes - skip\\n           continue;\\n-        cmds.push({action: \\\"edit\\\", guid: guid, data: edits});\\n+        let parents = this._nodeParents(guid, b);\\n+        cmds.push({action: \\\"edit\\\", guid: guid,\\n+                   depth: parents.length, parents: parents,\\n+                   data: edits});\\n       } else {\\n-        cmds.push({action: \\\"remove\\\", guid: guid});\\n+        let parents = this._nodeParents(guid, a); // ???\\n+        cmds.push({action: \\\"remove\\\", guid: guid,\\n+                   depth: parents.length, parents: parents});\\n       }\\n     }\\n     for (let guid in b) {\\n       if (guid in a)\\n         continue;\\n-      cmds.push({action: \\\"create\\\", guid: guid, data: b[guid]});\\n+      let parents = this._nodeParents(guid, b);\\n+      cmds.push({action: \\\"create\\\", guid: guid,\\n+                 depth: parents.length, parents: parents,\\n+                 data: b[guid]});\\n     }\\n+    return cmds;\\n+  },\\n+\\n+  _conflicts: function BSS__conflicts(a, b) {\\n+    if ((a.depth < b.depth) &&\\n+        (b.parents.indexOf(a.guid) >= 0) &&\\n+        a.action == \\\"remove\\\")\\n+      return true;\\n+    if ((a.guid == b.guid) && a != b)\\n+      return true;\\n+// FIXME - how else can two commands conflict?\\n+    return false;\\n   },\\n \\n-  _reconcile: function BSS__reconcile(a, b) {\\n+  // NEED TO also look at the parent chain & index; only items in the\\n+  // same \\\"spot\\\" qualify for likeness\\n+  _commandLike: function BSS__commandLike(a, b) {\\n+    if (!a || !b)\\n+      return false;\\n+\\n+    if (a.action != b.action)\\n+      return false;\\n+\\n+    switch (a.data.type) {\\n+    case 0:\\n+      if (b.data.type == a.data.type &&\\n+          b.data.uri == a.data.uri &&\\n+          b.data.title == a.data.title)\\n+        return true;\\n+      return false;\\n+    case 6:\\n+      if (b.data.type == a.data.type &&\\n+          b.data.title == a.data.title)\\n+        return true;\\n+      return false;\\n+    case 7:\\n+      // fixme: we need to enable this after we \\n+//      if (b.data.type == a.data.type)\\n+//        return true;\\n+      return false;\\n+    default:\\n+      LOG(\\\"_commandLike: Unknown item type: \\\" + uneval(a));\\n+      return false;\\n+    }\\n+  },\\n+\\n+  _deepEquals: function BSS__commandEquals(a, b) {\\n+    if (!a && !b)\\n+      return true;\\n+    if (!a || !b)\\n+      return false;\\n+\\n+    for (let key in a) {\\n+      if (typeof(a[key]) == \\\"object\\\") {\\n+        if (!typeof(b[key]) == \\\"object\\\")\\n+          return false;\\n+        if (!this._deepEquals(a[key], b[key]))\\n+          return false;\\n+      } else {\\n+        if (a[key] != b[key])\\n+          return false;\\n+      }\\n+    }\\n+    return true;\\n+  },\\n+\\n+  _reconcile: function BSS__reconcile(listA, listB) {\\n+    let propagations = [[], []];\\n+    let conflicts = [[], []];\\n+\\n+    for (let i = 0; i < listA.length; i++) {\\n+      for (let j = 0; j < listB.length; j++) {\\n+        if (this._commandLike(listA[i], listB[j]) ||\\n+            this._deepEquals(listA[i], listB[j])) {\\n+          delete listA[i];\\n+          delete listB[j];\\n+        }\\n+      }\\n+    }\\n+\\n+    listA = listA.filter(function(elt) { return elt });\\n+    listB = listB.filter(function(elt) { return elt });\\n+\\n+    for (let i = 0; i < listA.length; i++) {\\n+      for (let j = 0; j < listB.length; j++) {\\n+        if (this._conflicts(listA[i], listB[j]) ||\\n+            this._conflicts(listB[j], listA[i])) {\\n+          if (conflicts[0].some(\\n+            function(elt) { return elt.guid == listA[i].guid }))\\n+            conflicts[0].push(listA[i]);\\n+          if (conflicts[1].some(\\n+            function(elt) { return elt.guid == listB[j].guid }))\\n+            conflicts[1].push(listB[j]);\\n+        }\\n+      }\\n+    }\\n+    for (let i = 0; i < listA.length; i++) {\\n+      // need to check if a previous conflict might break this cmd\\n+      if (!conflicts[0].some(\\n+        function(elt) { return elt.guid == listA[i].guid }))\\n+        propagations[1].push(listA[i]);\\n+    }\\n+    for (let j = 0; j < listB.length; j++) {\\n+      // need to check if a previous conflict might break this cmd\\n+      if (!conflicts[1].some(\\n+        function(elt) { return elt.guid == listB[j].guid }))\\n+        propagations[0].push(listB[j]);\\n+    }\\n+    return {propagations: propagations, conflicts: conflicts};\\n   },\\n \\n   _applyCommandsToObj: function BSS__applyCommandsToObj(commands, obj) {\\n@@ -409,17 +524,6 @@ BookmarksSyncService.prototype = {\\n     }\\n   },\\n \\n-  // FIXME - hack to make sure we have Commands, not just eval'ed hashes\\n-  _sanitizeCommands: function BSS__sanitizeCommands(hashes) {\\n-    var commands = [];\\n-    for (var i = 0; i < hashes.length; i++) {\\n-      commands.push(new this._sync.Command(hashes[i][\\\"action\\\"],\\n-                                           hashes[i][\\\"path\\\"],\\n-                                           hashes[i][\\\"value\\\"]));\\n-    }\\n-    return commands;\\n-  },\\n-\\n   _getBookmarks: function BMS__getBookmarks(folder) {\\n     if (!folder)\\n       folder = this._bms.bookmarksRoot;\\n@@ -449,11 +553,13 @@ BookmarksSyncService.prototype = {\\n \\n       var localBookmarks = this._getBookmarks();\\n       var localJson = this._wrapNode(localBookmarks);\\n+      LOG(\\\"local json: \\\" + uneval(localJson));\\n \\n       // 1) Fetch server deltas\\n       asyncRun(bind2(this, this._getServerData), handlers['complete'], localJson);\\n       var server = yield;\\n \\n+      LOG(\\\"server: \\\" + uneval(server));\\n       if (server['status'] == 2) {\\n         LOG(\\\"Sync complete\\\");\\n         return;\\n@@ -468,7 +574,8 @@ BookmarksSyncService.prototype = {\\n       // 2) Generate local deltas from snapshot -> current client status\\n \\n       LOG(\\\"Generating local updates\\\");\\n-      var localUpdates = this._sanitizeCommands(this._sync.detectUpdates(this._snapshot, localJson));\\n+      var localUpdates = this._detectUpdates(this._snapshot, localJson);\\n+      LOG(\\\"updates: \\\" + uneval(localUpdates));\\n       if (!(server['status'] == 1 || localUpdates.length > 0)) {\\n         LOG(\\\"Sync complete (1): no changes needed on client or server\\\");\\n         return;\\n@@ -481,7 +588,7 @@ BookmarksSyncService.prototype = {\\n \\n       if (server['status'] == 1 && localUpdates.length > 0) {\\n         LOG(\\\"Reconciling updates\\\");\\n-        var ret = this._sync.reconcile([localUpdates, server['updates']]);\\n+        var ret = this._reconcile(localUpdates, server['updates']);\\n         propagations = ret.propagations;\\n         conflicts = ret.conflicts;\\n       }\\n@@ -516,15 +623,15 @@ BookmarksSyncService.prototype = {\\n       // 3.1) Apply server changes to local store\\n       if (propagations[0] && propagations[0].length) {\\n         LOG(\\\"Applying changes locally\\\");\\n-        localBookmarks = this._getBookmarks(); // fixme: wtf\\n+        //localBookmarks = this._getBookmarks(); // fixme: wtf\\n         this._snapshot = this._wrapNode(localBookmarks);\\n-        // Note: propagations[0] is changed by applyCommands, so we make a deep copy\\n-        this._sync.applyCommands(this._snapshot, eval(uneval(propagations[0])));\\n-        var combinedCommands = this._combineCommands(propagations[0]);\\n-        LOG(\\\"Combined commands: \\\" + uneval(combinedCommands) + \\\"\\\\n\\\");\\n-        var sortedCommands = this._sortCommands(combinedCommands);\\n-        LOG(\\\"Sorted commands: \\\" + uneval(sortedCommands) + \\\"\\\\n\\\");\\n-        this._applyCommands(combinedCommands);\\n+        this._applyCommandsToObj(this._snapshot, propagations[0]);\\n+        //var combinedCommands = this._combineCommands(propagations[0]);\\n+        //LOG(\\\"Combined commands: \\\" + uneval(combinedCommands) + \\\"\\\\n\\\");\\n+        //var sortedCommands = this._sortCommands(combinedCommands);\\n+        //LOG(\\\"Sorted commands: \\\" + uneval(sortedCommands) + \\\"\\\\n\\\");\\n+        //this._applyCommands(combinedCommands);\\n+        this._applyCommands(propagations[0]);\\n         this._snapshot = this._wrapNode(localBookmarks);\\n       }\\n \\n@@ -604,10 +711,10 @@ BookmarksSyncService.prototype = {\\n         }\\n         keys = keys.sort();\\n         for (var i = 0; i < keys.length; i++) {\\n-          this._sync.applyCommands(tmp, this._sanitizeCommands(ret.deltas[keys[i]]));\\n+          this._applyCommandsToObj(tmp, ret.deltas[keys[i]]);\\n         }\\n         ret.status = 1;\\n-        ret.updates = this._sync.detectUpdates(this._snapshot, tmp);\\n+        ret.updates = this._detectUpdates(this._snapshot, tmp);\\n \\n       } else if (ret.deltas[this._snapshotVersion]) {\\n         LOG(\\\"No changes from server\\\");\\n@@ -627,7 +734,7 @@ BookmarksSyncService.prototype = {\\n         }\\n \\n         var tmp = eval(uneval(this._snapshot)); // fixme hack hack hack\\n-        this._sync.applyCommands(tmp, this._sanitizeCommands(data.updates));\\n+        this._applyCommandsToObj(tmp, data.updates);\\n \\n         // fixme: this is duplicated from above, need to do some refactoring\\n \\n@@ -640,11 +747,11 @@ BookmarksSyncService.prototype = {\\n         }\\n         keys = keys.sort();\\n         for (var i = 0; i < keys.length; i++) {\\n-          this._sync.applyCommands(tmp, this._sanitizeCommands(ret.deltas[keys[i]]));\\n+          this._applyCommandsToObj(tmp, ret.deltas[keys[i]]);\\n         }\\n \\n         ret.status = data.status;\\n-        ret.updates = this._sync.detectUpdates(this._snapshot, tmp);\\n+        ret.updates = this._detectUpdates(this._snapshot, tmp);\\n         ret.version = data.version;\\n         var keys = [];\\n         for (var v in ret.deltas) {\\n@@ -681,7 +788,7 @@ BookmarksSyncService.prototype = {\\n       LOG(\\\"Got full bookmarks file from server\\\");\\n       var tmp = eval(data.target.responseText);\\n       ret.status = 1;\\n-      ret.updates = this._sync.detectUpdates(this._snapshot, tmp.snapshot);\\n+      ret.updates = this._detectUpdates(this._snapshot, tmp.snapshot);\\n       ret.version = tmp.version;\\n       break;\\n     case 404:\\n\""}