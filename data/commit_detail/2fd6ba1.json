{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas2fd6ba1\""},"diff":"\"2fd6ba1 Bug 394692 - ASSERTION: read cursor is bad: 'mReadCursor != mWriteCursor', file xpcom/io/nsPipe3.cpp, line 539.  Narrow the criteria used to decide whether to fire the assertion to deal with a particular (valid) pattern of memory allocations.  r=biesi, a=bz\\ndiff --git a/xpcom/io/nsPipe3.cpp b/xpcom/io/nsPipe3.cpp\\nindex 20cd6ec..409646e 100644\\n--- a/xpcom/io/nsPipe3.cpp\\n+++ b/xpcom/io/nsPipe3.cpp\\n@@ -536,7 +536,29 @@ nsPipe::AdvanceWriteCursor(PRUint32 bytesWritten)\\n \\n         mWriteCursor = newWriteCursor;\\n \\n-        NS_ASSERTION(mReadCursor != mWriteCursor, \\\"read cursor is bad\\\");\\n+        // The only way mReadCursor == mWriteCursor is if:\\n+        //\\n+        // - mReadCursor is at the start of a segment (which, based on how\\n+        //   nsSegmentedBuffer works, means that this segment is the \\\"first\\\"\\n+        //   segment)\\n+        // - mWriteCursor points at the location past the end of the current\\n+        //   write segment (so the current write filled the current write\\n+        //   segment, so we've incremented mWriteCursor to point past the end\\n+        //   of it)\\n+        // - the segment to which data has just been written is located\\n+        //   exactly one segment's worth of bytes before the first segment\\n+        //   where mReadCursor is located\\n+        //\\n+        // Consequently, the byte immediately after the end of the current\\n+        // write segment is the first byte of the first segment, so\\n+        // mReadCursor == mWriteCursor.  (Another way to think about this is\\n+        // to consider the buffer architecture diagram above, but consider it\\n+        // with an arena allocator which allocates from the *end* of the\\n+        // arena to the *beginning* of the arena.)\\n+        NS_ASSERTION(mReadCursor != mWriteCursor ||\\n+                     (mBuffer.GetSegment(0) == mReadCursor &&\\n+                      mWriteCursor == mWriteLimit),\\n+                     \\\"read cursor is bad\\\");\\n \\n         // update the writable flag on the output stream\\n         if (mWriteCursor == mWriteLimit) {\\ndiff --git a/xpcom/tests/Makefile.in b/xpcom/tests/Makefile.in\\nindex f77f932..89c3a51 100644\\n--- a/xpcom/tests/Makefile.in\\n+++ b/xpcom/tests/Makefile.in\\n@@ -72,6 +72,7 @@ CPPSRCS\\t\\t= \\\\\\n \\t\\tTestAutoPtr.cpp \\\\\\n \\t\\tTestVersionComparator.cpp \\\\\\n \\t\\tTestTextFormatter.cpp \\\\\\n+\\t\\tTestPipe.cpp \\\\\\n \\t\\t$(NULL)\\n \\n ifndef MOZ_ENABLE_LIBXUL\\n@@ -123,6 +124,8 @@ ENABLE_CXX_EXCEPTIONS = 1\\n \\n XPCSHELL_TESTS = unit\\n \\n+CPP_UNIT_TESTS = TestPipe\\n+\\n include $(topsrcdir)/config/rules.mk\\n \\n LOCAL_INCLUDES\\t= \\\\\\n@@ -141,3 +144,7 @@ check::\\n \\t@$(PERL) -w $(srcdir)/TestVersionComparatorRunner.pl \\\"$(RUN_TEST_PROGRAM) $(FINAL_TARGET)/TestVersionComparator$(BIN_SUFFIX)\\\"\\n \\t@echo \\\"Running nsTextFormatter tests\\\"\\n \\t@$(RUN_TEST_PROGRAM) $(FINAL_TARGET)/TestTextFormatter$(BIN_SUFFIX)\\n+\\t@$(EXIT_ON_ERROR) \\\\\\n+\\tfor f in $(CPP_UNIT_TESTS); do \\\\\\n+\\t  XPCOM_DEBUG_BREAK=stack-and-abort $(RUN_TEST_PROGRAM) $(DIST)/bin/$$f; \\\\\\n+\\tdone\\ndiff --git a/xpcom/tests/TestHarness.h b/xpcom/tests/TestHarness.h\\nnew file mode 100644\\nindex 0000000..ac90c47\\n--- /dev/null\\n+++ b/xpcom/tests/TestHarness.h\\n@@ -0,0 +1,94 @@\\n+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is mozilla.org code.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Jeff Walden <jwalden+code@mit.edu>.\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either of the GNU General Public License Version 2 or later (the \\\"GPL\\\"),\\n+ * or the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+\\n+/*\\n+ * Test harness for XPCOM objects, providing a scoped XPCOM initializer,\\n+ * nsCOMPtr, nsRefPtr, and stdio.h/stdlib.h.\\n+ */\\n+\\n+#ifndef TestHarness_h__\\n+#define TestHarness_h__\\n+\\n+#include \\\"nsIServiceManager.h\\\"\\n+#include \\\"nsCOMPtr.h\\\"\\n+#include \\\"nsAutoPtr.h\\\"\\n+#include <stdio.h>\\n+#include <stdlib.h>\\n+\\n+class ScopedXPCOM\\n+{\\n+  public:\\n+    ScopedXPCOM(const char* testName)\\n+    {\\n+      mTestName = testName;\\n+      printf(\\\"Running %s tests...\\\\n\\\", mTestName);\\n+\\n+      nsresult rv = NS_InitXPCOM2(&mServMgr, NULL, NULL);\\n+      if (NS_FAILED(rv))\\n+      {\\n+        printf(\\\"FAIL NS_InitXPCOM2 returned failure code %x\\\\n\\\", rv);\\n+        mServMgr = NULL;\\n+      }\\n+    }\\n+\\n+    ~ScopedXPCOM()\\n+    {\\n+      if (mServMgr)\\n+      {\\n+        NS_RELEASE(mServMgr);\\n+        nsresult rv = NS_ShutdownXPCOM(NULL);\\n+        if (NS_FAILED(rv))\\n+        {\\n+          printf(\\\"FAIL XPCOM shutdown failed with code %x\\\\n\\\", rv);\\n+          exit(1);\\n+        }\\n+      }\\n+\\n+      printf(\\\"Finished running %s tests.\\\\n\\\", mTestName);\\n+    }\\n+\\n+    PRBool failed()\\n+    {\\n+      return mServMgr == NULL;\\n+    }\\n+\\n+  private:\\n+    const char* mTestName;\\n+    nsIServiceManager* mServMgr;\\n+};\\n+\\n+#endif  // TestHarness_h__\\ndiff --git a/xpcom/tests/TestPipe.cpp b/xpcom/tests/TestPipe.cpp\\nnew file mode 100644\\nindex 0000000..08d3b6f\\n--- /dev/null\\n+++ b/xpcom/tests/TestPipe.cpp\\n@@ -0,0 +1,243 @@\\n+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is mozilla.org code.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Jeff Walden <jwalden+code@mit.edu>.\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either of the GNU General Public License Version 2 or later (the \\\"GPL\\\"),\\n+ * or the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+\\n+#include \\\"TestHarness.h\\\"\\n+\\n+#include \\\"nsIPipe.h\\\"\\n+#include \\\"nsIMemory.h\\\"\\n+\\n+/**\\n+ * Allocator can allocate exactly count * size bytes, stored at mMemory;\\n+ * immediately after the end of this is a byte-map of 0/1 values indicating\\n+ * which <size>-byte locations in mMemory are empty and which are filled.\\n+ * Pretty stupid, but enough to test bug 394692.\\n+ */\\n+class BackwardsAllocator : public nsIMemory\\n+{\\n+  public:\\n+    BackwardsAllocator()\\n+      : mMemory(0),\\n+        mIndex(0xFFFFFFFF),\\n+        mCount(0xFFFFFFFF),\\n+        mSize(0)\\n+    { }\\n+    ~BackwardsAllocator()\\n+    {\\n+      delete [] mMemory;\\n+    }\\n+\\n+    nsresult Init(PRUint32 count, size_t size);\\n+\\n+    NS_DECL_ISUPPORTS\\n+    NS_DECL_NSIMEMORY\\n+\\n+  private:\\n+    PRUint32 previous(PRUint32 i)\\n+    {\\n+      if (i == 0)\\n+        return mCount - 1;\\n+      return i - 1;\\n+    }\\n+\\n+  private:\\n+    PRUint8* mMemory;\\n+    PRUint32 mIndex;\\n+    PRUint32 mCount;\\n+    size_t mSize;\\n+};\\n+\\n+NS_IMPL_ISUPPORTS1(BackwardsAllocator, nsIMemory)\\n+\\n+NS_IMETHODIMP BackwardsAllocator::Init(PRUint32 count, size_t size)\\n+{\\n+  if (mMemory)\\n+  {\\n+    printf(\\\"FAIL allocator already initialized!\\\\n\\\");\\n+    return NS_ERROR_ALREADY_INITIALIZED;\\n+  }\\n+\\n+  mMemory = new PRUint8[count * size + count];\\n+  if (!mMemory)\\n+  {\\n+    printf(\\\"FAIL failed to allocate mMemory!\\\\n\\\");\\n+    return NS_ERROR_OUT_OF_MEMORY;\\n+  }\\n+  memset(mMemory, 0, count * size + count);\\n+\\n+  mIndex = 0;\\n+  mCount = count;\\n+  mSize = size;\\n+\\n+  return NS_OK;\\n+}\\n+\\n+NS_IMETHODIMP_(void*) BackwardsAllocator::Alloc(size_t size)\\n+{\\n+  if (size != mSize)\\n+  {\\n+    NS_ERROR(\\\"umm, why would this be reached for this test?\\\");\\n+    return NULL;\\n+  }\\n+\\n+  PRUint32 index = mIndex;\\n+\\n+  while ((index = previous(index)) != mIndex)\\n+  {\\n+    if (mMemory[mSize * mCount + index] == 1)\\n+      continue;\\n+    mMemory[mSize * mCount + index] = 1;\\n+    mIndex = index;\\n+    return &mMemory[mSize * index];\\n+  }\\n+\\n+  NS_ERROR(\\\"shouldn't reach here in this test\\\");\\n+  return NULL;\\n+}\\n+\\n+NS_IMETHODIMP_(void*) BackwardsAllocator::Realloc(void* ptr, size_t newSize)\\n+{\\n+  NS_ERROR(\\\"shouldn't reach here in this test\\\");\\n+  return NULL;\\n+}\\n+\\n+NS_IMETHODIMP_(void) BackwardsAllocator::Free(void* ptr)\\n+{\\n+  PRUint8* p = static_cast<PRUint8*>(ptr);\\n+  if (p)\\n+    mMemory[mCount * mSize + (p - mMemory) / mSize] = 0;\\n+}\\n+\\n+NS_IMETHODIMP BackwardsAllocator::HeapMinimize(PRBool immediate)\\n+{\\n+  return NS_OK;\\n+}\\n+\\n+NS_IMETHODIMP BackwardsAllocator::IsLowMemory(PRBool* retval)\\n+{\\n+  *retval = PR_FALSE;\\n+  return NS_OK;\\n+}\\n+\\n+\\n+nsresult TestBackwardsAllocator()\\n+{\\n+  const PRUint32 SEGMENT_COUNT = 10;\\n+  const size_t SEGMENT_SIZE = 10;\\n+\\n+  nsRefPtr<BackwardsAllocator> allocator = new BackwardsAllocator();\\n+  if (!allocator)\\n+  {\\n+    printf(\\\"Allocation of BackwardsAllocator failed!\\\\n\\\");\\n+    return NS_ERROR_OUT_OF_MEMORY;\\n+  }\\n+  nsresult rv = allocator->Init(SEGMENT_COUNT, SEGMENT_SIZE);\\n+  if (NS_FAILED(rv))\\n+    return rv;\\n+\\n+  nsCOMPtr<nsIAsyncInputStream> input;\\n+  nsCOMPtr<nsIAsyncOutputStream> output;\\n+  rv = NS_NewPipe2(getter_AddRefs(input),\\n+                   getter_AddRefs(output),\\n+                   PR_FALSE,\\n+                   PR_FALSE,\\n+                   SEGMENT_SIZE, SEGMENT_COUNT, allocator); \\n+  if (NS_FAILED(rv))\\n+  {\\n+    printf(\\\"FAIL NS_NewPipe2 failed: %x\\\\n\\\", rv);\\n+    return rv;\\n+  }\\n+\\n+  const PRUint32 BUFFER_LENGTH = 100;\\n+  const char written[] =\\n+    \\\"0123456789\\\"\\n+    \\\"1123456789\\\"\\n+    \\\"2123456789\\\"\\n+    \\\"3123456789\\\"\\n+    \\\"4123456789\\\"\\n+    \\\"5123456789\\\"\\n+    \\\"6123456789\\\"\\n+    \\\"7123456789\\\"\\n+    \\\"8123456789\\\"\\n+    \\\"9123456789\\\"; // not just a memset, to ensure the allocator works correctly\\n+  if (sizeof(written) < BUFFER_LENGTH)\\n+  {\\n+    printf(\\\"FAIL test error with string size\\\\n\\\");\\n+    return NS_ERROR_FAILURE;\\n+  }\\n+\\n+  PRUint32 writeCount;\\n+  rv = output->Write(written, BUFFER_LENGTH, &writeCount);\\n+  if (NS_FAILED(rv) || writeCount != BUFFER_LENGTH)\\n+  {\\n+    printf(\\\"FAIL writing %d bytes (wrote %d bytes) to output failed: %x\\\\n\\\",\\n+           BUFFER_LENGTH, writeCount, rv);\\n+    return rv;\\n+  }\\n+\\n+  char read[BUFFER_LENGTH];\\n+  PRUint32 readCount;\\n+  rv = input->Read(read, BUFFER_LENGTH, &readCount);\\n+  if (NS_FAILED(rv) || readCount != BUFFER_LENGTH)\\n+  {\\n+    printf(\\\"FAIL reading %d bytes (got %d bytes) from input failed: %x\\\\n\\\",\\n+           BUFFER_LENGTH, readCount,  rv);\\n+    return rv;\\n+  }\\n+\\n+  if (0 != memcmp(written, read, BUFFER_LENGTH))\\n+  {\\n+    printf(\\\"FAIL didn't read the written data correctly!\\\\n\\\");\\n+    return NS_ERROR_FAILURE;\\n+  }\\n+\\n+  printf(\\\"TestBackwardsAllocator PASSED!\\\\n\\\");\\n+  return NS_OK;\\n+}\\n+\\n+int main(int argc, char** argv)\\n+{\\n+  ScopedXPCOM xpcom(\\\"nsPipe\\\");\\n+  if (xpcom.failed())\\n+    return 1;\\n+\\n+  int rv = 0;\\n+\\n+  if (NS_FAILED(TestBackwardsAllocator()))\\n+    rv = 1;\\n+\\n+  return rv;\\n+}\\n\""}