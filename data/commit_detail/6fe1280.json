{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas6fe1280\""},"diff":"\"6fe1280 Fix hangs in nested Gecko event loops (caused by bug 395397 appshell patch). b=397439 r=mark sr=roc a=roc\\ndiff --git a/widget/src/cocoa/nsAppShell.h b/widget/src/cocoa/nsAppShell.h\\nindex a0e9669..7f73dfa 100644\\n--- a/widget/src/cocoa/nsAppShell.h\\n+++ b/widget/src/cocoa/nsAppShell.h\\n@@ -72,6 +72,8 @@ protected:\\n   virtual void ScheduleNativeEventCallback();\\n   virtual PRBool ProcessNextNativeEvent(PRBool aMayWait);\\n \\n+  PRBool InGeckoMainEventLoop();\\n+\\n   static void ProcessGeckoEvents(void* aInfo);\\n \\n protected:\\n@@ -96,6 +98,9 @@ protected:\\n   // reduced the number of calls by 6%-7% (reducing the original regression\\n   // to 3%-4%).  See bmo bug 395397.\\n   static const PRUint32  kHadMoreEventsCountMax = 3;\\n+\\n+  PRInt32            mRecursionDepth;\\n+  PRInt32            mNativeEventCallbackDepth;\\n };\\n \\n #endif // nsAppShell_h_\\ndiff --git a/widget/src/cocoa/nsAppShell.mm b/widget/src/cocoa/nsAppShell.mm\\nindex 1733ca4b..17c253d 100644\\n--- a/widget/src/cocoa/nsAppShell.mm\\n+++ b/widget/src/cocoa/nsAppShell.mm\\n@@ -110,6 +110,8 @@ nsAppShell::nsAppShell()\\n , mTerminated(PR_FALSE)\\n , mSkippedNativeCallback(PR_FALSE)\\n , mHadMoreEventsCount(0)\\n+, mRecursionDepth(0)\\n+, mNativeEventCallbackDepth(0)\\n {\\n   // mMainPool sits low on the autorelease pool stack to serve as a catch-all\\n   // for autoreleased objects on this thread.  Because it won't be popped\\n@@ -266,7 +268,9 @@ nsAppShell::ProcessGeckoEvents(void* aInfo)\\n   }\\n \\n   if (self->mSuspendNativeCount <= 0) {\\n+    ++self->mNativeEventCallbackDepth;\\n     self->NativeEventCallback();\\n+    --self->mNativeEventCallbackDepth;\\n   } else {\\n     self->mSkippedNativeCallback = PR_TRUE;\\n   }\\n@@ -438,10 +442,11 @@ nsAppShell::ProcessNextNativeEvent(PRBool aMayWait)\\n \\n     NSEvent* nextEvent = nil;\\n \\n-    // If we're running modal (either Cocoa modal or XUL modal) we still need\\n-    // to use nextEventMatchingMask and sendEvent -- otherwise (in Minefield)\\n-    // the modal window won't receive key events or most mouse events.\\n-    if ([NSApp _isRunningModal] || (gXULModalLevel > 0)) {\\n+    // If we're running modal (or not in a Gecko \\\"main\\\" event loop) we still\\n+    // need to use nextEventMatchingMask and sendEvent -- otherwise (in\\n+    // Minefield) the modal window (or non-main event loop) won't receive key\\n+    // events or most mouse events.\\n+    if ([NSApp _isRunningModal] || !InGeckoMainEventLoop()) {\\n       if (nextEvent = [NSApp nextEventMatchingMask:NSAnyEventMask\\n                                          untilDate:waitUntil\\n                                             inMode:currentMode\\n@@ -489,6 +494,35 @@ nsAppShell::ProcessNextNativeEvent(PRBool aMayWait)\\n   return moreEvents;\\n }\\n \\n+// Returns PR_TRUE if Gecko events are currently being processed in its \\\"main\\\"\\n+// event loop (or one of its \\\"main\\\" event loops).  Returns PR_FALSE if Gecko\\n+// events are being processed in a \\\"nested\\\" event loop, or if we're not\\n+// running in any sort of Gecko event loop.  How we process native events in\\n+// ProcessNextNativeEvent() turns on our decision (and if we make the wrong\\n+// choice, the result may be a hang).\\n+//\\n+// We define the \\\"main\\\" event loop(s) as the place (or places) where Gecko\\n+// event processing \\\"normally\\\" takes place, and all other Gecko event loops\\n+// as \\\"nested\\\".  The \\\"nested\\\" event loops are normally processed while a call\\n+// from a \\\"main\\\" event loop is on the stack ... but not always.  For example,\\n+// the Venkman JavaScript debugger runs a \\\"nested\\\" event loop (in jsdService::\\n+// EnterNestedEventLoop()) whenever it breaks into the current script.  But\\n+// if this happens as the result of the user pressing a key combination, there\\n+// won't be any other Gecko event-processing call on the stack (e.g.\\n+// NS_ProcessNextEvent() or NS_ProcessPendingEvents()).  (In the current\\n+// nsAppShell implementation, what counts as the \\\"main\\\" event loop is what\\n+// nsBaseAppShell::NativeEventCallback() does to process Gecko events.  We\\n+// don't currently use nsBaseAppShell::Run().)\\n+PRBool\\n+nsAppShell::InGeckoMainEventLoop()\\n+{\\n+  if ((gXULModalLevel > 0) || (mRecursionDepth > 0))\\n+    return PR_FALSE;\\n+  if (mNativeEventCallbackDepth <= 0)\\n+    return PR_FALSE;\\n+  return PR_TRUE;\\n+}\\n+\\n // Run\\n //\\n // Overrides the base class's Run() method to call [NSApp run] (which spins\\n@@ -563,6 +597,8 @@ NS_IMETHODIMP\\n nsAppShell::OnProcessNextEvent(nsIThreadInternal *aThread, PRBool aMayWait,\\n                                PRUint32 aRecursionDepth)\\n {\\n+  mRecursionDepth = aRecursionDepth;\\n+\\n   NS_ASSERTION(mAutoreleasePools,\\n                \\\"No stack on which to store autorelease pool\\\");\\n \\n@@ -583,6 +619,8 @@ NS_IMETHODIMP\\n nsAppShell::AfterProcessNextEvent(nsIThreadInternal *aThread,\\n                                   PRUint32 aRecursionDepth)\\n {\\n+  mRecursionDepth = aRecursionDepth;\\n+\\n   CFIndex count = ::CFArrayGetCount(mAutoreleasePools);\\n \\n   NS_ASSERTION(mAutoreleasePools && count,\\n\""}