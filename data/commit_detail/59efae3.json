{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas59efae3\""},"diff":"\"59efae3 Bug 395909. Should not require namespaces for ARIA role usage in text/html. r=surkov, a=dsicore\\ndiff --git a/accessible/public/nsIAccessibilityService.idl b/accessible/public/nsIAccessibilityService.idl\\nindex 568ec53..eabeafc 100644\\n--- a/accessible/public/nsIAccessibilityService.idl\\n+++ b/accessible/public/nsIAccessibilityService.idl\\n@@ -55,7 +55,7 @@ interface nsIAccessibilityService : nsIAccessibleRetrieval\\n   nsIAccessible createHyperTextAccessible(in nsISupports aFrame);\\n   nsIAccessible createHTMLBRAccessible(in nsISupports aFrame);\\n   nsIAccessible createHTMLButtonAccessible(in nsISupports aFrame);\\n-  nsIAccessible createHTMLAccessibleByMarkup(in nsIFrame aFrame, in nsIWeakReference aWeakShell, in nsIDOMNode aDOMNode, in AString aRole);\\n+  nsIAccessible createHTMLAccessibleByMarkup(in nsIFrame aFrame, in nsIWeakReference aWeakShell, in nsIDOMNode aDOMNode);\\n   nsIAccessible createHTMLLIAccessible(in nsISupports aFrame, in nsISupports aBulletFrame, in AString aBulletText);\\n   nsIAccessible createHTMLCheckboxAccessible(in nsISupports aFrame);\\n   nsIAccessible createHTMLComboboxAccessible(in nsIDOMNode aNode, in nsIWeakReference aPresShell);\\ndiff --git a/accessible/src/base/nsAccessNode.cpp b/accessible/src/base/nsAccessNode.cpp\\nindex 705a914..8ddea6d 100755\\n--- a/accessible/src/base/nsAccessNode.cpp\\n+++ b/accessible/src/base/nsAccessNode.cpp\\n@@ -47,12 +47,14 @@\\n #include \\\"nsIDocShellTreeItem.h\\\"\\n #include \\\"nsIDocument.h\\\"\\n #include \\\"nsIDocumentViewer.h\\\"\\n+#include \\\"nsIDOM3Node.h\\\"\\n #include \\\"nsIDOMCSSStyleDeclaration.h\\\"\\n #include \\\"nsIDOMCSSPrimitiveValue.h\\\"\\n #include \\\"nsIDOMDocument.h\\\"\\n #include \\\"nsIDOMElement.h\\\"\\n #include \\\"nsIDOMHTMLDocument.h\\\"\\n #include \\\"nsIDOMHTMLElement.h\\\"\\n+#include \\\"nsIDOMNSDocument.h\\\"\\n #include \\\"nsIDOMNSHTMLElement.h\\\"\\n #include \\\"nsIDOMViewCSS.h\\\"\\n #include \\\"nsIDOMWindow.h\\\"\\n@@ -890,3 +892,71 @@ nsAccessNode::GetLanguage(nsAString& aLanguage)\\n   return NS_OK;\\n }\\n \\n+PRBool\\n+nsAccessNode::GetARIARole(nsIContent *aContent, nsString& aRole)\\n+{\\n+  nsAutoString prefix;\\n+  PRBool strictPrefixChecking = PR_TRUE;\\n+  aRole.Truncate();\\n+\\n+  if (aContent->IsNodeOfType(nsINode::eHTML)) { // HTML node\\n+    // Allow non-namespaced role attribute in HTML\\n+    aContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::role, aRole);\\n+    // Find non-namespaced role attribute on HTML node\\n+    nsCOMPtr<nsIDOMNSDocument> doc(do_QueryInterface(aContent->GetDocument()));\\n+    if (doc) {\\n+      // In text/html we are hardcoded to allow the exact prefix \\\"wairole:\\\" to \\n+      // always indicate that we are using the WAI roles.\\n+      // This allows ARIA to be used within text/html where namespaces cannot be defined.\\n+      // We also now relax the prefix checking, which means no prefix is required to use WAI Roles\\n+      nsAutoString mimeType;\\n+      doc->GetContentType(mimeType);\\n+      if (mimeType.EqualsLiteral(\\\"text/html\\\")) {\\n+        prefix = NS_LITERAL_STRING(\\\"wairole:\\\");\\n+        strictPrefixChecking = PR_FALSE;\\n+      }\\n+    }\\n+  }\\n+\\n+  // Try namespaced-role attribute (xhtml or xhtml2 namespace) -- allowed in any kind of content\\n+  if (aRole.IsEmpty() && !aContent->GetAttr(kNameSpaceID_XHTML, nsAccessibilityAtoms::role, aRole) &&\\n+      !aContent->GetAttr(kNameSpaceID_XHTML2_Unofficial, nsAccessibilityAtoms::role, aRole)) {\\n+    return PR_FALSE;\\n+  }\\n+\\n+  PRBool hasPrefix = (aRole.Find(\\\":\\\") >= 0);\\n+\\n+  if (!hasPrefix) {\\n+    // * No prefix* -- not a QName\\n+    // Just return entire string as long as prefix is not currently required\\n+    if (strictPrefixChecking) {\\n+      // Prefix was required and we didn't have one\\n+      aRole.Truncate();\\n+      return PR_FALSE;\\n+    }\\n+    return PR_TRUE;\\n+  }\\n+\\n+  // * Has prefix * -- is a QName (role=\\\"prefix:rolename\\\")\\n+  if (strictPrefixChecking) {  // Not text/html, we need to actually find the WAIRole prefix\\n+    // QI to nsIDOM3Node causes some overhead. Unfortunately we need to do this each\\n+    // time there is a prefixed role attribute, because the prefix to namespace mappings\\n+    // can change within any subtree via the xmlns attribute\\n+    nsCOMPtr<nsIDOM3Node> dom3Node(do_QueryInterface(aContent));\\n+    if (dom3Node) {\\n+      // Look up exact prefix name for WAI Roles\\n+      NS_NAMED_LITERAL_STRING(kWAIRoles_Namespace, \\\"http://www.w3.org/2005/01/wai-rdf/GUIRoleTaxonomy#\\\");\\n+      dom3Node->LookupPrefix(kWAIRoles_Namespace, prefix);\\n+      prefix += ':';\\n+    }\\n+  }\\n+\\n+  PRUint32 length = prefix.Length();\\n+  if (length > 1 && StringBeginsWith(aRole, prefix)) {\\n+    // Is a QName (role=\\\"prefix:rolename\\\"), and prefix matches WAI Role prefix\\n+    // Trim the WAI Role prefix off\\n+    aRole.Cut(0, length);\\n+  }\\n+\\n+  return PR_TRUE;\\n+}\\ndiff --git a/accessible/src/base/nsAccessNode.h b/accessible/src/base/nsAccessNode.h\\nindex 81673a8..9eb824a 100755\\n--- a/accessible/src/base/nsAccessNode.h\\n+++ b/accessible/src/base/nsAccessNode.h\\n@@ -71,6 +71,16 @@ class nsApplicationAccessibleWrap;\\n typedef nsInterfaceHashtable<nsVoidPtrHashKey, nsIAccessNode>\\n         nsAccessNodeHashtable;\\n \\n+/**\\n+ * Does the current content have this ARIA role? \\n+ * Implemented as a compiler macro so that length can be computed at compile time.\\n+ * @param aContent  Node to get role string from\\n+ * @param aRoleName Role string to compare with -- literal const char*\\n+ * @return PR_TRUE if there is a match\\n+ */\\n+#define ARIARoleEquals(aContent, aRoleName) \\\\\\n+  nsAccessNode::ARIARoleEqualsImpl(aContent, aRoleName, NS_ARRAY_LENGTH(aRoleName) - 1)\\n+\\n class nsAccessNode: public nsIAccessNode, public nsPIAccessNode\\n {\\n   public: // construction, destruction\\n@@ -114,14 +124,16 @@ class nsAccessNode: public nsIAccessNode, public nsPIAccessNode\\n               aContent->HasAttr(kNameSpaceID_XHTML2_Unofficial, nsAccessibilityAtoms::role);\\n     }\\n \\n-    // Return PR_TRUE if there is a role attribute, and fill it into aRole\\n-    static PRBool GetRoleAttribute(nsIContent *aContent, nsAString& aRole)\\n-    {\\n-      aRole.Truncate();\\n-      return (aContent->IsNodeOfType(nsINode::eHTML) && aContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::role, aRole)) ||\\n-              aContent->GetAttr(kNameSpaceID_XHTML, nsAccessibilityAtoms::role, aRole) ||\\n-              aContent->GetAttr(kNameSpaceID_XHTML2_Unofficial, nsAccessibilityAtoms::role, aRole);\\n-    }\\n+    /**\\n+     * Provide the role string if there is one\\n+     * @param aContent Node to get role string from\\n+     * @param aRole String to fill role into\\n+     * @return PR_TRUE if there is a role attribute, and fill it into aRole\\n+     */\\n+    static PRBool GetARIARole(nsIContent *aContent, nsString& aRole);\\n+\\n+    static PRBool ARIARoleEqualsImpl(nsIContent* aContent, const char* aRoleName, PRUint32 aLen)\\n+      { nsAutoString role; return GetARIARole(aContent, role) && role.EqualsASCII(aRoleName, aLen); }\\n \\n     static void GetComputedStyleDeclaration(const nsAString& aPseudoElt,\\n                                             nsIDOMElement *aElement,\\ndiff --git a/accessible/src/base/nsAccessibilityService.cpp b/accessible/src/base/nsAccessibilityService.cpp\\nindex 87d2423..a53d833 100644\\n--- a/accessible/src/base/nsAccessibilityService.cpp\\n+++ b/accessible/src/base/nsAccessibilityService.cpp\\n@@ -434,7 +434,6 @@ nsresult\\n nsAccessibilityService::CreateHTMLAccessibleByMarkup(nsIFrame *aFrame,\\n                                                      nsIWeakReference *aWeakShell,\\n                                                      nsIDOMNode *aNode,\\n-                                                     const nsAString& aRole,\\n                                                      nsIAccessible **aAccessible)\\n {\\n   // This method assumes we're in an HTML namespace.\\n@@ -1337,9 +1336,7 @@ NS_IMETHODIMP nsAccessibilityService::GetAccessible(nsIDOMNode *aNode,\\n   }\\n \\n   nsAutoString role;\\n-  if (nsAccessNode::GetRoleAttribute(content, role) &&\\n-      StringEndsWith(role, NS_LITERAL_STRING(\\\":presentation\\\")) &&\\n-      !content->IsFocusable()) {\\n+  if (nsAccessNode::GetARIARole(content, role) && role.EqualsLiteral(\\\"presentation\\\") && !content->IsFocusable()) {\\n     // Only create accessible for role=\\\":presentation\\\" if it is focusable --\\n     // in that case we need an accessible in case it gets focused, we\\n     // don't want focus ever to be 'lost'\\n@@ -1366,7 +1363,7 @@ NS_IMETHODIMP nsAccessibilityService::GetAccessible(nsIDOMNode *aNode,\\n   } else if (!newAcc) {  // HTML accessibles\\n     // Prefer to use markup (mostly tag name, perhaps attributes) to\\n     // decide if and what kind of accessible to create.\\n-    CreateHTMLAccessibleByMarkup(frame, aWeakShell, aNode, role, getter_AddRefs(newAcc));\\n+    CreateHTMLAccessibleByMarkup(frame, aWeakShell, aNode, getter_AddRefs(newAcc));\\n \\n     PRBool tryFrame = (newAcc == nsnull);\\n     if (!content->IsFocusable()) { \\ndiff --git a/accessible/src/base/nsAccessible.cpp b/accessible/src/base/nsAccessible.cpp\\nindex f7e57ac..4089ff6 100644\\n--- a/accessible/src/base/nsAccessible.cpp\\n+++ b/accessible/src/base/nsAccessible.cpp\\n@@ -45,7 +45,6 @@\\n #include \\\"nsIAccessibleHyperText.h\\\"\\n #include \\\"nsAccessibleTreeWalker.h\\\"\\n \\n-#include \\\"nsIDOM3Node.h\\\"\\n #include \\\"nsIDOMElement.h\\\"\\n #include \\\"nsIDOMDocument.h\\\"\\n #include \\\"nsIDOMDocumentXBL.h\\\"\\n@@ -53,7 +52,6 @@\\n #include \\\"nsIDOMHTMLDocument.h\\\"\\n #include \\\"nsIDOMHTMLFormElement.h\\\"\\n #include \\\"nsIDOMNodeFilter.h\\\"\\n-#include \\\"nsIDOMNSDocument.h\\\"\\n #include \\\"nsIDOMNSHTMLElement.h\\\"\\n #include \\\"nsIDOMTreeWalker.h\\\"\\n #include \\\"nsIDOMXULButtonElement.h\\\"\\n@@ -475,45 +473,18 @@ NS_IMETHODIMP nsAccessible::Init()\\n {\\n   nsIContent *content = GetRoleContent(mDOMNode);\\n   nsAutoString roleString;\\n-  if (content && GetRoleAttribute(content, roleString)) {\\n-    // QI to nsIDOM3Node causes some overhead. Unfortunately we need to do this each\\n-    // time there is a role attribute, because the prefixe to namespace mappings\\n-    // can change within any subtree via the xmlns attribute\\n-    nsCOMPtr<nsIDOM3Node> dom3Node(do_QueryInterface(content));\\n-    if (dom3Node) {\\n-      nsAutoString prefix;\\n-      NS_NAMED_LITERAL_STRING(kWAIRoles_Namespace, \\\"http://www.w3.org/2005/01/wai-rdf/GUIRoleTaxonomy#\\\");\\n-      dom3Node->LookupPrefix(kWAIRoles_Namespace, prefix);\\n-      if (prefix.IsEmpty()) {\\n-        // In HTML we are hardcoded to allow the exact prefix \\\"wairole:\\\" to \\n-        // always indicate that we are using the WAI roles. This allows DHTML accessibility\\n-        // to be used within HTML\\n-        nsCOMPtr<nsIDOMNSDocument> doc(do_QueryInterface(content->GetDocument()));\\n-        if (doc) {\\n-          nsAutoString mimeType;\\n-          doc->GetContentType(mimeType);\\n-          if (mimeType.EqualsLiteral(\\\"text/html\\\")) {\\n-            prefix = NS_LITERAL_STRING(\\\"wairole\\\");\\n-          }\\n-        }\\n-      }\\n-      prefix += ':';\\n-      PRUint32 length = prefix.Length();\\n-      if (length > 1 && StringBeginsWith(roleString, prefix)) {\\n-        roleString.Cut(0, length);\\n-        nsCString utf8Role = NS_ConvertUTF16toUTF8(roleString); // For easy comparison\\n-        ToLowerCase(utf8Role);\\n-        PRUint32 index;\\n-        for (index = 0; nsARIAMap::gWAIRoleMap[index].roleString; index ++) {\\n-          if (utf8Role.Equals(nsARIAMap::gWAIRoleMap[index].roleString)) {\\n-            break; // The dynamic role attribute maps to an entry in our table\\n-          }\\n-        }\\n-        // Always use some entry if there is a role string\\n-        // If no match, we use the last entry which maps to ROLE_NOTHING\\n-        mRoleMapEntry = &nsARIAMap::gWAIRoleMap[index];\\n+  if (content && GetARIARole(content, roleString)) {\\n+    nsCString utf8Role = NS_ConvertUTF16toUTF8(roleString); // For easy comparison\\n+    ToLowerCase(utf8Role);\\n+    PRUint32 index;\\n+    for (index = 0; nsARIAMap::gWAIRoleMap[index].roleString; index ++) {\\n+      if (utf8Role.Equals(nsARIAMap::gWAIRoleMap[index].roleString)) {\\n+        break; // The dynamic role attribute maps to an entry in our table\\n       }\\n     }\\n+    // Always use some entry if there is a role string\\n+    // If no match, we use the last entry which maps to ROLE_NOTHING\\n+    mRoleMapEntry = &nsARIAMap::gWAIRoleMap[index];\\n   }\\n \\n   return nsAccessNodeWrap::Init();\\n@@ -2067,7 +2038,7 @@ nsAccessible::GetAttributes(nsIPersistentProperties **aAttributes)\\n     // XXX In the future we may need to expose the dynamic content role inheritance chain\\n     // through this attribute\\n     nsAutoString xmlRole;\\n-    if (GetRoleAttribute(content, xmlRole)) {\\n+    if (GetARIARole(content, xmlRole)) {\\n       attributes->SetStringProperty(NS_LITERAL_CSTRING(\\\"xml-roles\\\"), xmlRole, oldValueUnused);          \\n     }\\n \\ndiff --git a/accessible/src/base/nsDocAccessible.cpp b/accessible/src/base/nsDocAccessible.cpp\\nindex 24e5d98..de777b8 100644\\n--- a/accessible/src/base/nsDocAccessible.cpp\\n+++ b/accessible/src/base/nsDocAccessible.cpp\\n@@ -1807,9 +1807,7 @@ NS_IMETHODIMP nsDocAccessible::InvalidateCacheSubtree(nsIContent *aChild,\\n                             eCoalesceFromSameSubtree, isAsynch);\\n \\n     // Check to see change occured in an ARIA menu, and fire an EVENT_MENUPOPUP_START if it did\\n-    nsAutoString role;\\n-    if (GetRoleAttribute(aChild, role) &&\\n-        StringEndsWith(role, NS_LITERAL_STRING(\\\":menu\\\"), nsCaseInsensitiveStringComparator())) {\\n+    if (ARIARoleEquals(aChild, \\\"menu\\\")) {\\n       FireDelayedToolkitEvent(nsIAccessibleEvent::EVENT_MENUPOPUP_START,\\n                               childNode, nsnull, eAllowDupes, isAsynch);\\n     }\\n@@ -1817,8 +1815,7 @@ NS_IMETHODIMP nsDocAccessible::InvalidateCacheSubtree(nsIContent *aChild,\\n     // Check to see if change occured inside an alert, and fire an EVENT_ALERT if it did\\n     nsIContent *ancestor = aChild;\\n     while (ancestor) {\\n-      if (GetRoleAttribute(ancestor, role) &&\\n-          StringEndsWith(role, NS_LITERAL_STRING(\\\":alert\\\"), nsCaseInsensitiveStringComparator())) {\\n+      if (ARIARoleEquals(ancestor, \\\"alert\\\")) {\\n         nsCOMPtr<nsIDOMNode> alertNode(do_QueryInterface(ancestor));\\n         FireDelayedToolkitEvent(nsIAccessibleEvent::EVENT_ALERT, alertNode, nsnull,\\n                                 eRemoveDupes, isAsynch);\\ndiff --git a/accessible/src/msaa/nsAccessibleWrap.cpp b/accessible/src/msaa/nsAccessibleWrap.cpp\\nindex 0b30f42..daa2a84 100644\\n--- a/accessible/src/msaa/nsAccessibleWrap.cpp\\n+++ b/accessible/src/msaa/nsAccessibleWrap.cpp\\n@@ -466,7 +466,7 @@ STDMETHODIMP nsAccessibleWrap::get_accRole(\\n \\n   if (content->IsNodeOfType(nsINode::eELEMENT)) {\\n     nsAutoString roleString;\\n-    if (msaaRole != ROLE_SYSTEM_CLIENT && !GetRoleAttribute(content, roleString)) {\\n+    if (msaaRole != ROLE_SYSTEM_CLIENT && !GetARIARole(content, roleString)) {\\n       nsINodeInfo *nodeInfo = content->NodeInfo();\\n       nodeInfo->GetName(roleString);\\n       nsAutoString nameSpaceURI;\\n\""}