{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basba27e80\""},"diff":"\"ba27e80 Print path to expected garbage along with refcount imbalances.  b=387224  r=graydon  a=brendan\\ndiff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp\\nindex 1af5a05..37425df 100644\\n--- a/xpcom/base/nsCycleCollector.cpp\\n+++ b/xpcom/base/nsCycleCollector.cpp\\n@@ -453,6 +453,7 @@ struct PtrInfo\\n     // For finding roots in ExplainLiveExpectedGarbage (when nodes\\n     // expected to be garbage are black).\\n     ReversedEdge* mReversedEdges; // linked list\\n+    PtrInfo* mShortestPathToExpectedGarbage;\\n #endif\\n \\n     PtrInfo(void *aPointer, nsCycleCollectionParticipant *aParticipant\\n@@ -471,7 +472,8 @@ struct PtrInfo\\n           mName(nsnull),\\n           mLangID(aLangID),\\n           mSCCIndex(0),\\n-          mReversedEdges(nsnull)\\n+          mReversedEdges(nsnull),\\n+          mShortestPathToExpectedGarbage(nsnull)\\n #endif\\n     {\\n     }\\n@@ -2315,10 +2317,13 @@ nsCycleCollector::ExplainLiveExpectedGarbage()\\n \\n             nsDeque queue; // for breadth-first search\\n             NodePool::Enumerator etor_roots(graph.mNodes);\\n-            for (PRUint32 i = suspectCurrentCount; i < graph.mRootCount; ++i) {\\n+            for (PRUint32 i = 0; i < graph.mRootCount; ++i) {\\n                 PtrInfo *root_pi = etor_roots.GetNext();\\n-                root_pi->mSCCIndex = INDEX_REACHED;\\n-                queue.Push(root_pi);\\n+                if (i >= suspectCurrentCount) {\\n+                    root_pi->mSCCIndex = INDEX_REACHED;\\n+                    root_pi->mShortestPathToExpectedGarbage = root_pi;\\n+                    queue.Push(root_pi);\\n+                }\\n             }\\n \\n             while (queue.GetSize() > 0) {\\n@@ -2326,7 +2331,10 @@ nsCycleCollector::ExplainLiveExpectedGarbage()\\n                 for (ReversedEdge *e = pi->mReversedEdges; e; e = e->mNext) {\\n                     if (e->mTarget->mSCCIndex == INDEX_UNREACHED) {\\n                         e->mTarget->mSCCIndex = INDEX_REACHED;\\n-                        queue.Push(e->mTarget);\\n+                        PtrInfo *target = e->mTarget;\\n+                        if (!target->mShortestPathToExpectedGarbage)\\n+                            target->mShortestPathToExpectedGarbage = pi;\\n+                        queue.Push(target);\\n                     }\\n                 }\\n \\n@@ -2337,11 +2345,19 @@ nsCycleCollector::ExplainLiveExpectedGarbage()\\n                            pi->mName, pi->mPointer,\\n                            pi->mRefCount - pi->mInternalRefs,\\n                            pi->mRefCount, pi->mInternalRefs);\\n+\\n+                    printf(\\\"  An object expected to be garbage could be \\\"\\n+                           \\\"reached from it by the path:\\\\n\\\");\\n+                    for (PtrInfo *path = pi, *prev = nsnull; prev != path;\\n+                         prev = path,\\n+                         path = path->mShortestPathToExpectedGarbage)\\n+                        printf(\\\"    %s %p\\\\n\\\", path->mName, path->mPointer);\\n+\\n                     printf(\\\"  The %d known references to it were from:\\\\n\\\",\\n                            pi->mInternalRefs);\\n                     for (ReversedEdge *e = pi->mReversedEdges;\\n                          e; e = e->mNext) {\\n-                        printf(\\\"  %s %p\\\\n\\\",\\n+                        printf(\\\"    %s %p\\\\n\\\",\\n                                e->mTarget->mName, e->mTarget->mPointer);\\n                     }\\n                     mRuntimes[pi->mLangID]->PrintAllReferencesTo(pi->mPointer);\\n\""}