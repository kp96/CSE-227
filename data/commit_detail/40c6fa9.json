{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas40c6fa9\""},"diff":"\"40c6fa9 Bug 391846. Fire correct text change events when a node is shown or hidden. r=surkov, sr=sicking, a=sicking\\ndiff --git a/accessible/public/nsIAccessibilityService.idl b/accessible/public/nsIAccessibilityService.idl\\nindex f544615..568ec53 100644\\n--- a/accessible/public/nsIAccessibilityService.idl\\n+++ b/accessible/public/nsIAccessibilityService.idl\\n@@ -98,8 +98,8 @@ interface nsIAccessibilityService : nsIAccessibleRetrieval\\n    *                           EVENT_HIDE (destroy or hide)\\n    */\\n   void invalidateSubtreeFor(in nsIPresShell aPresShell,\\n-                                       in nsIContent aChangedContent,\\n-                                       in PRUint32 aEvent);\\n+                            in nsIContent aChangedContent,\\n+                            in PRUint32 aEvent);\\n };\\n \\n \\ndiff --git a/accessible/public/nsIAccessibleEvent.idl b/accessible/public/nsIAccessibleEvent.idl\\nindex 15938f4..8d7d212 100755\\n--- a/accessible/public/nsIAccessibleEvent.idl\\n+++ b/accessible/public/nsIAccessibleEvent.idl\\n@@ -553,6 +553,11 @@ interface nsIAccessibleTextChangeEvent : nsIAccessibleEvent\\n    * Returns true if text was inserted, otherwise false.\\n    */\\n   boolean isInserted();\\n+\\n+  /**\\n+   * The inserted or removed text\\n+   */\\n+  readonly attribute DOMString modifiedText;\\n };\\n \\n [scriptable, uuid(b9076dce-4cd3-4e3d-a7f6-7f33a7f40c31)]\\ndiff --git a/accessible/src/base/nsAccessibilityService.cpp b/accessible/src/base/nsAccessibilityService.cpp\\nindex cc0050a..2288ff2 100644\\n--- a/accessible/src/base/nsAccessibilityService.cpp\\n+++ b/accessible/src/base/nsAccessibilityService.cpp\\n@@ -1804,11 +1804,14 @@ NS_IMETHODIMP nsAccessibilityService::InvalidateSubtreeFor(nsIPresShell *aShell,\\n {\\n   NS_ASSERTION(aEvent == nsIAccessibleEvent::EVENT_ASYNCH_SIGNIFICANT_CHANGE ||\\n                aEvent == nsIAccessibleEvent::EVENT_ASYNCH_SHOW ||\\n-               aEvent == nsIAccessibleEvent::EVENT_ASYNCH_HIDE,\\n+               aEvent == nsIAccessibleEvent::EVENT_ASYNCH_HIDE ||\\n+               aEvent == nsIAccessibleEvent::EVENT_DOM_SIGNIFICANT_CHANGE ||\\n+               aEvent == nsIAccessibleEvent::EVENT_DOM_CREATE ||\\n+               aEvent == nsIAccessibleEvent::EVENT_DOM_DESTROY,\\n                \\\"Incorrect aEvent passed in\\\");\\n \\n+  NS_ENSURE_ARG_POINTER(aShell);\\n   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aShell));\\n-  NS_ASSERTION(aShell, \\\"No pres shell in call to InvalidateSubtreeFor\\\");\\n   nsCOMPtr<nsIAccessibleDocument> accessibleDoc =\\n     nsAccessNode::GetDocAccessibleFor(weakShell);\\n   nsCOMPtr<nsPIAccessibleDocument> privateAccessibleDoc =\\ndiff --git a/accessible/src/base/nsAccessibleEventData.cpp b/accessible/src/base/nsAccessibleEventData.cpp\\nindex d14689c..f33e8e7 100755\\n--- a/accessible/src/base/nsAccessibleEventData.cpp\\n+++ b/accessible/src/base/nsAccessibleEventData.cpp\\n@@ -394,11 +394,16 @@ NS_IMPL_ISUPPORTS_INHERITED1(nsAccTextChangeEvent, nsAccEvent,\\n \\n nsAccTextChangeEvent::\\n   nsAccTextChangeEvent(nsIAccessible *aAccessible,\\n-                       PRInt32 aStart, PRUint32 aLength, PRBool aIsInserted):\\n+                       PRInt32 aStart, PRUint32 aLength, PRBool aIsInserted, PRBool aIsAsynch):\\n   nsAccEvent(aIsInserted ? nsIAccessibleEvent::EVENT_TEXT_INSERTED : nsIAccessibleEvent::EVENT_TEXT_REMOVED,\\n-             aAccessible, nsnull),\\n+             aAccessible, nsnull, aIsAsynch),\\n   mStart(aStart), mLength(aLength), mIsInserted(aIsInserted)\\n {\\n+  nsCOMPtr<nsIAccessibleText> textAccessible = do_QueryInterface(aAccessible);\\n+  NS_ASSERTION(textAccessible, \\\"Should not be firing test change event for non-text accessible!!!\\\");\\n+  if (textAccessible) {\\n+    textAccessible->GetText(aStart, aStart + aLength, mModifiedText);\\n+  }\\n }\\n \\n NS_IMETHODIMP\\n@@ -422,6 +427,13 @@ nsAccTextChangeEvent::IsInserted(PRBool *aIsInserted)\\n   return NS_OK;\\n }\\n \\n+NS_IMETHODIMP\\n+nsAccTextChangeEvent::GetModifiedText(nsAString& aModifiedText)\\n+{\\n+  aModifiedText = mModifiedText;\\n+  return NS_OK;\\n+}\\n+\\n // nsAccCaretMoveEvent\\n NS_IMPL_ISUPPORTS_INHERITED1(nsAccCaretMoveEvent, nsAccEvent,\\n                              nsIAccessibleCaretMoveEvent)\\ndiff --git a/accessible/src/base/nsAccessibleEventData.h b/accessible/src/base/nsAccessibleEventData.h\\nindex 4206c61..1dc8a8f 100644\\n--- a/accessible/src/base/nsAccessibleEventData.h\\n+++ b/accessible/src/base/nsAccessibleEventData.h\\n@@ -46,6 +46,8 @@\\n #include \\\"nsIAccessible.h\\\"\\n #include \\\"nsIAccessibleDocument.h\\\"\\n #include \\\"nsIDOMNode.h\\\"\\n+#include \\\"nsString.h\\\"\\n+\\n class nsIPresShell;\\n \\n class nsAccEvent: public nsIAccessibleEvent\\n@@ -128,8 +130,8 @@ class nsAccTextChangeEvent: public nsAccEvent,\\n                             public nsIAccessibleTextChangeEvent\\n {\\n public:\\n-  nsAccTextChangeEvent(nsIAccessible *aAccessible,\\n-                       PRInt32 aStart, PRUint32 aLength, PRBool aIsInserted);\\n+  nsAccTextChangeEvent(nsIAccessible *aAccessible, PRInt32 aStart, PRUint32 aLength,\\n+                       PRBool aIsInserted, PRBool aIsAsynch = PR_FALSE);\\n \\n   NS_DECL_ISUPPORTS_INHERITED\\n   NS_FORWARD_NSIACCESSIBLEEVENT(nsAccEvent::)\\n@@ -139,6 +141,7 @@ private:\\n   PRInt32 mStart;\\n   PRUint32 mLength;\\n   PRBool mIsInserted;\\n+  nsString mModifiedText;\\n };\\n \\n class nsAccCaretMoveEvent: public nsAccEvent,\\ndiff --git a/accessible/src/base/nsDocAccessible.cpp b/accessible/src/base/nsDocAccessible.cpp\\nindex 230f833..0471237 100644\\n--- a/accessible/src/base/nsDocAccessible.cpp\\n+++ b/accessible/src/base/nsDocAccessible.cpp\\n@@ -1149,9 +1149,6 @@ void nsDocAccessible::ContentAppended(nsIDocument *aDocument,\\n   PRUint32 childCount = aContainer->GetChildCount();\\n   for (PRUint32 index = aNewIndexInContainer; index < childCount; index ++) {\\n     nsCOMPtr<nsIContent> child(aContainer->GetChildAt(index));\\n-\\n-    FireTextChangedEventOnDOMNodeInserted(child, aContainer, index);\\n-\\n     // InvalidateCacheSubtree will not fire the EVENT_SHOW for the new node\\n     // unless an accessible can be created for the passed in node, which it\\n     // can't do unless the node is visible. The right thing happens there so\\n@@ -1184,8 +1181,6 @@ void\\n nsDocAccessible::ContentInserted(nsIDocument *aDocument, nsIContent* aContainer,\\n                                  nsIContent* aChild, PRInt32 aIndexInContainer)\\n {\\n-  FireTextChangedEventOnDOMNodeInserted(aChild, aContainer, aIndexInContainer);\\n-\\n   // InvalidateCacheSubtree will not fire the EVENT_SHOW for the new node\\n   // unless an accessible can be created for the passed in node, which it\\n   // can't do unless the node is visible. The right thing happens there so\\n@@ -1197,10 +1192,11 @@ void\\n nsDocAccessible::ContentRemoved(nsIDocument *aDocument, nsIContent* aContainer,\\n                                 nsIContent* aChild, PRInt32 aIndexInContainer)\\n {\\n-  FireTextChangedEventOnDOMNodeRemoved(aChild, aContainer, aIndexInContainer);\\n-\\n   // Invalidate the subtree of the removed element.\\n-  InvalidateCacheSubtree(aChild, nsIAccessibleEvent::EVENT_DOM_DESTROY);\\n+  // InvalidateCacheSubtree(aChild, nsIAccessibleEvent::EVENT_DOM_DESTROY);\\n+  // This is no longer needed, we get our notifications directly from content\\n+  // *before* the frame for the content is destroyed, or any other side effects occur.\\n+  // That allows us to correctly calculate the TEXT_REMOVED event if there is one.\\n }\\n \\n void\\n@@ -1256,122 +1252,82 @@ nsDocAccessible::FireTextChangedEventOnDOMCharacterDataModified(nsIContent *aCon\\n   }\\n }\\n \\n-void\\n-nsDocAccessible::FireTextChangedEventOnDOMNodeInserted(nsIContent *aChild,\\n-                                                       nsIContent *aContainer,\\n-                                                       PRInt32 aIndexInContainer)\\n+already_AddRefed<nsIAccessibleTextChangeEvent>\\n+nsDocAccessible::CreateTextChangeEventForNode(nsIAccessible *aContainerAccessible,\\n+                                              nsIDOMNode *aChangeNode,\\n+                                              nsIAccessible *aAccessibleForChangeNode,\\n+                                              PRBool aIsInserting,\\n+                                              PRBool aIsAsynch)\\n {\\n-  if (!mIsContentLoaded || !mDocument) {\\n-    return;\\n-  }\\n-\\n-  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(aChild));\\n-  if (!node)\\n-    return;\\n-\\n-  nsCOMPtr<nsIAccessible> accessible;\\n-  nsresult rv = GetAccessibleInParentChain(node, getter_AddRefs(accessible));\\n-  if (NS_FAILED(rv) || !accessible)\\n-    return;\\n-\\n   nsRefPtr<nsHyperTextAccessible> textAccessible;\\n-  rv = accessible->QueryInterface(NS_GET_IID(nsHyperTextAccessible),\\n-                                  getter_AddRefs(textAccessible));\\n-  if (NS_FAILED(rv) || !textAccessible)\\n-    return;\\n-\\n-  PRUint32 length = 1;\\n-  if (aChild && aChild->IsNodeOfType(nsINode::eTEXT)) {\\n-    length = aChild->TextLength();\\n-    if (!length)\\n-      return;\\n-  } else {\\n-    // Don't fire event for the first html:br in an editor.\\n-    nsCOMPtr<nsIEditor> editor;\\n-    textAccessible->GetAssociatedEditor(getter_AddRefs(editor));\\n-    if (editor) {\\n-      PRBool isEmpty = PR_FALSE;\\n-      editor->GetDocumentIsEmpty(&isEmpty);\\n-      if (isEmpty)\\n-        return;\\n+  aContainerAccessible->QueryInterface(NS_GET_IID(nsHyperTextAccessible),\\n+                                       getter_AddRefs(textAccessible));\\n+  if (!textAccessible) {\\n+    return nsnull;\\n+  }\\n+\\n+  PRInt32 offset;\\n+  PRInt32 length = 0;\\n+  nsCOMPtr<nsIAccessible> changeAccessible;\\n+  nsresult rv = textAccessible->DOMPointToHypertextOffset(aChangeNode, -1, &offset,\\n+                                                          getter_AddRefs(changeAccessible));\\n+  NS_ENSURE_SUCCESS(rv, nsnull);\\n+\\n+  if (!aAccessibleForChangeNode) {\\n+    // A span-level object or something else without an accessible is being removed, where\\n+    // it has no accessible but it has descendant content which is aggregated as text\\n+    // into the parent hypertext.\\n+    // In this case, accessibleToBeRemoved may just be the first\\n+    // accessible that is removed, which affects the text in the hypertext container\\n+    if (!changeAccessible) {\\n+      return nsnull; // No descendant content that represents any text in the hypertext parent\\n+    }\\n+    nsCOMPtr<nsIAccessible> child = changeAccessible;\\n+    while (PR_TRUE) {\\n+      nsCOMPtr<nsIAccessNode> childAccessNode =\\n+        do_QueryInterface(changeAccessible);\\n+      nsCOMPtr<nsIDOMNode> childNode;\\n+      childAccessNode->GetDOMNode(getter_AddRefs(childNode));\\n+      if (!nsAccUtils::IsAncestorOf(aChangeNode, childNode)) {\\n+        break;  // We only want accessibles with DOM nodes as children of this node\\n+      }\\n+      length += TextLength(child);\\n+      child->GetNextSibling(getter_AddRefs(changeAccessible));\\n+      if (!changeAccessible) {\\n+        break;\\n+      }\\n+      child.swap(changeAccessible);\\n     }\\n   }\\n-\\n-  nsCOMPtr<nsIDOMNode> parentNode(do_QueryInterface(aContainer));\\n-  if (!parentNode)\\n-    return;\\n-\\n-  PRInt32 offset = 0;\\n-  rv = textAccessible->DOMPointToHypertextOffset(parentNode, aIndexInContainer, &offset);\\n-  if (NS_FAILED(rv))\\n-    return;\\n-\\n-  nsCOMPtr<nsIAccessibleTextChangeEvent> event =\\n-    new nsAccTextChangeEvent(accessible, offset, length, PR_TRUE);\\n-  if (!event)\\n-    return;\\n-\\n-  textAccessible->FireAccessibleEvent(event);\\n-}\\n-\\n-void\\n-nsDocAccessible::FireTextChangedEventOnDOMNodeRemoved(nsIContent *aChild,\\n-                                                      nsIContent *aContainer,\\n-                                                      PRInt32 aIndexInContainer)\\n-{\\n-  if (!mIsContentLoaded || !mDocument) {\\n-    return;\\n-  }\\n-\\n-  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(aChild));\\n-  if (!node)\\n-    return;\\n-\\n-  nsCOMPtr<nsIAccessible> accessible;\\n-  nsresult rv = GetAccessibleInParentChain(node, getter_AddRefs(accessible));\\n-  if (NS_FAILED(rv) || !accessible)\\n-    return;\\n-\\n-  nsRefPtr<nsHyperTextAccessible> textAccessible;\\n-  rv = accessible->QueryInterface(NS_GET_IID(nsHyperTextAccessible),\\n-                                  getter_AddRefs(textAccessible));\\n-  if (NS_FAILED(rv) || !textAccessible)\\n-    return;\\n-\\n-  PRUint32 length = 1;\\n-  if (aChild && aChild->IsNodeOfType(nsINode::eTEXT)) {\\n-    length = aChild->TextLength();\\n-    if (!length)\\n-      return;\\n-  } else {\\n-    // Don't fire event for the last html:br in an editor.\\n-    nsCOMPtr<nsIEditor> editor;\\n-    textAccessible->GetAssociatedEditor(getter_AddRefs(editor));\\n-    if (editor) {\\n-      PRBool isEmpty = PR_FALSE;\\n-      editor->GetDocumentIsEmpty(&isEmpty);\\n-      if (isEmpty)\\n-        return;\\n+  else {\\n+    NS_ASSERTION(changeAccessible == aAccessibleForChangeNode,\\n+                 \\\"Hypertext is reporting a different accessible for this node\\\");\\n+    length = TextLength(aAccessibleForChangeNode);\\n+    if (Role(aAccessibleForChangeNode) == nsIAccessibleRole::ROLE_WHITESPACE) {  // newline\\n+      // Don't fire event for the first html:br in an editor.\\n+      nsCOMPtr<nsIEditor> editor;\\n+      textAccessible->GetAssociatedEditor(getter_AddRefs(editor));\\n+      if (editor) {\\n+        PRBool isEmpty = PR_FALSE;\\n+        editor->GetDocumentIsEmpty(&isEmpty);\\n+        if (isEmpty) {\\n+          return nsnull;\\n+        }\\n+      }\\n     }\\n   }\\n \\n-  nsCOMPtr<nsIDOMNode> parentNode(do_QueryInterface(aContainer));\\n-  if (!parentNode)\\n-    return;\\n-\\n-  PRInt32 offset = 0;\\n-  rv = textAccessible->DOMPointToHypertextOffset(parentNode, aIndexInContainer, &offset);\\n-  if (NS_FAILED(rv))\\n-    return;\\n+  if (length <= 0) {\\n+    return nsnull;\\n+  }\\n \\n-  nsCOMPtr<nsIAccessibleTextChangeEvent> event =\\n-    new nsAccTextChangeEvent(accessible, offset, length, PR_FALSE);\\n-  if (!event)\\n-    return;\\n+  nsIAccessibleTextChangeEvent *event =\\n+    new nsAccTextChangeEvent(aContainerAccessible, offset, length, aIsInserting, aIsAsynch);\\n+  NS_IF_ADDREF(event);\\n \\n-  textAccessible->FireAccessibleEvent(event);\\n+  return event;\\n }\\n-\\n+  \\n nsresult nsDocAccessible::FireDelayedToolkitEvent(PRUint32 aEvent,\\n                                                   nsIDOMNode *aDOMNode,\\n                                                   void *aData,\\n@@ -1492,9 +1448,38 @@ NS_IMETHODIMP nsDocAccessible::FlushPendingEvents()\\n \\n     nsCOMPtr<nsIAccessible> accessible;\\n     accessibleEvent->GetAccessible(getter_AddRefs(accessible));\\n+\\n+    PRUint32 eventType;\\n+    accessibleEvent->GetEventType(&eventType);\\n+    if (eventType == nsIAccessibleEvent::EVENT_DOM_CREATE || \\n+        eventType == nsIAccessibleEvent::EVENT_ASYNCH_SHOW) {\\n+      // Also fire text changes if the node being created could affect the text in an nsIAccessibleText parent.\\n+      // When a node is being made visible or is inserted, the text in an ancestor hyper text will gain characters\\n+      // At this point we now have the frame and accessible for this node if there is one. That is why we\\n+      // wait to fire this here, instead of in InvalidateCacheSubtree(), where we wouldn't be able to calculate\\n+      // the offset, length and text for the text change.\\n+      nsCOMPtr<nsIDOMNode> domNode;\\n+      accessibleEvent->GetDOMNode(getter_AddRefs(domNode));\\n+      if (domNode && domNode != mDOMNode) {\\n+        nsCOMPtr<nsIAccessible> containerAccessible;\\n+        GetAccessibleInParentChain(domNode, getter_AddRefs(containerAccessible));\\n+        nsCOMPtr<nsIAccessibleTextChangeEvent> textChangeEvent =\\n+          CreateTextChangeEventForNode(containerAccessible, domNode, accessible, PR_TRUE, PR_TRUE);\\n+        if (textChangeEvent) {\\n+          PRBool isFromUserInput;\\n+          accessibleEvent->GetIsFromUserInput(&isFromUserInput);\\n+          nsCOMPtr<nsIDOMNode> hyperTextNode;\\n+          textChangeEvent->GetDOMNode(getter_AddRefs(hyperTextNode));\\n+          nsAccEvent::PrepareForEvent(hyperTextNode, isFromUserInput);\\n+          // XXX Queue them up and merge the text change events\\n+          // XXX We need a way to ignore SplitNode and JoinNode() when they\\n+          // do not affect the text within the hypertext\\n+          FireAccessibleEvent(textChangeEvent);\\n+        }\\n+      }\\n+    }\\n+\\n     if (accessible) {\\n-      PRUint32 eventType;\\n-      accessibleEvent->GetEventType(&eventType);\\n       if (eventType == nsIAccessibleEvent::EVENT_INTERNAL_LOAD) {\\n         nsCOMPtr<nsPIAccessibleDocument> docAccessible =\\n           do_QueryInterface(accessible);\\n@@ -1534,6 +1519,14 @@ NS_IMETHODIMP nsDocAccessible::FlushPendingEvents()\\n         // Post event processing\\n         if (eventType == nsIAccessibleEvent::EVENT_ASYNCH_HIDE ||\\n             eventType == nsIAccessibleEvent::EVENT_DOM_DESTROY) {\\n+          // Invalidate children\\n+          nsCOMPtr<nsIAccessible> containerAccessible;\\n+          accessible->GetParent(getter_AddRefs(containerAccessible));\\n+          nsCOMPtr<nsPIAccessible> privateContainerAccessible =\\n+            do_QueryInterface(containerAccessible);\\n+          if (privateContainerAccessible) {\\n+            privateContainerAccessible->InvalidateChildren();\\n+          }\\n           // Shutdown nsIAccessNode's or nsIAccessibles for any DOM nodes in this subtree\\n           nsCOMPtr<nsIDOMNode> hidingNode;\\n           accessibleEvent->GetDOMNode(getter_AddRefs(hidingNode));\\n@@ -1702,6 +1695,12 @@ NS_IMETHODIMP nsDocAccessible::InvalidateCacheSubtree(nsIContent *aChild,\\n   }\\n #endif\\n \\n+  nsCOMPtr<nsIAccessible> containerAccessible;\\n+  GetAccessibleInParentChain(childNode, getter_AddRefs(containerAccessible));\\n+  if (!containerAccessible) {\\n+    containerAccessible = this;\\n+  }\\n+\\n   if (!isShowing) {\\n     // Fire EVENT_ASYNCH_HIDE or EVENT_DOM_DESTROY if previous accessible existed for node being hidden.\\n     // Fire this before the accessible goes away.\\n@@ -1713,6 +1712,19 @@ NS_IMETHODIMP nsDocAccessible::InvalidateCacheSubtree(nsIContent *aChild,\\n       NS_ENSURE_TRUE(removalEvent, NS_ERROR_OUT_OF_MEMORY);\\n       FireDelayedAccessibleEvent(removalEvent, eCoalesceFromSameSubtree, isAsynch);\\n     }\\n+    if (childNode != mDOMNode) { // Fire text change unless the node being removed is for this doc\\n+      // When a node is hidden or removed, the text in an ancestor hyper text will lose characters\\n+      // At this point we still have the frame and accessible for this node if there was one\\n+      // XXX Collate events when a range is deleted\\n+      // XXX We need a way to ignore SplitNode and JoinNode() when they\\n+      // do not affect the text within the hypertext\\n+      nsCOMPtr<nsIAccessibleTextChangeEvent> textChangeEvent =\\n+        CreateTextChangeEventForNode(containerAccessible, childNode, childAccessible,\\n+                                     PR_FALSE, isAsynch);\\n+      if (textChangeEvent) {\\n+        FireAccessibleEvent(textChangeEvent);\\n+      }\\n+    }\\n   }\\n \\n   // We need to get an accessible for the mutation event's container node\\n@@ -1722,18 +1734,12 @@ NS_IMETHODIMP nsDocAccessible::InvalidateCacheSubtree(nsIContent *aChild,\\n   // We're guaranteed success, because we will eventually end up at the doc accessible,\\n   // and there is always one of those.\\n \\n-  nsCOMPtr<nsIAccessible> containerAccessible;\\n-  GetAccessibleInParentChain(childNode, getter_AddRefs(containerAccessible));\\n-  if (!containerAccessible) {\\n-    containerAccessible = this;\\n-  }\\n-  nsCOMPtr<nsPIAccessible> privateContainerAccessible =\\n-    do_QueryInterface(containerAccessible);\\n-  if (privateContainerAccessible) {\\n-    privateContainerAccessible->InvalidateChildren();\\n-  }\\n-\\n   if (aChild && !isHiding) {\\n+    nsCOMPtr<nsPIAccessible> privateContainerAccessible =\\n+      do_QueryInterface(containerAccessible);\\n+    if (privateContainerAccessible) {\\n+      privateContainerAccessible->InvalidateChildren();\\n+    }\\n     // Fire EVENT_SHOW, EVENT_MENUPOPUP_START for newly visible content.\\n     // Fire after a short timer, because we want to make sure the view has been\\n     // updated to make this accessible content visible. If we don't wait,\\ndiff --git a/accessible/src/base/nsDocAccessible.h b/accessible/src/base/nsDocAccessible.h\\nindex a381d92..649e8d2 100644\\n--- a/accessible/src/base/nsDocAccessible.h\\n+++ b/accessible/src/base/nsDocAccessible.h\\n@@ -107,7 +107,7 @@ class nsDocAccessible : public nsHyperTextAccessibleWrap,\\n     /**\\n       * Non-virtual method to fire a delayed event after a 0 length timeout\\n       *\\n-      * @param aEvent - the nsIAccessibleEvent event ype\\n+      * @param aEvent - the nsIAccessibleEvent event type\\n       * @param aDOMNode - DOM node the accesible event should be fired for\\n       * @param aData - any additional data for the event\\n       * @param aAllowDupes - eAllowDupes: more than one event of the same type is allowed. \\n@@ -161,21 +161,20 @@ class nsDocAccessible : public nsHyperTextAccessibleWrap,\\n      */\\n     void FireTextChangedEventOnDOMCharacterDataModified(nsIContent *aContent,\\n                                                         CharacterDataChangeInfo* aInfo);\\n-    /**\\n-     * Fire text changed event for the inserted element if it is inside a text\\n-     * accessible.\\n-     */\\n-    void FireTextChangedEventOnDOMNodeInserted(nsIContent *aChild,\\n-                                               nsIContent *aContainer,\\n-                                               PRInt32 aIndexInContainer);\\n \\n     /**\\n-     * Fire text changed event for the removed element if it is inside a text\\n-     * accessible.\\n+     * Create a text change event for a changed node\\n+     * @param aContainerAccessible, the first accessible in the container\\n+     * @param aChangeNode, the node that is being inserted or removed, or shown/hidden\\n+     * @param aAccessibleForChangeNode, the accessible for that node, or nsnull if none exists\\n+     * @param aIsInserting, is aChangeNode being created or shown (vs. removed or hidden)\\n      */\\n-    void FireTextChangedEventOnDOMNodeRemoved(nsIContent *aChild,\\n-                                              nsIContent *aContainer,\\n-                                              PRInt32 aIndexInContainer);\\n+    already_AddRefed<nsIAccessibleTextChangeEvent>\\n+    nsDocAccessible::CreateTextChangeEventForNode(nsIAccessible *aContainerAccessible,\\n+                                                  nsIDOMNode *aChangeNode,\\n+                                                  nsIAccessible *aAccessibleForNode,\\n+                                                  PRBool aIsInserting,\\n+                                                  PRBool aIsAsynch);\\n \\n     nsAccessNodeHashtable mAccessNodeCache;\\n     void *mWnd;\\ndiff --git a/accessible/src/html/nsHTMLTextAccessible.cpp b/accessible/src/html/nsHTMLTextAccessible.cpp\\nindex 2a5dc70..a29b8d7a 100644\\n--- a/accessible/src/html/nsHTMLTextAccessible.cpp\\n+++ b/accessible/src/html/nsHTMLTextAccessible.cpp\\n@@ -62,9 +62,9 @@ NS_IMETHODIMP nsHTMLTextAccessible::GetName(nsAString& aName)\\n NS_IMETHODIMP nsHTMLTextAccessible::GetRole(PRUint32 *aRole)\\n {\\n   nsIFrame *frame = GetFrame();\\n-  NS_ENSURE_TRUE(frame, NS_ERROR_NULL_POINTER);\\n-\\n-  if (frame->IsGeneratedContentFrame()) {\\n+  // Don't return on null frame -- we still return a role\\n+  // after accessible is shutdown/DEFUNCT\\n+  if (frame && frame->IsGeneratedContentFrame()) {\\n     *aRole = nsIAccessibleRole::ROLE_STATICTEXT;\\n     return NS_OK;\\n   }\\ndiff --git a/accessible/src/html/nsHyperTextAccessible.cpp b/accessible/src/html/nsHyperTextAccessible.cpp\\nindex a5c39aa..521559d 100644\\n--- a/accessible/src/html/nsHyperTextAccessible.cpp\\n+++ b/accessible/src/html/nsHyperTextAccessible.cpp\\n@@ -526,7 +526,6 @@ nsresult nsHyperTextAccessible::DOMPointToHypertextOffset(nsIDOMNode* aNode, PRI\\n   NS_ENSURE_ARG_POINTER(aHyperTextOffset);\\n   *aHyperTextOffset = 0;\\n   NS_ENSURE_ARG_POINTER(aNode);\\n-  NS_ENSURE_TRUE(aNodeOffset >= 0, NS_ERROR_INVALID_ARG);\\n   if (aFinalAccessible) {\\n     *aFinalAccessible = nsnull;\\n   }\\n@@ -536,7 +535,10 @@ nsresult nsHyperTextAccessible::DOMPointToHypertextOffset(nsIDOMNode* aNode, PRI\\n \\n   unsigned short nodeType;\\n   aNode->GetNodeType(&nodeType);\\n-  if (nodeType == nsIDOMNode::TEXT_NODE) {\\n+  if (aNodeOffset == -1) {\\n+    findNode = aNode;\\n+  }\\n+  else if (nodeType == nsIDOMNode::TEXT_NODE) {\\n     // For text nodes, aNodeOffset comes in as a character offset\\n     // Text offset will be added at the end, if we find the offset in this hypertext\\n     // We want the \\\"skipped\\\" offset into the text (rendered text without the extra whitespace)\\n@@ -618,6 +620,7 @@ nsresult nsHyperTextAccessible::DOMPointToHypertextOffset(nsIDOMNode* aNode, PRI\\n       NS_ADDREF(*aFinalAccessible = childAccessible);\\n     }\\n   }\\n+\\n   return NS_OK;\\n }\\n \\ndiff --git a/accessible/src/html/nsHyperTextAccessible.h b/accessible/src/html/nsHyperTextAccessible.h\\nindex d025c05..4af7bf1 100644\\n--- a/accessible/src/html/nsHyperTextAccessible.h\\n+++ b/accessible/src/html/nsHyperTextAccessible.h\\n@@ -101,6 +101,9 @@ public:\\n     *\\n     * @param aNode - the node to look for\\n     * @param aNodeOffset - the offset to look for\\n+    *                      if -1 just look directly for the node\\n+    *                      if >=0 and aNode is text, this represents a char offset\\n+    *                      if >=0 and aNode is not text, this represents a child node offset\\n     * @param aResultOffset - the character offset into the current\\n     *                        nsHyperTextAccessible\\n     * @param aFinalAccessible [optional] - returns the accessible child which\\ndiff --git a/accessible/src/msaa/nsHyperTextAccessibleWrap.cpp b/accessible/src/msaa/nsHyperTextAccessibleWrap.cpp\\nindex 533fb9e..cd66a41 100755\\n--- a/accessible/src/msaa/nsHyperTextAccessibleWrap.cpp\\n+++ b/accessible/src/msaa/nsHyperTextAccessibleWrap.cpp\\n@@ -89,28 +89,24 @@ nsHyperTextAccessibleWrap::GetModifiedText(PRBool aGetInsertedText,\\n \\n   if (!gTextEvent)\\n     return NS_OK;\\n+    \\n+  PRBool isInserted;\\n+  gTextEvent->IsInserted(&isInserted);\\n+  if (aGetInsertedText != isInserted)\\n+    return NS_OK;\\n \\n   nsCOMPtr<nsIAccessible> targetAcc;\\n   gTextEvent->GetAccessible(getter_AddRefs(targetAcc));\\n   if (targetAcc != this)\\n     return NS_OK;\\n \\n-  PRBool isInserted;\\n-  gTextEvent->IsInserted(&isInserted);\\n-\\n-  if (aGetInsertedText != isInserted)\\n-    return NS_OK;\\n-\\n-  nsAutoString text;\\n   PRInt32 offset;\\n   PRUint32 length;\\n \\n   gTextEvent->GetStart(&offset);\\n   gTextEvent->GetLength(&length);\\n-  GetText(offset, offset + length, aText);\\n   *aStartOffset = offset;\\n   *aEndOffset = offset + length;\\n-\\n-  return NS_OK;\\n+  return gTextEvent->GetModifiedText(aText);\\n }\\n \\ndiff --git a/content/base/src/Makefile.in b/content/base/src/Makefile.in\\nindex c8072f9..c477985 100644\\n--- a/content/base/src/Makefile.in\\n+++ b/content/base/src/Makefile.in\\n@@ -82,6 +82,7 @@ REQUIRES\\t= xpcom \\\\\\n \\t\\t  util \\\\\\n \\t\\t  appshell \\\\\\n \\t\\t  shistory \\\\\\n+\\t\\t  accessibility \\\\\\n \\t\\t  $(NULL)\\n \\n EXPORTS\\t\\t= \\\\\\ndiff --git a/content/base/src/nsGenericElement.cpp b/content/base/src/nsGenericElement.cpp\\nindex c866cb5..b7f8ec6 100644\\n--- a/content/base/src/nsGenericElement.cpp\\n+++ b/content/base/src/nsGenericElement.cpp\\n@@ -125,6 +125,11 @@\\n #include \\\"nsIXULDocument.h\\\"\\n #endif /* MOZ_XUL */\\n \\n+#ifdef ACCESSIBILITY\\n+#include \\\"nsIAccessibilityService.h\\\"\\n+#include \\\"nsIAccessibleEvent.h\\\"\\n+#endif /* ACCESSIBILITY */\\n+\\n #include \\\"nsCycleCollectionParticipant.h\\\"\\n #include \\\"nsCCUncollectableMarker.h\\\"\\n #include \\\"nsCycleCollector.h\\\"\\n@@ -2694,6 +2699,22 @@ nsGenericElement::doRemoveChildAt(PRUint32 aIndex, PRBool aNotify,\\n   NS_PRECONDITION(!aParent || aParent->GetCurrentDoc() == aDocument,\\n                   \\\"Incorrect aDocument\\\");\\n \\n+#ifdef ACCESSIBILITY\\n+  // A11y needs to be notified of content removals first, so accessibility\\n+  // events can be fired before any changes occur\\n+  if (aNotify && aDocument) {\\n+    nsIPresShell *presShell = aDocument->GetPrimaryShell();\\n+    if (presShell && presShell->IsAccessibilityActive()) {\\n+      nsCOMPtr<nsIAccessibilityService> accService = \\n+        do_GetService(\\\"@mozilla.org/accessibilityService;1\\\");\\n+      if (accService) {\\n+        accService->InvalidateSubtreeFor(presShell, aKid,\\n+                                         nsIAccessibleEvent::EVENT_DOM_DESTROY);\\n+      }\\n+    }\\n+  }\\n+#endif\\n+\\n   nsMutationGuard::DidMutate();\\n \\n   nsINode* container = NODE_FROM(aParent, aDocument);\\n\""}