{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas71a60fb\""},"diff":"\"71a60fb Backing out SQLite upgrade from 3.4.1 to version 3.4.2; patch by sdwilsh, r=sspitzer, a=bsmedberg\\ndiff --git a/db/sqlite3/README.MOZILLA b/db/sqlite3/README.MOZILLA\\nindex 36f6576..ea6375e 100644\\n--- a/db/sqlite3/README.MOZILLA\\n+++ b/db/sqlite3/README.MOZILLA\\n@@ -1,7 +1,8 @@\\n-This is sqlite 3.4.2\\n+This is sqlite 3.4.1\\n \\n-See the change log for more details:\\n-http://www.sqlite.org/changes.html#version_3_4_2\\n+This version has some security stuff dealing with the upper\\n+bounds of data types.  See the change log for more details:\\n+http://www.sqlite.org/changes.html#version_3_4_1\\n \\n -- Shawn Wilsher <me@shawnwilsher.com> 08/2007\\n \\n@@ -17,7 +18,7 @@ Simply copy the sqlite3.h and sqlite3.c files from the amalgamation of sqlite.\\n They you need to update sqlite3file.h, which pulls out random bits of the\\n internal files that we need to export. If any of these internal structures\\n change, they need to be changed in sqlite3file.h as well.  This may involve\\n-downloading the whole source (not the amalgamation) to check.\\n+downloading the whole souce (not the amalgamation) to check.\\n \\n -- Shawn Wilsher <me@shawnwilsher.com> 06/2007\\n \\ndiff --git a/db/sqlite3/src/sqlite3.c b/db/sqlite3/src/sqlite3.c\\nindex 38603fc..6b78161 100644\\n--- a/db/sqlite3/src/sqlite3.c\\n+++ b/db/sqlite3/src/sqlite3.c\\n@@ -1,6 +1,6 @@\\n /******************************************************************************\\n ** This file is an amalgamation of many separate C source files from SQLite\\n-** version 3.4.2.  By combining all the individual C code files into this \\n+** version 3.4.1.  By combining all the individual C code files into this \\n ** single large file, the entire code can be compiled as a one translation\\n ** unit.  This allows many compilers to do optimizations that would not be\\n ** possible if the files were compiled separately.  Performance improvements\\n@@ -11,13 +11,13 @@\\n ** programs, you need this file and the \\\"sqlite3.h\\\" header file that defines\\n ** the programming interface to the SQLite library.  (If you do not have \\n ** the \\\"sqlite3.h\\\" header file at hand, you will find a copy in the first\\n-** 2709 lines past this header comment.)  Additional code files may be\\n+** 2702 lines past this header comment.)  Additional code files may be\\n ** needed if you want a wrapper to interface SQLite with your choice of\\n ** programming language.  The code for the \\\"sqlite3\\\" command-line shell\\n ** is also in a separate file.  This file contains only code for the core\\n ** SQLite library.\\n **\\n-** This amalgamation was generated on 2007-08-14 00:24:36 UTC.\\n+** This amalgamation was generated on 2007-07-20 11:05:39 UTC.\\n */\\n #define SQLITE_AMALGAMATION 1\\n #ifndef SQLITE_PRIVATE\\n@@ -59,7 +59,7 @@\\n ** the version number) and changes its name to \\\"sqlite3.h\\\" as\\n ** part of the build process.\\n **\\n-** @(#) $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** @(#) $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n #ifndef _SQLITE3_H_\\n #define _SQLITE3_H_\\n@@ -73,13 +73,6 @@ extern \\\"C\\\" {\\n #endif\\n \\n /*\\n-** Add the ability to override 'extern'\\n-*/\\n-#ifndef SQLITE_EXTERN\\n-# define SQLITE_EXTERN extern\\n-#endif\\n-\\n-/*\\n ** Make sure these symbols where not defined by some previous header\\n ** file.\\n */\\n@@ -117,8 +110,8 @@ extern \\\"C\\\" {\\n **\\n ** See also: [sqlite3_libversion()] and [sqlite3_libversion_number()].\\n */\\n-#define SQLITE_VERSION         \\\"3.4.2\\\"\\n-#define SQLITE_VERSION_NUMBER 3004002\\n+#define SQLITE_VERSION         \\\"3.4.1\\\"\\n+#define SQLITE_VERSION_NUMBER 3004001\\n \\n /*\\n ** CAPI3REF: Run-Time Library Version Numbers\\n@@ -136,9 +129,9 @@ extern \\\"C\\\" {\\n ** is provided for DLL users who can only access functions and not\\n ** constants within the DLL.\\n */\\n-SQLITE_EXTERN const char sqlite3_version[];\\n+extern const char sqlite3_version[];\\n SQLITE_API const char *sqlite3_libversion(void);\\n-SQLITE_API int sqlite3_libversion_number(void);\\n+int sqlite3_libversion_number(void);\\n \\n /*\\n ** CAPI3REF: Database Connection Handle\\n@@ -356,7 +349,7 @@ SQLITE_API int sqlite3_exec(\\n ** codes on and off.  Extended result codes are off by default for\\n ** backwards compatibility with older versions of SQLite.\\n */\\n-SQLITE_API int sqlite3_extended_result_codes(sqlite3*, int onoff);\\n+int sqlite3_extended_result_codes(sqlite3*, int onoff);\\n \\n /*\\n ** CAPI3REF: Last Insert Rowid\\n@@ -378,7 +371,7 @@ SQLITE_API int sqlite3_extended_result_codes(sqlite3*, int onoff);\\n ** by this routine reverts to the last value inserted before the\\n ** trigger fired.\\n */\\n-SQLITE_API sqlite_int64 sqlite3_last_insert_rowid(sqlite3*);\\n+sqlite_int64 sqlite3_last_insert_rowid(sqlite3*);\\n \\n /*\\n ** CAPI3REF: Count The Number Of Rows Modified\\n@@ -433,7 +426,7 @@ SQLITE_API int sqlite3_changes(sqlite3*);\\n ** table. To get an accurate count of the number of rows deleted, use\\n ** \\\"DELETE FROM table WHERE 1\\\" instead.\\n */\\n-SQLITE_API int sqlite3_total_changes(sqlite3*);\\n+int sqlite3_total_changes(sqlite3*);\\n \\n /*\\n ** CAPI3REF: Interrupt A Long-Running Query\\n@@ -539,7 +532,7 @@ SQLITE_API int sqlite3_complete16(const void *sql);\\n ** Note that calling [sqlite3_busy_timeout()] will also set or clear\\n ** the busy handler.\\n */\\n-SQLITE_API int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);\\n+int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);\\n \\n /*\\n ** CAPI3REF: Set A Busy Timeout\\n@@ -558,7 +551,7 @@ SQLITE_API int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);\\n ** (using [sqlite3_busy_handler()]) prior to calling\\n ** this routine, that other busy handler is cleared.\\n */\\n-SQLITE_API int sqlite3_busy_timeout(sqlite3*, int ms);\\n+int sqlite3_busy_timeout(sqlite3*, int ms);\\n \\n /*\\n ** CAPI3REF: Convenience Routines For Running Queries\\n@@ -607,7 +600,7 @@ SQLITE_API int sqlite3_busy_timeout(sqlite3*, int ms);\\n **\\n ** The return value of this routine is the same as from [sqlite3_exec()].\\n */\\n-SQLITE_API int sqlite3_get_table(\\n+int sqlite3_get_table(\\n   sqlite3*,              /* An open database */\\n   const char *sql,       /* SQL to be executed */\\n   char ***resultp,       /* Result written to a char *[]  that this points to */\\n@@ -615,7 +608,7 @@ SQLITE_API int sqlite3_get_table(\\n   int *ncolumn,          /* Number of result columns written here */\\n   char **errmsg          /* Error msg written here */\\n );\\n-SQLITE_API void sqlite3_free_table(char **result);\\n+void sqlite3_free_table(char **result);\\n \\n /*\\n ** CAPI3REF: Formatted String Printing Functions\\n@@ -776,7 +769,7 @@ SQLITE_API void sqlite3_free(void*);\\n ** [sqlite3_prepare()] or its variants.  Authorization is not\\n ** performed during statement evaluation in [sqlite3_step()].\\n */\\n-SQLITE_API int sqlite3_set_authorizer(\\n+int sqlite3_set_authorizer(\\n   sqlite3*,\\n   int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),\\n   void *pUserData\\n@@ -896,7 +889,7 @@ SQLITE_API void *sqlite3_profile(sqlite3*,\\n ** can be used, for example, to implement the \\\"Cancel\\\" button on a\\n ** progress dialog box in a GUI.\\n */\\n-SQLITE_API void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);\\n+void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);\\n \\n /*\\n ** CAPI3REF: Opening A New Database Connection\\n@@ -1063,7 +1056,7 @@ SQLITE_API int sqlite3_prepare(\\n   sqlite3_stmt **ppStmt,  /* OUT: Statement handle */\\n   const char **pzTail     /* OUT: Pointer to unused portion of zSql */\\n );\\n-SQLITE_API int sqlite3_prepare_v2(\\n+int sqlite3_prepare_v2(\\n   sqlite3 *db,            /* Database handle */\\n   const char *zSql,       /* SQL statement, UTF-8 encoded */\\n   int nByte,              /* Maximum length of zSql in bytes. */\\n@@ -1077,7 +1070,7 @@ SQLITE_API int sqlite3_prepare16(\\n   sqlite3_stmt **ppStmt,  /* OUT: Statement handle */\\n   const void **pzTail     /* OUT: Pointer to unused portion of zSql */\\n );\\n-SQLITE_API int sqlite3_prepare16_v2(\\n+int sqlite3_prepare16_v2(\\n   sqlite3 *db,            /* Database handle */\\n   const void *zSql,       /* SQL statement, UTF-16 encoded */\\n   int nByte,              /* Maximum length of zSql in bytes. */\\n@@ -1177,15 +1170,15 @@ typedef struct sqlite3_context sqlite3_context;\\n ** [SQLITE_MISUSE] is returned if these routines are called on a virtual\\n ** machine that is the wrong state or which has already been finalized.\\n */\\n-SQLITE_API int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));\\n-SQLITE_API int sqlite3_bind_double(sqlite3_stmt*, int, double);\\n-SQLITE_API int sqlite3_bind_int(sqlite3_stmt*, int, int);\\n-SQLITE_API int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite_int64);\\n-SQLITE_API int sqlite3_bind_null(sqlite3_stmt*, int);\\n-SQLITE_API int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));\\n-SQLITE_API int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));\\n-SQLITE_API int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);\\n-SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);\\n+int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));\\n+int sqlite3_bind_double(sqlite3_stmt*, int, double);\\n+int sqlite3_bind_int(sqlite3_stmt*, int, int);\\n+int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite_int64);\\n+int sqlite3_bind_null(sqlite3_stmt*, int);\\n+int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));\\n+int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));\\n+int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);\\n+int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);\\n \\n /*\\n ** CAPI3REF: Number Of Host Parameters\\n@@ -1201,7 +1194,7 @@ SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);\\n ** numbering and the value returned by this interface is the index of the\\n ** host parameter with the largest index value.\\n */\\n-SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*);\\n+int sqlite3_bind_parameter_count(sqlite3_stmt*);\\n \\n /*\\n ** CAPI3REF: Name Of A Host Parameter\\n@@ -1221,7 +1214,7 @@ SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*);\\n ** UTF-8 encoding even if the named parameter was originally specified\\n ** as UTF-16 in [sqlite3_prepare16()] or [sqlite3_prepare16_v2()].\\n */\\n-SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);\\n+const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);\\n \\n /*\\n ** CAPI3REF: Index Of A Parameter With A Given Name\\n@@ -1230,7 +1223,7 @@ SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);\\n ** The name must match exactly.  If no parameter with the given name is \\n ** found, return 0.  Parameter names must be UTF8.\\n */\\n-SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);\\n+int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);\\n \\n /*\\n ** CAPI3REF: Reset All Bindings On A Prepared Statement\\n@@ -1240,7 +1233,7 @@ SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);\\n ** [sqlite3_stmt | prepared statement].  Use this routine to\\n ** reset all host parameters to NULL.\\n */\\n-SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt*);\\n+int sqlite3_clear_bindings(sqlite3_stmt*);\\n \\n /*\\n ** CAPI3REF: Number Of Columns In A Result Set\\n@@ -1250,7 +1243,7 @@ SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt*);\\n ** if pStmt is an SQL statement that does not return data (for \\n ** example an UPDATE).\\n */\\n-SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt);\\n+int sqlite3_column_count(sqlite3_stmt *pStmt);\\n \\n /*\\n ** CAPI3REF: Column Names In A Result Set\\n@@ -1268,8 +1261,8 @@ SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt);\\n ** or until the next call sqlite3_column_name() or sqlite3_column_name16()\\n ** on the same column.\\n */\\n-SQLITE_API const char *sqlite3_column_name(sqlite3_stmt*, int N);\\n-SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt*, int N);\\n+const char *sqlite3_column_name(sqlite3_stmt*, int N);\\n+const void *sqlite3_column_name16(sqlite3_stmt*, int N);\\n \\n /*\\n ** CAPI3REF: Source Of Data In A Query Result\\n@@ -1305,12 +1298,12 @@ SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt*, int N);\\n ** These APIs are only available if the library was compiled with the \\n ** SQLITE_ENABLE_COLUMN_METADATA preprocessor symbol defined.\\n */\\n-SQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt*,int);\\n-SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt*,int);\\n-SQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt*,int);\\n-SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt*,int);\\n-SQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt*,int);\\n-SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);\\n+const char *sqlite3_column_database_name(sqlite3_stmt*,int);\\n+const void *sqlite3_column_database_name16(sqlite3_stmt*,int);\\n+const char *sqlite3_column_table_name(sqlite3_stmt*,int);\\n+const void *sqlite3_column_table_name16(sqlite3_stmt*,int);\\n+const char *sqlite3_column_origin_name(sqlite3_stmt*,int);\\n+const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);\\n \\n /*\\n ** CAPI3REF: Declared Datatype Of A Query Result\\n@@ -1341,8 +1334,8 @@ SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);\\n ** is associated with individual values, not with the containers\\n ** used to hold those values.\\n */\\n-SQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt *, int i);\\n-SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int);\\n+const char *sqlite3_column_decltype(sqlite3_stmt *, int i);\\n+const void *sqlite3_column_decltype16(sqlite3_stmt*,int);\\n \\n /* \\n ** CAPI3REF:  Evaluate An SQL Statement\\n@@ -1428,7 +1421,7 @@ SQLITE_API int sqlite3_step(sqlite3_stmt*);\\n ** called on the [sqlite_stmt | prepared statement] for the first time,\\n ** this routine returns zero.\\n */\\n-SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);\\n+int sqlite3_data_count(sqlite3_stmt *pStmt);\\n \\n /*\\n ** CAPI3REF: Fundamental Datatypes\\n@@ -1579,16 +1572,16 @@ SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);\\n ** sqlite3_column_blob() with calls to sqlite3_column_bytes16().  And do not\\n ** mix calls to sqlite3_column_text16() with calls to sqlite3_column_bytes().\\n */\\n-SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);\\n-SQLITE_API int sqlite3_column_bytes(sqlite3_stmt*, int iCol);\\n-SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);\\n-SQLITE_API double sqlite3_column_double(sqlite3_stmt*, int iCol);\\n-SQLITE_API int sqlite3_column_int(sqlite3_stmt*, int iCol);\\n-SQLITE_API sqlite_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);\\n-SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);\\n-SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);\\n-SQLITE_API int sqlite3_column_type(sqlite3_stmt*, int iCol);\\n-SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);\\n+const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);\\n+int sqlite3_column_bytes(sqlite3_stmt*, int iCol);\\n+int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);\\n+double sqlite3_column_double(sqlite3_stmt*, int iCol);\\n+int sqlite3_column_int(sqlite3_stmt*, int iCol);\\n+sqlite_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);\\n+const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);\\n+const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);\\n+int sqlite3_column_type(sqlite3_stmt*, int iCol);\\n+sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);\\n \\n /*\\n ** CAPI3REF: Destroy A Prepared Statement Object\\n@@ -1680,7 +1673,7 @@ SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt);\\n ** the implementation most closely matches the way in which the\\n ** SQL function is used.\\n */\\n-SQLITE_API int sqlite3_create_function(\\n+int sqlite3_create_function(\\n   sqlite3 *,\\n   const char *zFunctionName,\\n   int nArg,\\n@@ -1690,7 +1683,7 @@ SQLITE_API int sqlite3_create_function(\\n   void (*xStep)(sqlite3_context*,int,sqlite3_value**),\\n   void (*xFinal)(sqlite3_context*)\\n );\\n-SQLITE_API int sqlite3_create_function16(\\n+int sqlite3_create_function16(\\n   sqlite3*,\\n   const void *zFunctionName,\\n   int nArg,\\n@@ -1723,10 +1716,10 @@ SQLITE_API int sqlite3_create_function16(\\n ** the use of these functions.  To help encourage people to avoid\\n ** using these functions, we are not going to tell you want they do.\\n */\\n-SQLITE_API int sqlite3_aggregate_count(sqlite3_context*);\\n+int sqlite3_aggregate_count(sqlite3_context*);\\n SQLITE_API int sqlite3_expired(sqlite3_stmt*);\\n-SQLITE_API int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);\\n-SQLITE_API int sqlite3_global_recover(void);\\n+int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);\\n+int sqlite3_global_recover(void);\\n \\n \\n /*\\n@@ -1768,18 +1761,18 @@ SQLITE_API int sqlite3_global_recover(void);\\n ** [sqlite3_value_bytes()], [sqlite3_value_bytes16()], [sqlite_value_text()],\\n ** or [sqlite3_value_text16()].  \\n */\\n-SQLITE_API const void *sqlite3_value_blob(sqlite3_value*);\\n-SQLITE_API int sqlite3_value_bytes(sqlite3_value*);\\n-SQLITE_API int sqlite3_value_bytes16(sqlite3_value*);\\n-SQLITE_API double sqlite3_value_double(sqlite3_value*);\\n-SQLITE_API int sqlite3_value_int(sqlite3_value*);\\n-SQLITE_API sqlite_int64 sqlite3_value_int64(sqlite3_value*);\\n-SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value*);\\n-SQLITE_API const void *sqlite3_value_text16(sqlite3_value*);\\n-SQLITE_API const void *sqlite3_value_text16le(sqlite3_value*);\\n-SQLITE_API const void *sqlite3_value_text16be(sqlite3_value*);\\n-SQLITE_API int sqlite3_value_type(sqlite3_value*);\\n-SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);\\n+const void *sqlite3_value_blob(sqlite3_value*);\\n+int sqlite3_value_bytes(sqlite3_value*);\\n+int sqlite3_value_bytes16(sqlite3_value*);\\n+double sqlite3_value_double(sqlite3_value*);\\n+int sqlite3_value_int(sqlite3_value*);\\n+sqlite_int64 sqlite3_value_int64(sqlite3_value*);\\n+const unsigned char *sqlite3_value_text(sqlite3_value*);\\n+const void *sqlite3_value_text16(sqlite3_value*);\\n+const void *sqlite3_value_text16le(sqlite3_value*);\\n+const void *sqlite3_value_text16be(sqlite3_value*);\\n+int sqlite3_value_type(sqlite3_value*);\\n+int sqlite3_value_numeric_type(sqlite3_value*);\\n \\n /*\\n ** CAPI3REF: Obtain Aggregate Function Context\\n@@ -1799,7 +1792,7 @@ SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);\\n ** parameter to the callback routine that implements the aggregate\\n ** function.\\n */\\n-SQLITE_API void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);\\n+void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);\\n \\n /*\\n ** CAPI3REF: User Data For Functions\\n@@ -1809,7 +1802,7 @@ SQLITE_API void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);\\n ** used to register user functions is available to\\n ** the implementation of the function using this call.\\n */\\n-SQLITE_API void *sqlite3_user_data(sqlite3_context*);\\n+void *sqlite3_user_data(sqlite3_context*);\\n \\n /*\\n ** CAPI3REF: Function Auxiliary Data\\n@@ -1841,8 +1834,8 @@ SQLITE_API void *sqlite3_user_data(sqlite3_context*);\\n ** expressions that are constant at compile time. This includes literal\\n ** values and SQL variables.\\n */\\n-SQLITE_API void *sqlite3_get_auxdata(sqlite3_context*, int);\\n-SQLITE_API void sqlite3_set_auxdata(sqlite3_context*, int, void*, void (*)(void*));\\n+void *sqlite3_get_auxdata(sqlite3_context*, int);\\n+void sqlite3_set_auxdata(sqlite3_context*, int, void*, void (*)(void*));\\n \\n \\n /*\\n@@ -1887,20 +1880,20 @@ typedef void (*sqlite3_destructor_type)(void*);\\n ** to throw and error indicating that a string or BLOB is to long\\n ** to represent.\\n */\\n-SQLITE_API void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));\\n-SQLITE_API void sqlite3_result_double(sqlite3_context*, double);\\n-SQLITE_API void sqlite3_result_error(sqlite3_context*, const char*, int);\\n-SQLITE_API void sqlite3_result_error16(sqlite3_context*, const void*, int);\\n-SQLITE_API void sqlite3_result_error_toobig(sqlite3_context*);\\n-SQLITE_API void sqlite3_result_int(sqlite3_context*, int);\\n-SQLITE_API void sqlite3_result_int64(sqlite3_context*, sqlite_int64);\\n-SQLITE_API void sqlite3_result_null(sqlite3_context*);\\n-SQLITE_API void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));\\n-SQLITE_API void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));\\n-SQLITE_API void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));\\n-SQLITE_API void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));\\n-SQLITE_API void sqlite3_result_value(sqlite3_context*, sqlite3_value*);\\n-SQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n);\\n+void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));\\n+void sqlite3_result_double(sqlite3_context*, double);\\n+void sqlite3_result_error(sqlite3_context*, const char*, int);\\n+void sqlite3_result_error16(sqlite3_context*, const void*, int);\\n+void sqlite3_result_error_toobig(sqlite3_context*);\\n+void sqlite3_result_int(sqlite3_context*, int);\\n+void sqlite3_result_int64(sqlite3_context*, sqlite_int64);\\n+void sqlite3_result_null(sqlite3_context*);\\n+void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));\\n+void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));\\n+void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));\\n+void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));\\n+void sqlite3_result_value(sqlite3_context*, sqlite3_value*);\\n+void sqlite3_result_zeroblob(sqlite3_context*, int n);\\n \\n /*\\n ** CAPI3REF: Define New Collating Sequences\\n@@ -1944,14 +1937,14 @@ SQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n);\\n ** subject to change in future releases.  The other collation creation\\n ** functions are stable.\\n */\\n-SQLITE_API int sqlite3_create_collation(\\n+int sqlite3_create_collation(\\n   sqlite3*, \\n   const char *zName, \\n   int eTextRep, \\n   void*,\\n   int(*xCompare)(void*,int,const void*,int,const void*)\\n );\\n-SQLITE_API int sqlite3_create_collation_v2(\\n+int sqlite3_create_collation_v2(\\n   sqlite3*, \\n   const char *zName, \\n   int eTextRep, \\n@@ -1959,7 +1952,7 @@ SQLITE_API int sqlite3_create_collation_v2(\\n   int(*xCompare)(void*,int,const void*,int,const void*),\\n   void(*xDestroy)(void*)\\n );\\n-SQLITE_API int sqlite3_create_collation16(\\n+int sqlite3_create_collation16(\\n   sqlite3*, \\n   const char *zName, \\n   int eTextRep, \\n@@ -1993,12 +1986,12 @@ SQLITE_API int sqlite3_create_collation16(\\n ** [sqlite3_create_collation()], [sqlite3_create_collation16()], or\\n ** [sqlite3_create_collation_v2()].\\n */\\n-SQLITE_API int sqlite3_collation_needed(\\n+int sqlite3_collation_needed(\\n   sqlite3*, \\n   void*, \\n   void(*)(void*,sqlite3*,int eTextRep,const char*)\\n );\\n-SQLITE_API int sqlite3_collation_needed16(\\n+int sqlite3_collation_needed16(\\n   sqlite3*, \\n   void*,\\n   void(*)(void*,sqlite3*,int eTextRep,const void*)\\n@@ -2056,7 +2049,7 @@ SQLITE_API int sqlite3_sleep(int);\\n ** it is not safe to invoke this routine after [sqlite3_open()] has\\n ** been called.\\n */\\n-SQLITE_EXTERN char *sqlite3_temp_directory;\\n+extern char *sqlite3_temp_directory;\\n \\n /*\\n ** CAPI3REF:  Test To See If The Databse Is In Auto-Commit Mode\\n@@ -2066,7 +2059,7 @@ SQLITE_EXTERN char *sqlite3_temp_directory;\\n ** by default.  Autocommit is disabled by a BEGIN statement and reenabled\\n ** by the next COMMIT or ROLLBACK.\\n */\\n-SQLITE_API int sqlite3_get_autocommit(sqlite3*);\\n+int sqlite3_get_autocommit(sqlite3*);\\n \\n /*\\n ** CAPI3REF:  Find The Database Handle Associated With A Prepared Statement\\n@@ -2077,7 +2070,7 @@ SQLITE_API int sqlite3_get_autocommit(sqlite3*);\\n ** the first argument to the [sqlite3_prepare_v2()] or its variants\\n ** that was used to create the statement in the first place.\\n */\\n-SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt*);\\n+sqlite3 *sqlite3_db_handle(sqlite3_stmt*);\\n \\n \\n /*\\n@@ -2102,8 +2095,8 @@ SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt*);\\n **\\n ** These are experimental interfaces and are subject to change.\\n */\\n-SQLITE_API void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);\\n-SQLITE_API void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);\\n+void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);\\n+void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);\\n \\n /*\\n ** CAPI3REF: Data Change Notification Callbacks\\n@@ -2129,7 +2122,7 @@ SQLITE_API void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);\\n ** If another function was previously registered, its pArg value is returned.\\n ** Otherwise NULL is returned.\\n */\\n-SQLITE_API void *sqlite3_update_hook(\\n+void *sqlite3_update_hook(\\n   sqlite3*, \\n   void(*)(void *,int ,char const *,char const *,sqlite_int64),\\n   void*\\n@@ -2176,7 +2169,7 @@ SQLITE_API void *sqlite3_update_hook(\\n **\\n ** Shared cache is disabled by default for backward compatibility.\\n */\\n-SQLITE_API int sqlite3_enable_shared_cache(int);\\n+int sqlite3_enable_shared_cache(int);\\n \\n /*\\n ** CAPI3REF:  Attempt To Free Heap Memory\\n@@ -2188,7 +2181,7 @@ SQLITE_API int sqlite3_enable_shared_cache(int);\\n ** This function is not a part of standard builds.  It is only created\\n ** if SQLite is compiled with the SQLITE_ENABLE_MEMORY_MANAGEMENT macro.\\n */\\n-SQLITE_API int sqlite3_release_memory(int);\\n+int sqlite3_release_memory(int);\\n \\n /*\\n ** CAPI3REF:  Impose A Limit On Heap Size\\n@@ -2219,7 +2212,7 @@ SQLITE_API int sqlite3_release_memory(int);\\n ** SQLITE_ENABLE_MEMORY_MANAGEMENT option set.\\n ** memory-management has been enabled.\\n */\\n-SQLITE_API void sqlite3_soft_heap_limit(int);\\n+void sqlite3_soft_heap_limit(int);\\n \\n /*\\n ** CAPI3REF:  Clean Up Thread Local Storage\\n@@ -2234,7 +2227,7 @@ SQLITE_API void sqlite3_soft_heap_limit(int);\\n ** want to make absolutely sure they have not forgotten something\\n ** prior to killing off a thread.\\n */\\n-SQLITE_API void sqlite3_thread_cleanup(void);\\n+void sqlite3_thread_cleanup(void);\\n \\n /*\\n ** CAPI3REF:  Extract Metadata About A Column Of A Table\\n@@ -2300,7 +2293,7 @@ SQLITE_API void sqlite3_thread_cleanup(void);\\n ** This API is only available if the library was compiled with the\\n ** SQLITE_ENABLE_COLUMN_METADATA preprocessor symbol defined.\\n */\\n-SQLITE_API int sqlite3_table_column_metadata(\\n+int sqlite3_table_column_metadata(\\n   sqlite3 *db,                /* Connection handle */\\n   const char *zDbName,        /* Database name or NULL */\\n   const char *zTableName,     /* Table name */\\n@@ -2328,7 +2321,7 @@ SQLITE_API int sqlite3_table_column_metadata(\\n ** Extension loading must be enabled using [sqlite3_enable_load_extension()]\\n ** prior to calling this API or an error will be returned.\\n */\\n-SQLITE_API int sqlite3_load_extension(\\n+int sqlite3_load_extension(\\n   sqlite3 *db,          /* Load the extension into this database connection */\\n   const char *zFile,    /* Name of the shared library containing extension */\\n   const char *zProc,    /* Entry point.  Derived from zFile if 0 */\\n@@ -2347,7 +2340,7 @@ SQLITE_API int sqlite3_load_extension(\\n ** Call this routine with onoff==1 to turn extension loading on\\n ** and call it with onoff==0 to turn it back off again.\\n */\\n-SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff);\\n+int sqlite3_enable_load_extension(sqlite3 *db, int onoff);\\n \\n /*\\n ** CAPI3REF: Make Arrangements To Automatically Load An Extension\\n@@ -2374,7 +2367,7 @@ SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff);\\n ** This interface is experimental and is subject to change or\\n ** removal in future releases of SQLite.\\n */\\n-SQLITE_API int sqlite3_auto_extension(void *xEntryPoint);\\n+int sqlite3_auto_extension(void *xEntryPoint);\\n \\n \\n /*\\n@@ -2389,7 +2382,7 @@ SQLITE_API int sqlite3_auto_extension(void *xEntryPoint);\\n ** This interface is experimental and is subject to change or\\n ** removal in future releases of SQLite.\\n */\\n-SQLITE_API void sqlite3_reset_auto_extension(void);\\n+void sqlite3_reset_auto_extension(void);\\n \\n \\n /*\\n@@ -2532,7 +2525,7 @@ struct sqlite3_index_info {\\n ** virtual tables on the module, or before using preexisting virtual\\n ** tables of the module.\\n */\\n-SQLITE_API int sqlite3_create_module(\\n+int sqlite3_create_module(\\n   sqlite3 *db,               /* SQLite connection to register module with */\\n   const char *zName,         /* Name of the module */\\n   const sqlite3_module *,    /* Methods for the module */\\n@@ -2544,7 +2537,7 @@ SQLITE_API int sqlite3_create_module(\\n ** except that it allows a destructor function to be specified. It is\\n ** even more experimental than the rest of the virtual tables API.\\n */\\n-SQLITE_API int sqlite3_create_module_v2(\\n+int sqlite3_create_module_v2(\\n   sqlite3 *db,               /* SQLite connection to register module with */\\n   const char *zName,         /* Name of the module */\\n   const sqlite3_module *,    /* Methods for the module */\\n@@ -2595,7 +2588,7 @@ struct sqlite3_vtab_cursor {\\n ** to declare the format (the names and datatypes of the columns) of\\n ** the virtual tables they implement.\\n */\\n-SQLITE_API int sqlite3_declare_vtab(sqlite3*, const char *zCreateTable);\\n+int sqlite3_declare_vtab(sqlite3*, const char *zCreateTable);\\n \\n /*\\n ** Virtual tables can provide alternative implementations of functions\\n@@ -2613,7 +2606,7 @@ SQLITE_API int sqlite3_declare_vtab(sqlite3*, const char *zCreateTable);\\n ** This API should be considered part of the virtual table interface,\\n ** which is experimental and subject to change.\\n */\\n-SQLITE_API int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);\\n+int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);\\n \\n /*\\n ** The interface to the virtual-table mechanism defined above (back up\\n@@ -2662,7 +2655,7 @@ typedef struct sqlite3_blob sqlite3_blob;\\n ** This function sets the database-handle error code and message\\n ** accessible via [sqlite3_errcode()] and [sqlite3_errmsg()].\\n */\\n-SQLITE_API int sqlite3_blob_open(\\n+int sqlite3_blob_open(\\n   sqlite3*,\\n   const char *zDb,\\n   const char *zTable,\\n@@ -2677,7 +2670,7 @@ SQLITE_API int sqlite3_blob_open(\\n **\\n ** Close an open [sqlite3_blob | blob handle].\\n */\\n-SQLITE_API int sqlite3_blob_close(sqlite3_blob *);\\n+int sqlite3_blob_close(sqlite3_blob *);\\n \\n /*\\n ** CAPI3REF:  Return The Size Of An Open BLOB\\n@@ -2685,7 +2678,7 @@ SQLITE_API int sqlite3_blob_close(sqlite3_blob *);\\n ** Return the size in bytes of the blob accessible via the open \\n ** [sqlite3_blob | blob-handle] passed as an argument.\\n */\\n-SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *);\\n+int sqlite3_blob_bytes(sqlite3_blob *);\\n \\n /*\\n ** CAPI3REF:  Read Data From A BLOB Incrementally\\n@@ -2699,7 +2692,7 @@ SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *);\\n ** [SQLITE_ERROR | SQLite error code] or an\\n ** [SQLITE_IOERR_READ | extended error code] is returned.\\n */\\n-SQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *z, int n, int iOffset);\\n+int sqlite3_blob_read(sqlite3_blob *, void *z, int n, int iOffset);\\n \\n /*\\n ** CAPI3REF:  Write Data Into A BLOB Incrementally\\n@@ -2722,7 +2715,7 @@ SQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *z, int n, int iOffset);\\n ** [SQLITE_ERROR | SQLite error code] or an\\n ** [SQLITE_IOERR_READ | extended error code] is returned.\\n */\\n-SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);\\n+int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);\\n \\n /*\\n ** Undo the hack that converts floating point types to integer for\\n@@ -2757,7 +2750,7 @@ SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOff\\n ** sqlite3RegisterDateTimeFunctions() found at the bottom of the file.\\n ** All other code has file scope.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n **\\n ** SQLite processes all times and dates as Julian Day numbers.  The\\n ** dates and times are stored as the number of days since noon\\n@@ -2801,7 +2794,7 @@ SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOff\\n *************************************************************************\\n ** Internal interface definitions for SQLite.\\n **\\n-** @(#) $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** @(#) $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n #ifndef _SQLITEINT_H_\\n #define _SQLITEINT_H_\\n@@ -2821,7 +2814,7 @@ SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOff\\n ** \\n ** This file defines various limits of what SQLite can process.\\n **\\n-** @(#) $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** @(#) $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n /*\\n@@ -3024,7 +3017,7 @@ SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOff\\n ** This is the header file for the generic hash-table implemenation\\n ** used in SQLite.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n #ifndef _SQLITE_HASH_H_\\n #define _SQLITE_HASH_H_\\n@@ -3406,7 +3399,7 @@ typedef UINT8_TYPE i8;             /* 1-byte signed integer */\\n ** Macros to determine whether the machine is big or little endian,\\n ** evaluated at runtime.\\n */\\n-SQLITE_PRIVATE const int sqlite3one;\\n+extern const int sqlite3one;\\n #if defined(i386) || defined(__i386__) || defined(_M_IX86)\\n # define SQLITE_BIGENDIAN    0\\n # define SQLITE_LITTLEENDIAN 1\\n@@ -3456,7 +3449,7 @@ struct BusyHandler {\\n ** or VDBE.  The VDBE implements an abstract machine that runs a\\n ** simple program to access and modify the underlying database.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n #ifndef _SQLITE_VDBE_H_\\n #define _SQLITE_VDBE_H_\\n@@ -3772,7 +3765,7 @@ SQLITE_PRIVATE   void sqlite3VdbeComment(Vdbe*, const char*, ...);\\n ** subsystem.  See comments in the source code for a detailed description\\n ** of what each interface routine does.\\n **\\n-** @(#) $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** @(#) $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n #ifndef _BTREE_H_\\n #define _BTREE_H_\\n@@ -3926,7 +3919,7 @@ SQLITE_PRIVATE int sqlite3BtreePageDump(Btree*, int, int recursive);\\n ** subsystem.  The page cache subsystem reads and writes a file a page\\n ** at a time and provides a journal for rollback.\\n **\\n-** @(#) $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** @(#) $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n #ifndef _PAGER_H_\\n@@ -4048,17 +4041,17 @@ void enable_simulated_io_errors(void);\\n ** The following global variables are used for testing and debugging\\n ** only.  They only work if SQLITE_MEMDEBUG is defined.\\n */\\n-SQLITE_API extern int sqlite3_nMalloc;      /* Number of sqliteMalloc() calls */\\n-SQLITE_API extern int sqlite3_nFree;        /* Number of sqliteFree() calls */\\n-SQLITE_API extern int sqlite3_iMallocFail;  /* Fail sqliteMalloc() after this many calls */\\n-SQLITE_API extern int sqlite3_iMallocReset; /* Set iMallocFail to this when it reaches 0 */\\n+extern int sqlite3_nMalloc;      /* Number of sqliteMalloc() calls */\\n+extern int sqlite3_nFree;        /* Number of sqliteFree() calls */\\n+extern int sqlite3_iMallocFail;  /* Fail sqliteMalloc() after this many calls */\\n+extern int sqlite3_iMallocReset; /* Set iMallocFail to this when it reaches 0 */\\n \\n-SQLITE_API extern void *sqlite3_pFirst;         /* Pointer to linked list of allocations */\\n-SQLITE_API extern int sqlite3_nMaxAlloc;        /* High water mark of ThreadData.nAlloc */\\n-SQLITE_API extern int sqlite3_mallocDisallowed; /* assert() in sqlite3Malloc() if set */\\n-SQLITE_API extern int sqlite3_isFail;           /* True if all malloc calls should fail */\\n-SQLITE_API extern const char *sqlite3_zFile;    /* Filename to associate debug info with */\\n-SQLITE_API extern int sqlite3_iLine;            /* Line number for debug info */\\n+extern void *sqlite3_pFirst;         /* Pointer to linked list of allocations */\\n+extern int sqlite3_nMaxAlloc;        /* High water mark of ThreadData.nAlloc */\\n+extern int sqlite3_mallocDisallowed; /* assert() in sqlite3Malloc() if set */\\n+extern int sqlite3_isFail;           /* True if all malloc calls should fail */\\n+extern const char *sqlite3_zFile;    /* Filename to associate debug info with */\\n+extern int sqlite3_iLine;            /* Line number for debug info */\\n \\n #define ENTER_MALLOC (sqlite3_zFile = __FILE__, sqlite3_iLine = __LINE__)\\n #define sqliteMalloc(x)          (ENTER_MALLOC, sqlite3Malloc(x,1))\\n@@ -4080,15 +4073,15 @@ SQLITE_API extern int sqlite3_iLine;            /* Line number for debug info */\\n \\n #endif\\n \\n-/* Variable sqlite3MallocHasFailed is set to true after a malloc() \\n+/* Variable sqlite3_mallocHasFailed is set to true after a malloc() \\n ** failure occurs. \\n **\\n ** The sqlite3MallocFailed() macro returns true if a malloc has failed\\n ** in this thread since the last call to sqlite3ApiExit(), or false \\n ** otherwise.\\n */\\n-SQLITE_PRIVATE int sqlite3MallocHasFailed;\\n-#define sqlite3MallocFailed() (sqlite3MallocHasFailed && sqlite3OsInMutex(1))\\n+extern int sqlite3_mallocHasFailed;\\n+#define sqlite3MallocFailed() (sqlite3_mallocHasFailed && sqlite3OsInMutex(1))\\n \\n #define sqliteFree(x)          sqlite3FreeX(x)\\n #define sqliteAllocSize(x)     sqlite3AllocSize(x)\\n@@ -4509,7 +4502,7 @@ struct OsFile {\\n #ifndef SQLITE_TEST\\n #define PENDING_BYTE      0x40000000  /* First byte past the 1GB boundary */\\n #else\\n-SQLITE_API extern unsigned int sqlite3_pending_byte;\\n+extern unsigned int sqlite3_pending_byte;\\n #define PENDING_BYTE sqlite3_pending_byte\\n #endif\\n \\n@@ -4667,7 +4660,7 @@ struct sqlite3OsVtbl {\\n \\n \\n /* This additional API routine is available with redefinable I/O */\\n-SQLITE_API struct sqlite3OsVtbl *sqlite3_os_switch(void);\\n+struct sqlite3OsVtbl *sqlite3_os_switch(void);\\n \\n \\n /*\\n@@ -5853,11 +5846,11 @@ struct TriggerStep {\\n   Trigger *pTrig;      /* The trigger that this step is a part of */\\n \\n   Select *pSelect;     /* Valid for SELECT and sometimes \\n-                          INSERT steps (when pExprList == 0) */\\n+\\t\\t\\t  INSERT steps (when pExprList == 0) */\\n   Token target;        /* Valid for DELETE, UPDATE, INSERT steps */\\n   Expr *pWhere;        /* Valid for DELETE, UPDATE steps */\\n   ExprList *pExprList; /* Valid for UPDATE statements and sometimes \\n-                           INSERT steps (when pSelect == 0)         */\\n+\\t\\t\\t   INSERT steps (when pSelect == 0)         */\\n   IdList *pIdList;     /* Valid for INSERT statements only */\\n   TriggerStep *pNext;  /* Next in the link-list */\\n   TriggerStep *pLast;  /* Last element in link-list. Valid for 1st elem only */\\n@@ -5925,15 +5918,69 @@ typedef struct {\\n } InitData;\\n \\n /*\\n-** Assuming zIn points to the first byte of a UTF-8 character,\\n-** advance zIn to point to the first byte of the next UTF-8 character.\\n+ * This global flag is set for performance testing of triggers. When it is set\\n+ * SQLite will perform the overhead of building new and old trigger references \\n+ * even when no triggers exist\\n+ */\\n+extern int sqlite3_always_code_trigger_setup;\\n+\\n+/*\\n+** A lookup table used by the SQLITE_READ_UTF8 macro.  The definition\\n+** is in utf.c.\\n */\\n+extern const unsigned char sqlite3UtfTrans1[];\\n+\\n+/*\\n+** Macros for reading UTF8 characters.\\n+**\\n+** SQLITE_READ_UTF8(x,c) reads a single UTF8 value out of x and writes\\n+** that value into c.  The type of x must be unsigned char*.  The type\\n+** of c must be unsigned int.\\n+**\\n+** SQLITE_SKIP_UTF8(x) advances x forward by one character.  The type of\\n+** x must be unsigned char*.\\n+**\\n+** Notes On Invalid UTF-8:\\n+**\\n+**  *  These macros never allow a 7-bit character (0x00 through 0x7f) to\\n+**     be encoded as a multi-byte character.  Any multi-byte character that\\n+**     attempts to encode a value between 0x00 and 0x7f is rendered as 0xfffd.\\n+**\\n+**  *  These macros never allow a UTF16 surrogate value to be encoded.\\n+**     If a multi-byte character attempts to encode a value between\\n+**     0xd800 and 0xe000 then it is rendered as 0xfffd.\\n+**\\n+**  *  Bytes in the range of 0x80 through 0xbf which occur as the first\\n+**     byte of a character are interpreted as single-byte characters\\n+**     and rendered as themselves even though they are technically\\n+**     invalid characters.\\n+**\\n+**  *  These routines accept an infinite number of different UTF8 encodings\\n+**     for unicode values 0x80 and greater.  They do not change over-length\\n+**     encodings to 0xfffd as some systems recommend.\\n+** \\n+*/\\n+#define SQLITE_READ_UTF8(zIn, c) {                     \\\\\\n+  c = *(zIn++);                                        \\\\\\n+  if( c>=0xc0 ){                                       \\\\\\n+    c = sqlite3UtfTrans1[c-0xc0];                      \\\\\\n+    while( (*zIn & 0xc0)==0x80 ){                      \\\\\\n+      c = (c<<6) + (0x3f & *(zIn++));                  \\\\\\n+    }                                                  \\\\\\n+    if( c<0x80                                         \\\\\\n+        || (c&0xFFFFF800)==0xD800                      \\\\\\n+        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }    \\\\\\n+  }                                                    \\\\\\n+}\\n #define SQLITE_SKIP_UTF8(zIn) {                        \\\\\\n   if( (*(zIn++))>=0xc0 ){                              \\\\\\n     while( (*zIn & 0xc0)==0x80 ){ zIn++; }             \\\\\\n   }                                                    \\\\\\n }\\n \\n+\\n+\\n+\\n /*\\n ** The SQLITE_CORRUPT_BKPT macro can be either a constant (for production\\n ** builds) or a function call (for debugging).  If it is a function call,\\n@@ -6152,7 +6199,7 @@ SQLITE_PRIVATE int sqlite3GetInt32(const char *, int*);\\n SQLITE_PRIVATE int sqlite3FitsIn64Bits(const char *);\\n SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *pData, int nChar);\\n SQLITE_PRIVATE int sqlite3Utf8CharLen(const char *pData, int nByte);\\n-SQLITE_PRIVATE int sqlite3Utf8Read(const u8*, const u8*, const u8**);\\n+SQLITE_PRIVATE u32 sqlite3ReadUtf8(const unsigned char *);\\n SQLITE_PRIVATE int sqlite3PutVarint(unsigned char *, u64);\\n SQLITE_PRIVATE int sqlite3GetVarint(const unsigned char *, u64 *);\\n SQLITE_PRIVATE int sqlite3GetVarint32(const unsigned char *, u32 *);\\n@@ -6175,6 +6222,7 @@ SQLITE_PRIVATE Expr *sqlite3ExprSetColl(Parse *pParse, Expr *, Token *);\\n SQLITE_PRIVATE int sqlite3CheckCollSeq(Parse *, CollSeq *);\\n SQLITE_PRIVATE int sqlite3CheckObjectName(Parse *, const char *);\\n SQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *, int);\\n+SQLITE_PRIVATE void sqlite3Utf16Substr(sqlite3_context *,int,sqlite3_value **);\\n \\n SQLITE_PRIVATE const void *sqlite3ValueText(sqlite3_value*, u8);\\n SQLITE_PRIVATE int sqlite3ValueBytes(sqlite3_value*, u8);\\n@@ -6184,7 +6232,7 @@ SQLITE_PRIVATE sqlite3_value *sqlite3ValueNew(void);\\n SQLITE_PRIVATE char *sqlite3Utf16to8(const void*, int);\\n SQLITE_PRIVATE int sqlite3ValueFromExpr(Expr *, u8, u8, sqlite3_value **);\\n SQLITE_PRIVATE void sqlite3ValueApplyAffinity(sqlite3_value *, u8, u8);\\n-SQLITE_PRIVATE const unsigned char sqlite3UpperToLower[];\\n+extern const unsigned char sqlite3UpperToLower[];\\n SQLITE_PRIVATE void sqlite3RootPageMoved(Db*, int, int);\\n SQLITE_PRIVATE void sqlite3Reindex(Parse*, Token*, Token*);\\n SQLITE_PRIVATE void sqlite3AlterFunctions(sqlite3*);\\n@@ -6223,13 +6271,6 @@ SQLITE_PRIVATE void sqlite3FailedMalloc(void);\\n SQLITE_PRIVATE void sqlite3AbortOtherActiveVdbes(sqlite3 *, Vdbe *);\\n SQLITE_PRIVATE int sqlite3OpenTempDatabase(Parse *);\\n \\n-/*\\n-** The interface to the LEMON-generated parser\\n-*/\\n-SQLITE_PRIVATE void *sqlite3ParserAlloc(void*(*)(size_t));\\n-SQLITE_PRIVATE void sqlite3ParserFree(void*, void(*)(void*));\\n-SQLITE_PRIVATE void sqlite3Parser(void*, int, Token, Parse*);\\n-\\n #ifndef SQLITE_OMIT_LOAD_EXTENSION\\n SQLITE_PRIVATE   void sqlite3CloseExtensions(sqlite3*);\\n SQLITE_PRIVATE   int sqlite3AutoLoadExtensions(sqlite3*);\\n@@ -6291,7 +6332,7 @@ SQLITE_PRIVATE FuncDef *sqlite3VtabOverloadFunction(FuncDef*, int nArg, Expr*);\\n SQLITE_PRIVATE void sqlite3InvalidFunction(sqlite3_context*,int,sqlite3_value**);\\n SQLITE_PRIVATE int sqlite3Reprepare(Vdbe*);\\n SQLITE_PRIVATE void sqlite3ExprListCheckLength(Parse*, ExprList*, int, const char*);\\n-SQLITE_PRIVATE CollSeq *sqlite3BinaryCompareCollSeq(Parse *, Expr *, Expr *);\\n+CollSeq* sqlite3BinaryCompareCollSeq(Parse *, Expr *, Expr *);\\n \\n #if SQLITE_MAX_EXPR_DEPTH>0\\n SQLITE_PRIVATE   void sqlite3ExprSetHeight(Expr *);\\n@@ -6300,7 +6341,9 @@ SQLITE_PRIVATE   int sqlite3SelectExprHeight(Select *);\\n   #define sqlite3ExprSetHeight(x)\\n #endif\\n \\n+SQLITE_PRIVATE u32 sqlite3Get2byte(const u8*);\\n SQLITE_PRIVATE u32 sqlite3Get4byte(const u8*);\\n+SQLITE_PRIVATE void sqlite3Put2byte(u8*, u32);\\n SQLITE_PRIVATE void sqlite3Put4byte(u8*, u32);\\n \\n #ifdef SQLITE_SSE\\n@@ -6323,7 +6366,7 @@ SQLITE_PRIVATE   void sqlite3VdbeIOTraceSql(Vdbe*);\\n # define IOTRACE(A)\\n # define sqlite3VdbeIOTraceSql(X)\\n #endif\\n-SQLITE_EXTERN void (*sqlite3_io_trace)(const char*,...);\\n+extern void (*sqlite3_io_trace)(const char*,...);\\n \\n #endif\\n \\n@@ -7407,7 +7450,7 @@ SQLITE_PRIVATE int sqlite3OsSectorSize(OsFile *id){\\n ** backwards compatibility with an earlier redefinable I/O\\n ** interface design.\\n */\\n-SQLITE_API struct sqlite3OsVtbl *sqlite3_os_switch(void){\\n+struct sqlite3OsVtbl *sqlite3_os_switch(void){\\n   return &sqlite3Os;\\n }\\n #endif\\n@@ -7428,7 +7471,7 @@ SQLITE_API struct sqlite3OsVtbl *sqlite3_os_switch(void){\\n ** Memory allocation functions used throughout sqlite.\\n **\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n /*\\n@@ -7481,7 +7524,7 @@ SQLITE_API struct sqlite3OsVtbl *sqlite3_os_switch(void){\\n ** Set the soft heap-size limit for the current thread. Passing a negative\\n ** value indicates no limit.\\n */\\n-SQLITE_API void sqlite3_soft_heap_limit(int n){\\n+void sqlite3_soft_heap_limit(int n){\\n   ThreadData *pTd = sqlite3ThreadData();\\n   if( pTd ){\\n     pTd->nSoftHeapLimit = n;\\n@@ -7492,7 +7535,7 @@ SQLITE_API void sqlite3_soft_heap_limit(int n){\\n /*\\n ** Release memory held by SQLite instances created by the current thread.\\n */\\n-SQLITE_API int sqlite3_release_memory(int n){\\n+int sqlite3_release_memory(int n){\\n   return sqlite3PagerReleaseMemory(n);\\n }\\n #else\\n@@ -7550,7 +7593,7 @@ SQLITE_API int sqlite3_release_memory(int n){\\n ** sqlite3_malloc_id are stored along with the other test system metadata.\\n */\\n #define TESTALLOC_USERSIZE 64\\n-SQLITE_API const char *sqlite3_malloc_id = 0;\\n+const char *sqlite3_malloc_id = 0;\\n \\n /*\\n ** Blocks used by the test layer have the following format:\\n@@ -7602,20 +7645,20 @@ SQLITE_API const char *sqlite3_malloc_id = 0;\\n ** order to verify that the library correctly handles an out-of-memory\\n ** condition.\\n */\\n-SQLITE_API int sqlite3_nMalloc;         /* Number of sqliteMalloc() calls */\\n-SQLITE_API int sqlite3_nFree;           /* Number of sqliteFree() calls */\\n-SQLITE_API int sqlite3_memUsed;         /* TODO Total memory obtained from malloc */\\n-SQLITE_API int sqlite3_memMax;          /* TODO Mem usage high-water mark */\\n-SQLITE_API int sqlite3_iMallocFail;     /* Fail sqliteMalloc() after this many calls */\\n-SQLITE_API int sqlite3_iMallocReset = -1; /* When iMallocFail reaches 0, set to this */\\n+int sqlite3_nMalloc;         /* Number of sqliteMalloc() calls */\\n+int sqlite3_nFree;           /* Number of sqliteFree() calls */\\n+int sqlite3_memUsed;         /* TODO Total memory obtained from malloc */\\n+int sqlite3_memMax;          /* TODO Mem usage high-water mark */\\n+int sqlite3_iMallocFail;     /* Fail sqliteMalloc() after this many calls */\\n+int sqlite3_iMallocReset = -1; /* When iMallocFail reaches 0, set to this */\\n \\n-SQLITE_API void *sqlite3_pFirst = 0;         /* Pointer to linked list of allocations */\\n-SQLITE_API int sqlite3_nMaxAlloc = 0;        /* High water mark of ThreadData.nAlloc */\\n-SQLITE_API int sqlite3_mallocDisallowed = 0; /* assert() in sqlite3Malloc() if set */\\n-SQLITE_API int sqlite3_isFail = 0;           /* True if all malloc calls should fail */\\n-SQLITE_API const char *sqlite3_zFile = 0;    /* Filename to associate debug info with */\\n-SQLITE_API int sqlite3_iLine = 0;            /* Line number for debug info */\\n-SQLITE_API int sqlite3_mallocfail_trace = 0; /* Print a msg on malloc fail if true */\\n+void *sqlite3_pFirst = 0;         /* Pointer to linked list of allocations */\\n+int sqlite3_nMaxAlloc = 0;        /* High water mark of ThreadData.nAlloc */\\n+int sqlite3_mallocDisallowed = 0; /* assert() in sqlite3Malloc() if set */\\n+int sqlite3_isFail = 0;           /* True if all malloc calls should fail */\\n+const char *sqlite3_zFile = 0;    /* Filename to associate debug info with */\\n+int sqlite3_iLine = 0;            /* Line number for debug info */\\n+int sqlite3_mallocfail_trace = 0; /* Print a msg on malloc fail if true */\\n \\n /*\\n ** Check for a simulated memory allocation failure.  Return true if\\n@@ -8203,10 +8246,10 @@ SQLITE_PRIVATE void sqlite3SetString(char **pz, ...){\\n ** then the connection error-code (the value returned by sqlite3_errcode())\\n ** is set to SQLITE_NOMEM.\\n */\\n-SQLITE_PRIVATE int sqlite3MallocHasFailed = 0;\\n+int sqlite3_mallocHasFailed = 0;\\n SQLITE_PRIVATE int sqlite3ApiExit(sqlite3* db, int rc){\\n   if( sqlite3MallocFailed() ){\\n-    sqlite3MallocHasFailed = 0;\\n+    sqlite3_mallocHasFailed = 0;\\n     sqlite3OsLeaveMutex();\\n     sqlite3Error(db, SQLITE_NOMEM, 0);\\n     rc = SQLITE_NOMEM;\\n@@ -8220,8 +8263,8 @@ SQLITE_PRIVATE int sqlite3ApiExit(sqlite3* db, int rc){\\n SQLITE_PRIVATE void sqlite3FailedMalloc(){\\n   if( !sqlite3MallocFailed() ){\\n     sqlite3OsEnterMutex();\\n-    assert( sqlite3MallocHasFailed==0 );\\n-    sqlite3MallocHasFailed = 1;\\n+    assert( sqlite3_mallocHasFailed==0 );\\n+    sqlite3_mallocHasFailed = 1;\\n   }\\n }\\n \\n@@ -9151,7 +9194,7 @@ SQLITE_PRIVATE void sqlite3DebugPrintf(const char *zFormat, ...){\\n ** Random numbers are used by some of the database backends in order\\n ** to generate random integer keys for tables or random filenames.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n \\n@@ -9249,7 +9292,7 @@ SQLITE_PRIVATE void sqlite3Randomness(int N, void *pBuf){\\n ** This file contains routines used to translate between UTF-8, \\n ** UTF-16, UTF-16BE, and UTF-16LE.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n **\\n ** Notes on UTF-8:\\n **\\n@@ -9307,7 +9350,7 @@ SQLITE_PRIVATE void sqlite3Randomness(int N, void *pBuf){\\n ** array is defined in a separate source code file named opcode.c which is\\n ** automatically generated by the makefile.\\n */\\n-SQLITE_PRIVATE const char *const sqlite3OpcodeNames[];\\n+extern const char *const sqlite3OpcodeNames[];\\n \\n /*\\n ** SQL is translated into a sequence of instructions to be\\n@@ -9711,13 +9754,13 @@ SQLITE_PRIVATE   int sqlite3VdbeMemExpandBlob(Mem *);\\n ** The following constant value is used by the SQLITE_BIGENDIAN and\\n ** SQLITE_LITTLEENDIAN macros.\\n */\\n-SQLITE_PRIVATE const int sqlite3one = 1;\\n+const int sqlite3one = 1;\\n \\n /*\\n ** This lookup table is used to help decode the first byte of\\n ** a multi-byte UTF8 character.\\n */\\n-static const unsigned char sqlite3UtfTrans1[] = {\\n+const unsigned char sqlite3UtfTrans1[] = {\\n   0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\\n   0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\\n   0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\\n@@ -9728,7 +9771,6 @@ static const unsigned char sqlite3UtfTrans1[] = {\\n   0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,\\n };\\n \\n-\\n #define WRITE_UTF8(zOut, c) {                          \\\\\\n   if( c<0x00080 ){                                     \\\\\\n     *zOut++ = (c&0xFF);                                \\\\\\n@@ -9796,54 +9838,6 @@ static const unsigned char sqlite3UtfTrans1[] = {\\n }\\n \\n /*\\n-** Translate a single UTF-8 character.  Return the unicode value.\\n-**\\n-** During translation, assume that the byte that zTerm points\\n-** is a 0x00.\\n-**\\n-** Write a pointer to the next unread byte back into *pzNext.\\n-**\\n-** Notes On Invalid UTF-8:\\n-**\\n-**  *  This routine never allows a 7-bit character (0x00 through 0x7f) to\\n-**     be encoded as a multi-byte character.  Any multi-byte character that\\n-**     attempts to encode a value between 0x00 and 0x7f is rendered as 0xfffd.\\n-**\\n-**  *  This routine never allows a UTF16 surrogate value to be encoded.\\n-**     If a multi-byte character attempts to encode a value between\\n-**     0xd800 and 0xe000 then it is rendered as 0xfffd.\\n-**\\n-**  *  Bytes in the range of 0x80 through 0xbf which occur as the first\\n-**     byte of a character are interpreted as single-byte characters\\n-**     and rendered as themselves even though they are technically\\n-**     invalid characters.\\n-**\\n-**  *  This routine accepts an infinite number of different UTF8 encodings\\n-**     for unicode values 0x80 and greater.  It do not change over-length\\n-**     encodings to 0xfffd as some systems recommend.\\n-*/\\n-SQLITE_PRIVATE int sqlite3Utf8Read(\\n-  const unsigned char *z,         /* First byte of UTF-8 character */\\n-  const unsigned char *zTerm,     /* Pretend this byte is 0x00 */\\n-  const unsigned char **pzNext    /* Write first byte past UTF-8 char here */\\n-){\\n-  int c = *(z++);\\n-  if( c>=0xc0 ){\\n-    c = sqlite3UtfTrans1[c-0xc0];\\n-    while( z!=zTerm && (*z & 0xc0)==0x80 ){\\n-      c = (c<<6) + (0x3f & *(z++));\\n-    }\\n-    if( c<0x80\\n-        || (c&0xFFFFF800)==0xD800\\n-        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }\\n-  }\\n-  *pzNext = z;\\n-  return c;\\n-}\\n-\\n-\\n-\\n-/*\\n ** If the TRANSLATE_TRACE macro is defined, the value of each Mem is\\n ** printed on stderr on the way into and out of sqlite3VdbeMemTranslate().\\n */ \\n@@ -9936,19 +9930,81 @@ SQLITE_PRIVATE int sqlite3VdbeMemTranslate(Mem *pMem, u8 desiredEnc){\\n   z = zOut;\\n \\n   if( pMem->enc==SQLITE_UTF8 ){\\n+    unsigned int iExtra = 0xD800;\\n+\\n+    if( 0==(pMem->flags&MEM_Term) && zTerm>zIn && (zTerm[-1]&0x80) ){\\n+      /* This UTF8 string is not nul-terminated, and the last byte is\\n+      ** not a character in the ascii range (codpoints 0..127). This\\n+      ** means the SQLITE_READ_UTF8() macro might read past the end\\n+      ** of the allocated buffer.\\n+      **\\n+      ** There are four possibilities:\\n+      **\\n+      **   1. The last byte is the first byte of a non-ASCII character,\\n+      **\\n+      **   2. The final N bytes of the input string are continuation bytes\\n+      **      and immediately preceding them is the first byte of a \\n+      **      non-ASCII character.\\n+      **\\n+      **   3. The final N bytes of the input string are continuation bytes\\n+      **      and immediately preceding them is a byte that encodes a \\n+      **      character in the ASCII range.\\n+      **\\n+      **   4. The entire string consists of continuation characters.\\n+      **\\n+      ** Cases (3) and (4) require no special handling. The SQLITE_READ_UTF8()\\n+      ** macro will not overread the buffer in these cases.\\n+      */\\n+      unsigned char *zExtra = &zTerm[-1];\\n+      while( zExtra>zIn && (zExtra[0]&0xC0)==0x80 ){\\n+        zExtra--;\\n+      }\\n+\\n+      if( (zExtra[0]&0xC0)==0xC0 ){\\n+        /* Make a copy of the last character encoding in the input string.\\n+        ** Then make sure it is nul-terminated and use SQLITE_READ_UTF8()\\n+        ** to decode the codepoint. Store the codepoint in variable iExtra,\\n+        ** it will be appended to the output string later.\\n+        */\\n+        unsigned char *zFree = 0;\\n+        unsigned char zBuf[16];\\n+        int nExtra = (pMem->n+zIn-zExtra);\\n+        zTerm = zExtra;\\n+        if( nExtra>15 ){\\n+          zExtra = sqliteMallocRaw(nExtra+1);\\n+          if( !zExtra ){\\n+            return SQLITE_NOMEM;\\n+          }\\n+          zFree = zExtra;\\n+        }else{\\n+          zExtra = zBuf;\\n+        }\\n+        memcpy(zExtra, zTerm, nExtra);\\n+        zExtra[nExtra] = '\\\\0';\\n+        SQLITE_READ_UTF8(zExtra, iExtra);\\n+        sqliteFree(zFree);\\n+      }\\n+    }\\n+\\n     if( desiredEnc==SQLITE_UTF16LE ){\\n       /* UTF-8 -> UTF-16 Little-endian */\\n       while( zIn<zTerm ){\\n-        c = sqlite3Utf8Read(zIn, zTerm, (const u8**)&zIn);\\n+        SQLITE_READ_UTF8(zIn, c); \\n         WRITE_UTF16LE(z, c);\\n       }\\n+      if( iExtra!=0xD800 ){\\n+        WRITE_UTF16LE(z, iExtra);\\n+      }\\n     }else{\\n       assert( desiredEnc==SQLITE_UTF16BE );\\n       /* UTF-8 -> UTF-16 Big-endian */\\n       while( zIn<zTerm ){\\n-        c = sqlite3Utf8Read(zIn, zTerm, (const u8**)&zIn);\\n+        SQLITE_READ_UTF8(zIn, c); \\n         WRITE_UTF16BE(z, c);\\n       }\\n+      if( iExtra!=0xD800 ){\\n+        WRITE_UTF16BE(z, iExtra);\\n+      }\\n     }\\n     pMem->n = z - zOut;\\n     *z++ = 0;\\n@@ -10132,11 +10188,11 @@ SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *zIn, int nChar){\\n SQLITE_PRIVATE int sqlite3Utf8To8(unsigned char *zIn){\\n   unsigned char *zOut = zIn;\\n   unsigned char *zStart = zIn;\\n-  unsigned char *zTerm;\\n-  u32 c;\\n+  int c;\\n \\n-  while( zIn[0] ){\\n-    c = sqlite3Utf8Read(zIn, zTerm, (const u8**)&zIn);\\n+  while(1){\\n+    SQLITE_READ_UTF8(zIn, c);\\n+    if( c==0 ) break;\\n     if( c!=0xfffd ){\\n       WRITE_UTF8(zOut, c);\\n     }\\n@@ -10156,7 +10212,6 @@ SQLITE_PRIVATE void sqlite3UtfSelfTest(){\\n   unsigned int i, t;\\n   unsigned char zBuf[20];\\n   unsigned char *z;\\n-  unsigned char *zTerm;\\n   int n;\\n   unsigned int c;\\n \\n@@ -10165,9 +10220,8 @@ SQLITE_PRIVATE void sqlite3UtfSelfTest(){\\n     WRITE_UTF8(z, i);\\n     n = z-zBuf;\\n     z[0] = 0;\\n-    zTerm = z;\\n     z = zBuf;\\n-    c = sqlite3Utf8Read(z, zTerm, (const u8**)&z);\\n+    SQLITE_READ_UTF8(z, c);\\n     t = i;\\n     if( i>=0xD800 && i<=0xDFFF ) t = 0xFFFD;\\n     if( (i&0xFFFFFFFE)==0xFFFE ) t = 0xFFFD;\\n@@ -10218,7 +10272,7 @@ SQLITE_PRIVATE void sqlite3UtfSelfTest(){\\n ** This file contains functions for allocating memory, comparing\\n ** strings, and stuff like that.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n \\n@@ -10337,7 +10391,7 @@ SQLITE_PRIVATE void sqlite3Dequote(char *z){\\n /* An array to map all upper-case characters into their corresponding\\n ** lower-case character. \\n */\\n-SQLITE_PRIVATE const unsigned char sqlite3UpperToLower[] = {\\n+const unsigned char sqlite3UpperToLower[] = {\\n #ifdef SQLITE_ASCII\\n       0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\\n      18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,\\n@@ -10947,7 +11001,7 @@ SQLITE_PRIVATE void sqlite3ReleaseThreadData(){\\n ** This is the implementation of generic hash-tables\\n ** used in SQLite.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n /* Turn bulk memory into a hash table object by initializing the\\n@@ -11334,7 +11388,7 @@ SQLITE_PRIVATE void *sqlite3HashInsert(Hash *pH, const void *pKey, int nKey, voi\\n /* Automatically generated.  Do not edit */\\n /* See the mkopcodec.awk script for details. */\\n #if !defined(SQLITE_OMIT_EXPLAIN) || !defined(NDEBUG) || defined(VDBE_PROFILE) || defined(SQLITE_DEBUG)\\n-SQLITE_PRIVATE const char *const sqlite3OpcodeNames[] = { \\\"?\\\",\\n+const char *const sqlite3OpcodeNames[] = { \\\"?\\\",\\n  /*   1 */ \\\"MemLoad\\\",\\n  /*   2 */ \\\"VNext\\\",\\n  /*   3 */ \\\"Column\\\",\\n@@ -11547,11 +11601,11 @@ SQLITE_PRIVATE const char *const sqlite3OpcodeNames[] = { \\\"?\\\",\\n  * pending-byte in the database file.\\n  */\\n #ifdef SQLITE_TEST\\n-SQLITE_API unsigned int sqlite3_pending_byte = 0x40000000;\\n+unsigned int sqlite3_pending_byte = 0x40000000;\\n #endif\\n \\n+int sqlite3_os_trace = 0;\\n #ifdef SQLITE_DEBUG\\n-SQLITE_API int sqlite3_os_trace = 0;\\n #define OSTRACE1(X)         if( sqlite3_os_trace ) sqlite3DebugPrintf(X)\\n #define OSTRACE2(X,Y)       if( sqlite3_os_trace ) sqlite3DebugPrintf(X,Y)\\n #define OSTRACE3(X,Y,Z)     if( sqlite3_os_trace ) sqlite3DebugPrintf(X,Y,Z)\\n@@ -11600,11 +11654,11 @@ static unsigned int elapse;\\n ** is used for testing the I/O recovery logic.\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_io_error_hit = 0;\\n-SQLITE_API int sqlite3_io_error_pending = 0;\\n-SQLITE_API int sqlite3_io_error_persist = 0;\\n-SQLITE_API int sqlite3_diskfull_pending = 0;\\n-SQLITE_API int sqlite3_diskfull = 0;\\n+int sqlite3_io_error_hit = 0;\\n+int sqlite3_io_error_pending = 0;\\n+int sqlite3_io_error_persist = 0;\\n+int sqlite3_diskfull_pending = 0;\\n+int sqlite3_diskfull = 0;\\n #define SimulateIOError(CODE)  \\\\\\n   if( sqlite3_io_error_pending || sqlite3_io_error_hit ) \\\\\\n      if( sqlite3_io_error_pending-- == 1 \\\\\\n@@ -11634,7 +11688,7 @@ static void local_ioerr(){\\n ** When testing, keep a count of the number of open files.\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_open_file_count = 0;\\n+int sqlite3_open_file_count = 0;\\n #define OpenCounter(X)  sqlite3_open_file_count+=(X)\\n #else\\n #define OpenCounter(X)\\n@@ -12600,7 +12654,7 @@ SQLITE_PRIVATE int sqlite3Os2InMutex( int thisThreadOnly ){\\n ** returned from sqlite3OsCurrentTime().  This is used for testing.\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_current_time = 0;\\n+int sqlite3_current_time = 0;\\n #endif\\n \\n /*\\n@@ -12648,7 +12702,7 @@ SQLITE_PRIVATE int sqlite3Os2CurrentTime( double *prNow ){\\n ** Ticket #1601\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_tsd_count = 0;\\n+int sqlite3_tsd_count = 0;\\n # define TSD_COUNTER_INCR InterlockedIncrement( &sqlite3_tsd_count )\\n # define TSD_COUNTER_DECR InterlockedDecrement( &sqlite3_tsd_count )\\n #else\\n@@ -12866,11 +12920,11 @@ struct unixFile {\\n  * pending-byte in the database file.\\n  */\\n #ifdef SQLITE_TEST\\n-SQLITE_API unsigned int sqlite3_pending_byte = 0x40000000;\\n+unsigned int sqlite3_pending_byte = 0x40000000;\\n #endif\\n \\n+int sqlite3_os_trace = 0;\\n #ifdef SQLITE_DEBUG\\n-SQLITE_API int sqlite3_os_trace = 0;\\n #define OSTRACE1(X)         if( sqlite3_os_trace ) sqlite3DebugPrintf(X)\\n #define OSTRACE2(X,Y)       if( sqlite3_os_trace ) sqlite3DebugPrintf(X,Y)\\n #define OSTRACE3(X,Y,Z)     if( sqlite3_os_trace ) sqlite3DebugPrintf(X,Y,Z)\\n@@ -12919,11 +12973,11 @@ static unsigned int elapse;\\n ** is used for testing the I/O recovery logic.\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_io_error_hit = 0;\\n-SQLITE_API int sqlite3_io_error_pending = 0;\\n-SQLITE_API int sqlite3_io_error_persist = 0;\\n-SQLITE_API int sqlite3_diskfull_pending = 0;\\n-SQLITE_API int sqlite3_diskfull = 0;\\n+int sqlite3_io_error_hit = 0;\\n+int sqlite3_io_error_pending = 0;\\n+int sqlite3_io_error_persist = 0;\\n+int sqlite3_diskfull_pending = 0;\\n+int sqlite3_diskfull = 0;\\n #define SimulateIOError(CODE)  \\\\\\n   if( sqlite3_io_error_pending || sqlite3_io_error_hit ) \\\\\\n      if( sqlite3_io_error_pending-- == 1 \\\\\\n@@ -12953,7 +13007,7 @@ static void local_ioerr(){\\n ** When testing, keep a count of the number of open files.\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_open_file_count = 0;\\n+int sqlite3_open_file_count = 0;\\n #define OpenCounter(X)  sqlite3_open_file_count+=(X)\\n #else\\n #define OpenCounter(X)\\n@@ -13288,12 +13342,12 @@ static Hash openHash = {SQLITE_HASH_BINARY, 0, 0, 0,\\n **   file systems that are known to be unsupported\\n */\\n typedef enum {\\n-        posixLockingStyle = 0,       /* standard posix-advisory locks */\\n-        afpLockingStyle,             /* use afp locks */\\n-        flockLockingStyle,           /* use flock() */\\n-        dotlockLockingStyle,         /* use <file>.lock files */\\n-        noLockingStyle,              /* useful for read-only file system */\\n-        unsupportedLockingStyle      /* indicates unsupported file system */\\n+\\tposixLockingStyle = 0,       /* standard posix-advisory locks */\\n+\\tafpLockingStyle,             /* use afp locks */\\n+\\tflockLockingStyle,           /* use flock() */\\n+\\tdotlockLockingStyle,         /* use <file>.lock files */\\n+\\tnoLockingStyle,              /* useful for read-only file system */\\n+\\tunsupportedLockingStyle      /* indicates unsupported file system */\\n } sqlite3LockingStyle;\\n #endif /* SQLITE_ENABLE_LOCKING_STYLE */\\n \\n@@ -13513,7 +13567,7 @@ static sqlite3LockingStyle sqlite3DetectLockingStyle(const char *filePath,\\n   \\n   if( (!strcmp(fsInfo.f_fstypename, \\\"hfs\\\")) ||\\n     (!strcmp(fsInfo.f_fstypename, \\\"ufs\\\")) )\\n-                return posixLockingStyle;\\n+\\t\\treturn posixLockingStyle;\\n   \\n   if(!strcmp(fsInfo.f_fstypename, \\\"afpfs\\\"))\\n     return afpLockingStyle;\\n@@ -14020,8 +14074,8 @@ static int unixSeek(OsFile *id, i64 offset){\\n ** Count the number of fullsyncs and normal syncs.  This is used to test\\n ** that syncs and fullsyncs are occuring at the right times.\\n */\\n-SQLITE_API int sqlite3_sync_count = 0;\\n-SQLITE_API int sqlite3_fullsync_count = 0;\\n+int sqlite3_sync_count = 0;\\n+int sqlite3_fullsync_count = 0;\\n #endif\\n \\n /*\\n@@ -14626,7 +14680,7 @@ struct ByteRangeLockPB2\\n   int fd;                           /* file desc to assoc this lock with */\\n };\\n \\n-#define afpfsByteRangeLock2FSCTL        _IOWR('z', 23, struct ByteRangeLockPB2)\\n+#define afpfsByteRangeLock2FSCTL\\t_IOWR('z', 23, struct ByteRangeLockPB2)\\n \\n /* return 0 on success, 1 on failure.  To match the behavior of the \\n   normal posix file locking (used in unixLock for example), we should \\n@@ -14635,7 +14689,7 @@ struct ByteRangeLockPB2\\n static int _AFPFSSetLock(const char *path, int fd, unsigned long long offset, \\n                          unsigned long long length, int setLockFlag)\\n {\\n-  struct ByteRangeLockPB2       pb;\\n+  struct ByteRangeLockPB2\\tpb;\\n   int                     err;\\n   \\n   pb.unLockFlag = setLockFlag ? 0 : 1;\\n@@ -15715,7 +15769,7 @@ SQLITE_PRIVATE int sqlite3UnixInMutex(int thisThrd){\\n ** Ticket #1601\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_tsd_count = 0;\\n+int sqlite3_tsd_count = 0;\\n # ifdef SQLITE_UNIX_THREADS\\n     static pthread_mutex_t tsd_counter_mutex = PTHREAD_MUTEX_INITIALIZER;\\n #   define TSD_COUNTER(N) \\\\\\n@@ -15818,7 +15872,7 @@ SQLITE_PRIVATE ThreadData *sqlite3UnixThreadSpecificData(int allocateFlag){\\n ** returned from sqlite3OsCurrentTime().  This is used for testing.\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_current_time = 0;\\n+int sqlite3_current_time = 0;\\n #endif\\n \\n /*\\n@@ -15917,11 +15971,11 @@ SQLITE_PRIVATE int sqlite3UnixCurrentTime(double *prNow){\\n  * pending-byte in the database file.\\n  */\\n #ifdef SQLITE_TEST\\n-SQLITE_API unsigned int sqlite3_pending_byte = 0x40000000;\\n+unsigned int sqlite3_pending_byte = 0x40000000;\\n #endif\\n \\n+int sqlite3_os_trace = 0;\\n #ifdef SQLITE_DEBUG\\n-SQLITE_API int sqlite3_os_trace = 0;\\n #define OSTRACE1(X)         if( sqlite3_os_trace ) sqlite3DebugPrintf(X)\\n #define OSTRACE2(X,Y)       if( sqlite3_os_trace ) sqlite3DebugPrintf(X,Y)\\n #define OSTRACE3(X,Y,Z)     if( sqlite3_os_trace ) sqlite3DebugPrintf(X,Y,Z)\\n@@ -15970,11 +16024,11 @@ static unsigned int elapse;\\n ** is used for testing the I/O recovery logic.\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_io_error_hit = 0;\\n-SQLITE_API int sqlite3_io_error_pending = 0;\\n-SQLITE_API int sqlite3_io_error_persist = 0;\\n-SQLITE_API int sqlite3_diskfull_pending = 0;\\n-SQLITE_API int sqlite3_diskfull = 0;\\n+int sqlite3_io_error_hit = 0;\\n+int sqlite3_io_error_pending = 0;\\n+int sqlite3_io_error_persist = 0;\\n+int sqlite3_diskfull_pending = 0;\\n+int sqlite3_diskfull = 0;\\n #define SimulateIOError(CODE)  \\\\\\n   if( sqlite3_io_error_pending || sqlite3_io_error_hit ) \\\\\\n      if( sqlite3_io_error_pending-- == 1 \\\\\\n@@ -16004,7 +16058,7 @@ static void local_ioerr(){\\n ** When testing, keep a count of the number of open files.\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_open_file_count = 0;\\n+int sqlite3_open_file_count = 0;\\n #define OpenCounter(X)  sqlite3_open_file_count+=(X)\\n #else\\n #define OpenCounter(X)\\n@@ -16147,7 +16201,7 @@ struct winFile {\\n ** In order to facilitate testing on a WinNT system, the test fixture\\n ** can manually set this value to 1 to emulate Win98 behavior.\\n */\\n-SQLITE_API int sqlite3_os_type = 0;\\n+int sqlite3_os_type = 0;\\n \\n /*\\n ** Return true (non-zero) if we are running under WinNT, Win2K, WinXP,\\n@@ -17706,7 +17760,7 @@ SQLITE_PRIVATE int sqlite3WinInMutex(int thisThreadOnly){\\n ** returned from sqlite3OsCurrentTime().  This is used for testing.\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_current_time = 0;\\n+int sqlite3_current_time = 0;\\n #endif\\n \\n /*\\n@@ -17743,7 +17797,7 @@ SQLITE_PRIVATE int sqlite3WinCurrentTime(double *prNow){\\n ** Ticket #1601\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_tsd_count = 0;\\n+int sqlite3_tsd_count = 0;\\n # define TSD_COUNTER_INCR InterlockedIncrement(&sqlite3_tsd_count)\\n # define TSD_COUNTER_DECR InterlockedDecrement(&sqlite3_tsd_count)\\n #else\\n@@ -17828,7 +17882,7 @@ SQLITE_PRIVATE ThreadData *sqlite3WinThreadSpecificData(int allocateFlag){\\n ** file simultaneously, or one process from reading the database while\\n ** another is writing.\\n **\\n-** @(#) $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** @(#) $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n #ifndef SQLITE_OMIT_DISKIO\\n \\n@@ -18180,10 +18234,10 @@ struct Pager {\\n ** a non-testing build.  These variables are not thread-safe.\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_pager_readdb_count = 0;    /* Number of full pages read from DB */\\n-SQLITE_API int sqlite3_pager_writedb_count = 0;   /* Number of full pages written to DB */\\n-SQLITE_API int sqlite3_pager_writej_count = 0;    /* Number of pages written to journal */\\n-SQLITE_API int sqlite3_pager_pgfree_count = 0;    /* Number of cache pages freed */\\n+int sqlite3_pager_readdb_count = 0;    /* Number of full pages read from DB */\\n+int sqlite3_pager_writedb_count = 0;   /* Number of full pages written to DB */\\n+int sqlite3_pager_writej_count = 0;    /* Number of pages written to journal */\\n+int sqlite3_pager_pgfree_count = 0;    /* Number of cache pages freed */\\n # define PAGER_INCR(v)  v++\\n #else\\n # define PAGER_INCR(v)\\n@@ -18367,11 +18421,7 @@ static int write32bits(OsFile *fd, u32 val){\\n */\\n static int pager_error(Pager *pPager, int rc){\\n   int rc2 = rc & 0xff;\\n-  assert(\\n-       pPager->errCode==SQLITE_FULL ||\\n-       pPager->errCode==SQLITE_OK ||\\n-       (pPager->errCode & 0xff)==SQLITE_IOERR\\n-  );\\n+  assert( pPager->errCode==SQLITE_FULL || pPager->errCode==SQLITE_OK );\\n   if(\\n     rc2==SQLITE_FULL ||\\n     rc2==SQLITE_IOERR ||\\n@@ -19260,15 +19310,10 @@ static int pager_playback(Pager *pPager, int isHot){\\n     }\\n \\n     /* If nRec is 0 and this rollback is of a transaction created by this\\n-    ** process and if this is the final header in the journal, then it means\\n-    ** that this part of the journal was being filled but has not yet been\\n-    ** synced to disk.  Compute the number of pages based on the remaining\\n-    ** size of the file.\\n-    **\\n-    ** The third term of the test was added to fix ticket #2565.\\n+    ** process. In this case the rest of the journal file consists of\\n+    ** journalled copies of pages that need to be read back into the cache.\\n     */\\n-    if( nRec==0 && !isHot &&\\n-        pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff ){\\n+    if( nRec==0 && !isHot ){\\n       nRec = (szJ - pPager->journalOff) / JOURNAL_PG_SZ(pPager);\\n     }\\n \\n@@ -19486,7 +19531,7 @@ SQLITE_PRIVATE void sqlite3PagerSetSafetyLevel(Pager *pPager, int level, int ful\\n ** testing and analysis only.  \\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_opentemp_count = 0;\\n+int sqlite3_opentemp_count = 0;\\n #endif\\n \\n /*\\n@@ -19746,8 +19791,8 @@ SQLITE_PRIVATE int sqlite3PagerMaxPageCount(Pager *pPager, int mxPage){\\n ** and generate no code.\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API extern int sqlite3_io_error_pending;\\n-SQLITE_API extern int sqlite3_io_error_hit;\\n+extern int sqlite3_io_error_pending;\\n+extern int sqlite3_io_error_hit;\\n static int saved_cnt;\\n void disable_simulated_io_errors(void){\\n   saved_cnt = sqlite3_io_error_pending;\\n@@ -20569,7 +20614,7 @@ SQLITE_PRIVATE int sqlite3PagerReleaseMemory(int nReq){\\n           pTmp->pNextAll = pPg->pNextAll;\\n         }\\n         nReleased += sqliteAllocSize(pPg);\\n-        IOTRACE((\\\"PGFREE %p %d *\\\\n\\\", pPager, pPg->pgno));\\n+        IOTRACE((\\\"PGFREE %p %d\\\\n\\\", pPager, pPg->pgno));\\n         PAGER_INCR(sqlite3_pager_pgfree_count);\\n         sqliteFree(pPg);\\n       }\\n@@ -20581,11 +20626,7 @@ SQLITE_PRIVATE int sqlite3PagerReleaseMemory(int nReq){\\n         ** The error will be returned to the user (or users, in the case \\n         ** of a shared pager cache) of the pager for which the error occured.\\n         */\\n-        assert(\\n-            (rc&0xff)==SQLITE_IOERR ||\\n-            rc==SQLITE_FULL ||\\n-            rc==SQLITE_BUSY\\n-        );\\n+        assert( (rc&0xff)==SQLITE_IOERR || rc==SQLITE_FULL );\\n         assert( pPager->state>=PAGER_RESERVED );\\n         pager_error(pPager, rc);\\n       }\\n@@ -20674,8 +20715,8 @@ static int pagerSharedLock(Pager *pPager){\\n         ** a write lock, so there is never any chance of two or more\\n         ** processes opening the journal at the same time.\\n         **\\n-        ** Open the journal for read/write access. This is because in \\n-        ** exclusive-access mode the file descriptor will be kept open and\\n+\\t** Open the journal for read/write access. This is because in \\n+\\t** exclusive-access mode the file descriptor will be kept open and\\n         ** possibly used for a transaction later on. On some systems, the\\n         ** OsTruncate() call used in exclusive-access mode also requires\\n         ** a read/write file handle.\\n@@ -21397,7 +21438,7 @@ static int pager_write(PgHdr *pPg){\\n                PAGERID(pPager), pPg->pgno, pPg->needSync, pager_pagehash(pPg));\\n           *(u32*)pEnd = saved;\\n \\n-          /* An error has occured writing to the journal file. The \\n+\\t  /* An error has occured writing to the journal file. The \\n           ** transaction will be rolled back by the layer above.\\n           */\\n           if( rc!=SQLITE_OK ){\\n@@ -22299,7 +22340,7 @@ SQLITE_PRIVATE void sqlite3PagerRefdump(Pager *pPager){\\n **    May you share freely, never taking more than you give.\\n **\\n *************************************************************************\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n **\\n ** This file implements a external (disk-based) database using BTrees.\\n ** See the header comment on \\\"btreeInt.h\\\" for additional information.\\n@@ -22318,7 +22359,7 @@ SQLITE_PRIVATE void sqlite3PagerRefdump(Pager *pPager){\\n **    May you share freely, never taking more than you give.\\n **\\n *************************************************************************\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n **\\n ** This file implements a external (disk-based) database using BTrees.\\n ** For a detailed discussion of BTrees, refer to\\n@@ -23298,13 +23339,11 @@ static int ptrmapGet(BtShared *pBt, Pgno key, u8 *pEType, Pgno *pPgno){\\n */\\n #define findCell(pPage, iCell) \\\\\\n   ((pPage)->aData + get2byte(&(pPage)->aData[(pPage)->cellOffset+2*(iCell)]))\\n-#ifdef SQLITE_TEST\\n SQLITE_PRIVATE u8 *sqlite3BtreeFindCell(MemPage *pPage, int iCell){\\n   assert( iCell>=0 );\\n   assert( iCell<get2byte(&pPage->aData[pPage->hdrOffset+3]) );\\n   return findCell(pPage, iCell);\\n }\\n-#endif\\n \\n /*\\n ** This a more complex version of sqlite3BtreeFindCell() that works for\\n@@ -24888,7 +24927,7 @@ static int autoVacuumCommit(BtShared *pBt, Pgno *pnTrunc){\\n       assert(nFin==0 || pBt->nTrunc==0 || nFin<=pBt->nTrunc);\\n       rc = SQLITE_OK;\\n       if( pBt->nTrunc ){\\n-        rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);\\n+        sqlite3PagerWrite(pBt->pPage1->pDbPage);\\n         put4byte(&pBt->pPage1->aData[32], 0);\\n         put4byte(&pBt->pPage1->aData[36], 0);\\n         pBt->nTrunc = nFin;\\n@@ -25670,8 +25709,8 @@ static int accessPayload(\\n       if( offset>=ovflSize ){\\n         /* The only reason to read this page is to obtain the page\\n         ** number for the next page in the overflow chain. The page\\n-        ** data is not required. So first try to lookup the overflow\\n-        ** page-list cache, if any, then fall back to the getOverflowPage()\\n+\\t** data is not required. So first try to lookup the overflow\\n+\\t** page-list cache, if any, then fall back to the getOverflowPage()\\n         ** function.\\n         */\\n #ifndef SQLITE_OMIT_INCRBLOB\\n@@ -27650,7 +27689,7 @@ static int balance_nonroot(MemPage *pPage){\\n         memcpy(&pNew->aData[8], pCell, 4);\\n         pTemp = 0;\\n       }else if( leafData ){\\n-        /* If the tree is a leaf-data tree, and the siblings are leaves, \\n+\\t/* If the tree is a leaf-data tree, and the siblings are leaves, \\n         ** then there is no divider cell in apCell[]. Instead, the divider \\n         ** cell consists of the integer key for the right-most cell of \\n         ** the sibling-page assembled above only.\\n@@ -27842,6 +27881,7 @@ static int balance_shallower(MemPage *pPage){\\n       }\\n     }\\n #endif\\n+    if( rc!=SQLITE_OK ) goto end_shallow_balance;\\n     releasePage(pChild);\\n   }\\n end_shallow_balance:\\n@@ -30377,7 +30417,7 @@ SQLITE_PRIVATE int sqlite3ValueBytes(sqlite3_value *pVal, u8 enc){\\n ** as they are added to the instruction stream.\\n */\\n #ifdef SQLITE_DEBUG\\n-SQLITE_API int sqlite3_vdbe_addop_trace = 0;\\n+int sqlite3_vdbe_addop_trace = 0;\\n #endif\\n \\n \\n@@ -31144,9 +31184,8 @@ SQLITE_PRIVATE void sqlite3VdbeIOTraceSql(Vdbe *p){\\n   if( nOp<1 ) return;\\n   pOp = &p->aOp[nOp-1];\\n   if( pOp->opcode==OP_Noop && pOp->p3!=0 ){\\n+    char *z = sqlite3StrDup(pOp->p3);\\n     int i, j;\\n-    char z[1000];\\n-    sqlite3_snprintf(sizeof(z), z, \\\"%s\\\", pOp->p3);\\n     for(i=0; isspace((unsigned char)z[i]); i++){}\\n     for(j=0; z[i]; i++){\\n       if( isspace((unsigned char)z[i]) ){\\n@@ -31159,6 +31198,7 @@ SQLITE_PRIVATE void sqlite3VdbeIOTraceSql(Vdbe *p){\\n     }\\n     z[j] = 0;\\n     sqlite3_io_trace(\\\"SQL %s\\\\n\\\", z);\\n+    sqliteFree(z);\\n   }\\n }\\n #endif /* !SQLITE_OMIT_TRACE && SQLITE_ENABLE_IOTRACE */\\n@@ -31786,7 +31826,7 @@ SQLITE_PRIVATE int sqlite3VdbeHalt(Vdbe *p){\\n     */\\n     if( db->autoCommit && db->activeVdbeCnt==1 ){\\n       if( p->rc==SQLITE_OK || (p->errorAction==OE_Fail && !isSpecialError) ){\\n-        /* The auto-commit flag is true, and the vdbe program was \\n+\\t/* The auto-commit flag is true, and the vdbe program was \\n         ** successful or hit an 'OR FAIL' constraint. This means a commit \\n         ** is required.\\n         */\\n@@ -31951,6 +31991,9 @@ SQLITE_PRIVATE int sqlite3VdbeReset(Vdbe *p){\\n #endif\\n   p->magic = VDBE_MAGIC_INIT;\\n   p->aborted = 0;\\n+  if( p->rc==SQLITE_SCHEMA ){\\n+    sqlite3ResetInternalSchema(db, 0);\\n+  }\\n   return p->rc & db->errMask;\\n }\\n  \\n@@ -32597,7 +32640,7 @@ SQLITE_API int sqlite3_expired(sqlite3_stmt *pStmt){\\n ** The following routines extract information from a Mem or sqlite3_value\\n ** structure.\\n */\\n-SQLITE_API const void *sqlite3_value_blob(sqlite3_value *pVal){\\n+const void *sqlite3_value_blob(sqlite3_value *pVal){\\n   Mem *p = (Mem*)pVal;\\n   if( p->flags & (MEM_Blob|MEM_Str) ){\\n     sqlite3VdbeMemExpandBlob(p);\\n@@ -32608,36 +32651,36 @@ SQLITE_API const void *sqlite3_value_blob(sqlite3_value *pVal){\\n     return sqlite3_value_text(pVal);\\n   }\\n }\\n-SQLITE_API int sqlite3_value_bytes(sqlite3_value *pVal){\\n+int sqlite3_value_bytes(sqlite3_value *pVal){\\n   return sqlite3ValueBytes(pVal, SQLITE_UTF8);\\n }\\n-SQLITE_API int sqlite3_value_bytes16(sqlite3_value *pVal){\\n+int sqlite3_value_bytes16(sqlite3_value *pVal){\\n   return sqlite3ValueBytes(pVal, SQLITE_UTF16NATIVE);\\n }\\n-SQLITE_API double sqlite3_value_double(sqlite3_value *pVal){\\n+double sqlite3_value_double(sqlite3_value *pVal){\\n   return sqlite3VdbeRealValue((Mem*)pVal);\\n }\\n-SQLITE_API int sqlite3_value_int(sqlite3_value *pVal){\\n+int sqlite3_value_int(sqlite3_value *pVal){\\n   return sqlite3VdbeIntValue((Mem*)pVal);\\n }\\n-SQLITE_API sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal){\\n+sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal){\\n   return sqlite3VdbeIntValue((Mem*)pVal);\\n }\\n-SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value *pVal){\\n+const unsigned char *sqlite3_value_text(sqlite3_value *pVal){\\n   return (const unsigned char *)sqlite3ValueText(pVal, SQLITE_UTF8);\\n }\\n #ifndef SQLITE_OMIT_UTF16\\n-SQLITE_API const void *sqlite3_value_text16(sqlite3_value* pVal){\\n+const void *sqlite3_value_text16(sqlite3_value* pVal){\\n   return sqlite3ValueText(pVal, SQLITE_UTF16NATIVE);\\n }\\n-SQLITE_API const void *sqlite3_value_text16be(sqlite3_value *pVal){\\n+const void *sqlite3_value_text16be(sqlite3_value *pVal){\\n   return sqlite3ValueText(pVal, SQLITE_UTF16BE);\\n }\\n-SQLITE_API const void *sqlite3_value_text16le(sqlite3_value *pVal){\\n+const void *sqlite3_value_text16le(sqlite3_value *pVal){\\n   return sqlite3ValueText(pVal, SQLITE_UTF16LE);\\n }\\n #endif /* SQLITE_OMIT_UTF16 */\\n-SQLITE_API int sqlite3_value_type(sqlite3_value* pVal){\\n+int sqlite3_value_type(sqlite3_value* pVal){\\n   return pVal->type;\\n }\\n /* sqlite3_value_numeric_type() defined in vdbe.c */\\n@@ -32646,7 +32689,7 @@ SQLITE_API int sqlite3_value_type(sqlite3_value* pVal){\\n ** The following routines are used by user-defined functions to specify\\n ** the function result.\\n */\\n-SQLITE_API void sqlite3_result_blob(\\n+void sqlite3_result_blob(\\n   sqlite3_context *pCtx, \\n   const void *z, \\n   int n, \\n@@ -32655,29 +32698,29 @@ SQLITE_API void sqlite3_result_blob(\\n   assert( n>=0 );\\n   sqlite3VdbeMemSetStr(&pCtx->s, z, n, 0, xDel);\\n }\\n-SQLITE_API void sqlite3_result_double(sqlite3_context *pCtx, double rVal){\\n+void sqlite3_result_double(sqlite3_context *pCtx, double rVal){\\n   sqlite3VdbeMemSetDouble(&pCtx->s, rVal);\\n }\\n-SQLITE_API void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){\\n+void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){\\n   pCtx->isError = 1;\\n   sqlite3VdbeMemSetStr(&pCtx->s, z, n, SQLITE_UTF8, SQLITE_TRANSIENT);\\n }\\n #ifndef SQLITE_OMIT_UTF16\\n-SQLITE_API void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){\\n+void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){\\n   pCtx->isError = 1;\\n   sqlite3VdbeMemSetStr(&pCtx->s, z, n, SQLITE_UTF16NATIVE, SQLITE_TRANSIENT);\\n }\\n #endif\\n-SQLITE_API void sqlite3_result_int(sqlite3_context *pCtx, int iVal){\\n+void sqlite3_result_int(sqlite3_context *pCtx, int iVal){\\n   sqlite3VdbeMemSetInt64(&pCtx->s, (i64)iVal);\\n }\\n-SQLITE_API void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){\\n+void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){\\n   sqlite3VdbeMemSetInt64(&pCtx->s, iVal);\\n }\\n-SQLITE_API void sqlite3_result_null(sqlite3_context *pCtx){\\n+void sqlite3_result_null(sqlite3_context *pCtx){\\n   sqlite3VdbeMemSetNull(&pCtx->s);\\n }\\n-SQLITE_API void sqlite3_result_text(\\n+void sqlite3_result_text(\\n   sqlite3_context *pCtx, \\n   const char *z, \\n   int n,\\n@@ -32686,7 +32729,7 @@ SQLITE_API void sqlite3_result_text(\\n   sqlite3VdbeMemSetStr(&pCtx->s, z, n, SQLITE_UTF8, xDel);\\n }\\n #ifndef SQLITE_OMIT_UTF16\\n-SQLITE_API void sqlite3_result_text16(\\n+void sqlite3_result_text16(\\n   sqlite3_context *pCtx, \\n   const void *z, \\n   int n, \\n@@ -32694,7 +32737,7 @@ SQLITE_API void sqlite3_result_text16(\\n ){\\n   sqlite3VdbeMemSetStr(&pCtx->s, z, n, SQLITE_UTF16NATIVE, xDel);\\n }\\n-SQLITE_API void sqlite3_result_text16be(\\n+void sqlite3_result_text16be(\\n   sqlite3_context *pCtx, \\n   const void *z, \\n   int n, \\n@@ -32702,7 +32745,7 @@ SQLITE_API void sqlite3_result_text16be(\\n ){\\n   sqlite3VdbeMemSetStr(&pCtx->s, z, n, SQLITE_UTF16BE, xDel);\\n }\\n-SQLITE_API void sqlite3_result_text16le(\\n+void sqlite3_result_text16le(\\n   sqlite3_context *pCtx, \\n   const void *z, \\n   int n, \\n@@ -32711,15 +32754,15 @@ SQLITE_API void sqlite3_result_text16le(\\n   sqlite3VdbeMemSetStr(&pCtx->s, z, n, SQLITE_UTF16LE, xDel);\\n }\\n #endif /* SQLITE_OMIT_UTF16 */\\n-SQLITE_API void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){\\n+void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){\\n   sqlite3VdbeMemCopy(&pCtx->s, pValue);\\n }\\n-SQLITE_API void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){\\n+void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){\\n   sqlite3VdbeMemSetZeroBlob(&pCtx->s, n);\\n }\\n \\n /* Force an SQLITE_TOOBIG error. */\\n-SQLITE_API void sqlite3_result_error_toobig(sqlite3_context *pCtx){\\n+void sqlite3_result_error_toobig(sqlite3_context *pCtx){\\n   sqlite3VdbeMemSetZeroBlob(&pCtx->s, SQLITE_MAX_LENGTH+1);\\n }\\n \\n@@ -32875,7 +32918,7 @@ SQLITE_API int sqlite3_step(sqlite3_stmt *pStmt){\\n ** Extract the user data from a sqlite3_context structure and return a\\n ** pointer to it.\\n */\\n-SQLITE_API void *sqlite3_user_data(sqlite3_context *p){\\n+void *sqlite3_user_data(sqlite3_context *p){\\n   assert( p && p->pFunc );\\n   return p->pFunc->pUserData;\\n }\\n@@ -32906,7 +32949,7 @@ SQLITE_PRIVATE void sqlite3InvalidFunction(\\n ** context is allocated on the first call.  Subsequent calls return the\\n ** same context that was returned on prior calls.\\n */\\n-SQLITE_API void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){\\n+void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){\\n   Mem *pMem = p->pMem;\\n   assert( p && p->pFunc && p->pFunc->xStep );\\n   if( (pMem->flags & MEM_Agg)==0 ){\\n@@ -32932,7 +32975,7 @@ SQLITE_API void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){\\n ** Return the auxilary data pointer, if any, for the iArg'th argument to\\n ** the user-function defined by pCtx.\\n */\\n-SQLITE_API void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){\\n+void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){\\n   VdbeFunc *pVdbeFunc = pCtx->pVdbeFunc;\\n   if( !pVdbeFunc || iArg>=pVdbeFunc->nAux || iArg<0 ){\\n     return 0;\\n@@ -32945,7 +32988,7 @@ SQLITE_API void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){\\n ** argument to the user-function defined by pCtx. Any previous value is\\n ** deleted by calling the delete function specified when it was set.\\n */\\n-SQLITE_API void sqlite3_set_auxdata(\\n+void sqlite3_set_auxdata(\\n   sqlite3_context *pCtx, \\n   int iArg, \\n   void *pAux, \\n@@ -32953,13 +32996,13 @@ SQLITE_API void sqlite3_set_auxdata(\\n ){\\n   struct AuxData *pAuxData;\\n   VdbeFunc *pVdbeFunc;\\n-  if( iArg<0 ) goto failed;\\n+  if( iArg<0 ) return;\\n \\n   pVdbeFunc = pCtx->pVdbeFunc;\\n   if( !pVdbeFunc || pVdbeFunc->nAux<=iArg ){\\n     int nMalloc = sizeof(VdbeFunc) + sizeof(struct AuxData)*iArg;\\n     pVdbeFunc = sqliteRealloc(pVdbeFunc, nMalloc);\\n-    if( !pVdbeFunc ) goto failed;\\n+    if( !pVdbeFunc ) return;\\n     pCtx->pVdbeFunc = pVdbeFunc;\\n     memset(&pVdbeFunc->apAux[pVdbeFunc->nAux], 0, \\n              sizeof(struct AuxData)*(iArg+1-pVdbeFunc->nAux));\\n@@ -32973,12 +33016,6 @@ SQLITE_API void sqlite3_set_auxdata(\\n   }\\n   pAuxData->pAux = pAux;\\n   pAuxData->xDelete = xDelete;\\n-  return;\\n-\\n-failed:\\n-  if( xDelete ){\\n-    xDelete(pAux);\\n-  }\\n }\\n \\n /*\\n@@ -32990,7 +33027,7 @@ failed:\\n ** implementations should keep their own counts within their aggregate\\n ** context.\\n */\\n-SQLITE_API int sqlite3_aggregate_count(sqlite3_context *p){\\n+int sqlite3_aggregate_count(sqlite3_context *p){\\n   assert( p && p->pFunc && p->pFunc->xStep );\\n   return p->pMem->n;\\n }\\n@@ -32998,7 +33035,7 @@ SQLITE_API int sqlite3_aggregate_count(sqlite3_context *p){\\n /*\\n ** Return the number of columns in the result set for the statement pStmt.\\n */\\n-SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt){\\n+int sqlite3_column_count(sqlite3_stmt *pStmt){\\n   Vdbe *pVm = (Vdbe *)pStmt;\\n   return pVm ? pVm->nResColumn : 0;\\n }\\n@@ -33007,7 +33044,7 @@ SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt){\\n ** Return the number of values available from the current row of the\\n ** currently executing statement pStmt.\\n */\\n-SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt){\\n+int sqlite3_data_count(sqlite3_stmt *pStmt){\\n   Vdbe *pVm = (Vdbe *)pStmt;\\n   if( pVm==0 || !pVm->resOnStack ) return 0;\\n   return pVm->nResColumn;\\n@@ -33065,7 +33102,7 @@ static void columnMallocFailure(sqlite3_stmt *pStmt)\\n ** The following routines are used to access elements of the current row\\n ** in the result set.\\n */\\n-SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){\\n+const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){\\n   const void *val;\\n   val = sqlite3_value_blob( columnMem(pStmt,i) );\\n   /* Even though there is no encoding conversion, value_blob() might\\n@@ -33075,47 +33112,47 @@ SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){\\n   columnMallocFailure(pStmt);\\n   return val;\\n }\\n-SQLITE_API int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){\\n+int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){\\n   int val = sqlite3_value_bytes( columnMem(pStmt,i) );\\n   columnMallocFailure(pStmt);\\n   return val;\\n }\\n-SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){\\n+int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){\\n   int val = sqlite3_value_bytes16( columnMem(pStmt,i) );\\n   columnMallocFailure(pStmt);\\n   return val;\\n }\\n-SQLITE_API double sqlite3_column_double(sqlite3_stmt *pStmt, int i){\\n+double sqlite3_column_double(sqlite3_stmt *pStmt, int i){\\n   double val = sqlite3_value_double( columnMem(pStmt,i) );\\n   columnMallocFailure(pStmt);\\n   return val;\\n }\\n-SQLITE_API int sqlite3_column_int(sqlite3_stmt *pStmt, int i){\\n+int sqlite3_column_int(sqlite3_stmt *pStmt, int i){\\n   int val = sqlite3_value_int( columnMem(pStmt,i) );\\n   columnMallocFailure(pStmt);\\n   return val;\\n }\\n-SQLITE_API sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i){\\n+sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i){\\n   sqlite_int64 val = sqlite3_value_int64( columnMem(pStmt,i) );\\n   columnMallocFailure(pStmt);\\n   return val;\\n }\\n-SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i){\\n+const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i){\\n   const unsigned char *val = sqlite3_value_text( columnMem(pStmt,i) );\\n   columnMallocFailure(pStmt);\\n   return val;\\n }\\n-SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i){\\n+sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i){\\n   return columnMem(pStmt, i);\\n }\\n #ifndef SQLITE_OMIT_UTF16\\n-SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i){\\n+const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i){\\n   const void *val = sqlite3_value_text16( columnMem(pStmt,i) );\\n   columnMallocFailure(pStmt);\\n   return val;\\n }\\n #endif /* SQLITE_OMIT_UTF16 */\\n-SQLITE_API int sqlite3_column_type(sqlite3_stmt *pStmt, int i){\\n+int sqlite3_column_type(sqlite3_stmt *pStmt, int i){\\n   return sqlite3_value_type( columnMem(pStmt,i) );\\n }\\n \\n@@ -33169,12 +33206,12 @@ static const void *columnName(\\n ** Return the name of the Nth column of the result set returned by SQL\\n ** statement pStmt.\\n */\\n-SQLITE_API const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N){\\n+const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N){\\n   return columnName(\\n       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_NAME);\\n }\\n #ifndef SQLITE_OMIT_UTF16\\n-SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){\\n+const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){\\n   return columnName(\\n       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_NAME);\\n }\\n@@ -33184,12 +33221,12 @@ SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){\\n ** Return the column declaration type (if applicable) of the 'i'th column\\n ** of the result set of SQL statement pStmt.\\n */\\n-SQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){\\n+const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){\\n   return columnName(\\n       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_DECLTYPE);\\n }\\n #ifndef SQLITE_OMIT_UTF16\\n-SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){\\n+const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){\\n   return columnName(\\n       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_DECLTYPE);\\n }\\n@@ -33201,12 +33238,12 @@ SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){\\n ** NULL is returned if the result column is an expression or constant or\\n ** anything else which is not an unabiguous reference to a database column.\\n */\\n-SQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N){\\n+const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N){\\n   return columnName(\\n       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_DATABASE);\\n }\\n #ifndef SQLITE_OMIT_UTF16\\n-SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N){\\n+const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N){\\n   return columnName(\\n       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_DATABASE);\\n }\\n@@ -33217,12 +33254,12 @@ SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N\\n ** NULL is returned if the result column is an expression or constant or\\n ** anything else which is not an unabiguous reference to a database column.\\n */\\n-SQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N){\\n+const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N){\\n   return columnName(\\n       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_TABLE);\\n }\\n #ifndef SQLITE_OMIT_UTF16\\n-SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){\\n+const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){\\n   return columnName(\\n       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_TABLE);\\n }\\n@@ -33233,12 +33270,12 @@ SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){\\n ** NULL is returned if the result column is an expression or constant or\\n ** anything else which is not an unabiguous reference to a database column.\\n */\\n-SQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N){\\n+const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N){\\n   return columnName(\\n       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_COLUMN);\\n }\\n #ifndef SQLITE_OMIT_UTF16\\n-SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N){\\n+const void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N){\\n   return columnName(\\n       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_COLUMN);\\n }\\n@@ -33309,7 +33346,7 @@ static int bindText(\\n /*\\n ** Bind a blob value to an SQL statement variable.\\n */\\n-SQLITE_API int sqlite3_bind_blob(\\n+int sqlite3_bind_blob(\\n   sqlite3_stmt *pStmt, \\n   int i, \\n   const void *zData, \\n@@ -33318,7 +33355,7 @@ SQLITE_API int sqlite3_bind_blob(\\n ){\\n   return bindText(pStmt, i, zData, nData, xDel, 0);\\n }\\n-SQLITE_API int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){\\n+int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){\\n   int rc;\\n   Vdbe *p = (Vdbe *)pStmt;\\n   rc = vdbeUnbind(p, i);\\n@@ -33327,10 +33364,10 @@ SQLITE_API int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){\\n   }\\n   return rc;\\n }\\n-SQLITE_API int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){\\n+int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){\\n   return sqlite3_bind_int64(p, i, (i64)iValue);\\n }\\n-SQLITE_API int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){\\n+int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){\\n   int rc;\\n   Vdbe *p = (Vdbe *)pStmt;\\n   rc = vdbeUnbind(p, i);\\n@@ -33339,10 +33376,10 @@ SQLITE_API int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValu\\n   }\\n   return rc;\\n }\\n-SQLITE_API int sqlite3_bind_null(sqlite3_stmt* p, int i){\\n+int sqlite3_bind_null(sqlite3_stmt* p, int i){\\n   return vdbeUnbind((Vdbe *)p, i);\\n }\\n-SQLITE_API int sqlite3_bind_text( \\n+int sqlite3_bind_text( \\n   sqlite3_stmt *pStmt, \\n   int i, \\n   const char *zData, \\n@@ -33352,7 +33389,7 @@ SQLITE_API int sqlite3_bind_text(\\n   return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF8);\\n }\\n #ifndef SQLITE_OMIT_UTF16\\n-SQLITE_API int sqlite3_bind_text16(\\n+int sqlite3_bind_text16(\\n   sqlite3_stmt *pStmt, \\n   int i, \\n   const void *zData, \\n@@ -33362,7 +33399,7 @@ SQLITE_API int sqlite3_bind_text16(\\n   return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF16NATIVE);\\n }\\n #endif /* SQLITE_OMIT_UTF16 */\\n-SQLITE_API int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){\\n+int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){\\n   int rc;\\n   Vdbe *p = (Vdbe *)pStmt;\\n   rc = vdbeUnbind(p, i);\\n@@ -33371,7 +33408,7 @@ SQLITE_API int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_valu\\n   }\\n   return rc;\\n }\\n-SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){\\n+int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){\\n   int rc;\\n   Vdbe *p = (Vdbe *)pStmt;\\n   rc = vdbeUnbind(p, i);\\n@@ -33385,7 +33422,7 @@ SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){\\n ** Return the number of wildcards that can be potentially bound to.\\n ** This routine is added to support DBD::SQLite.  \\n */\\n-SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){\\n+int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){\\n   Vdbe *p = (Vdbe*)pStmt;\\n   return p ? p->nVar : 0;\\n }\\n@@ -33415,7 +33452,7 @@ static void createVarMap(Vdbe *p){\\n **\\n ** The result is always UTF-8.\\n */\\n-SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){\\n+const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){\\n   Vdbe *p = (Vdbe*)pStmt;\\n   if( p==0 || i<1 || i>p->nVar ){\\n     return 0;\\n@@ -33429,7 +33466,7 @@ SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){\\n ** with that name.  If there is no variable with the given name,\\n ** return 0.\\n */\\n-SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){\\n+int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){\\n   Vdbe *p = (Vdbe*)pStmt;\\n   int i;\\n   if( p==0 ){\\n@@ -33452,7 +33489,7 @@ SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zNa\\n ** If the two statements contain a different number of bindings, then\\n ** an SQLITE_ERROR is returned.\\n */\\n-SQLITE_API int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){\\n+int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){\\n   Vdbe *pFrom = (Vdbe*)pFromStmt;\\n   Vdbe *pTo = (Vdbe*)pToStmt;\\n   int i, rc = SQLITE_OK;\\n@@ -33478,7 +33515,7 @@ SQLITE_API int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *\\n ** the first argument to the sqlite3_prepare() that was used to create\\n ** the statement in the first place.\\n */\\n-SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){\\n+sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){\\n   return pStmt ? ((Vdbe*)pStmt)->db : 0;\\n }\\n \\n@@ -33529,7 +33566,7 @@ SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){\\n ** in this file for details.  If in doubt, do not deviate from existing\\n ** commenting and indentation practices when changing or adding code.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n /*\\n@@ -33540,7 +33577,7 @@ SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){\\n ** help verify the correct operation of the library.\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_search_count = 0;\\n+int sqlite3_search_count = 0;\\n #endif\\n \\n /*\\n@@ -33552,7 +33589,7 @@ SQLITE_API int sqlite3_search_count = 0;\\n ** in an ordinary build.\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_interrupt_count = 0;\\n+int sqlite3_interrupt_count = 0;\\n #endif\\n \\n /*\\n@@ -33563,7 +33600,7 @@ SQLITE_API int sqlite3_interrupt_count = 0;\\n ** library.\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_sort_count = 0;\\n+int sqlite3_sort_count = 0;\\n #endif\\n \\n /*\\n@@ -33574,7 +33611,7 @@ SQLITE_API int sqlite3_sort_count = 0;\\n ** help verify the correct operation of the library.\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_max_blobsize = 0;\\n+int sqlite3_max_blobsize = 0;\\n #endif\\n \\n /*\\n@@ -33765,7 +33802,7 @@ static void applyAffinity(Mem *pRec, char affinity, u8 enc){\\n **\\n ** This is an EXPERIMENTAL api and is subject to change or removal.\\n */\\n-SQLITE_API int sqlite3_value_numeric_type(sqlite3_value *pVal){\\n+int sqlite3_value_numeric_type(sqlite3_value *pVal){\\n   Mem *pMem = (Mem*)pVal;\\n   applyNumericAffinity(pMem);\\n   storeTypeInfo(pMem, 0);\\n@@ -34770,19 +34807,7 @@ case OP_Function: {\\n   if( sqlite3SafetyOff(db) ) goto abort_due_to_misuse;\\n   (*ctx.pFunc->xFunc)(&ctx, n, apVal);\\n   if( sqlite3SafetyOn(db) ) goto abort_due_to_misuse;\\n-  if( sqlite3MallocFailed() ){\\n-    /* Even though a malloc() has failed, the implementation of the\\n-    ** user function may have called an sqlite3_result_XXX() function\\n-    ** to return a value. The following call releases any resources\\n-    ** associated with such a value.\\n-    **\\n-    ** Note: Maybe MemRelease() should be called if sqlite3SafetyOn()\\n-    ** fails also (the if(...) statement above). But if people are\\n-    ** misusing sqlite, they have bigger problems than a leaked value.\\n-    */\\n-    sqlite3VdbeMemRelease(&ctx.s);\\n-    goto no_mem;\\n-  }\\n+  if( sqlite3MallocFailed() ) goto no_mem;\\n   popStack(&pTos, n);\\n \\n   /* If any auxilary data functions have been called by this user function,\\n@@ -37792,14 +37817,14 @@ case OP_IntegrityCk: {\\n     if( (pTos[-nRoot].flags & MEM_Int)==0 ) break;\\n   }\\n   assert( nRoot>0 );\\n-  aRoot = sqliteMallocRaw( sizeof(int)*(nRoot+1) );\\n+  aRoot = sqliteMallocRaw( sizeof(int*)*(nRoot+1) );\\n   if( aRoot==0 ) goto no_mem;\\n   j = pOp->p1;\\n   assert( j>=0 && j<p->nMem );\\n   pnErr = &p->aMem[j];\\n   assert( (pnErr->flags & MEM_Int)!=0 );\\n   for(j=0; j<nRoot; j++){\\n-    aRoot[j] = (pTos-j)->u.i;\\n+    aRoot[j] = pTos[-j].u.i;\\n   }\\n   aRoot[j] = 0;\\n   popStack(&pTos, nRoot);\\n@@ -38733,7 +38758,7 @@ abort_due_to_interrupt:\\n **\\n ** This file contains code used to implement incremental BLOB I/O.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n \\n@@ -38754,7 +38779,7 @@ struct Incrblob {\\n /*\\n ** Open a blob handle.\\n */\\n-SQLITE_API int sqlite3_blob_open(\\n+int sqlite3_blob_open(\\n   sqlite3* db,            /* The database connection */\\n   const char *zDb,        /* The attached database containing the blob */\\n   const char *zTable,     /* The table containing the blob */\\n@@ -38958,7 +38983,7 @@ blob_open_out:\\n ** Close a blob handle that was previously created using\\n ** sqlite3_blob_open().\\n */\\n-SQLITE_API int sqlite3_blob_close(sqlite3_blob *pBlob){\\n+int sqlite3_blob_close(sqlite3_blob *pBlob){\\n   Incrblob *p = (Incrblob *)pBlob;\\n   sqlite3_stmt *pStmt = p->pStmt;\\n   sqliteFree(p);\\n@@ -39007,21 +39032,21 @@ static int blobReadWrite(\\n /*\\n ** Read data from a blob handle.\\n */\\n-SQLITE_API int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){\\n+int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){\\n   return blobReadWrite(pBlob, z, n, iOffset, sqlite3BtreeData);\\n }\\n \\n /*\\n ** Write data to a blob handle.\\n */\\n-SQLITE_API int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){\\n+int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){\\n   return blobReadWrite(pBlob, (void *)z, n, iOffset, sqlite3BtreePutData);\\n }\\n \\n /*\\n ** Query a blob handle for the size of the data.\\n */\\n-SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *pBlob){\\n+int sqlite3_blob_bytes(sqlite3_blob *pBlob){\\n   Incrblob *p = (Incrblob *)pBlob;\\n   return p->nByte;\\n }\\n@@ -39044,7 +39069,7 @@ SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *pBlob){\\n ** This file contains routines used for analyzing expressions and\\n ** for generating VDBE code that evaluates expressions in SQLite.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n /*\\n@@ -39207,7 +39232,7 @@ static int binaryCompareP1(Expr *pExpr1, Expr *pExpr2, int jumpIfNull){\\n ** Argument pRight (but not pLeft) may be a null pointer. In this case,\\n ** it is not considered.\\n */\\n-SQLITE_PRIVATE CollSeq *sqlite3BinaryCompareCollSeq(\\n+CollSeq* sqlite3BinaryCompareCollSeq(\\n   Parse *pParse, \\n   Expr *pLeft, \\n   Expr *pRight\\n@@ -40170,17 +40195,11 @@ static int lookupName(\\n       for(j=0; j<pEList->nExpr; j++){\\n         char *zAs = pEList->a[j].zName;\\n         if( zAs!=0 && sqlite3StrICmp(zAs, zCol)==0 ){\\n-          Expr *pDup, *pOrig;\\n+          Expr *pDup;\\n           assert( pExpr->pLeft==0 && pExpr->pRight==0 );\\n           assert( pExpr->pList==0 );\\n           assert( pExpr->pSelect==0 );\\n-          pOrig = pEList->a[j].pExpr;\\n-          if( !pNC->allowAgg && ExprHasProperty(pOrig, EP_Agg) ){\\n-            sqlite3ErrorMsg(pParse, \\\"misuse of aliased aggregate %s\\\", zAs);\\n-            sqliteFree(zCol);\\n-            return 2;\\n-          }\\n-          pDup = sqlite3ExprDup(pOrig);\\n+          pDup = sqlite3ExprDup(pEList->a[j].pExpr);\\n           if( pExpr->flags & EP_ExpCollate ){\\n             pDup->pColl = pExpr->pColl;\\n             pDup->flags |= EP_ExpCollate;\\n@@ -40608,7 +40627,7 @@ SQLITE_PRIVATE void sqlite3CodeSubselect(Parse *pParse, Expr *pExpr){\\n       }else if( pExpr->pList ){\\n         /* Case 2:     expr IN (exprlist)\\n         **\\n-        ** For each expression, build an index key from the evaluation and\\n+\\t** For each expression, build an index key from the evaluation and\\n         ** store it in the temporary table. If <expr> is a column, then use\\n         ** that columns affinity when building index keys. If <expr> is not\\n         ** a column, use numeric affinity.\\n@@ -41088,7 +41107,7 @@ SQLITE_PRIVATE void sqlite3ExprCode(Parse *pParse, Expr *pExpr){\\n       if( !pParse->trigStack ){\\n         sqlite3ErrorMsg(pParse,\\n                        \\\"RAISE() may only be used within a trigger-program\\\");\\n-        return;\\n+\\treturn;\\n       }\\n       if( pExpr->iColumn!=OE_Ignore ){\\n          assert( pExpr->iColumn==OE_Rollback ||\\n@@ -41632,7 +41651,7 @@ SQLITE_PRIVATE int sqlite3ExprAnalyzeAggList(NameContext *pNC, ExprList *pList){\\n ** This file contains C code routines that used to generate VDBE code\\n ** that implements the ALTER TABLE command.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n /*\\n@@ -42241,7 +42260,7 @@ exit_begin_add_column:\\n *************************************************************************\\n ** This file contains code associated with the ANALYZE command.\\n **\\n-** @(#) $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** @(#) $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n #ifndef SQLITE_OMIT_ANALYZE\\n \\n@@ -42653,7 +42672,7 @@ SQLITE_PRIVATE int sqlite3AnalysisLoad(sqlite3 *db, int iDb){\\n *************************************************************************\\n ** This file contains code used to implement the ATTACH and DETACH commands.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n #ifndef SQLITE_OMIT_ATTACH\\n@@ -43174,7 +43193,7 @@ SQLITE_PRIVATE int sqlite3FixTriggerStep(\\n ** systems that do not need this facility may omit it by recompiling\\n ** the library with -DSQLITE_OMIT_AUTHORIZATION=1\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n /*\\n@@ -43228,7 +43247,7 @@ SQLITE_PRIVATE int sqlite3FixTriggerStep(\\n ** Setting the auth function to NULL disables this hook.  The default\\n ** setting of the auth function is NULL.\\n */\\n-SQLITE_API int sqlite3_set_authorizer(\\n+int sqlite3_set_authorizer(\\n   sqlite3 *db,\\n   int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),\\n   void *pArg\\n@@ -43417,7 +43436,7 @@ SQLITE_PRIVATE void sqlite3AuthContextPop(AuthContext *pContext){\\n **     COMMIT\\n **     ROLLBACK\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n /*\\n@@ -46770,7 +46789,7 @@ SQLITE_PRIVATE KeyInfo *sqlite3IndexKeyinfo(Parse *pParse, Index *pIdx){\\n ** This file contains functions used to access the internal hash tables\\n ** of user defined functions and collation sequences.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n \\n@@ -47149,14 +47168,14 @@ SQLITE_PRIVATE Schema *sqlite3SchemaGet(Btree *pBt){\\n ** separating it out, the code will be automatically omitted from\\n ** static links that do not use it.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n #ifndef SQLITE_OMIT_COMPLETE\\n \\n /*\\n ** This is defined in tokenize.c.  We just have to import the definition.\\n */\\n-SQLITE_PRIVATE const char sqlite3IsIdChar[];\\n+extern const char sqlite3IsIdChar[];\\n #define IdChar(C)  (((c=C)&0x80)!=0 || (c>0x1f && sqlite3IsIdChar[c-0x20]))\\n \\n \\n@@ -47410,7 +47429,7 @@ SQLITE_API int sqlite3_complete16(const void *zSql){\\n ** This file contains C code routines that are called by the parser\\n ** in order to generate code for DELETE FROM statements.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n /*\\n@@ -47883,11 +47902,10 @@ SQLITE_PRIVATE void sqlite3GenerateIndexKey(\\n ** sqliteRegisterBuildinFunctions() found at the bottom of the file.\\n ** All other code has file scope.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n /* #include <math.h> */\\n \\n-\\n /*\\n ** Return the collating function associated with a function.\\n */\\n@@ -48260,6 +48278,15 @@ static const struct compareInfo likeInfoNorm = { '%', '_',   0, 1 };\\n static const struct compareInfo likeInfoAlt = { '%', '_',   0, 0 };\\n \\n /*\\n+** Read a single UTF-8 character and return its value.\\n+*/\\n+SQLITE_PRIVATE u32 sqlite3ReadUtf8(const unsigned char *z){\\n+  u32 c;\\n+  SQLITE_READ_UTF8(z, c);\\n+  return c;\\n+}\\n+\\n+/*\\n ** Compare two UTF-8 strings for equality where the first string can\\n ** potentially be a \\\"glob\\\" expression.  Return true (1) if they\\n ** are the same and false (0) if they are different.\\n@@ -48293,102 +48320,97 @@ static int patternCompare(\\n   const struct compareInfo *pInfo, /* Information about how to do the compare */\\n   const int esc                    /* The escape character */\\n ){\\n-  int c, c2;\\n+  register int c;\\n   int invert;\\n   int seen;\\n+  int c2;\\n   u8 matchOne = pInfo->matchOne;\\n   u8 matchAll = pInfo->matchAll;\\n   u8 matchSet = pInfo->matchSet;\\n   u8 noCase = pInfo->noCase; \\n   int prevEscape = 0;     /* True if the previous character was 'escape' */\\n \\n-  while( (c = sqlite3Utf8Read(zPattern,0,&zPattern))!=0 ){\\n+  while( (c = *zPattern)!=0 ){\\n     if( !prevEscape && c==matchAll ){\\n-      while( (c=sqlite3Utf8Read(zPattern,0,&zPattern)) == matchAll\\n-               || c == matchOne ){\\n-        if( c==matchOne && sqlite3Utf8Read(zString, 0, &zString)==0 ){\\n-          return 0;\\n+      while( (c=zPattern[1]) == matchAll || c == matchOne ){\\n+        if( c==matchOne ){\\n+          if( *zString==0 ) return 0;\\n+          SQLITE_SKIP_UTF8(zString);\\n         }\\n+        zPattern++;\\n       }\\n-      if( c==0 ){\\n-        return 1;\\n-      }else if( c==esc ){\\n-        c = sqlite3Utf8Read(zPattern, 0, &zPattern);\\n-        if( c==0 ){\\n-          return 0;\\n-        }\\n-      }else if( c==matchSet ){\\n-        assert( esc==0 );         /* This is GLOB, not LIKE */\\n-        assert( matchSet<0x80 );  /* '[' is a single-byte character */\\n-        while( *zString && patternCompare(&zPattern[-1],zString,pInfo,esc)==0 ){\\n+      if( c && esc && sqlite3ReadUtf8(&zPattern[1])==esc ){\\n+        u8 const *zTemp = &zPattern[1];\\n+        SQLITE_SKIP_UTF8(zTemp);\\n+        c = *zTemp;\\n+      }\\n+      if( c==0 ) return 1;\\n+      if( c==matchSet ){\\n+        assert( esc==0 );   /* This is GLOB, not LIKE */\\n+        while( *zString && patternCompare(&zPattern[1],zString,pInfo,esc)==0 ){\\n           SQLITE_SKIP_UTF8(zString);\\n         }\\n         return *zString!=0;\\n-      }\\n-      while( (c2 = sqlite3Utf8Read(zString,0,&zString))!=0 ){\\n-        if( noCase ){\\n-          c2 = c2<0x80 ? sqlite3UpperToLower[c2] : c2;\\n-          c = c<0x80 ? sqlite3UpperToLower[c] : c;\\n-          while( c2 != 0 && c2 != c ){\\n-            c2 = sqlite3Utf8Read(zString, 0, &zString);\\n-            if( c2<0x80 ) c2 = sqlite3UpperToLower[c2];\\n-          }\\n-        }else{\\n-          while( c2 != 0 && c2 != c ){\\n-            c2 = sqlite3Utf8Read(zString, 0, &zString);\\n+      }else{\\n+        while( (c2 = *zString)!=0 ){\\n+          if( noCase ){\\n+            c2 = sqlite3UpperToLower[c2];\\n+            c = sqlite3UpperToLower[c];\\n+            while( c2 != 0 && c2 != c ){ c2 = sqlite3UpperToLower[*++zString]; }\\n+          }else{\\n+            while( c2 != 0 && c2 != c ){ c2 = *++zString; }\\n           }\\n+          if( c2==0 ) return 0;\\n+          if( patternCompare(&zPattern[1],zString,pInfo,esc) ) return 1;\\n+          SQLITE_SKIP_UTF8(zString);\\n         }\\n-        if( c2==0 ) return 0;\\n-        if( patternCompare(zPattern,zString,pInfo,esc) ) return 1;\\n-      }\\n-      return 0;\\n-    }else if( !prevEscape && c==matchOne ){\\n-      if( sqlite3Utf8Read(zString, 0, &zString)==0 ){\\n         return 0;\\n       }\\n+    }else if( !prevEscape && c==matchOne ){\\n+      if( *zString==0 ) return 0;\\n+      SQLITE_SKIP_UTF8(zString);\\n+      zPattern++;\\n     }else if( c==matchSet ){\\n       int prior_c = 0;\\n       assert( esc==0 );    /* This only occurs for GLOB, not LIKE */\\n       seen = 0;\\n       invert = 0;\\n-      c = sqlite3Utf8Read(zString, 0, &zString);\\n+      c = sqlite3ReadUtf8(zString);\\n       if( c==0 ) return 0;\\n-      c2 = sqlite3Utf8Read(zPattern, 0, &zPattern);\\n-      if( c2=='^' ){\\n-        invert = 1;\\n-        c2 = sqlite3Utf8Read(zPattern, 0, &zPattern);\\n-      }\\n+      c2 = *++zPattern;\\n+      if( c2=='^' ){ invert = 1; c2 = *++zPattern; }\\n       if( c2==']' ){\\n         if( c==']' ) seen = 1;\\n-        c2 = sqlite3Utf8Read(zPattern, 0, &zPattern);\\n+        c2 = *++zPattern;\\n       }\\n-      while( c2 && c2!=']' ){\\n-        if( c2=='-' && zPattern[0]!=']' && zPattern[0]!=0 && prior_c>0 ){\\n-          c2 = sqlite3Utf8Read(zPattern, 0, &zPattern);\\n+      while( (c2 = sqlite3ReadUtf8(zPattern))!=0 && c2!=']' ){\\n+        if( c2=='-' && zPattern[1]!=']' && zPattern[1]!=0 && prior_c>0 ){\\n+          zPattern++;\\n+          c2 = sqlite3ReadUtf8(zPattern);\\n           if( c>=prior_c && c<=c2 ) seen = 1;\\n           prior_c = 0;\\n+        }else if( c==c2 ){\\n+          seen = 1;\\n+          prior_c = c2;\\n         }else{\\n-          if( c==c2 ){\\n-            seen = 1;\\n-          }\\n           prior_c = c2;\\n         }\\n-        c2 = sqlite3Utf8Read(zPattern, 0, &zPattern);\\n-      }\\n-      if( c2==0 || (seen ^ invert)==0 ){\\n-        return 0;\\n+        SQLITE_SKIP_UTF8(zPattern);\\n       }\\n-    }else if( esc==c && !prevEscape ){\\n+      if( c2==0 || (seen ^ invert)==0 ) return 0;\\n+      SQLITE_SKIP_UTF8(zString);\\n+      zPattern++;\\n+    }else if( esc && !prevEscape && sqlite3ReadUtf8(zPattern)==esc){\\n       prevEscape = 1;\\n+      SQLITE_SKIP_UTF8(zPattern);\\n     }else{\\n-      c2 = sqlite3Utf8Read(zString, 0, &zString);\\n       if( noCase ){\\n-        c = c<0x80 ? sqlite3UpperToLower[c] : c;\\n-        c2 = c2<0x80 ? sqlite3UpperToLower[c2] : c2;\\n-      }\\n-      if( c!=c2 ){\\n-        return 0;\\n+        if( sqlite3UpperToLower[c] != sqlite3UpperToLower[*zString] ) return 0;\\n+      }else{\\n+        if( c != *zString ) return 0;\\n       }\\n+      zPattern++;\\n+      zString++;\\n       prevEscape = 0;\\n     }\\n   }\\n@@ -48401,7 +48423,7 @@ static int patternCompare(\\n ** only.\\n */\\n #ifdef SQLITE_TEST\\n-SQLITE_API int sqlite3_like_count = 0;\\n+int sqlite3_like_count = 0;\\n #endif\\n \\n \\n@@ -48448,7 +48470,7 @@ static void likeFunc(\\n           \\\"ESCAPE expression must be a single character\\\", -1);\\n       return;\\n     }\\n-    escape = sqlite3Utf8Read(zEsc, 0, &zEsc);\\n+    escape = sqlite3ReadUtf8(zEsc);\\n   }\\n   if( zA && zB ){\\n     struct compareInfo *pInfo = sqlite3_user_data(context);\\n@@ -48979,7 +49001,6 @@ static void test_auxdata(\\n       if( zAux ){\\n         zRet[i*2] = '1';\\n         if( strcmp(zAux, z) ){\\n-          free_test_auxdata((void *)zRet);\\n           sqlite3_result_error(pCtx, \\\"Auxilary data corruption\\\", -1);\\n           return;\\n         }\\n@@ -49367,7 +49388,7 @@ SQLITE_PRIVATE int sqlite3IsLikeFunction(sqlite3 *db, Expr *pExpr, int *pIsNocas\\n ** This file contains C code routines that are called by the parser\\n ** to handle INSERT statements in SQLite.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n /*\\n@@ -50381,7 +50402,7 @@ SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(\\n     assert( pParse->ckOffset==nCol );\\n     pParse->ckOffset = 0;\\n     onError = overrideError!=OE_Default ? overrideError : OE_Abort;\\n-    if( onError==OE_Ignore ){\\n+    if( onError==OE_Ignore || onError==OE_Replace ){\\n       sqlite3VdbeAddOp(v, OP_Pop, nCol+1+hasTwoRowids, 0);\\n       sqlite3VdbeAddOp(v, OP_Goto, 0, ignoreDest);\\n     }else{\\n@@ -50645,7 +50666,7 @@ SQLITE_PRIVATE void sqlite3OpenTableAndIndices(\\n ** purposes only - to make sure the transfer optimization really\\n ** is happening when it is suppose to.\\n */\\n-SQLITE_API int sqlite3_xferopt_count;\\n+int sqlite3_xferopt_count;\\n #endif /* SQLITE_TEST */\\n \\n \\n@@ -50975,7 +50996,7 @@ static int xferOptimization(\\n ** other files are for internal use by SQLite and should not be\\n ** accessed by users of the library.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n \\n@@ -51127,7 +51148,7 @@ exec_out:\\n ** as extensions by SQLite should #include this file instead of \\n ** sqlite3.h.\\n **\\n-** @(#) $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** @(#) $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n #ifndef _SQLITE3EXT_H_\\n #define _SQLITE3EXT_H_\\n@@ -51499,7 +51520,7 @@ struct sqlite3_api_routines {\\n ** also check to make sure that the pointer to the function is\\n ** not NULL before calling it.\\n */\\n-SQLITE_API const sqlite3_api_routines sqlite3_apis = {\\n+const sqlite3_api_routines sqlite3_apis = {\\n   sqlite3_aggregate_context,\\n   sqlite3_aggregate_count,\\n   sqlite3_bind_blob,\\n@@ -51651,7 +51672,7 @@ SQLITE_API const sqlite3_api_routines sqlite3_apis = {\\n ** error message text.  The calling function should free this memory\\n ** by calling sqlite3_free().\\n */\\n-SQLITE_API int sqlite3_load_extension(\\n+int sqlite3_load_extension(\\n   sqlite3 *db,          /* Load the extension into this database connection */\\n   const char *zFile,    /* Name of the shared library containing extension */\\n   const char *zProc,    /* Entry point.  Use \\\"sqlite3_extension_init\\\" if 0 */\\n@@ -51736,7 +51757,7 @@ SQLITE_PRIVATE void sqlite3CloseExtensions(sqlite3 *db){\\n ** Enable or disable extension loading.  Extension loading is disabled by\\n ** default so as not to open security holes in older applications.\\n */\\n-SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff){\\n+int sqlite3_enable_load_extension(sqlite3 *db, int onoff){\\n   if( onoff ){\\n     db->flags |= SQLITE_LoadExtension;\\n   }else{\\n@@ -51759,7 +51780,7 @@ static void **aAutoExtension = 0;\\n ** Register a statically linked extension that is automatically\\n ** loaded by every new database connection.\\n */\\n-SQLITE_API int sqlite3_auto_extension(void *xInit){\\n+int sqlite3_auto_extension(void *xInit){\\n   int i;\\n   int rc = SQLITE_OK;\\n   sqlite3OsEnterMutex();\\n@@ -51785,7 +51806,7 @@ SQLITE_API int sqlite3_auto_extension(void *xInit){\\n /*\\n ** Reset the automatic extension loading mechanism.\\n */\\n-SQLITE_API void sqlite3_reset_auto_extension(void){\\n+void sqlite3_reset_auto_extension(void){\\n   sqlite3OsEnterMutex();\\n   sqliteFree(aAutoExtension);\\n   aAutoExtension = 0;\\n@@ -51844,7 +51865,7 @@ SQLITE_PRIVATE int sqlite3AutoLoadExtensions(sqlite3 *db){\\n *************************************************************************\\n ** This file contains code used to implement the PRAGMA command.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n /* Ignore this whole file if pragmas are disabled\\n@@ -53024,7 +53045,7 @@ pragma_out:\\n ** interface, and routines that contribute to loading the database schema\\n ** from disk.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n /*\\n@@ -53345,7 +53366,7 @@ static int sqlite3InitOne(sqlite3 *db, int iDb, char **pzErrMsg){\\n */\\n SQLITE_PRIVATE int sqlite3Init(sqlite3 *db, char **pzErrMsg){\\n   int i, rc;\\n-  int commit_internal = !(db->flags&SQLITE_InternChanges);\\n+  int called_initone = 0;\\n   \\n   if( db->init.busy ) return SQLITE_OK;\\n   rc = SQLITE_OK;\\n@@ -53356,6 +53377,7 @@ SQLITE_PRIVATE int sqlite3Init(sqlite3 *db, char **pzErrMsg){\\n     if( rc ){\\n       sqlite3ResetInternalSchema(db, i);\\n     }\\n+    called_initone = 1;\\n   }\\n \\n   /* Once all the other databases have been initialised, load the schema\\n@@ -53368,11 +53390,12 @@ SQLITE_PRIVATE int sqlite3Init(sqlite3 *db, char **pzErrMsg){\\n     if( rc ){\\n       sqlite3ResetInternalSchema(db, 1);\\n     }\\n+    called_initone = 1;\\n   }\\n #endif\\n \\n   db->init.busy = 0;\\n-  if( rc==SQLITE_OK && commit_internal ){\\n+  if( rc==SQLITE_OK && called_initone ){\\n     sqlite3CommitInternalChanges(db);\\n   }\\n \\n@@ -53621,7 +53644,7 @@ SQLITE_API int sqlite3_prepare(\\n ){\\n   return sqlite3Prepare(db,zSql,nBytes,0,ppStmt,pzTail);\\n }\\n-SQLITE_API int sqlite3_prepare_v2(\\n+int sqlite3_prepare_v2(\\n   sqlite3 *db,              /* Database handle. */\\n   const char *zSql,         /* UTF-8 encoded SQL statement. */\\n   int nBytes,               /* Length of zSql in bytes. */\\n@@ -53690,7 +53713,7 @@ SQLITE_API int sqlite3_prepare16(\\n ){\\n   return sqlite3Prepare16(db,zSql,nBytes,0,ppStmt,pzTail);\\n }\\n-SQLITE_API int sqlite3_prepare16_v2(\\n+int sqlite3_prepare16_v2(\\n   sqlite3 *db,              /* Database handle. */ \\n   const void *zSql,         /* UTF-8 encoded SQL statement. */\\n   int nBytes,               /* Length of zSql in bytes. */\\n@@ -53718,7 +53741,7 @@ SQLITE_API int sqlite3_prepare16_v2(\\n ** This file contains C code routines that are called by the parser\\n ** to handle SELECT statements in SQLite.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n \\n@@ -57328,7 +57351,7 @@ malloc_failed:\\n ** Instead, the entire table should be passed to sqlite3_free_table() when\\n ** the calling procedure is finished using it.\\n */\\n-SQLITE_API int sqlite3_get_table(\\n+int sqlite3_get_table(\\n   sqlite3 *db,                /* The database on which the SQL executes */\\n   const char *zSql,           /* The SQL to be executed */\\n   char ***pazResult,          /* Write the result table here */\\n@@ -57393,7 +57416,7 @@ SQLITE_API int sqlite3_get_table(\\n /*\\n ** This routine frees the space the sqlite3_get_table() malloced.\\n */\\n-SQLITE_API void sqlite3_free_table(\\n+void sqlite3_free_table(\\n   char **azResult            /* Result returned from from sqlite3_get_table() */\\n ){\\n   if( azResult ){\\n@@ -58084,21 +58107,21 @@ static int codeTriggerProgram(\\n     pParse->trigStack->orconf = orconf;\\n     switch( pTriggerStep->op ){\\n       case TK_SELECT: {\\n-        Select *ss = sqlite3SelectDup(pTriggerStep->pSelect);\\n+\\tSelect *ss = sqlite3SelectDup(pTriggerStep->pSelect);\\n         if( ss ){\\n           sqlite3SelectResolve(pParse, ss, 0);\\n           sqlite3Select(pParse, ss, SRT_Discard, 0, 0, 0, 0, 0);\\n           sqlite3SelectDelete(ss);\\n         }\\n-        break;\\n+\\tbreak;\\n       }\\n       case TK_UPDATE: {\\n         SrcList *pSrc;\\n         pSrc = targetSrcList(pParse, pTriggerStep);\\n         sqlite3VdbeAddOp(v, OP_ResetCount, 0, 0);\\n         sqlite3Update(pParse, pSrc,\\n-                sqlite3ExprListDup(pTriggerStep->pExprList), \\n-                sqlite3ExprDup(pTriggerStep->pWhere), orconf);\\n+\\t\\tsqlite3ExprListDup(pTriggerStep->pExprList), \\n+\\t\\tsqlite3ExprDup(pTriggerStep->pWhere), orconf);\\n         sqlite3VdbeAddOp(v, OP_ResetCount, 1, 0);\\n         break;\\n       }\\n@@ -58254,7 +58277,7 @@ SQLITE_PRIVATE int sqlite3CodeRowTrigger(\\n ** This file contains C code routines that are called by the parser\\n ** to handle UPDATE statements.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n #ifndef SQLITE_OMIT_VIRTUALTABLE\\n@@ -58885,7 +58908,7 @@ static void updateVirtualTable(\\n ** Most of the code in this file may be omitted by defining the\\n ** SQLITE_OMIT_VACUUM macro.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n #if !defined(SQLITE_OMIT_VACUUM) && !defined(SQLITE_OMIT_ATTACH)\\n@@ -59144,7 +59167,7 @@ end_of_vacuum:\\n *************************************************************************\\n ** This file contains code used to help implement virtual tables.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n #ifndef SQLITE_OMIT_VIRTUALTABLE\\n \\n@@ -59178,7 +59201,7 @@ static int createModule(\\n /*\\n ** External API function used to create a new virtual-table module.\\n */\\n-SQLITE_API int sqlite3_create_module(\\n+int sqlite3_create_module(\\n   sqlite3 *db,                    /* Database in which module is registered */\\n   const char *zName,              /* Name assigned to this module */\\n   const sqlite3_module *pModule,  /* The definition of the module */\\n@@ -59190,7 +59213,7 @@ SQLITE_API int sqlite3_create_module(\\n /*\\n ** External API function used to create a new virtual-table module.\\n */\\n-SQLITE_API int sqlite3_create_module_v2(\\n+int sqlite3_create_module_v2(\\n   sqlite3 *db,                    /* Database in which module is registered */\\n   const char *zName,              /* Name assigned to this module */\\n   const sqlite3_module *pModule,  /* The definition of the module */\\n@@ -59648,7 +59671,7 @@ SQLITE_PRIVATE int sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab,\\n ** valid to call this function from within the xCreate() or xConnect() of a\\n ** virtual table module.\\n */\\n-SQLITE_API int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){\\n+int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){\\n   Parse sParse;\\n \\n   int rc = SQLITE_OK;\\n@@ -59932,7 +59955,7 @@ SQLITE_PRIVATE FuncDef *sqlite3VtabOverloadFunction(\\n ** so is applicable.  Because this module is responsible for selecting\\n ** indices, you might also think of this module as the \\\"query optimizer\\\".\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n /*\\n@@ -59944,7 +59967,7 @@ SQLITE_PRIVATE FuncDef *sqlite3VtabOverloadFunction(\\n ** Trace output macros\\n */\\n #if defined(SQLITE_TEST) || defined(SQLITE_DEBUG)\\n-SQLITE_API int sqlite3_where_trace = 0;\\n+int sqlite3_where_trace = 0;\\n # define WHERETRACE(X)  if(sqlite3_where_trace) sqlite3DebugPrintf X\\n #else\\n # define WHERETRACE(X)\\n@@ -60298,22 +60321,10 @@ static int allowedOp(int op){\\n /*\\n ** Commute a comparision operator.  Expressions of the form \\\"X op Y\\\"\\n ** are converted into \\\"Y op X\\\".\\n-**\\n-** If a collation sequence is associated with either the left or right\\n-** side of the comparison, it remains associated with the same side after\\n-** the commutation. So \\\"Y collate NOCASE op X\\\" becomes \\n-** \\\"X collate NOCASE op Y\\\". This is because any collation sequence on\\n-** the left hand side of a comparison overrides any collation sequence \\n-** attached to the right. For the same reason the EP_ExpCollate flag\\n-** is not commuted.\\n */\\n static void exprCommute(Expr *pExpr){\\n-  u16 expRight = (pExpr->pRight->flags & EP_ExpCollate);\\n-  u16 expLeft = (pExpr->pLeft->flags & EP_ExpCollate);\\n   assert( allowedOp(pExpr->op) && pExpr->op!=TK_IN );\\n   SWAP(CollSeq*,pExpr->pRight->pColl,pExpr->pLeft->pColl);\\n-  pExpr->pRight->flags = (pExpr->pRight->flags & ~EP_ExpCollate) | expLeft;\\n-  pExpr->pLeft->flags = (pExpr->pLeft->flags & ~EP_ExpCollate) | expRight;\\n   SWAP(Expr*,pExpr->pRight,pExpr->pLeft);\\n   if( pExpr->op>=TK_GT ){\\n     assert( TK_LT==TK_GT+2 );\\n@@ -61748,7 +61759,7 @@ static void codeAllEqualityTerms(\\n ** overwrites the previous.  This information is used for testing and\\n ** analysis only.\\n */\\n-SQLITE_API char sqlite3_query_plan[BMS*2*40];  /* Text of the join */\\n+char sqlite3_query_plan[BMS*2*40];  /* Text of the join */\\n static int nQPlan = 0;              /* Next free slow in _query_plan[] */\\n \\n #endif /* SQLITE_TEST */\\n@@ -65808,7 +65819,7 @@ SQLITE_PRIVATE void sqlite3Parser(\\n ** individual tokens and sends those tokens one-by-one over to the\\n ** parser for analysis.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n /*\\n@@ -65861,7 +65872,7 @@ const unsigned char ebcdicToAscii[] = {\\n **\\n ** The code in this file has been automatically generated by\\n **\\n-**     $Header: /cvsroot/mozilla/db/sqlite3/src/sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+**     $Header: /cvsroot/mozilla/db/sqlite3/src/sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n **\\n ** The code in this file implements a function that determines whether\\n ** or not a given identifier is really an SQL keyword.  The same thing\\n@@ -65991,7 +66002,7 @@ SQLITE_PRIVATE int sqlite3KeywordCode(const unsigned char *z, int n){\\n ** But the feature is undocumented.\\n */\\n #ifdef SQLITE_ASCII\\n-SQLITE_PRIVATE const char sqlite3IsIdChar[] = {\\n+const char sqlite3IsIdChar[] = {\\n /* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */\\n     0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 2x */\\n     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  /* 3x */\\n@@ -66003,7 +66014,7 @@ SQLITE_PRIVATE const char sqlite3IsIdChar[] = {\\n #define IdChar(C)  (((c=C)&0x80)!=0 || (c>0x1f && sqlite3IsIdChar[c-0x20]))\\n #endif\\n #ifdef SQLITE_EBCDIC\\n-SQLITE_PRIVATE const char sqlite3IsIdChar[] = {\\n+const char sqlite3IsIdChar[] = {\\n /* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */\\n     0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  /* 4x */\\n     0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0,  /* 5x */\\n@@ -66286,6 +66297,13 @@ SQLITE_PRIVATE int sqlite3GetToken(const unsigned char *z, int *tokenType){\\n }\\n \\n /*\\n+** The interface to the LEMON-generated parser\\n+*/\\n+SQLITE_PRIVATE void *sqlite3ParserAlloc(void*(*)(size_t));\\n+SQLITE_PRIVATE void sqlite3ParserFree(void*, void(*)(void*));\\n+SQLITE_PRIVATE void sqlite3Parser(void*, int, Token, Parse*);\\n+\\n+/*\\n ** Run the parser on the given SQL string.  The parser structure is\\n ** passed in.  An SQLITE_ status code is returned.  If an error occurs\\n ** and pzErrMsg!=NULL then an error message might be written into \\n@@ -66430,15 +66448,15 @@ abort_parse:\\n ** other files are for internal use by SQLite and should not be\\n ** accessed by users of the library.\\n **\\n-** $Id: sqlite3.c,v 1.7 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** $Id: sqlite3.c,v 1.8 2007/09/14 21:07:51 dmose%mozilla.org Exp $\\n */\\n \\n /*\\n ** The version of the library\\n */\\n-SQLITE_API const char sqlite3_version[] = SQLITE_VERSION;\\n+const char sqlite3_version[] = SQLITE_VERSION;\\n SQLITE_API const char *sqlite3_libversion(void){ return sqlite3_version; }\\n-SQLITE_API int sqlite3_libversion_number(void){ return SQLITE_VERSION_NUMBER; }\\n+int sqlite3_libversion_number(void){ return SQLITE_VERSION_NUMBER; }\\n \\n /*\\n ** If the following function pointer is not NULL and if\\n@@ -66446,7 +66464,7 @@ SQLITE_API int sqlite3_libversion_number(void){ return SQLITE_VERSION_NUMBER; }\\n ** I/O active are written using this function.  These messages\\n ** are intended for debugging activity only.\\n */\\n-SQLITE_API void (*sqlite3_io_trace)(const char*, ...) = 0;\\n+void (*sqlite3_io_trace)(const char*, ...) = 0;\\n \\n /*\\n ** If the following global variable points to a string which is the\\n@@ -66455,7 +66473,7 @@ SQLITE_API void (*sqlite3_io_trace)(const char*, ...) = 0;\\n **\\n ** See also the \\\"PRAGMA temp_store_directory\\\" SQL command.\\n */\\n-SQLITE_API char *sqlite3_temp_directory = 0;\\n+char *sqlite3_temp_directory = 0;\\n \\n \\n /*\\n@@ -66501,7 +66519,7 @@ static int nocaseCollatingFunc(\\n /*\\n ** Return the ROWID of the most recent insert\\n */\\n-SQLITE_API sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db){\\n+sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db){\\n   return db->lastRowid;\\n }\\n \\n@@ -66515,7 +66533,7 @@ SQLITE_API int sqlite3_changes(sqlite3 *db){\\n /*\\n ** Return the number of changes since the database handle was opened.\\n */\\n-SQLITE_API int sqlite3_total_changes(sqlite3 *db){\\n+int sqlite3_total_changes(sqlite3 *db){\\n   return db->nTotalChange;\\n }\\n \\n@@ -66653,7 +66671,6 @@ SQLITE_PRIVATE void sqlite3RollbackAll(sqlite3 *db){\\n   }\\n   sqlite3VtabRollback(db);\\n   if( db->flags&SQLITE_InternChanges ){\\n-    sqlite3ExpirePreparedStatements(db);\\n     sqlite3ResetInternalSchema(db, 0);\\n   }\\n \\n@@ -66767,7 +66784,7 @@ SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler *p){\\n ** This routine sets the busy callback for an Sqlite database to the\\n ** given callback function with the given argument.\\n */\\n-SQLITE_API int sqlite3_busy_handler(\\n+int sqlite3_busy_handler(\\n   sqlite3 *db,\\n   int (*xBusy)(void*,int),\\n   void *pArg\\n@@ -66787,7 +66804,7 @@ SQLITE_API int sqlite3_busy_handler(\\n ** given callback function with the given argument. The progress callback will\\n ** be invoked every nOps opcodes.\\n */\\n-SQLITE_API void sqlite3_progress_handler(\\n+void sqlite3_progress_handler(\\n   sqlite3 *db, \\n   int nOps,\\n   int (*xProgress)(void*), \\n@@ -66812,7 +66829,7 @@ SQLITE_API void sqlite3_progress_handler(\\n ** This routine installs a default busy handler that waits for the\\n ** specified number of milliseconds before returning 0.\\n */\\n-SQLITE_API int sqlite3_busy_timeout(sqlite3 *db, int ms){\\n+int sqlite3_busy_timeout(sqlite3 *db, int ms){\\n   if( sqlite3SafetyCheck(db) ){\\n     return SQLITE_MISUSE;\\n   }\\n@@ -66947,7 +66964,7 @@ SQLITE_PRIVATE int sqlite3CreateFunc(\\n /*\\n ** Create new user functions.\\n */\\n-SQLITE_API int sqlite3_create_function(\\n+int sqlite3_create_function(\\n   sqlite3 *db,\\n   const char *zFunctionName,\\n   int nArg,\\n@@ -66965,7 +66982,7 @@ SQLITE_API int sqlite3_create_function(\\n }\\n \\n #ifndef SQLITE_OMIT_UTF16\\n-SQLITE_API int sqlite3_create_function16(\\n+int sqlite3_create_function16(\\n   sqlite3 *db,\\n   const void *zFunctionName,\\n   int nArg,\\n@@ -67000,7 +67017,7 @@ SQLITE_API int sqlite3_create_function16(\\n ** A global function must exist in order for name resolution to work\\n ** properly.\\n */\\n-SQLITE_API int sqlite3_overload_function(\\n+int sqlite3_overload_function(\\n   sqlite3 *db,\\n   const char *zName,\\n   int nArg\\n@@ -67054,7 +67071,7 @@ SQLITE_API void *sqlite3_profile(\\n ** If the invoked function returns non-zero, then the commit becomes a\\n ** rollback.\\n */\\n-SQLITE_API void *sqlite3_commit_hook(\\n+void *sqlite3_commit_hook(\\n   sqlite3 *db,              /* Attach the hook to this database */\\n   int (*xCallback)(void*),  /* Function to invoke on each commit */\\n   void *pArg                /* Argument to the function */\\n@@ -67069,7 +67086,7 @@ SQLITE_API void *sqlite3_commit_hook(\\n ** Register a callback to be invoked each time a row is updated,\\n ** inserted or deleted using this database connection.\\n */\\n-SQLITE_API void *sqlite3_update_hook(\\n+void *sqlite3_update_hook(\\n   sqlite3 *db,              /* Attach the hook to this database */\\n   void (*xCallback)(void*,int,char const *,char const *,sqlite_int64),\\n   void *pArg                /* Argument to the function */\\n@@ -67084,7 +67101,7 @@ SQLITE_API void *sqlite3_update_hook(\\n ** Register a callback to be invoked each time a transaction is rolled\\n ** back by this database connection.\\n */\\n-SQLITE_API void *sqlite3_rollback_hook(\\n+void *sqlite3_rollback_hook(\\n   sqlite3 *db,              /* Attach the hook to this database */\\n   void (*xCallback)(void*), /* Callback function */\\n   void *pArg                /* Argument to the function */\\n@@ -67550,7 +67567,7 @@ SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt){\\n /*\\n ** Register a new collation sequence with the database handle db.\\n */\\n-SQLITE_API int sqlite3_create_collation(\\n+int sqlite3_create_collation(\\n   sqlite3* db, \\n   const char *zName, \\n   int enc, \\n@@ -67566,7 +67583,7 @@ SQLITE_API int sqlite3_create_collation(\\n /*\\n ** Register a new collation sequence with the database handle db.\\n */\\n-SQLITE_API int sqlite3_create_collation_v2(\\n+int sqlite3_create_collation_v2(\\n   sqlite3* db, \\n   const char *zName, \\n   int enc, \\n@@ -67584,7 +67601,7 @@ SQLITE_API int sqlite3_create_collation_v2(\\n /*\\n ** Register a new collation sequence with the database handle db.\\n */\\n-SQLITE_API int sqlite3_create_collation16(\\n+int sqlite3_create_collation16(\\n   sqlite3* db, \\n   const char *zName, \\n   int enc, \\n@@ -67607,7 +67624,7 @@ SQLITE_API int sqlite3_create_collation16(\\n ** Register a collation sequence factory callback with the database handle\\n ** db. Replace any previously installed collation sequence factory.\\n */\\n-SQLITE_API int sqlite3_collation_needed(\\n+int sqlite3_collation_needed(\\n   sqlite3 *db, \\n   void *pCollNeededArg, \\n   void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*)\\n@@ -67626,7 +67643,7 @@ SQLITE_API int sqlite3_collation_needed(\\n ** Register a collation sequence factory callback with the database handle\\n ** db. Replace any previously installed collation sequence factory.\\n */\\n-SQLITE_API int sqlite3_collation_needed16(\\n+int sqlite3_collation_needed16(\\n   sqlite3 *db, \\n   void *pCollNeededArg, \\n   void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*)\\n@@ -67646,7 +67663,7 @@ SQLITE_API int sqlite3_collation_needed16(\\n ** This function is now an anachronism. It used to be used to recover from a\\n ** malloc() failure, but SQLite now does this automatically.\\n */\\n-SQLITE_API int sqlite3_global_recover(){\\n+int sqlite3_global_recover(){\\n   return SQLITE_OK;\\n }\\n #endif\\n@@ -67659,7 +67676,7 @@ SQLITE_API int sqlite3_global_recover(){\\n **\\n ******* THIS IS AN EXPERIMENTAL API AND IS SUBJECT TO CHANGE ******\\n */\\n-SQLITE_API int sqlite3_get_autocommit(sqlite3 *db){\\n+int sqlite3_get_autocommit(sqlite3 *db){\\n   return db->autoCommit;\\n }\\n \\n@@ -67683,7 +67700,7 @@ SQLITE_PRIVATE int sqlite3Corrupt(void){\\n ** This routine should only be called when there are no open\\n ** database connections.\\n */\\n-SQLITE_API int sqlite3_enable_shared_cache(int enable){\\n+int sqlite3_enable_shared_cache(int enable){\\n   ThreadData *pTd = sqlite3ThreadData();\\n   if( pTd ){\\n     /* It is only legal to call sqlite3_enable_shared_cache() when there\\n@@ -67707,7 +67724,7 @@ SQLITE_API int sqlite3_enable_shared_cache(int enable){\\n ** This is a convenience routine that makes sure that all thread-specific\\n ** data for this thread has been deallocated.\\n */\\n-SQLITE_API void sqlite3_thread_cleanup(void){\\n+void sqlite3_thread_cleanup(void){\\n   ThreadData *pTd = sqlite3OsThreadSpecificData(0);\\n   if( pTd ){\\n     memset(pTd, 0, sizeof(*pTd));\\n@@ -67720,7 +67737,7 @@ SQLITE_API void sqlite3_thread_cleanup(void){\\n ** See comment in sqlite3.h (sqlite.h.in) for details.\\n */\\n #ifdef SQLITE_ENABLE_COLUMN_METADATA\\n-SQLITE_API int sqlite3_table_column_metadata(\\n+int sqlite3_table_column_metadata(\\n   sqlite3 *db,                /* Connection handle */\\n   const char *zDbName,        /* Database name or NULL */\\n   const char *zTableName,     /* Table name */\\n@@ -67831,7 +67848,7 @@ error_out:\\n /*\\n ** Set all the parameters in the compiled SQL statement to NULL.\\n */\\n-SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt *pStmt){\\n+int sqlite3_clear_bindings(sqlite3_stmt *pStmt){\\n   int i;\\n   int rc = SQLITE_OK;\\n   for(i=1; rc==SQLITE_OK && i<=sqlite3_bind_parameter_count(pStmt); i++){\\n@@ -67850,7 +67867,7 @@ SQLITE_API int sqlite3_sleep(int ms){\\n /*\\n ** Enable or disable the extended result codes.\\n */\\n-SQLITE_API int sqlite3_extended_result_codes(sqlite3 *db, int onoff){\\n+int sqlite3_extended_result_codes(sqlite3 *db, int onoff){\\n   db->errMask = onoff ? 0xffffffff : 0xff;\\n   return SQLITE_OK;\\n }\\ndiff --git a/db/sqlite3/src/sqlite3.h b/db/sqlite3/src/sqlite3.h\\nindex 3354961..e7bfbd4 100644\\n--- a/db/sqlite3/src/sqlite3.h\\n+++ b/db/sqlite3/src/sqlite3.h\\n@@ -30,7 +30,7 @@\\n ** the version number) and changes its name to \\\"sqlite3.h\\\" as\\n ** part of the build process.\\n **\\n-** @(#) $Id: sqlite3.h,v 1.12 2007/09/14 20:46:32 dmose%mozilla.org Exp $\\n+** @(#) $Id: sqlite3.h,v 1.13 2007/09/14 21:07:52 dmose%mozilla.org Exp $\\n */\\n #ifndef _SQLITE3_H_\\n #define _SQLITE3_H_\\n@@ -44,13 +44,6 @@ extern \\\"C\\\" {\\n #endif\\n \\n /*\\n-** Add the ability to override 'extern'\\n-*/\\n-#ifndef SQLITE_EXTERN\\n-# define SQLITE_EXTERN extern\\n-#endif\\n-\\n-/*\\n ** Make sure these symbols where not defined by some previous header\\n ** file.\\n */\\n@@ -88,8 +81,8 @@ extern \\\"C\\\" {\\n **\\n ** See also: [sqlite3_libversion()] and [sqlite3_libversion_number()].\\n */\\n-#define SQLITE_VERSION         \\\"3.4.2\\\"\\n-#define SQLITE_VERSION_NUMBER 3004002\\n+#define SQLITE_VERSION         \\\"3.4.1\\\"\\n+#define SQLITE_VERSION_NUMBER 3004001\\n \\n /*\\n ** CAPI3REF: Run-Time Library Version Numbers\\n@@ -107,7 +100,7 @@ extern \\\"C\\\" {\\n ** is provided for DLL users who can only access functions and not\\n ** constants within the DLL.\\n */\\n-SQLITE_EXTERN const char sqlite3_version[];\\n+extern const char sqlite3_version[];\\n const char *sqlite3_libversion(void);\\n int sqlite3_libversion_number(void);\\n \\n@@ -2027,7 +2020,7 @@ int sqlite3_sleep(int);\\n ** it is not safe to invoke this routine after [sqlite3_open()] has\\n ** been called.\\n */\\n-SQLITE_EXTERN char *sqlite3_temp_directory;\\n+extern char *sqlite3_temp_directory;\\n \\n /*\\n ** CAPI3REF:  Test To See If The Databse Is In Auto-Commit Mode\\n\""}