{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas847a977\""},"diff":"\"847a977 b=377336, win32 printing page results in excessive data spooled to printer, for real this time, r=stuart\\ndiff --git a/gfx/cairo/cairo/src/cairo-paginated-surface.c b/gfx/cairo/cairo/src/cairo-paginated-surface.c\\nindex 78b7e30..72996f6 100644\\n--- a/gfx/cairo/cairo/src/cairo-paginated-surface.c\\n+++ b/gfx/cairo/cairo/src/cairo-paginated-surface.c\\n@@ -238,8 +238,8 @@ static cairo_int_status_t\\n _paint_fallback_image (cairo_paginated_surface_t *surface,\\n \\t\\t       cairo_box_int_t           *box)\\n {\\n-    double x_scale = surface->base.x_fallback_resolution / surface->base.x_resolution;\\n-    double y_scale = surface->base.y_fallback_resolution / surface->base.y_resolution;\\n+    double x_scale = surface->base.x_fallback_resolution / surface->target->x_resolution;\\n+    double y_scale = surface->base.y_fallback_resolution / surface->target->y_resolution;\\n     cairo_matrix_t matrix;\\n     int x, y, width, height;\\n     cairo_status_t status;\\ndiff --git a/gfx/cairo/cairo/src/cairo-win32-printing-surface.c b/gfx/cairo/cairo/src/cairo-win32-printing-surface.c\\nindex 839f3cd..7653b77 100644\\n--- a/gfx/cairo/cairo/src/cairo-win32-printing-surface.c\\n+++ b/gfx/cairo/cairo/src/cairo-win32-printing-surface.c\\n@@ -267,6 +267,12 @@ _cairo_win32_printing_surface_paint_surface_pattern (cairo_win32_surface_t   *su\\n     int x_tile, y_tile, left, right, top, bottom;\\n     RECT clip;\\n \\n+    /* If we can't use StretchDIBits with this surface, we can't do anything\\n+     * special here.\\n+     */\\n+    if (!(surface->flags & CAIRO_WIN32_SURFACE_CAN_STRETCHDIB))\\n+\\treturn CAIRO_INT_STATUS_UNSUPPORTED;\\n+\\n     extend = cairo_pattern_get_extend (&pattern->base);\\n     status = _cairo_pattern_acquire_surface ((cairo_pattern_t *)pattern,\\n \\t\\t\\t\\t\\t     (cairo_surface_t *)surface,\\n@@ -284,6 +290,12 @@ _cairo_win32_printing_surface_paint_surface_pattern (cairo_win32_surface_t   *su\\n \\tgoto FINISH2;\\n     }\\n \\n+    if (image->width == 0 || image->height == 0)\\n+    {\\n+\\tstatus = CAIRO_STATUS_SUCCESS;\\n+\\tgoto FINISH2;\\n+    }\\n+\\t\\n     if (image->format != CAIRO_FORMAT_RGB24) {\\n \\topaque_surface = cairo_image_surface_create (CAIRO_FORMAT_RGB24,\\n \\t\\t\\t\\t\\t\\t     image->width,\\n@@ -378,7 +390,7 @@ _cairo_win32_printing_surface_paint_surface_pattern (cairo_win32_surface_t   *su\\n \\t\\t\\t\\t&bi,\\n \\t\\t\\t\\tDIB_RGB_COLORS,\\n \\t\\t\\t\\tSRCCOPY))\\n-\\t\\treturn _cairo_win32_print_gdi_error (\\\"_cairo_win32_printing_surface_paint(StretchDIBits)\\\");\\n+\\t\\treturn _cairo_win32_print_gdi_error (\\\"_cairo_win32_printing_surface_paint_surface_pattern(StretchDIBits)\\\");\\n \\t}\\n     }\\n     SetStretchBltMode(surface->dc, oldmode);\\ndiff --git a/gfx/src/thebes/nsThebesDeviceContext.cpp b/gfx/src/thebes/nsThebesDeviceContext.cpp\\nindex 9fe9ba5..cb15bd5 100644\\n--- a/gfx/src/thebes/nsThebesDeviceContext.cpp\\n+++ b/gfx/src/thebes/nsThebesDeviceContext.cpp\\n@@ -69,7 +69,6 @@\\n #include \\\"gfxPSSurface.h\\\"\\n static nsSystemFontsGTK2 *gSystemFonts = nsnull;\\n #elif XP_WIN\\n-#include <cairo-win32.h>\\n #include \\\"nsSystemFontsWin.h\\\"\\n #include \\\"gfxWindowsSurface.h\\\"\\n #include \\\"gfxPDFSurface.h\\\"\\n@@ -193,7 +192,7 @@ nsThebesDeviceContext::SetDPI()\\n \\n #elif defined(XP_OS2)\\n         // get a printer DC if available, otherwise create a new (memory) DC\\n-        HDC dc = GetPrintDC();\\n+        HDC dc = GetPrintHDC();\\n         PRBool doCloseDC = PR_FALSE;\\n         if (dc <= 0) { // test for NULLHANDLE/DEV_ERROR or HDC_ERROR\\n             // create DC compatible with the screen\\n@@ -333,9 +332,6 @@ nsThebesDeviceContext::CreateRenderingContext(nsIRenderingContext *&aContext)\\n     }\\n \\n     return rv;\\n-\\n-\\n-    return NS_ERROR_NOT_IMPLEMENTED;\\n }\\n \\n NS_IMETHODIMP\\n@@ -700,6 +696,7 @@ nsThebesDeviceContext::CalcPrintingSize()\\n \\n #ifdef XP_WIN\\n     case gfxASurface::SurfaceTypeWin32:\\n+    case gfxASurface::SurfaceTypeWin32Printing:\\n     {\\n         inPoints = PR_FALSE;\\n         HDC dc =  GetPrintHDC();\\n@@ -756,3 +753,30 @@ nsThebesDeviceContext::UpdateScaledAppUnits()\\n {\\n     mAppUnitsPerDevPixel = PR_MAX(1, PRInt32(float(mAppUnitsPerDevNotScaledPixel) / mPixelScale));\\n }\\n+\\n+#if defined(XP_WIN) || defined(XP_OS2)\\n+HDC\\n+nsThebesDeviceContext::GetPrintHDC()\\n+{\\n+    if (mPrintingSurface) {\\n+        switch (mPrintingSurface->GetType()) {\\n+#ifdef XP_WIN\\n+            case gfxASurface::SurfaceTypeWin32:\\n+            case gfxASurface::SurfaceTypeWin32Printing:\\n+                return reinterpret_cast<gfxWindowsSurface*>(mPrintingSurface.get())->GetDC();\\n+#endif\\n+\\n+#ifdef XP_OS2\\n+            case gfxASurface::SurfaceTypeOS2:\\n+                return GpiQueryDevice(reinterpret_cast<gfxOS2Surface*>(mPrintingSurface.get())->GetPS());\\n+#endif\\n+\\n+            default:\\n+                NS_ASSERTION(0, \\\"invalid surface type in GetPrintHDC\\\");\\n+                break;\\n+        }\\n+    }\\n+\\n+    return nsnull;\\n+}\\n+#endif\\ndiff --git a/gfx/src/thebes/nsThebesDeviceContext.h b/gfx/src/thebes/nsThebesDeviceContext.h\\nindex a992a39..f3ef791 100644\\n--- a/gfx/src/thebes/nsThebesDeviceContext.h\\n+++ b/gfx/src/thebes/nsThebesDeviceContext.h\\n@@ -119,23 +119,8 @@ public:\\n     virtual PRBool SetPixelScale(float aScale);\\n \\n     nsNativeWidget GetWidget() { return mWidget; }\\n-#ifdef XP_WIN\\n-    HDC GetPrintHDC() {\\n-        if (mPrintingSurface) {\\n-            NS_ASSERTION(mPrintingSurface->GetType() == gfxASurface::SurfaceTypeWin32, \\\"invalid surface type\\\");\\n-            return reinterpret_cast<gfxWindowsSurface*>(mPrintingSurface.get())->GetDC();\\n-        }\\n-        return nsnull;\\n-    }\\n-#elif defined(XP_OS2)\\n-    // get the PS from the current surface and from that query the DC\\n-    HDC GetPrintDC() {\\n-        if (mPrintingSurface) {\\n-            NS_ASSERTION(mPrintingSurface->GetType() == gfxASurface::SurfaceTypeOS2, \\\"invalid surface type\\\");\\n-            return GpiQueryDevice(reinterpret_cast<gfxOS2Surface*>(mPrintingSurface.get())->GetPS());\\n-        }\\n-        return nsnull;\\n-    }\\n+#if defined(XP_WIN) || defined(XP_OS2)\\n+    HDC GetPrintHDC();\\n #endif\\n \\n protected:\\ndiff --git a/gfx/thebes/public/gfxASurface.h b/gfx/thebes/public/gfxASurface.h\\nindex 63227cfe..8d74ed4 100644\\n--- a/gfx/thebes/public/gfxASurface.h\\n+++ b/gfx/thebes/public/gfxASurface.h\\n@@ -80,7 +80,8 @@ public:\\n         SurfaceTypeBeOS,\\n         SurfaceTypeDirectFB,\\n         SurfaceTypeSVG,\\n-        SurfaceTypeOS2\\n+        SurfaceTypeOS2,\\n+        SurfaceTypeWin32Printing\\n     } gfxSurfaceType;\\n \\n     typedef enum {\\ndiff --git a/gfx/thebes/public/gfxWindowsSurface.h b/gfx/thebes/public/gfxWindowsSurface.h\\nindex 3202bf0..15d38ce 100644\\n--- a/gfx/thebes/public/gfxWindowsSurface.h\\n+++ b/gfx/thebes/public/gfxWindowsSurface.h\\n@@ -45,8 +45,13 @@\\n \\n class THEBES_API gfxWindowsSurface : public gfxASurface {\\n public:\\n+    enum {\\n+        FLAG_TAKE_DC = (1 << 0),\\n+        FLAG_FOR_PRINTING = (1 << 1)\\n+    };\\n+\\n     gfxWindowsSurface(HWND wnd);\\n-    gfxWindowsSurface(HDC dc, PRBool deleteDC = PR_FALSE);\\n+    gfxWindowsSurface(HDC dc, PRUint32 flags = 0);\\n \\n     // Create a DIB surface\\n     gfxWindowsSurface(const gfxIntSize& size,\\n@@ -76,7 +81,9 @@ public:\\n     nsresult EndPage();\\n \\n private:\\n-    PRBool mOwnsDC;\\n+    PRPackedBool mOwnsDC;\\n+    PRPackedBool mForPrinting;\\n+\\n     HDC mDC;\\n     HWND mWnd;\\n };\\ndiff --git a/gfx/thebes/src/gfxASurface.cpp b/gfx/thebes/src/gfxASurface.cpp\\nindex bd8cceb..9f45bcd 100644\\n--- a/gfx/thebes/src/gfxASurface.cpp\\n+++ b/gfx/thebes/src/gfxASurface.cpp\\n@@ -147,7 +147,8 @@ gfxASurface::Wrap (cairo_surface_t *csurf)\\n         result = new gfxImageSurface(csurf);\\n     }\\n #ifdef CAIRO_HAS_WIN32_SURFACE\\n-    else if (stype == CAIRO_SURFACE_TYPE_WIN32) {\\n+    else if (stype == CAIRO_SURFACE_TYPE_WIN32 ||\\n+             stype == CAIRO_SURFACE_TYPE_WIN32_PRINTING) {\\n         result = new gfxWindowsSurface(csurf);\\n     }\\n #endif\\ndiff --git a/gfx/thebes/src/gfxPDFSurface.cpp b/gfx/thebes/src/gfxPDFSurface.cpp\\nindex 4704958..1734380 100644\\n--- a/gfx/thebes/src/gfxPDFSurface.cpp\\n+++ b/gfx/thebes/src/gfxPDFSurface.cpp\\n@@ -91,9 +91,7 @@ gfxPDFSurface::BeginPage()\\n nsresult\\n gfxPDFSurface::EndPage()\\n {\\n-    cairo_t *cx = cairo_create(CairoSurface());\\n-    cairo_show_page(cx);\\n-    cairo_destroy(cx);\\n+    cairo_surface_show_page(CairoSurface());\\n     return NS_OK;\\n }\\n \\ndiff --git a/gfx/thebes/src/gfxPSSurface.cpp b/gfx/thebes/src/gfxPSSurface.cpp\\nindex 7cf6cd3..e43c222 100644\\n--- a/gfx/thebes/src/gfxPSSurface.cpp\\n+++ b/gfx/thebes/src/gfxPSSurface.cpp\\n@@ -91,9 +91,7 @@ gfxPSSurface::BeginPage()\\n nsresult\\n gfxPSSurface::EndPage()\\n {\\n-    cairo_t *cx = cairo_create(CairoSurface());\\n-    cairo_show_page(cx);\\n-    cairo_destroy(cx);\\n+    cairo_surface_show_page(CairoSurface());\\n     return NS_OK;\\n }\\n \\ndiff --git a/gfx/thebes/src/gfxWindowsFonts.cpp b/gfx/thebes/src/gfxWindowsFonts.cpp\\nindex 69d811a..c05e973 100644\\n--- a/gfx/thebes/src/gfxWindowsFonts.cpp\\n+++ b/gfx/thebes/src/gfxWindowsFonts.cpp\\n@@ -81,7 +81,10 @@ struct DCFromContext {\\n         dc = NULL;\\n         nsRefPtr<gfxASurface> aSurface = aContext->CurrentSurface();\\n         NS_ASSERTION(aSurface, \\\"DCFromContext: null surface\\\");\\n-        if (aSurface && aSurface->GetType() == gfxASurface::SurfaceTypeWin32) {\\n+        if (aSurface &&\\n+            (aSurface->GetType() == gfxASurface::SurfaceTypeWin32 ||\\n+             aSurface->GetType() == gfxASurface::SurfaceTypeWin32Printing))\\n+        {\\n             dc = static_cast<gfxWindowsSurface*>(aSurface.get())->GetDC();\\n             needsRelease = PR_FALSE;\\n         }\\ndiff --git a/gfx/thebes/src/gfxWindowsNativeDrawing.cpp b/gfx/thebes/src/gfxWindowsNativeDrawing.cpp\\nindex 068cece..d421332 100644\\n--- a/gfx/thebes/src/gfxWindowsNativeDrawing.cpp\\n+++ b/gfx/thebes/src/gfxWindowsNativeDrawing.cpp\\n@@ -83,7 +83,8 @@ gfxWindowsNativeDrawing::BeginNativeDrawing()\\n         // if this is a native win32 surface, we don't have to\\n         // redirect rendering to our own HDC; in some cases,\\n         // we may be able to use the HDC from the surface directly.\\n-        if (surf->GetType() == gfxASurface::SurfaceTypeWin32 &&\\n+        if ((surf->GetType() == gfxASurface::SurfaceTypeWin32 ||\\n+             surf->GetType() == gfxASurface::SurfaceTypeWin32Printing) &&\\n             (surf->GetContentType() == gfxASurface::CONTENT_COLOR ||\\n              (surf->GetContentType() == gfxASurface::CONTENT_COLOR_ALPHA &&\\n               (mNativeDrawFlags & CAN_DRAW_TO_COLOR_ALPHA))))\\ndiff --git a/gfx/thebes/src/gfxWindowsSurface.cpp b/gfx/thebes/src/gfxWindowsSurface.cpp\\nindex 229eb89..fbe5f91 100644\\n--- a/gfx/thebes/src/gfxWindowsSurface.cpp\\n+++ b/gfx/thebes/src/gfxWindowsSurface.cpp\\n@@ -45,20 +45,28 @@\\n #include \\\"nsString.h\\\"\\n \\n gfxWindowsSurface::gfxWindowsSurface(HWND wnd) :\\n-    mOwnsDC(PR_TRUE), mWnd(wnd)\\n+    mOwnsDC(PR_TRUE), mForPrinting(PR_FALSE), mWnd(wnd)\\n {\\n     mDC = ::GetDC(mWnd);\\n     Init(cairo_win32_surface_create(mDC));\\n }\\n \\n-gfxWindowsSurface::gfxWindowsSurface(HDC dc, PRBool deleteDC) :\\n-    mOwnsDC(deleteDC), mDC(dc),mWnd(nsnull)\\n+gfxWindowsSurface::gfxWindowsSurface(HDC dc, PRUint32 flags) :\\n+    mOwnsDC(PR_FALSE), mForPrinting(PR_FALSE), mDC(dc), mWnd(nsnull)\\n {\\n-    Init(cairo_win32_surface_create(mDC));\\n+    if (flags & FLAG_TAKE_DC)\\n+        mOwnsDC = PR_TRUE;\\n+\\n+    if (flags & FLAG_FOR_PRINTING) {\\n+        Init(cairo_win32_printing_surface_create(mDC, TRUE));\\n+        mForPrinting = PR_TRUE;\\n+    } else {\\n+        Init(cairo_win32_surface_create(mDC));\\n+    }\\n }\\n \\n gfxWindowsSurface::gfxWindowsSurface(const gfxIntSize& size, gfxImageFormat imageFormat) :\\n-    mOwnsDC(PR_FALSE), mWnd(nsnull)\\n+    mOwnsDC(PR_FALSE), mForPrinting(PR_FALSE), mWnd(nsnull)\\n {\\n     if (!CheckSurfaceSize(size))\\n         return;\\n@@ -71,7 +79,7 @@ gfxWindowsSurface::gfxWindowsSurface(const gfxIntSize& size, gfxImageFormat imag\\n }\\n \\n gfxWindowsSurface::gfxWindowsSurface(HDC dc, const gfxIntSize& size, gfxImageFormat imageFormat) :\\n-    mOwnsDC(PR_FALSE), mWnd(nsnull)\\n+    mOwnsDC(PR_FALSE), mForPrinting(PR_FALSE), mWnd(nsnull)\\n {\\n     if (!CheckSurfaceSize(size))\\n         return;\\n@@ -85,10 +93,13 @@ gfxWindowsSurface::gfxWindowsSurface(HDC dc, const gfxIntSize& size, gfxImageFor\\n \\n \\n gfxWindowsSurface::gfxWindowsSurface(cairo_surface_t *csurf) :\\n-    mOwnsDC(PR_FALSE), mWnd(nsnull)\\n+    mOwnsDC(PR_FALSE), mForPrinting(PR_FALSE), mWnd(nsnull)\\n {\\n     mDC = cairo_win32_surface_get_dc(csurf);\\n \\n+    if (cairo_surface_get_type(csurf) == CAIRO_SURFACE_TYPE_WIN32_PRINTING)\\n+        mForPrinting = PR_TRUE;\\n+\\n     Init(csurf, PR_TRUE);\\n }\\n \\n@@ -105,6 +116,9 @@ gfxWindowsSurface::~gfxWindowsSurface()\\n already_AddRefed<gfxImageSurface>\\n gfxWindowsSurface::GetImageSurface()\\n {\\n+    if (mForPrinting)\\n+        return nsnull;\\n+\\n     cairo_surface_t *isurf = cairo_win32_surface_get_image(CairoSurface());\\n     if (!isurf)\\n         return nsnull;\\n@@ -118,6 +132,9 @@ gfxWindowsSurface::GetImageSurface()\\n already_AddRefed<gfxWindowsSurface>\\n gfxWindowsSurface::OptimizeToDDB(HDC dc, const gfxIntSize& size, gfxImageFormat format)\\n {\\n+    if (mForPrinting)\\n+        return nsnull;\\n+\\n     gfxImageFormat realFormat = format;\\n \\n     if (realFormat != ImageFormatRGB24)\\n@@ -204,6 +221,8 @@ nsresult gfxWindowsSurface::BeginPage()\\n \\n nsresult gfxWindowsSurface::EndPage()\\n {\\n+    if (mForPrinting)\\n+        cairo_surface_show_page(CairoSurface());\\n     ::EndPage(mDC);\\n     return NS_OK;\\n }\\ndiff --git a/widget/src/windows/nsDeviceContextSpecWin.cpp b/widget/src/windows/nsDeviceContextSpecWin.cpp\\nindex 3ee98d3..e6d992f 100644\\n--- a/widget/src/windows/nsDeviceContextSpecWin.cpp\\n+++ b/widget/src/windows/nsDeviceContextSpecWin.cpp\\n@@ -547,7 +547,7 @@ NS_IMETHODIMP nsDeviceContextSpecWin::GetSurfaceForPrinter(gfxASurface **surface\\n       HDC dc = ::CreateDC(mDriverName, mDeviceName, NULL, mDevMode);\\n \\n       // have this surface take over ownership of this DC\\n-      newSurface = new gfxWindowsSurface(dc, PR_TRUE);\\n+      newSurface = new gfxWindowsSurface(dc, gfxWindowsSurface::FLAG_TAKE_DC | gfxWindowsSurface::FLAG_FOR_PRINTING);\\n     }\\n   }\\n \\n\""}