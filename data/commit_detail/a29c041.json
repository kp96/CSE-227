{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basa29c041\""},"diff":"\"a29c041 Bug 396450 - Move logic out of nsDownloadManager.h.  Patch by Edward Lee <edilee@gmail.com>. r=sdwilsh, a=mconnor\\ndiff --git a/toolkit/components/downloads/src/nsDownloadManager.cpp b/toolkit/components/downloads/src/nsDownloadManager.cpp\\nindex 7eedd2f..40f998e 100644\\n--- a/toolkit/components/downloads/src/nsDownloadManager.cpp\\n+++ b/toolkit/components/downloads/src/nsDownloadManager.cpp\\n@@ -831,6 +831,15 @@ nsDownloadManager::GetDownloadFromDB(PRUint32 aID, nsDownload **retVal)\\n   return NS_OK;\\n }\\n \\n+nsresult\\n+nsDownloadManager::AddToCurrentDownloads(nsDownload *aDl)\\n+{\\n+  if (!mCurrentDownloads.AppendObject(aDl))\\n+    return NS_ERROR_OUT_OF_MEMORY;\\n+\\n+  return NS_OK;\\n+}\\n+\\n void\\n nsDownloadManager::SendEvent(nsDownload *aDownload, const char *aTopic)\\n {\\n@@ -1126,7 +1135,7 @@ nsDownloadManager::CancelDownload(PRUint32 aID)\\n     return NS_ERROR_FAILURE;\\n \\n   // Don't cancel if download is already finished\\n-  if (CompletedSuccessfully(dl->mDownloadState))\\n+  if (dl->IsFinished())\\n     return NS_OK;\\n \\n   // if the download is paused, we have to resume it so we can cancel it\\n@@ -1876,7 +1885,7 @@ nsDownload::OnStateChange(nsIWebProgress *aWebProgress,\\n       }\\n     }\\n   } else if (aStateFlags & STATE_STOP) {\\n-    if (nsDownloadManager::IsInFinalStage(mDownloadState)) {\\n+    if (IsFinishable()) {\\n       // Set file size at the end of a transfer (for unknown transfer amounts)\\n       if (mMaxBytes == LL_MAXUINT)\\n         mMaxBytes = mCurrBytes;\\n@@ -2133,6 +2142,20 @@ nsDownload::PauseResume(PRBool aPause)\\n   return SetState(nsIDownloadManager::DOWNLOAD_DOWNLOADING);\\n }\\n \\n+PRBool\\n+nsDownload::IsFinishable()\\n+{\\n+  return mDownloadState == nsIDownloadManager::DOWNLOAD_NOTSTARTED ||\\n+         mDownloadState == nsIDownloadManager::DOWNLOAD_QUEUED ||\\n+         mDownloadState == nsIDownloadManager::DOWNLOAD_DOWNLOADING;\\n+}\\n+\\n+PRBool\\n+nsDownload::IsFinished()\\n+{\\n+  return mDownloadState == nsIDownloadManager::DOWNLOAD_FINISHED;\\n+}\\n+\\n nsresult\\n nsDownload::UpdateDB()\\n {\\ndiff --git a/toolkit/components/downloads/src/nsDownloadManager.h b/toolkit/components/downloads/src/nsDownloadManager.h\\nindex 1a03c78..c6a3802 100644\\n--- a/toolkit/components/downloads/src/nsDownloadManager.h\\n+++ b/toolkit/components/downloads/src/nsDownloadManager.h\\n@@ -101,13 +101,11 @@ protected:\\n   nsresult RestoreDatabaseState();\\n   nsresult GetDownloadFromDB(PRUint32 aID, nsDownload **retVal);\\n \\n-  inline nsresult AddToCurrentDownloads(nsDownload *aDl)\\n-  {\\n-    if (!mCurrentDownloads.AppendObject(aDl))\\n-      return NS_ERROR_OUT_OF_MEMORY;\\n-\\n-    return NS_OK;\\n-  }\\n+  /**\\n+   * Specially track the active downloads so that we don't need to check\\n+   * every download to see if they're in progress.\\n+   */\\n+  nsresult AddToCurrentDownloads(nsDownload *aDl);\\n \\n   void SendEvent(nsDownload *aDownload, const char *aTopic);\\n \\n@@ -160,26 +158,6 @@ protected:\\n   PRInt32 GetRetentionBehavior();\\n   nsresult ExecuteDesiredAction(nsDownload *aDownload);\\n \\n-  static PRBool IsInFinalStage(DownloadState aState)\\n-  {\\n-    return aState == nsIDownloadManager::DOWNLOAD_NOTSTARTED ||\\n-           aState == nsIDownloadManager::DOWNLOAD_QUEUED ||\\n-           aState == nsIDownloadManager::DOWNLOAD_DOWNLOADING;\\n-  }\\n-\\n-  static PRBool IsInProgress(DownloadState aState)\\n-  {\\n-    return aState == nsIDownloadManager::DOWNLOAD_NOTSTARTED ||\\n-           aState == nsIDownloadManager::DOWNLOAD_QUEUED ||\\n-           aState == nsIDownloadManager::DOWNLOAD_DOWNLOADING ||\\n-           aState == nsIDownloadManager::DOWNLOAD_PAUSED;\\n-  }\\n-\\n-  static PRBool CompletedSuccessfully(DownloadState aState)\\n-  {\\n-    return aState == nsIDownloadManager::DOWNLOAD_FINISHED;\\n-  }\\n-\\n private:\\n   nsCOMArray<nsIDownloadProgressListener> mListeners;\\n   nsCOMPtr<nsIStringBundle> mBundle;\\n@@ -223,6 +201,16 @@ protected:\\n \\n   nsresult PauseResume(PRBool aPause);\\n \\n+  /**\\n+   * Download is in a state to stop and complete the download?\\n+   */\\n+  PRBool IsFinishable();\\n+\\n+  /**\\n+   * Download is totally done transferring and all?\\n+   */\\n+  PRBool IsFinished();\\n+\\n   nsDownloadManager *mDownloadManager;\\n   nsCOMPtr<nsIURI> mTarget;\\n \\n\""}