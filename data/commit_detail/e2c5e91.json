{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Base2c5e91\""},"diff":"\"e2c5e91 Make disabling image loading in prefs also block images loaded via <object>. Bug 393503, r+sr=biesi, a=jst\\ndiff --git a/content/base/src/nsObjectLoadingContent.cpp b/content/base/src/nsObjectLoadingContent.cpp\\nindex 9671af1b..d2f7029 100644\\n--- a/content/base/src/nsObjectLoadingContent.cpp\\n+++ b/content/base/src/nsObjectLoadingContent.cpp\\n@@ -401,13 +401,54 @@ nsObjectLoadingContent::OnStartRequest(nsIRequest *aRequest, nsISupports *aConte\\n   ObjectType newType = GetTypeOfContent(mContentType);\\n   LOG((\\\"OBJLC [%p]: OnStartRequest: Content Type=<%s> Old type=%u New Type=%u\\\\n\\\",\\n        this, mContentType.get(), mType, newType));\\n-  if (mType != newType) {\\n-    UnloadContent();\\n-  }\\n \\n+  // Now do a content policy check\\n+  // XXXbz this duplicates some code in nsContentBlocker::ShouldLoad  \\n+  PRInt32 contentPolicyType;\\n+  switch (newType) {\\n+    case eType_Image:\\n+      contentPolicyType = nsIContentPolicy::TYPE_IMAGE;\\n+      break;\\n+    case eType_Document:\\n+      contentPolicyType = nsIContentPolicy::TYPE_SUBDOCUMENT;\\n+      break;\\n+    default:\\n+      contentPolicyType = nsIContentPolicy::TYPE_OBJECT;\\n+      break;\\n+  }\\n+  nsCOMPtr<nsIURI> uri;\\n+  chan->GetURI(getter_AddRefs(uri));\\n   nsCOMPtr<nsIContent> thisContent = \\n     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));\\n   NS_ASSERTION(thisContent, \\\"must be a content\\\");\\n+\\n+  nsIDocument* doc = thisContent->GetOwnerDoc();\\n+  if (!doc) {\\n+    Fallback(PR_FALSE);\\n+    return NS_BINDING_ABORTED;    \\n+  }\\n+\\n+  PRInt16 shouldProcess = nsIContentPolicy::ACCEPT;\\n+  rv =\\n+    NS_CheckContentProcessPolicy(contentPolicyType,\\n+                                 uri,\\n+                                 doc->NodePrincipal(),\\n+                                 static_cast<nsIImageLoadingContent*>(this),\\n+                                 mContentType,\\n+                                 nsnull, //extra\\n+                                 &shouldProcess,\\n+                                 nsContentUtils::GetContentPolicy(),\\n+                                 nsContentUtils::GetSecurityManager());\\n+  if (NS_FAILED(rv) || NS_CP_REJECTED(shouldProcess)) {\\n+    HandleBeingBlockedByContentPolicy(rv, shouldProcess);\\n+    rv = NS_OK; // otherwise, the AutoFallback will make us fall back\\n+    return NS_BINDING_ABORTED;\\n+  }  \\n+  \\n+  if (mType != newType) {\\n+    UnloadContent();\\n+  }\\n+\\n   switch (newType) {\\n     case eType_Image:\\n       rv = LoadImageWithChannel(chan, getter_AddRefs(mFinalListener));\\n@@ -434,8 +475,6 @@ nsObjectLoadingContent::OnStartRequest(nsIRequest *aRequest, nsISupports *aConte\\n         }\\n       }\\n \\n-      nsCOMPtr<nsIURI> uri;\\n-      chan->GetURI(getter_AddRefs(uri));\\n       rv = mFrameLoader->CheckForRecursiveLoad(uri);\\n       if (NS_FAILED(rv)) {\\n         Fallback(PR_FALSE);\\n@@ -918,19 +957,9 @@ nsObjectLoadingContent::LoadObject(nsIURI* aURI,\\n                                 nsnull, //extra\\n                                 &shouldLoad,\\n                                 nsContentUtils::GetContentPolicy(),\\n-                                nsContentUtils::GetSecurityManager());\\n+                                secMan);\\n     if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad)) {\\n-      // Must call UnloadContent first, as it overwrites\\n-      // mSuppressed/mUserDisabled. It also takes care of setting the type to\\n-      // eType_Null.\\n-      UnloadContent();\\n-      if (NS_SUCCEEDED(rv)) {\\n-        if (shouldLoad == nsIContentPolicy::REJECT_TYPE) {\\n-          mUserDisabled = PR_TRUE;\\n-        } else if (shouldLoad == nsIContentPolicy::REJECT_SERVER) {\\n-          mSuppressed = PR_TRUE;\\n-        }\\n-      }\\n+      HandleBeingBlockedByContentPolicy(rv, shouldLoad);\\n       return NS_OK;\\n     }\\n   }\\n@@ -1457,6 +1486,23 @@ nsObjectLoadingContent::GetFrame(PRBool aFlushLayout)\\n   return objFrame;\\n }\\n \\n+void\\n+nsObjectLoadingContent::HandleBeingBlockedByContentPolicy(nsresult aStatus,\\n+                                                          PRInt16 aRetval)\\n+{\\n+  // Must call UnloadContent first, as it overwrites\\n+  // mSuppressed/mUserDisabled. It also takes care of setting the type to\\n+  // eType_Null.\\n+  UnloadContent();\\n+  if (NS_SUCCEEDED(aStatus)) {\\n+    if (aRetval == nsIContentPolicy::REJECT_TYPE) {\\n+      mUserDisabled = PR_TRUE;\\n+    } else if (aRetval == nsIContentPolicy::REJECT_SERVER) {\\n+      mSuppressed = PR_TRUE;\\n+    }\\n+  }\\n+}\\n+\\n nsresult\\n nsObjectLoadingContent::TryInstantiate(const nsACString& aMIMEType,\\n                                        nsIURI* aURI)\\ndiff --git a/content/base/src/nsObjectLoadingContent.h b/content/base/src/nsObjectLoadingContent.h\\nindex 654d953..b2c64a9 100644\\n--- a/content/base/src/nsObjectLoadingContent.h\\n+++ b/content/base/src/nsObjectLoadingContent.h\\n@@ -280,6 +280,14 @@ class nsObjectLoadingContent : public nsImageLoadingContent\\n     nsIObjectFrame* GetFrame(PRBool aFlushLayout);\\n \\n     /**\\n+     * Handle being blocked by a content policy.  aStatus is the nsresult\\n+     * return value of the Should* call, while aRetval is what it returned in\\n+     * its out parameter.\\n+     */\\n+    void HandleBeingBlockedByContentPolicy(nsresult aStatus,\\n+                                           PRInt16 aRetval);\\n+\\n+    /**\\n      * Checks if we have a frame that's ready for instantiation, and if so,\\n      * calls Instantiate().\\n      */\\n\""}