{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Baseb080a3\""},"diff":"\"eb080a3 Bug 393653. Console warnings in GetFinalState() point to actual bug with the calculation of the EMBEDS relationship on the root accessible. r=surkov, a=dsicore\\ndiff --git a/accessible/src/base/nsAccessible.cpp b/accessible/src/base/nsAccessible.cpp\\nindex 01c5b71..0514862 100644\\n--- a/accessible/src/base/nsAccessible.cpp\\n+++ b/accessible/src/base/nsAccessible.cpp\\n@@ -2244,8 +2244,7 @@ nsAccessible::GetFinalState(PRUint32 *aState, PRUint32 *aExtraState)\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n   // Apply ARIA states to be sure accessible states will be overriden.\\n-  rv = GetARIAState(aState);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n+  *aState |= GetARIAState();\\n \\n   // Set additional states which presence depends on another states.\\n   if (aExtraState) {\\n@@ -2305,48 +2304,47 @@ nsAccessible::GetFinalState(PRUint32 *aState, PRUint32 *aExtraState)\\n   return NS_OK;\\n }\\n \\n-nsresult\\n-nsAccessible::GetARIAState(PRUint32 *aState)\\n+PRUint32\\n+nsAccessible::GetARIAState()\\n {\\n-  if (!mDOMNode) {\\n-    return NS_ERROR_FAILURE; // Node already shut down\\n-  }\\n-\\n   // Test for universal states first\\n   nsIContent *content = GetRoleContent(mDOMNode);\\n-  NS_ENSURE_TRUE(content, NS_ERROR_FAILURE); // Node already shut down\\n+  if (!content) {\\n+    return 0;\\n+  }\\n \\n+  PRUint32 ariaState = 0;\\n   PRUint32 index = 0;\\n   while (nsARIAMap::gWAIUnivStateMap[index].attributeName != nsnull) {\\n-    MappedAttrState(content, aState, &nsARIAMap::gWAIUnivStateMap[index]);\\n+    MappedAttrState(content, &ariaState, &nsARIAMap::gWAIUnivStateMap[index]);\\n     ++ index;\\n   }\\n \\n   if (!mRoleMapEntry)\\n-    return NS_OK;\\n+    return ariaState;\\n \\n   // Once DHTML role is used, we're only readonly if DHTML readonly used\\n-  (*aState) &= ~nsIAccessibleStates::STATE_READONLY;\\n+  ariaState &= ~nsIAccessibleStates::STATE_READONLY;\\n \\n-  if ((*aState) & nsIAccessibleStates::STATE_UNAVAILABLE) {\\n+  if (ariaState & nsIAccessibleStates::STATE_UNAVAILABLE) {\\n     // Disabled elements are not selectable or focusable, even if disabled\\n     // via DHTML accessibility disabled property\\n-    (*aState) &= ~(nsIAccessibleStates::STATE_SELECTABLE |\\n+    ariaState &= ~(nsIAccessibleStates::STATE_SELECTABLE |\\n                    nsIAccessibleStates::STATE_FOCUSABLE);\\n   }\\n \\n-  (*aState) |= mRoleMapEntry->state;\\n-  if (MappedAttrState(content, aState, &mRoleMapEntry->attributeMap1) &&\\n-      MappedAttrState(content, aState, &mRoleMapEntry->attributeMap2) &&\\n-      MappedAttrState(content, aState, &mRoleMapEntry->attributeMap3) &&\\n-      MappedAttrState(content, aState, &mRoleMapEntry->attributeMap4) &&\\n-      MappedAttrState(content, aState, &mRoleMapEntry->attributeMap5) &&\\n-      MappedAttrState(content, aState, &mRoleMapEntry->attributeMap6) &&\\n-      MappedAttrState(content, aState, &mRoleMapEntry->attributeMap7)) {\\n-    MappedAttrState(content, aState, &mRoleMapEntry->attributeMap8);\\n+  ariaState |= mRoleMapEntry->state;\\n+  if (MappedAttrState(content, &ariaState, &mRoleMapEntry->attributeMap1) &&\\n+      MappedAttrState(content, &ariaState, &mRoleMapEntry->attributeMap2) &&\\n+      MappedAttrState(content, &ariaState, &mRoleMapEntry->attributeMap3) &&\\n+      MappedAttrState(content, &ariaState, &mRoleMapEntry->attributeMap4) &&\\n+      MappedAttrState(content, &ariaState, &mRoleMapEntry->attributeMap5) &&\\n+      MappedAttrState(content, &ariaState, &mRoleMapEntry->attributeMap6) &&\\n+      MappedAttrState(content, &ariaState, &mRoleMapEntry->attributeMap7)) {\\n+    MappedAttrState(content, &ariaState, &mRoleMapEntry->attributeMap8);\\n   }\\n \\n-  return NS_OK;\\n+  return ariaState;\\n }\\n \\n // Not implemented by this class\\ndiff --git a/accessible/src/base/nsAccessible.h b/accessible/src/base/nsAccessible.h\\nindex 3f1ba92..578e511 100644\\n--- a/accessible/src/base/nsAccessible.h\\n+++ b/accessible/src/base/nsAccessible.h\\n@@ -136,12 +136,7 @@ public:\\n    * argument should hold states for accessible before you pass it into this\\n    * method.\\n    */\\n-  nsresult GetARIAState(PRUint32 *aState);\\n-\\n-#ifdef MOZ_ACCESSIBILITY_ATK\\n-  static PRBool FindTextFrame(PRInt32 &index, nsPresContext *aPresContext, nsIFrame *aCurFrame, \\n-                                   nsIFrame **aFirstTextFrame, const nsIFrame *aTextFrame);\\n-#endif\\n+  PRUint32 GetARIAState();\\n \\n #ifdef DEBUG_A11Y\\n   static PRBool IsTextInterfaceSupportCorrect(nsIAccessible *aAccessible);\\ndiff --git a/accessible/src/base/nsRootAccessible.cpp b/accessible/src/base/nsRootAccessible.cpp\\nindex 29f1dd5..78d823e 100644\\n--- a/accessible/src/base/nsRootAccessible.cpp\\n+++ b/accessible/src/base/nsRootAccessible.cpp\\n@@ -939,6 +939,9 @@ nsRootAccessible::GetContentDocShell(nsIDocShellTreeItem *aStart)\\n       }\\n       nsCOMPtr<nsIAccessible> ancestor;\\n       accessible->GetParent(getter_AddRefs(ancestor));\\n+      if (ancestor == this) {\\n+        break; // Don't check past original root accessible we started with\\n+      }\\n       accessible.swap(ancestor);\\n     }\\n \\n\""}