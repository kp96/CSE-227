{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basa0aa440\""},"diff":"\"a0aa440 Bug 385888: Removal of non-Cairo code from windows/nsWindow, p=alfredkayser, r=emaijala, sr=roc, a=pavlov\\ndiff --git a/widget/src/windows/nsWindow.cpp b/widget/src/windows/nsWindow.cpp\\nindex 2d48b6a..fa04cb1 100644\\n--- a/widget/src/windows/nsWindow.cpp\\n+++ b/widget/src/windows/nsWindow.cpp\\n@@ -101,12 +101,8 @@\\n #include \\\"resource.h\\\"\\n #include <commctrl.h>\\n #include \\\"prtime.h\\\"\\n-#ifdef MOZ_CAIRO_GFX\\n #include \\\"gfxContext.h\\\"\\n #include \\\"gfxWindowsSurface.h\\\"\\n-#else\\n-#include \\\"nsIRenderingContextWin.h\\\"\\n-#endif\\n #include \\\"nsIImage.h\\\"\\n \\n #ifdef ACCESSIBILITY\\n@@ -786,9 +782,7 @@ nsWindow::nsWindow() : nsBaseWidget()\\n #ifdef MOZ_XUL\\n   mIsTranslucent      = PR_FALSE;\\n   mIsTopTranslucent   = PR_FALSE;\\n-#ifdef MOZ_CAIRO_GFX\\n   mTranslucentSurface = nsnull;\\n-#endif\\n   mMemoryDC           = NULL;\\n   mMemoryBitmap       = NULL;\\n   mMemoryBits         = NULL;\\n@@ -2600,84 +2594,6 @@ static PRUint8* Data32BitTo1Bit(PRUint8* aImageData,\\n }\\n \\n // static\\n-PRUint8* nsWindow::Data8BitTo1Bit(PRUint8* aAlphaData,\\n-                                  PRUint32 aAlphaBytesPerRow,\\n-                                  PRUint32 aWidth, PRUint32 aHeight)\\n-{\\n-  // We need (aWidth + 7) / 8 bytes plus zero-padding up to a multiple of\\n-  // 4 bytes for each row (HBITMAP requirement). Bug 353553.\\n-  PRUint32 outBpr = ((aWidth + 31) / 8) & ~3;\\n-  \\n-  PRUint8* outData = new PRUint8[outBpr * aHeight];\\n-  if (!outData)\\n-    return NULL;\\n-\\n-  PRUint8 *outRow = outData,\\n-          *alphaRow = aAlphaData;\\n-\\n-  for (PRUint32 curRow = 0; curRow < aHeight; curRow++) {\\n-    PRUint8 *arow = alphaRow;\\n-    PRUint8 *nextOutRow = outRow + outBpr;\\n-    PRUint8 alphaPixels = 0;\\n-    PRUint8 offset = 7;\\n-\\n-    for (PRUint32 curCol = 0; curCol < aWidth; curCol++) {\\n-      if (*alphaRow++ > 0)\\n-        alphaPixels |= (1 << offset);\\n-        \\n-      if (offset == 0) {\\n-        *outRow++ = alphaPixels;\\n-        offset = 7;\\n-        alphaPixels = 0;\\n-      } else {\\n-        offset--;\\n-      }\\n-    }\\n-    if (offset != 7)\\n-      *outRow++ = alphaPixels;\\n-\\n-    alphaRow = arow + aAlphaBytesPerRow;\\n-    while (outRow != nextOutRow)\\n-      *outRow++ = 0; // padding\\n-  }\\n-\\n-  return outData;\\n-}\\n-\\n-// static\\n-PRUint8* nsWindow::DataToAData(PRUint8* aImageData, PRUint32 aImageBytesPerRow,\\n-                               PRUint8* aAlphaData, PRUint32 aAlphaBytesPerRow,\\n-                               PRUint32 aWidth, PRUint32 aHeight)\\n-{\\n-  // We will have 32 bpp, so bytes per row will be 4 * w\\n-  PRUint32 outBpr = aWidth * 4;\\n-\\n-  // Avoid overflows\\n-  if (aWidth > 0xfff || aHeight > 0xfff)\\n-    return NULL;\\n-\\n-  PRUint8* outData = new PRUint8[outBpr * aHeight];\\n-  if (!outData)\\n-    return NULL;\\n-\\n-  PRUint8 *outRow = outData,\\n-          *imageRow = aImageData,\\n-          *alphaRow = aAlphaData;\\n-  for (PRUint32 curRow = 0; curRow < aHeight; curRow++) {\\n-    PRUint8 *irow = imageRow, *arow = alphaRow;\\n-    for (PRUint32 curCol = 0; curCol < aWidth; curCol++) {\\n-      *outRow++ = *imageRow++; // B\\n-      *outRow++ = *imageRow++; // G\\n-      *outRow++ = *imageRow++; // R\\n-      *outRow++ = *alphaRow++; // A\\n-    }\\n-    imageRow = irow + aImageBytesPerRow;\\n-    alphaRow = arow + aAlphaBytesPerRow;\\n-  }\\n-  return outData;\\n-}\\n-\\n-// static\\n HBITMAP nsWindow::DataToBitmap(PRUint8* aImageData,\\n                                PRUint32 aWidth,\\n                                PRUint32 aHeight,\\n@@ -2769,38 +2685,6 @@ HBITMAP nsWindow::DataToBitmap(PRUint8* aImageData,\\n   return bmp;\\n }\\n \\n-// static\\n-HBITMAP nsWindow::CreateOpaqueAlphaChannel(PRUint32 aWidth, PRUint32 aHeight)\\n-{\\n-  // Make up an opaque alpha channel.\\n-  // We need (aWidth + 7) / 8 bytes plus zero-padding up to a multiple of\\n-  // 4 bytes for each row (HBITMAP requirement). Bug 353553.\\n-  PRUint32 nonPaddedBytesPerRow = (aWidth + 7) / 8;\\n-  PRUint32 abpr = (nonPaddedBytesPerRow + 3) & ~3;\\n-  PRUint32 bufferSize = abpr * aHeight;\\n-  PRUint8* opaque = (PRUint8*)malloc(bufferSize);\\n-  if (!opaque)\\n-    return NULL;\\n-\\n-  memset(opaque, 0xff, bufferSize);\\n-\\n-  // If we have row padding, set it to zero.\\n-  if (nonPaddedBytesPerRow != abpr) {\\n-    PRUint8* p = opaque;\\n-    PRUint8* end = opaque + bufferSize;\\n-    while (p != end) {\\n-      PRUint8* nextRow = p + abpr;\\n-      p += nonPaddedBytesPerRow;\\n-      while (p != nextRow)\\n-        *p++ = 0; // padding\\n-    }\\n-  }\\n-\\n-  HBITMAP hAlpha = DataToBitmap(opaque, aWidth, aHeight, 1);\\n-  free(opaque);\\n-  return hAlpha;\\n-}\\n-\\n NS_IMETHODIMP nsWindow::SetCursor(imgIContainer* aCursor,\\n                                   PRUint32 aHotspotX, PRUint32 aHotspotY)\\n {\\n@@ -2826,7 +2710,6 @@ NS_IMETHODIMP nsWindow::SetCursor(imgIContainer* aCursor,\\n   if (width > 128 || height > 128)\\n     return NS_ERROR_NOT_AVAILABLE;\\n \\n-#ifdef MOZ_CAIRO_GFX\\n   PRUint32 bpr;\\n   gfx_format format;\\n   frame->GetImageBytesPerRow(&bpr);\\n@@ -2906,134 +2789,6 @@ NS_IMETHODIMP nsWindow::SetCursor(imgIContainer* aCursor,\\n     ::DestroyIcon(gHCursor);\\n   gHCursor = cursor;\\n \\n-#else\\n-\\n-  gfx_format format;\\n-  nsresult rv = frame->GetFormat(&format);\\n-  if (NS_FAILED(rv))\\n-    return rv;\\n-\\n-  if (format != gfxIFormats::BGR_A1 && format != gfxIFormats::BGR_A8 &&\\n-      format != gfxIFormats::BGR)\\n-    return NS_ERROR_UNEXPECTED;\\n-\\n-  // On Win2k with nVidia video drivers 71.84 at 32 bit color, cursors that \\n-  // have 8 bit alpha are truncated to 64x64.  Skip cursors larger than that.\\n-  // This is redundant with checks above, but we'll leave it in as a reminder\\n-  // in case we start accepting larger cursors again\\n-  if (IsWin2k() && (format == gfxIFormats::BGR_A8) &&\\n-      (width > 64 || height > 64))\\n-    return NS_ERROR_FAILURE;\\n-\\n-  PRUint32 bpr;\\n-  rv = frame->GetImageBytesPerRow(&bpr);\\n-  if (NS_FAILED(rv))\\n-    return rv;\\n-\\n-  frame->LockImageData();\\n-  PRUint32 dataLen;\\n-  PRUint8* data;\\n-  rv = frame->GetImageData(&data, &dataLen);\\n-  if (NS_FAILED(rv)) {\\n-    frame->UnlockImageData();\\n-    return rv;\\n-  }\\n-\\n-  HBITMAP hBMP = NULL;\\n-  if (format != gfxIFormats::BGR_A8) {\\n-    hBMP = DataToBitmap(data, width, height, 24);\\n-    if (hBMP == NULL) {\\n-      frame->UnlockImageData();\\n-      return NS_ERROR_FAILURE;\\n-    }\\n-  }\\n-\\n-  HBITMAP hAlpha = NULL;\\n-  if (format == gfxIFormats::BGR) {\\n-    hAlpha = CreateOpaqueAlphaChannel(width, height);\\n-  } else {\\n-    PRUint32 abpr;\\n-    rv = frame->GetAlphaBytesPerRow(&abpr);\\n-    if (NS_FAILED(rv)) {\\n-      frame->UnlockImageData();\\n-      if (hBMP != NULL)\\n-        ::DeleteObject(hBMP);\\n-      return rv;\\n-    }\\n-\\n-    PRUint8* adata;\\n-    frame->LockAlphaData();\\n-    rv = frame->GetAlphaData(&adata, &dataLen);\\n-    if (NS_FAILED(rv)) {\\n-      if (hBMP != NULL)\\n-        ::DeleteObject(hBMP);\\n-      frame->UnlockImageData();\\n-      frame->UnlockAlphaData();\\n-      return rv;\\n-    }\\n-\\n-    if (format == gfxIFormats::BGR_A8) {\\n-      // Convert BGR_A8 to BGRA.  \\n-      // Some platforms (or video cards?) on 32bit color mode will ignore\\n-      // hAlpha. For them, we could speed up things by creating an opaque alpha\\n-      // channel, but since we don't know how to determine whether hAlpha is\\n-      // ignored, create a proper 1 bit alpha channel to supplement the RGBA.\\n-      // Plus, on non-32bit color and possibly other platforms, the alpha\\n-      // of RGBA is ignored.\\n-      PRUint8* bgra8data = DataToAData(data, bpr, adata, abpr, width, height);\\n-      if (bgra8data) {\\n-        hBMP = DataToBitmap(bgra8data, width, height, 32);\\n-        if (hBMP != NULL) {\\n-          PRUint8* a1data = Data8BitTo1Bit(adata, abpr, width, height);\\n-          if (a1data) {\\n-            hAlpha = DataToBitmap(a1data, width, height, 1);\\n-            delete [] a1data;\\n-          }\\n-        }\\n-        delete [] bgra8data;\\n-      }\\n-    } else {\\n-      hAlpha = DataToBitmap(adata, width, height, 1);\\n-    }\\n-\\n-    frame->UnlockAlphaData();\\n-  }\\n-  frame->UnlockImageData();\\n-  if (hBMP == NULL) {\\n-    return NS_ERROR_FAILURE;\\n-  }\\n-  if (hAlpha == NULL) {\\n-    ::DeleteObject(hBMP);\\n-    return NS_ERROR_FAILURE;\\n-  }\\n-\\n-  ICONINFO info = {0};\\n-  info.fIcon = FALSE;\\n-  info.xHotspot = aHotspotX;\\n-  info.yHotspot = aHotspotY;\\n-  info.hbmMask = hAlpha;\\n-  info.hbmColor = hBMP;\\n-  \\n-  HCURSOR cursor = ::CreateIconIndirect(&info);\\n-  ::DeleteObject(hBMP);\\n-  ::DeleteObject(hAlpha);\\n-  if (cursor == NULL) {\\n-    return NS_ERROR_FAILURE;\\n-  }\\n-\\n-  mCursor = nsCursor(-1);\\n-  ::SetCursor(cursor);\\n-\\n-  NS_IF_RELEASE(gCursorImgContainer);\\n-  gCursorImgContainer = aCursor;\\n-  NS_ADDREF(gCursorImgContainer);\\n-\\n-  if (gHCursor != NULL)\\n-    ::DestroyIcon(gHCursor);\\n-  gHCursor = cursor;\\n-\\n-#endif\\n-\\n   return NS_OK;\\n }\\n \\n@@ -4465,12 +4220,8 @@ PRBool nsWindow::ProcessMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT\\n       break;\\n \\n     case WM_PAINT:\\n-#ifdef MOZ_CAIRO_GFX\\n       *aRetValue = (int) OnPaint();\\n       result = PR_TRUE;\\n-#else\\n-      result = OnPaint();\\n-#endif\\n       break;\\n \\n #ifndef WINCE\\n@@ -5950,7 +5701,6 @@ PRBool nsWindow::OnPaint(HDC aDC)\\n                            (PRInt32) mWnd);\\n #endif // NS_DEBUG\\n \\n-#ifdef MOZ_CAIRO_GFX\\n #ifdef MOZ_XUL\\n       nsRefPtr<gfxASurface> targetSurface;\\n       if (mIsTranslucent) {\\n@@ -6009,43 +5759,6 @@ PRBool nsWindow::OnPaint(HDC aDC)\\n       }\\n #endif\\n \\n-#else\\n-      /* Non-cairo GFX */\\n-      if (NS_SUCCEEDED(CallCreateInstance(kRenderingContextCID, &event.renderingContext)))\\n-      {\\n-        nsIRenderingContextWin *winrc;\\n-        if (NS_SUCCEEDED(CallQueryInterface(event.renderingContext, &winrc)))\\n-        {\\n-          nsIDrawingSurface* surf;\\n-\\n-          //i know all of this seems a little backwards. i'll fix it, i swear. MMP\\n-\\n-          if (NS_OK == winrc->CreateDrawingSurface(hDC, surf))\\n-          {\\n-            event.renderingContext->Init(mContext, surf);\\n-            result = DispatchWindowEvent(&event, eventStatus);\\n-            event.renderingContext->DestroyDrawingSurface(surf);\\n-\\n-#ifdef MOZ_XUL\\n-            if (mIsTranslucent)\\n-            {\\n-              // Data from offscreen drawing surface was copied to memory bitmap of transparent\\n-              // bitmap. Now it can be read from memory bitmap to apply alpha channel and after\\n-              // that displayed on the screen.\\n-              UpdateTranslucentWindow();\\n-            }\\n-#endif\\n-          }\\n-\\n-          NS_RELEASE(winrc);\\n-        }\\n-\\n-        NS_RELEASE(event.renderingContext);\\n-      }\\n-      else\\n-        result = PR_FALSE;\\n-#endif\\n-\\n       NS_RELEASE(event.widget);\\n     }\\n   }\\n@@ -8223,7 +7936,6 @@ nsWindow* nsWindow::GetTopLevelWindow()\\n   }\\n }\\n \\n-#ifdef MOZ_CAIRO_GFX\\n gfxASurface *nsWindow::GetThebesSurface()\\n {\\n   if (mPaintDC)\\n@@ -8231,98 +7943,15 @@ gfxASurface *nsWindow::GetThebesSurface()\\n \\n   return (new gfxWindowsSurface(mWnd));\\n }\\n-#endif\\n \\n void nsWindow::ResizeTranslucentWindow(PRInt32 aNewWidth, PRInt32 aNewHeight, PRBool force)\\n {\\n   if (!force && aNewWidth == mBounds.width && aNewHeight == mBounds.height)\\n     return;\\n \\n-#ifdef MOZ_CAIRO_GFX\\n   mTranslucentSurface = new gfxWindowsSurface(gfxIntSize(aNewWidth, aNewHeight), gfxASurface::ImageFormatARGB32);\\n   mMemoryDC = mTranslucentSurface->GetDC();\\n   mMemoryBitmap = NULL;\\n-#else\\n-  // resize the alpha mask\\n-  PRUint8* pBits;\\n-\\n-  if (aNewWidth > 0 && aNewHeight > 0)\\n-  {\\n-    pBits = new PRUint8 [aNewWidth * aNewHeight];\\n-\\n-    if (pBits && mAlphaMask)\\n-    {\\n-      PRInt32 copyWidth, copyHeight;\\n-      PRInt32 growWidth, growHeight;\\n-\\n-      if (aNewWidth > mBounds.width)\\n-      {\\n-        copyWidth = mBounds.width;\\n-        growWidth = aNewWidth - mBounds.width;\\n-      } else\\n-      {\\n-        copyWidth = aNewWidth;\\n-        growWidth = 0;\\n-      }\\n-\\n-      if (aNewHeight > mBounds.height)\\n-      {\\n-        copyHeight = mBounds.height;\\n-        growHeight = aNewHeight - mBounds.height;\\n-      } else\\n-      {\\n-        copyHeight = aNewHeight;\\n-        growHeight = 0;\\n-      }\\n-\\n-      PRUint8* pSrc = mAlphaMask;\\n-      PRUint8* pDest = pBits;\\n-\\n-      for (PRInt32 cy = 0 ; cy < copyHeight ; cy++)\\n-      {\\n-        memcpy(pDest, pSrc, copyWidth);\\n-        memset(pDest + copyWidth, 255, growWidth);\\n-        pSrc += mBounds.width;\\n-        pDest += aNewWidth;\\n-      }\\n-\\n-      for (PRInt32 gy = 0 ; gy < growHeight ; gy++)\\n-      {\\n-        memset(pDest, 255, aNewWidth);\\n-        pDest += aNewWidth;\\n-      }\\n-    }\\n-  } else\\n-    pBits = nsnull;\\n-\\n-  delete [] mAlphaMask;\\n-  mAlphaMask = pBits;\\n-\\n-  if (!mMemoryDC)\\n-    mMemoryDC = ::CreateCompatibleDC(NULL);\\n-\\n-  // Always use at least 24-bit bitmaps regardless of the device context.\\n-  int depth = ::GetDeviceCaps(mMemoryDC, BITSPIXEL);\\n-  if (depth < 24)\\n-    depth = 24;\\n-\\n-  // resize the memory bitmap\\n-  BITMAPINFO bi = { 0 };\\n-  bi.bmiHeader.biSize = sizeof (BITMAPINFOHEADER);\\n-  bi.bmiHeader.biWidth = aNewWidth;\\n-  bi.bmiHeader.biHeight = -aNewHeight;\\n-  bi.bmiHeader.biPlanes = 1;\\n-  bi.bmiHeader.biBitCount = depth;\\n-  bi.bmiHeader.biCompression = BI_RGB;\\n-\\n-  mMemoryBitmap = ::CreateDIBSection(mMemoryDC, &bi, DIB_RGB_COLORS, (void**)&mMemoryBits, NULL, 0);\\n-\\n-  if (mMemoryBitmap)\\n-  {\\n-    HGDIOBJ oldBitmap = ::SelectObject(mMemoryDC, mMemoryBitmap);\\n-    ::DeleteObject(oldBitmap);\\n-  }\\n-#endif\\n }\\n \\n NS_IMETHODIMP nsWindow::GetWindowTranslucency(PRBool& aTranslucent)\\n@@ -8412,15 +8041,7 @@ nsresult nsWindow::SetupTranslucentWindowMemoryBitmap(PRBool aTranslucent)\\n   if (aTranslucent) {\\n     ResizeTranslucentWindow(mBounds.width, mBounds.height, PR_TRUE);\\n   } else {\\n-#ifdef MOZ_CAIRO_GFX\\n     mTranslucentSurface = nsnull;\\n-#else\\n-    if (mMemoryDC)\\n-      ::DeleteDC(mMemoryDC);\\n-    if (mMemoryBitmap)\\n-      ::DeleteObject(mMemoryBitmap);\\n-#endif\\n-\\n     mMemoryDC = NULL;\\n     mMemoryBitmap = NULL;\\n   }\\n@@ -8430,35 +8051,7 @@ nsresult nsWindow::SetupTranslucentWindowMemoryBitmap(PRBool aTranslucent)\\n \\n void nsWindow::UpdateTranslucentWindowAlphaInner(const nsRect& aRect, PRUint8* aAlphas)\\n {\\n-#ifdef MOZ_CAIRO_GFX\\n-  NS_ERROR(\\\"nsWindow::UpdateTranslucentWindowAlphaInner called, when it sholdn't be!\\\");\\n-#else\\n-  NS_ASSERTION(mIsTranslucent, \\\"Window is not transparent\\\");\\n-  NS_ASSERTION(aRect.x >= 0 && aRect.y >= 0 &&\\n-               aRect.XMost() <= mBounds.width && aRect.YMost() <= mBounds.height,\\n-               \\\"Rect is out of window bounds\\\");\\n-\\n-  PRBool transparencyMaskChanged = PR_FALSE;\\n-\\n-  if (!aRect.IsEmpty())\\n-  {\\n-    PRUint8* pSrcRow = aAlphas;\\n-    PRUint8* pDestRow = mAlphaMask + aRect.y * mBounds.width + aRect.x;\\n-\\n-    for (PRInt32 y = 0 ; y < aRect.height ; y++)\\n-    {\\n-      memcpy(pDestRow, pSrcRow, aRect.width);\\n-\\n-      pSrcRow += aRect.width;\\n-      pDestRow += mBounds.width;\\n-    }\\n-  }\\n-\\n-  // Windows 2000 and newer versions support layered windows which allow to implement\\n-  // full 256 level alpha translucency.\\n-  // The real screen update is performed in OnPaint() handler only after rendered\\n-  // bits from offscreen drawing surface are copied back to memory bitmap.\\n-#endif\\n+  NS_ERROR(\\\"nsWindow::UpdateTranslucentWindowAlphaInner called, when it shouldn't be!\\\");\\n }\\n \\n nsresult nsWindow::UpdateTranslucentWindow()\\n@@ -8466,116 +8059,20 @@ nsresult nsWindow::UpdateTranslucentWindow()\\n   if (mBounds.IsEmpty())\\n     return NS_OK;\\n \\n-  nsresult rv = NS_ERROR_FAILURE;\\n-\\n   ::GdiFlush();\\n \\n-  HDC hMemoryDC;\\n-  PRBool needConversion;\\n-\\n-#ifdef MOZ_CAIRO_GFX\\n-\\n-  hMemoryDC = mMemoryDC;\\n-  needConversion = PR_FALSE;\\n-\\n-  rv = NS_OK;\\n-\\n-#else\\n-\\n-  HBITMAP hAlphaBitmap;\\n-  int depth = ::GetDeviceCaps(mMemoryDC, BITSPIXEL);\\n-  if (depth < 24)\\n-    depth = 24;\\n-\\n-  needConversion = (depth == 24);\\n-\\n-  if (needConversion)\\n-  {\\n-    hMemoryDC = ::CreateCompatibleDC(NULL);\\n-\\n-    if (hMemoryDC)\\n-    {\\n-      // Memory bitmap with alpha channel\\n-      BITMAPINFO bi = { 0 };\\n-      bi.bmiHeader.biSize = sizeof (BITMAPINFOHEADER);\\n-      bi.bmiHeader.biWidth = mBounds.width;\\n-      bi.bmiHeader.biHeight = -mBounds.height;\\n-      bi.bmiHeader.biPlanes = 1;\\n-      bi.bmiHeader.biBitCount = 32;\\n-      bi.bmiHeader.biCompression = BI_RGB;\\n-\\n-      PRUint8* pBits32 = nsnull;\\n-      hAlphaBitmap = ::CreateDIBSection(hMemoryDC, &bi, DIB_RGB_COLORS, (void**)&pBits32, NULL, 0);\\n-      \\n-      if (hAlphaBitmap)\\n-      {\\n-        HGDIOBJ oldBitmap = ::SelectObject(hMemoryDC, hAlphaBitmap);\\n-\\n-        PRUint8* pPixel32 = pBits32;\\n-        PRUint8* pAlpha = mAlphaMask;\\n-        PRUint32 rasWidth = RASWIDTH(mBounds.width, 24);\\n-\\n-        for (PRInt32 y = 0 ; y < mBounds.height ; y++)\\n-        {\\n-          PRUint8* pPixel = mMemoryBits + y * rasWidth;\\n-\\n-          for (PRInt32 x = 0 ; x < mBounds.width ; x++)\\n-          {\\n-            *pPixel32++ = *pPixel++;\\n-            *pPixel32++ = *pPixel++;\\n-            *pPixel32++ = *pPixel++;\\n-            *pPixel32++ = *pAlpha++;\\n-          }\\n-        }\\n-\\n-        rv = NS_OK;\\n-      }\\n-    }\\n-  } else\\n-  {\\n-    hMemoryDC = mMemoryDC;\\n-\\n-    if (hMemoryDC)\\n-    {\\n-      PRUint8* pPixel = mMemoryBits + 3;    // Point to alpha component of pixel\\n-      PRUint8* pAlpha = mAlphaMask;\\n-      PRInt32 pixels = mBounds.width * mBounds.height;\\n-\\n-      for (PRInt32 cnt = 0 ; cnt < pixels ; cnt++)\\n-      {\\n-        *pPixel = *pAlpha++;\\n-        pPixel += 4;\\n-      }\\n-\\n-      rv = NS_OK;\\n-    }\\n-  }\\n-#endif /* MOZ_CAIRO_GFX */\\n-\\n-  if (rv == NS_OK)\\n-  {\\n-    BLENDFUNCTION bf = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };\\n-    SIZE winSize = { mBounds.width, mBounds.height };\\n-    POINT srcPos = { 0, 0 };\\n-    HWND hWnd = GetTopLevelHWND(mWnd, PR_TRUE);\\n-    RECT winRect;\\n-    ::GetWindowRect(hWnd, &winRect);\\n-\\n-    // perform the alpha blend\\n-    if (!::UpdateLayeredWindow(hWnd, NULL, (POINT*)&winRect, &winSize, hMemoryDC, &srcPos, 0, &bf, ULW_ALPHA))\\n-      rv = NS_ERROR_FAILURE;\\n-  }\\n-\\n+  BLENDFUNCTION bf = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };\\n+  SIZE winSize = { mBounds.width, mBounds.height };\\n+  POINT srcPos = { 0, 0 };\\n+  HWND hWnd = GetTopLevelHWND(mWnd, PR_TRUE);\\n+  RECT winRect;\\n+  ::GetWindowRect(hWnd, &winRect);\\n \\n-  if (needConversion)\\n-  {\\n-#ifndef MOZ_CAIRO_GFX\\n-    ::DeleteObject(hAlphaBitmap);\\n-#endif\\n-    ::DeleteDC(hMemoryDC);\\n-  }\\n+  // perform the alpha blend\\n+  if (!::UpdateLayeredWindow(hWnd, NULL, (POINT*)&winRect, &winSize, mMemoryDC, &srcPos, 0, &bf, ULW_ALPHA))\\n+    return NS_ERROR_FAILURE;\\n \\n-  return rv;\\n+  return NS_OK;\\n }\\n \\n #endif\\ndiff --git a/widget/src/windows/nsWindow.h b/widget/src/windows/nsWindow.h\\nindex de6c71d..845ed49 100644\\n--- a/widget/src/windows/nsWindow.h\\n+++ b/widget/src/windows/nsWindow.h\\n@@ -490,28 +490,6 @@ protected:\\n   static imgIContainer* gCursorImgContainer;\\n \\n   /**\\n-   * Create a 1 bit mask out of a 8 bit alpha layer.\\n-   *\\n-   * @param aAlphaData        8 bit alpha data\\n-   * @param aAlphaBytesPerRow How many bytes one row of data is\\n-   * @param aWidth            Width of the alpha data, in pixels\\n-   * @param aHeight           Height of the alpha data, in pixels\\n-   *\\n-   * @return 1 bit mask.  Must be delete[]d. On failure, NULL will be returned.\\n-   */\\n-  static PRUint8* Data8BitTo1Bit(PRUint8* aAlphaData, PRUint32 aAlphaBytesPerRow,\\n-                                 PRUint32 aWidth, PRUint32 aHeight);\\n-\\n-  /**\\n-   * Combine the given image data with a separate alpha channel to image data\\n-   * with the alpha channel interleaved with the image data (BGRA).\\n-   *\\n-   * @return BGRA data. Must be delete[]d. On failure, NULL will be returned.\\n-   */\\n-  static PRUint8* DataToAData(PRUint8* aImageData, PRUint32 aImageBytesPerRow,\\n-                              PRUint8* aAlphaData, PRUint32 aAlphaBytesPerRow,\\n-                              PRUint32 aWidth, PRUint32 aHeight);\\n-  /**\\n    * Convert the given image data to a HBITMAP. If the requested depth is\\n    * 32 bit and the OS supports translucency, a bitmap with an alpha channel\\n    * will be returned.\\n@@ -531,16 +509,6 @@ protected:\\n                               PRUint32 aHeight,\\n                               PRUint32 aDepth);\\n \\n-  /**\\n-   * Create a bitmap representing an opaque alpha channel (filled with 0xff).\\n-   * @param aWidth  Desired with of the bitmap\\n-   * @param aHeight Desired height of the bitmap\\n-   * @return        The bitmap. Caller should call DeleteObject when done with\\n-   *                the bitmap. On failure, NULL will be returned.\\n-   */\\n-  static HBITMAP CreateOpaqueAlphaChannel(PRUint32 aWidth, PRUint32 aHeight);\\n-\\n-\\n #ifdef ACCESSIBILITY\\n   static BOOL gIsAccessibilityOn;\\n   static HINSTANCE gmAccLib;\\n\""}