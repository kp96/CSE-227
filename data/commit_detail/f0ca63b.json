{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basf0ca63b\""},"diff":"\"f0ca63b Bug 397134 - Leak involving nsTimerImpl and nsLoadGroup when shutting down less than 1500ms after browsing to a page.  r=tony, a=mconnor\\ndiff --git a/browser/components/safebrowsing/public/nsIDocNavStartProgressListener.idl b/browser/components/safebrowsing/public/nsIDocNavStartProgressListener.idl\\nindex 5066c01..fe73c9f 100644\\n--- a/browser/components/safebrowsing/public/nsIDocNavStartProgressListener.idl\\n+++ b/browser/components/safebrowsing/public/nsIDocNavStartProgressListener.idl\\n@@ -64,8 +64,10 @@ interface nsIDocNavStartProgressListener : nsISupports\\n   attribute PRUint32 delay;\\n \\n   /**\\n-   * Callback object to be used when enabled=true.\\n-   * NULL when there is no callback.\\n+   * The callback, if non-null, used when globalProgressListenerEnabled is\\n+   * true.  Setting this to null has the side effect of unqueueing any pending\\n+   * events for which a callback would be notified; setting it to any other\\n+   * value, however, will not unqueue any events.\\n    */\\n   attribute nsIDocNavStartProgressCallback callback;\\n \\ndiff --git a/browser/components/safebrowsing/src/nsDocNavStartProgressListener.cpp b/browser/components/safebrowsing/src/nsDocNavStartProgressListener.cpp\\nindex 0855044..7ccc8f4 100644\\n--- a/browser/components/safebrowsing/src/nsDocNavStartProgressListener.cpp\\n+++ b/browser/components/safebrowsing/src/nsDocNavStartProgressListener.cpp\\n@@ -75,19 +75,19 @@ nsDocNavStartProgressListener::nsDocNavStartProgressListener() :\\n \\n nsDocNavStartProgressListener::~nsDocNavStartProgressListener()\\n {\\n-  // Clean up items left in our queues.\\n+  ClearPendingEvents();\\n+}\\n+\\n+void\\n+nsDocNavStartProgressListener::ClearPendingEvents()\\n+{\\n   mRequests.Clear();\\n \\n-  // Cancel pending timers.\\n   PRUint32 length = mTimers.Count();\\n-\\n   for (PRUint32 i = 0; i < length; ++i) {\\n     mTimers[i]->Cancel();\\n   }\\n-\\n   mTimers.Clear();\\n-  \\n-  mCallback = nsnull;\\n }\\n \\n // nsDocNavStartProgressListener::AttachListeners\\n@@ -198,6 +198,17 @@ nsDocNavStartProgressListener::SetCallback(\\n     nsIDocNavStartProgressCallback* aCallback)\\n {\\n   mCallback = aCallback;\\n+\\n+  // Break any cycles we have from mTimers to us by clearing all pending\\n+  // requests and timers; the timers we use are not exposed externally, but\\n+  // since we use ourself as an observer with each timer, we have to\\n+  // manually break this cycle to ensure prompt destruction of this and\\n+  // the release of everything this entrains, in the case that we can't wait\\n+  // for all the timers to expire normally for some reason (e.g. application\\n+  // shutdown).\\n+  if (!aCallback)\\n+    ClearPendingEvents();\\n+\\n   return NS_OK;\\n }\\n \\ndiff --git a/browser/components/safebrowsing/src/nsDocNavStartProgressListener.h b/browser/components/safebrowsing/src/nsDocNavStartProgressListener.h\\nindex 1d4f750..bd31f77 100644\\n--- a/browser/components/safebrowsing/src/nsDocNavStartProgressListener.h\\n+++ b/browser/components/safebrowsing/src/nsDocNavStartProgressListener.h\\n@@ -73,6 +73,9 @@ protected:\\n   nsresult AttachListeners();\\n   nsresult DetachListeners();\\n \\n+  // clears mRequests, cancels each timer in mTimer and then clears mTimers\\n+  void ClearPendingEvents();\\n+\\n   // Pull the URI out of the request.\\n   nsresult GetRequestUri(nsIRequest* aReq, nsIURI** uri);\\n };\\n\""}