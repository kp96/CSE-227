{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basa4c907c\""},"diff":"\"a4c907c Bug 378540. GetTextAtOffset() broken for word boundaries. r=surkov, a=dsicore\\ndiff --git a/accessible/src/base/nsARIAMap.cpp b/accessible/src/base/nsARIAMap.cpp\\nindex bd61754..8745ade 100644\\n--- a/accessible/src/base/nsARIAMap.cpp\\n+++ b/accessible/src/base/nsARIAMap.cpp\\n@@ -66,14 +66,11 @@ nsRoleMapEntry nsARIAMap::gWAIRoleMap[] =\\n   {\\\"application\\\", nsIAccessibleRole::ROLE_APPLICATION, eNameLabelOrTitle, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"button\\\", nsIAccessibleRole::ROLE_PUSHBUTTON, eNameOkFromChildren, eNoValue, kNoReqStates,\\n             {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"pressed\\\", kBoolState, nsIAccessibleStates::STATE_PRESSED}, kEndEntry},\\n+            {\\\"pressed\\\", kBoolState, nsIAccessibleStates::STATE_PRESSED},\\n+            {\\\"pressed\\\", \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED}, kEndEntry},\\n   {\\\"checkbox\\\", nsIAccessibleRole::ROLE_CHECKBUTTON, eNameOkFromChildren, eNoValue, nsIAccessibleStates::STATE_CHECKABLE,\\n             {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n             {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED},\\n-            {\\\"readonly\\\", kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n-  {\\\"checkboxtristate\\\", nsIAccessibleRole::ROLE_CHECKBUTTON, eNameOkFromChildren, eNoValue, nsIAccessibleStates::STATE_CHECKABLE,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED},\\n             {\\\"checked\\\", \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED},\\n             {\\\"readonly\\\", kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n   {\\\"columnheader\\\", nsIAccessibleRole::ROLE_COLUMNHEADER, eNameOkFromChildren, eNoValue, kNoReqStates,\\n@@ -116,6 +113,7 @@ nsRoleMapEntry nsARIAMap::gWAIRoleMap[] =\\n             {\\\"selected\\\", kBoolState, nsIAccessibleStates::STATE_SELECTED | nsIAccessibleStates::STATE_SELECTABLE},\\n             {\\\"selected\\\", \\\"false\\\", nsIAccessibleStates::STATE_SELECTABLE},\\n             {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED | nsIAccessibleStates::STATE_CHECKABLE},\\n+            {\\\"checked\\\", \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED | nsIAccessibleStates::STATE_CHECKABLE},\\n             {\\\"checked\\\", \\\"false\\\", nsIAccessibleStates::STATE_CHECKABLE}, kEndEntry},\\n   {\\\"menu\\\", nsIAccessibleRole::ROLE_MENUPOPUP, eNameLabelOrTitle, eNoValue, kNoReqStates,\\n             {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE}, kEndEntry},\\n@@ -124,11 +122,12 @@ nsRoleMapEntry nsARIAMap::gWAIRoleMap[] =\\n   {\\\"menuitem\\\", nsIAccessibleRole::ROLE_MENUITEM, eNameOkFromChildren, eNoValue, kNoReqStates,\\n             {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n             {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED | nsIAccessibleStates::STATE_CHECKABLE},\\n-            {\\\"checked\\\", \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED},\\n+            {\\\"checked\\\", \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED | nsIAccessibleStates::STATE_CHECKABLE},\\n             {\\\"checked\\\", \\\"false\\\", nsIAccessibleStates::STATE_CHECKABLE}, kEndEntry},\\n   {\\\"menuitemcheckbox\\\", nsIAccessibleRole::ROLE_MENUITEM, eNameOkFromChildren, eNoValue, nsIAccessibleStates::STATE_CHECKABLE,\\n             {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED }, kEndEntry},\\n+            {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED },\\n+            {\\\"checked\\\", \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED}, kEndEntry},\\n   {\\\"menuitemradio\\\", nsIAccessibleRole::ROLE_MENUITEM, eNameOkFromChildren, eNoValue, nsIAccessibleStates::STATE_CHECKABLE,\\n             {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n             {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED }, kEndEntry},\\n@@ -137,6 +136,7 @@ nsRoleMapEntry nsARIAMap::gWAIRoleMap[] =\\n             {\\\"selected\\\", kBoolState, nsIAccessibleStates::STATE_SELECTED | nsIAccessibleStates::STATE_SELECTABLE},\\n             {\\\"selected\\\", \\\"false\\\", nsIAccessibleStates::STATE_SELECTABLE},\\n             {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED | nsIAccessibleStates::STATE_CHECKABLE},\\n+            {\\\"checked\\\", \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED | nsIAccessibleStates::STATE_CHECKABLE},\\n             {\\\"checked\\\", \\\"false\\\", nsIAccessibleStates::STATE_CHECKABLE}, kEndEntry},\\n   {\\\"progressbar\\\", nsIAccessibleRole::ROLE_PROGRESSBAR, eNameLabelOrTitle, eHasValueMinMax, nsIAccessibleStates::STATE_READONLY,\\n             {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE}, kEndEntry},\\n@@ -193,7 +193,7 @@ nsRoleMapEntry nsARIAMap::gWAIRoleMap[] =\\n             {\\\"expanded\\\", kBoolState, nsIAccessibleStates::STATE_EXPANDED},\\n             {\\\"expanded\\\", \\\"false\\\", nsIAccessibleStates::STATE_COLLAPSED},\\n             {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED | nsIAccessibleStates::STATE_CHECKABLE},\\n-            {\\\"checked\\\", \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED},\\n+            {\\\"checked\\\", \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED | nsIAccessibleStates::STATE_CHECKABLE},\\n             {\\\"checked\\\", \\\"false\\\", nsIAccessibleStates::STATE_CHECKABLE},},\\n   {nsnull, nsIAccessibleRole::ROLE_NOTHING, eNameLabelOrTitle, eNoValue, kNoReqStates, kEndEntry} // Last item\\n };\\ndiff --git a/accessible/src/base/nsAccessibilityAtomList.h b/accessible/src/base/nsAccessibilityAtomList.h\\nindex 374089b..aa4f8e4 100755\\n--- a/accessible/src/base/nsAccessibilityAtomList.h\\n+++ b/accessible/src/base/nsAccessibilityAtomList.h\\n@@ -164,7 +164,6 @@ ACCESSIBILITY_ATOM(editable, \\\"editable\\\")\\n ACCESSIBILITY_ATOM(_for, \\\"for\\\")\\n ACCESSIBILITY_ATOM(hidden, \\\"hidden\\\")   // XUL tree columns\\n ACCESSIBILITY_ATOM(href, \\\"href\\\")\\n-ACCESSIBILITY_ATOM(id, \\\"id\\\")\\n ACCESSIBILITY_ATOM(increment, \\\"increment\\\") // XUL\\n ACCESSIBILITY_ATOM(lang, \\\"lang\\\")\\n ACCESSIBILITY_ATOM(maxpos, \\\"maxpos\\\") // XUL\\ndiff --git a/accessible/src/base/nsAccessibilityService.cpp b/accessible/src/base/nsAccessibilityService.cpp\\nindex 2288ff2..87d2423 100644\\n--- a/accessible/src/base/nsAccessibilityService.cpp\\n+++ b/accessible/src/base/nsAccessibilityService.cpp\\n@@ -1423,7 +1423,7 @@ NS_IMETHODIMP nsAccessibilityService::GetAccessible(nsIDOMNode *aNode,\\n   // We don't do this for <body>, <html>, <window>, <dialog> etc. which \\n   // correspond to the doc accessible and will be created in any case\\n   if (!newAcc && content->Tag() != nsAccessibilityAtoms::body && content->GetParent() && \\n-      (content->IsFocusable() ||\\n+      (content->IsFocusable() || content->GetID() ||\\n       (isHTML && nsAccUtils::HasListener(content, NS_LITERAL_STRING(\\\"click\\\"))) ||\\n        content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::describedby) ||\\n        content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::labelledby) ||\\ndiff --git a/accessible/src/base/nsAccessibilityUtils.cpp b/accessible/src/base/nsAccessibilityUtils.cpp\\nindex 23dcace..23d9380 100755\\n--- a/accessible/src/base/nsAccessibilityUtils.cpp\\n+++ b/accessible/src/base/nsAccessibilityUtils.cpp\\n@@ -402,3 +402,9 @@ nsAccUtils::GetDocShellTreeItemFor(nsIDOMNode *aNode)\\n   return docShellTreeItem;\\n }\\n \\n+PRBool\\n+nsAccUtils::GetID(nsIContent *aContent, nsAString& aID)\\n+{\\n+  nsIAtom *idAttribute = aContent->GetIDAttributeName();\\n+  return idAttribute ? aContent->GetAttr(kNameSpaceID_None, idAttribute, aID) : PR_FALSE;\\n+}\\ndiff --git a/accessible/src/base/nsAccessibilityUtils.h b/accessible/src/base/nsAccessibilityUtils.h\\nindex b4c9c8d..718d843 100755\\n--- a/accessible/src/base/nsAccessibilityUtils.h\\n+++ b/accessible/src/base/nsAccessibilityUtils.h\\n@@ -180,6 +180,14 @@ public:\\n    */\\n   static already_AddRefed<nsIDocShellTreeItem>\\n     GetDocShellTreeItemFor(nsIDOMNode *aNode);\\n+\\n+  /**\\n+   * Get the ID for an element, in some types of XML this may not be the ID attribute\\n+   * @param aContent  Node to get the ID for\\n+   * @param aID       Where to put ID string\\n+   * @return          PR_TRUE if there is an ID set for this node\\n+   */\\n+  static PRBool GetID(nsIContent *aContent, nsAString& aID);\\n };\\n \\n #endif\\ndiff --git a/accessible/src/base/nsAccessible.cpp b/accessible/src/base/nsAccessible.cpp\\nindex bff9f35..34956a5 100644\\n--- a/accessible/src/base/nsAccessible.cpp\\n+++ b/accessible/src/base/nsAccessible.cpp\\n@@ -1630,11 +1630,10 @@ nsIContent* nsAccessible::GetHTMLLabelContent(nsIContent *aForNode)\\n       // for=\\\"control_id\\\" attribute. To save computing time, only \\n       // look for those inside of a form element\\n       nsAutoString forId;\\n-      aForNode->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::id, forId);\\n-      // Actually we'll be walking down the content this time, with a depth first search\\n-      if (forId.IsEmpty()) {\\n+      if (!nsAccUtils::GetID(aForNode, forId)) {\\n         break;\\n       }\\n+      // Actually we'll be walking down the content this time, with a depth first search\\n       return FindDescendantPointingToID(&forId, walkUpContent,\\n                                         nsAccessibilityAtoms::_for);\\n     }\\n@@ -1701,10 +1700,8 @@ nsAccessible::FindNeighbourPointingToNode(nsIContent *aForNode,\\n                                           PRUint32 aAncestorLevelsToSearch)\\n {\\n   nsCOMPtr<nsIContent> binding;\\n-\\n   nsAutoString controlID;\\n-  aForNode->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::id, controlID);\\n-  if (controlID.IsEmpty()) {\\n+  if (!nsAccUtils::GetID(aForNode, controlID)) {\\n     binding = aForNode->GetBindingParent();\\n     if (binding == aForNode)\\n       return nsnull;\\n@@ -2063,12 +2060,10 @@ nsAccessible::GetAttributes(nsIPersistentProperties **aAttributes)\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n   nsCOMPtr<nsIContent> content = GetRoleContent(mDOMNode);\\n-  if (content) {\\n-    nsAutoString id;\\n+  nsAutoString id;\\n+  if (content && nsAccUtils::GetID(content, id)) {\\n     nsAutoString oldValueUnused;\\n-    if (content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::id, id)) {\\n-      attributes->SetStringProperty(NS_LITERAL_CSTRING(\\\"id\\\"), id, oldValueUnused);    \\n-    }\\n+    attributes->SetStringProperty(NS_LITERAL_CSTRING(\\\"id\\\"), id, oldValueUnused);\\n     // XXX In the future we may need to expose the dynamic content role inheritance chain\\n     // through this attribute\\n     nsAutoString xmlRole;\\ndiff --git a/accessible/src/base/nsDocAccessible.cpp b/accessible/src/base/nsDocAccessible.cpp\\nindex ed2058c..24e5d98 100644\\n--- a/accessible/src/base/nsDocAccessible.cpp\\n+++ b/accessible/src/base/nsDocAccessible.cpp\\n@@ -77,6 +77,8 @@\\n // nsDocAccessible  //\\n //=============================//\\n \\n+PRUint32 nsDocAccessible::gLastFocusedAccessiblesState = 0;\\n+\\n //-----------------------------------------------------\\n // construction\\n //-----------------------------------------------------\\n@@ -919,6 +921,23 @@ nsDocAccessible::AttributeChanged(nsIDocument *aDocument, nsIContent* aContent,\\n                                   PRInt32 aNameSpaceID, nsIAtom* aAttribute,\\n                                   PRInt32 aModType, PRUint32 aStateMask)\\n {\\n+  AttributeChangedImpl(aContent, aNameSpaceID, aAttribute);\\n+\\n+  // If it was the focused node, cache the new state\\n+  nsCOMPtr<nsIDOMNode> targetNode = do_QueryInterface(aContent);\\n+  if (targetNode == gLastFocusedNode) {\\n+    nsCOMPtr<nsIAccessible> focusedAccessible;\\n+    GetAccService()->GetAccessibleFor(targetNode, getter_AddRefs(focusedAccessible));\\n+    if (focusedAccessible) {\\n+      gLastFocusedAccessiblesState = State(focusedAccessible);\\n+    }\\n+  }\\n+}\\n+\\n+\\n+void\\n+nsDocAccessible::AttributeChangedImpl(nsIContent* aContent, PRInt32 aNameSpaceID, nsIAtom* aAttribute)\\n+{\\n   // Fire accessible event after short timer, because we need to wait for\\n   // DOM attribute & resulting layout to actually change. Otherwise,\\n   // assistive technology will retrieve the wrong state/value/selection info.\\n@@ -1087,21 +1106,33 @@ nsDocAccessible::ARIAAttributeChanged(nsIContent* aContent, nsIAtom* aAttribute)\\n     return;\\n   }\\n \\n-  if (aAttribute == nsAccessibilityAtoms::checked) {\\n-    nsCOMPtr<nsIAccessibleStateChangeEvent> event =\\n-      new nsAccStateChangeEvent(targetNode,\\n-                                nsIAccessibleStates::STATE_CHECKED,\\n-                                PR_FALSE);\\n-    FireDelayedAccessibleEvent(event);\\n-    return;\\n-  }\\n-\\n-  if (aAttribute == nsAccessibilityAtoms::pressed) {\\n+  if (aAttribute == nsAccessibilityAtoms::checked ||\\n+      aAttribute == nsAccessibilityAtoms::pressed) {\\n+    const PRUint32 kState = (aAttribute == nsAccessibilityAtoms::checked) ?\\n+                            nsIAccessibleStates::STATE_CHECKED : \\n+                            nsIAccessibleStates::STATE_PRESSED;\\n     nsCOMPtr<nsIAccessibleStateChangeEvent> event =\\n-      new nsAccStateChangeEvent(targetNode,\\n-                                nsIAccessibleStates::STATE_PRESSED,\\n-                                PR_FALSE);\\n+      new nsAccStateChangeEvent(targetNode, kState, PR_FALSE);\\n     FireDelayedAccessibleEvent(event);\\n+    if (targetNode == gLastFocusedNode) {\\n+      // State changes for MIXED state currently only supported for focused item, because\\n+      // otherwise we would need access to the old attribute value in this listener.\\n+      // This is because we don't know if the previous value of aaa:checked or aaa:pressed was \\\"mixed\\\"\\n+      // without caching that info.\\n+      nsCOMPtr<nsIAccessible> accessible;\\n+      event->GetAccessible(getter_AddRefs(accessible));\\n+      if (accessible) {\\n+        PRBool wasMixed = (gLastFocusedAccessiblesState & nsIAccessibleStates::STATE_MIXED) != 0;\\n+        PRBool isMixed  = (State(accessible) & nsIAccessibleStates::STATE_MIXED) != 0;\\n+        if (wasMixed != isMixed) {\\n+          nsCOMPtr<nsIAccessibleStateChangeEvent> event =\\n+            new nsAccStateChangeEvent(targetNode,\\n+                                      nsIAccessibleStates::STATE_MIXED,\\n+                                      PR_FALSE, isMixed);\\n+          FireDelayedAccessibleEvent(event);\\n+        }\\n+      }\\n+    }\\n     return;\\n   }\\n \\ndiff --git a/accessible/src/base/nsDocAccessible.h b/accessible/src/base/nsDocAccessible.h\\nindex c02455b..76d7b6c 100644\\n--- a/accessible/src/base/nsDocAccessible.h\\n+++ b/accessible/src/base/nsDocAccessible.h\\n@@ -149,7 +149,16 @@ class nsDocAccessible : public nsHyperTextAccessibleWrap,\\n     static void ScrollTimerCallback(nsITimer *aTimer, void *aClosure);\\n \\n     /**\\n-     * Fires accessible events when ARIA attribute is chaned.\\n+     * Fires accessible events when attribute is changed.\\n+     *\\n+     * @param aContent - node that attribute is changed for\\n+     * @param aNameSpaceID - namespace of changed attribute\\n+     * @param aAttribute - changed attribute\\n+     */\\n+    void AttributeChangedImpl(nsIContent* aContent, PRInt32 aNameSpaceID, nsIAtom* aAttribute);\\n+\\n+    /**\\n+     * Fires accessible events when ARIA attribute is changed.\\n      *\\n      * @param aContent - node that attribute is changed for\\n      * @param aAttribute - changed attribute\\n@@ -195,6 +204,7 @@ class nsDocAccessible : public nsHyperTextAccessibleWrap,\\n protected:\\n     PRBool mIsAnchor;\\n     PRBool mIsAnchorJumped;\\n+    static PRUint32 gLastFocusedAccessiblesState;\\n \\n private:\\n     static void DocLoadCallback(nsITimer *aTimer, void *aClosure);\\ndiff --git a/accessible/src/base/nsRootAccessible.cpp b/accessible/src/base/nsRootAccessible.cpp\\nindex 2f6ceb1..55b322e 100644\\n--- a/accessible/src/base/nsRootAccessible.cpp\\n+++ b/accessible/src/base/nsRootAccessible.cpp\\n@@ -481,6 +481,7 @@ PRBool nsRootAccessible::FireAccessibleFocusEvent(nsIAccessible *aAccessible,\\n     return PR_FALSE;\\n   }\\n \\n+  gLastFocusedAccessiblesState = State(finalFocusAccessible);\\n   PRUint32 role = Role(finalFocusAccessible);\\n   if (role == nsIAccessibleRole::ROLE_MENUITEM) {\\n     if (!mCurrentARIAMenubar) {  // Entering menus\\ndiff --git a/accessible/src/html/nsHyperTextAccessible.cpp b/accessible/src/html/nsHyperTextAccessible.cpp\\nindex f4f9e0b..e2fb613 100644\\n--- a/accessible/src/html/nsHyperTextAccessible.cpp\\n+++ b/accessible/src/html/nsHyperTextAccessible.cpp\\n@@ -866,6 +866,12 @@ nsresult nsHyperTextAccessible::GetTextHelper(EGetTextType aType, nsAccessibleTe\\n                                        amount, eDirNext, needsStart);\\n     NS_ENSURE_TRUE(endOffset >= 0, NS_ERROR_FAILURE);\\n     if (finalEndOffset == aOffset) {\\n+      if (aType == eGetAt && amount == eSelectWord) { \\n+        // Fix word error for the first character in word: PeekOffset() will return the previous word when \\n+        // aOffset points to the first character of the word, but accessibility APIs want the current word \\n+        // that the first character is in\\n+        return GetTextHelper(eGetAfter, aBoundaryType, aOffset, aStartOffset, aEndOffset, aText);\\n+      }\\n       // This happens sometimes when current character at finalStartOffset \\n       // is an embedded object character representing another hypertext, that\\n       // the AT really needs to dig into separately\\n@@ -873,13 +879,6 @@ nsresult nsHyperTextAccessible::GetTextHelper(EGetTextType aType, nsAccessibleTe\\n     }\\n   }\\n \\n-  // Fix word error for the first character in word: PeekOffset() will return the previous word when \\n-  // aOffset points to the first character of the word, but accessibility APIs want the current word \\n-  // that the first character is in\\n-  if (aType == eGetAt && amount == eSelectWord && aOffset == endOffset) { \\n-    return GetTextHelper(eGetAfter, aBoundaryType, aOffset, aStartOffset, aEndOffset, aText);\\n-  }\\n-\\n   *aStartOffset = finalStartOffset;\\n   *aEndOffset = finalEndOffset;\\n \\n\""}