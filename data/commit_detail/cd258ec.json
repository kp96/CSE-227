{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bascd258ec\""},"diff":"\"cd258ec Bookmarks sync extension - initial import\\ndiff --git a/services/sync/nsBookmarksSyncService.js b/services/sync/nsBookmarksSyncService.js\\nnew file mode 100644\\nindex 0000000..ff58101\\n--- /dev/null\\n+++ b/services/sync/nsBookmarksSyncService.js\\n@@ -0,0 +1,672 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Places.\\n+ *\\n+ * The Initial Developer of the Original Code is Mozilla.\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *  Dan Mills <thunder@mozilla.com>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+\\n+const Cc = Components.classes;\\n+const Ci = Components.interfaces;\\n+const Cr = Components.results;\\n+const Cu = Components.utils;\\n+\\n+Cu.import(\\\"resource://gre/modules/XPCOMUtils.jsm\\\");\\n+\\n+function BookmarksSyncService() { this._init(); }\\n+BookmarksSyncService.prototype = {\\n+\\n+  __bms: null,\\n+  get _bms() {\\n+    if (!this.__bms)\\n+      this.__bms = Cc[\\\"@mozilla.org/browser/nav-bookmarks-service;1\\\"].\\n+                   getService(Ci.nsINavBookmarksService);\\n+    return this.__bms;\\n+  },\\n+\\n+  __hsvc: null,\\n+  get _hsvc() {\\n+    if (!this.__hsvc)\\n+      this.__hsvc = Cc[\\\"@mozilla.org/browser/nav-history-service;1\\\"].\\n+                    getService(Ci.nsINavHistoryService);\\n+    return this.__hsvc;\\n+  },\\n+\\n+  __ans: null,\\n+  get _ans() {\\n+    if (!this.__ans)\\n+      this.__ans = Cc[\\\"@mozilla.org/browser/annotation-service;1\\\"].\\n+                   getService(Ci.nsIAnnotationService);\\n+    return this.__ans;\\n+  },\\n+\\n+  // DAVCollection object\\n+  _dav: null,\\n+\\n+  // sync.js\\n+  _sync: {},\\n+\\n+  // PlacesUtils\\n+  _utils: {},\\n+\\n+  // Last synced tree\\n+  // FIXME: this should be serialized to disk\\n+  _snapshot: {},\\n+  _snapshotVersion: 0,\\n+\\n+  _init: function BSS__init() {\\n+\\n+    var serverUrl = \\\"http://sync.server.url/\\\";\\n+    try {\\n+      var branch = Cc[\\\"@mozilla.org/preferences-service;1\\\"].\\n+        getService(Ci.nsIPrefBranch);\\n+      serverUrl = branch.getCharPref(\\\"browser.places.sync.serverUrl\\\");\\n+    }\\n+    catch (ex) { /* use defaults */ }\\n+    LOG(\\\"Bookmarks sync server: \\\" + serverUrl);\\n+    this._dav = new DAVCollection(serverUrl);\\n+\\n+    var jsLoader = Cc[\\\"@mozilla.org/moz/jssubscript-loader;1\\\"].\\n+      getService(Ci.mozIJSSubScriptLoader);\\n+    jsLoader.loadSubScript(\\\"chrome://sync/content/sync-engine.js\\\", this._sync);\\n+    jsLoader.loadSubScript(\\\"chrome://browser/content/places/utils.js\\\", this._utils);\\n+  },\\n+\\n+  _applyCommands: function BSS__applyCommands(node, commandList) {\\n+    for (var i = 0; i < commandList.length; i++) {\\n+      var command = commandList[i];\\n+      LOG(\\\"Processing command: \\\" + uneval(command));\\n+      switch (command[\\\"action\\\"]) {\\n+      case \\\"create\\\":\\n+        this._createCommand(node, this._snapshot, command);\\n+        break;\\n+      case \\\"remove\\\":\\n+        this._removeCommand(node, command);\\n+        break;\\n+      case \\\"edit\\\":\\n+        this._editCommand(node, command);\\n+        break;\\n+      default:\\n+        LOG(\\\"unknown action in command: \\\" + command[\\\"action\\\"]);\\n+        break;\\n+      }\\n+    }\\n+  },\\n+\\n+  _nodeFromPath: function BSS__nodeFromPath (aNodeRoot, aPath) {\\n+    var node = aNodeRoot;\\n+    for (var i = 0; i < aPath.length; i = i + 2) {\\n+      if (aPath[i] != \\\"children\\\")\\n+        break;\\n+      node.QueryInterface(Ci.nsINavHistoryQueryResultNode);\\n+      var openState = node.containerOpen;\\n+      node.containerOpen = true;\\n+      node = node.getChild(aPath[i + 1]);\\n+      //node.containerOpen = openState; // fixme?\\n+    }\\n+    return node;\\n+  },\\n+\\n+  _createCommand: function BSS__createCommand(aNode, aJsonNode, aCommand) {\\n+    var path = aCommand[\\\"path\\\"];\\n+    if (path[path.length - 2] != \\\"children\\\")\\n+      path = aCommand[\\\"path\\\"].slice(0, path.length - 1);\\n+\\n+    var json = this._sync.pathToReference(aJsonNode, path);\\n+    if (json[\\\"_done\\\"] == true)\\n+      return;\\n+    json[\\\"_done\\\"] = true;\\n+\\n+    var index = path[path.length - 1];\\n+    var node = this._nodeFromPath(aNode, path.slice(0, path.length - 2));\\n+\\n+    switch (json[\\\"type\\\"]) {\\n+    case 0:\\n+      LOG(\\\"  -> creating a bookmark: '\\\" + json[\\\"title\\\"] + \\\"' -> \\\" + json[\\\"uri\\\"]);\\n+      this._bms.insertBookmark(node.itemId, makeURI(json[\\\"uri\\\"]), index, json[\\\"title\\\"]);\\n+      break;\\n+    case 6:\\n+      LOG(\\\"  -> creating a folder: '\\\" + json[\\\"title\\\"] + \\\"'\\\");\\n+      this._bms.createFolder(node.itemId, json[\\\"title\\\"], index);\\n+      break;\\n+    case 7:\\n+      LOG(\\\"  -> creating a separator\\\");\\n+      this._bms.insertSeparator(node.itemId, index);\\n+      break;\\n+    default:\\n+      LOG(\\\"createCommand: Unknown item type: \\\" + json[\\\"type\\\"]);\\n+      break;\\n+    }\\n+  },\\n+\\n+  _removeCommand: function BSS__removeCommand(node, command) {\\n+    if (command[\\\"path\\\"].length == 0) {\\n+      LOG(\\\"removing item\\\");\\n+      switch (node.type) {\\n+      case node.RESULT_TYPE_URI:\\n+        // FIXME: check it's an actual bookmark?\\n+        this._bms.removeItem(node.itemId);\\n+        break;\\n+      case node.RESULT_TYPE_FOLDER:\\n+        this._bms.removeFolder(node.itemId);\\n+        break;\\n+      case node.RESULT_TYPE_SEPARATOR:\\n+        this._bms.removeItem(node.itemId);\\n+        break;\\n+      default:\\n+        LOG(\\\"removeCommand: Unknown item type: \\\" + node.type);\\n+        break;\\n+      }\\n+    } else if (command[\\\"path\\\"].shift() == \\\"children\\\") {\\n+      if (command[\\\"path\\\"].length == 0) {\\n+        LOG(\\\"invalid command?\\\");\\n+        return;\\n+      }\\n+\\n+      var index = command[\\\"path\\\"].shift();\\n+\\n+      node.QueryInterface(Ci.nsINavHistoryQueryResultNode);\\n+      var openState = node.containerOpen;\\n+      node.containerOpen = true;\\n+      this._removeCommand(node.getChild(index), command);\\n+      node.containerOpen = openState;\\n+    }\\n+  },\\n+\\n+  _editCommand: function BSS__editCommand(node, command) {\\n+    switch (command[\\\"path\\\"].shift()) {\\n+    case \\\"children\\\":\\n+      node.QueryInterface(Ci.nsINavHistoryQueryResultNode);\\n+      var openState = node.containerOpen;\\n+      node.containerOpen = true;\\n+      this._editCommand(node.getChild(command[\\\"path\\\"].shift()), command);\\n+      node.containerOpen = openState;\\n+      break;\\n+    case \\\"type\\\":\\n+      LOG(\\\"Can't change item type!\\\"); // FIXME: is this valid?\\n+      break;\\n+    case \\\"title\\\":\\n+      this._bms.setItemTitle(node.itemId, command[\\\"value\\\"]);\\n+      break;\\n+    case \\\"uri\\\":\\n+      this._bms.changeBookmarkURI(node.itemId, makeURI(command[\\\"value\\\"]));\\n+      break;\\n+    }\\n+  },\\n+\\n+  // FIXME - hack to make sure we have Commands, not just eval'ed hashes\\n+  _sanitizeCommands: function BSS__sanitizeCommands(hashes) {\\n+    var commands = [];\\n+    for (var i = 0; i < hashes.length; i++) {\\n+      commands.push(new this._sync.Command(hashes[i][\\\"action\\\"],\\n+                                           hashes[i][\\\"path\\\"],\\n+                                           hashes[i][\\\"value\\\"]));\\n+    }\\n+    return commands;\\n+  },\\n+\\n+  _getLocalBookmarks: function BMS__getLocalBookmarks() {\\n+    var query = this._hsvc.getNewQuery();\\n+    query.setFolders([this._bms.bookmarksRoot], 1);\\n+    return this._hsvc.executeQuery(query, this._hsvc.getNewQueryOptions()).root;\\n+  },\\n+\\n+  // FIXME: temp version here because we can't yet get to PlacesUtils.wrapNode\\n+  _wrapNode: function BSS__wrapNode(node) {\\n+    //var guid = this._bms.getItemGuid(node.itemId);\\n+    var item = {\\\"type\\\": node.type}; //,\\n+    //                \\\"guid\\\": guid};\\n+\\n+    if (node.type == node.RESULT_TYPE_FOLDER) {\\n+      node.QueryInterface(Ci.nsINavHistoryQueryResultNode);\\n+      var openState = node.containerOpen;\\n+      node.containerOpen = true;\\n+      var children = [];\\n+      for (var i = 0; i < node.childCount; i++) {\\n+        children.push(this._wrapNode(node.getChild(i)));\\n+      }\\n+      item[\\\"children\\\"] = children;\\n+      item[\\\"title\\\"] = node.title;\\n+      node.containerOpen = openState;\\n+    } else if (node.type == node.RESULT_TYPE_SEPARATOR) {\\n+    } else if (node.type == node.RESULT_TYPE_URI) {\\n+      // FIXME: need to verify that it's a bookmark, it could be a history result!\\n+      item[\\\"title\\\"] = node.title;\\n+      item[\\\"uri\\\"] = node.uri;\\n+    } else {\\n+      // what do we do?\\n+    }\\n+\\n+    return item;\\n+  },\\n+\\n+  // 1) Fetch server deltas\\n+  // 1.1) Construct current server status from snapshot + server deltas\\n+  // 1.2) Generate single delta from snapshot -> current server status\\n+  // 2) Generate local deltas from snapshot -> current client status\\n+  // 3) Reconcile client/server deltas and generate new deltas for them.\\n+  // 3.1) Apply local delta with server changes\\n+  // 3.2) Append server delta to the delta file and upload\\n+\\n+  _doSync: function BSS__doSync() {\\n+    var generator = yield;\\n+    var handlers = this._handlersForGenerator(generator);\\n+\\n+    LOG(\\\"Beginning sync\\\");\\n+\\n+    try {\\n+      //this._dav.lock(handlers);\\n+      //var data = yield;\\n+      var data;\\n+\\n+      var localBookmarks = this._getLocalBookmarks();\\n+      var localJson = this._wrapNode(localBookmarks);\\n+\\n+      // 1) Fetch server deltas\\n+      asyncRun(bind2(this, this._getServerData), handlers['complete'], localJson);\\n+      var server = yield;\\n+\\n+      if (server['status'] == 2) {\\n+        LOG(\\\"Sync complete\\\");\\n+        return;\\n+      } else if (server['status'] != 0 && server['status'] != 1) {\\n+        LOG(\\\"Sync error\\\");\\n+        return;\\n+      }\\n+\\n+      // 2) Generate local deltas from snapshot -> current client status\\n+      LOG(\\\"Generating local updates\\\");\\n+      var localUpdates = this._sanitizeCommands(this._sync.detectUpdates(this._snapshot, localJson));\\n+\\n+      // 3) Reconcile client/server deltas and generate new deltas for them.\\n+\\n+      if (!(server['status'] == 1 || localUpdates.length > 0)) {\\n+        LOG(\\\"Sync complete: no changes needed on client or server\\\");\\n+        return;\\n+      }\\n+\\n+      var propagations = [server['updates'], localUpdates];\\n+\\n+      if (server['status'] == 1 && localUpdates.length > 0) {\\n+        LOG(\\\"Reconciling updates\\\");\\n+        var propagations = this._sync.reconcile([localUpdates, server['updates']]);\\n+      }\\n+      LOG(\\\"Local:\\\" + uneval(propagations[0]));\\n+      LOG(\\\"To server:\\\" + uneval(propagations[1]));\\n+\\n+      LOG(\\\"Local snapshot version: \\\" + this._snapshotVersion);\\n+      LOG(\\\"Latest server version: \\\" + server['version']);\\n+      this._snapshotVersion = server['version'];\\n+\\n+      if (!(propagations[0].length || propagations[1].length)) {\\n+        this._snapshot = this._wrapNode(localBookmarks);\\n+        LOG(\\\"Sync complete: no changes needed on client or server\\\");\\n+        return;\\n+      }\\n+\\n+      // 3.1) Apply server changes to local store\\n+      if (propagations[0].length) {\\n+        LOG(\\\"Applying changes locally\\\");\\n+        localBookmarks = this._getLocalBookmarks(); // fixme: wtf\\n+        this._snapshot = this._wrapNode(localBookmarks);\\n+        // applyCommands changes the imput commands, so we eval(uneval()) them to make a copy :-/\\n+        this._sync.applyCommands(this._snapshot, eval(uneval(propagations[0])));\\n+        this._applyCommands(localBookmarks, propagations[0]);\\n+        this._snapshot = this._wrapNode(localBookmarks);\\n+      }\\n+\\n+      // 3.2) Append server delta to the delta file and upload\\n+      if (propagations[1].length) {\\n+        LOG(\\\"Uploading changes to server\\\");\\n+        this._snapshotVersion++;\\n+        server['deltas'][this._snapshotVersion] = propagations[1];\\n+        this._dav.PUT(\\\"bookmarks.delta\\\", uneval(server['deltas']), handlers);\\n+        data = yield;\\n+\\n+        if (data.target.status >= 200 || data.target.status < 300)\\n+          LOG(\\\"Successfully updated deltas on server\\\");\\n+        else\\n+          LOG(\\\"Error: could not update deltas on server\\\");\\n+      }\\n+\\n+      LOG(\\\"Sync complete\\\");\\n+    } finally {\\n+      //this._dav.unlock(handlers);\\n+      //data = yield;\\n+    }\\n+  },\\n+\\n+\\n+  /* Get the deltas/combined updates from the server\\n+   * Returns:\\n+   *   status:\\n+   *     -1: error\\n+   *      0: no changes from server\\n+   *      1: ok\\n+   *      2: ok, initial sync\\n+   *   version:\\n+   *     the latest version on the server\\n+   *   deltas:\\n+   *     the individual deltas on the server\\n+   *   updates:\\n+   *     the relevant deltas (from our snapshot version to current),\\n+   *     combined into a single set.\\n+   */\\n+  _getServerData: function BSS__getServerData(onComplete, localJson) {\\n+    var generator = yield;\\n+    var handlers = this._handlersForGenerator(generator);\\n+\\n+    var ret = {status: -1, version: -1, deltas: null, updates: null};\\n+\\n+    LOG(\\\"Getting bookmarks delta from server\\\");\\n+    this._dav.GET(\\\"bookmarks.delta\\\", handlers);\\n+    var data = yield;\\n+\\n+    switch (data.target.status) {\\n+    case 200:\\n+      LOG(\\\"Got bookmarks delta from server\\\");\\n+\\n+      ret.deltas = eval(data.target.responseText);\\n+      var tmp = eval(uneval(this._snapshot)); // fixme hack hack hack\\n+\\n+      if (ret.deltas[this._snapshotVersion + 1]) {\\n+        // Merge the matching deltas into one, find highest version\\n+        var keys = [];\\n+        for (var v in ret.deltas) {\\n+          if (v > this._snapshotVersion)\\n+            keys.push(v);\\n+          if (v > ret.version)\\n+            ret.version = v;\\n+        }\\n+        keys = keys.sort();\\n+        for (var i = 0; i < keys.length; i++) {\\n+          this._sync.applyCommands(tmp, this._sanitizeCommands(ret.deltas[keys[i]]));\\n+        }\\n+        ret.status = 1;\\n+        ret.updates = this._sync.detectUpdates(this._snapshot, tmp);\\n+\\n+      } else if (ret.deltas[this._snapshotVersion]) {\\n+        LOG(\\\"No changes from server\\\");\\n+        ret.status = 0;\\n+        ret.version = this._snapshotVersion;\\n+        ret.updates = [];\\n+\\n+      } else {\\n+        LOG(\\\"Server delta can't update from our snapshot version, getting full file\\\");\\n+        // generate updates from full local->remote snapshot diff\\n+        asyncRun(bind2(this, this._getServerUpdatesFull), handlers['complete'], localJson);\\n+        data = yield;\\n+        if (data.status == 2) {\\n+          // we have a delta file but no snapshot on the server.  bad.\\n+          // fixme?\\n+          LOG(\\\"Error: Delta file on server, but snapshot file missing.  New snapshot uploaded, may be inconsistent with deltas!\\\");\\n+        }\\n+\\n+        var tmp = eval(uneval(this._snapshot)); // fixme hack hack hack\\n+        this._sync.applyCommands(tmp, this._sanitizeCommands(data.updates));\\n+\\n+        // fixme: this is duplicated from above, need to do some refactoring\\n+\\n+        var keys = [];\\n+        for (var v in ret.deltas) {\\n+          if (v > this._snapshotVersion)\\n+            keys.push(v);\\n+          if (v > ret.version)\\n+            ret.version = v;\\n+        }\\n+        keys = keys.sort();\\n+        for (var i = 0; i < keys.length; i++) {\\n+          this._sync.applyCommands(tmp, this._sanitizeCommands(ret.deltas[keys[i]]));\\n+        }\\n+\\n+        ret.status = data.status;\\n+        ret.updates = this._sync.detectUpdates(this._snapshot, tmp);\\n+        ret.version = data.version;\\n+        var keys = [];\\n+        for (var v in ret.deltas) {\\n+          if (v > ret.version)\\n+            ret.version = v;\\n+        }\\n+      }\\n+      break;\\n+    case 404:\\n+      LOG(\\\"Server has no delta file.  Getting full bookmarks file from server\\\");\\n+      // generate updates from full local->remote snapshot diff\\n+      asyncRun(bind2(this, this._getServerUpdatesFull), handlers['complete'], localJson);\\n+      ret = yield;\\n+      ret.deltas = {};\\n+      break;\\n+    default:\\n+      LOG(\\\"Could not get bookmarks.delta: unknown HTTP status code \\\" + data.target.status);\\n+      break;\\n+    }\\n+    onComplete(ret);\\n+  },\\n+\\n+  _getServerUpdatesFull: function BSS__getServerUpdatesFull(onComplete, localJson) {\\n+    var generator = yield;\\n+    var handlers = this._handlersForGenerator(generator);\\n+\\n+    var ret = {status: -1, version: -1, updates: null};\\n+\\n+    this._dav.GET(\\\"bookmarks.json\\\", handlers);\\n+    data = yield;\\n+\\n+    switch (data.target.status) {\\n+    case 200:\\n+      LOG(\\\"Got full bookmarks file from server\\\");\\n+      var tmp = eval(data.target.responseText);\\n+      ret.status = 1;\\n+      ret.updates = this._sync.detectUpdates(this._snapshot, tmp.snapshot);\\n+      ret.version = tmp.version;\\n+      break;\\n+    case 404:\\n+      LOG(\\\"No bookmarks on server.  Starting initial sync to server\\\");\\n+\\n+      this._snapshot = localJson;\\n+      this._snapshotVersion = 1;\\n+      this._dav.PUT(\\\"bookmarks.json\\\", uneval({version: 1, snapshot: this._snapshot}), handlers);\\n+      data = yield;\\n+\\n+      if (data.target.status >= 200 || data.target.status < 300) {\\n+        LOG(\\\"Initial sync to server successful\\\");\\n+        ret.status = 2;\\n+      } else {\\n+        LOG(\\\"Initial sync to server failed\\\");\\n+      }\\n+      break;\\n+    default:\\n+      LOG(\\\"Could not get bookmarks.json: unknown HTTP status code \\\" + data.target.status);\\n+      break;\\n+    }\\n+    onComplete(ret);\\n+  },\\n+\\n+  _handlersForGenerator: function BSS__handlersForGenerator(generator) {\\n+    var h = {load: bind2(this, function(event) { handleEvent(generator, event); }),\\n+             error: bind2(this, function(event) { LOG(\\\"Request failed: \\\" + uneval(event)); })};\\n+    h['complete'] = h['load'];\\n+    return h;\\n+  },\\n+\\n+  // Interfaces this component implements.\\n+  interfaces: [Ci.nsIBookmarksSyncService, Ci.nsISupports],\\n+\\n+  // nsISupports\\n+\\n+  // XPCOM registration\\n+  classDescription: \\\"Bookmarks Sync Service\\\",\\n+  contractID: \\\"@mozilla.org/places/sync-service;1\\\",\\n+  classID: Components.ID(\\\"{6efd73bf-6a5a-404f-9246-f70a1286a3d6}\\\"),\\n+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIBookmarksSyncService, Ci.nsISupports]),\\n+\\n+  // nsIBookmarksSyncService\\n+\\n+  sync: function BSS_sync() { asyncRun(bind2(this, this._doSync)); }\\n+};\\n+\\n+function asyncRun(func, handler, data) {\\n+  var generator = func(handler, data);\\n+  generator.next();\\n+  generator.send(generator);\\n+}\\n+\\n+function handleEvent(generator, data) {\\n+  try { generator.send(data); }\\n+  catch (e) {\\n+    if (e instanceof StopIteration)\\n+      generator = null;\\n+    else\\n+\\tthrow e;\\n+  }\\n+}\\n+\\n+function EventListener(handler) {\\n+  this._handler = handler;\\n+}\\n+EventListener.prototype = {\\n+  handleEvent: function EL_handleEvent(event) {\\n+    this._handler(event);\\n+  }\\n+};\\n+\\n+function DAVCollection(baseUrl) {\\n+  this._baseUrl = baseUrl;\\n+}\\n+DAVCollection.prototype = {\\n+  _addHandler: function DC__addHandler(request, handlers, eventName) {\\n+    if (handlers[eventName])\\n+      request.addEventListener(eventName, new EventListener(handlers[eventName]), false);\\n+  },\\n+  _makeRequest: function DC__makeRequest(op, path, handlers, headers) {\\n+    var request = Cc[\\\"@mozilla.org/xmlextras/xmlhttprequest;1\\\"].createInstance();\\n+    request = request.QueryInterface(Ci.nsIDOMEventTarget);\\n+  \\n+    if (!handlers)\\n+      handlers = {};\\n+    this._addHandler(request, handlers, \\\"load\\\");\\n+    this._addHandler(request, handlers, \\\"error\\\");\\n+  \\n+    request = request.QueryInterface(Ci.nsIXMLHttpRequest);\\n+    request.open(op, this._baseUrl + path, true);\\n+  \\n+    if (headers) {\\n+      for (var key in headers) {\\n+        request.setRequestHeader(key, headers[key]);\\n+      }\\n+    }\\n+\\n+    return request;\\n+  },\\n+  GET: function DC_GET(path, handlers, headers) {\\n+    if (!headers)\\n+      headers = {'Content-type': 'text/plain'};\\n+    var request = this._makeRequest(\\\"GET\\\", path, handlers, headers);\\n+    request.send(null);\\n+  },\\n+  PUT: function DC_PUT(path, data, handlers, headers) {\\n+    if (!headers)\\n+      headers = {'Content-type': 'text/plain'};\\n+    var request = this._makeRequest(\\\"PUT\\\", path, handlers, headers);\\n+    request.send(data);\\n+  },\\n+  _runLockHandler: function DC__runLockHandler(name, event) {\\n+    if (this._lockHandlers && this._lockHandlers[name])\\n+      this._lockHandlers[name](event);\\n+  },\\n+  // FIXME: make this function not reentrant\\n+  lock: function DC_lock(handlers) {\\n+    this._lockHandlers = handlers;\\n+    internalHandlers = {load: bind2(this, this._onLock),\\n+                        error: bind2(this, this._onLockError)};\\n+    headers = {'Content-Type': 'text/xml; charset=\\\"utf-8\\\"'};\\n+    var request = this._makeRequest(\\\"LOCK\\\", \\\"\\\", internalHandlers, headers);\\n+    request.send(\\\"<?xml version=\\\\\\\"1.0\\\\\\\" encoding=\\\\\\\"utf-8\\\\\\\" ?>\\\\n\\\" +\\n+                 \\\"<D:lockinfo xmlns:D=\\\\\\\"DAV:\\\\\\\">\\\\n\\\" +\\n+                 \\\"  <D:locktype><D:write/></D:locktype>\\\\n\\\" +\\n+                 \\\"  <D:lockscope><D:exclusive/></D:lockscope>\\\\n\\\" +\\n+                 \\\"</D:lockinfo>\\\");\\n+  },\\n+  _onLock: function DC__onLock(event) {\\n+    LOG(\\\"acquired lock (\\\" + event.target.status + \\\"):\\\\n\\\" + event.target.responseText + \\\"\\\\n\\\");\\n+    this._token = \\\"woo\\\";\\n+    this._runLockHandler(\\\"load\\\", event);\\n+  },\\n+  _onLockError: function DC__onLockError(event) {\\n+    LOG(\\\"lock failed (\\\" + event.target.status + \\\"):\\\\n\\\" + event.target.responseText + \\\"\\\\n\\\");\\n+    this._runLockHandler(\\\"error\\\", event);\\n+  },\\n+  // FIXME: make this function not reentrant\\n+  unlock: function DC_unlock(handlers) {\\n+    this._lockHandlers = handlers;\\n+    internalHandlers = {load: bind2(this, this._onUnlock),\\n+                        error: bind2(this, this._onUnlockError)};\\n+    headers = {'Lock-Token': \\\"<\\\" + this._token + \\\">\\\"};\\n+    var request = this._makeRequest(\\\"UNLOCK\\\", \\\"\\\", internalHandlers, headers);\\n+    request.send(null);\\n+  },\\n+  _onUnlock: function DC__onUnlock(event) {\\n+    LOG(\\\"removed lock (\\\" + event.target.status + \\\"):\\\\n\\\" + event.target.responseText + \\\"\\\\n\\\");\\n+    this._token = null;\\n+    this._runLockHandler(\\\"load\\\", event);\\n+  },\\n+  _onUnlockError: function DC__onUnlockError(event) {\\n+    LOG(\\\"unlock failed (\\\" + event.target.status + \\\"):\\\\n\\\" + event.target.responseText + \\\"\\\\n\\\");\\n+    this._runLockHandler(\\\"error\\\", event);\\n+  },\\n+};\\n+\\n+function makeFile(path) {\\n+  var file = Cc[\\\"@mozilla.org/file/local;1\\\"].createInstance(Ci.nsILocalFile);\\n+  file.initWithPath(path);\\n+  return file;\\n+}\\n+\\n+function makeURI(uriString) {\\n+  var ioservice = Cc[\\\"@mozilla.org/network/io-service;1\\\"].\\n+                  getService(Ci.nsIIOService);\\n+  return ioservice.newURI(uriString, null, null);\\n+}\\n+\\n+function bind2(object, method) {\\n+  return function innerBind() { return method.apply(object, arguments); }\\n+}\\n+\\n+function LOG(aText) {\\n+  dump(aText + \\\"\\\\n\\\");\\n+  var consoleService = Cc[\\\"@mozilla.org/consoleservice;1\\\"].\\n+                       getService(Ci.nsIConsoleService);\\n+  consoleService.logStringMessage(aText);\\n+}\\n+\\n+function NSGetModule(compMgr, fileSpec) {\\n+  return XPCOMUtils.generateModule([BookmarksSyncService]);\\n+}\\ndiff --git a/services/sync/nsIBookmarksSyncService.idl b/services/sync/nsIBookmarksSyncService.idl\\nnew file mode 100644\\nindex 0000000..f7ad26c\\n--- /dev/null\\n+++ b/services/sync/nsIBookmarksSyncService.idl\\n@@ -0,0 +1,45 @@\\n+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Places.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Mozilla Corp.\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *   Dan Mills <thunder@mozilla.com>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+\\n+#include \\\"nsISupports.idl\\\"\\n+\\n+[scriptable, uuid(1f00216a-4d2d-40e8-b4c5-afa3338a2d6c)]\\n+interface nsIBookmarksSyncService : nsISupports\\n+{\\n+  void sync();\\n+};\\ndiff --git a/services/sync/xptgen b/services/sync/xptgen\\nnew file mode 100755\\nindex 0000000..84eba2b\\n--- /dev/null\\n+++ b/services/sync/xptgen\\n@@ -0,0 +1,2 @@\\n+#!/bin/bash\\n+../../mozilla-trunk/obj/firefox/dist/bin/xpidl -m typelib -I ../../mozilla-trunk/mozilla/xpcom/base/ -o nsIBookmarksSyncService nsIBookmarksSyncService.idl\\n\""}