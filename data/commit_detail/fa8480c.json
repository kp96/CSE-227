{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basfa8480c\""},"diff":"\"fa8480c Back-out due to test failure.\\ndiff --git a/dom/src/base/nsJSEnvironment.cpp b/dom/src/base/nsJSEnvironment.cpp\\nindex 0d7f9da..4ab94b0 100644\\n--- a/dom/src/base/nsJSEnvironment.cpp\\n+++ b/dom/src/base/nsJSEnvironment.cpp\\n@@ -2257,10 +2257,9 @@ nsJSContext::InitContext(nsIScriptGlobalObject *aGlobalObject)\\n     PRUint32 flags = 0;\\n     \\n     if (chromeWindow) {\\n-      // Flag this context and scripts compiled against it as \\\"system\\\", for\\n+      // Flag this object and scripts compiled against it as \\\"system\\\", for\\n       // optional automated XPCNativeWrapper construction when chrome views\\n       // a content DOM.\\n-      ::JS_FlagSystemContext(mContext);\\n       flags = nsIXPConnect::FLAG_SYSTEM_GLOBAL_OBJECT;\\n \\n       // Always enable E4X for XUL and other chrome content -- there is no\\ndiff --git a/js/src/jscntxt.h b/js/src/jscntxt.h\\nindex 2db4c3d..fa3a47c 100644\\n--- a/js/src/jscntxt.h\\n+++ b/js/src/jscntxt.h\\n@@ -643,10 +643,10 @@ struct JSContext {\\n      * property values associated with this context's global object.\\n      */\\n     uint8               xmlSettingFlags;\\n-#else\\n     uint8               padding;\\n+#else\\n+    uint16              padding;\\n #endif\\n-    uint8               gcDefaultFlags;\\n \\n     /* Runtime version control identifier. */\\n     uint16              version;\\ndiff --git a/js/src/jsdbgapi.c b/js/src/jsdbgapi.c\\nindex 093c7b2..8e6ef22 100644\\n--- a/js/src/jsdbgapi.c\\n+++ b/js/src/jsdbgapi.c\\n@@ -1632,9 +1632,12 @@ JS_IsSystemObject(JSContext *cx, JSObject *obj)\\n }\\n \\n JS_PUBLIC_API(void)\\n-JS_FlagSystemContext(JSContext *cx)\\n+JS_FlagSystemObject(JSContext *cx, JSObject *obj)\\n {\\n-    cx->gcDefaultFlags = GCF_SYSTEM;\\n+    uint8 *flagp;\\n+\\n+    flagp = js_GetGCThingFlags(obj);\\n+    *flagp |= GCF_SYSTEM;\\n }\\n \\n /************************************************************************/\\ndiff --git a/js/src/jsdbgapi.h b/js/src/jsdbgapi.h\\nindex d3f4f5d..4b904f2 100644\\n--- a/js/src/jsdbgapi.h\\n+++ b/js/src/jsdbgapi.h\\n@@ -393,25 +393,22 @@ JS_FlagScriptFilenamePrefix(JSRuntime *rt, const char *prefix, uint32 flags);\\n #define JSFILENAME_SYSTEM       0x00000001      /* \\\"system\\\" script, see below */\\n \\n /*\\n- * Return true if obj is a \\\"system\\\" object, that is, one parented by a system\\n- * object, or if obj's parent is null, one created on a context flagged as a\\n- * system context by JS_FlagSystemContext.\\n- *\\n- * What \\\"system\\\" means is up to the API client, but it can be used to implement\\n- * access control policies based on script filenames and their prefixes, using\\n- * JS_FlagScriptFilenamePrefix and JS_GetTopScriptFilenameFlags.\\n+ * Return true if obj is a \\\"system\\\" object, that is, one flagged by a prior\\n+ * call to JS_FlagSystemObject(cx, obj).  What \\\"system\\\" means is up to the API\\n+ * client, but it can be used to coordinate access control policies based on\\n+ * script filenames and their prefixes, using JS_FlagScriptFilenamePrefix and\\n+ * JS_GetTopScriptFilenameFlags.\\n  */\\n extern JS_PUBLIC_API(JSBool)\\n JS_IsSystemObject(JSContext *cx, JSObject *obj);\\n \\n /*\\n- * Flag cx as a \\\"system\\\" context. The API client can flag system contexts to\\n- * optimize access control checks. The engine stores, but does not interpret,\\n- * the per-context flag set by this call, and uses it when new GC-things are\\n- * created on cx.\\n+ * Flag obj as a \\\"system\\\" object.  The API client can flag system objects to\\n+ * optimize access control checks.  The engine stores but does not interpret\\n+ * the per-object flag set by this call.\\n  */\\n extern JS_PUBLIC_API(void)\\n-JS_FlagSystemContext(JSContext *cx);\\n+JS_FlagSystemObject(JSContext *cx, JSObject *obj);\\n \\n /************************************************************************/\\n \\ndiff --git a/js/src/jsgc.c b/js/src/jsgc.c\\nindex 1ebd8a1..56d4751 100644\\n--- a/js/src/jsgc.c\\n+++ b/js/src/jsgc.c\\n@@ -1563,7 +1563,7 @@ js_NewGCThing(JSContext *cx, uintN flags, size_t nbytes)\\n     }\\n \\n     /* We can't fail now, so update flags. */\\n-    *flagp = (uint8)flags | cx->gcDefaultFlags;\\n+    *flagp = (uint8)flags;\\n \\n #ifdef DEBUG_gchist\\n     gchist[gchpos].lastDitch = doGC;\\ndiff --git a/js/src/jsobj.c b/js/src/jsobj.c\\nindex 12cf0e7..3d30058 100644\\n--- a/js/src/jsobj.c\\n+++ b/js/src/jsobj.c\\n@@ -2431,7 +2431,6 @@ JSObject *\\n js_NewObject(JSContext *cx, JSClass *clasp, JSObject *proto, JSObject *parent)\\n {\\n     jsid id;\\n-    uintN gcflags;\\n     JSObject *obj;\\n     JSObjectOps *ops;\\n     JSObjectMap *map;\\n@@ -2452,20 +2451,17 @@ js_NewObject(JSContext *cx, JSClass *clasp, JSObject *proto, JSObject *parent)\\n         }\\n     }\\n \\n-    /*\\n-     * Require that obj has the same system flag as its parent or (if null)\\n-     * its context's default system flag (see js_NewGCThing).\\n-     */\\n-    gcflags = GCX_OBJECT;\\n-    if (parent)\\n-        gcflags |= *js_GetGCThingFlags(parent) & GCF_SYSTEM;\\n+    /* Always call the class's getObjectOps hook if it has one. */\\n+    ops = clasp->getObjectOps\\n+          ? clasp->getObjectOps(cx, clasp)\\n+          : &js_ObjectOps;\\n \\n     /*\\n      * Allocate a zeroed object from the GC heap.  Do this *after* any other\\n      * GC-thing allocations under js_GetClassPrototype or clasp->getObjectOps,\\n      * to avoid displacing the newborn root for obj.\\n      */\\n-    obj = (JSObject *) js_NewGCThing(cx, gcflags, sizeof(JSObject));\\n+    obj = (JSObject *) js_NewGCThing(cx, GCX_OBJECT, sizeof(JSObject));\\n     if (!obj)\\n         return NULL;\\n \\n@@ -2485,11 +2481,6 @@ js_NewObject(JSContext *cx, JSClass *clasp, JSObject *proto, JSObject *parent)\\n     for (i = JSSLOT_PRIVATE; i != JS_INITIAL_NSLOTS; ++i)\\n         obj->fslots[i] = JSVAL_VOID;\\n \\n-    /* Always call the class's getObjectOps hook if it has one. */\\n-    ops = clasp->getObjectOps\\n-          ? clasp->getObjectOps(cx, clasp)\\n-          : &js_ObjectOps;\\n-\\n     /*\\n      * Root obj to prevent it from being collected out from under this call to\\n      * js_NewObject. There's a possibilty of GC under the objectHook call-out\\ndiff --git a/js/src/xpconnect/loader/mozJSComponentLoader.cpp b/js/src/xpconnect/loader/mozJSComponentLoader.cpp\\nindex fa9b917..1dc4ad1 100644\\n--- a/js/src/xpconnect/loader/mozJSComponentLoader.cpp\\n+++ b/js/src/xpconnect/loader/mozJSComponentLoader.cpp\\n@@ -74,7 +74,6 @@\\n #include \\\"nsIFileURL.h\\\"\\n #include \\\"nsNetUtil.h\\\"\\n #endif\\n-#include \\\"jsdbgapi.h\\\"\\n #include \\\"jsxdrapi.h\\\"\\n #include \\\"jsprf.h\\\"\\n #include \\\"nsIFastLoadFileControl.h\\\"\\n@@ -510,8 +509,6 @@ mozJSComponentLoader::ReallyInit()\\n     if (!mContext)\\n         return NS_ERROR_OUT_OF_MEMORY;\\n \\n-    JS_FlagSystemContext(mContext);\\n-\\n     uint32 options = JS_GetOptions(mContext);\\n     JS_SetOptions(mContext, options | JSOPTION_XML);\\n \\ndiff --git a/js/src/xpconnect/src/nsXPConnect.cpp b/js/src/xpconnect/src/nsXPConnect.cpp\\nindex 4072c99..91e9f94 100644\\n--- a/js/src/xpconnect/src/nsXPConnect.cpp\\n+++ b/js/src/xpconnect/src/nsXPConnect.cpp\\n@@ -982,9 +982,8 @@ nsXPConnect::InitClassesWithNewWrappedGlobal(JSContext * aJSContext,\\n        !JS_SetPrototype(aJSContext, tempGlobal, nsnull))\\n         return UnexpectedFailure(NS_ERROR_FAILURE);\\n \\n-    NS_ASSERTION(!(aFlags & nsIXPConnect::FLAG_SYSTEM_GLOBAL_OBJECT) ||\\n-                 JS_IsSystemObject(aJSContext, tempGlobal),\\n-                 \\\"system flag mismatch\\\");\\n+    if(aFlags & nsIXPConnect::FLAG_SYSTEM_GLOBAL_OBJECT)\\n+        JS_FlagSystemObject(aJSContext, tempGlobal);\\n \\n     nsCOMPtr<nsIXPConnectJSObjectHolder> holder;\\n     {\\ndiff --git a/js/src/xpconnect/src/xpcwrappednative.cpp b/js/src/xpconnect/src/xpcwrappednative.cpp\\nindex 83b69f7..2b1d3e8 100644\\n--- a/js/src/xpconnect/src/xpcwrappednative.cpp\\n+++ b/js/src/xpconnect/src/xpcwrappednative.cpp\\n@@ -871,6 +871,10 @@ XPCWrappedNative::Init(XPCCallContext& ccx, JSObject* parent, JSBool isGlobal,\\n         return JS_FALSE;\\n     }\\n \\n+    // Propagate the system flag from parent to child.\\n+    if(JS_IsSystemObject(ccx, parent))\\n+        JS_FlagSystemObject(ccx, mFlatJSObject);\\n+\\n     // This reference will be released when mFlatJSObject is finalized.\\n     // Since this reference will push the refcount to 2 it will also root\\n     // mFlatJSObject;\\n@@ -1717,6 +1721,10 @@ XPCWrappedNative::InitTearOffJSObject(XPCCallContext& ccx,\\n     if(!obj || !JS_SetPrivate(ccx, obj, to))\\n         return JS_FALSE;\\n \\n+    // Propagate the system flag from parent to child.\\n+    if(JS_IsSystemObject(ccx, mFlatJSObject))\\n+        JS_FlagSystemObject(ccx, obj);\\n+\\n     to->SetJSObject(obj);\\n     return JS_TRUE;\\n }\\ndiff --git a/js/src/xpconnect/src/xpcwrappednativeproto.cpp b/js/src/xpconnect/src/xpcwrappednativeproto.cpp\\nindex c6fda10..31c0dde 100644\\n--- a/js/src/xpconnect/src/xpcwrappednativeproto.cpp\\n+++ b/js/src/xpconnect/src/xpcwrappednativeproto.cpp\\n@@ -112,6 +112,10 @@ XPCWrappedNativeProto::Init(\\n \\n     JSBool ok = mJSProtoObject && JS_SetPrivate(ccx, mJSProtoObject, this);\\n \\n+    // Propagate the system flag from parent to child.\\n+    if(ok && JS_IsSystemObject(ccx, parent))\\n+        JS_FlagSystemObject(ccx, mJSProtoObject);\\n+\\n     DEBUG_ReportShadowedMembers(mSet, nsnull, this);\\n \\n     return ok;\\n\""}