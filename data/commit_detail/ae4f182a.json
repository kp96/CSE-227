{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basae4f182a\""},"diff":"\"ae4f182a Bug 395081. AccessibleObjectFromPoint() returns errors. r=surkov, a=dsicore\\ndiff --git a/accessible/public/nsIAccessible.idl b/accessible/public/nsIAccessible.idl\\nindex 6418517..ca8c870 100644\\n--- a/accessible/public/nsIAccessible.idl\\n+++ b/accessible/public/nsIAccessible.idl\\n@@ -194,6 +194,10 @@ interface nsIAccessible : nsISupports\\n \\n   /**\\n    * Accessible child which contains the coordinate at (x, y) in screen pixels.\\n+   * If the point is in the current accessible but not in a child, the\\n+   * current accessible will be returned.\\n+   * If the point is in neither the current accessible or a child, then\\n+   * null will be returned.\\n    */\\n   nsIAccessible getChildAtPoint(in long x, in long y);\\n \\ndiff --git a/accessible/src/base/nsAccessible.cpp b/accessible/src/base/nsAccessible.cpp\\nindex 4089ff6..ebceb3c 100644\\n--- a/accessible/src/base/nsAccessible.cpp\\n+++ b/accessible/src/base/nsAccessible.cpp\\n@@ -1064,6 +1064,24 @@ nsAccessible::GetChildAtPoint(PRInt32 aX, PRInt32 aY,\\n   NS_ENSURE_ARG_POINTER(aAccessible);\\n   *aAccessible = nsnull;\\n \\n+  if (!mDOMNode) {\\n+    return NS_ERROR_FAILURE;  // Already shut down\\n+  }\\n+\\n+  // If we can't find the point in a child, we will return the fallback answer:\\n+  // we return |this| if the point is within it, otherwise nsnull\\n+  nsCOMPtr<nsIAccessible> fallbackAnswer;\\n+  PRInt32 x, y, width, height;\\n+  GetBounds(&x, &y, &width, &height);\\n+  if (aX >= x && aX < x + width &&\\n+      aY >= y && aY < y + height) {\\n+    fallbackAnswer = this;\\n+  }\\n+  if (MustPrune(this)) {  // Do not dig any further\\n+    NS_IF_ADDREF(*aAccessible = fallbackAnswer);\\n+    return NS_OK;\\n+  }\\n+\\n   // Search an accessible at the given point starting from accessible document\\n   // because containing block (see CSS2) for out of flow element (for example,\\n   // absolutely positioned element) may be different from its DOM parent and\\n@@ -1073,9 +1091,7 @@ nsAccessible::GetChildAtPoint(PRInt32 aX, PRInt32 aY,\\n   nsCOMPtr<nsIAccessibleDocument> accDocument;\\n   nsresult rv = GetAccessibleDocument(getter_AddRefs(accDocument));\\n   NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  if (!accDocument)\\n-    return NS_OK;\\n+  NS_ENSURE_TRUE(accDocument, NS_ERROR_FAILURE);\\n \\n   nsCOMPtr<nsPIAccessNode> accessNodeDocument(do_QueryInterface(accDocument));\\n   NS_ASSERTION(accessNodeDocument,\\n@@ -1092,37 +1108,75 @@ nsAccessible::GetChildAtPoint(PRInt32 aX, PRInt32 aY,\\n \\n   nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();\\n   nsIFrame *foundFrame = presShell->GetFrameForPoint(frame, offset);\\n-  if (!foundFrame)\\n-    return NS_OK;\\n-\\n-  nsCOMPtr<nsIContent> content(foundFrame->GetContent());\\n-  if (!content)\\n+  nsCOMPtr<nsIContent> content;\\n+  if (!foundFrame || !(content = foundFrame->GetContent())) {\\n+    NS_IF_ADDREF(*aAccessible = fallbackAnswer);\\n     return NS_OK;\\n+  }\\n \\n   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(content));\\n   nsCOMPtr<nsIAccessibilityService> accService = GetAccService();\\n \\n   nsCOMPtr<nsIDOMNode> relevantNode;\\n   accService->GetRelevantContentNodeFor(node, getter_AddRefs(relevantNode));\\n-  if (!relevantNode)\\n+  if (!relevantNode) {\\n+    NS_IF_ADDREF(*aAccessible = fallbackAnswer);\\n     return NS_OK;\\n+  }\\n \\n   nsCOMPtr<nsIAccessible> accessible;\\n   accService->GetAccessibleFor(relevantNode, getter_AddRefs(accessible));\\n-  if (!accessible)\\n-    return NS_OK;\\n-\\n-  nsCOMPtr<nsIAccessible> parent;\\n-  accessible->GetParent(getter_AddRefs(parent));\\n-\\n-  while (parent && parent != this) {\\n-    accessible.swap(parent);\\n-    accessible->GetParent(getter_AddRefs(parent));\\n+  if (!accessible) {\\n+    // No accessible for the node with the point, so find the first\\n+    // accessible in the DOM parent chain\\n+    accDocument->GetAccessibleInParentChain(relevantNode,\\n+                                            getter_AddRefs(accessible));\\n+    if (!accessible) {\\n+      NS_IF_ADDREF(*aAccessible = fallbackAnswer);\\n+      return NS_OK;\\n+    }\\n   }\\n \\n-  if (parent)\\n-    NS_ADDREF(*aAccessible = accessible);\\n+  if (accessible == this) {\\n+    // Manually walk through accessible children and see if\\n+    // the are within this point.\\n+    // This takes care of cases where layout won't walk into\\n+    // things for us, such as image map areas and sub documents\\n+    nsCOMPtr<nsIAccessible> child;\\n+    while (NextChild(child)) {\\n+      PRInt32 childX, childY, childWidth, childHeight;\\n+      child->GetBounds(&childX, &childY, &childWidth, &childHeight);\\n+      if (aX >= childX && aX < childX + childWidth &&\\n+          aY >= childY && aY < childY + childHeight &&\\n+          (State(child) & nsIAccessibleStates::STATE_INVISIBLE) == 0) {\\n+        // Don't walk into offscreen or invisible items\\n+        NS_IF_ADDREF(*aAccessible = child);\\n+        return NS_OK;\\n+      }\\n+    }\\n+    // Fall through -- the point is in this accessible but not in a child\\n+    // We are allowed to return |this| as the answer\\n+  }\\n+  else {\\n+    nsCOMPtr<nsIAccessible> parent;\\n+    while (PR_TRUE) {\\n+      accessible->GetParent(getter_AddRefs(parent));\\n+      if (!parent) {\\n+        // Reached the top of the hierarchy\\n+        // these bounds were inside an accessible that is not a descendant of this one\\n+        NS_IF_ADDREF(*aAccessible = fallbackAnswer);\\n+        return NS_OK;\\n+      }\\n+      if (parent == this) {\\n+        // We reached |this|, so |accessible| is the\\n+        // child we want to return\\n+        break;\\n+      }\\n+      accessible.swap(parent);\\n+    }\\n+  }\\n \\n+  NS_IF_ADDREF(*aAccessible = accessible);\\n   return NS_OK;\\n }\\n \\ndiff --git a/accessible/src/base/nsBaseWidgetAccessible.h b/accessible/src/base/nsBaseWidgetAccessible.h\\nindex c9e0fe4..a665aca 100644\\n--- a/accessible/src/base/nsBaseWidgetAccessible.h\\n+++ b/accessible/src/base/nsBaseWidgetAccessible.h\\n@@ -63,6 +63,8 @@ public:\\n   NS_IMETHOD GetLastChild(nsIAccessible **_retval);\\n   NS_IMETHOD GetChildCount(PRInt32 *_retval);\\n   NS_IMETHOD GetAllowsAnonChildAccessibles(PRBool *aAllowsAnonChildren);\\n+  NS_IMETHOD GetChildAtPoint(PRInt32 aX, PRInt32 aY, nsIAccessible **aAccessible)\\n+    { *aAccessible = this; return NS_OK; } // Don't walk into these\\n };\\n \\n /**\\ndiff --git a/accessible/src/base/nsOuterDocAccessible.cpp b/accessible/src/base/nsOuterDocAccessible.cpp\\nindex 705f7c0..75d8638 100644\\n--- a/accessible/src/base/nsOuterDocAccessible.cpp\\n+++ b/accessible/src/base/nsOuterDocAccessible.cpp\\n@@ -86,6 +86,24 @@ nsOuterDocAccessible::GetState(PRUint32 *aState, PRUint32 *aExtraState)\\n   return NS_OK;\\n }\\n \\n+NS_IMETHODIMP\\n+nsOuterDocAccessible::GetChildAtPoint(PRInt32 aX, PRInt32 aY,\\n+                                      nsIAccessible **aAccessible)\\n+{\\n+  NS_ENSURE_ARG_POINTER(aAccessible);\\n+  *aAccessible = nsnull;\\n+  if (!mDOMNode) {\\n+    return NS_ERROR_FAILURE;\\n+  }\\n+  PRInt32 docX, docY, docWidth, docHeight;\\n+  GetBounds(&docX, &docY, &docWidth, &docHeight);\\n+  if (aX < docX || aX >= docX + docWidth || aY < docY || aY >= docY + docHeight) {\\n+    return NS_ERROR_FAILURE;\\n+  }\\n+\\n+  return GetFirstChild(aAccessible);  // Always return the inner doc unless bounds outside of it\\n+}\\n+\\n void nsOuterDocAccessible::CacheChildren()\\n {  \\n   // An outer doc accessible usually has 1 nsDocAccessible child,\\ndiff --git a/accessible/src/base/nsOuterDocAccessible.h b/accessible/src/base/nsOuterDocAccessible.h\\nindex 55c3405..c2fe5b8 100644\\n--- a/accessible/src/base/nsOuterDocAccessible.h\\n+++ b/accessible/src/base/nsOuterDocAccessible.h\\n@@ -55,6 +55,8 @@ class nsOuterDocAccessible : public nsAccessibleWrap\\n     NS_IMETHOD GetName(nsAString& aName);\\n     NS_IMETHOD GetRole(PRUint32 *aRole);\\n     NS_IMETHOD GetState(PRUint32 *aState, PRUint32 *aExtraState);\\n+    NS_IMETHOD GetChildAtPoint(PRInt32 aX, PRInt32 aY,\\n+                               nsIAccessible **aAccessible);\\n     void CacheChildren();\\n };\\n \\ndiff --git a/accessible/src/html/nsHTMLAreaAccessible.h b/accessible/src/html/nsHTMLAreaAccessible.h\\nindex c561479..75291de 100644\\n--- a/accessible/src/html/nsHTMLAreaAccessible.h\\n+++ b/accessible/src/html/nsHTMLAreaAccessible.h\\n@@ -56,6 +56,8 @@ public:\\n   NS_IMETHOD GetChildCount(PRInt32 *_retval);\\n   NS_IMETHOD GetDescription(nsAString& _retval);\\n   NS_IMETHOD GetBounds(PRInt32 *x, PRInt32 *y, PRInt32 *width, PRInt32 *height);\\n+  NS_IMETHOD GetChildAtPoint(PRInt32 aX, PRInt32 aY, nsIAccessible **aAccessible)\\n+    { *aAccessible = this; return NS_OK; } // Don't walk into these\\n };\\n \\n #endif  \\n\""}