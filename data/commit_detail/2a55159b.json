{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas2a55159b\""},"diff":"\"2a55159b Bug 396456 - \\\"Refactor PauseResume into Pause, Cancel, Resume, RealResume\\\" [p=edilee@gmail.com (Edward Lee [Mardak]) r=sdwilsh a1.9=mconnor]\\ndiff --git a/toolkit/components/downloads/src/nsDownloadManager.cpp b/toolkit/components/downloads/src/nsDownloadManager.cpp\\nindex 30ace8a..597266d 100644\\n--- a/toolkit/components/downloads/src/nsDownloadManager.cpp\\n+++ b/toolkit/components/downloads/src/nsDownloadManager.cpp\\n@@ -841,6 +841,7 @@ nsDownloadManager::AddToCurrentDownloads(nsDownload *aDl)\\n   if (!mCurrentDownloads.AppendObject(aDl))\\n     return NS_ERROR_OUT_OF_MEMORY;\\n \\n+  aDl->mDownloadManager = this;\\n   return NS_OK;\\n }\\n \\n@@ -1062,7 +1063,6 @@ nsDownloadManager::AddDownload(DownloadType aDownloadType,\\n     return NS_ERROR_OUT_OF_MEMORY;\\n \\n   // give our new nsIDownload some info so it's ready to go off into the world\\n-  dl->mDownloadManager = this;\\n   dl->mTarget = aTarget;\\n   dl->mSource = aSource;\\n   dl->mTempFile = aTempFile;\\n@@ -1142,13 +1142,12 @@ nsDownloadManager::CancelDownload(PRUint32 aID)\\n   if (dl->IsFinished())\\n     return NS_OK;\\n \\n-  // if the download is paused, we have to resume it so we can cancel it\\n-  if (dl->IsPaused())\\n-    (void)dl->PauseResume(PR_FALSE);\\n+  // if the download is fake-paused, we have to resume it so we can cancel it\\n+  if (dl->IsPaused() && !dl->IsResumable())\\n+    (void)dl->Resume();\\n \\n-  // Cancel using the provided object\\n-  if (dl->mCancelable)\\n-    dl->mCancelable->Cancel(NS_BINDING_ABORTED);\\n+  // Have the download cancel its connection\\n+  (void)dl->Cancel();\\n \\n   // Dump the temp file.  This should really be done when the transfer\\n   // is cancelled, but there are other cancellation causes that shouldn't\\n@@ -1179,35 +1178,25 @@ nsDownloadManager::RetryDownload(PRUint32 aID)\\n       dl->mDownloadState != nsIDownloadManager::DOWNLOAD_CANCELED)\\n     return NS_ERROR_FAILURE;\\n \\n-  // we are redownloading this, so we need to link the download manager to the\\n-  // download else we'll try to dereference null pointers - eww\\n-  dl->mDownloadManager = this;\\n-\\n   dl->SetStartTime(PR_Now());\\n \\n   nsCOMPtr<nsIWebBrowserPersist> wbp =\\n     do_CreateInstance(\\\"@mozilla.org/embedding/browser/nsWebBrowserPersist;1\\\", &rv);\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n-  // Creates a cycle that will be broken when the download finishes\\n-  dl->mCancelable = wbp;\\n-  wbp->SetProgressListener(dl);\\n-\\n   rv = wbp->SetPersistFlags(nsIWebBrowserPersist::PERSIST_FLAGS_REPLACE_EXISTING_FILES |\\n                             nsIWebBrowserPersist::PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION);\\n-  if (NS_FAILED(rv)) {\\n-    dl->mCancelable = nsnull;\\n-    (void)wbp->SetProgressListener(nsnull);\\n-    return rv;\\n-  }\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n \\n   rv = AddToCurrentDownloads(dl);\\n-  if (NS_FAILED(rv)) {\\n-    dl->mCancelable = nsnull;\\n-    (void)wbp->SetProgressListener(nsnull);\\n-    return rv;\\n-  }\\n-  (void)dl->SetState(nsIDownloadManager::DOWNLOAD_QUEUED);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  rv = dl->SetState(nsIDownloadManager::DOWNLOAD_QUEUED);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  // Creates a cycle that will be broken when the download finishes\\n+  dl->mCancelable = wbp;\\n+  (void)wbp->SetProgressListener(dl);\\n \\n   rv = wbp->SaveURI(dl->mSource, nsnull, nsnull, nsnull, nsnull, dl->mTarget);\\n   if (NS_FAILED(rv)) {\\n@@ -1301,23 +1290,21 @@ nsDownloadManager::GetCanCleanUp(PRBool *aResult)\\n NS_IMETHODIMP\\n nsDownloadManager::PauseDownload(PRUint32 aID)\\n {\\n-  return PauseResumeDownload(aID, PR_TRUE);\\n+  nsDownload *dl = FindDownload(aID);\\n+  if (!dl)\\n+    return NS_ERROR_FAILURE;\\n+\\n+  return dl->Pause();\\n }\\n \\n NS_IMETHODIMP\\n nsDownloadManager::ResumeDownload(PRUint32 aID)\\n {\\n-  return PauseResumeDownload(aID, PR_FALSE);\\n-}\\n-\\n-nsresult\\n-nsDownloadManager::PauseResumeDownload(PRUint32 aID, PRBool aPause)\\n-{\\n   nsDownload *dl = FindDownload(aID);\\n   if (!dl)\\n     return NS_ERROR_FAILURE;\\n \\n-  return dl->PauseResume(aPause);\\n+  return dl->Resume();\\n }\\n \\n NS_IMETHODIMP\\n@@ -1874,16 +1861,10 @@ nsDownload::OnStateChange(nsIWebProgress *aWebProgress,\\n       // HTTP 450 - Blocked by parental control proxies\\n       if (NS_SUCCEEDED(rv) && status == 450) {\\n         // Cancel using the provided object\\n-        if (mCancelable)\\n-          (void)mCancelable->Cancel(NS_BINDING_ABORTED);\\n+        (void)Cancel();\\n \\n         // Fail the download - DOWNLOAD_BLOCKED\\n         (void)SetState(nsIDownloadManager::DOWNLOAD_BLOCKED);\\n-\\n-        mDownloadManager->NotifyListenersOnStateChange(aWebProgress, aRequest,\\n-                                                       aStateFlags, aStatus, this);\\n-\\n-        return UpdateDB();\\n       }\\n     }\\n   } else if (aStateFlags & STATE_STOP) {\\n@@ -2041,93 +2022,116 @@ nsDownload::GetReferrer(nsIURI **referrer)\\n }\\n \\n nsresult\\n-nsDownload::PauseResume(PRBool aPause)\\n+nsDownload::Pause()\\n {\\n-  if (IsPaused() == aPause || !mRequest)\\n-    return NS_OK;\\n+  nsresult rv = NS_ERROR_FAILURE;\\n+  if (IsResumable())\\n+    rv = Cancel();\\n+  else if (mRequest)\\n+    rv = mRequest->Suspend();\\n+  else\\n+    NS_NOTREACHED(\\\"We don't have a resumable download or a request to suspend??\\\");\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n \\n-  nsresult rv;\\n-  if (aPause) {\\n-    if (IsResumable()) {\\n-      rv = mCancelable->Cancel(NS_BINDING_ABORTED);\\n-      NS_ENSURE_SUCCESS(rv, rv);\\n-    } else {\\n-      // This is for non-resumable downloads and downloads that are used with\\n-      // \\\"Open With...\\\".\\n-      rv = mRequest->Suspend();\\n-      NS_ENSURE_SUCCESS(rv, rv);\\n-    }\\n-    return SetState(nsIDownloadManager::DOWNLOAD_PAUSED);\\n+  return SetState(nsIDownloadManager::DOWNLOAD_PAUSED);\\n+}\\n+\\n+nsresult\\n+nsDownload::Cancel()\\n+{\\n+  nsresult rv = NS_OK;\\n+  if (mCancelable) {\\n+    rv = mCancelable->Cancel(NS_BINDING_ABORTED);\\n+    // we're done with this, so break the cycle\\n+    mCancelable = nsnull;\\n   }\\n \\n-  if (IsResumable()) {\\n-    nsCOMPtr<nsIWebBrowserPersist> wbp =\\n-      do_CreateInstance(\\\"@mozilla.org/embedding/browser/nsWebBrowserPersist;1\\\", &rv);\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n+  return rv;\\n+}\\n \\n-    rv = wbp->SetPersistFlags(nsIWebBrowserPersist::PERSIST_FLAGS_APPEND_TO_FILE |\\n-                              nsIWebBrowserPersist::PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION);\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n+nsresult\\n+nsDownload::Resume()\\n+{\\n+  nsresult rv = NS_ERROR_FAILURE;\\n+  if (IsResumable())\\n+    rv = RealResume();\\n+  else if (mRequest)\\n+    rv = mRequest->Resume();\\n+  else\\n+    NS_NOTREACHED(\\\"We don't have a resumable download or a request to resume??\\\");\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n \\n-    // Create a new channel for the source URI\\n-    nsCOMPtr<nsIChannel> channel;\\n-    nsCOMPtr<nsIInterfaceRequestor> ir(do_QueryInterface(wbp));\\n-    rv = NS_NewChannel(getter_AddRefs(channel), mSource, nsnull, nsnull, ir);\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n+  return SetState(nsIDownloadManager::DOWNLOAD_DOWNLOADING);\\n+}\\n \\n-    // Get the size of the temporary or target file to be used as offset.\\n-    PRInt64 fileSize;\\n-    nsCOMPtr<nsILocalFile> targetLocalFile(mTempFile);\\n-    if (!targetLocalFile) {\\n-      rv = GetTargetFile(getter_AddRefs(targetLocalFile));\\n-      NS_ENSURE_SUCCESS(rv, rv);\\n-    }\\n-    // We need to get a new nsIFile though because of caching issues with the\\n-    // file size.  Cloning it takes care of this :(\\n-    nsCOMPtr<nsIFile> clone;\\n-    rv = targetLocalFile->Clone(getter_AddRefs(clone));\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n-    rv = clone->GetFileSize(&fileSize);\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n+nsresult\\n+nsDownload::RealResume()\\n+{\\n+  nsresult rv;\\n+  nsCOMPtr<nsIWebBrowserPersist> wbp =\\n+    do_CreateInstance(\\\"@mozilla.org/embedding/browser/nsWebBrowserPersist;1\\\", &rv);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  rv = wbp->SetPersistFlags(nsIWebBrowserPersist::PERSIST_FLAGS_APPEND_TO_FILE |\\n+                            nsIWebBrowserPersist::PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n \\n-    // Set the channel to resume at the right position along with the entityID\\n-    nsCOMPtr<nsIResumableChannel> resumableChannel(do_QueryInterface(channel));\\n-    if (!resumableChannel)\\n-      return NS_ERROR_UNEXPECTED;\\n-    rv = resumableChannel->ResumeAt(fileSize, mEntityID);\\n+  // Create a new channel for the source URI\\n+  nsCOMPtr<nsIChannel> channel;\\n+  nsCOMPtr<nsIInterfaceRequestor> ir(do_QueryInterface(wbp));\\n+  rv = NS_NewChannel(getter_AddRefs(channel), mSource, nsnull, nsnull, ir);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  // Get the size of the temporary or target file to be used as offset.\\n+  PRInt64 fileSize;\\n+  nsCOMPtr<nsILocalFile> targetLocalFile(mTempFile);\\n+  if (!targetLocalFile) {\\n+    rv = GetTargetFile(getter_AddRefs(targetLocalFile));\\n     NS_ENSURE_SUCCESS(rv, rv);\\n+  }\\n \\n-    // Track where we resumed because progress notifications restart at 0\\n-    mResumedAt = fileSize;\\n-    mCurrBytes = 0;\\n-    mMaxBytes = LL_MAXUINT;\\n+  // We need to get a new nsIFile though because of caching issues with the\\n+  // file size.  Cloning it takes care of this :(\\n+  nsCOMPtr<nsIFile> clone;\\n+  rv = targetLocalFile->Clone(getter_AddRefs(clone));\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+  rv = clone->GetFileSize(&fileSize);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n \\n-    // Set the referrer\\n-    if (mReferrer) {\\n-      nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));\\n-      if (httpChannel) {\\n-        rv = httpChannel->SetReferrer(mReferrer);\\n-        NS_ENSURE_SUCCESS(rv, rv);\\n-      }\\n-    }\\n+  // Set the channel to resume at the right position along with the entityID\\n+  nsCOMPtr<nsIResumableChannel> resumableChannel(do_QueryInterface(channel));\\n+  if (!resumableChannel)\\n+    return NS_ERROR_UNEXPECTED;\\n+  rv = resumableChannel->ResumeAt(fileSize, mEntityID);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n \\n-    // Creates a cycle that will be broken when the download finishes\\n-    mCancelable = wbp;\\n-    (void)wbp->SetProgressListener(this);\\n+  // Track where we resumed because progress notifications restart at 0\\n+  mResumedAt = fileSize;\\n+  mCurrBytes = 0;\\n+  mMaxBytes = LL_MAXUINT;\\n \\n-    // Save the channel using nsIWBP.\\n-    rv = wbp->SaveChannel(channel, targetLocalFile);\\n-    if (NS_FAILED(rv)) {\\n-      mCancelable = nsnull;\\n-      (void)wbp->SetProgressListener(nsnull);\\n-      return rv;\\n+  // Set the referrer\\n+  if (mReferrer) {\\n+    nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));\\n+    if (httpChannel) {\\n+      rv = httpChannel->SetReferrer(mReferrer);\\n+      NS_ENSURE_SUCCESS(rv, rv);\\n     }\\n-  } else {\\n-    rv = mRequest->Resume();\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n   }\\n \\n-  return SetState(nsIDownloadManager::DOWNLOAD_DOWNLOADING);\\n+  // Creates a cycle that will be broken when the download finishes\\n+  mCancelable = wbp;\\n+  (void)wbp->SetProgressListener(this);\\n+\\n+  // Save the channel using nsIWBP\\n+  rv = wbp->SaveChannel(channel, targetLocalFile);\\n+  if (NS_FAILED(rv)) {\\n+    mCancelable = nsnull;\\n+    (void)wbp->SetProgressListener(nsnull);\\n+    return rv;\\n+  }\\n+\\n+  return NS_OK;\\n }\\n \\n PRBool\\ndiff --git a/toolkit/components/downloads/src/nsDownloadManager.h b/toolkit/components/downloads/src/nsDownloadManager.h\\nindex 224f82a..c325730 100644\\n--- a/toolkit/components/downloads/src/nsDownloadManager.h\\n+++ b/toolkit/components/downloads/src/nsDownloadManager.h\\n@@ -137,7 +137,6 @@ protected:\\n                                     nsIDownload *aDownload);\\n \\n   nsDownload *FindDownload(PRUint32 aID);\\n-  nsresult PauseResumeDownload(PRUint32 aID, PRBool aPause);\\n   nsresult CancelAllDownloads();\\n \\n   /**\\n@@ -199,7 +198,27 @@ public:\\n protected:\\n   void SetStartTime(PRInt64 aStartTime);\\n \\n-  nsresult PauseResume(PRBool aPause);\\n+  /**\\n+   * Pause the download, but in certain cases it might get fake-paused instead\\n+   * of real-paused.\\n+   */\\n+  nsresult Pause();\\n+\\n+  /**\\n+   * All this does is cancel the connection that the download is using. It does\\n+   * not remove it from the download manager.\\n+   */\\n+  nsresult Cancel();\\n+\\n+  /**\\n+   * Resume the download. Works for both real-paused and fake-paused.\\n+   */\\n+  nsresult Resume();\\n+\\n+  /**\\n+   * Resume the real-paused download. Let Resume decide if this should get used.\\n+   */\\n+  nsresult RealResume();\\n \\n   /**\\n    * Download is not transferring?\\n\""}