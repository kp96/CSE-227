{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basec4b667\""},"diff":"\"ec4b667 Bug 392512, panel doesn't open when opened from a menu, r+sr=bz,a=dbaron\\ndiff --git a/layout/xul/base/src/nsXULPopupManager.cpp b/layout/xul/base/src/nsXULPopupManager.cpp\\nindex 6877e9c..079f100 100644\\n--- a/layout/xul/base/src/nsXULPopupManager.cpp\\n+++ b/layout/xul/base/src/nsXULPopupManager.cpp\\n@@ -517,29 +517,44 @@ nsXULPopupManager::HidePopup(nsIContent* aPopup,\\n   PRBool deselectMenu = PR_FALSE;\\n   nsCOMPtr<nsIContent> popupToHide, nextPopup, lastPopup;\\n   if (foundMenu) {\\n-    // at this point, item will be set to the found item in the list. If item\\n-    // is the topmost menu, the one to remove, then there are no other\\n-    // popups to hide. If item is not the topmost menu, then there are\\n+    // at this point, foundMenu will be set to the found item in the list. If\\n+    // foundMenu is the topmost menu, the one to remove, then there are no other\\n+    // popups to hide. If foundMenu is not the topmost menu, then there may be\\n     // open submenus below it. In this case, we need to make sure that those\\n-    // submenus are closed up first. To do this, we start at mCurrentMenu and\\n-    // close that popup. In synchronous mode, the FirePopupHidingEvent method\\n-    // will be called which in turn calls HidePopupCallback to close up the\\n-    // next popup in the chain. These two methods will be called in sequence\\n-    // recursively to close up all the necessary popups. In asynchronous mode,\\n-    // a similar process occurs except that the FirePopupHidingEvent method is\\n-    // called asynchrounsly. In either case, nextPopup is set to the content\\n-    // node of the next popup to close, and lastPopup is set to the last popup\\n-    // in the chain to close, which will be aPopup.\\n+    // submenus are closed up first. To do this, we scan up the menu list to\\n+    // find the topmost popup with only menus between it and foundMenu and\\n+    // close that menu first. In synchronous mode, the FirePopupHidingEvent\\n+    // method will be called which in turn calls HidePopupCallback to close up\\n+    // the next popup in the chain. These two methods will be called in\\n+    // sequence recursively to close up all the necessary popups. In\\n+    // asynchronous mode, a similar process occurs except that the\\n+    // FirePopupHidingEvent method is called asynchrounsly. In either case,\\n+    // nextPopup is set to the content node of the next popup to close, and\\n+    // lastPopup is set to the last popup in the chain to close, which will be\\n+    // aPopup, or null to close up all menus.\\n+\\n+    nsMenuChainItem* topMenu = foundMenu;\\n+    // Use IsMenu to ensure that foundMenu is a menu and scan down the child\\n+    // list until a non-menu is found. If foundMenu isn't a menu at all, don't\\n+    // scan and just close up this menu.\\n+    if (foundMenu->IsMenu()) {\\n+      item = topMenu->GetChild();\\n+      while (item && item->IsMenu()) {\\n+        topMenu = item;\\n+        item = item->GetChild();\\n+      }\\n+    }\\n+    \\n     deselectMenu = aDeselectMenu;\\n-    popupToHide = mCurrentMenu->Content();\\n-    popupFrame = mCurrentMenu->Frame();\\n+    popupToHide = topMenu->Content();\\n+    popupFrame = topMenu->Frame();\\n     type = popupFrame->PopupType();\\n \\n-    nsMenuChainItem* parent = mCurrentMenu->GetParent();\\n+    nsMenuChainItem* parent = topMenu->GetParent();\\n \\n     // close up another popup if there is one, and we are either hiding the\\n     // entire chain or the item to hide isn't the topmost popup.\\n-    if (parent && (aHideChain || mCurrentMenu != item))\\n+    if (parent && (aHideChain || topMenu != foundMenu))\\n       nextPopup = parent->Content();\\n \\n     lastPopup = aHideChain ? nsnull : aPopup;\\n@@ -1794,8 +1809,21 @@ nsXULMenuCommandEvent::Run()\\n   // associated view manager on exit from this function.\\n   // See bug 54233.\\n   // XXXndeakin is this still needed?\\n+\\n+  nsCOMPtr<nsIContent> popup;\\n   nsMenuFrame* menuFrame = pm->GetMenuFrameForContent(mMenu);\\n   if (menuFrame) {\\n+    // Find the popup that the menu is inside. Below, this popup will\\n+    // need to be hidden.\\n+    nsIFrame* popupFrame = menuFrame->GetParent();\\n+    while (popupFrame) {\\n+      if (popupFrame->GetType() == nsGkAtoms::menuPopupFrame) {\\n+        popup = popupFrame->GetContent();\\n+        break;\\n+      }\\n+      popupFrame = popupFrame->GetParent();\\n+    }\\n+\\n     nsPresContext* presContext = menuFrame->PresContext();\\n     nsCOMPtr<nsIViewManager> kungFuDeathGrip = presContext->GetViewManager();\\n     nsCOMPtr<nsIPresShell> shell = presContext->PresShell();\\n@@ -1814,7 +1842,8 @@ nsXULMenuCommandEvent::Run()\\n     shell->HandleDOMEventWithTarget(mMenu, &commandEvent, &status);\\n   }\\n \\n-  pm->Rollup();\\n+  if (popup)\\n+    pm->HidePopup(popup, PR_TRUE, PR_TRUE, PR_TRUE);\\n \\n   return NS_OK;\\n }\\ndiff --git a/toolkit/content/tests/widgets/Makefile.in b/toolkit/content/tests/widgets/Makefile.in\\nindex e483327..1fc9f02 100644\\n--- a/toolkit/content/tests/widgets/Makefile.in\\n+++ b/toolkit/content/tests/widgets/Makefile.in\\n@@ -68,6 +68,7 @@ _TEST_FILES = \\ttest_bug360220.xul \\\\\\n \\t\\ttest_datepicker.xul \\\\\\n \\t\\ttest_timepicker.xul \\\\\\n \\t\\txul_selectcontrol.js \\\\\\n+\\t\\ttest_panelfrommenu.xul \\\\\\n \\t\\ttest_hiddenitems.xul \\\\\\n \\t\\ttest_hiddenpaging.xul \\\\\\n \\t\\t$(NULL)\\ndiff --git a/toolkit/content/tests/widgets/test_panelfrommenu.xul b/toolkit/content/tests/widgets/test_panelfrommenu.xul\\nnew file mode 100644\\nindex 0000000..86063a6\\n--- /dev/null\\n+++ b/toolkit/content/tests/widgets/test_panelfrommenu.xul\\n@@ -0,0 +1,80 @@\\n+<?xml version=\\\"1.0\\\"?>\\n+<?xml-stylesheet href=\\\"chrome://global/skin\\\" type=\\\"text/css\\\"?>\\n+<?xml-stylesheet href=\\\"/tests/SimpleTest/test.css\\\" type=\\\"text/css\\\"?>\\n+\\n+<window title=\\\"Open panel from menuitem\\\"\\n+  onload=\\\"setTimeout(runTests, 0);\\\"\\n+  xmlns:html=\\\"http://www.w3.org/1999/xhtml\\\"\\n+  xmlns=\\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\">\\n+\\n+  <script type=\\\"application/javascript\\\" src=\\\"/MochiKit/packed.js\\\"></script>\\n+  <script type=\\\"application/javascript\\\" src=\\\"/tests/SimpleTest/SimpleTest.js\\\"></script>      \\n+  <script type=\\\"application/javascript\\\" src=\\\"/tests/SimpleTest/EventUtils.js\\\"></script>      \\n+\\n+<!--\\n+  This test does the following:\\n+   1. Opens the menu, causing the popupshown event to fire, which will call menuOpened.\\n+   2. Keyboard events are fired to cause the first item on the menu to be executed.\\n+   3. The command event handler for the first menuitem opens the panel.\\n+   4. As a menuitem was executed, the menu will roll up, hiding it.\\n+   5. The popuphidden event for the menu calls menuClosed which tests the popup states.\\n+   6. The panelOpened function tests the popup states again and hides the popup.\\n+   7. Once the panel's popuphidden event fires, the tests are complete.\\n+  -->\\n+\\n+<menu id=\\\"menu\\\" onpopupshown=\\\"menuOpened()\\\" onpopuphidden=\\\"menuClosed();\\\">\\n+  <menupopup>\\n+    <menuitem id=\\\"i1\\\" label=\\\"One\\\" oncommand=\\\"$('panel').openPopup($('menu'), 'after_start');\\\"/>\\n+    <menuitem id=\\\"i2\\\" label=\\\"Two\\\"/>\\n+  </menupopup>\\n+</menu>\\n+\\n+<panel id=\\\"panel\\\" onpopupshown=\\\"panelOpened()\\\" onpopuphidden=\\\"SimpleTest.finish()\\\">\\n+  <textbox/>\\n+</panel>\\n+\\n+<script class=\\\"testbody\\\" type=\\\"application/javascript\\\">\\n+<![CDATA[\\n+\\n+SimpleTest.waitForExplicitFinish();\\n+\\n+function runTests()\\n+{\\n+  var menu = $(\\\"menu\\\");\\n+  menu.open = true;\\n+}\\n+\\n+function menuOpened()\\n+{\\n+  synthesizeKey(\\\"VK_DOWN\\\", { });\\n+  synthesizeKey(\\\"VK_ENTER\\\", { });\\n+}\\n+\\n+function menuClosed()\\n+{\\n+  // the panel will be open at this point, but the popupshown event\\n+  // still needs to fire\\n+  is($(\\\"panel\\\").state, \\\"open\\\", \\\"panel is open after menu hide\\\");\\n+  is($(\\\"menu\\\").firstChild.state, \\\"closed\\\", \\\"menu is closed after menu hide\\\");\\n+}\\n+\\n+function panelOpened()\\n+{\\n+  is($(\\\"panel\\\").state, \\\"open\\\", \\\"panel is open\\\");\\n+  is($(\\\"menu\\\").firstChild.state, \\\"closed\\\", \\\"menu is closed\\\");\\n+  $(\\\"panel\\\").hidePopup();\\n+}\\n+\\n+]]>\\n+</script>\\n+\\n+<body xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\\n+<p id=\\\"display\\\">\\n+</p>\\n+<div id=\\\"content\\\" style=\\\"display: none\\\">\\n+</div>\\n+<pre id=\\\"test\\\">\\n+</pre>\\n+</body>\\n+\\n+</window>\\n\""}