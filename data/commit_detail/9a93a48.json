{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas9a93a48\""},"diff":"\"9a93a48 Bug 385607. Ensure that whitespace is collapsed across text-run boundaries across incremental updates like adding/removing frames in the middle of the textrun. r+sr+a=dbaron\\ndiff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp\\nindex 0887153..f73645e 100644\\n--- a/layout/generic/nsBlockFrame.cpp\\n+++ b/layout/generic/nsBlockFrame.cpp\\n@@ -665,6 +665,7 @@ nsBlockFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)\\n         }\\n         // XXX Bug NNNNNN Should probably handle percentage text-indent.\\n \\n+      data.line = &line;\\n         nsIFrame *kid = line->mFirstChild;\\n         for (PRInt32 i = 0, i_end = line->GetChildCount(); i != i_end;\\n              ++i, kid = kid->GetNextSibling()) {\\n@@ -736,6 +737,7 @@ nsBlockFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)\\n         }\\n         // XXX Bug NNNNNN Should probably handle percentage text-indent.\\n \\n+      data.line = &line;\\n         nsIFrame *kid = line->mFirstChild;\\n         for (PRInt32 i = 0, i_end = line->GetChildCount(); i != i_end;\\n              ++i, kid = kid->GetNextSibling()) {\\n@@ -4798,12 +4800,19 @@ nsBlockFrame::AddFrames(nsIFrame* aFrameList,\\n       prevSibLine->SetChildCount(prevSibLine->GetChildCount() - rem);\\n       prevSibLine->MarkDirty();\\n     }\\n+    // Force the lines next to where we're inserting content to regenerate\\n+    // their textruns\\n+    prevSibLine->SetInvalidateTextRuns(PR_TRUE);\\n+    if (prevSibLine.next() != end_lines()) {\\n+      prevSibLine.next()->SetInvalidateTextRuns(PR_TRUE);\\n+    }\\n \\n     // Now (partially) join the sibling lists together\\n     aPrevSibling->SetNextSibling(aFrameList);\\n   }\\n   else if (! mLines.empty()) {\\n     prevSiblingNextFrame = mLines.front()->mFirstChild;\\n+    mLines.front()->SetInvalidateTextRuns(PR_TRUE);\\n   }\\n \\n   // Walk through the new frames being added and update the line data\\n@@ -5212,6 +5221,10 @@ found_frame:;\\n     NS_ERROR(\\\"can't find deleted frame in lines\\\");\\n     return NS_ERROR_FAILURE;\\n   }\\n+  \\n+  if (line != mLines.front()) {\\n+    line.prev()->SetInvalidateTextRuns(PR_TRUE);\\n+  }\\n \\n   if (prevSibling && !prevSibling->GetNextSibling()) {\\n     // We must have found the first frame in the overflow line list. So\\n@@ -5224,6 +5237,8 @@ found_frame:;\\n     NS_ASSERTION(this == aDeletedFrame->GetParent(), \\\"messed up delete code\\\");\\n     NS_ASSERTION(line->Contains(aDeletedFrame), \\\"frame not in line\\\");\\n \\n+    line->SetInvalidateTextRuns(PR_TRUE);\\n+\\n     // If the frame being deleted is the last one on the line then\\n     // optimize away the line->Contains(next-in-flow) call below.\\n     PRBool isLastFrameOnLine = (1 == line->GetChildCount() ||\\n@@ -5370,6 +5385,10 @@ found_frame:;\\n       }\\n     }\\n   }\\n+  \\n+  if (line.next() != line_end) {\\n+    line.next()->SetInvalidateTextRuns(PR_TRUE);\\n+  }\\n \\n #ifdef DEBUG\\n   VerifyLines(PR_TRUE);\\n@@ -6104,10 +6123,16 @@ nsBlockFrame::ChildIsDirty(nsIFrame* aChild)\\n     // otherwise we have an empty line list, and ReflowDirtyLines\\n     // will handle reflowing the bullet.\\n   } else {\\n-    // Mark the line containing the child frame dirty.\\n+    // Mark the line containing the child frame dirty. We would rather do this\\n+    // in MarkIntrinsicWidthsDirty but that currently won't tell us which\\n+    // child is being dirtied.\\n     line_iterator fline = FindLineFor(aChild);\\n-    if (fline != end_lines())\\n+    if (fline != end_lines()) {\\n+      // An inline descendant might have been added or removed, so we should\\n+      // reconstruct textruns.\\n+      fline->SetInvalidateTextRuns(PR_TRUE);\\n       MarkLineDirty(fline);\\n+    }\\n   }\\n \\n   nsBlockFrameSuper::ChildIsDirty(aChild);\\ndiff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h\\nindex 66f8ca3..a61c8a6 100644\\n--- a/layout/generic/nsIFrame.h\\n+++ b/layout/generic/nsIFrame.h\\n@@ -92,6 +92,7 @@ class nsDisplayListSet;\\n class nsDisplayList;\\n class gfxSkipChars;\\n class gfxSkipCharsIterator;\\n+class nsLineList_iterator;\\n \\n struct nsPeekOffsetStruct;\\n struct nsPoint;\\n@@ -1137,12 +1138,16 @@ public:\\n    */\\n   struct InlineIntrinsicWidthData {\\n     InlineIntrinsicWidthData()\\n-      : prevLines(0)\\n+      : line(nsnull)\\n+      , prevLines(0)\\n       , currentLine(0)\\n       , skipWhitespace(PR_TRUE)\\n       , trailingWhitespace(0)\\n     {}\\n \\n+    // The line. This may be null if the inlines are not associated with a block.\\n+    const nsLineList_iterator* line;\\n+\\n     // The maximum intrinsic width for all previous lines.\\n     nscoord prevLines;\\n \\ndiff --git a/layout/generic/nsLineBox.h b/layout/generic/nsLineBox.h\\nindex faa97e0..bb032a4 100644\\n--- a/layout/generic/nsLineBox.h\\n+++ b/layout/generic/nsLineBox.h\\n@@ -305,6 +305,15 @@ public:\\n     return mFlags.mLineWrapped;\\n   }\\n \\n+  // mInvalidateTextRuns bit\\n+  void SetInvalidateTextRuns(PRBool aOn) {\\n+    NS_ASSERTION((PR_FALSE==aOn || PR_TRUE==aOn), \\\"somebody is playing fast and loose with bools and bits!\\\");\\n+    mFlags.mInvalidateTextRuns = aOn;\\n+  }\\n+  PRBool GetInvalidateTextRuns() const {\\n+    return mFlags.mInvalidateTextRuns;\\n+  }\\n+\\n   // mResizeReflowOptimizationDisabled bit\\n   void DisableResizeReflowOptimization() {\\n     mFlags.mResizeReflowOptimizationDisabled = PR_TRUE;\\n@@ -487,6 +496,7 @@ public:\\n     PRUint32 mBlock : 1;\\n     PRUint32 mImpactedByFloat : 1;\\n     PRUint32 mLineWrapped: 1;\\n+    PRUint32 mInvalidateTextRuns : 1;\\n     PRUint32 mResizeReflowOptimizationDisabled: 1;  // default 0 = means that the opt potentially applies to this line. 1 = never skip reflowing this line for a resize reflow\\n     PRUint32 mEmptyCacheValid: 1;\\n     PRUint32 mEmptyCacheState: 1;\\ndiff --git a/layout/generic/nsTextFrameThebes.cpp b/layout/generic/nsTextFrameThebes.cpp\\nindex 0b90702..2b394ad 100644\\n--- a/layout/generic/nsTextFrameThebes.cpp\\n+++ b/layout/generic/nsTextFrameThebes.cpp\\n@@ -1206,6 +1206,7 @@ BuildTextRuns(nsIRenderingContext* aRC, nsTextFrame* aForFrame,\\n     line = forwardIterator.GetLine();\\n     if (line->IsBlock())\\n       break;\\n+    line->SetInvalidateTextRuns(PR_FALSE);\\n     scanner.SetAtStartOfLine();\\n     scanner.SetCommonAncestorWithLastFrame(nsnull);\\n     nsIFrame* child = line->mFirstChild;\\n@@ -1966,7 +1967,7 @@ nsTextFrame::EnsureTextRun(nsIRenderingContext* aRC, nsIFrame* aLineContainer,\\n                            const nsLineList::iterator* aLine,\\n                            PRUint32* aFlowEndInTextRun)\\n {\\n-  if (mTextRun) {\\n+  if (mTextRun && (!aLine || !(*aLine)->GetInvalidateTextRuns())) {\\n     if (mTextRun->GetExpirationState()->IsTracked()) {\\n       gTextRuns->MarkUsed(mTextRun);\\n     }\\n@@ -5001,7 +5002,7 @@ nsTextFrame::AddInlineMinWidthForFlow(nsIRenderingContext *aRenderingContext,\\n {\\n   PRUint32 flowEndInTextRun;\\n   gfxSkipCharsIterator iter =\\n-    EnsureTextRun(aRenderingContext, nsnull, nsnull, &flowEndInTextRun);\\n+    EnsureTextRun(aRenderingContext, nsnull, aData->line, &flowEndInTextRun);\\n   if (!mTextRun)\\n     return;\\n \\n@@ -5099,7 +5100,7 @@ nsTextFrame::AddInlinePrefWidthForFlow(nsIRenderingContext *aRenderingContext,\\n {\\n   PRUint32 flowEndInTextRun;\\n   gfxSkipCharsIterator iter =\\n-    EnsureTextRun(aRenderingContext, nsnull, nsnull, &flowEndInTextRun);\\n+    EnsureTextRun(aRenderingContext, nsnull, aData->line, &flowEndInTextRun);\\n   if (!mTextRun)\\n     return;\\n \\n\""}