{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basd8e4ab4\""},"diff":"\"d8e4ab4 Bug 103487: use default anti-virus scanner to scan downloaded files on Windows, patch by Rob Arnold <robarnold@mozilla.com>, r=sdwilsh, r=jmathies, r=me\\ndiff --git a/toolkit/components/downloads/public/nsIDownloadManager.idl b/toolkit/components/downloads/public/nsIDownloadManager.idl\\nindex 70783b4..600c84d 100644\\n--- a/toolkit/components/downloads/public/nsIDownloadManager.idl\\n+++ b/toolkit/components/downloads/public/nsIDownloadManager.idl\\n@@ -55,13 +55,14 @@ interface mozIStorageConnection;\\n interface nsIDownloadManager : nsISupports {\\n   // Download States\\n   const short DOWNLOAD_NOTSTARTED       = -1;\\n-  const short DOWNLOAD_QUEUED           = 5;\\n   const short DOWNLOAD_DOWNLOADING      = 0;\\n   const short DOWNLOAD_FINISHED         = 1;\\n   const short DOWNLOAD_FAILED           = 2;\\n   const short DOWNLOAD_CANCELED         = 3;\\n   const short DOWNLOAD_PAUSED           = 4;\\n+  const short DOWNLOAD_QUEUED           = 5;\\n   const short DOWNLOAD_BLOCKED          = 6;\\n+  const short DOWNLOAD_SCANNING         = 7;\\n \\n   const short DOWNLOAD_TYPE_DOWNLOAD    = 0;\\n \\ndiff --git a/toolkit/components/downloads/src/Makefile.in b/toolkit/components/downloads/src/Makefile.in\\nindex d531a02..7ec15c4 100644\\n--- a/toolkit/components/downloads/src/Makefile.in\\n+++ b/toolkit/components/downloads/src/Makefile.in\\n@@ -65,12 +65,17 @@ REQUIRES  = xpcom \\\\\\n             embed_base \\\\\\n             alerts \\\\\\n             storage \\\\\\n+            xulapp \\\\\\n             $(NULL)\\n \\n CPPSRCS   = \\\\\\n     nsDownloadManager.cpp \\\\\\n     $(NULL)\\n \\n+ifeq ($(OS_ARCH),WINNT)\\n+CPPSRCS += nsDownloadScanner.cpp\\n+endif\\n+\\n include $(topsrcdir)/config/rules.mk\\n \\n EXTRA_DSO_LDOPTS += $(MOZ_COMPONENT_LIBS)\\ndiff --git a/toolkit/components/downloads/src/nsDownloadManager.cpp b/toolkit/components/downloads/src/nsDownloadManager.cpp\\nindex f852a97..fedaa2b 100644\\n--- a/toolkit/components/downloads/src/nsDownloadManager.cpp\\n+++ b/toolkit/components/downloads/src/nsDownloadManager.cpp\\n@@ -72,6 +72,7 @@\\n \\n #ifdef XP_WIN\\n #include <shlobj.h>\\n+#include \\\"nsDownloadScanner.h\\\"\\n #endif\\n \\n static PRBool gStoppingDownloads = PR_FALSE;\\n@@ -122,6 +123,9 @@ nsDownloadManager::GetSingleton()\\n \\n nsDownloadManager::~nsDownloadManager()\\n {\\n+#ifdef XP_WIN\\n+  delete mScanner;\\n+#endif\\n   gDownloadManagerService = nsnull;\\n }\\n \\n@@ -141,28 +145,13 @@ nsDownloadManager::CancelAllDownloads()\\n   return rv;\\n }\\n \\n-nsresult\\n-nsDownloadManager::FinishDownload(nsDownload *aDownload, DownloadState aState,\\n-                                  const char *aTopic) {\\n-  // We don't want to lose access to the download's member variables\\n-  nsRefPtr<nsDownload> kungFuDeathGrip = aDownload;\\n-\\n+void\\n+nsDownloadManager::CompleteDownload(nsDownload *aDownload)\\n+{\\n   // we've stopped, so break the cycle we created at download start\\n   aDownload->mCancelable = nsnull;\\n \\n-  // This has to be done in this exact order to not mess up our invariants\\n-  // 1) when the state changed listener is dispatched, it must no longer be\\n-  //    an active download.\\n-  // 2) when the observer is dispatched, the same conditions for 1 must be\\n-  //    true as well as the state being up to date.\\n   (void)mCurrentDownloads.RemoveObject(aDownload);\\n-\\n-  nsresult rv = aDownload->SetState(aState);\\n-  if (NS_FAILED(rv)) return rv;\\n-  \\n-  (void)mObserverService->NotifyObservers(aDownload, aTopic, nsnull);\\n-\\n-  return NS_OK;\\n }\\n \\n nsresult\\n@@ -573,6 +562,17 @@ nsDownloadManager::Init()\\n                                    getter_AddRefs(mBundle));\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n+#ifdef XP_WIN\\n+  mScanner = new nsDownloadScanner();\\n+  if (!mScanner)\\n+    return NS_ERROR_OUT_OF_MEMORY;\\n+  rv = mScanner->Init();\\n+  if (NS_FAILED(rv)) {\\n+    delete mScanner;\\n+    mScanner = nsnull;\\n+  }\\n+#endif\\n+\\n   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(\\n     \\\"UPDATE moz_downloads \\\"\\n     \\\"SET startTime = ?1, endTime = ?2, state = ?3, referrer = ?4 \\\"\\n@@ -691,6 +691,12 @@ nsDownloadManager::GetDownloadFromDB(PRUint32 aID, nsDownload **retVal)\\n   return NS_OK;\\n }\\n \\n+void\\n+nsDownloadManager::SendEvent(nsDownload *aDownload, const char *aTopic)\\n+{\\n+  (void)mObserverService->NotifyObservers(aDownload, aTopic, nsnull);\\n+}\\n+\\n ///////////////////////////////////////////////////////////////////////////////\\n //// nsIDownloadManager\\n \\n@@ -1010,8 +1016,7 @@ nsDownloadManager::CancelDownload(PRUint32 aID)\\n       dl->mTempFile->Remove(PR_FALSE);\\n   }\\n \\n-  nsresult rv = FinishDownload(dl, nsIDownloadManager::DOWNLOAD_CANCELED,\\n-                               \\\"dl-cancel\\\");\\n+  nsresult rv = dl->SetState(nsIDownloadManager::DOWNLOAD_CANCELED);\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n   return NS_OK;\\n@@ -1507,13 +1512,150 @@ nsDownload::SetState(DownloadState aState)\\n   PRInt16 oldState = mDownloadState;\\n   mDownloadState = aState;\\n \\n+  nsresult rv;\\n+\\n+  nsCOMPtr<nsIPrefBranch> pref = do_GetService(NS_PREFSERVICE_CONTRACTID);\\n+\\n+  // We don't want to lose access to our member variables\\n+  nsRefPtr<nsDownload> kungFuDeathGrip = this;\\n+\\n+  // When the state changed listener is dispatched, queries to the database and\\n+  // the download manager api should reflect what the nsIDownload object would\\n+  // return. So, if a download is done (finished, canceled, etc.), it should\\n+  // first be removed from the current downloads.  We will also have to update\\n+  // the database *before* notifying listeners.  At this point, you can safely\\n+  // dispatch to the observers as well.\\n+  switch (aState) {\\n+    case nsIDownloadManager::DOWNLOAD_BLOCKED:\\n+    case nsIDownloadManager::DOWNLOAD_CANCELED:\\n+      mDownloadManager->CompleteDownload(this);\\n+      break;\\n+#ifdef XP_WIN\\n+    case nsIDownloadManager::DOWNLOAD_SCANNING:\\n+    {\\n+      nsresult rv = mDownloadManager->mScanner ? mDownloadManager->mScanner->ScanDownload(this) : NS_ERROR_NOT_INITIALIZED;\\n+      // If we failed, then fall through to 'download finished'\\n+      if (NS_SUCCEEDED(rv))\\n+        break;\\n+      mDownloadState = aState = nsIDownloadManager::DOWNLOAD_FINISHED;\\n+    }\\n+#endif\\n+    case nsIDownloadManager::DOWNLOAD_FINISHED:\\n+    {\\n+      mDownloadManager->CompleteDownload(this);\\n+\\n+      // Master pref to control this function. \\n+      PRBool showTaskbarAlert = PR_TRUE;\\n+      if (pref)\\n+        pref->GetBoolPref(PREF_BDM_SHOWALERTONCOMPLETE, &showTaskbarAlert);\\n+\\n+      if (showTaskbarAlert) {\\n+        PRInt32 alertInterval = 2000;\\n+        if (pref)\\n+          pref->GetIntPref(PREF_BDM_SHOWALERTINTERVAL, &alertInterval);\\n+\\n+        PRInt64 alertIntervalUSec = alertInterval * PR_USEC_PER_MSEC;\\n+        PRInt64 goat = PR_Now() - mStartTime;\\n+        showTaskbarAlert = goat > alertIntervalUSec;\\n+       \\n+        PRInt32 size = mDownloadManager->mCurrentDownloads.Count();\\n+        if (showTaskbarAlert && size == 0) {\\n+          nsCOMPtr<nsIAlertsService> alerts =\\n+            do_GetService(\\\"@mozilla.org/alerts-service;1\\\");\\n+          if (alerts) {\\n+              nsXPIDLString title, message;\\n+\\n+              mDownloadManager->mBundle->GetStringFromName(\\n+                  NS_LITERAL_STRING(\\\"downloadsCompleteTitle\\\").get(),\\n+                  getter_Copies(title));\\n+              mDownloadManager->mBundle->GetStringFromName(\\n+                  NS_LITERAL_STRING(\\\"downloadsCompleteMsg\\\").get(),\\n+                  getter_Copies(message));\\n+\\n+              PRBool removeWhenDone =\\n+                mDownloadManager->GetRetentionBehavior() == 0;\\n+\\n+\\n+              // If downloads are automatically removed per the user's\\n+              // retention policy, there's no reason to make the text clickable\\n+              // because if it is, they'll click open the download manager and\\n+              // the items they downloaded will have been removed. \\n+              alerts->ShowAlertNotification(\\n+                  NS_LITERAL_STRING(DOWNLOAD_MANAGER_ALERT_ICON), title,\\n+                  message, !removeWhenDone, EmptyString(), mDownloadManager);\\n+            }\\n+        }\\n+      }\\n+#ifdef XP_WIN\\n+      PRBool addToRecentDocs = PR_TRUE;\\n+      if (pref)\\n+        pref->GetBoolPref(PREF_BDM_ADDTORECENTDOCS, &addToRecentDocs);\\n+\\n+      if (addToRecentDocs) {\\n+        LPSHELLFOLDER lpShellFolder = NULL;\\n+\\n+        if (SUCCEEDED(::SHGetDesktopFolder(&lpShellFolder))) {\\n+          nsresult rv;\\n+          nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(mTarget, &rv);\\n+          NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+          nsCOMPtr<nsIFile> file;\\n+          rv = fileURL->GetFile(getter_AddRefs(file));\\n+          NS_ENSURE_SUCCESS(rv, rv);\\n+          \\n+          nsAutoString path;\\n+          rv = file->GetPath(path);\\n+          NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+          PRUnichar *filePath = ToNewUnicode(path);\\n+          LPITEMIDLIST lpItemIDList = NULL;\\n+          if (SUCCEEDED(lpShellFolder->ParseDisplayName(NULL, NULL, filePath,\\n+                  NULL, &lpItemIDList, NULL))) {\\n+            ::SHAddToRecentDocs(SHARD_PIDL, lpItemIDList);\\n+            ::CoTaskMemFree(lpItemIDList);\\n+          }\\n+          nsMemory::Free(filePath);\\n+          lpShellFolder->Release();\\n+        }\\n+      }\\n+#endif\\n+\\n+      // Now remove the download if the user's retention policy is \\\"Remove when Done\\\"\\n+      if (mDownloadManager->GetRetentionBehavior() == 0)\\n+        mDownloadManager->RemoveDownload(mID);\\n+\\n+    }\\n+    break;\\n+  default:\\n+    break;\\n+  }\\n+  \\n   // Before notifying the listener, we must update the database so that calls\\n   // to it work out properly.\\n-  nsresult rv = UpdateDB();\\n+  rv = UpdateDB();\\n   NS_ENSURE_SUCCESS(rv, rv);\\n-  \\n+\\n   mDownloadManager->NotifyListenersOnDownloadStateChange(oldState, this);\\n \\n+  switch (mDownloadState) {\\n+    case nsIDownloadManager::DOWNLOAD_DOWNLOADING:\\n+      mDownloadManager->SendEvent(this, \\\"dl-start\\\");\\n+      break;\\n+    case nsIDownloadManager::DOWNLOAD_FAILED:\\n+      mDownloadManager->SendEvent(this, \\\"dl-failed\\\");\\n+      break;\\n+    case nsIDownloadManager::DOWNLOAD_SCANNING:\\n+      mDownloadManager->SendEvent(this, \\\"dl-scanning\\\");\\n+      break;\\n+    case nsIDownloadManager::DOWNLOAD_FINISHED:\\n+      mDownloadManager->SendEvent(this, \\\"dl-done\\\");\\n+      break;\\n+    case nsIDownloadManager::DOWNLOAD_BLOCKED:\\n+      mDownloadManager->SendEvent(this, \\\"dl-blocked\\\");\\n+      break;\\n+    default:\\n+      break;\\n+  }\\n   return NS_OK;\\n }\\n \\n@@ -1577,7 +1719,6 @@ nsDownload::OnProgressChange64(nsIWebProgress *aWebProgress,\\n     // Update the state and the database\\n     rv = SetState(nsIDownloadManager::DOWNLOAD_DOWNLOADING);\\n     NS_ENSURE_SUCCESS(rv, rv);\\n-    mDownloadManager->mObserverService->NotifyObservers(this, \\\"dl-start\\\", nsnull);\\n   }\\n \\n   // filter notifications since they come in so frequently\\n@@ -1661,9 +1802,7 @@ nsDownload::OnStatusChange(nsIWebProgress *aWebProgress,\\n     // We don't want to lose access to our member variables\\n     nsRefPtr<nsDownload> kungFuDeathGrip = this;\\n \\n-    (void)mDownloadManager->FinishDownload(this,\\n-                                           nsIDownloadManager::DOWNLOAD_FAILED,\\n-                                           \\\"dl-failed\\\");\\n+    (void)SetState(nsIDownloadManager::DOWNLOAD_FAILED);\\n \\n     // Get title for alert.\\n     nsXPIDLString title;\\n@@ -1705,7 +1844,6 @@ nsDownload::OnStateChange(nsIWebProgress* aWebProgress,\\n   \\n   // We need to update mDownloadState before updating the dialog, because\\n   // that will close and call CancelDownload if it was the last open window.\\n-  nsCOMPtr<nsIPrefBranch> pref = do_GetService(NS_PREFSERVICE_CONTRACTID);\\n \\n   if (aStateFlags & STATE_START) {\\n     nsresult rv;\\n@@ -1721,9 +1859,7 @@ nsDownload::OnStateChange(nsIWebProgress* aWebProgress,\\n           (void)mCancelable->Cancel(NS_BINDING_ABORTED);\\n \\n         // Fail the download - DOWNLOAD_BLOCKED\\n-        mDownloadManager->FinishDownload(this, \\n-                                         nsIDownloadManager::DOWNLOAD_BLOCKED,\\n-                                         \\\"dl-blocked\\\");\\n+        (void)SetState(nsIDownloadManager::DOWNLOAD_BLOCKED);\\n \\n         mDownloadManager->NotifyListenersOnStateChange(aWebProgress, aRequest,\\n                                                        aStateFlags, aStatus, this);\\n@@ -1733,7 +1869,7 @@ nsDownload::OnStateChange(nsIWebProgress* aWebProgress,\\n     }\\n   } else if (aStateFlags & STATE_STOP) {\\n     if (nsDownloadManager::IsInFinalStage(mDownloadState)) {\\n-      // Set file size at the end of a tranfer (for unknown transfer amounts)\\n+      // Set file size at the end of a transfer (for unknown transfer amounts)\\n       if (mMaxBytes == LL_MAXUINT)\\n         mMaxBytes = mCurrBytes;\\n \\n@@ -1745,88 +1881,17 @@ nsDownload::OnStateChange(nsIWebProgress* aWebProgress,\\n \\n       mPercentComplete = 100;\\n \\n-      (void)mDownloadManager->FinishDownload(this,\\n-                                             nsIDownloadManager::DOWNLOAD_FINISHED,\\n-                                             \\\"dl-done\\\");\\n-\\n-      // Master pref to control this function. \\n-      PRBool showTaskbarAlert = PR_TRUE;\\n-      if (pref)\\n-        pref->GetBoolPref(PREF_BDM_SHOWALERTONCOMPLETE, &showTaskbarAlert);\\n-\\n-      if (showTaskbarAlert) {\\n-        PRInt32 alertInterval = -1;\\n-        pref->GetIntPref(PREF_BDM_SHOWALERTINTERVAL, &alertInterval);\\n-\\n-        PRInt64 alertIntervalUSec = alertInterval * PR_USEC_PER_MSEC;\\n-        PRInt64 goat = PR_Now() - mStartTime;\\n-        showTaskbarAlert = goat > alertIntervalUSec;\\n-       \\n-        PRInt32 size = mDownloadManager->mCurrentDownloads.Count();\\n-        if (showTaskbarAlert && size == 0) {\\n-          nsCOMPtr<nsIAlertsService> alerts =\\n-            do_GetService(\\\"@mozilla.org/alerts-service;1\\\");\\n-        if (alerts) {\\n-            nsXPIDLString title, message;\\n-\\n-            mDownloadManager->mBundle->GetStringFromName(NS_LITERAL_STRING(\\\"downloadsCompleteTitle\\\").get(), getter_Copies(title));\\n-            mDownloadManager->mBundle->GetStringFromName(NS_LITERAL_STRING(\\\"downloadsCompleteMsg\\\").get(), getter_Copies(message));\\n-\\n-            PRBool removeWhenDone = mDownloadManager->GetRetentionBehavior() == 0;\\n-\\n-\\n-            // If downloads are automatically removed per the user's retention policy, \\n-            // there's no reason to make the text clickable because if it is, they'll\\n-            // click open the download manager and the items they downloaded will have\\n-            // been removed. \\n-            alerts->ShowAlertNotification(NS_LITERAL_STRING(DOWNLOAD_MANAGER_ALERT_ICON), title, message, !removeWhenDone, \\n-                                          EmptyString(), mDownloadManager);\\n-          }\\n-        }\\n-      }\\n #ifdef XP_WIN\\n-      PRBool addToRecentDocs = PR_TRUE;\\n-      if (pref)\\n-        pref->GetBoolPref(PREF_BDM_ADDTORECENTDOCS, &addToRecentDocs);\\n-\\n-      if (addToRecentDocs) {\\n-        LPSHELLFOLDER lpShellFolder = NULL;\\n-\\n-        if (SUCCEEDED(::SHGetDesktopFolder(&lpShellFolder))) {\\n-          nsresult rv;\\n-          nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(mTarget, &rv);\\n-          NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-          nsCOMPtr<nsIFile> file;\\n-          rv = fileURL->GetFile(getter_AddRefs(file));\\n-          NS_ENSURE_SUCCESS(rv, rv);\\n-        \\n-          nsAutoString path;\\n-          rv = file->GetPath(path);\\n-          NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-          PRUnichar *filePath = ToNewUnicode(path);\\n-          LPITEMIDLIST lpItemIDList = NULL;\\n-          if (SUCCEEDED(lpShellFolder->ParseDisplayName(NULL, NULL, filePath, NULL, &lpItemIDList, NULL))) {\\n-            ::SHAddToRecentDocs(SHARD_PIDL, lpItemIDList);\\n-            ::CoTaskMemFree(lpItemIDList);\\n-          }\\n-          nsMemory::Free(filePath);\\n-          lpShellFolder->Release();\\n-        }\\n-      }\\n+      (void)SetState(nsIDownloadManager::DOWNLOAD_SCANNING);\\n+#else\\n+      (void)SetState(nsIDownloadManager::DOWNLOAD_FINISHED);\\n #endif\\n     }\\n-\\n-    // Now remove the download if the user's retention policy is \\\"Remove when Done\\\"\\n-    if (mDownloadManager->GetRetentionBehavior() == 0)\\n-      mDownloadManager->RemoveDownload(mID);\\n   }\\n \\n   mDownloadManager->NotifyListenersOnStateChange(aWebProgress, aRequest,\\n                                                  aStateFlags, aStatus, this);\\n-\\n-  return UpdateDB();\\n+  return NS_OK;\\n }\\n \\n NS_IMETHODIMP\\ndiff --git a/toolkit/components/downloads/src/nsDownloadManager.h b/toolkit/components/downloads/src/nsDownloadManager.h\\nindex 4e4f8e0..4e17472 100644\\n--- a/toolkit/components/downloads/src/nsDownloadManager.h\\n+++ b/toolkit/components/downloads/src/nsDownloadManager.h\\n@@ -71,6 +71,10 @@ typedef PRInt16 DownloadType;\\n \\n class nsDownload;\\n \\n+#ifdef XP_WIN\\n+class nsDownloadScanner;\\n+#endif\\n+\\n class nsDownloadManager : public nsIDownloadManager,\\n                           public nsIObserver\\n {\\n@@ -84,6 +88,11 @@ public:\\n   static nsDownloadManager *GetSingleton();\\n \\n   virtual ~nsDownloadManager();\\n+#ifdef XP_WIN\\n+  nsDownloadManager() : mScanner(nsnull) { };\\n+private:\\n+  nsDownloadScanner *mScanner;\\n+#endif\\n \\n protected:\\n   struct TimerParams {\\n@@ -103,6 +112,8 @@ protected:\\n     return NS_OK;\\n   }\\n \\n+  void SendEvent(nsDownload *aDownload, const char *aTopic);\\n+\\n \\n   /**\\n    * Adds a download with the specified information to the DB.\\n@@ -136,14 +147,12 @@ protected:\\n   nsresult CancelAllDownloads();\\n \\n   /**\\n-   * Removes download from \\\"current downloads,\\\" updates download state, and\\n-   * notifies observers.\\n+   * Removes download from \\\"current downloads\\\". \\n    *\\n    * This method removes the cycle created when starting the download, so \\n    * make sure to use kungFuDeathGrip if you want to access member variables\\n    */\\n-  nsresult FinishDownload(nsDownload *aDownload, DownloadState aState,\\n-                          const char *aTopic);\\n+  void CompleteDownload(nsDownload *aDownload);\\n \\n   void     ConfirmCancelDownloads(PRInt32 aCount,\\n                                   nsISupportsPRBool* aCancelDownloads,\\ndiff --git a/toolkit/components/downloads/src/nsDownloadScanner.cpp b/toolkit/components/downloads/src/nsDownloadScanner.cpp\\nnew file mode 100644\\nindex 0000000..87726d20\\n--- /dev/null\\n+++ b/toolkit/components/downloads/src/nsDownloadScanner.cpp\\n@@ -0,0 +1,313 @@\\n+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n+/* vim: se cin sw=2 ts=2 et : */\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is download manager code.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Mozilla Corporation\\n+ *\\n+ * Contributor(s):\\n+ *   Rob Arnold <robarnold@mozilla.com> (Original Author)\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+ \\n+#include \\\"nsDownloadScanner.h\\\"\\n+#include <comcat.h>\\n+#include <process.h>\\n+#include \\\"nsDownloadManager.h\\\"\\n+#include \\\"nsIXULAppInfo.h\\\"\\n+#include \\\"nsXULAppAPI.h\\\"\\n+#include \\\"nsIPrefService.h\\\"\\n+#include \\\"nsNetUtil.h\\\"\\n+\\n+/**\\n+ * Code overview\\n+ *\\n+ * Antivirus vendors on Windows can implement the IOfficeAntiVirus interface\\n+ * so that other programs (not just Office) can use their functionality.\\n+ * According to the Microsoft documentation, this interface requires only\\n+ * Windows 95/NT 4 and IE 5 so it is used in preference to IAttachmentExecute\\n+ * which requires XP SP2 (Windows 2000 is still supported at this time). \\n+ *\\n+ * The interface is rather simple; it provides a Scan method which takes a\\n+ * small structure describing what to scan. Unfortunately, the method is\\n+ * synchronous and could take a while, so it is not a good idea to call it from\\n+ * the main thread. Some antivirus scanners can take a long time to scan or the\\n+ * call might block while the scanner shows its UI so if the user were to\\n+ * download many files that finished around the same time, they would have to\\n+ * wait a while if the scanning were done on exactly one other thread. Since\\n+ * the overhead of creating a thread is relatively small compared to the time\\n+ * it takes to download a file and scan it, a new thread is spawned for each\\n+ * download that is to be scanned. Since most of the mozilla codebase is not\\n+ * threadsafe, all the information needed for the scanner is gathered in the\\n+ * main thread in nsDownloadScanner::Scan::Start. The only function of\\n+ * nsDownloadScanner::Scan which is invoked on another thread is DoScan.\\n+ *\\n+ * There are 4 possible outcomes of the virus scan:\\n+ *    AVSCAN_GOOD   => the file is clean\\n+ *    AVSCAN_BAD    => the file has a virus\\n+ *    AVSCAN_UGLY   => the file had a virus, but it was cleaned\\n+ *    AVSCAN_FAILED => something else went wrong with the virus scanner.\\n+ *\\n+ * Both the good and ugly states leave the user with a benign file, so they\\n+ * transition to the finished state. Bad files are sent to the blocked state.\\n+ * Failed states transition to finished downloads.\\n+ *\\n+ * Possible Future enhancements:\\n+ *  * Use all available virus scanners instead of just the first one that is\\n+ *    enumerated (or use some heuristic)\\n+ *  * Create an interface for scanning files in general\\n+ *  * Make this a service\\n+ *  * Get antivirus scanner status via WMI/registry\\n+ */\\n+\\n+#define PREF_BDA_DONTCLEAN \\\"browser.download.antivirus.dontclean\\\"\\n+\\n+nsDownloadScanner::nsDownloadScanner()\\n+  : mHaveAVScanner(PR_FALSE)\\n+{\\n+}\\n+\\n+nsresult\\n+nsDownloadScanner::Init()\\n+{\\n+  // This CoInitialize/CoUninitialize pattern seems to be common in the Mozilla\\n+  // codebase. All other COM calls/objects are made on different threads.\\n+  nsresult rv = NS_OK;\\n+  CoInitialize(NULL);\\n+  if (FindCLSID() < 0)\\n+    rv = NS_ERROR_NOT_AVAILABLE;\\n+  CoUninitialize();\\n+  return rv;\\n+}\\n+\\n+PRInt32\\n+nsDownloadScanner::FindCLSID()\\n+{\\n+  nsRefPtr<ICatInformation> catInfo;\\n+  HRESULT hr;\\n+  hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_INPROC,\\n+                        IID_ICatInformation, getter_AddRefs(catInfo));\\n+  if (FAILED(hr)) {\\n+    NS_WARNING(\\\"Could not create category information class\\\\n\\\");\\n+    return -1;\\n+  }\\n+  nsRefPtr<IEnumCLSID> clsidEnumerator;\\n+  GUID guids [1] = { CATID_MSOfficeAntiVirus };\\n+  hr = catInfo->EnumClassesOfCategories(1, guids, 0, NULL,\\n+      getter_AddRefs(clsidEnumerator));\\n+  if (FAILED(hr)) {\\n+    NS_WARNING(\\\"Could not get class enumerator for category\\\\n\\\");\\n+    return -2;\\n+  }\\n+  ULONG nReceived;\\n+  clsidEnumerator->Next(1, &mScannerCLSID, &nReceived);\\n+  if (nReceived == 0) {\\n+    // No installed Anti Virus program\\n+    return -3;\\n+  }\\n+  mHaveAVScanner = PR_TRUE;\\n+  return 0;\\n+}\\n+\\n+unsigned int __stdcall\\n+nsDownloadScanner::ScannerThreadFunction(void *p)\\n+{\\n+  NS_ASSERTION(!NS_IsMainThread(), \\\"Antivirus scan should not be run on the main thread\\\");\\n+  nsDownloadScanner::Scan *scan = static_cast<nsDownloadScanner::Scan*>(p);\\n+  scan->DoScan();\\n+  _endthreadex(0);\\n+  return 0;\\n+}\\n+\\n+nsDownloadScanner::Scan::Scan(nsDownloadScanner *scanner, nsDownload *download)\\n+  : mDLScanner(scanner), mAVScanner(NULL), mThread(NULL), \\n+    mDownload(download), mStatus(AVSCAN_NOTSTARTED)\\n+{\\n+}\\n+\\n+nsresult\\n+nsDownloadScanner::Scan::Start()\\n+{\\n+  mThread = (HANDLE)_beginthreadex(NULL, 0, ScannerThreadFunction,\\n+      this, CREATE_SUSPENDED, NULL);\\n+  if (!mThread)\\n+    return NS_ERROR_OUT_OF_MEMORY;\\n+\\n+  nsresult rv = NS_OK;\\n+\\n+  // Default is to try to clean downloads\\n+  mIsReadOnlyRequest = PR_FALSE;\\n+\\n+  nsCOMPtr<nsIPrefBranch> pref =\\n+    do_GetService(NS_PREFSERVICE_CONTRACTID);\\n+  if (pref)\\n+    rv = pref->GetBoolPref(PREF_BDA_DONTCLEAN, &mIsReadOnlyRequest);\\n+\\n+  // Get the path to the file on disk\\n+  nsCOMPtr<nsILocalFile> file;\\n+  rv = mDownload->GetTargetFile(getter_AddRefs(file));\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+  rv = file->GetPath(mPath);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+\\n+  // Grab the app name\\n+  nsCOMPtr<nsIXULAppInfo> appinfo =\\n+    do_GetService(XULAPPINFO_SERVICE_CONTRACTID, &rv);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  nsCAutoString name;\\n+  rv = appinfo->GetName(name);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+  CopyUTF8toUTF16(name, mName);\\n+\\n+\\n+  // Get the origin\\n+  nsCOMPtr<nsIURI> uri;\\n+  rv = mDownload->GetSource(getter_AddRefs(uri));\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  nsCAutoString origin;\\n+  rv = uri->GetSpec(origin);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  CopyUTF8toUTF16(origin, mOrigin);\\n+\\n+\\n+  // We count https/ftp/http as an http download\\n+  PRBool isHttp(PR_FALSE), isFtp(PR_FALSE), isHttps(PR_FALSE);\\n+  nsCOMPtr<nsIURI> innerURI = NS_GetInnermostURI(uri);\\n+  (void)innerURI->SchemeIs(\\\"http\\\", &isHttp);\\n+  (void)innerURI->SchemeIs(\\\"ftp\\\", &isFtp);\\n+  (void)innerURI->SchemeIs(\\\"https\\\", &isHttps);\\n+  mIsHttpDownload = isHttp || isFtp || isHttps;\\n+\\n+  // ResumeThread returns the previous suspend count\\n+  if (1 != ::ResumeThread(mThread)) {\\n+    CloseHandle(mThread);\\n+    return NS_ERROR_UNEXPECTED;\\n+  }\\n+  return NS_OK;\\n+}\\n+\\n+nsresult\\n+nsDownloadScanner::Scan::Run()\\n+{\\n+  // Cleanup our thread\\n+  WaitForSingleObject(mThread, INFINITE);\\n+  CloseHandle(mThread);\\n+\\n+  DownloadState downloadState = 0;\\n+  switch (mStatus) {\\n+    case AVSCAN_BAD:\\n+      downloadState = nsIDownloadManager::DOWNLOAD_BLOCKED;\\n+      break;\\n+    default:\\n+    case AVSCAN_FAILED:\\n+    case AVSCAN_GOOD:\\n+    case AVSCAN_UGLY:\\n+      downloadState = nsIDownloadManager::DOWNLOAD_FINISHED;\\n+      break;\\n+  }\\n+  (void)mDownload->SetState(downloadState);\\n+\\n+  NS_RELEASE_THIS();\\n+  return NS_OK;\\n+}\\n+\\n+void\\n+nsDownloadScanner::Scan::DoScan()\\n+{\\n+  HRESULT hr;\\n+  MSOAVINFO info;\\n+  info.cbsize = sizeof(MSOAVINFO);\\n+  info.fPath = TRUE;\\n+  info.fInstalled = FALSE;\\n+  info.fReadOnlyRequest = mIsReadOnlyRequest;\\n+  info.fHttpDownload = mIsHttpDownload;\\n+  info.hwnd = NULL;\\n+\\n+  info.pwzHostName = mName.BeginWriting();\\n+  info.u.pwzFullPath = mPath.BeginWriting();\\n+\\n+  info.pwzOrigURL = mOrigin.BeginWriting();\\n+\\n+  CoInitialize(NULL);\\n+  hr = CoCreateInstance(mDLScanner->mScannerCLSID, NULL, CLSCTX_ALL,\\n+                        IID_IOfficeAntiVirus, getter_AddRefs(mAVScanner));\\n+  if (FAILED(hr)) {\\n+    NS_WARNING(\\\"Could not instantiate antivirus scanner\\\");\\n+    mStatus = AVSCAN_FAILED;\\n+  } else {\\n+    mStatus = AVSCAN_SCANNING;\\n+    hr = mAVScanner->Scan(&info);\\n+    switch (hr) {\\n+    case S_OK:\\n+      mStatus = AVSCAN_GOOD;\\n+      break;\\n+    case S_FALSE:\\n+      mStatus = AVSCAN_UGLY;\\n+      break;\\n+    case E_FAIL:\\n+      mStatus = AVSCAN_BAD;\\n+      break;\\n+    default:\\n+    case ERROR_FILE_NOT_FOUND:\\n+      NS_WARNING(\\\"Downloaded file disappeared before it could be scanned\\\");\\n+      mStatus = AVSCAN_FAILED;\\n+      break;\\n+    }\\n+  }\\n+  CoUninitialize();\\n+\\n+  // We need to do a few more things on the main thread\\n+  NS_DispatchToMainThread(this);\\n+}\\n+\\n+nsresult\\n+nsDownloadScanner::ScanDownload(nsDownload *download)\\n+{\\n+  if (!mHaveAVScanner)\\n+    return NS_ERROR_NOT_AVAILABLE;\\n+\\n+  // No ref ptr, see comment below\\n+  Scan *scan = new Scan(this, download);\\n+  if (!scan)\\n+    return NS_ERROR_OUT_OF_MEMORY;\\n+\\n+  NS_ADDREF(scan);\\n+\\n+  nsresult rv = scan->Start();\\n+\\n+  // Note that we only release upon error. On success, the scan is passed off\\n+  // to a new thread. It is eventually released in Scan::Run on the main thread.\\n+  if (NS_FAILED(rv))\\n+    NS_RELEASE(scan);\\n+\\n+  return rv;\\n+}\\ndiff --git a/toolkit/components/downloads/src/nsDownloadScanner.h b/toolkit/components/downloads/src/nsDownloadScanner.h\\nnew file mode 100644\\nindex 0000000..e7a4a26\\n--- /dev/null\\n+++ b/toolkit/components/downloads/src/nsDownloadScanner.h\\n@@ -0,0 +1,67 @@\\n+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n+/* vim: se cin sw=2 ts=2 et : */\\n+#ifndef nsDownloadScanner_h_\\n+#define nsDownloadScanner_h_\\n+\\n+#ifdef WIN32_LEAN_AND_MEAN\\n+#undef WIN32_LEAN_AND_MEAN\\n+#endif\\n+#define INITGUID\\n+#include <Windows.h>\\n+#define AVVENDOR\\n+#include <msoav.h>\\n+\\n+#include \\\"nsAutoPtr.h\\\"\\n+#include \\\"nsThreadUtils.h\\\"\\n+#include \\\"nsDownloadManager.h\\\"\\n+\\n+enum AVScanState\\n+{\\n+  AVSCAN_NOTSTARTED = 0,\\n+  AVSCAN_SCANNING,\\n+  AVSCAN_GOOD,\\n+  AVSCAN_BAD,\\n+  AVSCAN_UGLY,\\n+  AVSCAN_FAILED\\n+};\\n+\\n+class nsDownloadScanner\\n+{\\n+public:\\n+  nsDownloadScanner();\\n+  nsresult Init();\\n+  nsresult ScanDownload(nsDownload *download);\\n+\\n+private:\\n+  PRBool mHaveAVScanner;\\n+  CLSID mScannerCLSID;\\n+  PRInt32 FindCLSID();\\n+\\n+  static unsigned int __stdcall ScannerThreadFunction(void *p);\\n+  class Scan : public nsRunnable\\n+  {\\n+  public:\\n+    Scan(nsDownloadScanner *scanner, nsDownload *download);\\n+    nsresult Start();\\n+\\n+  private:\\n+    nsDownloadScanner *mDLScanner;\\n+    nsRefPtr<IOfficeAntiVirus> mAVScanner;\\n+    HANDLE mThread;\\n+    nsRefPtr<nsDownload> mDownload;\\n+    AVScanState mStatus;\\n+    nsString mPath;\\n+    nsString mName;\\n+    nsString mOrigin;\\n+    // Also true if it is an ftp download\\n+    PRBool mIsHttpDownload;\\n+    PRBool mIsReadOnlyRequest;\\n+\\n+    NS_IMETHOD Run();\\n+\\n+    void DoScan();\\n+\\n+    friend unsigned int __stdcall nsDownloadScanner::ScannerThreadFunction(void *);\\n+  };\\n+};\\n+#endif\\n\""}