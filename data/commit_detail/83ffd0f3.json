{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas83ffd0f3\""},"diff":"\"83ffd0f3 Bug 370245 - Make the HTTP server asynchronously process requests, and pave the way for future improvements to processing.  r=biesi, a=bsmedberg on a testing-only change\\ndiff --git a/netwerk/test/httpserver/README b/netwerk/test/httpserver/README\\nindex 9e2d0b9..d16b1b05 100644\\n--- a/netwerk/test/httpserver/README\\n+++ b/netwerk/test/httpserver/README\\n@@ -78,6 +78,10 @@ calling server.stop() before the host application closes to ensure that all\\n requests have completed.  Things probably aren't going to break too horribly if\\n you don't do this, but better safe than sorry.\\n \\n+MozJSHTTP makes no effort to time out requests, beyond any the socket itself\\n+might or might not provide.  I don't believe it provides any by default, but\\n+I haven't verified this.\\n+\\n To be clear: the guarantee that nsIHttpServer.stop says implementations should\\n make when possible (that .stop returns only when all pending requests have been\\n serviced) cannot be made in a 1.8 environment; it can be made in a 1.9\\ndiff --git a/netwerk/test/httpserver/TODO b/netwerk/test/httpserver/TODO\\nindex e21dbdb..3a95466 100644\\n--- a/netwerk/test/httpserver/TODO\\n+++ b/netwerk/test/httpserver/TODO\\n@@ -5,11 +5,6 @@ Bugs to fix:\\n   a performance standpoint?)\\n \\n Ideas for future improvements:\\n-- mod_cern_meta or Apache asis functionality (probably the former, since\\n-  asis+binary files looks annoying but is a definite want, and line endings are\\n-  likely a pain):\\n-    <http://httpd.apache.org/docs/2.0/mod/mod_cern_meta.html> and\\n-    <http://httpd.apache.org/docs/2.0/mod/mod_asis.html>\\n - add API to disable response buffering which, when called, causes errors when\\n   you try to do anything other than write to the body stream (i.e., modify\\n   headers or status line) once you've written anything to it -- useful when\\ndiff --git a/netwerk/test/httpserver/httpd.js b/netwerk/test/httpserver/httpd.js\\nindex c3d6432..6e702a3 100644\\n--- a/netwerk/test/httpserver/httpd.js\\n+++ b/netwerk/test/httpserver/httpd.js\\n@@ -81,6 +81,13 @@ function HttpError(code, description)\\n   this.code = code;\\n   this.description = description;\\n }\\n+HttpError.prototype =\\n+{\\n+  toString: function()\\n+  {\\n+    return this.code + \\\" \\\" + this.description;\\n+  }\\n+};\\n \\n /**\\n  * Errors thrown to trigger specific HTTP server responses.\\n@@ -158,12 +165,30 @@ function dumpn(str)\\n     dump(str + \\\"\\\\n\\\");\\n }\\n \\n+/** Dumps the current JS stack if DEBUG. */\\n+function dumpStack()\\n+{\\n+  // peel off the frames for dumpStack() and Error()\\n+  var stack = new Error().stack.split(/\\\\n/).slice(2);\\n+  stack.forEach(dumpn);\\n+}\\n+\\n+\\n+/** The XPCOM thread manager. */\\n+var gThreadManager = null;\\n+\\n \\n /**\\n  * JavaScript constructors for commonly-used classes; precreating these is a\\n  * speedup over doing the same from base principles.  See the docs at\\n  * http://developer.mozilla.org/en/docs/Components.Constructor for details.\\n  */\\n+const ServerSocket = CC(\\\"@mozilla.org/network/server-socket;1\\\",\\n+                        \\\"nsIServerSocket\\\",\\n+                        \\\"init\\\");\\n+const BinaryInputStream = CC(\\\"@mozilla.org/binaryinputstream;1\\\",\\n+                             \\\"nsIBinaryInputStream\\\",\\n+                             \\\"setInputStream\\\");\\n const Pipe = CC(\\\"@mozilla.org/pipe;1\\\",\\n                 \\\"nsIPipe\\\",\\n                 \\\"init\\\");\\n@@ -173,6 +198,9 @@ const FileInputStream = CC(\\\"@mozilla.org/network/file-input-stream;1\\\",\\n const StreamCopier = CC(\\\"@mozilla.org/network/async-stream-copier;1\\\",\\n                         \\\"nsIAsyncStreamCopier\\\",\\n                         \\\"init\\\");\\n+const Pump = CC(\\\"@mozilla.org/network/input-stream-pump;1\\\",\\n+                \\\"nsIInputStreamPump\\\",\\n+                \\\"init\\\");\\n const ConverterInputStream = CC(\\\"@mozilla.org/intl/converter-input-stream;1\\\",\\n                                 \\\"nsIConverterInputStream\\\",\\n                                 \\\"init\\\");\\n@@ -185,10 +213,10 @@ const SupportsString = CC(\\\"@mozilla.org/supports-string;1\\\",\\n /**\\n  * Returns the RFC 822/1123 representation of a date.\\n  *\\n- * @param date\\n+ * @param date : Number\\n  *   the date, in milliseconds from midnight (00:00:00), January 1, 1970 GMT\\n- * @returns\\n- *   the string specifying the given date\\n+ * @returns string\\n+ *   the representation of the given date\\n  */\\n function toDateString(date)\\n {\\n@@ -213,9 +241,9 @@ function toDateString(date)\\n    * Processes a date and returns the encoded UTC time as a string according to\\n    * the format specified in RFC 2616.\\n    *\\n-   * @param date\\n-   *   the date as a JavaScript Date object\\n-   * @returns\\n+   * @param date : Date\\n+   *   the date to process\\n+   * @returns string\\n    *   a string of the form \\\"HH:MM:SS\\\", ranging from \\\"00:00:00\\\" to \\\"23:59:59\\\"\\n    */\\n   function toTime(date)\\n@@ -238,9 +266,9 @@ function toDateString(date)\\n    * Processes a date and returns the encoded UTC date as a string according to\\n    * the date1 format specified in RFC 2616.\\n    *\\n-   * @param date\\n-   *   the date as a JavaScript Date object\\n-   * @returns\\n+   * @param date : Date\\n+   *   the date to process\\n+   * @returns string\\n    *   a string of the form \\\"HH:MM:SS\\\", ranging from \\\"00:00:00\\\" to \\\"23:59:59\\\"\\n    */\\n   function toDate1(date)\\n@@ -267,7 +295,7 @@ function toDateString(date)\\n /**\\n  * Prints out a human-readable representation of the object o and its fields,\\n  * omitting those whose names begin with \\\"_\\\" if showMembers != true (to ignore\\n- * hidden properties exposed via getters/setters).\\n+ * \\\"private\\\" properties exposed via getters/setters).\\n  */\\n function printObj(o, showMembers)\\n {\\n@@ -289,6 +317,9 @@ function printObj(o, showMembers)\\n  */\\n function nsHttpServer()\\n {\\n+  if (!gThreadManager)\\n+    gThreadManager = Cc[\\\"@mozilla.org/thread-manager;1\\\"].getService();\\n+\\n   /** The port on which this server listens. */\\n   this._port = undefined;\\n \\n@@ -314,28 +345,51 @@ nsHttpServer.prototype =\\n   // NSISERVERSOCKETLISTENER\\n \\n   /**\\n-   * This function signals that a new connection has been accepted.  It is the\\n-   * method through which all requests must be handled, and by the end of this\\n-   * method any and all response requests must be sent.\\n+   * Processes an incoming request coming in on the given socket and contained\\n+   * in the given transport.\\n    *\\n+   * @param socket : nsIServerSocket\\n+   *   the socket through which the request was served\\n+   * @param trans : nsISocketTransport\\n+   *   the transport for the request/response\\n    * @see nsIServerSocketListener.onSocketAccepted\\n    */\\n-  onSocketAccepted: function(serverSocket, trans)\\n+  onSocketAccepted: function(socket, trans)\\n   {\\n+    dumpn(\\\"*** onSocketAccepted(socket=\\\" + socket + \\\", trans=\\\" + trans + \\\") \\\" +\\n+          \\\"on thread \\\" + gThreadManager.currentThread +\\n+          \\\" (main is \\\" + gThreadManager.mainThread + \\\")\\\");\\n+\\n     dumpn(\\\">>> new connection on \\\" + trans.host + \\\":\\\" + trans.port);\\n \\n-    var input = trans.openInputStream(Ci.nsITransport.OPEN_BLOCKING, 0, 0);\\n+    const SEGMENT_SIZE = 8192;\\n+    const SEGMENT_COUNT = 1024;\\n+    var input = trans.openInputStream(0, SEGMENT_SIZE, SEGMENT_COUNT)\\n+                     .QueryInterface(Ci.nsIAsyncInputStream);\\n     var output = trans.openOutputStream(Ci.nsITransport.OPEN_BLOCKING, 0, 0);\\n \\n-    this._processConnection(serverSocket.port, input, output);\\n+    var conn = new Connection(input, output, this, socket.port);\\n+    var reader = new RequestReader(conn);\\n+\\n+    // XXX add request timeout functionality here!\\n+\\n+    // Note: must use main thread here, or we might get a GC that will cause\\n+    //       threadsafety assertions.  We really need to fix XPConnect so that\\n+    //       you can actually do things in multi-threaded JS.  :-(\\n+    input.asyncWait(reader, 0, 0, gThreadManager.mainThread);\\n   },\\n \\n   /**\\n    * Called when the socket associated with this is closed.\\n    *\\n+   * @param socket : nsIServerSocket\\n+   *   the socket being closed\\n+   * @param status : nsresult\\n+   *   the reason the socket stopped listening (NS_BINDING_ABORTED if the server\\n+   *   was stopped using nsIHttpServer.stop)\\n    * @see nsIServerSocketListener.onStopListening\\n    */\\n-  onStopListening: function(serverSocket, status)\\n+  onStopListening: function(socket, status)\\n   {\\n     dumpn(\\\">>> shutting down server\\\");\\n     this._socketClosed = true;\\n@@ -354,11 +408,9 @@ nsHttpServer.prototype =\\n     this._port = port;\\n     this._doQuit = this._socketClosed = false;\\n \\n-    var socket = Cc[\\\"@mozilla.org/network/server-socket;1\\\"]\\n-                   .createInstance(Ci.nsIServerSocket);\\n-    socket.init(this._port,\\n-                true,       // loopback only\\n-                -1);        // default number of pending connections\\n+    var socket = new ServerSocket(this._port,\\n+                                  true, // loopback only\\n+                                  -1);  // default number of pending connections\\n \\n     dumpn(\\\">>> listening on port \\\" + socket.port);\\n     socket.asyncListen(this);\\n@@ -378,18 +430,10 @@ nsHttpServer.prototype =\\n     this._socket = null;\\n     this._doQuit = false;\\n \\n-    // spin an event loop and wait for the socket-close notification, if we can;\\n-    // this is only possible in Mozilla 1.9 code, but in situations where\\n-    // nothing really horrible happens at shutdown, nothing bad will happen in\\n-    // Mozilla 1.8-based code (and we want to support that)\\n-    if (\\\"@mozilla.org/thread-manager;1\\\" in Cc)\\n-    {\\n-      var thr = Cc[\\\"@mozilla.org/thread-manager;1\\\"]\\n-                  .getService()\\n-                  .currentThread;\\n-      while (!this._socketClosed || this._handler.hasPendingRequests())\\n-        thr.processNextEvent(true);\\n-    }\\n+    // spin an event loop and wait for the socket-close notification\\n+    var thr = gThreadManager.currentThread;\\n+    while (!this._socketClosed || this._handler.hasPendingRequests())\\n+      thr.processNextEvent(true);\\n   },\\n \\n   //\\n@@ -460,6 +504,7 @@ nsHttpServer.prototype =\\n     throw Cr.NS_ERROR_NO_INTERFACE;\\n   },\\n \\n+\\n   // NON-XPCOM PUBLIC API\\n \\n   /**\\n@@ -471,114 +516,750 @@ nsHttpServer.prototype =\\n   {\\n     return this._socketClosed && !this._handler.hasPendingRequests();\\n   },\\n+\\n   \\n   // PRIVATE IMPLEMENTATION\\n \\n   /**\\n-   * Processes an incoming request in inStream served through the given port and\\n-   * writes the response to outStream.\\n+   * Closes the passed-in connection.\\n+   *\\n+   * @param connection : Connection\\n+   *   the connection to close\\n+   */\\n+  _endConnection: function(connection)\\n+  {\\n+    //\\n+    // Order is important below: we must decrement handler._pendingRequests\\n+    // BEFORE calling this.stop(), if needed, in connection.destroy().\\n+    // this.stop() returns only when the server socket's closed AND all pending\\n+    // requests are complete, which clearly isn't (and never will be) the case\\n+    // if it were the other way around.\\n+    //\\n+\\n+    connection.close();\\n+\\n+    NS_ASSERT(this == connection.server);\\n+\\n+    this._handler._pendingRequests--;\\n+\\n+    connection.destroy();\\n+  },\\n+\\n+  /**\\n+   * Requests that the server be shut down when possible.\\n+   */\\n+  _requestQuit: function()\\n+  {\\n+    dumpn(\\\">>> requesting a quit\\\");\\n+    dumpStack();\\n+    this._doQuit = true;\\n+  }\\n+\\n+};\\n+\\n+\\n+/**\\n+ * Represents a connection to the server (and possibly in the future the thread\\n+ * on which the connection is processed).\\n+ *\\n+ * @param input : nsIInputStream\\n+ *   stream from which incoming data on the connection is read\\n+ * @param output : nsIOutputStream\\n+ *   stream to write data out the connection\\n+ * @param server : nsHttpServer\\n+ *   the server handling the connection\\n+ * @param port : int\\n+ *   the port on which the server is running\\n+ */\\n+function Connection(input, output, server, port)\\n+{\\n+  /** Stream of incoming data. */\\n+  this.input = input;\\n+\\n+  /** Stream for outgoing data. */\\n+  this.output = output;\\n+\\n+  /** The server associated with this request. */\\n+  this.server = server;\\n+\\n+  /** The port on which the server is running. */\\n+  this.port = port;\\n+  \\n+  /** State variables for debugging. */\\n+  this._closed = this._processed = false;\\n+}\\n+Connection.prototype =\\n+{\\n+  /** Closes this connection's input/output streams. */\\n+  close: function()\\n+  {\\n+    this.input.close();\\n+    this.output.close();\\n+    this._closed = true;\\n+  },\\n+\\n+  /**\\n+   * Initiates processing of this connection, using the data in the given\\n+   * request.\\n    *\\n-   * @param port\\n-   *   the port on which the request was served\\n-   * @param inStream\\n-   *   an nsIInputStream containing the incoming request\\n-   * @param outStream\\n-   *   the nsIOutputStream to which the response should be written\\n+   * @param request : Request\\n+   *   the request which should be processed\\n    */\\n-  _processConnection: function(port, inStream, outStream)\\n+  process: function(request)\\n   {\\n+    NS_ASSERT(!this._closed && !this._processed);\\n+\\n+    this._processed = true;\\n+\\n+    this.server._handler.handleResponse(this, request);\\n+  },\\n+\\n+  /**\\n+   * Initiates processing of this connection, generating a response with the\\n+   * given HTTP error code.\\n+   *\\n+   * @param code : uint\\n+   *   an HTTP code, so in the range [0, 1000)\\n+   * @param metadata : Request\\n+   *   incomplete data about the incoming request (since there were errors\\n+   *   during its processing\\n+   */\\n+  processError: function(code, metadata)\\n+  {\\n+    NS_ASSERT(!this._closed && !this._processed);\\n+\\n+    this._processed = true;\\n+\\n+    this.server._handler.handleError(code, this, metadata);\\n+  },\\n+\\n+  /** Ends this connection, destroying the resources it uses. */\\n+  end: function()\\n+  {\\n+    this.server._endConnection(this);\\n+  },\\n+\\n+  /** Destroys resources used by this. */\\n+  destroy: function()\\n+  {\\n+    if (!this._closed)\\n+      this.close();\\n+\\n+    // If an error triggered a server shutdown, act on it now\\n+    var server = this.server;\\n+    if (server._doQuit)\\n+      server.stop();\\n+  }\\n+};\\n+\\n+\\n+\\n+/** Returns an array of count bytes from the given input stream. */\\n+function readBytes(inputStream, count)\\n+{\\n+  return new BinaryInputStream(inputStream).readByteArray(count);\\n+}\\n+\\n+\\n+\\n+/** Request reader processing states; see RequestReader for details. */\\n+const READER_INITIAL    = 0;\\n+const READER_IN_HEADERS = 1;\\n+const READER_IN_BODY    = 2;\\n+\\n+\\n+/**\\n+ * Reads incoming request data asynchronously, does any necessary preprocessing,\\n+ * and forwards it to the request handler.  Processing occurs in three states:\\n+ *\\n+ *   READER_INITIAL             Haven't read the entire request line yet\\n+ *   READER_IN_HEADERS          Reading headers in the request\\n+ *   READER_IN_BODY             Finished reading all request headers (when body\\n+ *                              support's added, will be reading the body)\\n+ *\\n+ * During the first two stages, initial metadata about the request is gathered\\n+ * into a Request object.  Once the status line and headers have been processed,\\n+ * we create a Response and hand it off to the ServerHandler to be given to the\\n+ * appropriate request handler.\\n+ *\\n+ * XXX we should set up a stream to provide lazy access to the request body\\n+ *\\n+ * @param connection : Connection\\n+ *   the connection for the request being read\\n+ */\\n+function RequestReader(connection)\\n+{\\n+  /** Connection metadata for this request. */\\n+  this._connection = connection;\\n+\\n+  /**\\n+   * A container providing line-by-line access to the raw bytes that make up the\\n+   * data which has been read from the connection but has not yet been acted\\n+   * upon (by passing it to the request handler or by extracting request\\n+   * metadata from it).\\n+   */\\n+  this._data = new LineData();\\n+\\n+  /** The current state of parsing the incoming request. */\\n+  this._state = READER_INITIAL;\\n+\\n+  /** Metadata constructed from the incoming request for the request handler. */\\n+  this._metadata = new Request(connection.port);\\n+\\n+  /**\\n+   * Used to preserve state if we run out of line data midway through a\\n+   * multi-line header.  _lastHeaderName stores the name of the header, while\\n+   * _lastHeaderValue stores the value we've seen so far for the header.\\n+   *\\n+   * These fields are always either both undefined or both strings.\\n+   */\\n+  this._lastHeaderName = this._lastHeaderValue = undefined;\\n+}\\n+RequestReader.prototype =\\n+{\\n+  // NSIINPUTSTREAMCALLBACK\\n+\\n+  /**\\n+   * Called when more data from the incoming request is available.  This method\\n+   * then reads the available data from input and deals with that data as\\n+   * necessary, depending upon the syntax of already-downloaded data.\\n+   *\\n+   * @param input : nsIAsyncInputStream\\n+   *   the stream of incoming data from the connection\\n+   */\\n+  onInputStreamReady: function(input)\\n+  {\\n+    dumpn(\\\"*** onInputStreamReady(input=\\\" + input + \\\") on thread \\\" +\\n+          gThreadManager.currentThread + \\\" (main is \\\" +\\n+          gThreadManager.mainThread + \\\")\\\");\\n+    dumpn(\\\"*** this._state == \\\" + this._state);\\n+\\n+    var count = input.available();\\n+\\n+    // Handle cases where we get more data after a request error has been\\n+    // discovered but *before* we can close the connection.\\n+    if (!this._data)\\n+      return;\\n+\\n+    var moreAvailable = false;\\n+\\n+    switch (this._state)\\n+    {\\n+      case READER_INITIAL:\\n+        moreAvailable = this._processRequestLine(input, count);\\n+        break;\\n+\\n+      case READER_IN_HEADERS:\\n+        moreAvailable = this._processHeaders(input, count);\\n+        break;\\n+\\n+      case READER_IN_BODY:\\n+        // XXX handle the request body!  until then, just stop reading\\n+        break;\\n+\\n+      default:\\n+        NS_ASSERT(false);\\n+    }\\n+\\n+    if (moreAvailable)\\n+      input.asyncWait(this, 0, 0, gThreadManager.currentThread);\\n+  },\\n+\\n+  //\\n+  // see nsISupports.QueryInterface\\n+  //\\n+  QueryInterface: function(aIID)\\n+  {\\n+    if (aIID.equals(Ci.nsIInputStreamCallback) ||\\n+        aIID.equals(Ci.nsISupports))\\n+      return this;\\n+\\n+    throw Cr.NS_ERROR_NO_INTERFACE;\\n+  },\\n+\\n+\\n+  // PRIVATE API\\n+\\n+  /**\\n+   * Reads count bytes from input and processes unprocessed, downloaded data as\\n+   * a request line.\\n+   *\\n+   * @param input : nsIInputStream\\n+   *   stream from which count bytes of data must be read\\n+   * @param count : PRUint32\\n+   *   the number of bytes of data which must be read from input\\n+   * @returns boolean\\n+   *   true if more data must be read from the request, false otherwise\\n+   */\\n+  _processRequestLine: function(input, count)\\n+  {\\n+    NS_ASSERT(this._state == READER_INITIAL);\\n+\\n+    var data = this._data;\\n+    data.appendBytes(readBytes(input, count));\\n+\\n+\\n+    // servers SHOULD ignore any empty line(s) received where a Request-Line\\n+    // is expected (section 4.1)\\n+    var line = {};\\n+    var readSuccess;\\n+    while ((readSuccess = data.readLine(line)) && line.value == \\\"\\\")\\n+      dumpn(\\\"*** ignoring beginning blank line...\\\");\\n+\\n+    // if we don't have a full line, wait until we do\\n+    if (!readSuccess)\\n+      return true;\\n+\\n+    // we have the first non-blank line\\n     try\\n     {\\n-      var metadata = new RequestMetadata(port);\\n-      metadata.init(inStream);\\n+      this._parseRequestLine(line.value);\\n \\n-      inStream.close();\\n+      // do we have more header data to read?\\n+      if (!this._parseHeaders())\\n+        return true;\\n \\n-      this._handler.handleRequest(outStream, metadata);\\n+      // headers complete, do a data check and then forward to the handler\\n+      this._validateRequest();\\n+      return this._handleResponse();\\n     }\\n     catch (e)\\n     {\\n-      dumpn(\\\">>> internal error, shutting down server: \\\" + e);\\n-      dumpn(\\\"*** stack trace: \\\" + e.stack);\\n+      this._handleError(e);\\n+      return false;\\n+    }\\n+  },\\n+\\n+  /**\\n+   * Reads data from input and processes it, assuming it is either at the\\n+   * beginning or in the middle of processing request headers.\\n+   *\\n+   * @param input : nsIInputStream\\n+   *   stream from which count bytes of data must be read\\n+   * @param count : PRUint32\\n+   *   the number of bytes of data which must be read from input\\n+   * @returns boolean\\n+   *   true if more data must be read from the request, false otherwise\\n+   */\\n+  _processHeaders: function(input, count)\\n+  {\\n+    NS_ASSERT(this._state == READER_IN_HEADERS);\\n+\\n+    // XXX things to fix here:\\n+    //\\n+    // - need to support RFC 2047-encoded non-US-ASCII characters\\n+    // - really support absolute URLs (requires telling the server all its\\n+    //   hostnames, beyond just localhost:port or 127.0.0.1:port)\\n+\\n+    this._data.appendBytes(readBytes(input, count));\\n+\\n+    try\\n+    {\\n+      // do we have all the headers?\\n+      if (!this._parseHeaders())\\n+        return true;\\n+\\n+      // we have all the headers, continue with the body\\n+      this._validateRequest();\\n+      return this._handleResponse();\\n+    }\\n+    catch (e)\\n+    {\\n+      this._handleError(e);\\n+      return false;\\n+    }\\n+  },\\n+\\n+  /**\\n+   * Does various post-header checks on the data in this request.\\n+   *\\n+   * @throws : HttpError\\n+   *   if the request was malformed in some way\\n+   */\\n+  _validateRequest: function()\\n+  {\\n+    NS_ASSERT(this._state == READER_IN_BODY);\\n+\\n+    dumpn(\\\"*** _validateRequest\\\");\\n \\n-      inStream.close(); // in case we failed before then\\n+    var metadata = this._metadata;\\n+    var headers = metadata._headers;\\n \\n-      this._doQuit = true;\\n-      this._endConnection(this._handler, outStream);\\n+    var isHttp11 = metadata._httpVersion.equals(nsHttpVersion.HTTP_1_1);\\n+\\n+    // 19.6.1.1 -- servers MUST report 400 to HTTP/1.1 requests w/o Host header\\n+    if (isHttp11 && !headers.hasHeader(\\\"Host\\\"))\\n+      throw HTTP_400;\\n+  },\\n+\\n+  /**\\n+   * Handles responses in case of error, either in the server or in the request.\\n+   *\\n+   * @param e\\n+   *   the specific error encountered, which is an HttpError in the case where\\n+   *   the request is in some way invalid or cannot be fulfilled; if this isn't\\n+   *   an HttpError we're going to be paranoid and shut down, because that\\n+   *   shouldn't happen, ever\\n+   */\\n+  _handleError: function(e)\\n+  {\\n+    var server = this._connection.server;\\n+    if (e instanceof HttpError)\\n+    {\\n+      var code = e.code;\\n+    }\\n+    else\\n+    {\\n+      // no idea what happened -- be paranoid and shut down\\n+      code = 500;\\n+      server._requestQuit();\\n     }\\n \\n-    // stream cleanup, etc. happens in _endConnection below -- called from\\n-    // stream copier observer when all data has been copied\\n+    // make attempted reuse of data an error\\n+    this._data = null;\\n+\\n+    this._connection.processError(code, this._metadata);\\n   },\\n \\n   /**\\n-   * Closes the passed-in output stream and (if necessary) shuts down this\\n-   * server.\\n+   * Now that we've read the request line and headers, we can actually hand off\\n+   * the request to be handled.\\n    *\\n-   * @param handler\\n-   *   the request handler which handled the request\\n-   * @param outStream\\n-   *   the nsIOutputStream for the processed request which must be closed\\n+   * This method is called once per request, after the request line and all\\n+   * headers have been received.\\n+   *\\n+   * @returns boolean\\n+   *   true if more data must be read, false otherwise\\n    */\\n-  _endConnection: function(handler, outStream)\\n+  _handleResponse: function()\\n   {\\n-    //\\n-    // Order is important below: we must decrement handler._pendingRequests\\n-    // BEFORE calling this.stop(), if needed, because this.stop() returns only\\n-    // when the server socket's closed AND all pending requests are complete,\\n-    // which clearly isn't (and never will be) the case if it were the other way\\n-    // around\\n-    //\\n+    NS_ASSERT(this._state == READER_IN_BODY);\\n+\\n+    // XXX set up a stream for data in the request body here\\n \\n-    outStream.close();  // inputstream already closed after processing\\n-    handler._pendingRequests--;\\n+    // We don't need the line-based data any more, so make attempted reuse an\\n+    // error.\\n+    this._data = null;\\n \\n-    // handle possible server quit -- note that this doesn't affect extant open\\n-    // connections and pending requests: nsIServerSocket.close is specified not\\n-    // to affect open connections, and nsIHttpServer.stop attempts to do its\\n-    // best to return only when the server socket is closed and all pending\\n-    // requests have been served\\n-    if (this._doQuit)\\n-      this.stop();\\n+    this._connection.process(this._metadata);\\n+\\n+    return false;\\n   },\\n \\n+\\n+  // PARSING\\n+\\n   /**\\n-   * Requests that the server be shut down when possible.\\n+   * Parses the request line for the HTTP request associated with this.\\n+   *\\n+   * @param line : string\\n+   *   the request line\\n    */\\n-  _requestQuit: function()\\n+  _parseRequestLine: function(line)\\n   {\\n-    dumpn(\\\">>> requesting a quit\\\");\\n-    this._doQuit = true;\\n+    NS_ASSERT(this._state == READER_INITIAL);\\n+\\n+    dumpn(\\\"*** _parseRequestLine('\\\" + line + \\\"')\\\");\\n+\\n+    var metadata = this._metadata;\\n+\\n+    // clients and servers SHOULD accept any amount of SP or HT characters\\n+    // between fields, even though only a single SP is required (section 19.3)\\n+    var request = line.split(/[ \\\\t]+/);\\n+    if (!request || request.length != 3)\\n+      throw HTTP_400;\\n+\\n+    metadata._method = request[0];\\n+\\n+    // get the HTTP version\\n+    var ver = request[2];\\n+    var match = ver.match(/^HTTP\\\\/(\\\\d+\\\\.\\\\d+)$/);\\n+    if (!match)\\n+      throw HTTP_400;\\n+\\n+    // determine HTTP version\\n+    try\\n+    {\\n+      metadata._httpVersion = new nsHttpVersion(match[1]);\\n+      if (!metadata._httpVersion.equals(nsHttpVersion.HTTP_1_0) &&\\n+          !metadata._httpVersion.equals(nsHttpVersion.HTTP_1_1))\\n+        throw \\\"unsupported HTTP version\\\";\\n+    }\\n+    catch (e)\\n+    {\\n+      // we support HTTP/1.0 and HTTP/1.1 only\\n+      throw HTTP_501;\\n+    }\\n+\\n+\\n+    var fullPath = request[1];\\n+\\n+    if (fullPath.charAt(0) != \\\"/\\\")\\n+    {\\n+      // XXX we don't really support absolute URIs yet -- a MUST for HTTP/1.1;\\n+      //     for now just get the path and use that, ignoring hostport\\n+      try\\n+      {\\n+        var uri = Cc[\\\"@mozilla.org/network/io-service;1\\\"]\\n+                    .getService(Ci.nsIIOService)\\n+                    .newURI(fullPath, null, null);\\n+        fullPath = uri.path;\\n+      }\\n+      catch (e) { /* invalid URI */ }\\n+      if (fullPath.charAt(0) != \\\"/\\\")\\n+      {\\n+        this.errorCode = 400;\\n+        return;\\n+      }\\n+    }\\n+\\n+    var splitter = fullPath.indexOf(\\\"?\\\");\\n+    if (splitter < 0)\\n+    {\\n+      // _queryString already set in ctor\\n+      metadata._path = fullPath;\\n+    }\\n+    else\\n+    {\\n+      metadata._path = fullPath.substring(0, splitter);\\n+      metadata._queryString = fullPath.substring(splitter + 1);\\n+    }\\n+\\n+    // our work here is finished\\n+    this._state = READER_IN_HEADERS;\\n+  },\\n+\\n+  /**\\n+   * Parses all available HTTP headers in this until the header-ending CRLFCRLF,\\n+   * adding them to the store of headers in the request.\\n+   *\\n+   * @throws\\n+   *   HTTP_400 if the headers are malformed\\n+   * @returns boolean\\n+   *   true if all headers have now been processed, false otherwise\\n+   */\\n+  _parseHeaders: function()\\n+  {\\n+    NS_ASSERT(this._state == READER_IN_HEADERS);\\n+\\n+    dumpn(\\\"*** _parseHeaders\\\");\\n+\\n+    var data = this._data;\\n+\\n+    var headers = this._metadata._headers;\\n+    var lastName = this._lastHeaderName;\\n+    var lastVal = this._lastHeaderValue;\\n+\\n+    var line = {};\\n+    while (true)\\n+    {\\n+      NS_ASSERT(!((lastVal === undefined) ^ (lastName === undefined)),\\n+                lastName === undefined ?\\n+                  \\\"lastVal without lastName?  lastVal: '\\\" + lastVal + \\\"'\\\" :\\n+                  \\\"lastName without lastVal?  lastName: '\\\" + lastName + \\\"'\\\");\\n+\\n+      if (!data.readLine(line))\\n+      {\\n+        // save any data we have from the header we might still be processing\\n+        this._lastHeaderName = lastName;\\n+        this._lastHeaderValue = lastVal;\\n+        return false;\\n+      }\\n+\\n+      var lineText = line.value;\\n+      var firstChar = lineText.charAt(0);\\n+\\n+      // blank line means end of headers\\n+      if (lineText == \\\"\\\")\\n+      {\\n+        // we're finished with the previous header\\n+        if (lastName)\\n+        {\\n+          try\\n+          {\\n+            headers.setHeader(lastName, lastVal, true);\\n+          }\\n+          catch (e)\\n+          {\\n+            dumpn(\\\"*** e == \\\" + e);\\n+            throw HTTP_400;\\n+          }\\n+        }\\n+        else\\n+        {\\n+          // no headers in request -- valid for HTTP/1.0 requests\\n+        }\\n+\\n+        // either way, we're done processing headers\\n+        this._state = READER_IN_BODY;\\n+        return true;\\n+      }\\n+      else if (firstChar == \\\" \\\" || firstChar == \\\"\\\\t\\\")\\n+      {\\n+        // multi-line header if we've already seen a header line\\n+        if (!lastName)\\n+        {\\n+          // we don't have a header to continue!\\n+          throw HTTP_400;\\n+        }\\n+\\n+        // append this line's text to the value; starts with SP/HT, so no need\\n+        // for separating whitespace\\n+        lastVal += lineText;\\n+      }\\n+      else\\n+      {\\n+        // we have a new header, so set the old one (if one existed)\\n+        if (lastName)\\n+        {\\n+          try\\n+          {\\n+            headers.setHeader(lastName, lastVal, true);\\n+          }\\n+          catch (e)\\n+          {\\n+            dumpn(\\\"*** e == \\\" + e);\\n+            throw HTTP_400;\\n+          }\\n+        }\\n+\\n+        var colon = lineText.indexOf(\\\":\\\"); // first colon must be splitter\\n+        if (colon < 1)\\n+        {\\n+          // no colon or missing header field-name\\n+          throw HTTP_400;\\n+        }\\n+\\n+        // set header name, value (to be set in the next loop, usually)\\n+        lastName = lineText.substring(0, colon);\\n+        lastVal = lineText.substring(colon + 1);\\n+      } // empty, continuation, start of header\\n+    } // while (true)\\n   }\\n+};\\n+\\n+\\n+/** The character codes for CR and LF. */\\n+const CR = 0x0D, LF = 0x0A;\\n+\\n+/**\\n+ * Calculates the number of characters before the first CRLF pair in array, or\\n+ * -1 if the array contains no CRLF pair.\\n+ *\\n+ * @param array : Array\\n+ *   an array of numbers in the range [0, 256), each representing a single\\n+ *   character; the first CRLF is the lowest index i where\\n+ *   |array[i] == \\\"\\\\r\\\".charCodeAt(0)| and |array[i+1] == \\\"\\\\n\\\".charCodeAt(0)|,\\n+ *   if such an |i| exists, and -1 otherwise\\n+ * @returns int\\n+ *   the index of the first CRLF if any were present, -1 otherwise\\n+ */\\n+function findCRLF(array)\\n+{\\n+  for (var i = array.indexOf(CR); i >= 0; i = array.indexOf(CR, i + 1))\\n+  {\\n+    if (array[i + 1] == LF)\\n+      return i;\\n+  }\\n+  return -1;\\n+}\\n+\\n+\\n+/**\\n+ * A container which provides line-by-line access to the arrays of bytes with\\n+ * which it is seeded.\\n+ */\\n+function LineData()\\n+{\\n+  /** An array of queued bytes from which to get line-based characters. */\\n+  this._data = [];\\n+}\\n+LineData.prototype =\\n+{\\n+  /**\\n+   * Appends the bytes in the given array to the internal data cache maintained\\n+   * by this.\\n+   */\\n+  appendBytes: function(bytes)\\n+  {\\n+    Array.prototype.push.apply(this._data, bytes);\\n+  },\\n+\\n+  /**\\n+   * Removes and returns a line of data, delimited by CRLF, from this.\\n+   *\\n+   * @param out\\n+   *   an object whose \\\"value\\\" property will be set to the first line of text\\n+   *   present in this, sans CRLF, if this contains a full CRLF-delimited line\\n+   *   of text; if this doesn't contain enough data, the value of the property\\n+   *   is undefined\\n+   * @returns boolean\\n+   *   true if a full line of data could be read from the data in this, false\\n+   *   otherwise\\n+   */\\n+  readLine: function(out)\\n+  {\\n+    var data = this._data;\\n+    var length = findCRLF(data);\\n+    if (length < 0)\\n+      return false;\\n+\\n+    //\\n+    // We have the index of the CR, so remove all the characters, including\\n+    // CRLF, from the array with splice, and convert the removed array into the\\n+    // corresponding string, from which we then strip the trailing CRLF.\\n+    //\\n+    // Getting the line in this matter acknowledges that substring is an O(1)\\n+    // operation in SpiderMonkey because strings are immutable, whereas two\\n+    // splices, both from the beginning of the data, are less likely to be as\\n+    // cheap as a single splice plus two extra character conversions.\\n+    //\\n+    var line = String.fromCharCode.apply(null, data.splice(0, length + 2));\\n+    out.value = line.substring(0, length);\\n \\n+    return true;\\n+  },\\n+\\n+  /**\\n+   * Retrieve any bytes we may have overread from the request's postdata.  After\\n+   * this method is called, this must not be used in any way.\\n+   *\\n+   * @returns Array\\n+   *   the bytes read past the CRLFCRLF at the end of request headers\\n+   */\\n+  purge: function()\\n+  {\\n+    var data = this._data;\\n+    this._data = null;\\n+    return data;\\n+  }\\n };\\n \\n \\n+\\n /**\\n  * Gets a content-type for the given file, as best as it is possible to do so.\\n  *\\n- * @param file\\n+ * @param file : nsIFile\\n  *   the nsIFile for which to get a file type\\n- * @returns\\n+ * @returns string\\n  *   the best content-type which can be determined for the file\\n  */\\n function getTypeFromFile(file)\\n {\\n   try\\n   {\\n-    var type = Cc[\\\"@mozilla.org/uriloader/external-helper-app-service;1\\\"]\\n-                 .getService(Ci.nsIMIMEService)\\n-                 .getTypeFromFile(file);\\n+    return Cc[\\\"@mozilla.org/uriloader/external-helper-app-service;1\\\"]\\n+             .getService(Ci.nsIMIMEService)\\n+             .getTypeFromFile(file);\\n   }\\n   catch (e)\\n   {\\n-    type = \\\"application/octet-stream\\\";\\n+    return \\\"application/octet-stream\\\";\\n   }\\n-  return type;\\n }\\n \\n \\n-\\n /**\\n  * Creates a request-handling function for an nsIHttpRequestHandler object.\\n  */\\n@@ -797,17 +1478,17 @@ function maybeAddHeaders(file, metadata, response)\\n  * support for HTTP error pages for various codes and fallback to HTTP 500 if\\n  * those codes fail for any reason.\\n  *\\n- * @param srv\\n- *   the nsHttpServer in which this handler is being used\\n+ * @param server : nsHttpServer\\n+ *   the server in which this handler is being used\\n  */\\n-function ServerHandler(srv)\\n+function ServerHandler(server)\\n {\\n   // FIELDS\\n \\n   /**\\n    * The nsHttpServer instance associated with this handler.\\n    */\\n-  this._server = srv;\\n+  this._server = server;\\n \\n   /**\\n    * A variable used to ensure that all requests are fully complete before the\\n@@ -831,7 +1512,7 @@ function ServerHandler(srv)\\n    * Custom request handlers for the server in which this resides.  Path-handler\\n    * pairs are stored as property-value pairs in this property.\\n    *\\n-   * @see also ServerHandler.prototype._defaultPaths\\n+   * @see ServerHandler.prototype._defaultPaths\\n    */\\n   this._overridePaths = {};\\n \\n@@ -840,13 +1521,13 @@ function ServerHandler(srv)\\n    * resides.  Path-handler pairs are stored as property-value pairs in this\\n    * property.\\n    *\\n-   * @see also ServerHandler.prototype._defaultErrors\\n+   * @see ServerHandler.prototype._defaultErrors\\n    */\\n   this._overrideErrors = {};\\n \\n   /**\\n-   * Init our default handler for directories. The handler used to\\n-   * serve directories when no index file is present.\\n+   * The default handler for requests for directories, used to serve directories\\n+   * when no index file is present.\\n    */\\n   this._indexHandler = defaultIndexHandler;\\n }\\n@@ -856,26 +1537,19 @@ ServerHandler.prototype =\\n \\n   /**\\n    * Handles a request to this server, responding to the request appropriately\\n-   * and initiating server shutdown if necessary.  If the request metadata\\n-   * specifies an error code, the appropriate error response will be sent.\\n+   * and initiating server shutdown if necessary.\\n+   *\\n+   * This method never throws an exception.\\n    *\\n-   * @param outStream\\n-   *   an nsIOutputStream to which a response should be written\\n-   * @param metadata\\n+   * @param connection : Connection\\n+   *   the connection for this request\\n+   * @param metadata : Request\\n    *   request metadata as generated from the initial request\\n    */\\n-  handleRequest: function(outStream, metadata)\\n+  handleResponse: function(connection, metadata)\\n   {\\n     var response = new Response();\\n \\n-    // handle any existing error codes\\n-    if (metadata.errorCode)\\n-    {\\n-      dumpn(\\\"*** errorCode == \\\" + metadata.errorCode);\\n-      this._handleError(metadata, response);\\n-      return this._end(response, outStream);\\n-    }\\n-\\n     var path = metadata.path;\\n     dumpn(\\\"*** path == \\\" + path);\\n \\n@@ -894,8 +1568,12 @@ ServerHandler.prototype =\\n       {\\n         response.recycle();\\n \\n-        if (!(e instanceof HttpError) || e.code != 404)\\n+        if (!(e instanceof HttpError))\\n           throw HTTP_500;\\n+        if (e.code != 404)\\n+          throw e;\\n+\\n+        dumpn(\\\"*** default: \\\" + (path in this._defaultPaths));\\n \\n         if (path in this._defaultPaths)\\n           this._defaultPaths[path](metadata, response);\\n@@ -903,36 +1581,40 @@ ServerHandler.prototype =\\n           throw HTTP_404;\\n       }\\n     }\\n-    catch (e2)\\n+    catch (e)\\n     {\\n-      if (!(e2 instanceof HttpError))\\n+      var errorCode = \\\"internal\\\";\\n+\\n+      try\\n       {\\n-        dumpn(\\\"*** internal error: e2 == \\\" + e2);\\n-        throw e2;\\n-      }\\n+        if (!(e instanceof HttpError))\\n+          throw e;\\n \\n-      var errorCode = e2.code;\\n-      dumpn(\\\"*** errorCode == \\\" + errorCode);\\n+        errorCode = e.code;\\n+        dumpn(\\\"*** errorCode == \\\" + errorCode);\\n \\n-      response.recycle();\\n+        response.recycle();\\n \\n-      metadata.errorCode = errorCode;\\n-      this._handleError(metadata, response);\\n+        this._handleError(errorCode, metadata, response);\\n+      }\\n+      catch (e2)\\n+      {\\n+        dumpn(\\\"*** error handling \\\" + errorCode + \\\" error: \\\" +\\n+              \\\"e2 == \\\" + e2 + \\\", shutting down server\\\");\\n+\\n+        response.destroy();\\n+        connection.close();\\n+        connection.server.stop();\\n+        return;\\n+      }\\n     }\\n \\n-    return this._end(response, outStream);\\n+    this._end(response, connection);\\n   },\\n \\n-  /**\\n-   * Associates a file with a server path so that it is returned by future\\n-   * requests to that path.\\n-   *\\n-   * @param path\\n-   *   the path on the server, which must begin with a \\\"/\\\"\\n-   * @param file\\n-   *   the nsILocalFile representing the file to be served; must not be a\\n-   *   directory\\n-   */\\n+  //\\n+  // see nsIHttpServer.registerFile\\n+  //\\n   registerFile: function(path, file)\\n   {\\n     dumpn(\\\"*** registering '\\\" + path + \\\"' as mapping to \\\" + file.path);\\n@@ -945,18 +1627,7 @@ ServerHandler.prototype =\\n           throw HTTP_404;\\n \\n         response.setStatusLine(metadata.httpVersion, 200, \\\"OK\\\");\\n-\\n-        try\\n-        {\\n-          this._writeFileResponse(file, response);\\n-        }\\n-        catch (e)\\n-        {\\n-          // something happened -- but the calling code should handle the error\\n-          // and clean up the response\\n-          throw e;\\n-        }\\n-\\n+        this._writeFileResponse(file, response);\\n         maybeAddHeaders(file, metadata, response);\\n       };\\n   },\\n@@ -1028,12 +1699,26 @@ ServerHandler.prototype =\\n     this._indexHandler = handler;\\n   },\\n \\n+  // NON-XPCOM PUBLIC API\\n+\\n+  /**\\n+   * Returns true if this handler is in the middle of handling any current\\n+   * requests; this must be false before the server in which this is used may be\\n+   * safely shut down.\\n+   */\\n+  hasPendingRequests: function()\\n+  {\\n+    return this._pendingRequests > 0;\\n+  },\\n+\\n+\\n+  // PRIVATE API\\n+\\n   /**\\n-   * Set or remove a handler in an ojbect with a key.\\n-   * If handler is null, the key will be deleted.\\n+   * Sets or remove (if handler is null) a handler in an object with a key.\\n    *\\n    * @param handler\\n-   *   A function or an nsIHttpRequestHandler object.\\n+   *   a handler, either function or an nsIHttpRequestHandler\\n    * @param dict\\n    *   The object to attach the handler to.\\n    * @param key\\n@@ -1051,26 +1736,14 @@ ServerHandler.prototype =\\n   },\\n \\n   /**\\n-   * Returns true if this handler is in the middle of handling any current\\n-   * requests; this must be false before the server in which this is used may be\\n-   * safely shut down.\\n-   */\\n-  hasPendingRequests: function()\\n-  {\\n-    return this._pendingRequests > 0;\\n-  },\\n-\\n-  // PRIVATE API\\n-\\n-  /**\\n    * Handles a request which maps to a file in the local filesystem (if a base\\n    * path has already been set; otherwise the 404 error is thrown).\\n    *\\n-   * @param metadata\\n-   *   request-related data as a RequestMetadata object\\n-   * @param response\\n-   *   an uninitialized Response to the given request which must be initialized\\n-   *   by a request handler\\n+   * @param metadata : Request\\n+   *   metadata for the incoming request\\n+   * @param response : Response\\n+   *   an uninitialized Response to the given request, to be initialized by a\\n+   *   request handler\\n    * @throws HTTP_###\\n    *   if an HTTP error occurred (usually HTTP_404); note that in this case the\\n    *   calling code must handle cleanup of the response by calling .destroy()\\n@@ -1078,54 +1751,47 @@ ServerHandler.prototype =\\n    */\\n   _handleDefault: function(metadata, response)\\n   {\\n-    try\\n-    {\\n-      response.setStatusLine(metadata.httpVersion, 200, \\\"OK\\\");\\n+    response.setStatusLine(metadata.httpVersion, 200, \\\"OK\\\");\\n \\n-      var path = metadata.path;\\n-      NS_ASSERT(path.charAt(0) == \\\"/\\\");\\n+    var path = metadata.path;\\n+    NS_ASSERT(path.charAt(0) == \\\"/\\\", \\\"invalid path: <\\\" + path + \\\">\\\");\\n \\n-      // determine the actual on-disk file; this requires finding the deepest\\n-      // path-to-directory mapping in the requested URL\\n-      var file = this._getFileForPath(path);\\n+    // determine the actual on-disk file; this requires finding the deepest\\n+    // path-to-directory mapping in the requested URL\\n+    var file = this._getFileForPath(path);\\n \\n-      // the \\\"file\\\" might be a directory, in which case we either serve the\\n-      // contained index.html or make the index handler write the response\\n-      if (file.exists() && file.isDirectory())\\n+    // the \\\"file\\\" might be a directory, in which case we either serve the\\n+    // contained index.html or make the index handler write the response\\n+    if (file.exists() && file.isDirectory())\\n+    {\\n+      file.append(\\\"index.html\\\"); // make configurable?\\n+      if (!file.exists() || file.isDirectory())\\n       {\\n-        file.append(\\\"index.html\\\"); // make configurable?\\n-        if (!file.exists() || file.isDirectory())\\n-        {\\n-          metadata._bag.setPropertyAsInterface(\\\"directory\\\", file.parent);\\n-          this._indexHandler(metadata, response);\\n-          return;\\n-        }\\n+        metadata._ensurePropertyBag();\\n+        metadata._bag.setPropertyAsInterface(\\\"directory\\\", file.parent);\\n+        this._indexHandler(metadata, response);\\n+        return;\\n       }\\n+    }\\n \\n-      // alternately, the file might not exist\\n-      if (!file.exists())\\n-        throw HTTP_404;\\n+    // alternately, the file might not exist\\n+    if (!file.exists())\\n+      throw HTTP_404;\\n \\n-      // finally...\\n-      dumpn(\\\"*** handling '\\\" + path + \\\"' as mapping to \\\" + file.path);\\n-      this._writeFileResponse(file, response);\\n+    // finally...\\n+    dumpn(\\\"*** handling '\\\" + path + \\\"' as mapping to \\\" + file.path);\\n+    this._writeFileResponse(file, response);\\n \\n-      maybeAddHeaders(file, metadata, response);\\n-    }\\n-    catch (e)\\n-    {\\n-      // something failed, but make the calling code handle Response cleanup\\n-      throw e;\\n-    }\\n+    maybeAddHeaders(file, metadata, response);\\n   },\\n \\n   /**\\n    * Writes an HTTP response for the given file, including setting headers for\\n    * file metadata.\\n    *\\n-   * @param file\\n+   * @param file : nsILocalFile\\n    *   the file which is to be sent in the response\\n-   * @param response\\n+   * @param response : Response\\n    *   the response to which the file should be written\\n    */\\n   _writeFileResponse: function(file, response)\\n@@ -1152,13 +1818,14 @@ ServerHandler.prototype =\\n    * all registered path->directory mappings and any paths which are explicitly\\n    * overridden.\\n    *\\n-   * @returns\\n-   *   the nsILocalFile which is to be sent as the response to a request for\\n-   *   path\\n+   * @param path : string\\n+   *   the server path for which a file should be retrieved, e.g. \\\"/foo/bar\\\"\\n    * @throws HttpError\\n    *   when the correct action is the corresponding HTTP error (i.e., because no\\n    *   mapping was found for a directory in path, the referenced file doesn't\\n    *   exist, etc.)\\n+   * @returns nsILocalFile\\n+   *   the file to be sent as the response to a request for the path\\n    */\\n   _getFileForPath: function(path)\\n   {\\n@@ -1233,9 +1900,36 @@ ServerHandler.prototype =\\n       if (!dirIsRoot && file.equals(parentFolder))\\n         throw HTTP_403;\\n     }\\n-\\n-    return file;\\n-  },\\n+\\n+    return file;\\n+  },\\n+\\n+  /**\\n+   * Writes the error page for the given HTTP error code over the given\\n+   * connection.\\n+   *\\n+   * @param errorCode : uint\\n+   *   the HTTP error code to be used\\n+   * @param connection : Connection\\n+   *   the connection on which the error occurred\\n+   */\\n+  handleError: function(errorCode, connection)\\n+  {\\n+    var response = new Response();\\n+\\n+    dumpn(\\\"*** error in request: \\\" + errorCode);\\n+\\n+    try\\n+    {\\n+      this._handleError(errorCode, new Request(connection.port), response);\\n+      this._end(response, connection);\\n+    }\\n+    catch (e)\\n+    {\\n+      connection.close();\\n+      connection.server.stop();\\n+    }\\n+  }, \\n \\n   /**\\n    * Handles a request which generates the given error code, using the\\n@@ -1243,21 +1937,22 @@ ServerHandler.prototype =\\n    * the x00 status code if the code has no handler, and failing to status code\\n    * 500 if all else fails.\\n    *\\n-   * @param metadata\\n+   * @param errorCode : uint\\n+   *   the HTTP error which is to be returned\\n+   * @param metadata : Request\\n    *   metadata for the request, which will often be incomplete since this is an\\n-   *   error -- must have its .errorCode set for the desired error\\n-   * @param response\\n+   *   error\\n+   * @param response : Response\\n    *   an uninitialized Response should be initialized when this method\\n    *   completes with information which represents the desired error code in the\\n    *   ideal case or a fallback code in abnormal circumstances (i.e., 500 is a\\n    *   fallback for 505, per HTTP specs)\\n    */\\n-  _handleError: function(metadata, response)\\n+  _handleError: function(errorCode, metadata, response)\\n   {\\n     if (!metadata)\\n       throw Cr.NS_ERROR_NULL_POINTER;\\n \\n-    var errorCode = metadata.errorCode;\\n     var errorX00 = errorCode - (errorCode % 100);\\n \\n     try\\n@@ -1324,167 +2019,182 @@ ServerHandler.prototype =\\n    * those headers and data, sends them to the HTTP client, and halts further\\n    * processing.  It will also send a quit message to the server if necessary.\\n    *\\n-   * @param response\\n-   *   a Response object representing the desired response\\n-   * @param outStream\\n-   *   a stream to which the response should be written\\n+   * This method never throws an exception.\\n+   *\\n+   * @param response : Response\\n+   *   the desired response\\n+   * @param connection : Connection\\n+   *   the connection associated with the given response\\n    * @note\\n    *   after completion, response must be considered \\\"dead\\\", and none of its\\n    *   methods or properties may be accessed\\n    */\\n-  _end:  function(response, outStream)\\n+  _end:  function(response, connection)\\n   {\\n+    // post-processing\\n+    response.setHeader(\\\"Connection\\\", \\\"close\\\", false);\\n+    response.setHeader(\\\"Server\\\", \\\"MozJSHTTP\\\", false);\\n+    response.setHeader(\\\"Date\\\", toDateString(Date.now()), false);\\n+\\n+    var bodyStream = response.bodyInputStream;\\n+\\n+    // XXX suckage time!\\n+    //\\n+    // If the body of the response has had no data written to it (or has never\\n+    // been accessed -- same deal internally since we'll create one if we have\\n+    // to access bodyInputStream but have neither an input stream nor an\\n+    // output stream), the in-tree implementation of nsIPipe is such that\\n+    // when we try to close the pipe's output stream with no data in it, this\\n+    // is interpreted as an error and closing the output stream also closes\\n+    // the input stream.  .available then throws, so we catch and deal as best\\n+    // as we can.\\n+    //\\n+    // Unfortunately, the easy alternative (substitute a storage stream for a\\n+    // pipe) also doesn't work.  There's no problem writing zero bytes to the\\n+    // output end of the stream, but then attempting to get an input stream to\\n+    // read fails because the seek position must be strictly less than the\\n+    // buffer size.\\n+    //\\n+    // Much as I'd like the zero-byte body to be a mostly-unimportant problem,\\n+    // there are some HTTP responses such as 304 Not Modified which MUST have\\n+    // zero-byte bodies, so this *is* a necessary hack.\\n     try\\n     {\\n-      // post-processing\\n-      response.setHeader(\\\"Connection\\\", \\\"close\\\", false);\\n-      response.setHeader(\\\"Server\\\", \\\"MozJSHTTP\\\", false);\\n-      response.setHeader(\\\"Date\\\", toDateString(Date.now()), false);\\n-\\n-      var bodyStream = response.bodyInputStream\\n-                               .QueryInterface(Ci.nsIInputStream);\\n+      var available = bodyStream.available();\\n+    }\\n+    catch (e)\\n+    {\\n+      available = 0;\\n+    }\\n \\n-      // XXX suckage time!\\n-      //\\n-      // If the body of the response has had no data written to it (or has never\\n-      // been accessed -- same deal internally since we'll create one if we have\\n-      // to access bodyInputStream but have neither an input stream nor an\\n-      // output stream), the in-tree implementation of nsIPipe is such that\\n-      // when we try to close the pipe's output stream with no data in it, this\\n-      // is interpreted as an error and closing the output stream also closes\\n-      // the input stream.  .available then throws, so we catch and deal as best\\n-      // as we can.\\n-      //\\n-      // Unfortunately, the easy alternative (substitute a storage stream for a\\n-      // pipe) also doesn't work.  There's no problem writing zero bytes to the\\n-      // output end of the stream, but then attempting to get an input stream to\\n-      // read fails because the seek position must be strictly less than the\\n-      // buffer size.\\n-      //\\n-      // Much as I'd like the zero-byte body to be a mostly-unimportant problem,\\n-      // there are some HTTP responses such as 304 Not Modified which MUST have\\n-      // zero-byte bodies, so this *is* a necessary hack.\\n-      try\\n-      {\\n-        var available = bodyStream.available();\\n-      }\\n-      catch (e)\\n-      {\\n-        available = 0;\\n-      }\\n+    response.setHeader(\\\"Content-Length\\\", available.toString(), false);\\n \\n-      response.setHeader(\\\"Content-Length\\\", available.toString(), false);\\n \\n+    // construct and send response\\n \\n-      // construct and send response\\n+    // request-line\\n+    var preamble = \\\"HTTP/\\\" + response.httpVersion + \\\" \\\" +\\n+                   response.httpCode + \\\" \\\" +\\n+                   response.httpDescription + \\\"\\\\r\\\\n\\\";\\n \\n-      // request-line\\n-      var preamble = \\\"HTTP/\\\" + response.httpVersion + \\\" \\\" +\\n-                     response.httpCode + \\\" \\\" +\\n-                     response.httpDescription + \\\"\\\\r\\\\n\\\";\\n+    // headers\\n+    var head = response.headers;\\n+    var headEnum = head.enumerator;\\n+    while (headEnum.hasMoreElements())\\n+    {\\n+      var fieldName = headEnum.getNext()\\n+                              .QueryInterface(Ci.nsISupportsString)\\n+                              .data;\\n+      preamble += fieldName + \\\": \\\" + head.getHeader(fieldName) + \\\"\\\\r\\\\n\\\";\\n+    }\\n \\n-      // headers\\n-      var head = response.headers;\\n-      var headEnum = head.enumerator;\\n-      while (headEnum.hasMoreElements())\\n-      {\\n-        var fieldName = headEnum.getNext()\\n-                                .QueryInterface(Ci.nsISupportsString)\\n-                                .data;\\n-        preamble += fieldName + \\\": \\\" + head.getHeader(fieldName) + \\\"\\\\r\\\\n\\\";\\n-      }\\n+    // end request-line/headers\\n+    preamble += \\\"\\\\r\\\\n\\\";\\n \\n-      // end request-line/headers\\n-      preamble += \\\"\\\\r\\\\n\\\";\\n+    var outStream = connection.output;\\n+    try\\n+    {\\n       outStream.write(preamble, preamble.length);\\n+    }\\n+    catch (e)\\n+    {\\n+      // Connection closed already?  Even if not, failure to write the response\\n+      // means we probably will fail later anyway, so in the interests of\\n+      // avoiding exceptions we'll (possibly) close the connection and return.\\n+      response.destroy();\\n+      connection.close();\\n+      return;\\n+    }\\n \\n-\\n-      // In certain situations, it's possible for us to have a race between\\n-      // the copy observer's onStopRequest and the listener for a channel\\n-      // opened to this server.  Since we include a Content-Length header with\\n-      // every response, if the channel snarfs up all the data we promise,\\n-      // calls onStopRequest on the listener (and the server is shut down\\n-      // by that listener, causing the script to finish executing), and then\\n-      // tries to call onStopRequest on the copyObserver, we'll call into a\\n-      // scope with no Components and cause assertions *and* fail to close the\\n-      // connection properly.  To combat this, during server shutdown we delay\\n-      // full shutdown until any pending requests are fully copied using this\\n-      // property on the server handler.  We increment before (possibly)\\n-      // starting the copy observer and decrement when the copy completes,\\n-      // ensuring that all copies complete before the server fully shuts down.\\n-      //\\n-      // We do this for every request primarily to simplify maintenance of this\\n-      // property (and also because it's less fragile when we can remove the\\n-      // zero-sized body hack used above).\\n-      this._pendingRequests++;\\n-\\n-      // If we have a body, send it -- if we don't, then don't bother with a\\n-      // heavyweight async copy which doesn't need to happen and just do\\n-      // response post-processing (usually handled by the copy observer)\\n-      // directly\\n-      if (available != 0)\\n-      {\\n-        // local references for use in the copy observer\\n-        var server = this._server;\\n-        var handler = this;\\n-\\n-        /**\\n-         * Observer of the copying of data from the body stream generated by a\\n-         * request handler to the output stream for the server socket.  It\\n-         * handles all post-request-writing cleanup details, such as closing\\n-         * open streams and shutting down the server in case of errors.\\n-         */\\n-        var copyObserver =\\n+    // In certain situations, it's possible for us to have a race between\\n+    // the copy observer's onStopRequest and the listener for a channel\\n+    // opened to this server.  Since we include a Content-Length header with\\n+    // every response, if the channel snarfs up all the data we promise,\\n+    // calls onStopRequest on the listener (and the server is shut down\\n+    // by that listener, causing the script to finish executing), and then\\n+    // tries to call onStopRequest on the copyObserver, we'll call into a\\n+    // scope with no Components and cause assertions *and* fail to close the\\n+    // connection properly.  To combat this, during server shutdown we delay\\n+    // full shutdown until any pending requests are fully copied using this\\n+    // property on the server handler.  We increment before (possibly)\\n+    // starting the copy observer and decrement when the copy completes,\\n+    // ensuring that all copies complete before the server fully shuts down.\\n+    //\\n+    // We do this for every request primarily to simplify maintenance of this\\n+    // property (and also because it's less fragile when we can remove the\\n+    // zero-sized body hack used above).\\n+    this._pendingRequests++;\\n+\\n+    var server = this._server;\\n+\\n+    // If we have a body, send it -- if we don't, then don't bother with a\\n+    // heavyweight async copy which doesn't need to happen and just do\\n+    // response post-processing (usually handled by the copy observer)\\n+    // directly\\n+    if (available != 0)\\n+    {\\n+      /**\\n+       * Observer of the copying of data from the body stream generated by a\\n+       * request handler to the output stream for the server socket.  It\\n+       * handles all post-request-writing cleanup details, such as closing\\n+       * open streams and shutting down the server in case of errors.\\n+       */\\n+      var copyObserver =\\n+        {\\n+          onStartRequest: function(request, context) { /* don't care */ },\\n+\\n+          /**\\n+           * Called when the async stream copy completes.  This is place where\\n+           * final cleanup should occur, including stream closures and\\n+           * response destruction.  Note that errors which are detected here\\n+           * should still shut down the server, for safety.\\n+           */\\n+          onStopRequest: function(request, cx, statusCode)\\n           {\\n-            onStartRequest: function(request, context) { /* don't care */ },\\n-\\n-            /**\\n-             * Called when the async stream copy completes.  This is place where\\n-             * final cleanup should occur, including stream closures and\\n-             * response destruction.  Note that errors which are detected here\\n-             * should still shut down the server, for safety.\\n-             */\\n-            onStopRequest: function(request, context, statusCode)\\n+            // statusCode can indicate user-triggered failures (e.g. if the user\\n+            // closes the connection during the copy, which would cause a status\\n+            // of NS_ERROR_NET_RESET), so don't treat its value being an error\\n+            // code as catastrophic.  I can create this situation when running\\n+            // Mochitests in a debug build by clicking the Stop button during\\n+            // test execution, but it's not exactly a surefire way to reproduce\\n+            // the problem.\\n+            if (!Components.isSuccessCode(statusCode))\\n             {\\n-              // if something bad happened during the copy, be paranoid\\n-              if (!Components.isSuccessCode(statusCode))\\n-                server._requestQuit();\\n+              dumpn(\\\"*** WARNING: non-success statusCode in onStopRequest: \\\" +\\n+                    statusCode);\\n+            }\\n \\n-              // we're completely finished with this response\\n-              response.destroy();\\n+            // we're completely finished with this response\\n+            response.destroy();\\n \\n-              server._endConnection(handler, outStream);\\n-            },\\n+            connection.end();\\n+          },\\n \\n-            QueryInterface: function(aIID)\\n-            {\\n-              if (aIID.equals(Ci.nsIRequestObserver) ||\\n-                  aIID.equals(Ci.nsISupports))\\n-                return this;\\n+          QueryInterface: function(aIID)\\n+          {\\n+            if (aIID.equals(Ci.nsIRequestObserver) ||\\n+                aIID.equals(Ci.nsISupports))\\n+              return this;\\n \\n-              throw Cr.NS_ERROR_NO_INTERFACE;\\n-            }\\n-          };\\n+            throw Cr.NS_ERROR_NO_INTERFACE;\\n+          }\\n+        };\\n \\n \\n-        // body -- written async, because pipes deadlock if we do\\n-        // |outStream.writeFrom(bodyStream, bodyStream.available());|\\n-        var copier = new StreamCopier(bodyStream, outStream, null,\\n-                                      true, true, 8192);\\n-        copier.asyncCopy(copyObserver, null);\\n-      }\\n-      else\\n-      {\\n-        // finished with the response -- destroy\\n-        response.destroy();\\n-        this._server._endConnection(this, outStream);\\n-      }\\n+      //\\n+      // Now write out the body, async since we might be serving this to\\n+      // ourselves on the same thread, and writing too much data would deadlock.\\n+      //\\n+      var copier = new StreamCopier(bodyStream, outStream,\\n+                                    null,\\n+                                    true, true, 8192);\\n+      copier.asyncCopy(copyObserver, null);\\n     }\\n-    catch (e)\\n+    else\\n     {\\n-      // something bad happened -- throw and make calling code deal with the\\n-      // response given to us\\n-      throw e;\\n+      // finished with the response -- destroy\\n+      response.destroy();\\n+      this._server._endConnection(connection);\\n     }\\n   },\\n \\n@@ -1617,7 +2327,7 @@ ServerHandler.prototype =\\n       if (metadata.queryString)\\n         body +=  \\\"?\\\" + metadata.queryString;\\n         \\n-      body += \\\" HTTP/\\\" + metadata.httpVersion + \\\"\\\\n\\\";\\n+      body += \\\" HTTP/\\\" + metadata.httpVersion + \\\"\\\\r\\\\n\\\";\\n \\n       var headEnum = metadata.headers;\\n       while (headEnum.hasMoreElements())\\n@@ -1625,7 +2335,7 @@ ServerHandler.prototype =\\n         var fieldName = headEnum.getNext()\\n                                 .QueryInterface(Ci.nsISupportsString)\\n                                 .data;\\n-        body += fieldName + \\\": \\\" + metadata.getHeader(fieldName) + \\\"\\\\n\\\";\\n+        body += fieldName + \\\": \\\" + metadata.getHeader(fieldName) + \\\"\\\\r\\\\n\\\";\\n       }\\n \\n       response.bodyOutputStream.write(body, body.length);\\n@@ -1649,6 +2359,11 @@ FileMap.prototype =\\n   /**\\n    * Maps key to a clone of the nsILocalFile value if value is non-null;\\n    * otherwise, removes any extant mapping for key.\\n+   *\\n+   * @param key : string\\n+   *   string to which a clone of value is mapped\\n+   * @param value : nsILocalFile\\n+   *   the file to map to key, or null to remove a mapping\\n    */\\n   put: function(key, value)\\n   {\\n@@ -1661,6 +2376,11 @@ FileMap.prototype =\\n   /**\\n    * Returns a clone of the nsILocalFile mapped to key, or null if no such\\n    * mapping exists.\\n+   *\\n+   * @param key : string\\n+   *   key to which the returned file maps\\n+   * @returns nsILocalFile\\n+   *   a clone of the mapped file, or null if no mapping exists\\n    */\\n   get: function(key)\\n   {\\n@@ -1704,9 +2424,9 @@ const IS_TOKEN_ARRAY =\\n /**\\n  * Determines whether the given character code is a CTL.\\n  *\\n- * @param code\\n+ * @param code : uint\\n  *   the character code\\n- * @returns\\n+ * @returns boolean\\n  *   true if code is a CTL, false otherwise\\n  */\\n function isCTL(code)\\n@@ -2003,7 +2723,7 @@ const headerUtils =\\n    *\\n    * @throws NS_ERROR_INVALID_ARG\\n    *   if fieldName does not match the field-name production in RFC 2616\\n-   * @returns\\n+   * @returns string\\n    *   fieldName converted to lowercase if it is a valid header, for characters\\n    *   where case conversion is possible\\n    */\\n@@ -2030,11 +2750,11 @@ const headerUtils =\\n    * part of the HTTP protocol), normalizes the value if it is, and\\n    * returns the normalized value.\\n    *\\n-   * @param fieldValue\\n+   * @param fieldValue : string\\n    *   a value to be normalized as an HTTP header field value\\n    * @throws NS_ERROR_INVALID_ARG\\n    *   if fieldValue does not match the field-value production in RFC 2616\\n-   * @returns\\n+   * @returns string\\n    *   fieldValue as a normalized HTTP header field value\\n    */\\n   normalizeFieldValue: function(fieldValue)\\n@@ -2078,9 +2798,9 @@ const headerUtils =\\n  * Converts the given string into a string which is safe for use in an HTML\\n  * context.\\n  *\\n- * @param str\\n+ * @param str : string\\n  *   the string to make HTML-safe\\n- * @returns\\n+ * @returns string\\n  *   an HTML-safe version of str\\n  */\\n function htmlEscape(str)\\n@@ -2108,8 +2828,12 @@ function nsHttpVersion(versionString)\\n   if (!matches)\\n     throw \\\"Not a valid HTTP version!\\\";\\n \\n+  /** The major version number of this, as a number. */\\n   this.major = parseInt(matches[1], 10);\\n+\\n+  /** The minor version number of this, as a number. */\\n   this.minor = parseInt(matches[2], 10);\\n+\\n   if (isNaN(this.major) || isNaN(this.minor) ||\\n       this.major < 0    || this.minor < 0)\\n     throw \\\"Not a valid HTTP version!\\\";\\n@@ -2117,16 +2841,6 @@ function nsHttpVersion(versionString)\\n nsHttpVersion.prototype =\\n {\\n   /**\\n-   * The major version number of this, as a number\\n-   */\\n-  major: undefined,\\n-\\n-  /**\\n-   * The minor version number of this, as a number.\\n-   */\\n-  minor: undefined,\\n-\\n-  /**\\n    * Returns the standard string representation of the HTTP version represented\\n    * by this (e.g., \\\"1.1\\\").\\n    */\\n@@ -2138,6 +2852,9 @@ nsHttpVersion.prototype =\\n   /**\\n    * Returns true if this represents the same HTTP version as otherVersion,\\n    * false otherwise.\\n+   *\\n+   * @param otherVersion : nsHttpVersion\\n+   *   the version to compare against this\\n    */\\n   equals: function (otherVersion)\\n   {\\n@@ -2180,9 +2897,9 @@ nsHttpHeaders.prototype =\\n   /**\\n    * Sets the header represented by name and value in this.\\n    *\\n-   * @param name\\n+   * @param name : string\\n    *   the header name\\n-   * @param value\\n+   * @param value : string\\n    *   the header value\\n    * @throws NS_ERROR_INVALID_ARG\\n    *   if name or value is not a valid header component\\n@@ -2201,14 +2918,14 @@ nsHttpHeaders.prototype =\\n   /**\\n    * Returns the value for the header specified by this.\\n    *\\n-   * @returns\\n-   *   the field value for the given header, possibly with non-semantic changes\\n-   *   (i.e., leading/trailing whitespace stripped, whitespace runs replaced\\n-   *   with spaces, etc.) at the option of the implementation\\n    * @throws NS_ERROR_INVALID_ARG\\n    *   if fieldName does not constitute a valid header field name\\n    * @throws NS_ERROR_NOT_AVAILABLE\\n    *   if the given header does not exist in this\\n+   * @returns string\\n+   *   the field value for the given header, possibly with non-semantic changes\\n+   *   (i.e., leading/trailing whitespace stripped, whitespace runs replaced\\n+   *   with spaces, etc.) at the option of the implementation\\n    */\\n   getHeader: function(fieldName)\\n   {\\n@@ -2224,10 +2941,12 @@ nsHttpHeaders.prototype =\\n    * Returns true if a header with the given field name exists in this, false\\n    * otherwise.\\n    *\\n-   * @param fieldName\\n+   * @param fieldName : string\\n    *   the field name whose existence is to be determined in this\\n    * @throws NS_ERROR_INVALID_ARG\\n    *   if fieldName does not constitute a valid header field name\\n+   * @returns boolean\\n+   *   true if the header's present, false otherwise\\n    */\\n   hasHeader: function(fieldName)\\n   {\\n@@ -2259,8 +2978,8 @@ nsHttpHeaders.prototype =\\n /**\\n  * Constructs an nsISimpleEnumerator for the given array of items.\\n  *\\n- * @param items\\n- *   the array of items, which must all implement nsISupports\\n+ * @param items : Array\\n+ *   the items, which must all implement nsISupports\\n  */\\n function nsSimpleEnumerator(items)\\n {\\n@@ -2292,22 +3011,19 @@ nsSimpleEnumerator.prototype =\\n \\n \\n /**\\n- * Parses a server request into a set of metadata, so far as is possible.  Any\\n- * detected errors will result in this.errorCode being set to an HTTP error code\\n- * value.  Users MUST check this value after creation and any external\\n- * initialization of RequestMetadata objects to ensure that errors are handled\\n- * correctly.\\n+ * A representation of the data in an HTTP request.\\n  *\\n- * @param port\\n+ * @param port : uint\\n  *   the port on which the server receiving this request runs\\n  */\\n-function RequestMetadata(port)\\n+function Request(port)\\n {\\n   this._method = \\\"\\\";\\n   this._path = \\\"\\\";\\n   this._queryString = \\\"\\\";\\n   this._host = \\\"\\\";\\n   this._port = port;\\n+  this._host = \\\"localhost\\\"; // XXX or from environment or server itself?\\n \\n   /**\\n    * The headers in this request.\\n@@ -2315,20 +3031,13 @@ function RequestMetadata(port)\\n   this._headers = new nsHttpHeaders();\\n \\n   /**\\n-   * For the addition of ad-hoc properties and new functionality\\n-   * without having to tweak nsIHttpRequestMetadata every time.\\n-   */\\n-  this._bag = new WritablePropertyBag();\\n-\\n-  /**\\n-   * The numeric HTTP error, if any, associated with this request.  This value\\n-   * may be set by the constructor but is usually only set by the handler after\\n-   * this has been constructed.  After this has been initialized, this value\\n-   * MUST be checked for errors.\\n+   * For the addition of ad-hoc properties and new functionality without having\\n+   * to change nsIHttpRequestMetadata every time; currently lazily created,\\n+   * as its only use is in directory listings.\\n    */\\n-  this.errorCode = 0;\\n+  this._bag = null;\\n }\\n-RequestMetadata.prototype =\\n+Request.prototype =\\n {\\n   // SERVER METADATA\\n \\n@@ -2413,6 +3122,7 @@ RequestMetadata.prototype =\\n   //\\n   get enumerator()\\n   {\\n+    this._ensurePropertyBag();\\n     return this._bag.enumerator;\\n   },\\n \\n@@ -2421,262 +3131,15 @@ RequestMetadata.prototype =\\n   //\\n   getProperty: function(name) \\n   {\\n+    this._ensurePropertyBag();\\n     return this._bag.getProperty(name);\\n   },\\n-\\n-  // ENTITY\\n-\\n-  /**\\n-   * An input stream which contains the body of this request.\\n-   */\\n-  get bodyStream()\\n-  {\\n-    // we want this once we do real request processing -- expose externally when\\n-    // we do this\\n-    return null;\\n-  },\\n-\\n-  // PUBLIC CONSTRUCTION API\\n-\\n-  /**\\n-   * The HTTP error code which should be the result of this request.  It must be\\n-   * checked whenever other API documentation says it should be checked.\\n-   */\\n-  errorCode: 0,\\n-\\n-  // INITIALIZATION\\n-  init: function(input)\\n-  {\\n-    // XXX this is incredibly un-RFC2616 in every possible way:\\n-    //\\n-    // - accepts non-CRLF line endings\\n-    // - no real testing for non-US-ASCII text and throwing in that case\\n-    // - handles POSTs by displaying the URL and throwing away the request\\n-    //   entity\\n-    // - need to support RFC 2047-encoded non-US-ASCII characters\\n-    // - really support absolute URLs (requires telling the server its hostname,\\n-    //   beyond just localhost:port and 127.0.0.1:port), not just pretend we\\n-    //   serve every request that's given to us regardless of the server\\n-    //   hostname and port\\n-    // - etc.\\n-\\n-    // read the input line by line; the first line either tells us the requested\\n-    // path or is empty, in which case the second line contains the path\\n-    var lis = new ConverterInputStream(input, \\\"ISO-8859-1\\\", 1024, 0xFFFD);\\n-    lis.QueryInterface(Ci.nsIUnicharLineInputStream);\\n-\\n-\\n-    this._parseRequestLine(lis);\\n-    if (this.errorCode)\\n-      return;\\n-\\n-    this._parseHeaders(lis);\\n-    if (this.errorCode)\\n-      return;\\n-\\n-    // XXX need to put body transmitted with this request into an input stream!\\n-\\n-    // 19.6.1.1 -- servers MUST report 400 to HTTP/1.1 requests w/o Host header\\n-    if (!this._headers.hasHeader(\\\"Host\\\") &&\\n-        this._httpVersion.equals(nsHttpVersion.HTTP_1_1))\\n-    {\\n-      this.errorCode = 400;\\n-      return;\\n-    }\\n-\\n-    // XXX set this based on Host or the request URI?\\n-    this._host = \\\"localhost\\\";\\n-  },\\n-\\n-  // PRIVATE API\\n-\\n-  /**\\n-   * Parses the request line for the HTTP request in the given input stream.  On\\n-   * completion this.errorCode must be checked to determine whether any errors\\n-   * occurred during header parsing.\\n-   *\\n-   * @param lis\\n-   *   an nsIUnicharLineInputStream from which to parse HTTP headers\\n-   */\\n-  _parseRequestLine: function(lis)\\n-  {\\n-    // servers SHOULD ignore any empty line(s) received where a Request-Line\\n-    // is expected (section 4.1)\\n-    var line = {};\\n-    while (lis.readLine(line) && line.value == \\\"\\\")\\n-      dumpn(\\\"*** ignoring beginning blank line...\\\");\\n-\\n-    // clients and servers SHOULD accept any amount of SP or HT characters\\n-    // between fields, even though only a single SP is required (section 19.3)\\n-    var request = line.value.split(/[ \\\\t]+/);\\n-    if (!request || request.length != 3)\\n-    {\\n-      this.errorCode = 400;\\n-      return;\\n-    }\\n-\\n-    this._method = request[0];\\n-\\n-    // check the HTTP version\\n-    var ver = request[2];\\n-    var match = ver.match(/^HTTP\\\\/(\\\\d+\\\\.\\\\d+)$/);\\n-    if (!match)\\n-    {\\n-      this.errorCode = 400;\\n-      return;\\n-    }\\n-\\n-    // reject unrecognized methods\\n-    if (request[0] != \\\"GET\\\" && request[0] != \\\"POST\\\")\\n-    {\\n-      this.errorCode = 501;\\n-      return;\\n-    }\\n-\\n-    // determine HTTP version\\n-    try\\n-    {\\n-      this._httpVersion = new nsHttpVersion(match[1]);\\n-      if (!this._httpVersion.equals(nsHttpVersion.HTTP_1_0) &&\\n-          !this._httpVersion.equals(nsHttpVersion.HTTP_1_1))\\n-        throw \\\"unsupported HTTP version\\\";\\n-    }\\n-    catch (e)\\n-    {\\n-      // we support HTTP/1.0 and HTTP/1.1 only\\n-      this.errorCode = 501;\\n-      return;\\n-    }\\n-\\n-    var fullPath = request[1];\\n-\\n-    if (fullPath.charAt(0) != \\\"/\\\")\\n-    {\\n-      // XXX we don't support absolute URIs yet -- a MUST for HTTP/1.1;\\n-      //     for now just get the path and use that, ignoring hostport\\n-      try\\n-      {\\n-        var uri = Cc[\\\"@mozilla.org/network/io-service;1\\\"]\\n-                    .getService(Ci.nsIIOService)\\n-                    .newURI(fullPath, null, null);\\n-        fullPath = uri.path;\\n-      }\\n-      catch (e) { /* invalid URI */ }\\n-      if (fullPath.charAt(0) != \\\"/\\\")\\n-      {\\n-        this.errorCode = 400;\\n-        return;\\n-      }\\n-    }\\n-\\n-    var splitter = fullPath.indexOf(\\\"?\\\");\\n-    if (splitter < 0)\\n-    {\\n-      // _queryString already set in ctor\\n-      this._path = fullPath;\\n-    }\\n-    else\\n-    {\\n-      this._path = fullPath.substring(0, splitter);\\n-      this._queryString = fullPath.substring(splitter + 1);\\n-    }\\n-  },\\n-\\n-  /**\\n-   * Parses all available HTTP headers from the given input stream.  On\\n-   * completion, this.errorCode must be checked to determine whether any errors\\n-   * occurred during header parsing.\\n-   *\\n-   * @param lis\\n-   *   the nsIUnicharLineInputStream from which to parse HTTP headers\\n-   */\\n-  _parseHeaders: function(lis)\\n+  \\n+  /** Ensures a property bag has been created for ad-hoc behaviors. */\\n+  _ensurePropertyBag: function()\\n   {\\n-    var headers = this._headers;\\n-    var lastName, lastVal;\\n-\\n-    var line = {};\\n-    while (true)\\n-    {\\n-      NS_ASSERT((lastVal === undefined && lastName === undefined) ||\\n-                (lastVal !== undefined && lastName !== undefined),\\n-                lastName === undefined ?\\n-                  \\\"lastVal without lastName?  lastVal: '\\\" + lastVal + \\\"'\\\" :\\n-                  \\\"lastName without lastVal?  lastName: '\\\" + lastName + \\\"'\\\");\\n-\\n-      lis.readLine(line);\\n-      var lineText = line.value;\\n-      var firstChar = lineText.charAt(0);\\n-\\n-      // blank line means end of headers\\n-      if (lineText == \\\"\\\")\\n-      {\\n-        // we're finished with the previous header\\n-        if (lastName)\\n-        {\\n-          try\\n-          {\\n-            headers.setHeader(lastName, lastVal, true);\\n-          }\\n-          catch (e)\\n-          {\\n-            dumpn(\\\"*** e == \\\" + e);\\n-            this.errorCode = 400;\\n-            return;\\n-          }\\n-        }\\n-        else\\n-        {\\n-          // no headers in request -- valid for HTTP/1.0 requests\\n-        }\\n-\\n-        // either way, we're done processing headers\\n-        break;\\n-      }\\n-      else if (firstChar == \\\" \\\" || firstChar == \\\"\\\\t\\\")\\n-      {\\n-        // multi-line header if we've seen a header line\\n-        if (!lastName)\\n-        {\\n-          // we don't have a header to continue!\\n-          this.errorCode = 400;\\n-          return;\\n-        }\\n-\\n-        // append this line's text to the value; starts with SP/HT, so no need\\n-        // for separating whitespace\\n-        lastVal += lineText;\\n-      }\\n-      else\\n-      {\\n-        // we have a new header, so set the old one (if one existed)\\n-        if (lastName)\\n-        {\\n-          try\\n-          {\\n-            headers.setHeader(lastName, lastVal, true);\\n-          }\\n-          catch (e)\\n-          {\\n-            dumpn(\\\"*** e == \\\" + e);\\n-            this.errorCode = 400;\\n-            return;\\n-          }\\n-        }\\n-\\n-        var colon = lineText.indexOf(\\\":\\\"); // first colon must be splitter\\n-        if (colon < 1)\\n-        {\\n-          // no colon or missing header field-name\\n-          this.errorCode = 400;\\n-          return;\\n-        }\\n-\\n-        // set header name, value (to be set in the next loop, usually)\\n-        lastName = lineText.substring(0, colon);\\n-        lastVal = lineText.substring(colon + 1);\\n-      } // empty, continuation, start of header\\n-    } // while (true)\\n+    if (!this._bag)\\n+      this._bag = new WritablePropertyBag();\\n   }\\n };\\n \\n@@ -2826,9 +3289,7 @@ function server(port, basePath)\\n     srv.registerDirectory(\\\"/\\\", lp);\\n   srv.start(port);\\n \\n-  var thread = Cc[\\\"@mozilla.org/thread-manager;1\\\"]\\n-                 .getService()\\n-                 .currentThread;\\n+  var thread = gThreadManager.currentThread;\\n   while (!srv.isStopped())\\n     thread.processNextEvent(true);\\n \\ndiff --git a/netwerk/test/httpserver/nsIHttpServer.idl b/netwerk/test/httpserver/nsIHttpServer.idl\\nindex 54a0f63..4b14c10 100644\\n--- a/netwerk/test/httpserver/nsIHttpServer.idl\\n+++ b/netwerk/test/httpserver/nsIHttpServer.idl\\n@@ -272,13 +272,13 @@ interface nsIHttpRequestMetadata : nsIPropertyBag\\n   boolean hasHeader(in string fieldName);\\n \\n   /**\\n-   * An nsISimpleEnumerator over the names of the headers in this request.  The\\n-   * header field names in the enumerator may not necessarily have the same case\\n-   * as they do in the request itself.\\n+   * An nsISimpleEnumerator of nsISupportsStrings over the names of the headers\\n+   * in this request.  The header field names in the enumerator may not\\n+   * necessarily have the same case as they do in the request itself.\\n    */\\n   readonly attribute nsISimpleEnumerator headers;\\n \\n-  // XXX should expose body of request here!\\n+  // XXX expose request body here!\\n };\\n \\n \\ndiff --git a/netwerk/test/httpserver/test/head_utils.js b/netwerk/test/httpserver/test/head_utils.js\\nindex 2b5d1fb..16ce16f 100644\\n--- a/netwerk/test/httpserver/test/head_utils.js\\n+++ b/netwerk/test/httpserver/test/head_utils.js\\n@@ -41,11 +41,6 @@ do_import_script(\\\"netwerk/test/httpserver/httpd.js\\\");\\n // if these tests fail, we'll want the debug output\\n DEBUG = true;\\n \\n-// XPCOM constructor shorthands\\n-const BinaryInputStream = CC(\\\"@mozilla.org/binaryinputstream;1\\\",\\n-                             \\\"nsIBinaryInputStream\\\",\\n-                             \\\"setInputStream\\\");\\n-\\n \\n /**\\n  * Constructs a new nsHttpServer instance.  This function is intended to\\ndiff --git a/netwerk/test/unit/test_reopen.js b/netwerk/test/unit/test_reopen.js\\nindex 0ebb375..b05cc3b 100644\\n--- a/netwerk/test/unit/test_reopen.js\\n+++ b/netwerk/test/unit/test_reopen.js\\n@@ -21,10 +21,6 @@ var test_array = [\\n \\n // Utility functions\\n \\n-var BinaryInputStream =\\n-          Components.Constructor(\\\"@mozilla.org/binaryinputstream;1\\\",\\n-                                 \\\"nsIBinaryInputStream\\\", \\\"setInputStream\\\");\\n-\\n function makeChan(url) {\\n   var ios = Cc[\\\"@mozilla.org/network/io-service;1\\\"]\\n               .getService(Ci.nsIIOService);\\n\""}