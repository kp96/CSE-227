{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas9f9b12b\""},"diff":"\"9f9b12b Bug 282814: nsAutoBuffer::EnsureElemCapacity is broken. r=bsmedberg, a=bzbarsky.\\ndiff --git a/xpcom/ds/nsAutoBuffer.h b/xpcom/ds/nsAutoBuffer.h\\nindex 05cb4b3..2441bcc 100644\\n--- a/xpcom/ds/nsAutoBuffer.h\\n+++ b/xpcom/ds/nsAutoBuffer.h\\n@@ -46,6 +46,13 @@\\n /**\\n  * A buffer which will use stack space if the requested size will\\n  * fit in the stack buffer and allocate from the heap if not.\\n+ *\\n+ * Be careful when you call EnsureElemCapacity/AddElemCapacity: the data\\n+ * contained in the buffer is not preserved through this operation.\\n+ *\\n+ * This class is not intended to be used with types that are not\\n+ * POD structures or primitives. The buffer allocated by this class is not\\n+ * initialized.\\n  * \\n  * Below is a usage example : \\n  * \\n@@ -58,16 +65,14 @@\\n  *\\n  * PRUnichar *unicharPtr = buffer.get();\\n  *\\n- * // add PRUnichar's to the buffer pointed to by |unicharPtr| as long as\\n- * // the number of PRUnichar's is less than |intialLength|\\n- *    \\n+ * // use the buffer for various stuff\\n+ *\\n  * // increase the capacity\\n+ * // note that the data will not be preserved through this step\\n  * if (!buffer.AddElemCapacity(extraLength))\\n  *     return NS_ERROR_OUT_OF_MEMORY\\n  *\\n- * unicharPtr = buffer.get() + initialLength;\\n- *\\n- * //continue to add PRUnichar's....\\n+ * // continue to use the buffer for other things\\n  */\\n \\n template <class T, PRInt32 sz>\\n@@ -83,27 +88,27 @@ public:\\n   ~nsAutoBuffer()\\n   {\\n     if (mBufferPtr != mStackBuffer)\\n-      nsMemory::Free(mBufferPtr);\\n+      NS_Free(mBufferPtr);\\n   }\\n \\n+  // Note that this method can forget the data in the array!\\n+  // This is intentional.\\n   PRBool EnsureElemCapacity(PRInt32 inElemCapacity)\\n   {\\n     if (inElemCapacity <= mCurElemCapacity)\\n       return PR_TRUE;\\n-    \\n+\\n     T* newBuffer;\\n \\n-    if (mBufferPtr != mStackBuffer)\\n-      newBuffer = (T*)nsMemory::Realloc((void *)mBufferPtr, inElemCapacity * sizeof(T));\\n-    else \\n-      newBuffer = (T*)nsMemory::Alloc(inElemCapacity * sizeof(T));\\n+    if (mBufferPtr != mStackBuffer) {\\n+      newBuffer = static_cast<T*>(NS_Realloc(mBufferPtr, inElemCapacity * sizeof(T)));\\n+    } else {\\n+      newBuffer = static_cast<T*>(NS_Alloc(inElemCapacity * sizeof(T)));\\n+    }\\n \\n     if (!newBuffer)\\n       return PR_FALSE;\\n \\n-    if (mBufferPtr != mStackBuffer)\\n-      nsMemory::Free(mBufferPtr);\\n-\\n     mBufferPtr = newBuffer; \\n     mCurElemCapacity = inElemCapacity;\\n     return PR_TRUE;\\n\""}