{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basa6a81f8\""},"diff":"\"a6a81f8 Bug 373462, Bug 385322, Better scheduling of cycle collection/gc, r=jst, sr=sicking, a=sicking\\ndiff --git a/content/base/src/nsXMLHttpRequest.cpp b/content/base/src/nsXMLHttpRequest.cpp\\nindex 01a99f5..40e3c9d 100644\\n--- a/content/base/src/nsXMLHttpRequest.cpp\\n+++ b/content/base/src/nsXMLHttpRequest.cpp\\n@@ -56,6 +56,7 @@\\n #include \\\"prprf.h\\\"\\n #include \\\"nsIDOMEventListener.h\\\"\\n #include \\\"nsIJSContextStack.h\\\"\\n+#include \\\"nsJSEnvironment.h\\\"\\n #include \\\"nsIScriptSecurityManager.h\\\"\\n #include \\\"nsWeakPtr.h\\\"\\n #include \\\"nsICharsetAlias.h\\\"\\n@@ -1776,6 +1777,7 @@ nsXMLHttpRequest::RequestCompleted()\\n     ChangeState(XML_HTTP_REQUEST_OPENED);\\n   }\\n \\n+  nsJSContext::MaybeCC(PR_FALSE);\\n   return rv;\\n }\\n \\n@@ -2318,6 +2320,7 @@ nsXMLHttpRequest::Error(nsIDOMEvent* aEvent)\\n     NotifyEventListeners(errorEventListeners, event);\\n   }\\n \\n+  nsJSContext::MaybeCC(PR_FALSE);\\n   return NS_OK;\\n }\\n \\ndiff --git a/dom/src/base/nsJSEnvironment.cpp b/dom/src/base/nsJSEnvironment.cpp\\nindex db881ff..3776230 100644\\n--- a/dom/src/base/nsJSEnvironment.cpp\\n+++ b/dom/src/base/nsJSEnvironment.cpp\\n@@ -154,8 +154,26 @@ static PRLogModuleInfo* gJSDiagnostics;\\n \\n #define JAVASCRIPT nsIProgrammingLanguage::JAVASCRIPT\\n \\n+// The max number of delayed cycle collects..\\n+#define NS_MAX_DELAYED_CCOLLECT     45\\n+// The max number of user interaction notifications in inactive state before\\n+// we try to call cycle collector more aggressively.\\n+#define NS_CC_SOFT_LIMIT_INACTIVE   6\\n+// The max number of user interaction notifications in active state before\\n+// we try to call cycle collector more aggressively.\\n+#define NS_CC_SOFT_LIMIT_ACTIVE     12\\n+// When higher probability MaybeCC is used, the number of sDelayedCCollectCount\\n+// is multiplied with this number.\\n+#define NS_PROBABILITY_MULTIPLIER   3\\n+// Cycle collector should never run more often than this value\\n+#define NS_MIN_CC_INTERVAL          10000 // ms\\n+\\n // if you add statics here, add them to the list in nsJSRuntime::Startup\\n \\n+static PRUint32 sDelayedCCollectCount;\\n+static PRUint32 sCCollectCount;\\n+static PRTime sPreviousCCTime;\\n+static PRBool sPreviousCCDidCollect;\\n static nsITimer *sGCTimer;\\n static PRBool sReadyForGC;\\n \\n@@ -199,6 +217,75 @@ static nsICollation *gCollation;\\n \\n static nsIUnicodeDecoder *gDecoder;\\n \\n+// nsUserActivityObserver observes user-interaction-active and\\n+// user-interaction-inactive notifications. It counts the number of\\n+// notifications and if the number is bigger than NS_CC_SOFT_LIMIT_ACTIVE\\n+// (in case the current notification is user-interaction-active) or\\n+// NS_CC_SOFT_LIMIT_INACTIVE (current notification is user-interaction-inactive)\\n+// MaybeCC is called with aHigherParameter set to PR_TRUE, otherwise PR_FALSE.\\n+//\\n+// When moving from active state to inactive, nsJSContext::CC() is called\\n+// unless the timer related to page load is active.\\n+\\n+class nsUserActivityObserver : public nsIObserver\\n+{\\n+public:\\n+  nsUserActivityObserver()\\n+  : mUserActivityCounter(0), mOldCCollectCount(0), mUserIsActive(PR_FALSE) {}\\n+  NS_DECL_ISUPPORTS\\n+  NS_DECL_NSIOBSERVER\\n+private:\\n+  PRUint32 mUserActivityCounter;\\n+  PRUint32 mOldCCollectCount;\\n+  PRBool   mUserIsActive;\\n+};\\n+\\n+NS_IMPL_ISUPPORTS1(nsUserActivityObserver, nsIObserver)\\n+\\n+NS_IMETHODIMP\\n+nsUserActivityObserver::Observe(nsISupports* aSubject, const char* aTopic,\\n+                                const PRUnichar* aData)\\n+{\\n+  if (mOldCCollectCount != sCCollectCount) {\\n+    mOldCCollectCount = sCCollectCount;\\n+    // Cycle collector was called between user interaction notifications, so\\n+    // we can reset the counter.\\n+    mUserActivityCounter = 0;\\n+  }\\n+  PRBool higherProbability = PR_FALSE;\\n+  ++mUserActivityCounter;\\n+  if (!strcmp(aTopic, \\\"user-interaction-inactive\\\")) {\\n+#ifdef DEBUG_smaug\\n+    printf(\\\"user-interaction-inactive\\\\n\\\");\\n+#endif\\n+    if (mUserIsActive) {\\n+      mUserIsActive = PR_FALSE;\\n+      if (!sGCTimer) {\\n+        nsJSContext::CC();\\n+        return NS_OK;\\n+      }\\n+    }\\n+    higherProbability = (mUserActivityCounter > NS_CC_SOFT_LIMIT_INACTIVE);\\n+  } else if (!strcmp(aTopic, \\\"user-interaction-active\\\")) {\\n+#ifdef DEBUG_smaug\\n+    printf(\\\"user-interaction-active\\\\n\\\");\\n+#endif\\n+    mUserIsActive = PR_TRUE;\\n+    higherProbability = (mUserActivityCounter > NS_CC_SOFT_LIMIT_ACTIVE);\\n+  } else if (!strcmp(aTopic, \\\"xpcom-shutdown\\\")) {\\n+    nsCOMPtr<nsIObserverService> obs =\\n+      do_GetService(\\\"@mozilla.org/observer-service;1\\\");\\n+    if (obs) {\\n+      obs->RemoveObserver(this, \\\"user-interaction-active\\\");\\n+      obs->RemoveObserver(this, \\\"user-interaction-inactive\\\");\\n+      obs->RemoveObserver(this, \\\"xpcom-shutdown\\\");\\n+    }\\n+    return NS_OK;\\n+  }\\n+  nsJSContext::MaybeCC(higherProbability);\\n+  return NS_OK;\\n+}\\n+\\n /****************************************************************\\n  ************************** AutoFree ****************************\\n  ****************************************************************/\\n@@ -3220,6 +3307,50 @@ nsJSContext::PreserveWrapper(nsIXPConnectWrappedNative *aWrapper)\\n   return nsDOMClassInfo::PreserveNodeWrapper(aWrapper);\\n }\\n \\n+//static\\n+void\\n+nsJSContext::CC()\\n+{\\n+#ifdef DEBUG_smaug\\n+  printf(\\\"Will run cycle collector\\\\n\\\");\\n+#endif\\n+  sPreviousCCTime = PR_Now();\\n+  sDelayedCCollectCount = 0;\\n+  ++sCCollectCount;\\n+  // nsCycleCollector_collect() will run a ::JS_GC() indirectly, so\\n+  // we do not explicitly call ::JS_GC() here.\\n+  sPreviousCCDidCollect = nsCycleCollector_collect();\\n+#ifdef DEBUG_smaug\\n+  printf(\\\"%s\\\\n\\\", sPreviousCCDidCollect ?\\n+                   \\\"Cycle collector did collect nodes\\\" :\\n+                   \\\"Cycle collector did not collect nodes\\\");\\n+#endif\\n+}\\n+\\n+//static\\n+void\\n+nsJSContext::MaybeCC(PRBool aHigherProbability)\\n+{\\n+  ++sDelayedCCollectCount;\\n+  // Increase the probability also if the previous call to cycle collector\\n+  // collected something.\\n+  if (aHigherProbability || sPreviousCCDidCollect) {\\n+    sDelayedCCollectCount *= NS_PROBABILITY_MULTIPLIER;\\n+  }\\n+\\n+  if (!sGCTimer && (sDelayedCCollectCount > NS_MAX_DELAYED_CCOLLECT)) {\\n+    if ((PR_Now() - sPreviousCCTime) >=\\n+        PRTime(NS_MIN_CC_INTERVAL * PR_USEC_PER_MSEC)) {\\n+      nsJSContext::CC();\\n+    }\\n+#ifdef DEBUG_smaug\\n+    else {\\n+      printf(\\\"Running cycle collector was delayed: NS_MIN_CC_INTERVAL\\\\n\\\");\\n+    }\\n+#endif\\n+  }\\n+}\\n+\\n NS_IMETHODIMP\\n nsJSContext::Notify(nsITimer *timer)\\n {\\n@@ -3238,9 +3369,7 @@ nsJSContext::Notify(nsITimer *timer)\\n     // loading and move on as if they weren't.\\n     sPendingLoadCount = 0;\\n \\n-    // nsCycleCollector_collect() will run a ::JS_GC() indirectly,\\n-    // so we do not explicitly call ::JS_GC() here. \\n-    nsCycleCollector_collect();\\n+    nsJSContext::MaybeCC(PR_TRUE);\\n   } else {\\n     FireGCTimer(PR_TRUE);\\n   }\\n@@ -3273,9 +3402,7 @@ nsJSContext::LoadEnd()\\n     NS_RELEASE(sGCTimer);\\n     sLoadInProgressGCTimer = PR_FALSE;\\n \\n-    // nsCycleCollector_collect() will run a ::JS_GC() indirectly, so\\n-    // we do not explicitly call ::JS_GC() here.\\n-    nsCycleCollector_collect();\\n+    nsJSContext::MaybeCC(PR_TRUE);\\n   }\\n }\\n \\n@@ -3302,9 +3429,7 @@ nsJSContext::FireGCTimer(PRBool aLoadInProgress)\\n     // timer.\\n     sLoadInProgressGCTimer = PR_FALSE;\\n \\n-    // nsCycleCollector_collect() will run a ::JS_GC() indirectly, so\\n-    // we do not explicitly call ::JS_GC() here.\\n-    nsCycleCollector_collect();\\n+    nsJSContext::MaybeCC(PR_TRUE);\\n \\n     return;\\n   }\\n@@ -3413,6 +3538,10 @@ void\\n nsJSRuntime::Startup()\\n {\\n   // initialize all our statics, so that we can restart XPCOM\\n+  sDelayedCCollectCount = 0;\\n+  sCCollectCount = 0;\\n+  sPreviousCCTime = 0;\\n+  sPreviousCCDidCollect = PR_FALSE;\\n   sGCTimer = nsnull;\\n   sReadyForGC = PR_FALSE;\\n   sLoadInProgressGCTimer = PR_FALSE;\\n@@ -3547,6 +3676,15 @@ nsJSRuntime::Init()\\n   MaxScriptRunTimePrefChangedCallback(\\\"dom.max_chrome_script_run_time\\\",\\n                                       nsnull);\\n \\n+  nsCOMPtr<nsIObserverService> obs =\\n+    do_GetService(\\\"@mozilla.org/observer-service;1\\\", &rv);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+  nsIObserver* activityObserver = new nsUserActivityObserver();\\n+  NS_ENSURE_TRUE(activityObserver, NS_ERROR_OUT_OF_MEMORY);\\n+  obs->AddObserver(activityObserver, \\\"user-interaction-inactive\\\", PR_FALSE);\\n+  obs->AddObserver(activityObserver, \\\"user-interaction-active\\\", PR_FALSE);\\n+  obs->AddObserver(activityObserver, \\\"xpcom-shutdown\\\", PR_FALSE);\\n+\\n   rv = CallGetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &sSecurityManager);\\n \\n   sIsInitialized = NS_SUCCEEDED(rv);\\ndiff --git a/dom/src/base/nsJSEnvironment.h b/dom/src/base/nsJSEnvironment.h\\nindex 01d0187..2662e0f 100644\\n--- a/dom/src/base/nsJSEnvironment.h\\n+++ b/dom/src/base/nsJSEnvironment.h\\n@@ -170,6 +170,24 @@ public:\\n   static void LoadStart();\\n   static void LoadEnd();\\n \\n+  // CC does always call cycle collector and it also updates the counters\\n+  // that MaybeCC uses.\\n+  static void CC();\\n+\\n+  // MaybeCC calls cycle collector if certain conditions are fulfilled.\\n+  // The conditions are:\\n+  // - The timer related to page load (sGCTimer) must not be active.\\n+  // - At least NS_MIN_CC_INTERVAL milliseconds must have elapsed since the\\n+  //   previous cycle collector call.\\n+  // - Certain number of MaybeCC calls have occurred.\\n+  //   The number of needed MaybeCC calls depends on the aHigherProbability\\n+  //   parameter. If the parameter is true, probability for calling cycle\\n+  //   collector rises increasingly. If the parameter is all the time false,\\n+  //   at least NS_MAX_DELAYED_CCOLLECT MaybeCC calls are needed.\\n+  //   If the previous call to cycle collector did collect something,\\n+  //   MaybeCC works effectively as if aHigherProbability was true.\\n+  static void MaybeCC(PRBool aHigherProbability);\\n+\\n protected:\\n   nsresult InitializeExternalClasses();\\n   nsresult InitializeLiveConnectClasses(JSObject *aGlobalObj);\\ndiff --git a/dom/src/base/nsWindowRoot.cpp b/dom/src/base/nsWindowRoot.cpp\\nindex 3ffdd6b..aa30af0 100644\\n--- a/dom/src/base/nsWindowRoot.cpp\\n+++ b/dom/src/base/nsWindowRoot.cpp\\n@@ -54,10 +54,49 @@\\n #include \\\"nsString.h\\\"\\n #include \\\"nsEventDispatcher.h\\\"\\n #include \\\"nsIProgrammingLanguage.h\\\"\\n-\\n+#include \\\"nsIObserverService.h\\\"\\n+#include \\\"nsServiceManagerUtils.h\\\"\\n+#include \\\"nsITimer.h\\\"\\n #include \\\"nsCycleCollectionParticipant.h\\\"\\n \\n+#define NS_USER_INTERACTION_INTERVAL 5000 // ms\\n+\\n static NS_DEFINE_CID(kEventListenerManagerCID,    NS_EVENTLISTENERMANAGER_CID);\\n+static PRUint32 gMouseOrKeyboardEventCounter = 0;\\n+static PRUint32 gWindowRootCount = 0;\\n+static nsITimer* gUserInteractionTimer = nsnull;\\n+static nsITimerCallback* gUserInteractionTimerCallback = nsnull;\\n+\\n+class nsUITimerCallback : public nsITimerCallback\\n+{\\n+public:\\n+  nsUITimerCallback() : mPreviousCount(0) {}\\n+  NS_DECL_ISUPPORTS\\n+  NS_DECL_NSITIMERCALLBACK\\n+private:\\n+  PRUint32 mPreviousCount;\\n+};\\n+\\n+NS_IMPL_ISUPPORTS1(nsUITimerCallback, nsITimerCallback)\\n+\\n+// If aTimer is nsnull, this method always sends \\\"user-interaction-inactive\\\"\\n+// notification.\\n+NS_IMETHODIMP\\n+nsUITimerCallback::Notify(nsITimer* aTimer)\\n+{\\n+  nsresult rv;\\n+  nsCOMPtr<nsIObserverService> obs =\\n+      do_GetService(\\\"@mozilla.org/observer-service;1\\\", &rv);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+  if ((gMouseOrKeyboardEventCounter == mPreviousCount) || !aTimer) {\\n+    gMouseOrKeyboardEventCounter = 0;\\n+    obs->NotifyObservers(nsnull, \\\"user-interaction-inactive\\\", nsnull);\\n+  } else {\\n+    obs->NotifyObservers(nsnull, \\\"user-interaction-active\\\", nsnull);\\n+  }\\n+  mPreviousCount = gMouseOrKeyboardEventCounter;\\n+  return NS_OK;\\n+}\\n \\n nsWindowRoot::nsWindowRoot(nsIDOMWindow* aWindow)\\n {\\n@@ -71,6 +110,20 @@ nsWindowRoot::nsWindowRoot(nsIDOMWindow* aWindow)\\n   AddEventListener(NS_LITERAL_STRING(\\\"focus\\\"), focusListener, PR_TRUE);\\n   AddEventListener(NS_LITERAL_STRING(\\\"blur\\\"), focusListener, PR_TRUE);\\n   mRefCnt.decr(static_cast<nsIDOMEventTarget*>(this));\\n+\\n+  if (gWindowRootCount == 0) {\\n+    gUserInteractionTimerCallback = new nsUITimerCallback();\\n+    if (gUserInteractionTimerCallback) {\\n+      NS_ADDREF(gUserInteractionTimerCallback);\\n+      CallCreateInstance(\\\"@mozilla.org/timer;1\\\", &gUserInteractionTimer);\\n+      if (gUserInteractionTimer) {\\n+        gUserInteractionTimer->InitWithCallback(gUserInteractionTimerCallback,\\n+                                                NS_USER_INTERACTION_INTERVAL,\\n+                                                nsITimer::TYPE_REPEATING_SLACK);\\n+      }\\n+    }\\n+  }\\n+  ++gWindowRootCount;\\n }\\n \\n nsWindowRoot::~nsWindowRoot()\\n@@ -78,6 +131,18 @@ nsWindowRoot::~nsWindowRoot()\\n   if (mListenerManager) {\\n     mListenerManager->Disconnect();\\n   }\\n+\\n+  --gWindowRootCount;\\n+  if (gWindowRootCount == 0) {\\n+    if (gUserInteractionTimerCallback) {\\n+      gUserInteractionTimerCallback->Notify(nsnull);\\n+      NS_RELEASE(gUserInteractionTimerCallback);\\n+    }\\n+    if (gUserInteractionTimer) {\\n+      gUserInteractionTimer->Cancel();\\n+      NS_RELEASE(gUserInteractionTimer);\\n+    }\\n+  }\\n }\\n \\n NS_IMPL_CYCLE_COLLECTION_2(nsWindowRoot, mListenerManager, mFocusController)\\n@@ -247,6 +312,21 @@ nsWindowRoot::PreHandleEvent(nsEventChainPreVisitor& aVisitor)\\n   aVisitor.mForceContentDispatch = PR_TRUE; //FIXME! Bug 329119\\n   // To keep mWindow alive\\n   aVisitor.mItemData = mWindow;\\n+  if (NS_IS_TRUSTED_EVENT(aVisitor.mEvent) &&\\n+      ((aVisitor.mEvent->eventStructType == NS_MOUSE_EVENT  &&\\n+        static_cast<nsMouseEvent*>(aVisitor.mEvent)->reason ==\\n+          nsMouseEvent::eReal) ||\\n+       aVisitor.mEvent->eventStructType == NS_MOUSE_SCROLL_EVENT ||\\n+       aVisitor.mEvent->eventStructType == NS_KEY_EVENT)) {\\n+    if (gMouseOrKeyboardEventCounter == 0) {\\n+      nsCOMPtr<nsIObserverService> obs =\\n+        do_GetService(\\\"@mozilla.org/observer-service;1\\\");\\n+      if (obs) {\\n+        obs->NotifyObservers(nsnull, \\\"user-interaction-active\\\", nsnull);\\n+      }\\n+    }\\n+    ++gMouseOrKeyboardEventCounter;\\n+  }\\n   return NS_OK;\\n }\\n \\ndiff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp\\nindex 3bfbcea..b362041 100644\\n--- a/xpcom/base/nsCycleCollector.cpp\\n+++ b/xpcom/base/nsCycleCollector.cpp\\n@@ -869,7 +869,7 @@ struct nsCycleCollector\\n     PRBool Forget(nsISupports *n);\\n     void Allocated(void *n, size_t sz);\\n     void Freed(void *n);\\n-    void Collect(PRUint32 aTryCollections = 1);\\n+    PRBool Collect(PRUint32 aTryCollections = 1);\\n     void Shutdown();\\n \\n #ifdef DEBUG_CC\\n@@ -2021,9 +2021,10 @@ nsCycleCollector::Freed(void *n)\\n }\\n #endif\\n \\n-void\\n+PRBool\\n nsCycleCollector::Collect(PRUint32 aTryCollections)\\n {\\n+    PRBool didCollect = PR_FALSE;\\n #if defined(DEBUG_CC) && !defined(__MINGW32__)\\n     if (!mParams.mDoNothing && mParams.mHookMalloc)\\n         InitMemHook();\\n@@ -2031,7 +2032,7 @@ nsCycleCollector::Collect(PRUint32 aTryCollections)\\n \\n     // This can legitimately happen in a few cases. See bug 383651.\\n     if (mCollectionInProgress)\\n-        return;\\n+        return didCollect;\\n \\n #ifdef COLLECT_TIME_DEBUG\\n     printf(\\\"cc: Starting nsCycleCollector::Collect(%d)\\\\n\\\", aTryCollections);\\n@@ -2168,8 +2169,11 @@ nsCycleCollector::Collect(PRUint32 aTryCollections)\\n                 // mBuf.GetSize() == 0 check above), we should stop\\n                 // repeating collections if we didn't collect anything\\n                 // this time.\\n-                if (!collected)\\n+                if (!collected) {\\n                     aTryCollections = 0;\\n+                } else {\\n+                    didCollect = PR_TRUE;\\n+                }\\n             }\\n \\n #ifdef DEBUG_CC\\n@@ -2194,6 +2198,7 @@ nsCycleCollector::Collect(PRUint32 aTryCollections)\\n #ifdef DEBUG_CC\\n     ExplainLiveExpectedGarbage();\\n #endif\\n+    return didCollect;\\n }\\n \\n void\\n@@ -2594,11 +2599,10 @@ NS_CycleCollectorForget(nsISupports *n)\\n }\\n \\n \\n-void \\n+PRBool\\n nsCycleCollector_collect()\\n {\\n-    if (sCollector)\\n-        sCollector->Collect();\\n+    return sCollector ? sCollector->Collect() : PR_FALSE;\\n }\\n \\n nsresult \\ndiff --git a/xpcom/base/nsCycleCollector.h b/xpcom/base/nsCycleCollector.h\\nindex 0809ee6..ac8ceb5 100644\\n--- a/xpcom/base/nsCycleCollector.h\\n+++ b/xpcom/base/nsCycleCollector.h\\n@@ -66,7 +66,8 @@ struct nsCycleCollectionLanguageRuntime\\n NS_COM void nsCycleCollector_suspectCurrent(nsISupports *n);\\n // NS_COM PRBool nsCycleCollector_forget(nsISupports *n);\\n nsresult nsCycleCollector_startup();\\n-NS_COM void nsCycleCollector_collect();\\n+// Returns PR_TRUE if some nodes were collected.\\n+NS_COM PRBool nsCycleCollector_collect();\\n void nsCycleCollector_shutdown();\\n \\n #ifdef DEBUG\\n\""}