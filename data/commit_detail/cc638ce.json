{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bascc638ce\""},"diff":"\"cc638ce Make ExplainLiveExpectedGarbage print *all* references to JS objects with refcount imbalances.  b=387224  r=graydon  a=brendan\\ndiff --git a/js/src/xpconnect/src/nsXPConnect.cpp b/js/src/xpconnect/src/nsXPConnect.cpp\\nindex f65c6cd..bf536b3 100644\\n--- a/js/src/xpconnect/src/nsXPConnect.cpp\\n+++ b/js/src/xpconnect/src/nsXPConnect.cpp\\n@@ -621,6 +621,21 @@ nsXPConnect::Root(void *p)\\n     return NS_OK;\\n }\\n \\n+#ifdef DEBUG_CC\\n+void\\n+nsXPConnect::PrintAllReferencesTo(void *p)\\n+{\\n+#ifdef DEBUG\\n+    if(!mCycleCollectionContext) {\\n+        NS_NOTREACHED(\\\"no context\\\");\\n+        return;\\n+    }\\n+    JS_DumpHeap(*mCycleCollectionContext, stdout, nsnull, 0, p,\\n+                0x7fffffff, nsnull);\\n+#endif\\n+}\\n+#endif\\n+\\n NS_IMETHODIMP\\n nsXPConnect::Unlink(void *p)\\n {\\ndiff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h\\nindex e0519bb..728bb64 100644\\n--- a/js/src/xpconnect/src/xpcprivate.h\\n+++ b/js/src/xpconnect/src/xpcprivate.h\\n@@ -492,6 +492,9 @@ public:\\n     virtual nsresult BeginCycleCollection();\\n     virtual nsresult FinishCycleCollection();\\n     virtual nsCycleCollectionParticipant *ToParticipant(void *p);\\n+#ifdef DEBUG_CC\\n+    virtual void PrintAllReferencesTo(void *p);\\n+#endif\\n \\n     JSObjectRefcounts* GetJSObjectRefcounts() {return mObjRefcounts;}\\n #ifndef XPCONNECT_STANDALONE\\ndiff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp\\nindex 2ba67b8..9ba3b1f 100644\\n--- a/xpcom/base/nsCycleCollector.cpp\\n+++ b/xpcom/base/nsCycleCollector.cpp\\n@@ -444,6 +444,7 @@ struct PtrInfo\\n #ifdef DEBUG_CC\\n     size_t mBytes;\\n     char *mName;\\n+    PRUint32 mLangID;\\n \\n     // For finding roots in ExplainLiveExpectedGarbage (when there are\\n     // missing calls to suspect or failures to unlink).\\n@@ -454,7 +455,9 @@ struct PtrInfo\\n     ReversedEdge* mReversedEdges; // linked list\\n #endif\\n \\n-    PtrInfo(void *aPointer, nsCycleCollectionParticipant *aParticipant)\\n+    PtrInfo(void *aPointer, nsCycleCollectionParticipant *aParticipant\\n+            IF_DEBUG_CC_PARAM(PRUint32 aLangID)\\n+            )\\n         : mPointer(aPointer),\\n           mParticipant(aParticipant),\\n           mColor(grey),\\n@@ -466,6 +469,7 @@ struct PtrInfo\\n #ifdef DEBUG_CC\\n         , mBytes(0),\\n           mName(nsnull),\\n+          mLangID(aLangID),\\n           mSCCIndex(0),\\n           mReversedEdges(nsnull)\\n #endif\\n@@ -529,7 +533,9 @@ public:\\n             NS_ASSERTION(aPool.mBlocks == nsnull && aPool.mLast == nsnull,\\n                          \\\"pool not empty\\\");\\n         }\\n-        PtrInfo *Add(void *aPointer, nsCycleCollectionParticipant *aParticipant)\\n+        PtrInfo *Add(void *aPointer, nsCycleCollectionParticipant *aParticipant\\n+                     IF_DEBUG_CC_PARAM(PRUint32 aLangID)\\n+                    )\\n         {\\n             if (mNext == mBlockEnd) {\\n                 Block *block;\\n@@ -539,7 +545,9 @@ public:\\n                 mBlockEnd = block->mEntries + BlockSize;\\n                 mNextBlock = &block->mNext;\\n             }\\n-            return new (mNext++) PtrInfo(aPointer, aParticipant);\\n+            return new (mNext++) PtrInfo(aPointer, aParticipant\\n+                                         IF_DEBUG_CC_PARAM(aLangID)\\n+                                        );\\n         }\\n     private:\\n         Block **mNextBlock;\\n@@ -818,6 +826,10 @@ struct nsCycleCollectionXPCOMRuntime :\\n     }\\n \\n     inline nsCycleCollectionParticipant *ToParticipant(void *p);\\n+\\n+#ifdef DEBUG_CC\\n+    virtual void PrintAllReferencesTo(void *p) {}\\n+#endif\\n };\\n \\n struct nsCycleCollector\\n@@ -1104,7 +1116,17 @@ public:\\n \\n     PRUint32 Count() const { return mPtrToNodeMap.entryCount; }\\n \\n+#ifdef DEBUG_CC\\n+    PtrInfo* AddNode(void *s, nsCycleCollectionParticipant *aParticipant,\\n+                     PRUint32 aLangID);\\n+#else\\n     PtrInfo* AddNode(void *s, nsCycleCollectionParticipant *aParticipant);\\n+    PtrInfo* AddNode(void *s, nsCycleCollectionParticipant *aParticipant,\\n+                     PRUint32 aLangID)\\n+    {\\n+        AddNode(s, aParticipant);\\n+    }\\n+#endif\\n     void Traverse(PtrInfo* aPtrInfo);\\n \\n private:\\n@@ -1138,13 +1160,17 @@ GCGraphBuilder::~GCGraphBuilder()\\n }\\n \\n PtrInfo*\\n-GCGraphBuilder::AddNode(void *s, nsCycleCollectionParticipant *aParticipant)\\n+GCGraphBuilder::AddNode(void *s, nsCycleCollectionParticipant *aParticipant\\n+                        IF_DEBUG_CC_PARAM(PRUint32 aLangID)\\n+                       )\\n {\\n     PtrToNodeEntry *e = static_cast<PtrToNodeEntry*>(PL_DHashTableOperate(&mPtrToNodeMap, s, PL_DHASH_ADD));\\n     PtrInfo *result;\\n     if (!e->mNode) {\\n         // New entry.\\n-        result = mNodeBuilder.Add(s, aParticipant);\\n+        result = mNodeBuilder.Add(s, aParticipant\\n+                                  IF_DEBUG_CC_PARAM(aLangID)\\n+                                 );\\n         if (!result) {\\n             PL_DHashTableRawRemove(&mPtrToNodeMap, e);\\n             return nsnull;\\n@@ -1215,7 +1241,7 @@ GCGraphBuilder::NoteXPCOMChild(nsISupports *child)\\n     nsXPCOMCycleCollectionParticipant *cp;\\n     ToParticipant(child, &cp);\\n     if (cp) {\\n-        PtrInfo *childPi = AddNode(child, cp);\\n+        PtrInfo *childPi = AddNode(child, cp, nsIProgrammingLanguage::CPLUSPLUS);\\n         if (!childPi)\\n             return;\\n         mEdgeBuilder.Add(childPi);\\n@@ -1232,7 +1258,7 @@ GCGraphBuilder::NoteNativeChild(void *child,\\n \\n     NS_ASSERTION(participant, \\\"Need a nsCycleCollectionParticipant!\\\");\\n \\n-    PtrInfo *childPi = AddNode(child, participant);\\n+    PtrInfo *childPi = AddNode(child, participant, nsIProgrammingLanguage::CPLUSPLUS);\\n     if (!childPi)\\n         return;\\n     mEdgeBuilder.Add(childPi);\\n@@ -1254,7 +1280,7 @@ GCGraphBuilder::NoteScriptChild(PRUint32 langID, void *child)\\n     if (!cp)\\n         return;\\n \\n-    PtrInfo *childPi = AddNode(child, cp);\\n+    PtrInfo *childPi = AddNode(child, cp, langID);\\n     if (!childPi)\\n         return;\\n     mEdgeBuilder.Add(childPi);\\n@@ -1283,7 +1309,8 @@ nsCycleCollector::MarkRoots(GCGraph &graph)\\n         nsXPCOMCycleCollectionParticipant *cp;\\n         ToParticipant(s, &cp);\\n         if (cp) {\\n-            PtrInfo *pinfo = builder.AddNode(canonicalize(s), cp);\\n+            PtrInfo *pinfo = builder.AddNode(canonicalize(s), cp,\\n+                                             nsIProgrammingLanguage::CPLUSPLUS);\\n             if (pinfo)\\n                 pinfo->mWasPurple = PR_TRUE;\\n         }\\n@@ -2314,6 +2341,7 @@ nsCycleCollector::ExplainLiveExpectedGarbage()\\n                         printf(\\\"  %s %p\\\\n\\\",\\n                                e->mTarget->mName, e->mTarget->mPointer);\\n                     }\\n+                    mRuntimes[pi->mLangID]->PrintAllReferencesTo(pi->mPointer);\\n                 }\\n             }\\n \\ndiff --git a/xpcom/base/nsCycleCollector.h b/xpcom/base/nsCycleCollector.h\\nindex 7e70161..c125ee8 100644\\n--- a/xpcom/base/nsCycleCollector.h\\n+++ b/xpcom/base/nsCycleCollector.h\\n@@ -38,6 +38,10 @@\\n #ifndef nsCycleCollector_h__\\n #define nsCycleCollector_h__\\n \\n+// NOTE: If you use header files to define DEBUG_CC, you must do so here\\n+// *and* in nsCycleCollectionParticipant.h\\n+//#define DEBUG_CC\\n+\\n class nsISupports;\\n class nsCycleCollectionParticipant;\\n \\n@@ -49,6 +53,9 @@ struct nsCycleCollectionLanguageRuntime\\n     virtual nsresult BeginCycleCollection() = 0;\\n     virtual nsresult FinishCycleCollection() = 0;\\n     virtual nsCycleCollectionParticipant *ToParticipant(void *p) = 0;\\n+#ifdef DEBUG_CC\\n+    virtual void PrintAllReferencesTo(void *p) = 0;\\n+#endif\\n };\\n \\n // PRBool nsCycleCollector_suspect(nsISupports *n);\\ndiff --git a/xpcom/glue/nsCycleCollectionParticipant.h b/xpcom/glue/nsCycleCollectionParticipant.h\\nindex 8e05620..fdb54f2 100644\\n--- a/xpcom/glue/nsCycleCollectionParticipant.h\\n+++ b/xpcom/glue/nsCycleCollectionParticipant.h\\n@@ -40,6 +40,18 @@\\n \\n #include \\\"nsISupports.h\\\"\\n \\n+// NOTE: If you use header files to define DEBUG_CC, you must do so here\\n+// *and* in nsCycleCollector.h\\n+//#define DEBUG_CC\\n+\\n+#ifdef DEBUG_CC\\n+#define IF_DEBUG_CC_PARAM(_p) , _p\\n+#define IF_DEBUG_CC_ONLY_PARAM(_p) _p\\n+#else\\n+#define IF_DEBUG_CC_PARAM(_p)\\n+#define IF_DEBUG_CC_ONLY_PARAM(_p)\\n+#endif\\n+\\n #define NS_CYCLECOLLECTIONPARTICIPANT_IID                                      \\\\\\n {                                                                              \\\\\\n     0x9674489b,                                                                \\\\\\n\""}