{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas2b3259d\""},"diff":"\"2b3259d block document loads for URIs tagged as malware by the url-classifier service.  b=384941, r=bzbarsky, r=tony, sr=biesi, ui-r=johnath, a=bzbarsky\\ndiff --git a/browser/locales/en-US/chrome/overrides/appstrings.properties b/browser/locales/en-US/chrome/overrides/appstrings.properties\\nindex eafb720..357abe3 100644\\n--- a/browser/locales/en-US/chrome/overrides/appstrings.properties\\n+++ b/browser/locales/en-US/chrome/overrides/appstrings.properties\\n@@ -59,3 +59,4 @@ externalProtocolPrompt=An external application must be launched to handle %1$S:\\n externalProtocolUnknown=<Unknown>\\n externalProtocolChkMsg=Remember my choice for all links of this type.\\n externalProtocolLaunchBtn=Launch application\\n+malwareBlocked=The site at %S has been reported as an attack site and has been blocked based on your security preferences.\\ndiff --git a/docshell/base/Makefile.in b/docshell/base/Makefile.in\\nindex fd10746..cbe1589 100644\\n--- a/docshell/base/Makefile.in\\n+++ b/docshell/base/Makefile.in\\n@@ -113,6 +113,7 @@ XPIDLSRCS\\t= \\\\\\n \\t\\tnsIURIFixup.idl\\t\\t\\t\\\\\\n \\t\\tnsIEditorDocShell.idl\\t\\t\\\\\\n \\t\\tnsIWebPageDescriptor.idl\\t\\\\\\n+\\t\\tnsIURIClassifier.idl\\t\\t\\\\\\n \\t\\t$(NULL)\\n \\n EXPORTS\\t\\t= nsDocShellLoadTypes.h\\ndiff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp\\nindex cb0d16d..68536f5 100644\\n--- a/docshell/base/nsDocShell.cpp\\n+++ b/docshell/base/nsDocShell.cpp\\n@@ -58,6 +58,7 @@\\n #include \\\"nsIDocumentViewer.h\\\"\\n #include \\\"nsIDocumentLoaderFactory.h\\\"\\n #include \\\"nsCURILoader.h\\\"\\n+#include \\\"nsURILoader.h\\\"\\n #include \\\"nsDocShellCID.h\\\"\\n #include \\\"nsLayoutCID.h\\\"\\n #include \\\"nsDOMCID.h\\\"\\n@@ -105,6 +106,7 @@\\n #include \\\"nsIViewManager.h\\\"\\n #include \\\"nsIScrollableView.h\\\"\\n #include \\\"nsIScriptChannel.h\\\"\\n+#include \\\"nsIURIClassifier.h\\\"\\n \\n // we want to explore making the document own the load group\\n // so we can associate the document URI with the load group.\\n@@ -2840,6 +2842,7 @@ nsDocShell::DisplayLoadError(nsresult aError, nsIURI *aURI,\\n     PRUint32 formatStrCount = 0;\\n     nsresult rv = NS_OK;\\n     nsAutoString messageStr;\\n+    nsCAutoString cssClass;\\n \\n     // Turn the error code into a human readable error message.\\n     if (NS_ERROR_UNKNOWN_PROTOCOL == aError) {\\n@@ -2980,6 +2983,15 @@ nsDocShell::DisplayLoadError(nsresult aError, nsIURI *aURI,\\n             // Bad Content Encoding.\\n             error.AssignLiteral(\\\"contentEncodingError\\\");\\n             break;\\n+        case NS_ERROR_MALWARE_URI:\\n+            nsCAutoString host;\\n+            aURI->GetHost(host);\\n+            CopyUTF8toUTF16(host, formatStrs[0]);\\n+            formatStrCount = 1;\\n+\\n+            error.AssignLiteral(\\\"malwareBlocked\\\");\\n+            cssClass.AssignLiteral(\\\"blacklist\\\");\\n+            break;\\n         }\\n     }\\n \\n@@ -3021,7 +3033,7 @@ nsDocShell::DisplayLoadError(nsresult aError, nsIURI *aURI,\\n     if (mUseErrorPages && aURI && aFailedChannel) {\\n         // Display an error page\\n         LoadErrorPage(aURI, aURL, error.get(), messageStr.get(),\\n-                      aFailedChannel);\\n+                      cssClass.get(), aFailedChannel);\\n     } \\n     else\\n     {\\n@@ -3046,6 +3058,7 @@ NS_IMETHODIMP\\n nsDocShell::LoadErrorPage(nsIURI *aURI, const PRUnichar *aURL,\\n                           const PRUnichar *aErrorType,\\n                           const PRUnichar *aDescription,\\n+                          const char *aCSSClass,\\n                           nsIChannel* aFailedChannel)\\n {\\n #if defined(PR_LOGGING) && defined(DEBUG)\\n@@ -3110,12 +3123,17 @@ nsDocShell::LoadErrorPage(nsIURI *aURI, const PRUnichar *aURL,\\n     char *escapedCharset = nsEscape(charset.get(), url_Path);\\n     char *escapedError = nsEscape(NS_ConvertUTF16toUTF8(aErrorType).get(), url_Path);\\n     char *escapedDescription = nsEscape(NS_ConvertUTF16toUTF8(aDescription).get(), url_Path);\\n+    char *escapedCSSClass = nsEscape(aCSSClass, url_Path);\\n \\n     nsCString errorPageUrl(\\\"about:neterror?e=\\\");\\n \\n     errorPageUrl.AppendASCII(escapedError);\\n     errorPageUrl.AppendLiteral(\\\"&u=\\\");\\n     errorPageUrl.AppendASCII(escapedUrl);\\n+    if (escapedCSSClass && escapedCSSClass[0]) {\\n+        errorPageUrl.AppendASCII(\\\"&s=\\\");\\n+        errorPageUrl.AppendASCII(escapedCSSClass);\\n+    }\\n     errorPageUrl.AppendLiteral(\\\"&c=\\\");\\n     errorPageUrl.AppendASCII(escapedCharset);\\n     errorPageUrl.AppendLiteral(\\\"&d=\\\");\\n@@ -3125,6 +3143,7 @@ nsDocShell::LoadErrorPage(nsIURI *aURI, const PRUnichar *aURL,\\n     nsMemory::Free(escapedError);\\n     nsMemory::Free(escapedUrl);\\n     nsMemory::Free(escapedCharset);\\n+    nsMemory::Free(escapedCSSClass);\\n \\n     nsCOMPtr<nsIURI> errorPageURI;\\n     nsresult rv = NS_NewURI(getter_AddRefs(errorPageURI), errorPageUrl);\\n@@ -3222,6 +3241,11 @@ nsDocShell::Stop(PRUint32 aStopFlags)\\n             mRefreshURIList = nsnull;\\n         }\\n \\n+        if (mClassifier) {\\n+            mClassifier->Cancel();\\n+            mClassifier = nsnull;\\n+        }\\n+\\n         // XXXbz We could also pass |this| to nsIURILoader::Stop.  That will\\n         // just call Stop() on us as an nsIDocumentLoader... We need fewer\\n         // redundant apis!\\n@@ -4831,6 +4855,17 @@ nsDocShell::OnRedirectStateChange(nsIChannel* aOldChannel,\\n     if (!(aStateFlags & STATE_IS_DOCUMENT))\\n         return; // not a toplevel document\\n \\n+    // If this load is being checked by the URI classifier, we need to\\n+    // query the classifier again for the new URI.\\n+    if (mClassifier) {\\n+        mClassifier->SetChannel(aNewChannel);\\n+\\n+        // we call the nsClassifierCallback:Run() from the main loop to\\n+        // give the channel a chance to AsyncOpen() the channel before\\n+        // we suspend it.\\n+        NS_DispatchToCurrentThread(mClassifier);\\n+    }\\n+\\n     nsCOMPtr<nsIGlobalHistory3> history3(do_QueryInterface(mGlobalHistory));\\n     nsresult result = NS_ERROR_NOT_IMPLEMENTED;\\n     if (history3) {\\n@@ -4880,6 +4915,10 @@ nsDocShell::EndPageLoad(nsIWebProgress * aProgress,\\n     // during this load handler.\\n     //\\n     nsCOMPtr<nsIDocShell> kungFuDeathGrip(this);\\n+\\n+    // We're done with the URI classifier for this channel\\n+    mClassifier = nsnull;\\n+\\n     //\\n     // Notify the ContentViewer that the Document has finished loading...\\n     //\\n@@ -7244,8 +7283,34 @@ nsresult nsDocShell::DoChannelLoad(nsIChannel * aChannel,\\n     rv = aURILoader->OpenURI(aChannel,\\n                              (mLoadType == LOAD_LINK),\\n                              this);\\n-    \\n-    return rv;\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    rv = CheckClassifier(aChannel);\\n+    if (NS_FAILED(rv)) {\\n+        aChannel->Cancel(rv);\\n+        return rv;\\n+    }\\n+\\n+    return NS_OK;\\n+}\\n+\\n+nsresult\\n+nsDocShell::CheckClassifier(nsIChannel *aChannel)\\n+{\\n+    nsRefPtr<nsClassifierCallback> classifier = new nsClassifierCallback();\\n+    if (!classifier) return NS_ERROR_OUT_OF_MEMORY;\\n+\\n+    classifier->SetChannel(aChannel);\\n+    nsresult rv = classifier->Run();\\n+    if (rv == NS_ERROR_FACTORY_NOT_REGISTERED) {\\n+        // no URI classifier, ignore this\\n+        return NS_OK;\\n+    }\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    mClassifier = classifier;\\n+\\n+    return NS_OK;\\n }\\n \\n NS_IMETHODIMP\\n@@ -8992,4 +9057,126 @@ nsDocShell::IsAboutBlank(nsIURI* aURI)\\n     aURI->GetSpec(str);\\n     return str.EqualsLiteral(\\\"about:blank\\\");\\n }\\n-                                     \\n+\\n+//*****************************************************************************\\n+// nsClassifierCallback\\n+//*****************************************************************************\\n+\\n+NS_IMPL_THREADSAFE_ISUPPORTS2(nsClassifierCallback,\\n+                              nsIURIClassifierCallback,\\n+                              nsIRunnable)\\n+\\n+NS_IMETHODIMP\\n+nsClassifierCallback::Run()\\n+{\\n+    if (!mChannel) {\\n+        return NS_OK;\\n+    }\\n+\\n+    NS_ASSERTION(!mSuspendedChannel,\\n+                 \\\"nsClassifierCallback::Run() called while a \\\"\\n+                 \\\"channel is still suspended.\\\");\\n+\\n+    nsCOMPtr<nsIChannel> channel;\\n+    channel.swap(mChannel);\\n+\\n+    // Don't bother to run the classifier on a load that has already failed.\\n+    // (this might happen after a redirect)\\n+    PRUint32 status;\\n+    channel->GetStatus(&status);\\n+    if (NS_FAILED(status))\\n+        return NS_OK;\\n+\\n+    // Don't bother to run the classifier on a load that's coming from the\\n+    // cache and doesn't need validaton.\\n+    nsCOMPtr<nsICachingChannel> cachingChannel = do_QueryInterface(channel);\\n+    if (cachingChannel) {\\n+        PRBool fromCache;\\n+        if (NS_SUCCEEDED(cachingChannel->IsFromCache(&fromCache)) &&\\n+            fromCache) {\\n+            return NS_OK;\\n+        }\\n+    }\\n+\\n+    nsCOMPtr<nsIURI> uri;\\n+    nsresult rv = channel->GetURI(getter_AddRefs(uri));\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    // Don't bother checking certain types of URIs.\\n+    PRBool hasFlags;\\n+    rv = NS_URIChainHasFlags(uri,\\n+                             nsIProtocolHandler::URI_DANGEROUS_TO_LOAD,\\n+                             &hasFlags);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    if (hasFlags) return NS_OK;\\n+\\n+    rv = NS_URIChainHasFlags(uri,\\n+                             nsIProtocolHandler::URI_IS_LOCAL_FILE,\\n+                             &hasFlags);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    if (hasFlags) return NS_OK;\\n+\\n+    rv = NS_URIChainHasFlags(uri,\\n+                             nsIProtocolHandler::URI_IS_UI_RESOURCE,\\n+                             &hasFlags);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    if (hasFlags) return NS_OK;\\n+\\n+    nsCOMPtr<nsIURIClassifier> uriClassifier =\\n+        do_GetService(NS_URICLASSIFIERSERVICE_CONTRACTID, &rv);\\n+    if (NS_FAILED(rv)) return rv;\\n+\\n+    PRBool expectCallback;\\n+    rv = uriClassifier->Classify(uri, this, &expectCallback);\\n+    if (NS_FAILED(rv)) return rv;\\n+\\n+    if (expectCallback) {\\n+        // Suspend the channel, it will be resumed when we get the classifier\\n+        // callback.\\n+        rv = channel->Suspend();\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+        mSuspendedChannel = channel;\\n+\\n+        PR_LOG(gDocShellLog, PR_LOG_DEBUG,\\n+               (\\\"nsClassifierCallback[%p]: suspended channel %p\\\",\\n+                this, mSuspendedChannel.get()));\\n+    }\\n+\\n+    return NS_OK;\\n+}\\n+\\n+NS_IMETHODIMP\\n+nsClassifierCallback::OnClassifyComplete(nsresult aErrorCode)\\n+{\\n+    if (mSuspendedChannel) {\\n+        if (NS_FAILED(aErrorCode)) {\\n+            PR_LOG(gDocShellLog, PR_LOG_DEBUG,\\n+                   (\\\"nsClassifierCallback[%p]: cancelling channel %p with error code: %d\\\",\\n+                    this, mSuspendedChannel.get(), aErrorCode));\\n+            mSuspendedChannel->Cancel(aErrorCode);\\n+        }\\n+        PR_LOG(gDocShellLog, PR_LOG_DEBUG,\\n+               (\\\"nsClassifierCallback[%p]: resuming channel %p from OnClassifyComplete\\\",\\n+                this, mSuspendedChannel.get()));\\n+        mSuspendedChannel->Resume();\\n+        mSuspendedChannel = nsnull;\\n+    }\\n+\\n+    return NS_OK;\\n+}\\n+\\n+void\\n+nsClassifierCallback::Cancel()\\n+{\\n+    if (mSuspendedChannel) {\\n+        PR_LOG(gDocShellLog, PR_LOG_DEBUG,\\n+               (\\\"nsClassifierCallback[%p]: resuming channel %p from Cancel()\\\",\\n+                this, mSuspendedChannel.get()));\\n+        mSuspendedChannel->Resume();\\n+        mSuspendedChannel = nsnull;\\n+    }\\n+\\n+    if (mChannel) {\\n+        mChannel = nsnull;\\n+    }\\n+}\\ndiff --git a/docshell/base/nsDocShell.h b/docshell/base/nsDocShell.h\\nindex 2e3dcce..e44a8de 100644\\n--- a/docshell/base/nsDocShell.h\\n+++ b/docshell/base/nsDocShell.h\\n@@ -105,6 +105,7 @@\\n #include \\\"nsIObserver.h\\\"\\n #include \\\"nsDocShellLoadTypes.h\\\"\\n #include \\\"nsPIDOMEventTarget.h\\\"\\n+#include \\\"nsIURIClassifier.h\\\"\\n \\n class nsIScrollableView;\\n \\n@@ -141,6 +142,26 @@ protected:\\n     virtual ~nsRefreshTimer();\\n };\\n \\n+class nsClassifierCallback : public nsIURIClassifierCallback\\n+                           , public nsIRunnable\\n+{\\n+public:\\n+    nsClassifierCallback() {}\\n+    ~nsClassifierCallback() {}\\n+\\n+    NS_DECL_ISUPPORTS\\n+    NS_DECL_NSIURICLASSIFIERCALLBACK\\n+    NS_DECL_NSIRUNNABLE\\n+\\n+    void SetChannel(nsIChannel * aChannel)\\n+        { mChannel = aChannel; }\\n+\\n+    void Cancel();\\n+private:\\n+    nsCOMPtr<nsIChannel> mChannel;\\n+    nsCOMPtr<nsIChannel> mSuspendedChannel;\\n+};\\n+\\n //*****************************************************************************\\n //***    nsDocShell\\n //*****************************************************************************\\n@@ -260,6 +281,12 @@ protected:\\n                                   nsIChannel * aChannel);\\n     virtual nsresult DoChannelLoad(nsIChannel * aChannel,\\n                                    nsIURILoader * aURILoader);\\n+\\n+    // Check the channel load against the URI classifier service (if it\\n+    // exists).  The channel will be suspended until the classification is\\n+    // complete.\\n+    nsresult CheckClassifier(nsIChannel *aChannel);\\n+\\n     NS_IMETHOD ScrollIfAnchor(nsIURI * aURI, PRBool * aWasAnchor,\\n                               PRUint32 aLoadType, nscoord *cx, nscoord *cy);\\n \\n@@ -379,6 +406,7 @@ protected:\\n     NS_IMETHOD LoadErrorPage(nsIURI *aURI, const PRUnichar *aURL,\\n                              const PRUnichar *aPage,\\n                              const PRUnichar *aDescription,\\n+                             const char *aCSSClass,\\n                              nsIChannel* aFailedChannel);\\n     PRBool IsNavigationAllowed(PRBool aDisplayPrintErrorDialog = PR_TRUE);\\n     PRBool IsPrintingOrPP(PRBool aDisplayErrorDialog = PR_TRUE);\\n@@ -612,6 +640,9 @@ protected:\\n     // Secure browser UI object\\n     nsCOMPtr<nsISecureBrowserUI> mSecurityUI;\\n \\n+    // Suspends/resumes channels based on the URI classifier.\\n+    nsRefPtr<nsClassifierCallback> mClassifier;\\n+\\n     // WEAK REFERENCES BELOW HERE.\\n     // Note these are intentionally not addrefd.  Doing so will create a cycle.\\n     // For that reasons don't use nsCOMPtr.\\ndiff --git a/docshell/base/nsIURIClassifier.idl b/docshell/base/nsIURIClassifier.idl\\nnew file mode 100644\\nindex 0000000..04c07bf\\n--- /dev/null\\n+++ b/docshell/base/nsIURIClassifier.idl\\n@@ -0,0 +1,85 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is mozilla.org code.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Mozilla Corporation.\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *   Dave Camp <dcamp@mozilla.com>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+\\n+#include \\\"nsISupports.idl\\\"\\n+\\n+interface nsIURI;\\n+interface nsIChannel;\\n+\\n+/**\\n+ * Callback function for nsIURIClassifier lookups.\\n+ */\\n+[scriptable, function, uuid(8face46e-0c96-470f-af40-0037dcd797bd)]\\n+interface nsIURIClassifierCallback : nsISupports\\n+{\\n+  /**\\n+   * Called by the URI classifier service when it is done checking a URI.\\n+   *\\n+   * Clients are responsible for associating callback objects with classify()\\n+   * calls.\\n+   *\\n+   * @param aErrorCode\\n+   *        The error code with which the channel should be cancelled, or\\n+   *        NS_OK if the load should continue normally.\\n+   */\\n+  void onClassifyComplete(in nsresult aErrorCode);\\n+};\\n+\\n+/**\\n+ * The URI classifier service checks a URI against lists of phishing\\n+ * and malware sites.\\n+ */\\n+[scriptable, uuid(2de5c563-1203-43dd-a212-f5d56d530b6f)]\\n+interface nsIURIClassifier : nsISupports\\n+{\\n+  /**\\n+   * Classify a URI.\\n+   *\\n+   * @param aURI\\n+   *        The URI that should be checked by the URI classifier.\\n+   * @param aCallback\\n+   *        The URI classifier will call this callback when the URI has been\\n+   *        classified.\\n+   *\\n+   * @return <code>false</code> if classification is not necessary.  The\\n+   *         callback will not be called.\\n+   *         <code>true</code> if classification will be performed.  The\\n+   *         callback will be called.\\n+   */\\n+  boolean classify(in nsIURI aURI,\\n+                   in nsIURIClassifierCallback aCallback);\\n+};\\ndiff --git a/docshell/base/nsWebShell.cpp b/docshell/base/nsWebShell.cpp\\nindex 883b11b..35c2eca 100644\\n--- a/docshell/base/nsWebShell.cpp\\n+++ b/docshell/base/nsWebShell.cpp\\n@@ -85,6 +85,7 @@\\n #include \\\"nsIDocShellTreeNode.h\\\"\\n #include \\\"nsIDocShellTreeOwner.h\\\"\\n #include \\\"nsCURILoader.h\\\"\\n+#include \\\"nsURILoader.h\\\"\\n #include \\\"nsIDOMWindowInternal.h\\\"\\n #include \\\"nsEscape.h\\\"\\n #include \\\"nsIPlatformCharset.h\\\"\\n@@ -124,6 +125,8 @@\\n #include \\\"nsIScriptSecurityManager.h\\\"\\n #include \\\"nsContentPolicyUtils.h\\\"\\n \\n+#include \\\"nsIURIClassifier.h\\\"\\n+\\n #ifdef NS_DEBUG\\n /**\\n  * Note: the log module is created during initialization which\\n@@ -1191,6 +1194,7 @@ nsresult nsWebShell::EndPageLoad(nsIWebProgress *aProgress,\\n              aStatus == NS_ERROR_UNKNOWN_SOCKET_TYPE ||\\n              aStatus == NS_ERROR_NET_INTERRUPT ||\\n              aStatus == NS_ERROR_NET_RESET ||\\n+             aStatus == NS_ERROR_MALWARE_URI ||\\n              NS_ERROR_GET_MODULE(aStatus) == NS_ERROR_MODULE_SECURITY) {\\n       DisplayLoadError(aStatus, url, nsnull, channel);\\n     }\\ndiff --git a/docshell/build/nsDocShellCID.h b/docshell/build/nsDocShellCID.h\\nindex 48e4c87..4dd040e 100644\\n--- a/docshell/build/nsDocShellCID.h\\n+++ b/docshell/build/nsDocShellCID.h\\n@@ -50,6 +50,12 @@\\n     \\\"@mozilla.org/webnavigation-info;1\\\"\\n \\n /**\\n+ * Contract ID for a service implementing nsIURIClassifier that identifies\\n+ * phishing and malware sites.\\n+ */\\n+#define NS_URICLASSIFIERSERVICE_CONTRACTID \\\"@mozilla.org/uriclassifierservice\\\"\\n+\\n+/**\\n  * An observer service topic that can be listened to to catch creation\\n  * of content browsing areas (both toplevel ones and subframes).  The\\n  * subject of the notification will be the nsIWebNavigation being\\ndiff --git a/docshell/resources/content/netError.xhtml b/docshell/resources/content/netError.xhtml\\nindex 5bce039..886410e 100644\\n--- a/docshell/resources/content/netError.xhtml\\n+++ b/docshell/resources/content/netError.xhtml\\n@@ -67,7 +67,7 @@\\n       // or optionally, to specify an alternate CSS class to allow for\\n       // custom styling and favicon:\\n       //\\n-      //   moz-neterror:page?c=classname&e=error&u=url&d=desc\\n+      //   moz-neterror:page?e=error&u=url&s=classname&d=desc\\n \\n       // Note that this file uses document.documentURI to get\\n       // the URL (with the format from above). This is because\\n@@ -86,14 +86,13 @@\\n       function getCSSClass()\\n       {\\n         var url = document.documentURI;\\n-        var classParam = url.search(/c\\\\=/);\\n-        \\n-        // c is optional, if classParam == -1 just return nothing\\n-        if (classParam == -1)\\n+        var matches = url.match(/s\\\\=([^&]+)\\\\&/);\\n+        // s is optional, if no match just return nothing\\n+        if (!matches || matches.length < 2)\\n           return \\\"\\\";\\n-          \\n-        var rest = url.search(/\\\\&/);\\n-        return decodeURIComponent(url.slice(classParam + 2, rest));\\n+\\n+        // parenthetical match is the second entry\\n+        return decodeURIComponent(matches[1]);\\n       }\\n \\n       function getDescription()\\ndiff --git a/dom/locales/en-US/chrome/appstrings.properties b/dom/locales/en-US/chrome/appstrings.properties\\nindex 673456c..b31d455 100644\\n--- a/dom/locales/en-US/chrome/appstrings.properties\\n+++ b/dom/locales/en-US/chrome/appstrings.properties\\n@@ -59,3 +59,4 @@ externalProtocolPrompt=An external application must be launched to handle %1$S:\\n externalProtocolUnknown=<Unknown>\\n externalProtocolChkMsg=Remember my choice for all links of this type.\\n externalProtocolLaunchBtn=Launch application\\n+malwareBlocked=The site at %S has been reported as an attack site and has been blocked based on your security preferences.\\ndiff --git a/toolkit/components/build/nsToolkitCompsModule.cpp b/toolkit/components/build/nsToolkitCompsModule.cpp\\nindex 869789e..4da2431 100644\\n--- a/toolkit/components/build/nsToolkitCompsModule.cpp\\n+++ b/toolkit/components/build/nsToolkitCompsModule.cpp\\n@@ -58,6 +58,7 @@\\n #include \\\"nsUrlClassifierDBService.h\\\"\\n #include \\\"nsUrlClassifierStreamUpdater.h\\\"\\n #include \\\"nsUrlClassifierUtils.h\\\"\\n+#include \\\"nsDocShellCID.h\\\"\\n #endif\\n \\n #ifdef MOZ_FEEDS\\n@@ -137,6 +138,10 @@ static const nsModuleComponentInfo components[] =\\n     NS_URLCLASSIFIERDBSERVICE_CID,\\n     NS_URLCLASSIFIERDBSERVICE_CONTRACTID,\\n     nsUrlClassifierDBServiceConstructor },\\n+  { \\\"Url Classifier DB Service\\\",\\n+    NS_URLCLASSIFIERDBSERVICE_CID,\\n+    NS_URICLASSIFIERSERVICE_CONTRACTID,\\n+    nsUrlClassifierDBServiceConstructor },\\n   { \\\"Url Classifier Stream Updater\\\",\\n     NS_URLCLASSIFIERSTREAMUPDATER_CID,\\n     NS_URLCLASSIFIERSTREAMUPDATER_CONTRACTID,\\ndiff --git a/toolkit/components/url-classifier/src/Makefile.in b/toolkit/components/url-classifier/src/Makefile.in\\nindex 8a8bb1f..c6303b6 100644\\n--- a/toolkit/components/url-classifier/src/Makefile.in\\n+++ b/toolkit/components/url-classifier/src/Makefile.in\\n@@ -12,9 +12,11 @@ LIBXUL_LIBRARY = 1\\n FORCE_STATIC_LIB = 1\\n \\n \\n-REQUIRES = necko \\\\\\n+REQUIRES = docshell \\\\\\n+           necko \\\\\\n            storage \\\\\\n            string \\\\\\n+           uriloader \\\\\\n            xpcom \\\\\\n            $(ZLIB_REQUIRES) \\\\\\n            $(NULL)\\ndiff --git a/toolkit/components/url-classifier/src/nsUrlClassifierDBService.cpp b/toolkit/components/url-classifier/src/nsUrlClassifierDBService.cpp\\nindex ff189cf..4bc2318 100644\\n--- a/toolkit/components/url-classifier/src/nsUrlClassifierDBService.cpp\\n+++ b/toolkit/components/url-classifier/src/nsUrlClassifierDBService.cpp\\n@@ -38,6 +38,7 @@\\n  *\\n  * ***** END LICENSE BLOCK ***** */\\n \\n+#include \\\"nsAutoPtr.h\\\"\\n #include \\\"nsCOMPtr.h\\\"\\n #include \\\"mozIStorageService.h\\\"\\n #include \\\"mozIStorageConnection.h\\\"\\n@@ -50,11 +51,15 @@\\n #include \\\"nsICryptoHash.h\\\"\\n #include \\\"nsIDirectoryService.h\\\"\\n #include \\\"nsIObserverService.h\\\"\\n+#include \\\"nsIPrefBranch.h\\\"\\n+#include \\\"nsIPrefBranch2.h\\\"\\n+#include \\\"nsIPrefService.h\\\"\\n #include \\\"nsIProperties.h\\\"\\n #include \\\"nsIProxyObjectManager.h\\\"\\n #include \\\"nsToolkitCompsCID.h\\\"\\n #include \\\"nsIUrlClassifierUtils.h\\\"\\n #include \\\"nsUrlClassifierDBService.h\\\"\\n+#include \\\"nsURILoader.h\\\"\\n #include \\\"nsString.h\\\"\\n #include \\\"nsTArray.h\\\"\\n #include \\\"nsVoidArray.h\\\"\\n@@ -119,6 +124,10 @@ static const PRLogModuleInfo *gUrlClassifierDbServiceLog = nsnull;\\n \\n #define KEY_LENGTH 16\\n \\n+// Prefs for implementing nsIURIClassifier to block page loads\\n+#define CHECK_MALWARE_PREF      \\\"browser.safebrowsing.malware.enabled\\\"\\n+#define CHECK_MALWARE_DEFAULT   PR_FALSE\\n+\\n // Singleton instance.\\n static nsUrlClassifierDBService* sUrlClassifierDBService;\\n \\n@@ -2029,10 +2038,54 @@ nsUrlClassifierDBServiceWorker::MaybeCreateTables(mozIStorageConnection* connect\\n }\\n \\n // -------------------------------------------------------------------------\\n+// Helper class for nsIURIClassifier implementation, translates table names\\n+// to nsIURIClassifier enums.\\n+\\n+class nsUrlClassifierClassifyCallback : public nsIUrlClassifierCallback\\n+{\\n+public:\\n+  NS_DECL_ISUPPORTS\\n+  NS_DECL_NSIURLCLASSIFIERCALLBACK\\n+\\n+  nsUrlClassifierClassifyCallback(nsIURIClassifierCallback *c)\\n+    : mCallback(c)\\n+    {}\\n+\\n+private:\\n+  nsCOMPtr<nsIURIClassifierCallback> mCallback;\\n+};\\n+\\n+NS_IMPL_THREADSAFE_ISUPPORTS1(nsUrlClassifierClassifyCallback,\\n+                              nsIUrlClassifierCallback);\\n+\\n+NS_IMETHODIMP\\n+nsUrlClassifierClassifyCallback::HandleEvent(const nsACString& tables)\\n+{\\n+  // XXX: we should probably have the wardens tell the service which table\\n+  // names match with which classification.  For now the table names give\\n+  // enough information.\\n+  nsresult response = NS_OK;\\n+\\n+  nsACString::const_iterator begin, end;\\n+\\n+  tables.BeginReading(begin);\\n+  tables.EndReading(end);\\n+  if (FindInReadable(NS_LITERAL_CSTRING(\\\"-malware-\\\"), begin, end)) {\\n+    response = NS_ERROR_MALWARE_URI;\\n+  }\\n+\\n+  mCallback->OnClassifyComplete(response);\\n+\\n+  return NS_OK;\\n+}\\n+\\n+\\n+// -------------------------------------------------------------------------\\n // Proxy class implementation\\n \\n-NS_IMPL_THREADSAFE_ISUPPORTS2(nsUrlClassifierDBService,\\n+NS_IMPL_THREADSAFE_ISUPPORTS3(nsUrlClassifierDBService,\\n                               nsIUrlClassifierDBService,\\n+                              nsIURIClassifier,\\n                               nsIObserver)\\n \\n /* static */ nsUrlClassifierDBService*\\n@@ -2058,6 +2111,7 @@ nsUrlClassifierDBService::GetInstance()\\n \\n \\n nsUrlClassifierDBService::nsUrlClassifierDBService()\\n+ : mCheckMalware(CHECK_MALWARE_DEFAULT)\\n {\\n }\\n \\n@@ -2088,6 +2142,17 @@ nsUrlClassifierDBService::Init()\\n     do_CreateInstance(NS_CRYPTO_HASH_CONTRACTID, &rv);\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n+  // Should we check document loads for malware URIs?\\n+  nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);\\n+\\n+  if (prefs) {\\n+    PRBool tmpbool;\\n+    rv = prefs->GetBoolPref(CHECK_MALWARE_PREF, &tmpbool);\\n+    mCheckMalware = NS_SUCCEEDED(rv) ? tmpbool : CHECK_MALWARE_DEFAULT;\\n+\\n+    prefs->AddObserver(CHECK_MALWARE_PREF, this, PR_FALSE);\\n+  }\\n+\\n   // Start the background thread.\\n   rv = NS_NewThread(&gDbBackgroundThread);\\n   if (NS_FAILED(rv))\\n@@ -2115,7 +2180,27 @@ nsUrlClassifierDBService::Init()\\n   return NS_OK;\\n }\\n \\n-nsresult\\n+NS_IMETHODIMP\\n+nsUrlClassifierDBService::Classify(nsIURI *uri,\\n+                                   nsIURIClassifierCallback* c,\\n+                                   PRBool* result)\\n+{\\n+  NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);\\n+\\n+  if (!mCheckMalware) {\\n+    *result = PR_FALSE;\\n+    return NS_OK;\\n+  }\\n+\\n+  nsRefPtr<nsUrlClassifierClassifyCallback> callback =\\n+    new nsUrlClassifierClassifyCallback(c);\\n+  if (!callback) return NS_ERROR_OUT_OF_MEMORY;\\n+\\n+  *result = PR_TRUE;\\n+  return LookupURI(uri, callback, PR_TRUE);\\n+}\\n+\\n+NS_IMETHODIMP\\n nsUrlClassifierDBService::Lookup(const nsACString& spec,\\n                                  nsIUrlClassifierCallback* c,\\n                                  PRBool needsProxy)\\n@@ -2132,11 +2217,21 @@ nsUrlClassifierDBService::Lookup(const nsACString& spec,\\n     return NS_ERROR_FAILURE;\\n   }\\n \\n+  return LookupURI(uri, c, needsProxy);\\n+}\\n+\\n+nsresult\\n+nsUrlClassifierDBService::LookupURI(nsIURI* uri,\\n+                                    nsIUrlClassifierCallback* c,\\n+                                    PRBool needsProxy)\\n+{\\n+  NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);\\n+\\n   nsCAutoString key;\\n   // Canonicalize the url\\n   nsCOMPtr<nsIUrlClassifierUtils> utilsService =\\n     do_GetService(NS_URLCLASSIFIERUTILS_CONTRACTID);\\n-  rv = utilsService->GetKeyForURI(uri, key);\\n+  nsresult rv = utilsService->GetKeyForURI(uri, key);\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n   nsCOMPtr<nsIUrlClassifierCallback> proxyCallback;\\n@@ -2278,11 +2373,21 @@ NS_IMETHODIMP\\n nsUrlClassifierDBService::Observe(nsISupports *aSubject, const char *aTopic,\\n                                   const PRUnichar *aData)\\n {\\n-  NS_ASSERTION(strcmp(aTopic, \\\"profile-before-change\\\") == 0 ||\\n-               strcmp(aTopic, \\\"xpcom-shutdown-threads\\\") == 0,\\n-               \\\"Unexpected observer topic\\\");\\n-\\n-  Shutdown();\\n+  if (!strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID)) {\\n+    nsresult rv;\\n+    nsCOMPtr<nsIPrefBranch> prefs(do_QueryInterface(aSubject, &rv));\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    if (NS_LITERAL_STRING(CHECK_MALWARE_PREF).Equals(aData)) {\\n+      PRBool tmpbool;\\n+      rv = prefs->GetBoolPref(CHECK_MALWARE_PREF, &tmpbool);\\n+      mCheckMalware = NS_SUCCEEDED(rv) ? tmpbool : CHECK_MALWARE_DEFAULT;\\n+    }\\n+  } else if (!strcmp(aTopic, \\\"profile-before-change\\\") ||\\n+             !strcmp(aTopic, \\\"xpcom-shutdown-threads\\\")) {\\n+    Shutdown();\\n+  } else {\\n+    return NS_ERROR_UNEXPECTED;\\n+  }\\n \\n   return NS_OK;\\n }\\n@@ -2296,6 +2401,11 @@ nsUrlClassifierDBService::Shutdown()\\n   if (!gDbBackgroundThread)\\n     return NS_OK;\\n \\n+  nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);\\n+  if (prefs) {\\n+    prefs->RemoveObserver(CHECK_MALWARE_PREF, this);\\n+  }\\n+\\n   nsresult rv;\\n   // First close the db connection.\\n   if (mWorker) {\\ndiff --git a/toolkit/components/url-classifier/src/nsUrlClassifierDBService.h b/toolkit/components/url-classifier/src/nsUrlClassifierDBService.h\\nindex 9c9ab05..2c449ae 100644\\n--- a/toolkit/components/url-classifier/src/nsUrlClassifierDBService.h\\n+++ b/toolkit/components/url-classifier/src/nsUrlClassifierDBService.h\\n@@ -45,12 +45,14 @@\\n #include \\\"nsID.h\\\"\\n #include \\\"nsIObserver.h\\\"\\n #include \\\"nsIUrlClassifierDBService.h\\\"\\n+#include \\\"nsIURIClassifier.h\\\"\\n \\n class nsUrlClassifierDBServiceWorker;\\n \\n // This is a proxy class that just creates a background thread and delagates\\n // calls to the background thread.\\n class nsUrlClassifierDBService : public nsIUrlClassifierDBService,\\n+                                 public nsIURIClassifier,\\n                                  public nsIObserver\\n {\\n public:\\n@@ -69,12 +71,17 @@ public:\\n \\n   NS_DECL_ISUPPORTS\\n   NS_DECL_NSIURLCLASSIFIERDBSERVICE\\n+  NS_DECL_NSIURICLASSIFIER\\n   NS_DECL_NSIOBSERVER\\n \\n private:\\n   // No subclassing\\n   ~nsUrlClassifierDBService();\\n \\n+  nsresult LookupURI(nsIURI* uri,\\n+                     nsIUrlClassifierCallback* c,\\n+                     PRBool needsProxy);\\n+\\n   // Disallow copy constructor\\n   nsUrlClassifierDBService(nsUrlClassifierDBService&);\\n \\n@@ -85,6 +92,10 @@ private:\\n   nsresult Shutdown();\\n   \\n   nsCOMPtr<nsUrlClassifierDBServiceWorker> mWorker;\\n+\\n+  // TRUE if the nsURIClassifier implementation should check for malware\\n+  // uris on document loads.\\n+  PRBool mCheckMalware;\\n };\\n \\n NS_DEFINE_STATIC_IID_ACCESSOR(nsUrlClassifierDBService, NS_URLCLASSIFIERDBSERVICE_CID)\\ndiff --git a/uriloader/base/nsURILoader.h b/uriloader/base/nsURILoader.h\\nindex 3a8237e..854d364 100644\\n--- a/uriloader/base/nsURILoader.h\\n+++ b/uriloader/base/nsURILoader.h\\n@@ -92,4 +92,10 @@ protected:\\n   friend class nsDocumentOpenInfo;\\n };\\n \\n+/**\\n+ * The load has been cancelled because it was found on a malware blacklist.\\n+ * XXX: this belongs in an nsDocShellErrors.h file of some sort.\\n+ */\\n+#define NS_ERROR_MALWARE_URI   NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_URILOADER, 30)\\n+\\n #endif /* nsURILoader_h__ */\\n\""}