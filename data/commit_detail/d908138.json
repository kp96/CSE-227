{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basd908138\""},"diff":"\"d908138 Fix for bug 393357 (nsDocument::mRadioGroups leaks its members). Patch by sharparrow1@yahoo.com, r/sr=bz, a=sicking.\\ndiff --git a/content/base/src/nsDocument.cpp b/content/base/src/nsDocument.cpp\\nindex 09861f0..c5888a8 100644\\n--- a/content/base/src/nsDocument.cpp\\n+++ b/content/base/src/nsDocument.cpp\\n@@ -315,7 +315,7 @@ struct nsRadioGroupStruct\\n    * A strong pointer to the currently selected radio button.\\n    */\\n   nsCOMPtr<nsIDOMHTMLInputElement> mSelectedRadioButton;\\n-  nsSmallVoidArray mRadioButtons;\\n+  nsCOMArray<nsIFormControl> mRadioButtons;\\n };\\n \\n \\n@@ -945,23 +945,20 @@ SubDocTraverser(PLDHashTable *table, PLDHashEntryHdr *hdr, PRUint32 number,\\n   return PL_DHASH_NEXT;\\n }\\n \\n-PR_STATIC_CALLBACK(PRIntn)\\n-RadioGroupsTraverser(nsHashKey *aKey, void *aData, void* aClosure)\\n+PR_STATIC_CALLBACK(PLDHashOperator)\\n+RadioGroupsTraverser(const nsAString& aKey, nsAutoPtr<nsRadioGroupStruct>& aData, void* aClosure)\\n {\\n-  nsRadioGroupStruct *entry = static_cast<nsRadioGroupStruct*>(aData);\\n   nsCycleCollectionTraversalCallback *cb = \\n     static_cast<nsCycleCollectionTraversalCallback*>(aClosure);\\n \\n-  cb->NoteXPCOMChild(entry->mSelectedRadioButton);\\n+  cb->NoteXPCOMChild(aData->mSelectedRadioButton);\\n \\n-  nsSmallVoidArray &radioButtons = entry->mRadioButtons;\\n-  PRUint32 i, count = radioButtons.Count();\\n+  PRUint32 i, count = aData->mRadioButtons.Count();\\n   for (i = 0; i < count; ++i) {\\n-    cb->NoteXPCOMChild(static_cast<nsIFormControl*>(radioButtons[i]));\\n+    cb->NoteXPCOMChild(aData->mRadioButtons[i]);\\n   }\\n-  \\n \\n-  return kHashEnumerateNext;\\n+  return PL_DHASH_NEXT;\\n }\\n \\n PR_STATIC_CALLBACK(PLDHashOperator)\\n@@ -1086,6 +1083,7 @@ nsDocument::Init()\\n   }\\n \\n   mLinkMap.Init();\\n+  mRadioGroups.Init();\\n \\n   // Force initialization.\\n   nsBindingManager *bindingManager = new nsBindingManager();\\n@@ -5041,17 +5039,15 @@ nsDocument::GetRadioGroup(const nsAString& aName,\\n   nsAutoString tmKey(aName);\\n   if(!IsCaseSensitive())\\n      ToLowerCase(tmKey); //should case-insensitive.\\n-  nsStringKey key(tmKey);\\n-  nsRadioGroupStruct *radioGroup =\\n-    static_cast<nsRadioGroupStruct *>(mRadioGroups.Get(&key));\\n+  if (mRadioGroups.Get(tmKey, aRadioGroup))\\n+    return NS_OK;\\n \\n-  if (!radioGroup) {\\n-    radioGroup = new nsRadioGroupStruct();\\n-    NS_ENSURE_TRUE(radioGroup, NS_ERROR_OUT_OF_MEMORY);\\n-    mRadioGroups.Put(&key, radioGroup);\\n-  }\\n+  nsAutoPtr<nsRadioGroupStruct> radioGroup(new nsRadioGroupStruct());\\n+  NS_ENSURE_TRUE(radioGroup, NS_ERROR_OUT_OF_MEMORY);\\n+  NS_ENSURE_TRUE(mRadioGroups.Put(tmKey, radioGroup), NS_ERROR_OUT_OF_MEMORY);\\n \\n   *aRadioGroup = radioGroup;\\n+  radioGroup.forget();\\n \\n   return NS_OK;\\n }\\n@@ -5157,7 +5153,7 @@ nsDocument::GetNextRadioButton(const nsAString& aName,\\n     else if (++index >= numRadios) {\\n       index = 0;\\n     }\\n-    radio = do_QueryInterface(static_cast<nsIFormControl*>(radioGroup->mRadioButtons.ElementAt(index)));\\n+    radio = do_QueryInterface(radioGroup->mRadioButtons[index]);\\n     NS_ASSERTION(radio, \\\"mRadioButtons holding a non-radio button\\\");\\n     radio->GetDisabled(&disabled);\\n   } while (disabled && radio != currentRadio);\\n@@ -5173,8 +5169,7 @@ nsDocument::AddToRadioGroup(const nsAString& aName,\\n   nsRadioGroupStruct* radioGroup = nsnull;\\n   GetRadioGroup(aName, &radioGroup);\\n   if (radioGroup) {\\n-    radioGroup->mRadioButtons.AppendElement(aRadio);\\n-    NS_IF_ADDREF(aRadio);\\n+    radioGroup->mRadioButtons.AppendObject(aRadio);\\n   }\\n \\n   return NS_OK;\\n@@ -5187,9 +5182,7 @@ nsDocument::RemoveFromRadioGroup(const nsAString& aName,\\n   nsRadioGroupStruct* radioGroup = nsnull;\\n   GetRadioGroup(aName, &radioGroup);\\n   if (radioGroup) {\\n-    if (radioGroup->mRadioButtons.RemoveElement(aRadio)) {\\n-      NS_IF_RELEASE(aRadio);\\n-    }\\n+    radioGroup->mRadioButtons.RemoveObject(aRadio);\\n   }\\n \\n   return NS_OK;\\n@@ -5208,9 +5201,7 @@ nsDocument::WalkRadioGroup(const nsAString& aName,\\n \\n   PRBool stop = PR_FALSE;\\n   for (int i = 0; i < radioGroup->mRadioButtons.Count(); i++) {\\n-    aVisitor->Visit(static_cast<nsIFormControl *>\\n-                               (radioGroup->mRadioButtons.ElementAt(i)),\\n-                    &stop);\\n+    aVisitor->Visit(radioGroup->mRadioButtons[i], &stop);\\n     if (stop) {\\n       return NS_OK;\\n     }\\ndiff --git a/content/base/src/nsDocument.h b/content/base/src/nsDocument.h\\nindex 849f108..350bea5 100644\\n--- a/content/base/src/nsDocument.h\\n+++ b/content/base/src/nsDocument.h\\n@@ -755,7 +755,7 @@ protected:\\n   nsRefPtr<nsScriptLoader> mScriptLoader;\\n   nsDocHeaderData* mHeaderData;\\n \\n-  nsHashtable mRadioGroups;\\n+  nsClassHashtable<nsStringHashKey, nsRadioGroupStruct> mRadioGroups;\\n \\n   // True if the document has been detached from its content viewer.\\n   PRPackedBool mIsGoingAway:1;\\n\""}