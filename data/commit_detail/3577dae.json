{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas3577dae\""},"diff":"\"3577dae [OS/2] Bug 395301: Move offscreen surface creation from gfxOS2Platform to gfxOS2Surface\\ndiff --git a/gfx/thebes/public/gfxOS2Platform.h b/gfx/thebes/public/gfxOS2Platform.h\\nindex e8aba38..6d86f4b 100644\\n--- a/gfx/thebes/public/gfxOS2Platform.h\\n+++ b/gfx/thebes/public/gfxOS2Platform.h\\n@@ -71,11 +71,6 @@ public:\\n                                   const gfxFontStyle *aStyle);\\n protected:\\n     static gfxFontconfigUtils *sFontconfigUtils;\\n-\\n-private:\\n-    HDC mDC;\\n-    HPS mPS;\\n-    HBITMAP mBitmap;\\n };\\n \\n #endif /* GFX_OS2_PLATFORM_H */\\ndiff --git a/gfx/thebes/public/gfxOS2Surface.h b/gfx/thebes/public/gfxOS2Surface.h\\nindex c795d02..b12f2bc 100644\\n--- a/gfx/thebes/public/gfxOS2Surface.h\\n+++ b/gfx/thebes/public/gfxOS2Surface.h\\n@@ -40,13 +40,19 @@\\n \\n #include \\\"gfxASurface.h\\\"\\n \\n+#define INCL_GPIBITMAPS\\n #include <os2.h>\\n #include <cairo-os2.h>\\n \\n class THEBES_API gfxOS2Surface : public gfxASurface {\\n \\n public:\\n+    // constructor to create a cairo surface using an existing PS\\n     gfxOS2Surface(HPS aPS, const gfxIntSize& aSize);\\n+    // constructor used to create a memory surface of given size\\n+    gfxOS2Surface(const gfxIntSize& aSize,\\n+                  gfxASurface::gfxImageFormat aImageFormat);\\n+    // constructor for surface connected to an onscreen window\\n     gfxOS2Surface(HWND aWnd);\\n     virtual ~gfxOS2Surface();\\n \\n@@ -55,8 +61,11 @@ public:\\n \\n private:\\n     PRBool mOwnsPS;\\n-    HPS mPS;\\n-    gfxIntSize mSize;\\n+    PRBool mHasWnd; // indicates if created through the HWND constructor\\n+    HDC mDC; // memory device context\\n+    HPS mPS; // presentation space connected to window or memory device\\n+    HBITMAP mBitmap; // bitmap for initialization of memory surface\\n+    gfxIntSize mSize; // current size of the surface\\n };\\n \\n #endif /* GFX_OS2_SURFACE_H */\\ndiff --git a/gfx/thebes/src/gfxOS2Platform.cpp b/gfx/thebes/src/gfxOS2Platform.cpp\\nindex 313a9b2..b34e962 100644\\n--- a/gfx/thebes/src/gfxOS2Platform.cpp\\n+++ b/gfx/thebes/src/gfxOS2Platform.cpp\\n@@ -51,7 +51,6 @@\\n gfxFontconfigUtils *gfxOS2Platform::sFontconfigUtils = nsnull;\\n \\n gfxOS2Platform::gfxOS2Platform()\\n-    : mDC(NULL), mPS(NULL), mBitmap(NULL)\\n {\\n #ifdef DEBUG_thebes\\n     printf(\\\"gfxOS2Platform::gfxOS2Platform()\\\\n\\\");\\n@@ -75,16 +74,6 @@ gfxOS2Platform::~gfxOS2Platform()\\n     gfxFontconfigUtils::Shutdown();\\n     sFontconfigUtils = nsnull;\\n \\n-    if (mBitmap) {\\n-        GpiSetBitmap(mPS, NULL);\\n-        GpiDeleteBitmap(mBitmap);\\n-    }\\n-    if (mPS) {\\n-        GpiDestroyPS(mPS);\\n-    }\\n-    if (mDC) {\\n-        DevCloseDC(mDC);\\n-    }\\n     // clean up OS/2 cairo stuff\\n     cairo_os2_fini();\\n #ifdef DEBUG_thebes\\n@@ -102,41 +91,12 @@ gfxOS2Platform::CreateOffscreenSurface(const gfxIntSize& aSize,\\n #endif\\n     gfxASurface *newSurface = nsnull;\\n \\n-    // XXX we only ever seem to get aImageFormat=0 or ImageFormatARGB32 but\\n+    // we only ever seem to get aImageFormat=0 or ImageFormatARGB32 but\\n     // I don't really know if we need to differ between ARGB32 and RGB24 here\\n     if (aImageFormat == gfxASurface::ImageFormatARGB32 ||\\n         aImageFormat == gfxASurface::ImageFormatRGB24)\\n     {\\n-        // create a PS, partly taken from nsOffscreenSurface::Init(), i.e. nsDrawingSurfaceOS2.cpp\\n-        DEVOPENSTRUC dop = { 0, 0, 0, 0, 0 };\\n-        SIZEL sizel = { 0, 0 }; /* use same page size as device */\\n-        mDC = DevOpenDC(0, OD_MEMORY, \\\"*\\\", 5, (PDEVOPENDATA)&dop, NULLHANDLE);\\n-        if (mDC != DEV_ERROR) {\\n-            mPS = GpiCreatePS(0, mDC, &sizel, PU_PELS | GPIT_MICRO | GPIA_ASSOC);\\n-            if (mPS != GPI_ERROR) {\\n-                // XXX: nsPaletteOS2::SelectGlobalPalette(mPS);\\n-                // perhaps implement the palette stuff at some point?!\\n-\\n-                // now create a bitmap of the right size\\n-                BITMAPINFOHEADER2 hdr = { 0 };\\n-                hdr.cbFix = sizeof(BITMAPINFOHEADER2);\\n-                hdr.cx = aSize.width;\\n-                hdr.cy = aSize.height;\\n-                hdr.cPlanes = 1;\\n-\\n-                // find bit depth, XXX this may not work here, use the aImageFormat instead?!\\n-                LONG lBitCount = 0;\\n-                DevQueryCaps(mDC, CAPS_COLOR_BITCOUNT, 1, &lBitCount);\\n-                hdr.cBitCount = (USHORT)lBitCount;\\n-\\n-                mBitmap = GpiCreateBitmap(mPS, &hdr, 0, 0, 0);\\n-                if (mBitmap != GPI_ERROR) {\\n-                    // set final stats & select bitmap into ps\\n-                    GpiSetBitmap(mPS, mBitmap);\\n-                }\\n-            } /* if mPS */\\n-        } /* if mDC */\\n-        newSurface = new gfxOS2Surface(mPS, aSize);\\n+        newSurface = new gfxOS2Surface(aSize, aImageFormat);\\n     } else if (aImageFormat == gfxASurface::ImageFormatA8 ||\\n                aImageFormat == gfxASurface::ImageFormatA1) {\\n         newSurface = new gfxImageSurface(aSize, aImageFormat);\\ndiff --git a/gfx/thebes/src/gfxOS2Surface.cpp b/gfx/thebes/src/gfxOS2Surface.cpp\\nindex 64c72f6..bd21c83 100644\\n--- a/gfx/thebes/src/gfxOS2Surface.cpp\\n+++ b/gfx/thebes/src/gfxOS2Surface.cpp\\n@@ -44,17 +44,66 @@\\n  **********************************************************************/\\n \\n gfxOS2Surface::gfxOS2Surface(HPS aPS, const gfxIntSize& aSize)\\n-    : mOwnsPS(PR_FALSE), mPS(aPS), mSize(aSize)\\n+    : mOwnsPS(PR_FALSE), mHasWnd(PR_FALSE), mDC(nsnull), mPS(aPS), mBitmap(nsnull), mSize(aSize)\\n {\\n #ifdef DEBUG_thebes_2\\n-    printf(\\\"gfxOS2Surface[%#x]::gfxOS2Surface(HPS=%#x, ...)\\\\n\\\",\\n-           (unsigned int)this, (unsigned int)aPS);\\n+    printf(\\\"gfxOS2Surface[%#x]::gfxOS2Surface(HPS=%#x, Size=%dx%d)\\\\n\\\", (unsigned int)this,\\n+           (unsigned int)mPS, aSize.width, aSize.height);\\n #endif\\n \\n+    // create the cairo surface on the passed PS\\n     cairo_surface_t *surf = cairo_os2_surface_create(mPS, mSize.width, mSize.height);\\n #ifdef DEBUG_thebes_2\\n-    printf(\\\"  type(%#x)=%d (own=%d, ID=%#x, h/w=%d/%d)\\\\n\\\", (unsigned int)surf,\\n-           cairo_surface_get_type(surf), mOwnsPS, (unsigned int)mPS, mSize.width, mSize.height);\\n+    printf(\\\"  type(%#x)=%d (ID=%#x, h/w=%d/%d)\\\\n\\\", (unsigned int)surf,\\n+           cairo_surface_get_type(surf), (unsigned int)mPS, mSize.width, mSize.height);\\n+#endif\\n+    // XXX for now uncomment the mark_dirty function, see bug 371505\\n+    //cairo_surface_mark_dirty(surf);\\n+    Init(surf);\\n+}\\n+\\n+gfxOS2Surface::gfxOS2Surface(const gfxIntSize& aSize,\\n+                             gfxASurface::gfxImageFormat aImageFormat)\\n+    : mOwnsPS(PR_TRUE), mHasWnd(PR_FALSE), mSize(aSize)\\n+{\\n+#ifdef DEBUG_thebes_2\\n+    printf(\\\"gfxOS2Surface[%#x]::gfxOS2Surface(Size=%dx%d, %d)\\\\n\\\", (unsigned int)this,\\n+           aSize.width, aSize.height, aImageFormat);\\n+#endif\\n+    // in this case we don't have a window, so we create a memory presentation\\n+    // space to construct the cairo surface on\\n+\\n+    // create a PS, partly taken from nsOffscreenSurface::Init(), i.e. nsDrawingSurfaceOS2.cpp\\n+    DEVOPENSTRUC dop = { 0, 0, 0, 0, 0 };\\n+    SIZEL sizel = { 0, 0 }; // use same page size as device\\n+    mDC = DevOpenDC(0, OD_MEMORY, (PSZ)\\\"*\\\", 5, (PDEVOPENDATA)&dop, NULLHANDLE);\\n+    NS_ASSERTION(mDC != DEV_ERROR, \\\"Could not create memory DC\\\");\\n+\\n+    mPS = GpiCreatePS(0, mDC, &sizel, PU_PELS | GPIT_MICRO | GPIA_ASSOC);\\n+    NS_ASSERTION(mPS != GPI_ERROR, \\\"Could not create PS on memory DC!\\\");\\n+\\n+    // now create a bitmap of the right size\\n+    BITMAPINFOHEADER2 hdr = { 0 };\\n+    hdr.cbFix = sizeof(BITMAPINFOHEADER2);\\n+    hdr.cx = mSize.width;\\n+    hdr.cy = mSize.height;\\n+    hdr.cPlanes = 1;\\n+\\n+    // find bit depth\\n+    LONG lBitCount = 0;\\n+    DevQueryCaps(mDC, CAPS_COLOR_BITCOUNT, 1, &lBitCount);\\n+    hdr.cBitCount = (USHORT)lBitCount;\\n+\\n+    mBitmap = GpiCreateBitmap(mPS, &hdr, 0, 0, 0);\\n+    NS_ASSERTION(mBitmap != GPI_ERROR, \\\"Could not create bitmap in memory!\\\");\\n+    // set final stats & select bitmap into PS\\n+    GpiSetBitmap(mPS, mBitmap);\\n+\\n+    // now we can finally create the cairo surface on the in-memory PS\\n+    cairo_surface_t *surf = cairo_os2_surface_create(mPS, mSize.width, mSize.height);\\n+#ifdef DEBUG_thebes_2\\n+    printf(\\\"  type(%#x)=%d (ID=%#x, h/w=%d/%d)\\\\n\\\", (unsigned int)surf,\\n+           cairo_surface_get_type(surf), (unsigned int)mPS, mSize.width, mSize.height);\\n #endif\\n     // XXX for now uncomment the mark_dirty function, see bug 371505\\n     //cairo_surface_mark_dirty(surf);\\n@@ -62,11 +111,11 @@ gfxOS2Surface::gfxOS2Surface(HPS aPS, const gfxIntSize& aSize)\\n }\\n \\n gfxOS2Surface::gfxOS2Surface(HWND aWnd)\\n-    : mOwnsPS(PR_TRUE)\\n+    : mOwnsPS(PR_TRUE), mHasWnd(PR_TRUE), mDC(nsnull), mBitmap(nsnull)\\n {\\n #ifdef DEBUG_thebes_2\\n-    printf(\\\"gfxOS2Surface[%#x]::gfxOS2Surface(HWND=%#x)\\\\n\\\",\\n-           (unsigned int)this, (unsigned int)aWnd);\\n+    printf(\\\"gfxOS2Surface[%#x]::gfxOS2Surface(HWND=%#x)\\\\n\\\", (unsigned int)this,\\n+           (unsigned int)aWnd);\\n #endif\\n \\n     mPS = WinGetPS(aWnd);\\n@@ -79,10 +128,11 @@ gfxOS2Surface::gfxOS2Surface(HWND aWnd)\\n     if (mSize.height == 0) mSize.height = 1; // cairo_os2_surface_create() return something\\n     cairo_surface_t *surf = cairo_os2_surface_create(mPS, mSize.width, mSize.height);\\n #ifdef DEBUG_thebes_2\\n-    printf(\\\"  type(%#x)=%d (own=%d, ID=%#x, h/w=%d/%d)\\\\n\\\", (unsigned int)surf,\\n-           cairo_surface_get_type(surf), mOwnsPS, (unsigned int)mPS, mSize.width, mSize.height);\\n+    printf(\\\"  type(%#x)=%d (ID=%#x, h/w=%d/%d)\\\\n\\\", (unsigned int)surf,\\n+           cairo_surface_get_type(surf), (unsigned int)mPS, mSize.width, mSize.height);\\n #endif\\n-    cairo_os2_surface_set_hwnd(surf, aWnd); // XXX is this needed here??\\n+    // record the window handle in the cairo surface, so that refresh works\\n+    cairo_os2_surface_set_hwnd(surf, aWnd);\\n     // XXX for now uncomment the mark_dirty function, see bug 371505\\n     //cairo_surface_mark_dirty(surf);\\n     Init(surf);\\n@@ -94,6 +144,24 @@ gfxOS2Surface::~gfxOS2Surface()\\n     printf(\\\"gfxOS2Surface[%#x]::~gfxOS2Surface()\\\\n\\\", (unsigned int)this);\\n #endif\\n \\n-    if (mOwnsPS)\\n-        WinReleasePS(mPS);\\n+    // Surfaces connected to a window were created using WinGetPS so we should\\n+    // release it again with WinReleasePS. Memory surfaces on the other\\n+    // hand were created on memory device contexts with the GPI functions, so\\n+    // use those to clean up stuff.\\n+    if (mHasWnd) {\\n+        if (mOwnsPS && mPS) {\\n+            WinReleasePS(mPS);\\n+        }\\n+    } else {\\n+        if (mBitmap) {\\n+            GpiSetBitmap(mPS, NULL);\\n+            GpiDeleteBitmap(mBitmap);\\n+        }\\n+        if (mOwnsPS && mPS) {\\n+            GpiDestroyPS(mPS);\\n+        }\\n+        if (mDC) {\\n+            DevCloseDC(mDC);\\n+        }\\n+    }\\n }\\n\""}