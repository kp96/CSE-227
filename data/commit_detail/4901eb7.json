{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas4901eb7\""},"diff":"\"4901eb7 bug 378457.  use nsAutoBuffers instead of mallocs for unsicribe item data.  r=vlad, sr=bsmedberg. original patch from David Humphrey <david.humphrey@senecac.on.ca>\\ndiff --git a/gfx/thebes/src/gfxWindowsFonts.cpp b/gfx/thebes/src/gfxWindowsFonts.cpp\\nindex dac48fc..10e494e 100644\\n--- a/gfx/thebes/src/gfxWindowsFonts.cpp\\n+++ b/gfx/thebes/src/gfxWindowsFonts.cpp\\n@@ -58,6 +58,7 @@\\n \\n #include <windows.h>\\n \\n+#include \\\"nsAutoBuffer.h\\\"\\n #include \\\"nsUnicodeRange.h\\\"\\n #include \\\"nsUnicharUtils.h\\\"\\n \\n@@ -650,15 +651,15 @@ SetupTextRunFromGlyphs(gfxTextRun *aRun, WCHAR *aGlyphs, HDC aDC,\\n         return PR_FALSE;\\n \\n     SIZE size;\\n-    nsAutoTArray<int,500> partialWidthArray;\\n-    if (!partialWidthArray.AppendElements(length))\\n+    nsAutoBuffer<int,500> partialWidthArray;\\n+    if (!partialWidthArray.EnsureElemCapacity(length))\\n         return PR_FALSE;\\n     BOOL success = GetTextExtentExPointI(aDC,\\n                                          (WORD*) aGlyphs,\\n                                          length,\\n                                          INT_MAX,\\n                                          NULL,\\n-                                         partialWidthArray.Elements(),\\n+                                         partialWidthArray.get(),\\n                                          &size);\\n     if (!success)\\n         return PR_FALSE;\\n@@ -700,14 +701,14 @@ gfxWindowsFontGroup::InitTextRunGDI(gfxContext *aContext, gfxTextRun *aRun,\\n     nsRefPtr<gfxWindowsFont> font = GetFontAt(0);\\n     DCFromContext dc(aContext);\\n     if (SetupDCFont(dc, font)) {\\n-        nsAutoTArray<WCHAR,500> glyphArray;\\n-        if (!glyphArray.AppendElements(aLength))\\n+        nsAutoBuffer<WCHAR,500> glyphArray;\\n+        if (!glyphArray.EnsureElemCapacity(aLength))\\n             return;\\n \\n-        DWORD ret = GetGlyphIndicesA(dc, aString, aLength, (WORD*) glyphArray.Elements(),\\n+        DWORD ret = GetGlyphIndicesA(dc, aString, aLength, (WORD*) glyphArray.get(),\\n                                      GGI_MARK_NONEXISTING_GLYPHS);\\n         if (ret != GDI_ERROR &&\\n-            SetupTextRunFromGlyphs(aRun, glyphArray.Elements(), dc, font))\\n+            SetupTextRunFromGlyphs(aRun, glyphArray.get(), dc, font))\\n             return;\\n     }\\n \\n@@ -724,14 +725,14 @@ gfxWindowsFontGroup::InitTextRunGDI(gfxContext *aContext, gfxTextRun *aRun,\\n     nsRefPtr<gfxWindowsFont> font = GetFontAt(0);\\n     DCFromContext dc(aContext);\\n     if (SetupDCFont(dc, font)) {\\n-        nsAutoTArray<WCHAR,500> glyphArray;\\n-        if (!glyphArray.AppendElements(aLength))\\n+        nsAutoBuffer<WCHAR,500> glyphArray;\\n+        if (!glyphArray.EnsureElemCapacity(aLength))\\n             return;\\n \\n-        DWORD ret = GetGlyphIndicesW(dc, aString, aLength, (WORD*) glyphArray.Elements(),\\n+        DWORD ret = GetGlyphIndicesW(dc, aString, aLength, (WORD*) glyphArray.get(),\\n                                      GGI_MARK_NONEXISTING_GLYPHS);\\n         if (ret != GDI_ERROR &&\\n-            SetupTextRunFromGlyphs(aRun, glyphArray.Elements(), dc, font))\\n+            SetupTextRunFromGlyphs(aRun, glyphArray.get(), dc, font))\\n             return;\\n     }\\n \\n@@ -871,10 +872,6 @@ static const char *sCJKLangGroup[] = {\\n \\n #define STATIC_STRING_LENGTH 100\\n \\n-/**\\n- * XXX We could use a bunch of nsAutoTArrays to avoid memory allocation\\n- * for non-huge strings.\\n- */\\n class UniscribeItem\\n {\\n public:\\n@@ -886,22 +883,15 @@ public:\\n         mItemString(aString), mItemLength(aLength), \\n         mAlternativeString(nsnull), mScriptItem(aItem),\\n         mScript(aItem->a.eScript), mGroup(aGroup),\\n-        mGlyphs(nsnull), mClusters(nsnull), mAttr(nsnull),\\n         mNumGlyphs(0), mMaxGlyphs((int)(1.5 * aLength) + 16),\\n-        mOffsets(nsnull), mAdvances(nsnull),\\n         mFontSelected(PR_FALSE)\\n     {\\n-        mGlyphs = (WORD *)malloc(mMaxGlyphs * sizeof(WORD));\\n-        mClusters = (WORD *)malloc((mItemLength + 1) * sizeof(WORD));\\n-        mAttr = (SCRIPT_VISATTR *)malloc(mMaxGlyphs * sizeof(SCRIPT_VISATTR));\\n+        mGlyphs.EnsureElemCapacity(mMaxGlyphs);\\n+        mClusters.EnsureElemCapacity(mItemLength + 1);\\n+        mAttr.EnsureElemCapacity(mMaxGlyphs);\\n     }\\n \\n     ~UniscribeItem() {\\n-        free(mGlyphs);\\n-        free(mClusters);\\n-        free(mAttr);\\n-        free(mOffsets);\\n-        free(mAdvances);\\n         free(mAlternativeString);\\n     }\\n \\n@@ -936,13 +926,13 @@ public:\\n             rv = ScriptShape(shapeDC, mCurrentFont->ScriptCache(),\\n                              str, mRangeLength,\\n                              mMaxGlyphs, &sa,\\n-                             mGlyphs, mClusters,\\n-                             mAttr, &mNumGlyphs);\\n+                             mGlyphs.get(), mClusters.get(),\\n+                             mAttr.get(), &mNumGlyphs);\\n \\n             if (rv == E_OUTOFMEMORY) {\\n+                mGlyphs.AddElemCapacity(mMaxGlyphs);\\n+                mAttr.AddElemCapacity(mMaxGlyphs);\\n                 mMaxGlyphs *= 2;\\n-                mGlyphs = (WORD *)realloc(mGlyphs, mMaxGlyphs * sizeof(WORD));\\n-                mAttr = (SCRIPT_VISATTR *)realloc(mAttr, mMaxGlyphs * sizeof(SCRIPT_VISATTR));\\n                 continue;\\n             }\\n \\n@@ -959,7 +949,7 @@ public:\\n             }\\n #ifdef DEBUG_pavlov\\n             if (rv == USP_E_SCRIPT_NOT_IN_FONT) {\\n-                ScriptGetCMap(mDC, mCurrentFont->ScriptCache(), str, mRangeString, 0, mGlyphs);\\n+                ScriptGetCMap(mDC, mCurrentFont->ScriptCache(), str, mRangeString, 0, mGlyphs.get());\\n                 PRUnichar foo[LF_FACESIZE+1];\\n                 GetTextFaceW(mDC, LF_FACESIZE, foo);\\n                 printf(\\\"bah\\\\n\\\");\\n@@ -999,16 +989,16 @@ public:\\n     HRESULT Place() {\\n         HRESULT rv;\\n \\n-        mOffsets = (GOFFSET *)malloc(mNumGlyphs * sizeof(GOFFSET));\\n-        mAdvances = (int *)malloc(mNumGlyphs * sizeof(int));\\n+        mOffsets.EnsureElemCapacity(mNumGlyphs);\\n+        mAdvances.EnsureElemCapacity(mNumGlyphs);\\n \\n         HDC placeDC = nsnull;\\n \\n         while (PR_TRUE) {\\n             rv = ScriptPlace(placeDC, mCurrentFont->ScriptCache(),\\n-                             mGlyphs, mNumGlyphs,\\n-                             mAttr, &mScriptItem->a,\\n-                             mAdvances, mOffsets, NULL);\\n+                             mGlyphs.get(), mNumGlyphs,\\n+                             mAttr.get(), &mScriptItem->a,\\n+                             mAdvances.get(), mOffsets.get(), NULL);\\n \\n             if (rv == E_PENDING) {\\n                 SelectFont();\\n@@ -1465,16 +1455,20 @@ private:\\n \\n     gfxWindowsFontGroup *mGroup;\\n \\n-    WORD *mGlyphs;\\n-    WORD *mClusters;\\n-    SCRIPT_VISATTR *mAttr;\\n+#define AVERAGE_ITEM_LENGTH 40\\n+\\n+    nsAutoBuffer<WORD, (1.5 * AVERAGE_ITEM_LENGTH) + 16> mGlyphs;\\n+    nsAutoBuffer<WORD, AVERAGE_ITEM_LENGTH + 1> mClusters;\\n+    nsAutoBuffer<SCRIPT_VISATTR, (1.5 * AVERAGE_ITEM_LENGTH) + 16> mAttr;\\n+ \\n+    nsAutoBuffer<GOFFSET, 2 * AVERAGE_ITEM_LENGTH> mOffsets;\\n+    nsAutoBuffer<int, 2 * AVERAGE_ITEM_LENGTH> mAdvances;\\n+\\n+#undef AVERAGE_ITEM_LENGTH\\n \\n     int mMaxGlyphs;\\n     int mNumGlyphs;\\n \\n-    GOFFSET *mOffsets;\\n-    int *mAdvances;\\n-\\n     nsRefPtr<gfxWindowsFont> mCurrentFont;\\n \\n     PRPackedBool mFontSelected;\\ndiff --git a/xpcom/ds/nsAutoBuffer.h b/xpcom/ds/nsAutoBuffer.h\\nindex 8401136..05cb4b3 100644\\n--- a/xpcom/ds/nsAutoBuffer.h\\n+++ b/xpcom/ds/nsAutoBuffer.h\\n@@ -117,6 +117,16 @@ public:\\n   T*          get()             const  { return mBufferPtr; }\\n   PRInt32     GetElemCapacity() const  { return mCurElemCapacity;  }\\n \\n+  T& operator[](PRUint32 i)\\n+  {\\n+    return mBufferPtr[i];\\n+  }\\n+\\n+  const T& operator[](PRUint32 i) const\\n+  {\\n+    return mBufferPtr[i];\\n+  }\\n+\\n protected:\\n \\n   T             *mBufferPtr;\\n\""}