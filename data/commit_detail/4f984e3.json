{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas4f984e3\""},"diff":"\"4f984e3 Bug 392629. Be a bit more clever about invalidating listboxes and combobox dropdowns when the focus ring moves. r+sr=bzbarsky\\ndiff --git a/layout/forms/nsListControlFrame.cpp b/layout/forms/nsListControlFrame.cpp\\nindex b048221..cc4645f 100644\\n--- a/layout/forms/nsListControlFrame.cpp\\n+++ b/layout/forms/nsListControlFrame.cpp\\n@@ -375,6 +375,24 @@ void nsListControlFrame::PaintFocus(nsIRenderingContext& aRC, nsPoint aPt)\\n   nsCSSRendering::DrawDashedSides(0, aRC, dirty, borderStyle, colors, fRect, innerRect, 0, nsnull);\\n }\\n \\n+void\\n+nsListControlFrame::InvalidateFocus()\\n+{\\n+  if (mFocused != this)\\n+    return;\\n+\\n+  nsIFrame* containerFrame = GetOptionsContainer();\\n+  if (containerFrame) {\\n+    // Invalidating from the containerFrame because that's where our focus\\n+    // is drawn.\\n+    // The origin of the scrollport is the origin of containerFrame.\\n+    nsRect invalidateArea = containerFrame->GetOverflowRect();\\n+    nsRect emptyFallbackArea(0, 0, GetScrollPortSize().width, CalcFallbackRowHeight(0));\\n+    invalidateArea.UnionRect(invalidateArea, emptyFallbackArea);\\n+    containerFrame->Invalidate(invalidateArea);\\n+  }\\n+}\\n+\\n //---------------------------------------------------------\\n // Frames are not refcounted, no need to AddRef\\n NS_IMETHODIMP\\n@@ -851,6 +869,7 @@ nsListControlFrame::SingleSelection(PRInt32 aClickedIndex, PRBool aDoToggle)\\n   ScrollToIndex(aClickedIndex);\\n   mStartSelectionIndex = aClickedIndex;\\n   mEndSelectionIndex = aClickedIndex;\\n+  InvalidateFocus();\\n   return wasChanged;\\n }\\n \\n@@ -947,6 +966,7 @@ nsListControlFrame::PerformSelection(PRInt32 aClickedIndex,\\n       } else {\\n         mEndSelectionIndex = aClickedIndex;\\n       }\\n+      InvalidateFocus();\\n     } else if (aIsControl) {\\n       wasChanged = SingleSelection(aClickedIndex, PR_TRUE);\\n     } else {\\n@@ -1298,13 +1318,15 @@ nsListControlFrame::ResetList(PRBool aAllowScrolling)\\n \\n   mStartSelectionIndex = kNothingSelected;\\n   mEndSelectionIndex = kNothingSelected;\\n-\\n+  InvalidateFocus();\\n   // Combobox will redisplay itself with the OnOptionSelected event\\n } \\n  \\n void \\n nsListControlFrame::SetFocus(PRBool aOn, PRBool aRepaint)\\n {\\n+  InvalidateFocus();\\n+\\n   if (aOn) {\\n     ComboboxFocusSet();\\n     mFocused = this;\\n@@ -1312,8 +1334,7 @@ nsListControlFrame::SetFocus(PRBool aOn, PRBool aRepaint)\\n     mFocused = nsnull;\\n   }\\n \\n-  // Make sure the SelectArea frame gets painted\\n-  Invalidate(nsRect(0,0,mRect.width,mRect.height), PR_TRUE);\\n+  InvalidateFocus();\\n }\\n \\n void nsListControlFrame::ComboboxFocusSet()\\n@@ -1491,6 +1512,7 @@ nsListControlFrame::RemoveOption(nsPresContext* aPresContext, PRInt32 aIndex)\\n     }    \\n   }\\n \\n+  InvalidateFocus();\\n   return NS_OK;\\n }\\n \\n@@ -1633,6 +1655,7 @@ nsListControlFrame::OnSetSelectedIndex(PRInt32 aOldIndex, PRInt32 aNewIndex)\\n   ScrollToIndex(aNewIndex);\\n   mStartSelectionIndex = aNewIndex;\\n   mEndSelectionIndex = aNewIndex;\\n+  InvalidateFocus();\\n \\n #ifdef ACCESSIBILITY\\n   FireMenuItemActiveEvent();\\n@@ -2209,12 +2232,6 @@ nsListControlFrame::MouseMove(nsIDOMEvent* aMouseEvent)\\n       if (NS_SUCCEEDED(GetIndexFromDOMEvent(aMouseEvent, selectedIndex))) {\\n         PerformSelection(selectedIndex, PR_FALSE, PR_FALSE);\\n       }\\n-\\n-      // Make sure the SelectArea frame gets painted\\n-      // XXX this shouldn't be needed, but other places in this code do it\\n-      // and if we don't do this, invalidation doesn't happen when we move out\\n-      // of the top-level window. We should track this down and fix it --- roc\\n-      Invalidate(nsRect(0,0,mRect.width,mRect.height), PR_TRUE);\\n     }\\n   } else {// XXX - temporary until we get drag events\\n     if (mButtonDown) {\\n@@ -2720,6 +2737,7 @@ nsListControlFrame::KeyPress(nsIDOMEvent* aKeyEvent)\\n     if (isControl && charcode != ' ') {\\n       mStartSelectionIndex = newIndex;\\n       mEndSelectionIndex = newIndex;\\n+      InvalidateFocus();\\n       ScrollToIndex(newIndex);\\n     } else if (mControlSelectMode && charcode == ' ') {\\n       wasChanged = SingleSelection(newIndex, PR_TRUE);\\n@@ -2737,10 +2755,6 @@ nsListControlFrame::KeyPress(nsIDOMEvent* aKeyEvent)\\n       FireMenuItemActiveEvent();\\n     }\\n #endif\\n-\\n-    // Make sure the SelectArea frame gets painted\\n-    Invalidate(nsRect(0,0,mRect.width,mRect.height), PR_TRUE);\\n-\\n   }\\n \\n   return NS_OK;\\ndiff --git a/layout/forms/nsListControlFrame.h b/layout/forms/nsListControlFrame.h\\nindex 84a993f..7a888cd 100644\\n--- a/layout/forms/nsListControlFrame.h\\n+++ b/layout/forms/nsListControlFrame.h\\n@@ -245,6 +245,13 @@ public:\\n    * frame\\n    */\\n   void PaintFocus(nsIRenderingContext& aRC, nsPoint aPt);\\n+  /**\\n+   * If this frame IsFocused(), invalidates an area that includes anything\\n+   * that PaintFocus will or could have painted --- basically the whole\\n+   * GetOptionsContainer, plus some extra stuff if there are no options. This\\n+   * must be called every time mEndSelectionIndex changes.\\n+   */\\n+  void InvalidateFocus();\\n \\n   /**\\n    * Function to calculate the height a row, for use with the \\\"size\\\" attribute.\\n\""}