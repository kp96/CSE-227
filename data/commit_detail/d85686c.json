{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basd85686c\""},"diff":"\"d85686c Add code to disable any auth prompt and turn them into failures (from the microsummary svc). Get/save sync service password in the password manager (ui missing). Fix a bug in the reconciler that prevented it from returning any conflicts. Other misc cleanup.\\ndiff --git a/services/sync/nsBookmarksSyncService.js b/services/sync/nsBookmarksSyncService.js\\nindex e768d4a..6aa7746 100644\\n--- a/services/sync/nsBookmarksSyncService.js\\n+++ b/services/sync/nsBookmarksSyncService.js\\n@@ -92,15 +92,15 @@ BookmarksSyncService.prototype = {\\n   },\\n \\n   _init: function BSS__init() {\\n-    var serverUrl = \\\"http://sync.server.url/\\\";\\n+    let serverURL = 'https://dotmoz.mozilla.org/';\\n     try {\\n-      var branch = Cc[\\\"@mozilla.org/preferences-service;1\\\"].\\n+      let branch = Cc[\\\"@mozilla.org/preferences-service;1\\\"].\\n         getService(Ci.nsIPrefBranch);\\n-      serverUrl = branch.getCharPref(\\\"browser.places.sync.serverUrl\\\");\\n+      serverURL = branch.getCharPref(\\\"browser.places.sync.serverURL\\\");\\n     }\\n     catch (ex) { /* use defaults */ }\\n-    LOG(\\\"Bookmarks sync server: \\\" + serverUrl);\\n-    this._dav = new DAVCollection(serverUrl);\\n+    LOG(\\\"Bookmarks login server: \\\" + serverURL);\\n+    this._dav = new DAVCollection(serverURL);\\n   },\\n \\n   _wrapNode: function BSS__wrapNode(node) {\\n@@ -159,7 +159,7 @@ BookmarksSyncService.prototype = {\\n   },\\n \\n   _nodeParentsInt: function BSS__nodeParentsInt(guid, tree, parents) {\\n-    if (tree[guid].parentGuid == null)\\n+    if (tree[guid] && tree[guid].parentGuid == null)\\n       return parents;\\n     parents.push(tree[guid].parentGuid);\\n     return this._nodeParentsInt(tree[guid].parentGuid, tree, parents);\\n@@ -292,12 +292,26 @@ BookmarksSyncService.prototype = {\\n     }\\n   },\\n \\n+  // FIXME: todo: change the conflicts data structure to hold more\\n+  // information about which specific command pars conflict; an what\\n+  // commands would apply once those are resolved.  Perhaps something\\n+  // like:\\n+\\n+  // [[direct-conflictA, 2nd-degree-conflictA1, ...],\\n+  //  [direct-conflictB, 2nd-degree-conflict-B1, ...], ...]\\n+\\n+  // possible problem: a 2nd-degree conflict could show up in multiple\\n+  // lists (that is, there are multiple direct conflicts that prevent\\n+  // another command pair from cleanly applying). maybe:\\n+\\n+  // [[[dcA1, dcB1], [dcA2. dcB2], ...],\\n+  //  [2dcA1, 2dcA2, ...], [2dcB1, 2dcB2, ...]]\\n+\\n   _reconcile: function BSS__reconcile(onComplete, commandLists) {\\n     let generator = yield;\\n     this._timer = Cc[\\\"@mozilla.org/timer;1\\\"].createInstance(Ci.nsITimer);\\n-    let callback = bind2(this,\\n-                         function(event) { handleEvent(generator, event); });\\n-    let listener = new EventListener(callback);\\n+    let handlers = this._handlersForGenerator(generator);\\n+    let listener = new EventListener(handlers['complete']);\\n \\n     let [listA, listB] = commandLists;\\n     let propagations = [[], []];\\n@@ -335,10 +349,10 @@ BookmarksSyncService.prototype = {\\n       for (let j = 0; j < listB.length; j++) {\\n         if (this._conflicts(listA[i], listB[j]) ||\\n             this._conflicts(listB[j], listA[i])) {\\n-          if (conflicts[0].some(\\n+          if (!conflicts[0].some(\\n             function(elt) { return elt.guid == listA[i].guid }))\\n             conflicts[0].push(listA[i]);\\n-          if (conflicts[1].some(\\n+          if (!conflicts[1].some(\\n             function(elt) { return elt.guid == listB[j].guid }))\\n             conflicts[1].push(listB[j]);\\n         }\\n@@ -563,10 +577,6 @@ BookmarksSyncService.prototype = {\\n       var propagations = [server['updates'], localUpdates];\\n       var conflicts = [[],[]];\\n \\n-      // reconciliation was wrapped in this - why?\\n-      //if (server['status'] == 1 && localUpdates.length > 0) {\\n-      //}\\n-\\n       LOG(\\\"Reconciling updates\\\");\\n       asyncRun(bind2(this, this._reconcile),\\n                handlers['complete'], [localUpdates, server.updates]);\\n@@ -590,15 +600,13 @@ BookmarksSyncService.prototype = {\\n       }\\n \\n       if (conflicts && conflicts[0] && conflicts[0].length) {\\n-        //var combinedCommands = this._combineCommands(propagations[0]);\\n         LOG(\\\"\\\\nWARNING: Conflicts found, but we don't resolve conflicts yet!\\\\n\\\");\\n-        LOG(\\\"Conflicts(1) \\\" + uneval(this._combineCommands(conflicts[0])));\\n+        LOG(\\\"Conflicts(1) \\\" + uneval(conflicts[0]));\\n       }\\n \\n       if (conflicts && conflicts[1] && conflicts[1].length) {\\n-        //var combinedCommands = this._combineCommands(propagations[0]);\\n         LOG(\\\"\\\\nWARNING: Conflicts found, but we don't resolve conflicts yet!\\\\n\\\");\\n-        LOG(\\\"Conflicts(2) \\\" + uneval(this._combineCommands(conflicts[1])));\\n+        LOG(\\\"Conflicts(2) \\\" + uneval(conflicts[1]));\\n       }\\n \\n       // 3.1) Apply server changes to local store\\n@@ -793,13 +801,14 @@ BookmarksSyncService.prototype = {\\n   },\\n \\n   _handlersForGenerator: function BSS__handlersForGenerator(generator) {\\n-    var h = {load: bind2(this, function(event) { handleEvent(generator, event); }),\\n+    var h = {load: bind2(this, function(event) { continueGenerator(generator, event); }),\\n              error: bind2(this, function(event) { LOG(\\\"Request failed: \\\" + uneval(event)); })};\\n     h['complete'] = h['load'];\\n     return h;\\n   },\\n \\n   _onLogin: function BSS__onLogin(event) {\\n+    LOG(\\\"Bookmarks sync server: \\\" + this._dav.baseURL);\\n     this._os.notifyObservers(null, \\\"bookmarks-sync:login\\\", \\\"\\\");\\n   },\\n \\n@@ -823,8 +832,7 @@ BookmarksSyncService.prototype = {\\n   sync: function BSS_sync() { asyncRun(bind2(this, this._doSync)); },\\n \\n   login: function BSS_login() {\\n-    this._dav.login(\\\"nobody@mozilla.com\\\", \\\"password\\\", // FIXME\\n-                    {load: bind2(this, this._onLogin),\\n+    this._dav.login({load: bind2(this, this._onLogin),\\n                      error: bind2(this, this._onLoginError)});\\n   },\\n \\n@@ -834,15 +842,39 @@ BookmarksSyncService.prototype = {\\n   }\\n };\\n \\n+function makeFile(path) {\\n+  var file = Cc[\\\"@mozilla.org/file/local;1\\\"].createInstance(Ci.nsILocalFile);\\n+  file.initWithPath(path);\\n+  return file;\\n+}\\n+\\n+function makeURI(uriString) {\\n+  var ioservice = Cc[\\\"@mozilla.org/network/io-service;1\\\"].\\n+                  getService(Ci.nsIIOService);\\n+  return ioservice.newURI(uriString, null, null);\\n+}\\n+\\n+function LOG(aText) {\\n+  dump(aText + \\\"\\\\n\\\");\\n+  var consoleService = Cc[\\\"@mozilla.org/consoleservice;1\\\"].\\n+                       getService(Ci.nsIConsoleService);\\n+  consoleService.logStringMessage(aText);\\n+}\\n+\\n+function bind2(object, method) {\\n+  return function innerBind() { return method.apply(object, arguments); }\\n+}\\n+\\n function asyncRun(func, handler, data) {\\n   var generator = func(handler, data);\\n   generator.next();\\n   generator.send(generator);\\n }\\n \\n-function handleEvent(generator, data) {\\n+function continueGenerator(generator, data) {\\n   try { generator.send(data); }\\n   catch (e) {\\n+    generator.close();\\n     if (e instanceof StopIteration)\\n       generator = null;\\n     else\\n@@ -874,12 +906,17 @@ EventListener.prototype = {\\n   }\\n };\\n \\n-function DAVCollection(baseUrl) {\\n-  this._baseUrl = baseUrl;\\n+function DAVCollection(baseURL) {\\n+  this._baseURL = baseURL;\\n+  this._authProvider = new DummyAuthProvider();\\n }\\n DAVCollection.prototype = {\\n   _loggedIn: false,\\n \\n+  get baseURL() {\\n+    return this._baseURL;\\n+  },\\n+\\n   __base64: {},\\n   __vase64loaded: false,\\n   get _base64() {\\n@@ -914,7 +951,7 @@ DAVCollection.prototype = {\\n     this._addHandler(request, handlers, \\\"error\\\");\\n   \\n     request = request.QueryInterface(Ci.nsIXMLHttpRequest);\\n-    request.open(op, this._baseUrl + path, true);\\n+    request.open(op, this._baseURL + path, true);\\n   \\n     if (headers) {\\n       for (var key in headers) {\\n@@ -922,6 +959,8 @@ DAVCollection.prototype = {\\n       }\\n     }\\n \\n+    request.channel.notificationCallbacks = this._authProvider;\\n+\\n     return request;\\n   },\\n \\n@@ -947,14 +986,41 @@ DAVCollection.prototype = {\\n \\n   // Login / Logout\\n \\n-  login: function DC_login(username, password, handlers) {\\n+  login: function DC_login(handlers) {\\n     this._loginHandlers = handlers;\\n     internalHandlers = {load: bind2(this, this._onLogin),\\n                         error: bind2(this, this._onLoginError)};\\n \\n-    this._authString = \\\"Basic \\\" +\\n-      this._base64.Base64.encode(username + \\\":\\\" + password);\\n-    headers = {'Authorization': this._authString};\\n+    try {\\n+      let uri = makeURI(this._baseURL);\\n+      let username = 'nobody@mozilla.com';\\n+      let password;\\n+\\n+      let branch = Cc[\\\"@mozilla.org/preferences-service;1\\\"].\\n+        getService(Ci.nsIPrefBranch);\\n+      username = branch.getCharPref(\\\"browser.places.sync.username\\\");\\n+\\n+      // fixme: make a request and get the realm\\n+      let lm = Cc[\\\"@mozilla.org/login-manager;1\\\"].getService(Ci.nsILoginManager);\\n+      let logins = lm.findLogins({}, uri.hostPort, null,\\n+                                 'Use your ldap username/password - dotmoz');\\n+      LOG(\\\"Found \\\" + logins.length + \\\" logins\\\");\\n+\\n+      for (let i = 0; i < logins.length; i++) {\\n+        if (logins[i].username == username) {\\n+          password = logins[i].password;\\n+          break;\\n+        }\\n+      }\\n+\\n+      // FIXME: should we regen this each time to prevent it from staying in memory?\\n+      this._authString = \\\"Basic \\\" +\\n+        this._base64.Base64.encode(username + \\\":\\\" + password);\\n+      headers = {'Authorization': this._authString};\\n+    } catch (e) {\\n+      // try without the auth header?\\n+      // fixme: may want to just fail here\\n+    }\\n \\n     let request = this._makeRequest(\\\"GET\\\", \\\"\\\", internalHandlers, headers);\\n     request.send(null);\\n@@ -968,16 +1034,17 @@ DAVCollection.prototype = {\\n     //LOG(\\\"logged in (\\\" + event.target.status + \\\"):\\\\n\\\" +\\n     //    event.target.responseText + \\\"\\\\n\\\");\\n \\n-    if (event.target.status != 200) {\\n+    if (this._authProvider._authFailed || event.target.status >= 400) {\\n       this._onLoginError(event);\\n       return;\\n     }\\n \\n+    // fixme: hacktastic\\n     let hello = /Hello (.+)@mozilla.com/.exec(event.target.responseText)\\n     if (hello) {\\n       this._currentUserPath = hello[1];\\t\\n       this._currentUser = this._currentUserPath + \\\"@mozilla.com\\\";\\n-      this._baseUrl = \\\"http://dotmoz.mozilla.org/~\\\" +\\n+      this._baseURL = \\\"http://dotmoz.mozilla.org/~\\\" +\\n         this._currentUserPath + \\\"/\\\";\\n     }\\n \\n@@ -1047,28 +1114,141 @@ DAVCollection.prototype = {\\n   }\\n };\\n \\n-function makeFile(path) {\\n-  var file = Cc[\\\"@mozilla.org/file/local;1\\\"].createInstance(Ci.nsILocalFile);\\n-  file.initWithPath(path);\\n-  return file;\\n-}\\n \\n-function makeURI(uriString) {\\n-  var ioservice = Cc[\\\"@mozilla.org/network/io-service;1\\\"].\\n-                  getService(Ci.nsIIOService);\\n-  return ioservice.newURI(uriString, null, null);\\n-}\\n+// Taken from nsMicrosummaryService.js and massaged slightly\\n+function DummyAuthProvider() {}\\n+DummyAuthProvider.prototype = {\\n+  // Implement notification callback interfaces so we can suppress UI\\n+  // and abort loads for bad SSL certs and HTTP authorization requests.\\n+  \\n+  // Interfaces this component implements.\\n+  interfaces: [Ci.nsIBadCertListener,\\n+               Ci.nsIAuthPromptProvider,\\n+               Ci.nsIAuthPrompt,\\n+               Ci.nsIPrompt,\\n+               Ci.nsIInterfaceRequestor,\\n+               Ci.nsISupports],\\n+\\n+  // Auth requests appear to succeed when we cancel them (since the server\\n+  // redirects us to a \\\"you're not authorized\\\" page), so we have to set a flag\\n+  // to let the load handler know to treat the load as a failure.\\n+  get _authFailed()         { return this.__authFailed; },\\n+  set _authFailed(newValue) { return this.__authFailed = newValue },\\n \\n-function bind2(object, method) {\\n-  return function innerBind() { return method.apply(object, arguments); }\\n-}\\n+  // nsISupports\\n \\n-function LOG(aText) {\\n-  dump(aText + \\\"\\\\n\\\");\\n-  var consoleService = Cc[\\\"@mozilla.org/consoleservice;1\\\"].\\n-                       getService(Ci.nsIConsoleService);\\n-  consoleService.logStringMessage(aText);\\n-}\\n+  QueryInterface: function DAP_QueryInterface(iid) {\\n+    if (!this.interfaces.some( function(v) { return iid.equals(v) } ))\\n+      throw Cr.NS_ERROR_NO_INTERFACE;\\n+\\n+    // nsIAuthPrompt and nsIPrompt need separate implementations because\\n+    // their method signatures conflict.  The other interfaces we implement\\n+    // within DummyAuthProvider itself.\\n+    switch(iid) {\\n+    case Ci.nsIAuthPrompt:\\n+      return this.authPrompt;\\n+    case Ci.nsIPrompt:\\n+      return this.prompt;\\n+    default:\\n+      return this;\\n+    }\\n+  },\\n+\\n+  // nsIInterfaceRequestor\\n+  \\n+  getInterface: function DAP_getInterface(iid) {\\n+    return this.QueryInterface(iid);\\n+  },\\n+\\n+  // nsIBadCertListener\\n+\\n+  // Suppress UI and abort secure loads from servers with bad SSL certificates.\\n+  \\n+  confirmUnknownIssuer: function DAP_confirmUnknownIssuer(socketInfo, cert, certAddType) {\\n+    return false;\\n+  },\\n+\\n+  confirmMismatchDomain: function DAP_confirmMismatchDomain(socketInfo, targetURL, cert) {\\n+    return false;\\n+  },\\n+\\n+  confirmCertExpired: function DAP_confirmCertExpired(socketInfo, cert) {\\n+    return false;\\n+  },\\n+\\n+  notifyCrlNextupdate: function DAP_notifyCrlNextupdate(socketInfo, targetURL, cert) {\\n+  },\\n+\\n+  // nsIAuthPromptProvider\\n+  \\n+  getAuthPrompt: function(aPromptReason, aIID) {\\n+    this._authFailed = true;\\n+    throw Cr.NS_ERROR_NOT_AVAILABLE;\\n+  },\\n+\\n+  // HTTP always requests nsIAuthPromptProvider first, so it never needs\\n+  // nsIAuthPrompt, but not all channels use nsIAuthPromptProvider, so we\\n+  // implement nsIAuthPrompt too.\\n+\\n+  // nsIAuthPrompt\\n+\\n+  get authPrompt() {\\n+    var resource = this;\\n+    return {\\n+      QueryInterface: XPCOMUtils.generateQI([Ci.nsIPrompt]),\\n+      prompt: function(dialogTitle, text, passwordRealm, savePassword, defaultText, result) {\\n+        resource._authFailed = true;\\n+        return false;\\n+      },\\n+      promptUsernameAndPassword: function(dialogTitle, text, passwordRealm, savePassword, user, pwd) {\\n+        resource._authFailed = true;\\n+        return false;\\n+      },\\n+      promptPassword: function(dialogTitle, text, passwordRealm, savePassword, pwd) {\\n+        resource._authFailed = true;\\n+        return false;\\n+      }\\n+    };\\n+  },\\n+\\n+  // nsIPrompt\\n+\\n+  get prompt() {\\n+    var resource = this;\\n+    return {\\n+      QueryInterface: XPCOMUtils.generateQI([Ci.nsIPrompt]),\\n+      alert: function(dialogTitle, text) {\\n+        throw Cr.NS_ERROR_NOT_IMPLEMENTED;\\n+      },\\n+      alertCheck: function(dialogTitle, text, checkMessage, checkValue) {\\n+        throw Cr.NS_ERROR_NOT_IMPLEMENTED;\\n+      },\\n+      confirm: function(dialogTitle, text) {\\n+        throw Cr.NS_ERROR_NOT_IMPLEMENTED;\\n+      },\\n+      confirmCheck: function(dialogTitle, text, checkMessage, checkValue) {\\n+        throw Cr.NS_ERROR_NOT_IMPLEMENTED;\\n+      },\\n+      confirmEx: function(dialogTitle, text, buttonFlags, button0Title, button1Title, button2Title, checkMsg, checkValue) {\\n+        throw Cr.NS_ERROR_NOT_IMPLEMENTED;\\n+      },\\n+      prompt: function(dialogTitle, text, value, checkMsg, checkValue) {\\n+        throw Cr.NS_ERROR_NOT_IMPLEMENTED;\\n+      },\\n+      promptPassword: function(dialogTitle, text, password, checkMsg, checkValue) {\\n+        resource._authFailed = true;\\n+        return false;\\n+      },\\n+      promptUsernameAndPassword: function(dialogTitle, text, username, password, checkMsg, checkValue) {\\n+        resource._authFailed = true;\\n+        return false;\\n+      },\\n+      select: function(dialogTitle, text, count, selectList, outSelection) {\\n+        throw Cr.NS_ERROR_NOT_IMPLEMENTED;\\n+      }\\n+    };\\n+  }\\n+};\\n \\n function NSGetModule(compMgr, fileSpec) {\\n   return XPCOMUtils.generateModule([BookmarksSyncService]);\\ndiff --git a/services/sync/services-sync.js b/services/sync/services-sync.js\\nindex aaa6ec2..7c58c37 100644\\n--- a/services/sync/services-sync.js\\n+++ b/services/sync/services-sync.js\\n@@ -1,4 +1,5 @@\\n-pref(\\\"browser.places.sync.serverUrl\\\", \\\"http://places.sync.url/\\\");\\n+pref(\\\"browser.places.sync.serverURL\\\", \\\"http://dotmoz.mozilla.org/\\\");\\n+pref(\\\"browser.places.sync.username\\\", \\\"nobody@mozilla.com\\\");\\n pref(\\\"extensions.sync.lastversion\\\", \\\"firstrun\\\");\\n pref(\\\"extensions.sync.lastsync\\\", \\\"\\\");\\n \\n\""}