{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basfcc561e\""},"diff":"\"fcc561e Bug 92543 - BandRect.mFrames should be created as an nsAutoVoidArray p=alfredkayser@nl.ibm.com (Alfred Kayser) r+sr=roc@ocallahan.org (Robert O'Callahan) a=dbaron@mozilla.com (David Baron)\\ndiff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp\\nindex 0bda370..60eaf1a 100644\\n--- a/layout/base/nsPresShell.cpp\\n+++ b/layout/base/nsPresShell.cpp\\n@@ -6605,7 +6605,7 @@ CompareTrees(nsPresContext* aFirstPresContext, nsIFrame* aFirstFrame,\\n                 for ( ;trapIndex<band1.mCount; trapIndex++)\\n                 {\\n                   PRBool match = (trap1[trapIndex].EqualGeometry(trap2[trapIndex])) && \\n-                    trap1[trapIndex].mState == trap2[trapIndex].mState;\\n+                    ((trap1[trapIndex].mFrame!=nsull) == (trap2[trapIndex].mFrame!=nsnull));\\n                   if (!match)\\n                   {\\n                     LogVerifyMessage(k1, k2, \\\"band.mTrapezoids of space managers differs\\\\n\\\");\\n@@ -6630,7 +6630,7 @@ CompareTrees(nsPresContext* aFirstPresContext, nsIFrame* aFirstFrame,\\n                 for ( ; trapIndex<band1.mCount; trapIndex++)\\n                 {\\n                   PRBool match = (trap1[trapIndex].EqualGeometry(trap2[trapIndex])) && \\n-                    trap1[trapIndex].mState == trap2[trapIndex].mState;\\n+                    ((trap1[trapIndex].mFrame!=nsull) == (trap2[trapIndex].mFrame!=nsnull));\\n                   if (!match)\\n                   {\\n                     LogVerifyMessage(k1, k2, \\\"band.mTrapezoids of space managers differs\\\\n\\\");\\ndiff --git a/layout/generic/nsBlockBandData.cpp b/layout/generic/nsBlockBandData.cpp\\nindex 339fc59..92fa689 100644\\n--- a/layout/generic/nsBlockBandData.cpp\\n+++ b/layout/generic/nsBlockBandData.cpp\\n@@ -183,28 +183,16 @@ nsBlockBandData::ComputeAvailSpaceRect()\\n     NS_PRECONDITION(mCount<=mSize, \\\"bad state, count > size\\\");\\n     for (i = 0; i < mCount; i++) {\\n       trapezoid = &mTrapezoids[i];\\n-      if (trapezoid->mState != nsBandTrapezoid::Available) {\\n+      if (trapezoid->mFrames) {\\n #ifdef REALLY_NOISY_COMPUTEAVAILSPACERECT\\n-        printf(\\\"band %p checking !Avail trap %p with frame %p\\\\n\\\", this, trapezoid, trapezoid->mFrame);\\n+        printf(\\\"band %p checking !Avail trap %p with frame %p\\\\n\\\", this, trapezoid, trapezoid->mFrames);\\n #endif\\n-        if (nsBandTrapezoid::OccupiedMultiple == trapezoid->mState) {\\n-          PRInt32 j, numFrames = trapezoid->mFrames->Count();\\n-          NS_ASSERTION(numFrames > 0, \\\"bad trapezoid frame list\\\");\\n-          for (j = 0; j < numFrames; j++) {\\n-            nsIFrame* f = (nsIFrame*) trapezoid->mFrames->ElementAt(j);\\n-            const nsStyleDisplay* display = f->GetStyleDisplay();\\n-            if (NS_STYLE_FLOAT_LEFT == display->mFloats) {\\n-              leftFloats++;\\n-            }\\n-            else if (NS_STYLE_FLOAT_RIGHT == display->mFloats) {\\n-              rightFloats++;\\n-              if ((nsnull == rightTrapezoid) && (i > 0)) {\\n-                rightTrapezoid = &mTrapezoids[i - 1];\\n-              }\\n-            }\\n-          }\\n-        } else {\\n-          const nsStyleDisplay* display = trapezoid->mFrame->GetStyleDisplay();\\n+        const nsSmallVoidArray* frames = trapezoid->mFrames;\\n+        const PRInt32 numFrames = frames->Count();\\n+        NS_ASSERTION(numFrames > 0, \\\"bad trapezoid frame list\\\");\\n+        for (PRInt32 j = 0; j < numFrames; j++) {\\n+          nsIFrame* f = (nsIFrame*) frames->ElementAt(j);\\n+          const nsStyleDisplay* display = f->GetStyleDisplay();\\n           if (NS_STYLE_FLOAT_LEFT == display->mFloats) {\\n             leftFloats++;\\n           }\\n@@ -218,7 +206,7 @@ nsBlockBandData::ComputeAvailSpaceRect()\\n       }\\n     }\\n   }\\n-  else if (mTrapezoids[0].mState != nsBandTrapezoid::Available) {\\n+  else if (mTrapezoids[0].mFrames) {\\n     // We have a float using up all the available space\\n     leftFloats = 1;\\n   }\\n@@ -238,28 +226,21 @@ nsBlockBandData::ComputeAvailSpaceRect()\\n \\n   // When there is no available space, we still need a proper X\\n   // coordinate to place objects that end up here anyway.\\n-  if (nsBandTrapezoid::Available != trapezoid->mState) {\\n-    if (nsBandTrapezoid::OccupiedMultiple == trapezoid->mState) {\\n-      // It's not clear what coordinate to use when there is no\\n-      // available space and the space is multiply occupied...So: If\\n-      // any of the floats that are a part of the trapezoid are left\\n-      // floats then we move over to the right edge of the\\n-      // unavaliable space.\\n-      PRInt32 j, numFrames = trapezoid->mFrames->Count();\\n-      NS_ASSERTION(numFrames > 0, \\\"bad trapezoid frame list\\\");\\n-      for (j = 0; j < numFrames; j++) {\\n-        nsIFrame* f = (nsIFrame*) trapezoid->mFrames->ElementAt(j);\\n-        const nsStyleDisplay* display = f->GetStyleDisplay();\\n-        if (NS_STYLE_FLOAT_LEFT == display->mFloats) {\\n-          mAvailSpace.x = mAvailSpace.XMost();\\n-          break;\\n-        }\\n-      }\\n-    }\\n-    else {\\n-      const nsStyleDisplay* display = trapezoid->mFrame->GetStyleDisplay();\\n+  const nsSmallVoidArray* frames = trapezoid->mFrames;\\n+  if (frames) {\\n+    // It's not clear what coordinate to use when there is no\\n+    // available space and the space is multiply occupied...So: If\\n+    // any of the floats that are a part of the trapezoid are left\\n+    // floats then we move over to the right edge of the\\n+    // unavaliable space.\\n+    const PRInt32 numFrames = frames->Count();\\n+    NS_ASSERTION(numFrames > 0, \\\"bad trapezoid frame list\\\");\\n+    for (PRInt32 j = 0; j < numFrames; j++) {\\n+      nsIFrame* f = (nsIFrame*) frames->ElementAt(j);\\n+      const nsStyleDisplay* display = f->GetStyleDisplay();\\n       if (NS_STYLE_FLOAT_LEFT == display->mFloats) {\\n         mAvailSpace.x = mAvailSpace.XMost();\\n+        break;\\n       }\\n     }\\n     mAvailSpace.width = 0;\\ndiff --git a/layout/generic/nsSpaceManager.cpp b/layout/generic/nsSpaceManager.cpp\\nindex 70f83d5..773788e 100644\\n--- a/layout/generic/nsSpaceManager.cpp\\n+++ b/layout/generic/nsSpaceManager.cpp\\n@@ -69,7 +69,6 @@ nsSpaceManager::BandList::BandList()\\n   : nsSpaceManager::BandRect(NSCOORD_MIN, NSCOORD_MIN, NSCOORD_MIN, NSCOORD_MIN, (nsIFrame*)nsnull)\\n {\\n   PR_INIT_CLIST(this);\\n-  mNumFrames = 0;\\n }\\n \\n void\\n@@ -276,8 +275,7 @@ nsSpaceManager::GetBandAvailableSpace(const BandRect* aBand,\\n         aBandData.mCount += 2 * aBand->Length() + 2;  // estimate the number needed\\n         return NS_ERROR_FAILURE;\\n       }\\n-      trapezoid->mState = nsBandTrapezoid::Available;\\n-      trapezoid->mFrame = nsnull;\\n+      trapezoid->mFrames = nsnull;\\n \\n       // Assign the trapezoid a rectangular shape. The trapezoid must be in the\\n       // local coordinate space, so convert the current left coordinate\\n@@ -294,14 +292,8 @@ nsSpaceManager::GetBandAvailableSpace(const BandRect* aBand,\\n       aBandData.mCount += 2 * aBand->Length() + 1;  // estimate the number needed\\n       return NS_ERROR_FAILURE;\\n     }\\n-    if (1 == aBand->mNumFrames) {\\n-      trapezoid->mState = nsBandTrapezoid::Occupied;\\n-      trapezoid->mFrame = aBand->mFrame;\\n-    } else {\\n-      NS_ASSERTION(aBand->mNumFrames > 1, \\\"unexpected frame count\\\");\\n-      trapezoid->mState = nsBandTrapezoid::OccupiedMultiple;\\n-      trapezoid->mFrames = aBand->mFrames;\\n-    }\\n+    NS_ASSERTION(aBand->mFrames.Count() > 0, \\\"unexpected frame count\\\");\\n+    trapezoid->mFrames = &aBand->mFrames;\\n \\n     nscoord x = aBand->mLeft;\\n     // The first band can straddle the clip rect\\n@@ -333,8 +325,7 @@ nsSpaceManager::GetBandAvailableSpace(const BandRect* aBand,\\n       aBandData.mCount++;\\n       return NS_ERROR_FAILURE;\\n     }\\n-    trapezoid->mState = nsBandTrapezoid::Available;\\n-    trapezoid->mFrame = nsnull;\\n+    trapezoid->mFrames = nsnull;\\n \\n     // Assign the trapezoid a rectangular shape. The trapezoid must be in the\\n     // local coordinate space, so convert the current left coordinate\\n@@ -366,8 +357,7 @@ nsSpaceManager::GetBandData(nscoord       aYOffset,\\n     // All the requested space is available\\n     aBandData.mCount = 1;\\n     aBandData.mTrapezoids[0] = nsRect(0, aYOffset, aMaxSize.width, maxHeight);\\n-    aBandData.mTrapezoids[0].mState = nsBandTrapezoid::Available;\\n-    aBandData.mTrapezoids[0].mFrame = nsnull;\\n+    aBandData.mTrapezoids[0].mFrames = nsnull;\\n   } else {\\n     // Find the first band that contains the y-offset or is below the y-offset\\n     BandRect* band = GuessBandWithTopAbove(y);\\n@@ -380,8 +370,7 @@ nsSpaceManager::GetBandData(nscoord       aYOffset,\\n         aBandData.mCount = 1;\\n         aBandData.mTrapezoids[0] =\\n           nsRect(0, aYOffset, aMaxSize.width, PR_MIN(band->mTop - y, maxHeight));\\n-        aBandData.mTrapezoids[0].mState = nsBandTrapezoid::Available;\\n-        aBandData.mTrapezoids[0].mFrame = nsnull;\\n+        aBandData.mTrapezoids[0].mFrames = nsnull;\\n         break;\\n       } else if (y < band->mBottom) {\\n         // The band contains the y-offset. Return a list of available and\\n@@ -584,7 +573,7 @@ nsSpaceManager::AddRectToBand(BandRect* aBand, BandRect* aBandRect)\\n {\\n   NS_PRECONDITION((aBand->mTop == aBandRect->mTop) &&\\n                   (aBand->mBottom == aBandRect->mBottom), \\\"bad band\\\");\\n-  NS_PRECONDITION(1 == aBandRect->mNumFrames, \\\"shared band rect\\\");\\n+  NS_PRECONDITION(1 == aBandRect.mFrames.Count(), \\\"shared band rect\\\");\\n   nscoord topOfBand = aBand->mTop;\\n \\n   // Figure out where in the band horizontally to insert the rect\\n@@ -651,7 +640,7 @@ nsSpaceManager::AddRectToBand(BandRect* aBand, BandRect* aBandRect)\\n         }\\n \\n         // Mark the existing rect as shared\\n-        aBand->AddFrame(aBandRect->mFrame);\\n+        aBand->AddFrame(aBandRect->FrameAt(0));\\n         return;\\n       }\\n     }\\n@@ -701,12 +690,12 @@ nsSpaceManager::AddRectToBand(BandRect* aBand, BandRect* aBandRect)\\n       aBand->InsertAfter(r1);\\n \\n       // Mark the overlap as being shared\\n-      aBand->AddFrame(aBandRect->mFrame);\\n+      aBand->AddFrame(aBandRect->FrameAt(0));\\n       return;\\n \\n     } else {\\n       // Indicate the frames share the existing rect\\n-      aBand->AddFrame(aBandRect->mFrame);\\n+      aBand->AddFrame(aBandRect->FrameAt(0));\\n \\n       if (aBand->mRight == aBandRect->mRight) {\\n         // The new and existing rect have the same right edge. We're all done,\\n@@ -789,7 +778,7 @@ nsSpaceManager::InsertBandRect(BandRect* aBandRect)\\n       // the part that's above the band\\n       BandRect* bandRect1 = new BandRect(aBandRect->mLeft, aBandRect->mTop,\\n                                          aBandRect->mRight, band->mTop,\\n-                                         aBandRect->mFrame);\\n+                                         aBandRect->mFrames);\\n \\n       // Insert bandRect1 as a new band\\n       band->InsertBefore(bandRect1);\\n@@ -835,7 +824,7 @@ nsSpaceManager::InsertBandRect(BandRect* aBandRect)\\n       // the rect, creating a new rect for the part that overlaps the band\\n       BandRect* bandRect1 = new BandRect(aBandRect->mLeft, aBandRect->mTop,\\n                                          aBandRect->mRight, band->mBottom,\\n-                                         aBandRect->mFrame);\\n+                                         aBandRect->mFrames);\\n \\n       // Add bandRect1 to the band\\n       AddRectToBand(band, bandRect1);\\n@@ -952,9 +941,9 @@ nsSpaceManager::RemoveRegion(nsIFrame* aFrame)\\n           // Remember that we found a matching rect in this band\\n           foundMatchingRect = PR_TRUE;\\n \\n-          if (rect->mNumFrames > 1) {\\n+          if (rect->mFrames.Count() > 1) {\\n             // The band rect is occupied by more than one frame\\n-            rect->RemoveFrame(aFrame);\\n+            rect->mFrames.RemoveElement(aFrame);\\n \\n             // Remember that this rect was being shared by more than one frame\\n             // including aFrame\\n@@ -1156,33 +1145,19 @@ nsSpaceManager::List(FILE* out)\\n   else {\\n     BandRect* band = mBandList.Head();\\n     do {\\n-      fprintf(out, \\\"  left=%d top=%d right=%d bottom=%d numFrames=%d\\\",\\n-              band->mLeft, band->mTop, band->mRight, band->mBottom,\\n-              band->mNumFrames);\\n-      if (1 == band->mNumFrames) {\\n-        nsIFrameDebug*  frameDebug;\\n-\\n-        if (NS_SUCCEEDED(band->mFrame->QueryInterface(NS_GET_IID(nsIFrameDebug), (void**)&frameDebug))) {\\n-          frameDebug->GetFrameName(tmp);\\n-          fprintf(out, \\\" frame=\\\");\\n-          fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);\\n-          fprintf(out, \\\"@%p\\\", band->mFrame);\\n-        }\\n-      }\\n-      else if (1 < band->mNumFrames) {\\n-        fprintf(out, \\\"\\\\n    \\\");\\n-        nsVoidArray* a = band->mFrames;\\n-        PRInt32 i, n = a->Count();\\n-        for (i = 0; i < n; i++) {\\n-          nsIFrame* frame = (nsIFrame*) a->ElementAt(i);\\n-          if (frame) {\\n-            nsIFrameDebug*  frameDebug;\\n-\\n-            if (NS_SUCCEEDED(frame->QueryInterface(NS_GET_IID(nsIFrameDebug), (void**)&frameDebug))) {\\n-              frameDebug->GetFrameName(tmp);\\n-              fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);\\n-              fprintf(out, \\\"@%p \\\", frame);\\n-            }\\n+      PRInt32 const n = band->mFrames.Count();\\n+      fprintf(out, \\\"  left=%d top=%d right=%d bottom=%d count=%d frames=\\\",\\n+              band->mLeft, band->mTop, band->mRight, band->mBottom, n);\\n+\\n+      for (PRInt32 i = 0; i < n; i++) {\\n+        nsIFrame* frame = (nsIFrame*)band->mFrames.FastElementAt(i);\\n+        if (frame) {\\n+          nsIFrameDebug*  frameDebug;\\n+\\n+\\t\\t  if (NS_SUCCEEDED(frame->QueryInterface(NS_GET_IID(nsIFrameDebug), (void**)&frameDebug))) {\\n+            frameDebug->GetFrameName(tmp);\\n+            fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);\\n+            fprintf(out, \\\"@%p \\\", frame);\\n           }\\n         }\\n       }\\n@@ -1387,32 +1362,26 @@ nsSpaceManager::BandRect::BandRect(nscoord    aLeft,\\n   mTop = aTop;\\n   mRight = aRight;\\n   mBottom = aBottom;\\n-  mFrame = aFrame;\\n-  mNumFrames = 1;\\n+  AddFrame(aFrame);\\n }\\n \\n nsSpaceManager::BandRect::BandRect(nscoord      aLeft,\\n                                    nscoord      aTop,\\n                                    nscoord      aRight,\\n                                    nscoord      aBottom,\\n-                                   nsVoidArray* aFrames)\\n+                                   nsSmallVoidArray& aFrames)\\n {\\n   MOZ_COUNT_CTOR(BandRect);\\n   mLeft = aLeft;\\n   mTop = aTop;\\n   mRight = aRight;\\n   mBottom = aBottom;\\n-  mFrames = new nsVoidArray;\\n-  mFrames->operator=(*aFrames);\\n-  mNumFrames = mFrames->Count();\\n+  mFrames = aFrames;\\n }\\n \\n nsSpaceManager::BandRect::~BandRect()\\n {\\n   MOZ_COUNT_DTOR(BandRect);\\n-  if (mNumFrames > 1) {\\n-    delete mFrames;\\n-  }\\n }\\n \\n nsSpaceManager::BandRect*\\n@@ -1421,13 +1390,7 @@ nsSpaceManager::BandRect::SplitVertically(nscoord aBottom)\\n   NS_PRECONDITION((aBottom > mTop) && (aBottom < mBottom), \\\"bad argument\\\");\\n \\n   // Create a new band rect for the bottom part\\n-  BandRect* bottomBandRect;\\n-                                            \\n-  if (mNumFrames > 1) {\\n-    bottomBandRect = new BandRect(mLeft, aBottom, mRight, mBottom, mFrames);\\n-  } else {\\n-    bottomBandRect = new BandRect(mLeft, aBottom, mRight, mBottom, mFrame);\\n-  }\\n+  BandRect* bottomBandRect = new BandRect(mLeft, aBottom, mRight, mBottom, mFrames);\\n                                            \\n   // This band rect becomes the top part, so adjust the bottom edge\\n   mBottom = aBottom;\\n@@ -1440,13 +1403,7 @@ nsSpaceManager::BandRect::SplitHorizontally(nscoord aRight)\\n   NS_PRECONDITION((aRight > mLeft) && (aRight < mRight), \\\"bad argument\\\");\\n   \\n   // Create a new band rect for the right part\\n-  BandRect* rightBandRect;\\n-                                            \\n-  if (mNumFrames > 1) {\\n-    rightBandRect = new BandRect(aRight, mTop, mRight, mBottom, mFrames);\\n-  } else {\\n-    rightBandRect = new BandRect(aRight, mTop, mRight, mBottom, mFrame);\\n-  }\\n+  BandRect* rightBandRect = new BandRect(aRight, mTop, mRight, mBottom, mFrames);\\n                                            \\n   // This band rect becomes the left part, so adjust the right edge\\n   mRight = aRight;\\n@@ -1456,76 +1413,32 @@ nsSpaceManager::BandRect::SplitHorizontally(nscoord aRight)\\n PRBool\\n nsSpaceManager::BandRect::IsOccupiedBy(const nsIFrame* aFrame) const\\n {\\n-  PRBool  result;\\n+  const PRInt32 count = mFrames.Count();\\n \\n-  if (1 == mNumFrames) {\\n-    result = (mFrame == aFrame);\\n-  } else {\\n-    PRInt32 count = mFrames->Count();\\n-\\n-    result = PR_FALSE;\\n-    for (PRInt32 i = 0; i < count; i++) {\\n-      nsIFrame* f = (nsIFrame*)mFrames->ElementAt(i);\\n-\\n-      if (f == aFrame) {\\n-        result = PR_TRUE;\\n-        break;\\n-      }\\n-    }\\n+  for (PRInt32 i = 0; i < count; i++) {\\n+    if ((nsIFrame*)mFrames.FastElementAt(i) == aFrame)\\n+      return PR_TRUE;\\n   }\\n \\n-  return result;\\n-}\\n-\\n-void\\n-nsSpaceManager::BandRect::AddFrame(const nsIFrame* aFrame)\\n-{\\n-  if (1 == mNumFrames) {\\n-    nsIFrame* f = mFrame;\\n-    mFrames = new nsVoidArray;\\n-    mFrames->AppendElement(f);\\n-  }\\n-\\n-  mNumFrames++;\\n-  mFrames->AppendElement((void*)aFrame);\\n-  NS_POSTCONDITION(mFrames->Count() == mNumFrames, \\\"bad frame count\\\");\\n-}\\n-\\n-void\\n-nsSpaceManager::BandRect::RemoveFrame(const nsIFrame* aFrame)\\n-{\\n-  NS_PRECONDITION(mNumFrames > 1, \\\"only one frame\\\");\\n-  mFrames->RemoveElement((void*)aFrame);\\n-  mNumFrames--;\\n-\\n-  if (1 == mNumFrames) {\\n-    nsIFrame* f = (nsIFrame*)mFrames->ElementAt(0);\\n-\\n-    delete mFrames;\\n-    mFrame = f;\\n-  }\\n+  return PR_FALSE;\\n }\\n \\n PRBool\\n nsSpaceManager::BandRect::HasSameFrameList(const BandRect* aBandRect) const\\n {\\n+  const PRInt32 count = mFrames.Count();\\n   PRBool  result;\\n \\n   // Check whether they're occupied by the same number of frames\\n-  if (mNumFrames != aBandRect->mNumFrames) {\\n+  if (count != aBandRect->mFrames.Count()) {\\n     result = PR_FALSE;\\n-  } else if (1 == mNumFrames) {\\n-    result = (mFrame == aBandRect->mFrame);\\n   } else {\\n     result = PR_TRUE;\\n \\n     // For each frame occupying this band rect check whether it also occupies\\n     // aBandRect\\n-    PRInt32 count = mFrames->Count();\\n     for (PRInt32 i = 0; i < count; i++) {\\n-      nsIFrame* f = (nsIFrame*)mFrames->ElementAt(i);\\n-\\n-      if (-1 == aBandRect->mFrames->IndexOf(f)) {\\n+      if (-1 == aBandRect->mFrames.IndexOf(mFrames.FastElementAt(i))) {\\n         result = PR_FALSE;\\n         break;\\n       }\\ndiff --git a/layout/generic/nsSpaceManager.h b/layout/generic/nsSpaceManager.h\\nindex b312ea2..faa48f5 100644\\n--- a/layout/generic/nsSpaceManager.h\\n+++ b/layout/generic/nsSpaceManager.h\\n@@ -49,10 +49,10 @@\\n #include \\\"nsISupports.h\\\"\\n #include \\\"nsCoord.h\\\"\\n #include \\\"nsRect.h\\\"\\n+#include \\\"nsVoidArray.h\\\"\\n \\n class nsIPresShell;\\n class nsIFrame;\\n-class nsVoidArray;\\n struct nsSize;\\n struct nsHTMLReflowState;\\n class nsPresContext;\\n@@ -69,16 +69,10 @@ class nsPresContext;\\n  * </ul>\\n  */\\n struct nsBandTrapezoid {\\n-  enum State {Available, Occupied, OccupiedMultiple};\\n-\\n   nscoord   mTopY, mBottomY;            // top and bottom y-coordinates\\n   nscoord   mTopLeftX, mBottomLeftX;    // left edge x-coordinates\\n   nscoord   mTopRightX, mBottomRightX;  // right edge x-coordinates\\n-  State     mState;                     // state of the space\\n-  union {\\n-    nsIFrame*          mFrame;  // single frame occupying the space\\n-    const nsVoidArray* mFrames; // list of frames occupying the space\\n-  };\\n+  const nsSmallVoidArray* mFrames; // list of frames occupying the space\\n \\n   // Get the height of the trapezoid\\n   nscoord GetHeight() const {return mBottomY - mTopY;}\\n@@ -89,9 +83,6 @@ struct nsBandTrapezoid {\\n   // Set the trapezoid from a rectangle\\n   inline void operator=(const nsRect& aRect);\\n \\n-  // Do these trapezoids have the same geometry, frame, and state?\\n-  inline PRBool Equals(const nsBandTrapezoid& aTrap) const;\\n-\\n   // Do these trapezoids have the same geometry?\\n   inline PRBool EqualGeometry(const nsBandTrapezoid& aTrap) const;\\n \\n@@ -102,7 +93,7 @@ struct nsBandTrapezoid {\\n       mBottomLeftX(0),\\n       mTopRightX(0),\\n       mBottomRightX(0),\\n-      mFrame(nsnull)\\n+      mFrames(nsnull)\\n   {\\n   }\\n };\\n@@ -126,20 +117,6 @@ inline void nsBandTrapezoid::operator=(const nsRect& aRect)\\n   mBottomY = aRect.YMost();\\n }\\n \\n-inline PRBool nsBandTrapezoid::Equals(const nsBandTrapezoid& aTrap) const\\n-{\\n-  return (\\n-    mTopLeftX == aTrap.mTopLeftX &&\\n-    mBottomLeftX == aTrap.mBottomLeftX &&\\n-    mTopRightX == aTrap.mTopRightX &&\\n-    mBottomRightX == aTrap.mBottomRightX &&\\n-    mTopY == aTrap.mTopY &&\\n-    mBottomY == aTrap.mBottomY &&\\n-    mState == aTrap.mState &&\\n-    mFrame == aTrap.mFrame    \\n-  );\\n-}\\n-\\n inline PRBool nsBandTrapezoid::EqualGeometry(const nsBandTrapezoid& aTrap) const\\n {\\n   return (\\n@@ -377,18 +354,14 @@ public:\\n   struct BandRect : PRCListStr {\\n     nscoord   mLeft, mTop;\\n     nscoord   mRight, mBottom;\\n-    PRInt32   mNumFrames;    // number of frames occupying this rect\\n-    union {\\n-      nsIFrame*    mFrame;   // single frame occupying the space\\n-      nsVoidArray* mFrames;  // list of frames occupying the space\\n-    };\\n+    nsSmallVoidArray mFrames;  // list of frames occupying the space\\n \\n     BandRect(nscoord aLeft, nscoord aTop,\\n              nscoord aRight, nscoord aBottom,\\n-             nsIFrame*);\\n+             nsIFrame* aFrame);\\n     BandRect(nscoord aLeft, nscoord aTop,\\n              nscoord aRight, nscoord aBottom,\\n-             nsVoidArray*);\\n+             nsSmallVoidArray& frames);\\n     ~BandRect();\\n \\n     // List operations\\n@@ -414,8 +387,15 @@ public:\\n \\n     // Accessor functions\\n     PRBool  IsOccupiedBy(const nsIFrame*) const;\\n-    void    AddFrame(const nsIFrame*);\\n-    void    RemoveFrame(const nsIFrame*);\\n+    void    AddFrame(const nsIFrame* aFrame) {\\n+      mFrames.AppendElement((void*)aFrame);\\n+    }\\n+    void    RemoveFrame(const nsIFrame* aFrame) {\\n+      mFrames.RemoveElement((void*)aFrame);\\n+    }\\n+    nsIFrame * FrameAt(PRInt32 index) {\\n+      return static_cast<nsIFrame*>(mFrames.FastElementAt(index));\\n+    }\\n     PRBool  HasSameFrameList(const BandRect* aBandRect) const;\\n     PRInt32 Length() const;\\n   };\\n\""}