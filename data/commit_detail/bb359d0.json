{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basbb359d0\""},"diff":"\"bb359d0 Bug 396744 - crash [@nsAccessilbe::GetFinalState] with moving select, option and optgroup with display: none, r=aaronlev, a=dsicore\\ndiff --git a/accessible/src/base/nsAccessible.cpp b/accessible/src/base/nsAccessible.cpp\\nindex 5ac236f..897fcd9 100644\\n--- a/accessible/src/base/nsAccessible.cpp\\n+++ b/accessible/src/base/nsAccessible.cpp\\n@@ -2301,72 +2301,84 @@ nsAccessible::GetFinalState(PRUint32 *aState, PRUint32 *aExtraState)\\n   *aState |= GetARIAState();\\n \\n   // Set additional states which presence depends on another states.\\n-  if (aExtraState) {\\n-    if (!(*aState & nsIAccessibleStates::STATE_UNAVAILABLE)) {\\n-      *aExtraState |= nsIAccessibleStates::EXT_STATE_ENABLED |\\n-                      nsIAccessibleStates::EXT_STATE_SENSITIVE;\\n-    }\\n-\\n-    const PRUint32 kExpandCollapseStates =\\n-      nsIAccessibleStates::STATE_COLLAPSED | nsIAccessibleStates::STATE_EXPANDED;\\n-    if (*aState & kExpandCollapseStates) {\\n-      *aExtraState |= nsIAccessibleStates::EXT_STATE_EXPANDABLE;\\n-      if ((*aState & kExpandCollapseStates) == kExpandCollapseStates) {\\n-        // Cannot be both expanded and collapsed -- this happens \\n-        // in ARIA expanded combobox because of limitation of nsARIAMap\\n-        // XXX Perhaps we will be able to make this less hacky if \\n-        // we support extended states in nsARIAMap, e.g. derive\\n-        // COLLAPSED from EXPANDABLE && !EXPANDED\\n-        *aExtraState &= ~nsIAccessibleStates::STATE_COLLAPSED;\\n-      } \\n+  if (!aExtraState)\\n+    return NS_OK;\\n+\\n+  if (!(*aState & nsIAccessibleStates::STATE_UNAVAILABLE)) {\\n+    *aExtraState |= nsIAccessibleStates::EXT_STATE_ENABLED |\\n+                    nsIAccessibleStates::EXT_STATE_SENSITIVE;\\n+  }\\n+\\n+  const PRUint32 kExpandCollapseStates =\\n+    nsIAccessibleStates::STATE_COLLAPSED | nsIAccessibleStates::STATE_EXPANDED;\\n+  if (*aState & kExpandCollapseStates) {\\n+    *aExtraState |= nsIAccessibleStates::EXT_STATE_EXPANDABLE;\\n+    if ((*aState & kExpandCollapseStates) == kExpandCollapseStates) {\\n+      // Cannot be both expanded and collapsed -- this happens \\n+      // in ARIA expanded combobox because of limitation of nsARIAMap\\n+      // XXX Perhaps we will be able to make this less hacky if \\n+      // we support extended states in nsARIAMap, e.g. derive\\n+      // COLLAPSED from EXPANDABLE && !EXPANDED\\n+      *aExtraState &= ~nsIAccessibleStates::STATE_COLLAPSED;\\n     }\\n-    nsIFrame *frame = GetFrame();\\n-    if (frame) {\\n-      const nsStyleDisplay* display = frame->GetStyleDisplay();\\n-      if (display && display->mOpacity == 1.0f &&\\n-          !(*aState & nsIAccessibleStates::STATE_INVISIBLE)) {\\n-        *aExtraState |= nsIAccessibleStates::EXT_STATE_OPAQUE;\\n-      }\\n+  }\\n \\n-      const nsStyleXUL *xulStyle = frame->GetStyleXUL();\\n-      if (xulStyle) {\\n-        // In XUL all boxes are either vertical or horizontal\\n-        if (xulStyle->mBoxOrient == NS_STYLE_BOX_ORIENT_VERTICAL) {\\n-          *aExtraState |= nsIAccessibleStates::EXT_STATE_VERTICAL;\\n-        }\\n-        else {\\n-          *aExtraState |= nsIAccessibleStates::EXT_STATE_HORIZONTAL;\\n-        }\\n-      }\\n+  PRUint32 role;\\n+  rv = GetFinalRole(&role);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  if (role == nsIAccessibleRole::ROLE_ENTRY ||\\n+      role == nsIAccessibleRole::ROLE_PASSWORD_TEXT ||\\n+      role == nsIAccessibleRole::ROLE_COMBOBOX) {\\n+\\n+    nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));\\n+    NS_ENSURE_STATE(content);\\n+\\n+    nsAutoString autocomplete;\\n+    if (content->GetAttr(kNameSpaceID_WAIProperties,\\n+                         nsAccessibilityAtoms::autocomplete, autocomplete) &&\\n+        (autocomplete.EqualsIgnoreCase(\\\"inline\\\") ||\\n+         autocomplete.EqualsIgnoreCase(\\\"list\\\") ||\\n+         autocomplete.EqualsIgnoreCase(\\\"both\\\"))) {\\n+      *aExtraState |= nsIAccessibleStates::EXT_STATE_SUPPORTS_AUTOCOMPLETION;\\n     }\\n \\n-    PRUint32 role;\\n-    GetFinalRole(&role);\\n-    if (role == nsIAccessibleRole::ROLE_ENTRY ||\\n-        role == nsIAccessibleRole::ROLE_PASSWORD_TEXT ||\\n-        role == nsIAccessibleRole::ROLE_COMBOBOX) {\\n-      nsIContent *content = frame->GetContent();\\n-      NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);\\n-      nsAutoString autocomplete;\\n-      if (content->GetAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::autocomplete, autocomplete) &&\\n-          (autocomplete.EqualsIgnoreCase(\\\"inline\\\") ||\\n-           autocomplete.EqualsIgnoreCase(\\\"list\\\") ||\\n-           autocomplete.EqualsIgnoreCase(\\\"both\\\"))) {\\n-        *aExtraState |= nsIAccessibleStates::EXT_STATE_SUPPORTS_AUTOCOMPLETION;\\n+    // XXX We can remove this hack once we support RDF-based role & state maps\\n+    if (mRoleMapEntry && mRoleMapEntry->role == nsIAccessibleRole::ROLE_ENTRY) {\\n+      if (content->AttrValueIs(kNameSpaceID_WAIProperties,\\n+                               nsAccessibilityAtoms::multiline,\\n+                               nsAccessibilityAtoms::_true, eCaseMatters)) {\\n+        *aExtraState |= nsIAccessibleStates::EXT_STATE_MULTI_LINE;\\n       }\\n-      // XXX We can remove this hack once we support RDF-based role & state maps\\n-      if (mRoleMapEntry && mRoleMapEntry->role == nsIAccessibleRole::ROLE_ENTRY) {\\n-        if (content->AttrValueIs(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::multiline,\\n-                                 nsAccessibilityAtoms::_true, eCaseMatters)) {\\n-          *aExtraState |= nsIAccessibleStates::EXT_STATE_MULTI_LINE;\\n-        }\\n-        else {\\n-          *aExtraState |= nsIAccessibleStates::EXT_STATE_SINGLE_LINE;\\n-        }\\n+      else {\\n+        *aExtraState |= nsIAccessibleStates::EXT_STATE_SINGLE_LINE;\\n       }\\n     }\\n   }\\n \\n+  // For some reasons DOM node may have not a frame. We tract such accessibles\\n+  // as invisible.\\n+  nsIFrame *frame = GetFrame();\\n+  if (!frame)\\n+    return NS_OK;\\n+\\n+  const nsStyleDisplay* display = frame->GetStyleDisplay();\\n+  if (display && display->mOpacity == 1.0f &&\\n+      !(*aState & nsIAccessibleStates::STATE_INVISIBLE)) {\\n+    *aExtraState |= nsIAccessibleStates::EXT_STATE_OPAQUE;\\n+  }\\n+\\n+  const nsStyleXUL *xulStyle = frame->GetStyleXUL();\\n+  if (xulStyle) {\\n+    // In XUL all boxes are either vertical or horizontal\\n+    if (xulStyle->mBoxOrient == NS_STYLE_BOX_ORIENT_VERTICAL) {\\n+      *aExtraState |= nsIAccessibleStates::EXT_STATE_VERTICAL;\\n+    }\\n+    else {\\n+      *aExtraState |= nsIAccessibleStates::EXT_STATE_HORIZONTAL;\\n+    }\\n+  }\\n+\\n   return NS_OK;\\n }\\n \\n\""}