{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas08651ae\""},"diff":"\"08651ae Bug 372453 - XULRunner apps on mac without a hiddenwindow should be able to quit r=benjamin@smedbergs.us r=joshmoz@gmail.com a=bzbarsky@mit.edu\\ndiff --git a/toolkit/components/startup/src/nsAppStartup.cpp b/toolkit/components/startup/src/nsAppStartup.cpp\\nindex 6ec6fa5..b91b7a2 100644\\n--- a/toolkit/components/startup/src/nsAppStartup.cpp\\n+++ b/toolkit/components/startup/src/nsAppStartup.cpp\\n@@ -207,9 +207,33 @@ nsAppStartup::Quit(PRUint32 aMode)\\n   if (!mRestart) \\n     mRestart = aMode & eRestart;\\n \\n-  if (ferocity == eConsiderQuit && mConsiderQuitStopper == 0) {\\n-    // attempt quit if the last window has been unregistered/closed\\n-    ferocity = eAttemptQuit;\\n+  // If we're considering quitting, we will only do so if:\\n+  if (ferocity == eConsiderQuit) {\\n+    if (mConsiderQuitStopper == 0) {\\n+      // there are no windows...\\n+      ferocity = eAttemptQuit;\\n+    }\\n+#ifdef XP_MACOSX\\n+    else if (mConsiderQuitStopper == 1) {\\n+      // ... or there is only a hiddenWindow left, and it's useless:\\n+      nsCOMPtr<nsIAppShellService> appShell\\n+        (do_GetService(NS_APPSHELLSERVICE_CONTRACTID));\\n+\\n+      // Failure shouldn't be fatal, but will abort quit attempt:\\n+      if (!appShell)\\n+        return NS_OK;\\n+\\n+      PRBool usefulHiddenWindow;\\n+      appShell->GetApplicationProvidedHiddenWindow(&usefulHiddenWindow);\\n+      nsCOMPtr<nsIXULWindow> hiddenWindow;\\n+      appShell->GetHiddenWindow(getter_AddRefs(hiddenWindow));\\n+      // If the one window is useful, we won't quit:\\n+      if (!hiddenWindow || usefulHiddenWindow)\\n+        return NS_OK;\\n+\\n+      ferocity = eAttemptQuit;\\n+    }\\n+#endif\\n   }\\n \\n   /* Currently ferocity can never have the value of eForceQuit here.\\n@@ -369,8 +393,13 @@ nsAppStartup::ExitLastWindowClosingSurvivalArea(void)\\n   NS_ASSERTION(mConsiderQuitStopper > 0, \\\"consider quit stopper out of bounds\\\");\\n   --mConsiderQuitStopper;\\n \\n-  if (!mShuttingDown && mRunning && mConsiderQuitStopper == 0)\\n-    Quit(eAttemptQuit);\\n+#ifdef XP_MACOSX\\n+  if (!mShuttingDown && mRunning && (mConsiderQuitStopper <= 1))\\n+    Quit(eConsiderQuit);\\n+#else\\n+  if (!mShuttingDown && mRunning && (mConsiderQuitStopper == 0))\\n+    Quit(eConsiderQuit);\\n+#endif\\n \\n   return NS_OK;\\n }\\ndiff --git a/xpfe/appshell/public/nsIAppShellService.idl b/xpfe/appshell/public/nsIAppShellService.idl\\nindex 65416fb..e5b5c98 100644\\n--- a/xpfe/appshell/public/nsIAppShellService.idl\\n+++ b/xpfe/appshell/public/nsIAppShellService.idl\\n@@ -111,6 +111,13 @@ interface nsIAppShellService : nsISupports\\n                                    out JSContext aJSContext);\\n \\n   /**\\n+   * Return true if the application hidden window was provided by the\\n+   * application. If it wasn't, the default hidden window was used. This will\\n+   * usually be false on all non-mac platforms.\\n+   */\\n+  readonly attribute boolean applicationProvidedHiddenWindow;\\n+\\n+  /**\\n    * Add a window to the application's registry of windows.  These windows\\n    * are generally shown in the Windows taskbar, and the application\\n    * knows it can't quit until it's out of registered windows.\\ndiff --git a/xpfe/appshell/src/nsAppShellService.cpp b/xpfe/appshell/src/nsAppShellService.cpp\\nindex 6b0bdf0..11e3c82 100644\\n--- a/xpfe/appshell/src/nsAppShellService.cpp\\n+++ b/xpfe/appshell/src/nsAppShellService.cpp\\n@@ -84,7 +84,8 @@ class nsIAppShell;\\n \\n nsAppShellService::nsAppShellService() : \\n   mXPCOMShuttingDown(PR_FALSE),\\n-  mModalWindowCount(0)\\n+  mModalWindowCount(0),\\n+  mApplicationProvidedHiddenWindow(PR_FALSE)\\n {\\n   nsCOMPtr<nsIObserverService> obs\\n     (do_GetService(\\\"@mozilla.org/observer-service;1\\\"));\\n@@ -162,6 +163,7 @@ nsAppShellService::CreateHiddenWindow(nsIAppShell* aAppShell)\\n   nsXPIDLCString prefVal;\\n   rv = prefBranch->GetCharPref(\\\"browser.hiddenWindowChromeURL\\\", getter_Copies(prefVal));\\n   const char* hiddenWindowURL = prefVal.get() ? prefVal.get() : DEFAULT_HIDDENWINDOW_URL;\\n+  mApplicationProvidedHiddenWindow = prefVal.get() ? PR_TRUE : PR_FALSE;\\n #else\\n   static const char hiddenWindowURL[] = DEFAULT_HIDDENWINDOW_URL;\\n   PRUint32    chromeMask =  nsIWebBrowserChrome::CHROME_ALL;\\n@@ -446,6 +448,13 @@ nsAppShellService::GetHiddenWindowAndJSContext(nsIDOMWindowInternal **aWindow,\\n     return rv;\\n }\\n \\n+NS_IMETHODIMP\\n+nsAppShellService::GetApplicationProvidedHiddenWindow(PRBool* aAPHW)\\n+{\\n+    *aAPHW = mApplicationProvidedHiddenWindow;\\n+    return NS_OK;\\n+}\\n+\\n /*\\n  * Register a new top level window (created elsewhere)\\n  */\\ndiff --git a/xpfe/appshell/src/nsAppShellService.h b/xpfe/appshell/src/nsAppShellService.h\\nindex ee31907..de8d996 100644\\n--- a/xpfe/appshell/src/nsAppShellService.h\\n+++ b/xpfe/appshell/src/nsAppShellService.h\\n@@ -76,6 +76,7 @@ protected:\\n   nsRefPtr<nsWebShellWindow>  mHiddenWindow;\\n   PRPackedBool                mXPCOMShuttingDown;\\n   PRUint16                    mModalWindowCount;\\n+  PRPackedBool                mApplicationProvidedHiddenWindow;\\n };\\n \\n #endif\\n\""}