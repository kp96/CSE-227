{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas93dbb94\""},"diff":"\"93dbb94 Implement an iterator hook for cross origin wrappers to avoid wrongly walking up the prototype chain during enumeration. bug 390947, r+a=brendan sr=jst\\ndiff --git a/js/src/jsapi.c b/js/src/jsapi.c\\nindex 429c480..1e36f2e 100644\\n--- a/js/src/jsapi.c\\n+++ b/js/src/jsapi.c\\n@@ -65,6 +65,7 @@\\n #include \\\"jsfun.h\\\"\\n #include \\\"jsgc.h\\\"\\n #include \\\"jsinterp.h\\\"\\n+#include \\\"jsiter.h\\\"\\n #include \\\"jslock.h\\\"\\n #include \\\"jsmath.h\\\"\\n #include \\\"jsnum.h\\\"\\n@@ -86,10 +87,6 @@\\n #include \\\"jsxml.h\\\"\\n #endif\\n \\n-#if JS_HAS_GENERATORS\\n-#include \\\"jsiter.h\\\"\\n-#endif\\n-\\n #ifdef HAVE_VA_LIST_AS_ARRAY\\n #define JS_ADDRESSOF_VA_LIST(ap) ((va_list *)(ap))\\n #else\\n@@ -5549,6 +5546,12 @@ JS_ThrowReportedError(JSContext *cx, const char *message,\\n     return js_ErrorToException(cx, message, reportp);\\n }\\n \\n+JS_PUBLIC_API(JSBool)\\n+JS_ThrowStopIteration(JSContext *cx)\\n+{\\n+    return js_ThrowStopIteration(cx);\\n+}\\n+\\n #ifdef JS_THREADSAFE\\n /*\\n  * Get the owning thread id of a context. Returns 0 if the context is not\\ndiff --git a/js/src/jsapi.h b/js/src/jsapi.h\\nindex e80b715..06da165 100644\\n--- a/js/src/jsapi.h\\n+++ b/js/src/jsapi.h\\n@@ -2465,6 +2465,12 @@ extern JS_PUBLIC_API(JSBool)\\n JS_ThrowReportedError(JSContext *cx, const char *message,\\n                       JSErrorReport *reportp);\\n \\n+/*\\n+ * Throws a StopIteration exception on cx.\\n+ */\\n+extern JS_PUBLIC_API(JSBool)\\n+JS_ThrowStopIteration(JSContext *cx);\\n+\\n #ifdef JS_THREADSAFE\\n \\n /*\\ndiff --git a/js/src/jsiter.c b/js/src/jsiter.c\\nindex 54dcfa9..7047126 100644\\n--- a/js/src/jsiter.c\\n+++ b/js/src/jsiter.c\\n@@ -270,8 +270,8 @@ IteratorNextImpl(JSContext *cx, JSObject *obj, jsval *rval)\\n     return JS_TRUE;\\n }\\n \\n-static JSBool\\n-js_ThrowStopIteration(JSContext *cx, JSObject *obj)\\n+JSBool\\n+js_ThrowStopIteration(JSContext *cx)\\n {\\n     jsval v;\\n \\n@@ -295,7 +295,7 @@ iterator_next(JSContext *cx, uintN argc, jsval *vp)\\n \\n     if (*vp == JSVAL_HOLE) {\\n         *vp = JSVAL_NULL;\\n-        js_ThrowStopIteration(cx, obj);\\n+        js_ThrowStopIteration(cx);\\n         return JS_FALSE;\\n     }\\n     return JS_TRUE;\\n@@ -916,7 +916,7 @@ SendToGenerator(JSContext *cx, JSGeneratorOp op, JSObject *obj,\\n             *rval = JSVAL_VOID;\\n             return JS_TRUE;\\n         }\\n-        return js_ThrowStopIteration(cx, obj);\\n+        return js_ThrowStopIteration(cx);\\n     }\\n \\n     /*\\n@@ -990,7 +990,7 @@ generator_op(JSContext *cx, JSGeneratorOp op, jsval *vp)\\n         switch (op) {\\n           case JSGENOP_NEXT:\\n           case JSGENOP_SEND:\\n-            return js_ThrowStopIteration(cx, obj);\\n+            return js_ThrowStopIteration(cx);\\n           case JSGENOP_THROW:\\n             JS_SetPendingException(cx, vp[2]);\\n             return JS_FALSE;\\ndiff --git a/js/src/jsiter.h b/js/src/jsiter.h\\nindex 4da2ad6..f04cab2 100644\\n--- a/js/src/jsiter.h\\n+++ b/js/src/jsiter.h\\n@@ -77,6 +77,9 @@ js_CallIteratorNext(JSContext *cx, JSObject *iterobj, jsval *rval);\\n extern void\\n js_CloseNativeIterator(JSContext *cx, JSObject *iterobj);\\n \\n+extern JSBool\\n+js_ThrowStopIteration(JSContext *cx);\\n+\\n #if JS_HAS_GENERATORS\\n \\n /*\\ndiff --git a/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp b/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp\\nindex c7b9a8f..3eb2d71 100644\\n--- a/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp\\n+++ b/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp\\n@@ -41,6 +41,7 @@\\n #include \\\"nsDOMError.h\\\"\\n #include \\\"jsdbgapi.h\\\"\\n #include \\\"jsobj.h\\\"    // For OBJ_GET_PROPERTY.\\n+#include \\\"jscntxt.h\\\"  // For JSAutoTempValueRooter.\\n #include \\\"XPCWrapper.h\\\"\\n #include \\\"nsIDOMWindow.h\\\"\\n #include \\\"nsIDOMWindowCollection.h\\\"\\n@@ -87,6 +88,9 @@ XPC_XOW_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,\\n JS_STATIC_DLL_CALLBACK(JSBool)\\n XPC_XOW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);\\n \\n+JS_STATIC_DLL_CALLBACK(JSObject *)\\n+XPC_XOW_Iterator(JSContext *cx, JSObject *obj, JSBool keysonly);\\n+\\n JSExtendedClass sXPC_XOW_JSClass = {\\n   // JSClass (JSExtendedClass.base) initialization\\n   { \\\"XPCCrossOriginWrapper\\\",\\n@@ -101,8 +105,13 @@ JSExtendedClass sXPC_XOW_JSClass = {\\n     nsnull,              nsnull,\\n     nsnull,              nsnull\\n   },\\n+\\n   // JSExtendedClass initialization\\n-  XPC_XOW_Equality\\n+  XPC_XOW_Equality,\\n+  nsnull,             // outerObject\\n+  nsnull,             // innerObject\\n+  XPC_XOW_Iterator,\\n+  JSCLASS_NO_RESERVED_MEMBERS\\n };\\n \\n // The slot that we stick our scope into.\\n@@ -813,10 +822,10 @@ XPC_XOW_Finalize(JSContext *cx, JSObject *obj)\\n \\n   // Now that we have our scope, see if it's going away. If it is,\\n   // then our work here is going to be done when we destroy the scope\\n-  // entirely.\\n+  // entirely. Scope can be null if we're an enumerating XOW.\\n   XPCWrappedNativeScope *scope = reinterpret_cast<XPCWrappedNativeScope *>\\n                                                  (JSVAL_TO_PRIVATE(scopeVal));\\n-  if (XPCWrappedNativeScope::IsDyingScope(scope)) {\\n+  if (!scope || XPCWrappedNativeScope::IsDyingScope(scope)) {\\n     return;\\n   }\\n \\n@@ -937,6 +946,160 @@ XPC_XOW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)\\n     equality(cx, obj, OBJECT_TO_JSVAL(test), bp);\\n }\\n \\n+JS_STATIC_DLL_CALLBACK(void)\\n+IteratorFinalize(JSContext *cx, JSObject *obj)\\n+{\\n+  jsval v;\\n+  JS_GetReservedSlot(cx, obj, 0, &v);\\n+\\n+  JSIdArray *ida = reinterpret_cast<JSIdArray *>(JSVAL_TO_PRIVATE(v));\\n+  if (ida) {\\n+    JS_DestroyIdArray(cx, ida);\\n+  }\\n+}\\n+\\n+JS_STATIC_DLL_CALLBACK(JSBool)\\n+IteratorNext(JSContext *cx, uintN argc, jsval *vp)\\n+{\\n+  JSObject *obj = JSVAL_TO_OBJECT(vp[1]);\\n+  jsval v;\\n+\\n+  JS_GetReservedSlot(cx, obj, 0, &v);\\n+  JSIdArray *ida = reinterpret_cast<JSIdArray *>(JSVAL_TO_PRIVATE(v));\\n+\\n+  JS_GetReservedSlot(cx, obj, 1, &v);\\n+  jsint idx = JSVAL_TO_INT(v);\\n+\\n+  if (idx == ida->length) {\\n+    return JS_ThrowStopIteration(cx);\\n+  }\\n+\\n+  JS_GetReservedSlot(cx, obj, 2, &v);\\n+  jsid id = ida->vector[idx++];\\n+  if (JSVAL_TO_BOOLEAN(v)) {\\n+    if (!JS_IdToValue(cx, id, &v)) {\\n+      return JS_FALSE;\\n+    }\\n+\\n+    *vp = v;\\n+  } else {\\n+    // We need to return an [id, value] pair.\\n+    if (!OBJ_GET_PROPERTY(cx, JS_GetParent(cx, obj), id, &v)) {\\n+      return JS_FALSE;\\n+    }\\n+\\n+    jsval name;\\n+    if (!JS_IdToValue(cx, id, &name)) {\\n+      return JS_FALSE;\\n+    }\\n+\\n+    jsval vec[2] = { name, v };\\n+    JSAutoTempValueRooter tvr(cx, 2, vec);\\n+    JSObject *array = JS_NewArrayObject(cx, 2, vec);\\n+    if (!array) {\\n+      return JS_FALSE;\\n+    }\\n+\\n+    *vp = OBJECT_TO_JSVAL(array);\\n+  }\\n+\\n+  JS_SetReservedSlot(cx, obj, 1, INT_TO_JSVAL(idx));\\n+  return JS_TRUE;\\n+}\\n+\\n+static JSClass IteratorClass = {\\n+  \\\"XOW iterator\\\", JSCLASS_HAS_RESERVED_SLOTS(3),\\n+  JS_PropertyStub, JS_PropertyStub,\\n+  JS_PropertyStub, JS_PropertyStub,\\n+  JS_EnumerateStub, JS_ResolveStub,\\n+  JS_ConvertStub, IteratorFinalize,\\n+\\n+  JSCLASS_NO_OPTIONAL_MEMBERS\\n+};\\n+\\n+\\n+JS_STATIC_DLL_CALLBACK(JSObject *)\\n+XPC_XOW_Iterator(JSContext *cx, JSObject *obj, JSBool keysonly)\\n+{\\n+  // This is rather ugly: we want to use the trick seen in Enumerate,\\n+  // where we use our wrapper's resolve hook to determine if we should\\n+  // enumerate a given property. However, we don't want to pollute the\\n+  // identifiers with a next method, so we create an object that\\n+  // delegates (via the __proto__ link) to a XOW.\\n+\\n+  jsval root = JSVAL_NULL;\\n+\\n+  // Root v's address so we can set it and have the right value rooted.\\n+  JSAutoTempValueRooter tvr(cx, 1, &root);\\n+\\n+  JSObject *wrapperIter = JS_NewObject(cx, &sXPC_XOW_JSClass.base, nsnull,\\n+                                       JS_GetGlobalForObject(cx, obj));\\n+  if (!wrapperIter) {\\n+    return nsnull;\\n+  }\\n+\\n+  root = OBJECT_TO_JSVAL(wrapperIter);\\n+\\n+  JSObject *iterObj = JS_NewObject(cx, &IteratorClass, wrapperIter, obj);\\n+  if (!iterObj) {\\n+    return nsnull;\\n+  }\\n+\\n+  root = OBJECT_TO_JSVAL(iterObj);\\n+\\n+  // Do this sooner rather than later to avoid complications in\\n+  // IteratorFinalize.\\n+  if (!JS_SetReservedSlot(cx, iterObj, 0, PRIVATE_TO_JSVAL(nsnull))) {\\n+    return nsnull;\\n+  }\\n+\\n+  // Initialize iterObj.\\n+  if (!JS_DefineFunction(cx, iterObj, \\\"next\\\", (JSNative)IteratorNext, 0,\\n+                         JSFUN_FAST_NATIVE)) {\\n+    return nsnull;\\n+  }\\n+\\n+  // Initialize our XOW.\\n+  JSObject *innerObj = GetWrappedObject(cx, obj);\\n+  if (!innerObj) {\\n+    ThrowException(NS_ERROR_INVALID_ARG, cx);\\n+    return nsnull;\\n+  }\\n+\\n+  jsval v = OBJECT_TO_JSVAL(innerObj);\\n+  if (!JS_SetReservedSlot(cx, wrapperIter, XPCWrapper::sWrappedObjSlot, v) ||\\n+      !JS_SetReservedSlot(cx, wrapperIter, XPCWrapper::sResolvingSlot,\\n+                          JSVAL_FALSE) ||\\n+      !JS_SetReservedSlot(cx, wrapperIter, XPCWrapper::sNumSlots,\\n+                          PRIVATE_TO_JSVAL(nsnull))) {\\n+    return nsnull;\\n+  }\\n+\\n+  // Start enumerating over all of our properties.\\n+  do {\\n+    if (!XPCWrapper::Enumerate(cx, iterObj, innerObj)) {\\n+      return nsnull;\\n+    }\\n+  } while ((innerObj = JS_GetPrototype(cx, innerObj)) != nsnull);\\n+\\n+  JSIdArray *ida = JS_Enumerate(cx, iterObj);\\n+  if (!ida) {\\n+    return nsnull;\\n+  }\\n+\\n+  if (!JS_SetReservedSlot(cx, iterObj, 0, PRIVATE_TO_JSVAL(ida)) ||\\n+      !JS_SetReservedSlot(cx, iterObj, 1, JSVAL_ZERO) ||\\n+      !JS_SetReservedSlot(cx, iterObj, 2, BOOLEAN_TO_JSVAL(keysonly))) {\\n+    return nsnull;\\n+  }\\n+\\n+  if (!JS_SetPrototype(cx, iterObj, nsnull)) {\\n+    return nsnull;\\n+  }\\n+\\n+  return iterObj;\\n+}\\n+\\n JS_STATIC_DLL_CALLBACK(JSBool)\\n XPC_XOW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,\\n                  jsval *rval)\\ndiff --git a/js/src/xpconnect/src/XPCWrapper.cpp b/js/src/xpconnect/src/XPCWrapper.cpp\\nindex 45c7d88..3db44bb 100644\\n--- a/js/src/xpconnect/src/XPCWrapper.cpp\\n+++ b/js/src/xpconnect/src/XPCWrapper.cpp\\n@@ -106,30 +106,38 @@ XPCWrapper::Enumerate(JSContext *cx, JSObject *wrapperObj, JSObject *innerObj)\\n \\n   JSBool ok = JS_TRUE;\\n \\n-  do {\\n-    JSIdArray *ida = JS_Enumerate(cx, innerObj);\\n-    if (!ida) {\\n-      return JS_FALSE;\\n+  JSIdArray *ida = JS_Enumerate(cx, innerObj);\\n+  if (!ida) {\\n+    return JS_FALSE;\\n+  }\\n+\\n+  for (jsint i = 0, n = ida->length; i < n; i++) {\\n+    JSObject *pobj;\\n+    JSProperty *prop;\\n+\\n+    // Let OBJ_LOOKUP_PROPERTY, in particular our NewResolve hook,\\n+    // figure out whether this id should be reflected.\\n+    ok = OBJ_LOOKUP_PROPERTY(cx, wrapperObj, ida->vector[i], &pobj, &prop);\\n+    if (!ok) {\\n+      break;\\n     }\\n \\n-    for (jsint i = 0, n = ida->length; i < n; i++) {\\n-      JSObject *pobj;\\n-      JSProperty *prop;\\n+    if (prop) {\\n+      OBJ_DROP_PROPERTY(cx, pobj, prop);\\n+    }\\n \\n-      // Let OBJ_LOOKUP_PROPERTY, in particular our NewResolve hook,\\n-      // figure out whether this id should be reflected.\\n-      ok = OBJ_LOOKUP_PROPERTY(cx, wrapperObj, ida->vector[i], &pobj, &prop);\\n-      if (!ok) {\\n-        break;\\n-      }\\n+    if (pobj != wrapperObj) {\\n+      ok = OBJ_DEFINE_PROPERTY(cx, wrapperObj, ida->vector[i], JSVAL_VOID,\\n+                               nsnull, nsnull, JSPROP_ENUMERATE | JSPROP_SHARED,\\n+                               nsnull);\\n+    }\\n \\n-      if (prop) {\\n-        OBJ_DROP_PROPERTY(cx, pobj, prop);\\n-      }\\n+    if (!ok) {\\n+      break;\\n     }\\n+  }\\n \\n-    JS_DestroyIdArray(cx, ida);\\n-  } while (ok && (innerObj = JS_GetPrototype(cx, innerObj)) != nsnull);\\n+  JS_DestroyIdArray(cx, ida);\\n \\n   return ok;\\n }\\ndiff --git a/js/src/xpconnect/src/xpcjsruntime.cpp b/js/src/xpconnect/src/xpcjsruntime.cpp\\nindex 3b65294..b02612f 100644\\n--- a/js/src/xpconnect/src/xpcjsruntime.cpp\\n+++ b/js/src/xpconnect/src/xpcjsruntime.cpp\\n@@ -58,13 +58,14 @@ const char* XPCJSRuntime::mStrings[] = {\\n     \\\"Function\\\",             // IDX_FUNCTION\\n     \\\"prototype\\\",            // IDX_PROTOTYPE\\n     \\\"createInstance\\\",       // IDX_CREATE_INSTANCE\\n-    \\\"item\\\"                  // IDX_ITEM\\n+    \\\"item\\\",                 // IDX_ITEM\\n+    \\\"__proto__\\\",            // IDX_PROTO\\n+    \\\"__iterator__\\\"          // IDX_ITERATOR\\n #ifdef XPC_IDISPATCH_SUPPORT\\n     , \\\"GeckoActiveXObject\\\"  // IDX_ACTIVEX_OBJECT\\n     , \\\"COMObject\\\"           // IDX_COMOBJECT\\n     , \\\"supports\\\"            // IDX_ACTIVEX_SUPPORTS\\n #endif\\n-    , \\\"__proto__\\\"           // IDX_PROTO\\n };\\n \\n /***************************************************************************/\\ndiff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h\\nindex 767db75..0bcc64c 100644\\n--- a/js/src/xpconnect/src/xpcprivate.h\\n+++ b/js/src/xpconnect/src/xpcprivate.h\\n@@ -649,12 +649,13 @@ public:\\n         IDX_PROTOTYPE               ,\\n         IDX_CREATE_INSTANCE         ,\\n         IDX_ITEM                    ,\\n+        IDX_PROTO                   ,\\n+        IDX_ITERATOR                ,\\n #ifdef XPC_IDISPATCH_SUPPORT\\n         IDX_ACTIVEX_OBJECT          ,\\n         IDX_COM_OBJECT              ,\\n         IDX_ACTIVEX_SUPPORTS        ,\\n #endif\\n-        IDX_PROTO                   ,\\n         IDX_TOTAL_COUNT // just a count of the above\\n     };\\n \\n\""}