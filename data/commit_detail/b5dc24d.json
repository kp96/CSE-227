{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basb5dc24d\""},"diff":"\"b5dc24d Bug 216682 - Eliminate DrawToImage p=Alfred Kayser <alfredkayser@nl.ibm.com> r=tor, sr=pavlov, a=pavlov\\ndiff --git a/gfx/idl/gfxIImageFrame.idl b/gfx/idl/gfxIImageFrame.idl\\nindex 357ffef..9081520 100644\\n--- a/gfx/idl/gfxIImageFrame.idl\\n+++ b/gfx/idl/gfxIImageFrame.idl\\n@@ -57,7 +57,7 @@ native nsRectRef(nsIntRect &);\\n  * @author Stuart Parmenter <pavlov@netscape.com>\\n  * @version 0.1\\n  */\\n-[scriptable, uuid(f6d00ee7-defc-4101-b2dc-e72cf4c37c3c)]\\n+[scriptable, uuid(2502c898-73bd-4da5-8fae-21cf7a492f64)]\\n interface gfxIImageFrame : nsISupports\\n {\\n   /**\\n@@ -189,15 +189,6 @@ interface gfxIImageFrame : nsISupports\\n   /* GIF Specific methods.  These should be in a different class or interface. */\\n \\n   /**\\n-   * Blit this frame into another frame. Used for GIF animation compositing\\n-   */\\n-  void drawTo(in gfxIImageFrame aDst,\\n-              in PRInt32 aDX,\\n-              in PRInt32 aDY,\\n-              in PRInt32 aDWidth,\\n-              in PRInt32 aDHeight);\\n-\\n-  /**\\n    * Represents the number of milliseconds until the next frame should be displayed.\\n    * @note -1 means that this frame should be displayed forever.\\n    */\\ndiff --git a/gfx/public/nsIImage.h b/gfx/public/nsIImage.h\\nindex f1f142a..edde6fd 100644\\n--- a/gfx/public/nsIImage.h\\n+++ b/gfx/public/nsIImage.h\\n@@ -205,18 +205,6 @@ public:\\n                   const gfxRect &aDestRect) = 0;\\n \\n   /**\\n-   * BitBlit the entire (no cropping) nsIImage to another nsImage, the source and dest can be scaled\\n-   * @update - saari 03/08/01\\n-   * @param aDstImage  the nsImage to blit to\\n-   * @param aDX The destination horizontal location\\n-   * @param aDY The destination vertical location\\n-   * @param aDWidth The destination width of the pixelmap\\n-   * @param aDHeight The destination height of the pixelmap\\n-   * @return if TRUE, no errors\\n-   */\\n-  NS_IMETHOD DrawToImage(nsIImage* aDstImage, PRInt32 aDX, PRInt32 aDY, PRInt32 aDWidth, PRInt32 aDHeight) = 0;\\n-\\n-  /**\\n    * Get the alpha depth for the image mask\\n    * @update - lordpixel 2001/05/16\\n    * @return  the alpha mask depth for the image, ie, 0, 1 or 8\\ndiff --git a/gfx/src/shared/gfxImageFrame.cpp b/gfx/src/shared/gfxImageFrame.cpp\\nindex 5c2fd56..53d72d1 100644\\n--- a/gfx/src/shared/gfxImageFrame.cpp\\n+++ b/gfx/src/shared/gfxImageFrame.cpp\\n@@ -446,21 +446,6 @@ NS_IMETHODIMP gfxImageFrame::UnlockAlphaData()\\n   return mImage->UnlockImagePixels(PR_TRUE);\\n }\\n \\n-\\n-\\n-\\n-\\n-/* void drawTo */\\n-NS_IMETHODIMP gfxImageFrame::DrawTo(gfxIImageFrame* aDst, PRInt32 aDX, PRInt32 aDY, PRInt32 aDWidth, PRInt32 aDHeight)\\n-{\\n-  if (!mInitialized)\\n-    return NS_ERROR_NOT_INITIALIZED;\\n-\\n-  nsCOMPtr<nsIImage> img(do_GetInterface(aDst));\\n-  return mImage->DrawToImage(img, aDX, aDY, aDWidth, aDHeight);\\n-}\\n-\\n-\\n /* attribute long timeout; */\\n NS_IMETHODIMP gfxImageFrame::GetTimeout(PRInt32 *aTimeout)\\n {\\ndiff --git a/gfx/src/thebes/nsThebesImage.cpp b/gfx/src/thebes/nsThebesImage.cpp\\nindex 8ec3fec..164ff80 100644\\n--- a/gfx/src/thebes/nsThebesImage.cpp\\n+++ b/gfx/src/thebes/nsThebesImage.cpp\\n@@ -562,28 +562,6 @@ nsThebesImage::ThebesDrawTile(gfxContext *thebesContext,\\n     return NS_OK;\\n }\\n \\n-/* This is only used by the GIF decoder, via gfxImageFrame::DrawTo */\\n-NS_IMETHODIMP\\n-nsThebesImage::DrawToImage(nsIImage* aDstImage, PRInt32 aDX, PRInt32 aDY, PRInt32 aDWidth, PRInt32 aDHeight)\\n-{\\n-    nsThebesImage *dstThebesImage = static_cast<nsThebesImage*>(aDstImage);\\n-\\n-    nsRefPtr<gfxContext> dst = new gfxContext(dstThebesImage->ThebesSurface());\\n-\\n-    dst->NewPath();\\n-    // We don't use PixelSnappedRectangleAndSetPattern because if\\n-    // these coords aren't already pixel aligned, we've lost\\n-    // before we've even begun.\\n-    dst->Translate(gfxPoint(aDX, aDY));\\n-    dst->Rectangle(gfxRect(0, 0, aDWidth, aDHeight), PR_TRUE);\\n-    dst->Scale(double(aDWidth)/mWidth, double(aDHeight)/mHeight);\\n-\\n-    dst->SetSource(ThebesSurface());\\n-    dst->Paint();\\n-\\n-    return NS_OK;\\n-}\\n-\\n PRBool\\n nsThebesImage::ShouldUseImageSurfaces()\\n {\\ndiff --git a/gfx/src/thebes/nsThebesImage.h b/gfx/src/thebes/nsThebesImage.h\\nindex 0ff8103..ceba3fc 100644\\n--- a/gfx/src/thebes/nsThebesImage.h\\n+++ b/gfx/src/thebes/nsThebesImage.h\\n@@ -75,8 +75,6 @@ public:\\n     NS_IMETHOD Draw(nsIRenderingContext &aContext,\\n                     const gfxRect &aSourceRect,\\n                     const gfxRect &aDestRect);\\n-    NS_IMETHOD DrawToImage(nsIImage* aDstImage,\\n-                           PRInt32 aDX, PRInt32 aDY, PRInt32 aDWidth, PRInt32 aDHeight);\\n \\n     nsresult ThebesDrawTile(gfxContext *thebesContext,\\n                             nsIDeviceContext* dx,\\ndiff --git a/modules/libpr0n/src/imgContainer.cpp b/modules/libpr0n/src/imgContainer.cpp\\nindex 776c4ee..5a90d3a 100644\\n--- a/modules/libpr0n/src/imgContainer.cpp\\n+++ b/modules/libpr0n/src/imgContainer.cpp\\n@@ -663,8 +663,7 @@ nsresult imgContainer::DoComposite(gfxIImageFrame** aFrameToUse,\\n       CopyFrameImage(aPrevFrame, mAnim->compositingFrame);\\n     } else {\\n       ClearFrame(mAnim->compositingFrame);\\n-      aPrevFrame->DrawTo(mAnim->compositingFrame, prevFrameRect.x, prevFrameRect.y,\\n-                         prevFrameRect.width, prevFrameRect.height);\\n+      DrawFrameTo(aPrevFrame, mAnim->compositingFrame, prevFrameRect);\\n       needToBlankComposite = PR_FALSE;\\n     }\\n   }\\n@@ -721,8 +720,7 @@ nsresult imgContainer::DoComposite(gfxIImageFrame** aFrameToUse,\\n   }\\n \\n   // blit next frame into it's correct spot\\n-  aNextFrame->DrawTo(mAnim->compositingFrame, nextFrameRect.x, nextFrameRect.y,\\n-                     nextFrameRect.width, nextFrameRect.height);\\n+  DrawFrameTo(aNextFrame, mAnim->compositingFrame, nextFrameRect);\\n   // Set timeout of CompositeFrame to timeout of frame we just composed\\n   // Bug 177948\\n   PRInt32 timeout;\\n@@ -795,7 +793,7 @@ void imgContainer::ClearFrame(gfxIImageFrame *aFrame, nsIntRect &aRect)\\n // Whether we succeed or fail will not cause a crash, and there's not much\\n // we can do about a failure, so there we don't return a nsresult\\n PRBool imgContainer::CopyFrameImage(gfxIImageFrame *aSrcFrame,\\n-                                       gfxIImageFrame *aDstFrame)\\n+                                    gfxIImageFrame *aDstFrame)\\n {\\n   PRUint8* aDataSrc;\\n   PRUint8* aDataDest;\\n@@ -819,10 +817,7 @@ PRBool imgContainer::CopyFrameImage(gfxIImageFrame *aSrcFrame,\\n   aDstFrame->UnlockImageData();\\n \\n   // Tell the image that it's data has been updated\\n-  nsCOMPtr<nsIInterfaceRequestor> ireq(do_QueryInterface(aDstFrame));\\n-  if (!ireq)\\n-    return PR_FALSE;\\n-  nsCOMPtr<nsIImage> img(do_GetInterface(ireq));\\n+  nsCOMPtr<nsIImage> img(do_GetInterface(aDstFrame));\\n   if (!img)\\n     return PR_FALSE;\\n   nsIntRect r;\\n@@ -832,6 +827,41 @@ PRBool imgContainer::CopyFrameImage(gfxIImageFrame *aSrcFrame,\\n   return PR_TRUE;\\n }\\n \\n+//******************************************************************************\\n+nsresult imgContainer::DrawFrameTo(gfxIImageFrame *aSrc,\\n+                                   gfxIImageFrame *aDst, \\n+                                   nsIntRect& aDstRect)\\n+{\\n+  if (!aSrc || !aDst)\\n+    return NS_ERROR_NOT_INITIALIZED;\\n+\\n+  nsCOMPtr<nsIImage> srcImg(do_GetInterface(aSrc));\\n+  nsRefPtr<gfxASurface> srcSurf;\\n+  srcImg->GetSurface(getter_AddRefs(srcSurf));\\n+\\n+  nsCOMPtr<nsIImage> dstImg(do_GetInterface(aDst));\\n+  nsRefPtr<gfxASurface> dstSurf;\\n+  dstImg->GetSurface(getter_AddRefs(dstSurf));\\n+\\n+  gfxContext dst(dstSurf);\\n+  dst.NewPath();\\n+  // We don't use PixelSnappedRectangleAndSetPattern because if\\n+  // these coords aren't already pixel aligned, we've lost\\n+  // before we've even begun.\\n+  dst.Translate(gfxPoint(aDstRect.x, aDstRect.y));\\n+  dst.Rectangle(gfxRect(0, 0, aDstRect.width, aDstRect.height), PR_TRUE);\\n+\\n+  nsIntRect srcRect;\\n+  aSrc->GetRect(srcRect);\\n+  dst.Scale(double(aDstRect.width) / srcRect.width, \\n+            double(aDstRect.height) / srcRect.height);\\n+  dst.SetSource(srcSurf);\\n+  dst.Paint();\\n+\\n+  return NS_OK;\\n+}\\n+\\n+\\n /********* Methods to implement lazy allocation of nsIProperties object *************/\\n NS_IMETHODIMP imgContainer::Get(const char *prop, const nsIID & iid, void * *result)\\n {\\ndiff --git a/modules/libpr0n/src/imgContainer.h b/modules/libpr0n/src/imgContainer.h\\nindex 3db7034..dfd159a 100644\\n--- a/modules/libpr0n/src/imgContainer.h\\n+++ b/modules/libpr0n/src/imgContainer.h\\n@@ -271,6 +271,17 @@ private:\\n   static PRBool CopyFrameImage(gfxIImageFrame *aSrcFrame,\\n                                gfxIImageFrame *aDstFrame);\\n   \\n+  /** Draws one gfxIImageFrame's image to into another,\\n+   * at the position specified by aRect\\n+   *\\n+   * @param aSrcFrame  Frame providing the source image\\n+   * @param aDstFrame  Frame where the image is drawn into\\n+   * @param aRect      The position and size to draw the image\\n+   */\\n+  static nsresult DrawFrameTo(gfxIImageFrame *aSrcFrame,\\n+                              gfxIImageFrame *aDstFrame,\\n+                              nsIntRect& aRect);\\n+\\n   nsIntSize                  mSize;\\n   \\n   //! All the <gfxIImageFrame>s of the PNG\\n\""}