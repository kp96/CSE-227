{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Base011fa0\""},"diff":"\"e011fa0 Display one hex box with six digits for non-BMP codepoints with no glyph. Bug 376532, r+sr+a=roc\\ndiff --git a/gfx/thebes/public/gfxFont.h b/gfx/thebes/public/gfxFont.h\\nindex b7cabd8..80d0d6c 100644\\n--- a/gfx/thebes/public/gfxFont.h\\n+++ b/gfx/thebes/public/gfxFont.h\\n@@ -1068,7 +1068,7 @@ public:\\n      */\\n     void SetDetailedGlyphs(PRUint32 aCharIndex, const DetailedGlyph *aGlyphs,\\n                            PRUint32 aNumGlyphs);\\n-    void SetMissingGlyph(PRUint32 aCharIndex, PRUnichar aChar);\\n+    void SetMissingGlyph(PRUint32 aCharIndex, PRUint32 aChar);\\n     void SetSpaceGlyph(gfxFont *aFont, gfxContext *aContext, PRUint32 aCharIndex);\\n \\n     // API for access to the raw glyph data, needed by gfxFont::Draw\\ndiff --git a/gfx/thebes/src/gfxAtsuiFonts.cpp b/gfx/thebes/src/gfxAtsuiFonts.cpp\\nindex 0a2d9475..e9686fa 100644\\n--- a/gfx/thebes/src/gfxAtsuiFonts.cpp\\n+++ b/gfx/thebes/src/gfxAtsuiFonts.cpp\\n@@ -693,7 +693,8 @@ SetGlyphsForCharacterGroup(ATSLayoutRecord *aGlyphs, PRUint32 aGlyphCount,\\n                            Fixed *aBaselineDeltas, PRUint32 aAppUnitsPerDevUnit,\\n                            gfxTextRun *aRun, PRUint32 aSegmentStart,\\n                            const PRPackedBool *aUnmatched,\\n-                           const PRUnichar *aString)\\n+                           const PRUnichar *aString,\\n+                           const PRUint32 aLength)\\n {\\n     NS_ASSERTION(aGlyphCount > 0, \\\"Must set at least one glyph\\\");\\n     PRUint32 firstOffset = aGlyphs[0].originalOffset;\\n@@ -727,7 +728,15 @@ SetGlyphsForCharacterGroup(ATSLayoutRecord *aGlyphs, PRUint32 aGlyphCount,\\n     if (!allMatched) {\\n         for (i = firstOffset; i <= lastOffset; ++i) {\\n             PRUint32 index = i/2;\\n-            aRun->SetMissingGlyph(aSegmentStart + index, aString[index]);\\n+            if (NS_IS_HIGH_SURROGATE(aString[index]) &&\\n+                index + 1 < aLength &&\\n+                NS_IS_LOW_SURROGATE(aString[index + 1])) {\\n+                aRun->SetMissingGlyph(aSegmentStart + index,\\n+                                      SURROGATE_TO_UCS4(aString[index],\\n+                                                        aString[index + 1]));\\n+            } else {\\n+                aRun->SetMissingGlyph(aSegmentStart + index, aString[index]);\\n+            }\\n         }\\n         return;\\n     }\\n@@ -888,12 +897,12 @@ PostLayoutCallback(ATSULineRef aLine, gfxTextRun *aRun,\\n                                        glyphCount,\\n                                        baselineDeltas ? baselineDeltas + numGlyphs - glyphCount : nsnull,\\n                                        appUnitsPerDevUnit, aRun, aSegmentStart,\\n-                                       aUnmatched, aString);\\n+                                       aUnmatched, aString, aSegmentLength);\\n         } else {\\n             SetGlyphsForCharacterGroup(glyphRecords,\\n                                        glyphCount, baselineDeltas,\\n                                        appUnitsPerDevUnit, aRun, aSegmentStart,\\n-                                       aUnmatched, aString);\\n+                                       aUnmatched, aString, aSegmentLength);\\n             glyphRecords += glyphCount;\\n             if (baselineDeltas) {\\n                 baselineDeltas += glyphCount;\\ndiff --git a/gfx/thebes/src/gfxFont.cpp b/gfx/thebes/src/gfxFont.cpp\\nindex 246572f..925c94f 100644\\n--- a/gfx/thebes/src/gfxFont.cpp\\n+++ b/gfx/thebes/src/gfxFont.cpp\\n@@ -1559,7 +1559,7 @@ gfxTextRun::SetDetailedGlyphs(PRUint32 aIndex, const DetailedGlyph *aGlyphs,\\n }\\n   \\n void\\n-gfxTextRun::SetMissingGlyph(PRUint32 aIndex, PRUnichar aChar)\\n+gfxTextRun::SetMissingGlyph(PRUint32 aIndex, PRUint32 aChar)\\n {\\n     DetailedGlyph *details = AllocateDetailedGlyphs(aIndex, 1);\\n     if (!details)\\n@@ -1569,7 +1569,7 @@ gfxTextRun::SetMissingGlyph(PRUint32 aIndex, PRUnichar aChar)\\n     details->mGlyphID = aChar;\\n     GlyphRun *glyphRun = &mGlyphRuns[FindFirstGlyphRunContaining(aIndex)];\\n     gfxFloat width = PR_MAX(glyphRun->mFont->GetMetrics().aveCharWidth,\\n-                            gfxFontMissingGlyphs::GetDesiredMinWidth());\\n+                            gfxFontMissingGlyphs::GetDesiredMinWidth(aChar));\\n     details->mAdvance = PRUint32(width*GetAppUnitsPerDevUnit());\\n     details->mXOffset = 0;\\n     details->mYOffset = 0;\\ndiff --git a/gfx/thebes/src/gfxFontMissingGlyphs.cpp b/gfx/thebes/src/gfxFontMissingGlyphs.cpp\\nindex fb09ff3..d65d40e 100644\\n--- a/gfx/thebes/src/gfxFontMissingGlyphs.cpp\\n+++ b/gfx/thebes/src/gfxFontMissingGlyphs.cpp\\n@@ -126,22 +126,25 @@ static const PRUint16 glyphMicroFont[16] = {\\n };\\n \\n /* Parameters that control the rendering of hexboxes. They look like this:\\n-   \\n-       +---------+\\n-       |         |\\n-       | HHH HHH |\\n-       | HHH HHH |\\n-       | HHH HHH |\\n-       | HHH HHH |\\n-       | HHH HHH |\\n-       |         |\\n-       | HHH HHH |\\n-       | HHH HHH |\\n-       | HHH HHH |\\n-       | HHH HHH |\\n-       | HHH HHH |\\n-       |         |\\n-       +---------+\\n+\\n+        BMP codepoints           non-BMP codepoints\\n+      (U+0000 - U+FFFF)         (U+10000 - U+10FFFF)\\n+\\n+         +---------+              +-------------+ \\n+         |         |              |             |\\n+         | HHH HHH |              | HHH HHH HHH |\\n+         | HHH HHH |              | HHH HHH HHH |\\n+         | HHH HHH |              | HHH HHH HHH |\\n+         | HHH HHH |              | HHH HHH HHH |\\n+         | HHH HHH |              | HHH HHH HHH |\\n+         |         |              |             |\\n+         | HHH HHH |              | HHH HHH HHH |\\n+         | HHH HHH |              | HHH HHH HHH |\\n+         | HHH HHH |              | HHH HHH HHH |\\n+         | HHH HHH |              | HHH HHH HHH |\\n+         | HHH HHH |              | HHH HHH HHH |\\n+         |         |              |             |\\n+         +---------+              +-------------+\\n */\\n \\n /** Width of a minifont glyph (see above) */\\n@@ -167,15 +170,6 @@ static const int BOX_BORDER_WIDTH = 1;\\n  */\\n static const gfxFloat BOX_BORDER_OPACITY = 0.5;\\n /**\\n- * The minimum desired width for a missing-glyph glyph box. I've laid it out\\n- * like this so you can see what goes where.\\n- */\\n-static const int MIN_DESIRED_WIDTH =\\n-  BOX_HORIZONTAL_INSET + BOX_BORDER_WIDTH + HEX_CHAR_GAP +\\n-  MINIFONT_WIDTH + HEX_CHAR_GAP + MINIFONT_WIDTH +\\n-  HEX_CHAR_GAP + BOX_BORDER_WIDTH + BOX_HORIZONTAL_INSET;\\n-\\n-/**\\n  * Draw a single hex character using the current color. A nice way to do this\\n  * would be to fill in an A8 image surface and then use it as a mask\\n  * to paint the current color. Tragically this doesn't currently work with the\\n@@ -201,7 +195,7 @@ DrawHexChar(gfxContext *aContext, const gfxPoint& aPt, PRUint32 aDigit)\\n \\n void\\n gfxFontMissingGlyphs::DrawMissingGlyph(gfxContext *aContext, const gfxRect& aRect,\\n-                                       PRUnichar aChar)\\n+                                       PRUint32 aChar)\\n {\\n     aContext->Save();\\n \\n@@ -233,29 +227,60 @@ gfxFontMissingGlyphs::DrawMissingGlyph(gfxContext *aContext, const gfxRect& aRec\\n         aContext->Stroke();\\n     }\\n \\n-    if (aRect.Width() >= 2*MINIFONT_WIDTH + HEX_CHAR_GAP &&\\n-        aRect.Height() >= 2*MINIFONT_HEIGHT + HEX_CHAR_GAP) {\\n-        aContext->SetColor(currentColor);\\n-        gfxPoint center(aRect.X() + aRect.Width()/2,\\n-                        aRect.Y() + aRect.Height()/2);\\n-        gfxFloat halfGap = HEX_CHAR_GAP/2.0;\\n-        gfxFloat left = -(MINIFONT_WIDTH + halfGap);\\n-        gfxFloat top = -(MINIFONT_HEIGHT + halfGap);\\n-        DrawHexChar(aContext,\\n-                    center + gfxPoint(left, top), (aChar >> 12) & 0xF);\\n-        DrawHexChar(aContext,\\n-                    center + gfxPoint(halfGap, top), (aChar >> 8) & 0xF);\\n-        DrawHexChar(aContext,\\n-                    center + gfxPoint(left, halfGap), (aChar >> 4) & 0xF);\\n-        DrawHexChar(aContext,\\n-                    center + gfxPoint(halfGap, halfGap), aChar & 0xF);\\n+    gfxPoint center(aRect.X() + aRect.Width()/2,\\n+                    aRect.Y() + aRect.Height()/2);\\n+    gfxFloat halfGap = HEX_CHAR_GAP/2.0;\\n+    gfxFloat top = -(MINIFONT_HEIGHT + halfGap);\\n+    if (aChar < 0x10000) {\\n+        if (aRect.Width() >= 2*MINIFONT_WIDTH + HEX_CHAR_GAP &&\\n+            aRect.Height() >= 2*MINIFONT_HEIGHT + HEX_CHAR_GAP) {\\n+            // Draw 4 digits for BMP\\n+            aContext->SetColor(currentColor);\\n+            gfxFloat left = -(MINIFONT_WIDTH + halfGap);\\n+            DrawHexChar(aContext,\\n+                        center + gfxPoint(left, top), (aChar >> 12) & 0xF);\\n+            DrawHexChar(aContext,\\n+                        center + gfxPoint(halfGap, top), (aChar >> 8) & 0xF);\\n+            DrawHexChar(aContext,\\n+                        center + gfxPoint(left, halfGap), (aChar >> 4) & 0xF);\\n+            DrawHexChar(aContext,\\n+                        center + gfxPoint(halfGap, halfGap), aChar & 0xF);\\n+        }\\n+    } else {\\n+        if (aRect.Width() >= 3*MINIFONT_WIDTH + 2*HEX_CHAR_GAP &&\\n+            aRect.Height() >= 2*MINIFONT_HEIGHT + HEX_CHAR_GAP) {\\n+            // Draw 6 digits for non-BMP\\n+            aContext->SetColor(currentColor);\\n+            gfxFloat first = -(MINIFONT_WIDTH * 1.5 + HEX_CHAR_GAP);\\n+            gfxFloat second = -(MINIFONT_WIDTH / 2.0);\\n+            gfxFloat third = (MINIFONT_WIDTH / 2.0 + HEX_CHAR_GAP);\\n+            DrawHexChar(aContext,\\n+                        center + gfxPoint(first, top), (aChar >> 20) & 0xF);\\n+            DrawHexChar(aContext,\\n+                        center + gfxPoint(second, top), (aChar >> 16) & 0xF);\\n+            DrawHexChar(aContext,\\n+                        center + gfxPoint(third, top), (aChar >> 12) & 0xF);\\n+            DrawHexChar(aContext,\\n+                        center + gfxPoint(first, halfGap), (aChar >> 8) & 0xF);\\n+            DrawHexChar(aContext,\\n+                        center + gfxPoint(second, halfGap), (aChar >> 4) & 0xF);\\n+            DrawHexChar(aContext,\\n+                        center + gfxPoint(third, halfGap), aChar & 0xF);\\n+        }\\n     }\\n \\n     aContext->Restore();\\n }\\n \\n gfxFloat\\n-gfxFontMissingGlyphs::GetDesiredMinWidth()\\n+gfxFontMissingGlyphs::GetDesiredMinWidth(PRUint32 aChar)\\n {\\n-    return MIN_DESIRED_WIDTH;\\n+/**\\n+ * The minimum desired width for a missing-glyph glyph box. I've laid it out\\n+ * like this so you can see what goes where.\\n+ */\\n+    return BOX_HORIZONTAL_INSET + BOX_BORDER_WIDTH + HEX_CHAR_GAP +\\n+        MINIFONT_WIDTH + HEX_CHAR_GAP + MINIFONT_WIDTH +\\n+         ((aChar < 0x10000) ? 0 : HEX_CHAR_GAP + MINIFONT_WIDTH) +\\n+        HEX_CHAR_GAP + BOX_BORDER_WIDTH + BOX_HORIZONTAL_INSET;\\n }\\ndiff --git a/gfx/thebes/src/gfxFontMissingGlyphs.h b/gfx/thebes/src/gfxFontMissingGlyphs.h\\nindex 9904bb9..028a70b 100644\\n--- a/gfx/thebes/src/gfxFontMissingGlyphs.h\\n+++ b/gfx/thebes/src/gfxFontMissingGlyphs.h\\n@@ -56,12 +56,12 @@ public:\\n      * @param aChar the UTF16 codepoint for the character\\n      */\\n     static void DrawMissingGlyph(gfxContext *aContext, const gfxRect& aRect,\\n-                                 PRUnichar aChar);\\n+                                 PRUint32 aChar);\\n     /**\\n      * @return the desired minimum width for a glyph-box that will allow\\n      * the hexboxes to be drawn reasonably.\\n      */\\n-    static gfxFloat GetDesiredMinWidth();\\n+    static gfxFloat GetDesiredMinWidth(PRUint32 aChar);\\n };\\n \\n #endif\\ndiff --git a/gfx/thebes/src/gfxOS2Fonts.cpp b/gfx/thebes/src/gfxOS2Fonts.cpp\\nindex 0c8de58..049d908 100644\\n--- a/gfx/thebes/src/gfxOS2Fonts.cpp\\n+++ b/gfx/thebes/src/gfxOS2Fonts.cpp\\n@@ -488,21 +488,6 @@ void gfxOS2FontGroup::InitTextRun(gfxTextRun *aTextRun, const PRUint8 *aUTF8Text\\n                       aUTF8Length - aUTF8HeaderLength);\\n }\\n \\n-static void SetMissingGlyphForUCS4(gfxTextRun *aTextRun, PRUint32 aIndex,\\n-                                   PRUint32 aCh)\\n-{\\n-    if (aCh < 0x10000) {\\n-        aTextRun->SetMissingGlyph(aIndex, PRUnichar(aCh));\\n-        return;\\n-    }\\n-\\n-    // Display non-BMP characters as a surrogate pair\\n-    aTextRun->SetMissingGlyph(aIndex, H_SURROGATE(aCh));\\n-    if (aIndex + 1 < aTextRun->GetLength()) {\\n-        aTextRun->SetMissingGlyph(aIndex + 1, L_SURROGATE(aCh));\\n-    }\\n-}\\n-\\n // Helper function to return the leading UTF-8 character in a char pointer\\n // as 32bit number. Also sets the length of the current character (i.e. the\\n // offset to the next one) in the second argument\\n@@ -587,7 +572,7 @@ void gfxOS2FontGroup::CreateGlyphRunsFT(gfxTextRun *aTextRun, const PRUint8 *aUT\\n                                             g.SetSimpleGlyph(advance, gid));\\n             } else if (gid == 0) {\\n                 // gid = 0 only happens when the glyph is missing from the font\\n-                SetMissingGlyphForUCS4(aTextRun, utf16Offset, ch);\\n+                aTextRun->SetMissingGlyph(utf16Offset, ch);\\n             } else {\\n                 gfxTextRun::DetailedGlyph details;\\n                 details.mIsLastGlyph = PR_TRUE;\\ndiff --git a/gfx/thebes/src/gfxPangoFonts.cpp b/gfx/thebes/src/gfxPangoFonts.cpp\\nindex 89e886d..e7f3476 100644\\n--- a/gfx/thebes/src/gfxPangoFonts.cpp\\n+++ b/gfx/thebes/src/gfxPangoFonts.cpp\\n@@ -1002,21 +1002,6 @@ ConvertPangoToAppUnits(PRInt32 aCoordinate, PRUint32 aAppUnitsPerDevUnit)\\n     return PRInt32(v);\\n }\\n \\n-static void\\n-SetMissingGlyphForUCS4(gfxTextRun *aTextRun, PRUint32 aIndex, gunichar aCh)\\n-{\\n-    if (aCh < 0x10000) {\\n-        aTextRun->SetMissingGlyph(aIndex, PRUnichar(aCh));\\n-        return;\\n-    }\\n-\\n-    // Display non-BMP characters as a surrogate pair\\n-    aTextRun->SetMissingGlyph(aIndex, H_SURROGATE(aCh));\\n-    if (aIndex + 1 < aTextRun->GetLength()) {\\n-        aTextRun->SetMissingGlyph(aIndex + 1, L_SURROGATE(aCh));\\n-    }\\n-}\\n-\\n /**\\n  * Given a run of Pango glyphs that should be treated as a single\\n  * cluster/ligature, store them in the textrun at the appropriate character\\n@@ -1242,7 +1227,7 @@ gfxPangoFontGroup::SetMissingGlyphs(gfxTextRun *aTextRun,\\n             break;\\n         }\\n         gunichar ch = g_utf8_get_char(aUTF8 + index);\\n-        SetMissingGlyphForUCS4(aTextRun, utf16Offset, ch);\\n+        aTextRun->SetMissingGlyph(utf16Offset, ch);\\n \\n         ++utf16Offset;\\n         NS_ASSERTION(!IS_SURROGATE(ch), \\\"surrogates should not appear in UTF8\\\");\\n@@ -1301,7 +1286,7 @@ gfxPangoFontGroup::CreateGlyphRunsXft(gfxTextRun *aTextRun,\\n             } else if (IS_MISSING_GLYPH(glyph)) {\\n                 // Note that missing-glyph IDs are not simple glyph IDs, so we'll\\n                 // always get here when a glyph is missing\\n-                SetMissingGlyphForUCS4(aTextRun, utf16Offset, ch);\\n+                aTextRun->SetMissingGlyph(utf16Offset, ch);\\n             } else {\\n                 gfxTextRun::DetailedGlyph details;\\n                 details.mIsLastGlyph = PR_TRUE;\\ndiff --git a/gfx/thebes/src/gfxWindowsFonts.cpp b/gfx/thebes/src/gfxWindowsFonts.cpp\\nindex 8111d5c..4e7d5bc 100644\\n--- a/gfx/thebes/src/gfxWindowsFonts.cpp\\n+++ b/gfx/thebes/src/gfxWindowsFonts.cpp\\n@@ -1103,7 +1103,15 @@ public:\\n                 NS_ASSERTION(!gfxFontGroup::IsInvalidChar(mRangeString[offset]),\\n                 \\t\\t     \\\"invalid character detected\\\");\\n                 if (missing) {\\n-                    aRun->SetMissingGlyph(runOffset, mRangeString[offset]);\\n+                    if (NS_IS_HIGH_SURROGATE(mRangeString[offset]) &&\\n+                        offset + 1 < mRangeLength &&\\n+                        NS_IS_LOW_SURROGATE(mRangeString[offset + 1])) {\\n+                        aRun->SetMissingGlyph(runOffset,\\n+                                              SURROGATE_TO_UCS4(mRangeString[offset],\\n+                                                                mRangeString[offset + 1]));\\n+                    } else {\\n+                        aRun->SetMissingGlyph(runOffset, mRangeString[offset]);\\n+                    }\\n                 } else if (glyphCount == 1 && advance >= 0 &&\\n                     mOffsets[k].dv == 0 && mOffsets[k].du == 0 &&\\n                     gfxTextRun::CompressedGlyph::IsSimpleAdvance(advance) &&\\n\""}