{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas8797e1d\""},"diff":"\"8797e1d b=396972, clean up canvas API to avoid using internal API in contexts, r/a=stuart\\ndiff --git a/content/canvas/public/nsICanvasElement.h b/content/canvas/public/nsICanvasElement.h\\nindex 7df7bbe..e437ecb 100644\\n--- a/content/canvas/public/nsICanvasElement.h\\n+++ b/content/canvas/public/nsICanvasElement.h\\n@@ -39,7 +39,9 @@\\n #define nsICanvasElement_h___\\n \\n #include \\\"nsISupports.h\\\"\\n+#include \\\"nsRect.h\\\"\\n \\n+class gfxContext;\\n class nsIFrame;\\n \\n // {C234660C-BD06-493e-8583-939A5A158B37}\\n@@ -66,16 +68,10 @@ public:\\n \\n   /*\\n    * Ask the canvas element to tell the contexts to render themselves\\n-   * into the given nsIRenderingContext at the origin.\\n+   * to the given gfxContext at the origin of its coordinate space.\\n    */\\n-  NS_IMETHOD RenderContexts (nsIRenderingContext *rc) = 0;\\n+  NS_IMETHOD RenderContexts (gfxContext *ctx) = 0;\\n \\n-  /*\\n-   * Ask the canvas element to tell the contexts to render themselves\\n-   * into to given cairo_surface_t.\\n-   */\\n-  NS_IMETHOD RenderContextsToSurface (struct _cairo_surface *surf) = 0;\\n-  \\n   /**\\n    * Determine whether the canvas is write-only.\\n    */\\n@@ -85,6 +81,17 @@ public:\\n    * Force the canvas to be write-only.\\n    */\\n   virtual void SetWriteOnly() = 0;\\n+\\n+  /*\\n+   * Ask the canvas frame to invalidate itself\\n+   */\\n+  NS_IMETHOD InvalidateFrame () = 0;\\n+\\n+  /*\\n+   * Ask the canvas frame to invalidate a portion of the frame; damageRect\\n+   * is relative to the origin of the canvas frame.\\n+   */\\n+  NS_IMETHOD InvalidateFrameSubrect (const nsRect& damageRect) = 0;\\n };\\n \\n NS_DEFINE_STATIC_IID_ACCESSOR(nsICanvasElement, NS_ICANVASELEMENT_IID)\\ndiff --git a/content/canvas/public/nsICanvasRenderingContextInternal.h b/content/canvas/public/nsICanvasRenderingContextInternal.h\\nindex 8ea576a..cf4a121 100644\\n--- a/content/canvas/public/nsICanvasRenderingContextInternal.h\\n+++ b/content/canvas/public/nsICanvasRenderingContextInternal.h\\n@@ -42,13 +42,11 @@\\n #include \\\"nsICanvasElement.h\\\"\\n #include \\\"nsIInputStream.h\\\"\\n \\n-// {05150761-22A3-4e8d-A03E-EC53CB731C70}\\n+// {eab854fd-aa5e-44bb-8cc5-8d02f84b0216}\\n #define NS_ICANVASRENDERINGCONTEXTINTERNAL_IID \\\\\\n-  { 0x5150761, 0x22a3, 0x4e8d, { 0xa0, 0x3e, 0xec, 0x53, 0xcb, 0x73, 0x1c, 0x70 } }\\n+  { 0xeab854fd, 0xaa5e, 0x44bb, { 0x8c, 0xc5, 0x8d, 0x02, 0xf8, 0x4b, 0x02, 0x16 } }\\n \\n-class nsIRenderingContext;\\n-\\n-struct _cairo_surface;\\n+class gfxContext;\\n \\n class nsICanvasRenderingContextInternal : public nsISupports {\\n public:\\n@@ -62,11 +60,8 @@ public:\\n   // whenever the size of the element changes.\\n   NS_IMETHOD SetDimensions(PRInt32 width, PRInt32 height) = 0;\\n \\n-  // Render the canvas at the origin of the given nsIRenderingContext\\n-  NS_IMETHOD Render(nsIRenderingContext *rc) = 0;\\n-\\n-  // Render the canvas at the origin of the given cairo surface\\n-  NS_IMETHOD RenderToSurface(struct _cairo_surface *surf) = 0;\\n+  // Render the canvas at the origin of the given gfxContext\\n+  NS_IMETHOD Render(gfxContext *ctx) = 0;\\n \\n   // Gives you a stream containing the image represented by this context.\\n   // The format is given in aMimeTime, for example \\\"image/png\\\".\\n@@ -74,8 +69,8 @@ public:\\n   // If the image format does not support transparency or aIncludeTransparency\\n   // is false, alpha will be discarded and the result will be the image\\n   // composited on black.\\n-  NS_IMETHOD GetInputStream(const nsACString& aMimeType,\\n-                            const nsAString& aEncoderOptions,\\n+  NS_IMETHOD GetInputStream(const char *aMimeType,\\n+                            const PRUnichar *aEncoderOptions,\\n                             nsIInputStream **aStream) = 0;\\n };\\n \\ndiff --git a/content/canvas/src/nsCanvasRenderingContext2D.cpp b/content/canvas/src/nsCanvasRenderingContext2D.cpp\\nindex 4202085..46321bb 100644\\n--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp\\n+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp\\n@@ -99,6 +99,7 @@\\n \\n #include \\\"gfxContext.h\\\"\\n #include \\\"gfxASurface.h\\\"\\n+#include \\\"gfxImageSurface.h\\\"\\n #include \\\"gfxPlatform.h\\\"\\n #include \\\"gfxFont.h\\\"\\n #include \\\"gfxTextRunCache.h\\\"\\n@@ -235,16 +236,14 @@ class nsCanvasPattern : public nsIDOMCanvasPattern\\n public:\\n     NS_DECLARE_STATIC_IID_ACCESSOR(NS_CANVASPATTERN_PRIVATE_IID)\\n \\n-    nsCanvasPattern(cairo_pattern_t *cpat, PRUint8 *dataToFree,\\n+    nsCanvasPattern(cairo_pattern_t *cpat,\\n                     nsIURI* URIForSecurityCheck, PRBool forceWriteOnly)\\n-        : mPattern(cpat), mData(dataToFree), mURI(URIForSecurityCheck), mForceWriteOnly(forceWriteOnly)\\n+        : mPattern(cpat), mURI(URIForSecurityCheck), mForceWriteOnly(forceWriteOnly)\\n     { }\\n \\n     ~nsCanvasPattern() {\\n         if (mPattern)\\n             cairo_pattern_destroy(mPattern);\\n-        if (mData)\\n-            nsMemory::Free(mData);\\n     }\\n \\n     void Apply(cairo_t *cairo) {\\n@@ -292,10 +291,9 @@ public:\\n     // nsICanvasRenderingContextInternal\\n     NS_IMETHOD SetCanvasElement(nsICanvasElement* aParentCanvas);\\n     NS_IMETHOD SetDimensions(PRInt32 width, PRInt32 height);\\n-    NS_IMETHOD Render(nsIRenderingContext *rc);\\n-    NS_IMETHOD RenderToSurface(cairo_surface_t *surf);\\n-    NS_IMETHOD GetInputStream(const nsACString& aMimeType,\\n-                              const nsAString& aEncoderOptions,\\n+    NS_IMETHOD Render(gfxContext *ctx);\\n+    NS_IMETHOD GetInputStream(const char* aMimeType,\\n+                              const PRUnichar* aEncoderOptions,\\n                               nsIInputStream **aStream);\\n \\n     // nsISupports interface\\n@@ -308,8 +306,6 @@ protected:\\n     // destroy cairo/image stuff, in preparation for possibly recreating\\n     void Destroy();\\n \\n-    nsIFrame *GetCanvasLayoutFrame();\\n-\\n     // Some helpers.  Doesn't modify acolor on failure.\\n     enum {\\n         STYLE_STROKE = 0,\\n@@ -458,17 +454,6 @@ nsCanvasRenderingContext2D::~nsCanvasRenderingContext2D()\\n     Destroy();\\n }\\n \\n-nsIFrame*\\n-nsCanvasRenderingContext2D::GetCanvasLayoutFrame()\\n-{\\n-    if (!mCanvasElement)\\n-        return nsnull;\\n-\\n-    nsIFrame *fr = nsnull;\\n-    mCanvasElement->GetPrimaryCanvasFrame(&fr);\\n-    return fr;\\n-}\\n-\\n void\\n nsCanvasRenderingContext2D::Destroy()\\n {\\n@@ -653,14 +638,10 @@ nsCanvasRenderingContext2D::ApplyStyle(PRInt32 aWhichStyle)\\n nsresult\\n nsCanvasRenderingContext2D::Redraw()\\n {\\n-    nsIFrame *frame = GetCanvasLayoutFrame();\\n-    if (frame) {\\n-        nsRect r = frame->GetRect();\\n-        r.x = r.y = 0;\\n-        frame->Invalidate(r, PR_FALSE);\\n-    }\\n+    if (!mCanvasElement)\\n+        return nsnull;\\n \\n-    return NS_OK;\\n+    return mCanvasElement->InvalidateFrame();\\n }\\n \\n void\\n@@ -723,7 +704,7 @@ nsCanvasRenderingContext2D::SetDimensions(PRInt32 width, PRInt32 height)\\n }\\n  \\n NS_IMETHODIMP\\n-nsCanvasRenderingContext2D::Render(nsIRenderingContext *rc)\\n+nsCanvasRenderingContext2D::Render(gfxContext *ctx)\\n {\\n     nsresult rv = NS_OK;\\n \\n@@ -735,7 +716,6 @@ nsCanvasRenderingContext2D::Render(nsIRenderingContext *rc)\\n     if (!mThebesSurface)\\n         return NS_ERROR_FAILURE;\\n \\n-    gfxContext* ctx = (gfxContext*) rc->GetNativeGraphicData(nsIRenderingContext::NATIVE_THEBES_CONTEXT);\\n     nsRefPtr<gfxPattern> pat = new gfxPattern(mThebesSurface);\\n \\n     // XXX I don't want to use PixelSnapped here, but layout doesn't guarantee\\n@@ -748,19 +728,8 @@ nsCanvasRenderingContext2D::Render(nsIRenderingContext *rc)\\n }\\n \\n NS_IMETHODIMP\\n-nsCanvasRenderingContext2D::RenderToSurface(cairo_surface_t *surf)\\n-{\\n-    cairo_t *cr = cairo_create (surf);\\n-    cairo_set_source_surface (cr, mSurface, 0, 0);\\n-    cairo_paint (cr);\\n-    cairo_destroy (cr);\\n-\\n-    return NS_OK;\\n-}\\n- \\n-NS_IMETHODIMP\\n-nsCanvasRenderingContext2D::GetInputStream(const nsACString& aMimeType,\\n-                                           const nsAString& aEncoderOptions,\\n+nsCanvasRenderingContext2D::GetInputStream(const char *aMimeType,\\n+                                           const PRUnichar *aEncoderOptions,\\n                                            nsIInputStream **aStream)\\n {\\n     if (!mSurface ||\\n@@ -768,10 +737,12 @@ nsCanvasRenderingContext2D::GetInputStream(const nsACString& aMimeType,\\n         cairo_surface_status(mSurface) != CAIRO_STATUS_SUCCESS)\\n         return NS_ERROR_FAILURE;\\n \\n-    nsCString conid(NS_LITERAL_CSTRING(\\\"@mozilla.org/image/encoder;2?type=\\\"));\\n-    conid += aMimeType;\\n+    const char encoderPrefix[] = \\\"@mozilla.org/image/encoder;2?type=\\\";\\n+    nsAutoArrayPtr<char> conid(new (std::nothrow) char[strlen(encoderPrefix) + strlen(aMimeType) + 1]);\\n+    strcpy(conid, encoderPrefix);\\n+    strcat(conid, aMimeType);\\n \\n-    nsCOMPtr<imgIEncoder> encoder = do_CreateInstance(conid.get());\\n+    nsCOMPtr<imgIEncoder> encoder = do_CreateInstance(conid);\\n     if (!encoder)\\n         return NS_ERROR_FAILURE;\\n \\n@@ -779,7 +750,7 @@ nsCanvasRenderingContext2D::GetInputStream(const nsACString& aMimeType,\\n         encoder->InitFromData(mImageSurfaceData,\\n                               mWidth * mHeight * 4, mWidth, mHeight, mWidth * 4,\\n                               imgIEncoder::INPUT_FORMAT_HOSTARGB,\\n-                              aEncoderOptions);\\n+                              nsDependentString(aEncoderOptions));\\n     } else {\\n         nsAutoArrayPtr<PRUint8> imageBuffer(new (std::nothrow) PRUint8[mWidth * mHeight * 4]);\\n         if (!imageBuffer)\\n@@ -802,7 +773,7 @@ nsCanvasRenderingContext2D::GetInputStream(const nsACString& aMimeType,\\n         encoder->InitFromData(imageBuffer.get(),\\n                               mWidth * mHeight * 4, mWidth, mHeight, mWidth * 4,\\n                               imgIEncoder::INPUT_FORMAT_HOSTARGB,\\n-                              aEncoderOptions);\\n+                              nsDependentString(aEncoderOptions));\\n     }\\n \\n     return CallQueryInterface(encoder, aStream);\\n@@ -1100,10 +1071,9 @@ nsCanvasRenderingContext2D::CreatePattern(nsIDOMHTMLElement *image,\\n \\n     cairo_pattern_set_extend (cairopat, extend);\\n \\n-    nsCanvasPattern *pat = new nsCanvasPattern(cairopat, imgData, uri, forceWriteOnly);\\n+    nsCanvasPattern *pat = new nsCanvasPattern(cairopat, uri, forceWriteOnly);\\n     if (!pat) {\\n         cairo_pattern_destroy(cairopat);\\n-        nsMemory::Free(imgData);\\n         return NS_ERROR_OUT_OF_MEMORY;\\n     }\\n \\n@@ -1591,7 +1561,7 @@ nsCanvasRenderingContext2D::MozMeasureText(const nsAString& textToMeasure, float\\n     gfxTextRun::Metrics metrics = textRun->MeasureText(/* offset = */ 0, textToMeasure.Length(),\\n                                                        tightBoundingBox, mThebesContext,\\n                                                        nsnull);\\n-    *retVal = metrics.mAdvanceWidth/gfxFloat(elemDocument->GetPrimaryShell()->GetPresContext()->AppUnitsPerCSSPixel());\\n+    *retVal = float(metrics.mAdvanceWidth/gfxFloat(elemDocument->GetPrimaryShell()->GetPresContext()->AppUnitsPerCSSPixel()));\\n     return NS_OK;\\n }\\n \\n@@ -1910,7 +1880,7 @@ nsCanvasRenderingContext2D::DrawImage()\\n     DoDrawImageSecurityCheck(uri, forceWriteOnly);\\n \\n #define GET_ARG(dest,whicharg) \\\\\\n-    do { if (!ConvertJSValToDouble(dest, ctx, whicharg)) { rv = NS_ERROR_INVALID_ARG; goto FAIL; } } while (0)\\n+    do { if (!ConvertJSValToDouble(dest, ctx, whicharg)) { rv = NS_ERROR_INVALID_ARG; goto FINISH; } } while (0)\\n \\n     rv = NS_OK;\\n \\n@@ -1940,10 +1910,17 @@ nsCanvasRenderingContext2D::DrawImage()\\n     } else {\\n         // XXX ERRMSG we need to report an error to developers here! (bug 329026)\\n         rv = NS_ERROR_INVALID_ARG;\\n-        goto FAIL;\\n+        goto FINISH;\\n     }\\n #undef GET_ARG\\n \\n+    if (dw == 0.0 || dh == 0.0) {\\n+        rv = NS_OK;\\n+        // not really failure, but nothing to do --\\n+        // and noone likes a divide-by-zero\\n+        goto FINISH;\\n+    }\\n+\\n     if (!FloatValidate(sx,sy,sw,sh))\\n         return NS_ERROR_DOM_SYNTAX_ERR;\\n     if (!FloatValidate(dx,dy,dw,dh))\\n@@ -1957,7 +1934,7 @@ nsCanvasRenderingContext2D::DrawImage()\\n     {\\n         // XXX ERRMSG we need to report an error to developers here! (bug 329026)\\n         rv = NS_ERROR_DOM_INDEX_SIZE_ERR;\\n-        goto FAIL;\\n+        goto FINISH;\\n     }\\n \\n     cairo_matrix_init_translate(&surfMat, sx, sy);\\n@@ -1989,9 +1966,7 @@ nsCanvasRenderingContext2D::DrawImage()\\n \\n     cairo_pattern_destroy(pat);\\n \\n-FAIL:\\n-    if (imgData)\\n-        nsMemory::Free(imgData);\\n+FINISH:\\n     if (imgSurf)\\n         cairo_surface_destroy(imgSurf);\\n \\n@@ -2162,22 +2137,20 @@ nsCanvasRenderingContext2D::CairoSurfaceFromElement(nsIDOMElement *imgElt,\\n             rv = canvas->GetSize(&w, &h);\\n             NS_ENSURE_SUCCESS(rv, rv);\\n \\n-            cairo_surface_t *surf =\\n-                cairo_image_surface_create (CAIRO_FORMAT_ARGB32,\\n-                                            w, h);\\n-            cairo_t *cr = cairo_create (surf);\\n-            cairo_set_operator (cr, CAIRO_OPERATOR_CLEAR);\\n-            cairo_paint (cr);\\n-            cairo_destroy (cr);\\n-\\n-            rv = canvas->RenderContextsToSurface(surf);\\n-            if (NS_FAILED(rv)) {\\n-                cairo_surface_destroy (surf);\\n+            nsRefPtr<gfxImageSurface> surf =\\n+                new gfxImageSurface (gfxIntSize(w, h), gfxASurface::ImageFormatARGB32);\\n+            nsRefPtr<gfxContext> ctx = new gfxContext(surf);\\n+            ctx->SetOperator(gfxContext::OPERATOR_CLEAR);\\n+            ctx->Paint();\\n+            ctx->SetOperator(gfxContext::OPERATOR_OVER);\\n+\\n+            rv = canvas->RenderContexts(ctx);\\n+            if (NS_FAILED(rv))\\n                 return rv;\\n-            }\\n \\n-            *aCairoSurface = surf;\\n-            *imgData = nsnull;\\n+            *aCairoSurface = surf->CairoSurface();\\n+            cairo_surface_reference(*aCairoSurface);\\n+            *imgData = surf->Data();\\n             *widthOut = w;\\n             *heightOut = h;\\n \\n@@ -2211,8 +2184,8 @@ nsCanvasRenderingContext2D::CairoSurfaceFromElement(nsIDOMElement *imgElt,\\n     if (heightOut)\\n         *heightOut = imgHeight;\\n \\n-    gfxASurface* gfxsurf = nsnull;\\n-    rv = img->GetSurface(&gfxsurf);\\n+    nsRefPtr<gfxASurface> gfxsurf;\\n+    rv = img->GetSurface(getter_AddRefs(gfxsurf));\\n     NS_ENSURE_SUCCESS(rv, rv);\\n \\n     *aCairoSurface = gfxsurf->CairoSurface();\\ndiff --git a/content/html/content/src/nsHTMLCanvasElement.cpp b/content/html/content/src/nsHTMLCanvasElement.cpp\\nindex 317e6aa..0dd827f 100644\\n--- a/content/html/content/src/nsHTMLCanvasElement.cpp\\n+++ b/content/html/content/src/nsHTMLCanvasElement.cpp\\n@@ -88,10 +88,11 @@ public:\\n   // nsICanvasElement\\n   NS_IMETHOD GetPrimaryCanvasFrame(nsIFrame **aFrame);\\n   NS_IMETHOD GetSize(PRUint32 *width, PRUint32 *height);\\n-  NS_IMETHOD RenderContexts(nsIRenderingContext *ctx);\\n-  NS_IMETHOD RenderContextsToSurface(struct _cairo_surface *surf);\\n+  NS_IMETHOD RenderContexts(gfxContext *ctx);\\n   virtual PRBool IsWriteOnly();\\n   virtual void SetWriteOnly();\\n+  NS_IMETHOD InvalidateFrame ();\\n+  NS_IMETHOD InvalidateFrameSubrect (const nsRect& damageRect);\\n \\n   NS_IMETHOD_(PRBool) IsAttributeMapped(const nsIAtom* aAttribute) const;\\n   nsMapRuleToAttributesFunc GetAttributeMappingFunction() const;\\n@@ -372,7 +373,8 @@ nsHTMLCanvasElement::ToDataURLImpl(const nsAString& aMimeType,\\n   // get image bytes\\n   nsCOMPtr<nsIInputStream> imgStream;\\n   NS_ConvertUTF16toUTF8 aMimeType8(aMimeType);\\n-  rv = context->GetInputStream(aMimeType8, aEncoderOptions,\\n+  rv = context->GetInputStream(nsPromiseFlatCString(aMimeType8).get(),\\n+                               nsPromiseFlatString(aEncoderOptions).get(),\\n                                getter_AddRefs(imgStream));\\n   // XXX ERRMSG we need to report an error to developers here! (bug 329026)\\n   NS_ENSURE_SUCCESS(rv, rv);\\n@@ -506,21 +508,12 @@ nsHTMLCanvasElement::GetSize(PRUint32 *width, PRUint32 *height)\\n }\\n \\n NS_IMETHODIMP\\n-nsHTMLCanvasElement::RenderContexts(nsIRenderingContext *rc)\\n+nsHTMLCanvasElement::RenderContexts(gfxContext *ctx)\\n {\\n   if (!mCurrentContext)\\n     return NS_OK;\\n \\n-  return mCurrentContext->Render(rc);\\n-}\\n-\\n-NS_IMETHODIMP\\n-nsHTMLCanvasElement::RenderContextsToSurface(struct _cairo_surface *surf)\\n-{\\n-  if (!mCurrentContext)\\n-    return NS_OK;\\n-\\n-  return mCurrentContext->RenderToSurface(surf);\\n+  return mCurrentContext->Render(ctx);\\n }\\n \\n PRBool\\n@@ -534,3 +527,27 @@ nsHTMLCanvasElement::SetWriteOnly()\\n {\\n   mWriteOnly = PR_TRUE;\\n }\\n+\\n+NS_IMETHODIMP\\n+nsHTMLCanvasElement::InvalidateFrame()\\n+{\\n+  nsIFrame *frame = GetPrimaryFrame(Flush_Frames);\\n+  if (frame) {\\n+    nsRect r = frame->GetRect();\\n+    r.x = r.y = 0;\\n+    frame->Invalidate(r, PR_FALSE);\\n+  }\\n+\\n+  return NS_OK;\\n+}\\n+\\n+NS_IMETHODIMP\\n+nsHTMLCanvasElement::InvalidateFrameSubrect(const nsRect& damageRect)\\n+{\\n+  nsIFrame *frame = GetPrimaryFrame(Flush_Frames);\\n+  if (frame) {\\n+    frame->Invalidate(damageRect, PR_FALSE);\\n+  }\\n+\\n+  return NS_OK;\\n+}\\ndiff --git a/gfx/thebes/public/gfxASurface.h b/gfx/thebes/public/gfxASurface.h\\nindex 8d74ed4..60ee7954 100644\\n--- a/gfx/thebes/public/gfxASurface.h\\n+++ b/gfx/thebes/public/gfxASurface.h\\n@@ -111,11 +111,11 @@ public:\\n     void MarkDirty(const gfxRect& r);\\n \\n     /* Printing backend functions */\\n-    virtual nsresult BeginPrinting(const nsAString& aTitle, const nsAString& aPrintToFileName) { return NS_ERROR_NOT_IMPLEMENTED; }\\n-    virtual nsresult EndPrinting() { return NS_ERROR_NOT_IMPLEMENTED; }\\n-    virtual nsresult AbortPrinting() { return NS_ERROR_NOT_IMPLEMENTED; }\\n-    virtual nsresult BeginPage() { return NS_ERROR_NOT_IMPLEMENTED; }\\n-    virtual nsresult EndPage() { return NS_ERROR_NOT_IMPLEMENTED; }\\n+    virtual nsresult BeginPrinting(const nsAString& aTitle, const nsAString& aPrintToFileName);\\n+    virtual nsresult EndPrinting();\\n+    virtual nsresult AbortPrinting();\\n+    virtual nsresult BeginPage();\\n+    virtual nsresult EndPage();\\n \\n     void SetData(const cairo_user_data_key_t *key,\\n                  void *user_data,\\ndiff --git a/gfx/thebes/src/gfxASurface.cpp b/gfx/thebes/src/gfxASurface.cpp\\nindex 9f45bcd..fabbd70 100644\\n--- a/gfx/thebes/src/gfxASurface.cpp\\n+++ b/gfx/thebes/src/gfxASurface.cpp\\n@@ -306,3 +306,33 @@ gfxASurface::CheckSurfaceSize(const gfxIntSize& sz, PRInt32 limit)\\n \\n     return PR_TRUE;\\n }\\n+\\n+nsresult\\n+gfxASurface::BeginPrinting(const nsAString& aTitle, const nsAString& aPrintToFileName)\\n+{\\n+    return NS_ERROR_NOT_IMPLEMENTED;\\n+}\\n+\\n+nsresult\\n+gfxASurface::EndPrinting()\\n+{\\n+    return NS_ERROR_NOT_IMPLEMENTED;\\n+}\\n+\\n+nsresult\\n+gfxASurface::AbortPrinting()\\n+{\\n+    return NS_ERROR_NOT_IMPLEMENTED;\\n+}\\n+\\n+nsresult\\n+gfxASurface::BeginPage()\\n+{\\n+    return NS_ERROR_NOT_IMPLEMENTED;\\n+}\\n+\\n+nsresult\\n+gfxASurface::EndPage()\\n+{\\n+    return NS_ERROR_NOT_IMPLEMENTED;\\n+}\\ndiff --git a/layout/generic/nsHTMLCanvasFrame.cpp b/layout/generic/nsHTMLCanvasFrame.cpp\\nindex c75dd9e..14f2788 100644\\n--- a/layout/generic/nsHTMLCanvasFrame.cpp\\n+++ b/layout/generic/nsHTMLCanvasFrame.cpp\\n@@ -207,7 +207,7 @@ nsHTMLCanvasFrame::PaintCanvas(nsIRenderingContext& aRenderingContext,\\n     aRenderingContext.Translate(inner.x, inner.y);\\n     aRenderingContext.Scale(sx, sy);\\n \\n-    canvas->RenderContexts(&aRenderingContext);\\n+    canvas->RenderContexts((gfxContext*) aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_THEBES_CONTEXT));\\n \\n     aRenderingContext.PopState();\\n   } else {\\n@@ -216,7 +216,7 @@ nsHTMLCanvasFrame::PaintCanvas(nsIRenderingContext& aRenderingContext,\\n     aRenderingContext.PushState();\\n     aRenderingContext.Translate(inner.x, inner.y);\\n \\n-    canvas->RenderContexts(&aRenderingContext);\\n+    canvas->RenderContexts((gfxContext*) aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_THEBES_CONTEXT));\\n \\n     aRenderingContext.PopState();\\n   }\\n\""}