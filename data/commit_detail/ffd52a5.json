{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basffd52a5\""},"diff":"\"ffd52a5 Do lazy evaluation of XBL fields.  Bug 372769, r=mrbkap, sr=sicking\\ndiff --git a/content/xbl/src/Makefile.in b/content/xbl/src/Makefile.in\\nindex 3c4986d..ae32022 100644\\n--- a/content/xbl/src/Makefile.in\\n+++ b/content/xbl/src/Makefile.in\\n@@ -111,6 +111,7 @@ LOCAL_INCLUDES\\t= \\\\\\n \\t\\t-I$(srcdir)/../../xul/document/src \\\\\\n \\t\\t-I$(srcdir)/../../events/src \\\\\\n \\t\\t-I$(srcdir)/../../../layout/style \\\\\\n+\\t\\t-I$(srcdir)/../../../dom/src/base \\\\\\n \\t\\t$(NULL)\\n \\n DEFINES += -D_IMPL_NS_LAYOUT\\ndiff --git a/content/xbl/src/nsXBLBinding.cpp b/content/xbl/src/nsXBLBinding.cpp\\nindex 08b226b..00ff758 100644\\n--- a/content/xbl/src/nsXBLBinding.cpp\\n+++ b/content/xbl/src/nsXBLBinding.cpp\\n@@ -102,27 +102,127 @@\\n #include \\\"prprf.h\\\"\\n #include \\\"nsNodeUtils.h\\\"\\n \\n+// Nasty hack.  Maybe we could move some of the classinfo utility methods\\n+// (e.g. WrapNative and ThrowJSException) over to nsContentUtils?\\n+#include \\\"nsDOMClassInfo.h\\\"\\n+#include \\\"nsJSUtils.h\\\"\\n+\\n // Helper classes\\n \\n /***********************************************************************/\\n //\\n // The JS class for XBLBinding\\n //\\n-PR_STATIC_CALLBACK(void)\\n+JS_STATIC_DLL_CALLBACK(void)\\n XBLFinalize(JSContext *cx, JSObject *obj)\\n {\\n+  nsXBLPrototypeBinding* protoBinding =\\n+    static_cast<nsXBLPrototypeBinding*>(::JS_GetPrivate(cx, obj));\\n+  protoBinding->XBLDocumentInfo()->Release();\\n+  \\n   nsXBLJSClass* c = static_cast<nsXBLJSClass*>(::JS_GetClass(cx, obj));\\n   c->Drop();\\n }\\n \\n+JS_STATIC_DLL_CALLBACK(JSBool)\\n+XBLResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,\\n+           JSObject **objp)\\n+{\\n+  // Note: if we get here, that means that the implementation for some binding\\n+  // was installed, which means that AllowScripts() tested true.  Hence no need\\n+  // to do checks like that here.\\n+  \\n+  // Default to not resolving things.\\n+  NS_ASSERTION(*objp, \\\"Must have starting object\\\");\\n+\\n+  JSObject* origObj = *objp;\\n+  *objp = NULL;\\n+\\n+  if (!JSVAL_IS_STRING(id)) {\\n+    return JS_TRUE;\\n+  }\\n+\\n+  nsDependentJSString fieldName(id);\\n+                     \\n+  nsXBLPrototypeBinding* protoBinding =\\n+    static_cast<nsXBLPrototypeBinding*>(::JS_GetPrivate(cx, obj));\\n+  NS_ASSERTION(protoBinding, \\\"Must have prototype binding!\\\");\\n+\\n+  nsXBLProtoImplField* field = protoBinding->FindField(fieldName);\\n+  if (!field) {\\n+    return JS_TRUE;\\n+  }\\n+\\n+  // We have this field.  Time to install it.  Get our node.\\n+  JSClass* nodeClass = ::JS_GetClass(cx, origObj);\\n+  if (!nodeClass) {\\n+    return JS_FALSE;\\n+  }\\n+  \\n+  if (~nodeClass->flags &\\n+      (JSCLASS_HAS_PRIVATE | JSCLASS_PRIVATE_IS_NSISUPPORTS)) {\\n+    // Looks like whatever |origObj| is it's not our nsIContent.  It might well\\n+    // be the proto our binding installed, however, so just baul out quietly.\\n+    // Do NOT throw an exception here.\\n+    // We could make this stricter by checking the class maybe, but whatever\\n+    return JS_TRUE;\\n+  }\\n+\\n+  nsCOMPtr<nsIXPConnectWrappedNative> xpcWrapper =\\n+    do_QueryInterface(static_cast<nsISupports*>(::JS_GetPrivate(cx, origObj)));\\n+  if (!xpcWrapper) {\\n+    nsDOMClassInfo::ThrowJSException(cx, NS_ERROR_UNEXPECTED);\\n+    return JS_FALSE;\\n+  }\\n+\\n+  nsCOMPtr<nsIContent> content = do_QueryWrappedNative(xpcWrapper);\\n+  if (!content) {\\n+    nsDOMClassInfo::ThrowJSException(cx, NS_ERROR_UNEXPECTED);\\n+    return JS_FALSE;\\n+  }\\n+\\n+  // This mirrors code in nsXBLProtoImpl::InstallImplementation\\n+  nsIDocument* doc = content->GetOwnerDoc();\\n+  if (!doc) {\\n+    return JS_TRUE;\\n+  }\\n+\\n+  nsIScriptGlobalObject* global = doc->GetScriptGlobalObject();\\n+  if (!global) {\\n+    return JS_TRUE;\\n+  }\\n+\\n+  nsCOMPtr<nsIScriptContext> context = global->GetContext();\\n+  if (!context) {\\n+    return JS_TRUE;\\n+  }\\n+\\n+\\n+  // Now we either resolve or fail\\n+  *objp = origObj;\\n+  nsresult rv = field->InstallField(context, origObj,\\n+                                    protoBinding->DocURI());\\n+  if (NS_FAILED(rv)) {\\n+    if (!::JS_IsExceptionPending(cx)) {\\n+      nsDOMClassInfo::ThrowJSException(cx, rv);\\n+    }\\n+\\n+    return JS_FALSE;\\n+  }\\n+\\n+  return JS_TRUE;\\n+}\\n+\\n nsXBLJSClass::nsXBLJSClass(const nsAFlatCString& aClassName)\\n {\\n   memset(this, 0, sizeof(nsXBLJSClass));\\n   next = prev = static_cast<JSCList*>(this);\\n   name = ToNewCString(aClassName);\\n+  flags =\\n+    JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE | JSCLASS_NEW_RESOLVE_GETS_START;\\n   addProperty = delProperty = setProperty = getProperty = ::JS_PropertyStub;\\n   enumerate = ::JS_EnumerateStub;\\n-  resolve = ::JS_ResolveStub;\\n+  resolve = (JSResolveOp)XBLResolve;\\n   convert = ::JS_ConvertStub;\\n   finalize = XBLFinalize;\\n }\\n@@ -1034,6 +1134,7 @@ nsXBLBinding::WalkRules(nsIStyleRuleProcessor::EnumFunc aFunc, void* aData)\\n nsresult\\n nsXBLBinding::DoInitJSClass(JSContext *cx, JSObject *global, JSObject *obj,\\n                             const nsAFlatCString& aClassName,\\n+                            nsXBLPrototypeBinding* aProtoBinding,\\n                             void **aClassObject)\\n {\\n   // First ensure our JS class is initialized.\\n@@ -1139,6 +1240,11 @@ nsXBLBinding::DoInitJSClass(JSContext *cx, JSObject *global, JSObject *obj,\\n       return NS_ERROR_OUT_OF_MEMORY;\\n     }\\n \\n+    ::JS_SetPrivate(cx, proto, aProtoBinding);\\n+\\n+    // Keep this proto binding alive while we're alive\\n+    aProtoBinding->XBLDocumentInfo()->AddRef();\\n+\\n     *aClassObject = (void*)proto;\\n   }\\n   else {\\n@@ -1155,63 +1261,6 @@ nsXBLBinding::DoInitJSClass(JSContext *cx, JSObject *global, JSObject *obj,\\n   return NS_OK;\\n }\\n \\n-\\n-nsresult\\n-nsXBLBinding::InitClass(const nsCString& aClassName,\\n-                        nsIScriptContext* aContext, \\n-                        nsIDocument* aDocument, void** aScriptObject,\\n-                        void** aClassObject)\\n-{\\n-  *aClassObject = nsnull;\\n-  *aScriptObject = nsnull;\\n-\\n-  nsresult rv;\\n-\\n-  // Obtain the bound element's current script object.\\n-  JSContext* cx = (JSContext*)aContext->GetNativeContext();\\n-\\n-  nsIDocument *ownerDoc = mBoundElement->GetOwnerDoc();\\n-  nsIScriptGlobalObject *sgo;\\n-\\n-  if (!ownerDoc || !(sgo = ownerDoc->GetScriptGlobalObject())) {\\n-    NS_ERROR(\\\"Can't find global object for bound content!\\\");\\n-\\n-    return NS_ERROR_UNEXPECTED;\\n-  }\\n-\\n-  nsCOMPtr<nsIXPConnectJSObjectHolder> wrapper;\\n-  rv = nsContentUtils::XPConnect()->WrapNative(cx, sgo->GetGlobalJSObject(),\\n-                                               mBoundElement,\\n-                                               NS_GET_IID(nsISupports),\\n-                                               getter_AddRefs(wrapper));\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  JSObject* object = nsnull;\\n-  rv = wrapper->GetJSObject(&object);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  *aScriptObject = object;\\n-\\n-  // First ensure our JS class is initialized.\\n-\\n-  rv = DoInitJSClass(cx, sgo->GetGlobalJSObject(), object, aClassName,\\n-                     aClassObject);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  // Root mBoundElement so that it doesn't lose it's binding\\n-  nsIDocument* doc = mBoundElement->GetOwnerDoc();\\n-\\n-  if (doc) {\\n-    nsCOMPtr<nsIXPConnectWrappedNative> native_wrapper =\\n-      do_QueryInterface(wrapper);\\n-    if (native_wrapper) {\\n-      doc->AddReference(mBoundElement, native_wrapper);\\n-    }\\n-  }\\n-\\n-  return NS_OK;\\n-}\\n-\\n PRBool\\n nsXBLBinding::AllowScripts()\\n {\\n@@ -1344,6 +1393,20 @@ nsXBLBinding::GetFirstStyleBinding()\\n   return mNextBinding ? mNextBinding->GetFirstStyleBinding() : nsnull;\\n }\\n \\n+PRBool\\n+nsXBLBinding::ResolveAllFields(JSContext *cx, JSObject *obj) const\\n+{\\n+  if (!mPrototypeBinding->ResolveAllFields(cx, obj)) {\\n+    return PR_FALSE;\\n+  }\\n+\\n+  if (mNextBinding) {\\n+    return mNextBinding->ResolveAllFields(cx, obj);\\n+  }\\n+\\n+  return PR_TRUE;\\n+}\\n+\\n void\\n nsXBLBinding::MarkForDeath()\\n {\\ndiff --git a/content/xbl/src/nsXBLBinding.h b/content/xbl/src/nsXBLBinding.h\\nindex 744c418..55b571f 100644\\n--- a/content/xbl/src/nsXBLBinding.h\\n+++ b/content/xbl/src/nsXBLBinding.h\\n@@ -132,6 +132,10 @@ public:\\n   nsXBLBinding* RootBinding();\\n   nsXBLBinding* GetFirstStyleBinding();\\n \\n+  // Resolve all the fields for this binding and all ancestor bindings on the\\n+  // object |obj|.  False return means a JS exception was set.\\n+  PRBool ResolveAllFields(JSContext *cx, JSObject *obj) const;\\n+\\n   // Get the list of insertion points for aParent. The nsInsertionPointList\\n   // is owned by the binding, you should not delete it.\\n   nsresult GetInsertionPointsFor(nsIContent* aParent,\\n@@ -155,16 +159,11 @@ public:\\n \\n   static nsresult DoInitJSClass(JSContext *cx, JSObject *global, JSObject *obj,\\n                                 const nsAFlatCString& aClassName,\\n+                                nsXBLPrototypeBinding* aProtoBinding,\\n                                 void **aClassObject);\\n \\n   PRBool AllowScripts();  // XXX make const\\n \\n-// Internal member functions\\n-protected:\\n-  nsresult InitClass(const nsCString& aClassName, nsIScriptContext* aContext,\\n-                     nsIDocument* aDocument, void** aScriptObject,\\n-                     void** aClassObject);\\n-\\n // MEMBER VARIABLES\\n protected:\\n   nsAutoRefCnt mRefCnt;\\ndiff --git a/content/xbl/src/nsXBLContentSink.cpp b/content/xbl/src/nsXBLContentSink.cpp\\nindex 19bdf77..ea2ee5c 100644\\n--- a/content/xbl/src/nsXBLContentSink.cpp\\n+++ b/content/xbl/src/nsXBLContentSink.cpp\\n@@ -83,12 +83,13 @@ nsXBLContentSink::nsXBLContentSink()\\n   : mState(eXBL_InDocument),\\n     mSecondaryState(eXBL_None),\\n     mDocInfo(nsnull),\\n-    mFoundFirstBinding(PR_FALSE),    \\n     mIsChromeOrResource(PR_FALSE),\\n+    mFoundFirstBinding(PR_FALSE),    \\n     mBinding(nsnull),\\n     mHandler(nsnull),\\n     mImplementation(nsnull),\\n     mImplMember(nsnull),\\n+    mImplField(nsnull),\\n     mProperty(nsnull),\\n     mMethod(nsnull),\\n     mField(nsnull)\\n@@ -263,6 +264,18 @@ nsXBLContentSink::AddMember(nsXBLProtoImplMember* aMember)\\n   mImplMember = aMember; // Adjust our pointer to point to the new last member in the chain.\\n }\\n \\n+void\\n+nsXBLContentSink::AddField(nsXBLProtoImplField* aField)\\n+{\\n+  // Add this field to our chain.\\n+  if (mImplField)\\n+    mImplField->SetNext(aField); // Already have a chain. Just append to the end.\\n+  else\\n+    mImplementation->SetFieldList(aField); // We're the first member in the chain.\\n+\\n+  mImplField = aField; // Adjust our pointer to point to the new last field in the chain.\\n+}\\n+\\n NS_IMETHODIMP \\n nsXBLContentSink::HandleStartElement(const PRUnichar *aName, \\n                                      const PRUnichar **aAtts, \\n@@ -703,7 +716,8 @@ nsXBLContentSink::ConstructImplementation(const PRUnichar **aAtts)\\n {\\n   mImplementation = nsnull;\\n   mImplMember = nsnull;\\n-      \\n+  mImplField = nsnull;\\n+  \\n   if (!mBinding)\\n     return;\\n \\n@@ -777,7 +791,7 @@ nsXBLContentSink::ConstructField(const PRUnichar **aAtts, PRUint32 aLineNumber)\\n     mField = new nsXBLProtoImplField(name, readonly);\\n     if (mField) {\\n       mField->SetLineNumber(aLineNumber);\\n-      AddMember(mField);\\n+      AddField(mField);\\n     }\\n   }\\n }\\ndiff --git a/content/xbl/src/nsXBLContentSink.h b/content/xbl/src/nsXBLContentSink.h\\nindex 0d59fff..2cb1368 100644\\n--- a/content/xbl/src/nsXBLContentSink.h\\n+++ b/content/xbl/src/nsXBLContentSink.h\\n@@ -157,6 +157,7 @@ protected:\\n   nsresult ReportUnexpectedElement(nsIAtom* aElementName, PRUint32 aLineNumber);\\n \\n   void AddMember(nsXBLProtoImplMember* aMember);\\n+  void AddField(nsXBLProtoImplField* aField);\\n   \\n   XBLPrimaryState mState;\\n   XBLSecondaryState mSecondaryState;\\n@@ -168,6 +169,7 @@ protected:\\n   nsXBLPrototypeHandler* mHandler; // current handler, owned by its PrototypeBinding\\n   nsXBLProtoImpl* mImplementation;\\n   nsXBLProtoImplMember* mImplMember;\\n+  nsXBLProtoImplField* mImplField;\\n   nsXBLProtoImplProperty* mProperty;\\n   nsXBLProtoImplMethod* mMethod;\\n   nsXBLProtoImplField* mField;\\ndiff --git a/content/xbl/src/nsXBLProtoImpl.cpp b/content/xbl/src/nsXBLProtoImpl.cpp\\nindex 1a1feff..61f4562 100644\\n--- a/content/xbl/src/nsXBLProtoImpl.cpp\\n+++ b/content/xbl/src/nsXBLProtoImpl.cpp\\n@@ -47,6 +47,7 @@\\n #include \\\"nsIServiceManager.h\\\"\\n #include \\\"nsIXBLDocumentInfo.h\\\"\\n #include \\\"nsIDOMNode.h\\\"\\n+#include \\\"nsXBLPrototypeBinding.h\\\"\\n \\n nsresult\\n nsXBLProtoImpl::InstallImplementation(nsXBLPrototypeBinding* aBinding, nsIContent* aBoundElement)\\n@@ -55,7 +56,7 @@ nsXBLProtoImpl::InstallImplementation(nsXBLPrototypeBinding* aBinding, nsIConten\\n   // this prototype implementation as a guide.  The prototype implementation is compiled lazily,\\n   // so for the first bound element that needs a concrete implementation, we also build the\\n   // prototype implementation.\\n-  if (!mMembers)  // Constructor and destructor also live in mMembers\\n+  if (!mMembers && !mFields)  // Constructor and destructor also live in mMembers\\n     return NS_OK; // Nothing to do, so let's not waste time.\\n \\n   // If the way this gets the script context changes, fix\\n@@ -214,6 +215,37 @@ nsXBLProtoImpl::Traverse(nsCycleCollectionTraversalCallback &cb) const\\n   }\\n }\\n \\n+nsXBLProtoImplField*\\n+nsXBLProtoImpl::FindField(const nsString& aFieldName) const\\n+{\\n+  for (nsXBLProtoImplField* f = mFields; f; f = f->GetNext()) {\\n+    if (aFieldName.Equals(f->GetName())) {\\n+      return f;\\n+    }\\n+  }\\n+\\n+  return nsnull;\\n+}\\n+\\n+PRBool\\n+nsXBLProtoImpl::ResolveAllFields(JSContext *cx, JSObject *obj) const\\n+{\\n+  for (nsXBLProtoImplField* f = mFields; f; f = f->GetNext()) {\\n+    // Using OBJ_LOOKUP_PROPERTY is a pain, since what we have is a\\n+    // PRUnichar* for the property name.  Let's just use the public API and\\n+    // all.\\n+    nsDependentString name(f->GetName());\\n+    jsval dummy;\\n+    if (!::JS_LookupUCProperty(cx, obj,\\n+                               reinterpret_cast<const jschar*>(name.get()),\\n+                               name.Length(), &dummy)) {\\n+      return PR_FALSE;\\n+    }\\n+  }\\n+\\n+  return PR_TRUE;\\n+}\\n+\\n void\\n nsXBLProtoImpl::DestroyMembers(nsXBLProtoImplMember* aBrokenMember)\\n {\\ndiff --git a/content/xbl/src/nsXBLProtoImpl.h b/content/xbl/src/nsXBLProtoImpl.h\\nindex 54f36b1..15609f5 100644\\n--- a/content/xbl/src/nsXBLProtoImpl.h\\n+++ b/content/xbl/src/nsXBLProtoImpl.h\\n@@ -42,9 +42,11 @@\\n #include \\\"nsMemory.h\\\"\\n #include \\\"nsXBLPrototypeHandler.h\\\"\\n #include \\\"nsXBLProtoImplMember.h\\\"\\n-#include \\\"nsXBLPrototypeBinding.h\\\"\\n+#include \\\"nsXBLProtoImplField.h\\\"\\n \\n class nsIXPConnectJSObjectHolder;\\n+class nsXBLPrototypeBinding;\\n+class nsXBLProtoImplAnonymousMethod;\\n \\n class nsXBLProtoImpl\\n {\\n@@ -52,6 +54,7 @@ public:\\n   nsXBLProtoImpl() \\n     : mClassObject(nsnull),\\n       mMembers(nsnull),\\n+      mFields(nsnull),\\n       mConstructor(nsnull),\\n       mDestructor(nsnull)\\n   { \\n@@ -64,7 +67,8 @@ public:\\n     // clean them up automatically.\\n     for (nsXBLProtoImplMember* curr = mMembers; curr; curr=curr->GetNext())\\n       curr->Destroy(mClassObject != nsnull);\\n-    delete mMembers; \\n+    delete mMembers;\\n+    delete mFields;\\n   }\\n   \\n   nsresult InstallImplementation(nsXBLPrototypeBinding* aBinding, nsIContent* aBoundElement);\\n@@ -74,10 +78,26 @@ public:\\n                              void** aTargetClassObject);\\n   nsresult CompilePrototypeMembers(nsXBLPrototypeBinding* aBinding);\\n \\n-  void SetMemberList(nsXBLProtoImplMember* aMemberList) { delete mMembers; mMembers = aMemberList; }\\n+  void SetMemberList(nsXBLProtoImplMember* aMemberList)\\n+  {\\n+    delete mMembers;\\n+    mMembers = aMemberList;\\n+  }\\n+\\n+  void SetFieldList(nsXBLProtoImplField* aFieldList)\\n+  {\\n+    delete mFields;\\n+    mFields = aFieldList;\\n+  }\\n \\n   void Traverse(nsCycleCollectionTraversalCallback &cb) const;\\n \\n+  nsXBLProtoImplField* FindField(const nsString& aFieldName) const;\\n+\\n+  // Resolve all the fields for this implementation on the object |obj| False\\n+  // return means a JS exception was set.\\n+  PRBool ResolveAllFields(JSContext *cx, JSObject *obj) const;\\n+\\n protected:\\n   // Function to call if compilation of a member fails.  When this is called,\\n   // all members before aBrokenMember are compiled, compilation of\\n@@ -93,6 +113,8 @@ protected:\\n                         // and methods for the binding.\\n \\n   nsXBLProtoImplMember* mMembers; // The members of an implementation are chained in this singly-linked list.\\n+\\n+  nsXBLProtoImplField* mFields; // Our fields\\n   \\n public:\\n   nsXBLProtoImplAnonymousMethod* mConstructor; // Our class constructor.\\ndiff --git a/content/xbl/src/nsXBLProtoImplField.cpp b/content/xbl/src/nsXBLProtoImplField.cpp\\nindex 4c7480a..cf129df 100644\\n--- a/content/xbl/src/nsXBLProtoImplField.cpp\\n+++ b/content/xbl/src/nsXBLProtoImplField.cpp\\n@@ -46,14 +46,17 @@\\n #include \\\"nsXBLProtoImplField.h\\\"\\n #include \\\"nsIScriptContext.h\\\"\\n #include \\\"nsContentUtils.h\\\"\\n+#include \\\"nsIURI.h\\\"\\n \\n nsXBLProtoImplField::nsXBLProtoImplField(const PRUnichar* aName, const PRUnichar* aReadOnly)\\n-  : nsXBLProtoImplMember(aName),\\n+  : mNext(nsnull),\\n     mFieldText(nsnull),\\n     mFieldTextLength(0),\\n     mLineNumber(0)\\n {\\n   MOZ_COUNT_CTOR(nsXBLProtoImplField);\\n+  mName = NS_strdup(aName);  // XXXbz make more sense to use a stringbuffer?\\n+  \\n   mJSAttributes = JSPROP_ENUMERATE;\\n   if (aReadOnly) {\\n     nsAutoString readOnly; readOnly.Assign(*aReadOnly);\\n@@ -67,11 +70,8 @@ nsXBLProtoImplField::~nsXBLProtoImplField()\\n   MOZ_COUNT_DTOR(nsXBLProtoImplField);\\n   if (mFieldText)\\n     nsMemory::Free(mFieldText);\\n-}\\n-\\n-void\\n-nsXBLProtoImplField::Destroy(PRBool aIsCompiled)\\n-{\\n+  NS_Free(mName);\\n+  delete mNext;\\n }\\n \\n void \\n@@ -92,27 +92,15 @@ nsXBLProtoImplField::AppendFieldText(const nsAString& aText)\\n }\\n \\n nsresult\\n-nsXBLProtoImplField::InstallMember(nsIScriptContext* aContext,\\n-                                   nsIContent* aBoundElement, \\n-                                   void* aScriptObject,\\n-                                   void* aTargetClassObject,\\n-                                   const nsCString& aClassStr)\\n+nsXBLProtoImplField::InstallField(nsIScriptContext* aContext,\\n+                                  JSObject* aBoundNode,\\n+                                  nsIURI* aBindingDocURI) const\\n {\\n-  if (mFieldTextLength == 0)\\n-    return NS_OK; // nothing to do.\\n-\\n-  JSContext* cx = (JSContext*) aContext->GetNativeContext();\\n-  NS_ASSERTION(aScriptObject, \\\"uh-oh, script Object should NOT be null or bad things will happen\\\");\\n-  if (!aScriptObject)\\n-    return NS_ERROR_FAILURE;\\n+  NS_PRECONDITION(aBoundNode,\\n+                  \\\"uh-oh, bound node should NOT be null or bad things will \\\"\\n+                  \\\"happen\\\");\\n \\n-  nsCAutoString bindingURI(aClassStr);\\n-  PRInt32 hash = bindingURI.RFindChar('#');\\n-  if (hash != kNotFound)\\n-    bindingURI.Truncate(hash);\\n-  \\n-  // compile the literal string \\n-  jsval result = JSVAL_NULL;\\n+  jsval result = JSVAL_VOID;\\n   \\n   // EvaluateStringWithValue and JS_DefineUCProperty can both trigger GC, so\\n   // protect |result| here.\\n@@ -120,39 +108,40 @@ nsXBLProtoImplField::InstallMember(nsIScriptContext* aContext,\\n   nsAutoGCRoot root(&result, &rv);\\n   if (NS_FAILED(rv))\\n     return rv;\\n-  PRBool undefined;\\n-  // XXX Need a URI here!\\n-  nsCOMPtr<nsIScriptContext> context = aContext;\\n-  rv = context->EvaluateStringWithValue(nsDependentString(mFieldText,\\n-                                                          mFieldTextLength), \\n-                                        aScriptObject,\\n-                                        nsnull, bindingURI.get(),\\n-                                        mLineNumber, nsnull,\\n-                                        (void*) &result, &undefined);\\n-  if (NS_FAILED(rv))\\n-    return rv;\\n \\n-  if (!undefined) {\\n-    // Define the evaluated result as a JS property\\n-    nsDependentString name(mName);\\n-    JSAutoRequest ar(cx);\\n-    if (!::JS_DefineUCProperty(cx, static_cast<JSObject *>(aScriptObject),\\n-                               reinterpret_cast<const jschar*>(mName), \\n-                               name.Length(), result, nsnull, nsnull, mJSAttributes))\\n-      return NS_ERROR_OUT_OF_MEMORY;\\n-  }\\n+  if (mFieldTextLength != 0) {\\n+    nsCAutoString uriSpec;\\n+    aBindingDocURI->GetSpec(uriSpec);\\n   \\n-  return NS_OK;\\n-}\\n+    // compile the literal string\\n+    // XXX Could we produce a better principal here?  Should be able\\n+    // to, really!\\n+    PRBool undefined;\\n+    nsCOMPtr<nsIScriptContext> context = aContext;\\n+    rv = context->EvaluateStringWithValue(nsDependentString(mFieldText,\\n+                                                            mFieldTextLength), \\n+                                          aBoundNode,\\n+                                          nsnull, uriSpec.get(),\\n+                                          mLineNumber, nsnull,\\n+                                          (void*) &result, &undefined);\\n+    if (NS_FAILED(rv))\\n+      return rv;\\n \\n-nsresult \\n-nsXBLProtoImplField::CompileMember(nsIScriptContext* aContext, const nsCString& aClassStr,\\n-                                   void* aClassObject)\\n-{\\n-  return NS_OK;\\n-}\\n+    if (undefined) {\\n+      result = JSVAL_VOID;\\n+    }\\n+  }\\n \\n-void\\n-nsXBLProtoImplField::Traverse(nsCycleCollectionTraversalCallback &cb) const\\n-{\\n+  // Define the evaluated result as a JS property\\n+  nsDependentString name(mName);\\n+  JSContext* cx = (JSContext*) aContext->GetNativeContext();\\n+  JSAutoRequest ar(cx);\\n+  if (!::JS_DefineUCProperty(cx, aBoundNode,\\n+                             reinterpret_cast<const jschar*>(mName), \\n+                             name.Length(), result, nsnull, nsnull,\\n+                             mJSAttributes)) {\\n+    return NS_ERROR_OUT_OF_MEMORY;\\n+  }\\n+  \\n+  return NS_OK;\\n }\\ndiff --git a/content/xbl/src/nsXBLProtoImplField.h b/content/xbl/src/nsXBLProtoImplField.h\\nindex 06758e2..8c1d582 100644\\n--- a/content/xbl/src/nsXBLProtoImplField.h\\n+++ b/content/xbl/src/nsXBLProtoImplField.h\\n@@ -46,30 +46,31 @@\\n #include \\\"nsString.h\\\"\\n #include \\\"nsXBLProtoImplMember.h\\\"\\n \\n-class nsXBLProtoImplField: public nsXBLProtoImplMember\\n+class nsIURI;\\n+\\n+class nsXBLProtoImplField\\n {\\n public:\\n   nsXBLProtoImplField(const PRUnichar* aName, const PRUnichar* aReadOnly);\\n-  virtual ~nsXBLProtoImplField();\\n-  virtual void Destroy(PRBool aIsCompiled);\\n+  ~nsXBLProtoImplField();\\n \\n   void AppendFieldText(const nsAString& aText);\\n   void SetLineNumber(PRUint32 aLineNumber) {\\n     mLineNumber = aLineNumber;\\n   }\\n   \\n-  virtual nsresult InstallMember(nsIScriptContext* aContext,\\n-                                 nsIContent* aBoundElement, \\n-                                 void* aScriptObject,\\n-                                 void* aTargetClassObject,\\n-                                 const nsCString& aClassStr);\\n-  virtual nsresult CompileMember(nsIScriptContext* aContext,\\n-                                 const nsCString& aClassStr,\\n-                                 void* aClassObject);\\n+  nsXBLProtoImplField* GetNext() const { return mNext; }\\n+  void SetNext(nsXBLProtoImplField* aNext) { mNext = aNext; }\\n+\\n+  nsresult InstallField(nsIScriptContext* aContext,\\n+                        JSObject* aBoundNode, nsIURI*\\n+                        aBindingDocURI) const;\\n \\n-  virtual void Traverse(nsCycleCollectionTraversalCallback &cb) const;\\n+  const PRUnichar* GetName() const { return mName; }\\n \\n protected:\\n+  nsXBLProtoImplField* mNext;\\n+  PRUnichar* mName;\\n   PRUnichar* mFieldText;\\n   PRUint32 mFieldTextLength;\\n   PRUint32 mLineNumber;\\ndiff --git a/content/xbl/src/nsXBLPrototypeBinding.cpp b/content/xbl/src/nsXBLPrototypeBinding.cpp\\nindex 24f6205..db393bf 100644\\n--- a/content/xbl/src/nsXBLPrototypeBinding.cpp\\n+++ b/content/xbl/src/nsXBLPrototypeBinding.cpp\\n@@ -822,7 +822,7 @@ nsXBLPrototypeBinding::InitClass(const nsCString& aClassName,\\n   *aClassObject = nsnull;\\n \\n   return nsXBLBinding::DoInitJSClass(aContext, aGlobal, aScriptObject,\\n-                                     aClassName, aClassObject);\\n+                                     aClassName, this, aClassObject);\\n }\\n \\n nsIContent*\\ndiff --git a/content/xbl/src/nsXBLPrototypeBinding.h b/content/xbl/src/nsXBLPrototypeBinding.h\\nindex ee6e770..bb0d924 100644\\n--- a/content/xbl/src/nsXBLPrototypeBinding.h\\n+++ b/content/xbl/src/nsXBLPrototypeBinding.h\\n@@ -50,6 +50,7 @@\\n #include \\\"nsHashtable.h\\\"\\n #include \\\"nsIXBLDocumentInfo.h\\\"\\n #include \\\"nsCOMArray.h\\\"\\n+#include \\\"nsXBLProtoImpl.h\\\"\\n \\n class nsIAtom;\\n class nsIDocument;\\n@@ -58,7 +59,7 @@ class nsISupportsArray;\\n class nsSupportsHashtable;\\n class nsIXBLService;\\n class nsFixedSizeAllocator;\\n-class nsXBLProtoImpl;\\n+class nsXBLProtoImplField;\\n class nsXBLBinding;\\n \\n // *********************************************************************/\\n@@ -94,6 +95,22 @@ public:\\n   nsXBLProtoImplAnonymousMethod* GetDestructor();\\n   nsresult SetDestructor(nsXBLProtoImplAnonymousMethod* aDestructor);\\n \\n+  nsXBLProtoImplField* FindField(const nsString& aFieldName) const\\n+  {\\n+    return mImplementation ? mImplementation->FindField(aFieldName) : nsnull;\\n+  }\\n+\\n+  // Resolve all the fields for this binding on the object |obj|.\\n+  // False return means a JS exception was set.\\n+  PRBool ResolveAllFields(JSContext* cx, JSObject* obj) const\\n+  {\\n+    return !mImplementation || mImplementation->ResolveAllFields(cx, obj);\\n+  }\\n+\\n+  const nsCString& ClassName() const {\\n+    return mImplementation ? mImplementation->mClassName : EmptyCString();\\n+  }\\n+\\n   nsresult InitClass(const nsCString& aClassName, JSContext * aContext,\\n                      JSObject * aGlobal, JSObject * aScriptObject,\\n                      void ** aClassObject);\\ndiff --git a/content/xbl/test/Makefile.in b/content/xbl/test/Makefile.in\\nindex 029ec10..26db993 100644\\n--- a/content/xbl/test/Makefile.in\\n+++ b/content/xbl/test/Makefile.in\\n@@ -50,6 +50,7 @@ _TEST_FILES =\\t\\\\\\n \\t\\ttest_bug296375.xul \\\\\\n \\t\\ttest_bug366770.html \\\\\\n \\t\\ttest_bug371724.xhtml \\\\\\n+\\t\\ttest_bug372769.xhtml \\\\\\n \\t\\t$(NULL)\\n \\n libs:: $(_TEST_FILES)\\ndiff --git a/content/xbl/test/test_bug372769.xhtml b/content/xbl/test/test_bug372769.xhtml\\nnew file mode 100644\\nindex 0000000..3241d21\\n--- /dev/null\\n+++ b/content/xbl/test/test_bug372769.xhtml\\n@@ -0,0 +1,179 @@\\n+<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\\n+<!--\\n+https://bugzilla.mozilla.org/show_bug.cgi?id=372769\\n+-->\\n+<head>\\n+  <title>Test for Bug 372769</title>\\n+  <script type=\\\"text/javascript\\\" src=\\\"/MochiKit/packed.js\\\"></script>\\n+  <script type=\\\"text/javascript\\\" src=\\\"/tests/SimpleTest/SimpleTest.js\\\"></script>\\n+  <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"/tests/SimpleTest/test.css\\\" />\\n+  <bindings xmlns=\\\"http://www.mozilla.org/xbl\\\">\\n+    <binding id=\\\"test1\\\">\\n+      <implementation>\\n+        <field name=\\\"one\\\">1</field>\\n+        <field name=\\\"two\\\">9</field>\\n+        <field name=\\\"three\\\">3</field>\\n+        <field name=\\\"four\\\">10</field>\\n+        <field name=\\\"five\\\">11</field>\\n+        <field name=\\\"six\\\">this.four = 4; 6;</field>\\n+        <field name=\\\"seven\\\">this.five = 5; 7;</field>\\n+      </implementation>\\n+    </binding>\\n+\\n+    <binding id=\\\"test2\\\">\\n+      <implementation>\\n+        <!-- Tests for recursive resolves -->\\n+        <field name=\\\"eight\\\">this.eight</field>\\n+        <field name=\\\"nine\\\">this.ten</field>\\n+        <field name=\\\"ten\\\">this.nine</field>\\n+        <!-- Tests for non-DOM overrides -->\\n+        <field name=\\\"eleven\\\">11</field>\\n+        <field name=\\\"twelve\\\">12</field>\\n+        <!-- Tests for DOM overrides -->\\n+        <field name=\\\"parentNode\\\">this.parentNode</field>\\n+        <field name=\\\"ownerDocument\\\">\\\"ownerDocument override\\\"</field>\\n+      </implementation>\\n+    </binding>\\n+\\n+    <binding id=\\\"test3-ancestor\\\">\\n+      <implementation>\\n+        <field name=\\\"thirteen\\\">\\\"13 ancestor\\\"</field>\\n+        <field name=\\\"fourteen\\\">\\\"14 ancestor\\\"</field>\\n+        <property name=\\\"fifteen\\\" readonly=\\\"true\\\" onget=\\\"return '15 ancestor'\\\"/>\\n+      </implementation>\\n+    </binding>\\n+\\n+    <binding id=\\\"test3\\\" extends=\\\"#test3-ancestor\\\">\\n+      <implementation>\\n+        <field name=\\\"thirteen\\\">13</field>\\n+        <field name=\\\"fifteen\\\">15</field>\\n+        <field name=\\\"sixteen\\\">16</field>\\n+        <field name=\\\"sixteen\\\">\\\"16 later\\\"</field>\\n+        <field name=\\\"seventeen\\\">17</field>\\n+        <field name=\\\"eighteen\\\">\\\"18 field\\\"</field>\\n+        <property name=\\\"eighteen\\\" readonly=\\\"true\\\" onget=\\\"return 18\\\"/>\\n+        <property name=\\\"nineteen\\\" readonly=\\\"true\\\" onget=\\\"return 19\\\"/>\\n+        <field name=\\\"nineteen\\\">\\\"19 field\\\"</field>\\n+      </implementation>\\n+    </binding>\\n+\\n+    <binding id=\\\"test4\\\">\\n+      <implementation>\\n+        <field name=\\\"twenty\\\">for (var i in this) ; 20;</field>\\n+      </implementation>\\n+    </binding>\\n+\\n+      <binding id=\\\"test5\\\">\\n+      <implementation>\\n+        <field name=\\\"twenty-one\\\">for (var i in this) ; 21;</field>\\n+      </implementation>\\n+    </binding>\\n+</bindings>  \\n+</head>\\n+<body>\\n+<a target=\\\"_blank\\\" href=\\\"https://bugzilla.mozilla.org/show_bug.cgi?id=372769\\\">Mozilla Bug 372769</a>\\n+<p id=\\\"display1\\\" style=\\\"-moz-binding: url(#test1)\\\"></p>\\n+<p id=\\\"display2\\\" style=\\\"-moz-binding: url(#test2)\\\"></p>\\n+<p id=\\\"display3\\\" style=\\\"-moz-binding: url(#test3)\\\"></p>\\n+<p id=\\\"display4\\\" style=\\\"-moz-binding: url(#test4)\\\"></p>\\n+<p id=\\\"display5\\\" style=\\\"-moz-binding: url(#test5)\\\"></p>\\n+<div id=\\\"content\\\" style=\\\"display: none\\\">\\n+  \\n+</div>\\n+<pre id=\\\"test\\\">\\n+<script class=\\\"testbody\\\" type=\\\"text/javascript\\\">\\n+<![CDATA[\\n+\\n+/** Test for Bug 372769 **/\\n+SimpleTest.waitForExplicitFinish();\\n+addLoadEvent(function() {\\n+  var d = $(\\\"display1\\\");\\n+  is(d.one, 1, \\\"Should be able to read field\\\");\\n+\\n+  d.two = 2;\\n+  is(d.two, 2, \\\"Should be able to write field\\\");\\n+\\n+  is(\\\"three\\\" in d, true, 'Should have a property named \\\"three\\\"');\\n+  is(d.three, 3, \\\"Should be 3\\\");\\n+\\n+  is(d.four, 10, \\\"Unexpected value so far\\\");\\n+\\n+  // Save \\\"five\\\" for now\\n+\\n+  is(d.six, 6, \\\"Should be 6\\\");\\n+\\n+  is(d.four, 4, \\\"Now should be 4\\\");\\n+\\n+  d.four = 9;\\n+  is(d.four, 9, \\\"Just set it to 9\\\");\\n+  \\n+  var found = false;\\n+  for (var prop in d) {\\n+    if (prop == \\\"seven\\\") {\\n+      found = true;\\n+      break;\\n+    }\\n+  }\\n+  is(found, true, \\\"Enumeration is broken\\\");\\n+\\n+  is(d.four, 9, \\\"Shouldn't have rerun field six\\\");\\n+  is(d.five, 5, \\\"Should have run field 7\\\");\\n+  is(d.seven, 7, \\\"Should be 7\\\")\\n+\\n+  d = $(\\\"display2\\\");\\n+  is(typeof(d.eight), \\\"undefined\\\", \\\"Recursive resolve should bail out\\\");\\n+  is(typeof(d.nine), \\\"undefined\\\", \\\"Recursive double resolve should bail out\\\");\\n+  is(typeof(d.ten), \\\"undefined\\\",\\n+     \\\"This recursive double resolve should bail out too\\\");\\n+\\n+  // Get .eleven so it's resolved now\\n+  is(d.eleven, 11, \\\"Unexpected value for .eleven\\\");\\n+  var newProto = {};\\n+  newProto.eleven = \\\"Proto 11\\\";\\n+  newProto.twelve = \\\"Proto 12\\\";  \\n+  newProto.__proto__ = d.__proto__;\\n+  d.__proto__ = newProto;\\n+  is(d.eleven, 11, \\\"Proto should not have affected this\\\");\\n+  is(d.twelve, \\\"Proto 12\\\", \\\"Proto should have overridden 'twelve'\\\");\\n+  \\n+  is(d.parentNode, undefined, \\\"We overrode this, yes we did\\\");\\n+  is(typeof(d.parentNode), \\\"undefined\\\", \\\"This is a recursive resolve too\\\");\\n+  is(d.ownerDocument, \\\"ownerDocument override\\\",\\n+     \\\"Should have overridden ownerDocument\\\");\\n+\\n+  d = $(\\\"display3\\\");\\n+  is(d.thirteen, 13, \\\"descendant should win here\\\");\\n+  is(d.fourteen, \\\"14 ancestor\\\",\\n+     \\\"ancestor should win if descendant does nothing\\\")\\n+  is(d.fifteen, 15,\\n+     \\\"Field beats ancestor's property, since the latter lives on higher proto\\\")\\n+  is(d.sixteen, 16, \\\"First field wins\\\");\\n+  is(d.__proto__.seventeen, undefined, \\\"Shouldn't have this on proto\\\");\\n+  is(typeof(d.__proto__.seventeen), \\\"undefined\\\",\\n+     \\\"Really, should be undefined\\\");\\n+  is(d.seventeen, 17, \\\"Should have this prop on the node itself, though\\\");\\n+  is(d.eighteen, 18, \\\"Property beats field\\\");\\n+  is(d.nineteen, 19, \\\"Property still beats field\\\");\\n+\\n+  d = $(\\\"display4\\\");\\n+  is(d.twenty, 20, \\\"Should be 20\\\");\\n+\\n+  d = $(\\\"display5\\\");\\n+  found = false;\\n+  for (var prop2 in d) {\\n+    if (prop2 == \\\"twenty-one\\\") {\\n+      found = true;\\n+      break;\\n+    }\\n+  }\\n+  is(found, true, \\\"Enumeration is broken\\\");\\n+  is(d[\\\"twenty-one\\\"], 21, \\\"Should be 21\\\");\\n+  \\n+});\\n+addLoadEvent(SimpleTest.finish);\\n+]]>\\n+</script>\\n+</pre>\\n+</body>\\n+</html>\\n+\\ndiff --git a/dom/src/base/nsDOMClassInfo.cpp b/dom/src/base/nsDOMClassInfo.cpp\\nindex 5c18513..0ff7b6a 100644\\n--- a/dom/src/base/nsDOMClassInfo.cpp\\n+++ b/dom/src/base/nsDOMClassInfo.cpp\\n@@ -477,7 +477,8 @@ static const char kDOMStringBundleURL[] =\\n // possible.\\n \\n #define ELEMENT_SCRIPTABLE_FLAGS                                              \\\\\\n-  (NODE_SCRIPTABLE_FLAGS & ~nsIXPCScriptable::CLASSINFO_INTERFACES_ONLY)\\n+  ((NODE_SCRIPTABLE_FLAGS & ~nsIXPCScriptable::CLASSINFO_INTERFACES_ONLY) |   \\\\\\n+   nsIXPCScriptable::WANT_ENUMERATE)\\n \\n #define EXTERNAL_OBJ_SCRIPTABLE_FLAGS                                         \\\\\\n   (ELEMENT_SCRIPTABLE_FLAGS & ~nsIXPCScriptable::USE_JSSTUB_FOR_SETPROPERTY | \\\\\\n@@ -6940,6 +6941,32 @@ nsElementSH::PostCreate(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\\n   return NS_OK;\\n }\\n \\n+NS_IMETHODIMP\\n+nsElementSH::Enumerate(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\\n+                       JSObject *obj, PRBool *_retval)\\n+{\\n+  // Make sure to not call the superclass here!\\n+  nsCOMPtr<nsIContent> content(do_QueryWrappedNative(wrapper));\\n+  NS_ENSURE_TRUE(content, NS_ERROR_UNEXPECTED);\\n+\\n+  nsIDocument* doc = content->GetOwnerDoc();\\n+  if (!doc) {\\n+    // Nothing else to do here\\n+    return NS_OK;\\n+  }\\n+\\n+  nsXBLBinding* binding = doc->BindingManager()->GetBinding(content);\\n+  if (!binding) {\\n+    // Nothing else to do here\\n+    return NS_OK;\\n+  }\\n+\\n+  *_retval = binding->ResolveAllFields(cx, obj);\\n+  \\n+  return NS_OK;\\n+}\\n+  \\n+\\n // Generic array scriptable helper.\\n \\n NS_IMETHODIMP\\ndiff --git a/dom/src/base/nsDOMClassInfo.h b/dom/src/base/nsDOMClassInfo.h\\nindex da0f838..34bbc96 100644\\n--- a/dom/src/base/nsDOMClassInfo.h\\n+++ b/dom/src/base/nsDOMClassInfo.h\\n@@ -563,6 +563,8 @@ protected:\\n public:\\n   NS_IMETHOD PostCreate(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\\n                         JSObject *obj);\\n+  NS_IMETHOD Enumerate(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\\n+                       JSObject *obj, PRBool *_retval);\\n \\n   static nsIClassInfo *doCreate(nsDOMClassInfoData* aData)\\n   {\\n\""}