{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basbbc848d\""},"diff":"\"bbc848d Bug 389421. Rework word selection, in particular so that layout.word_select.stop_at_punctuation is applied to boundaries between punctuation and non-punctuation, and all Unicode punctuation is treated as punctuation.\\ndiff --git a/layout/generic/nsBRFrame.cpp b/layout/generic/nsBRFrame.cpp\\nindex 3ab544c..5c819cb 100644\\n--- a/layout/generic/nsBRFrame.cpp\\n+++ b/layout/generic/nsBRFrame.cpp\\n@@ -68,7 +68,7 @@ public:\\n   virtual PRBool PeekOffsetNoAmount(PRBool aForward, PRInt32* aOffset);\\n   virtual PRBool PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset);\\n   virtual PRBool PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,\\n-                                PRInt32* aOffset, PRBool* aSawBeforeType);\\n+                                PRInt32* aOffset, PeekWordState* aState);\\n \\n   NS_IMETHOD Reflow(nsPresContext* aPresContext,\\n                     nsHTMLReflowMetrics& aDesiredSize,\\n@@ -261,7 +261,7 @@ BRFrame::PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset)\\n \\n PRBool\\n BRFrame::PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,\\n-                        PRInt32* aOffset, PRBool* aSawBeforeType)\\n+                        PRInt32* aOffset, PeekWordState* aState)\\n {\\n   NS_ASSERTION (aOffset && *aOffset <= 1, \\\"aOffset out of range\\\");\\n   // Keep going. The actual line jumping will stop us.\\ndiff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp\\nindex 14d7f84..f29bac2 100644\\n--- a/layout/generic/nsFrame.cpp\\n+++ b/layout/generic/nsFrame.cpp\\n@@ -4647,7 +4647,7 @@ nsIFrame::PeekOffset(nsPeekOffsetStruct* aPos)\\n           nsContentUtils::GetBoolPref(\\\"layout.word_select.eat_space_to_next_word\\\");\\n       }\\n       \\n-      // sawBeforeType means \\\"we already saw characters of the type\\n+      // mSawBeforeType means \\\"we already saw characters of the type\\n       // before the boundary we're looking for\\\". Examples:\\n       // 1. If we're moving forward, looking for a word beginning (i.e. a boundary\\n       //    between whitespace and non-whitespace), then eatingWS==PR_TRUE means\\n@@ -4655,15 +4655,14 @@ nsIFrame::PeekOffset(nsPeekOffsetStruct* aPos)\\n       // 2. If we're moving backward, looking for a word beginning (i.e. a boundary\\n       //    between non-whitespace and whitespace), then eatingWS==PR_TRUE means\\n       //    \\\"we already saw some non-whitespace\\\".\\n-      PRBool sawBeforeType = PR_FALSE;\\n-\\n+      PeekWordState state;\\n       PRBool done = PR_FALSE;\\n       while (!done) {\\n         PRBool movingInFrameDirection =\\n           IsMovingInFrameDirection(current, aPos->mDirection, aPos->mVisual);\\n         \\n-        done = current->PeekOffsetWord(movingInFrameDirection, wordSelectEatSpace, aPos->mIsKeyboardSelect,\\n-                                       &offset, &sawBeforeType);\\n+        done = current->PeekOffsetWord(movingInFrameDirection, wordSelectEatSpace,\\n+                                       aPos->mIsKeyboardSelect, &offset, &state);\\n         \\n         if (!done) {\\n           nsIFrame* nextFrame;\\n@@ -4676,14 +4675,14 @@ nsIFrame::PeekOffset(nsPeekOffsetStruct* aPos)\\n           // We can't jump lines if we're looking for whitespace following\\n           // non-whitespace, and we already encountered non-whitespace.\\n           if (NS_FAILED(result) ||\\n-              jumpedLine && !wordSelectEatSpace && sawBeforeType) {\\n+              jumpedLine && !wordSelectEatSpace && state.mSawBeforeType) {\\n             done = PR_TRUE;\\n           } else {\\n             current = nextFrame;\\n             offset = nextFrameOffset;\\n             // Jumping a line is equivalent to encountering whitespace\\n             if (wordSelectEatSpace && jumpedLine)\\n-              sawBeforeType = PR_TRUE;\\n+              state.SetSawBeforeType();\\n           }\\n         }\\n       }\\n@@ -4889,7 +4888,7 @@ nsFrame::PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset)\\n \\n PRBool\\n nsFrame::PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,\\n-                        PRInt32* aOffset, PRBool* aSawBeforeType)\\n+                        PRInt32* aOffset, PeekWordState* aState)\\n {\\n   NS_ASSERTION (aOffset && *aOffset <= 1, \\\"aOffset out of range\\\");\\n   PRInt32 startOffset = *aOffset;\\n@@ -4898,16 +4897,41 @@ nsFrame::PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsK\\n   if (aForward == (startOffset == 0)) {\\n     // We're before the frame and moving forward, or after it and moving backwards.\\n     // If we're looking for non-whitespace, we found it (without skipping this frame).\\n-    if (aWordSelectEatSpace && *aSawBeforeType)\\n-      return PR_TRUE;\\n+    if (!aState->mAtStart) {\\n+      if (aState->mLastCharWasPunctuation) {\\n+        // We're not punctuation, so this is a punctuation boundary.\\n+        if (BreakWordBetweenPunctuation(aForward, aIsKeyboardSelect))\\n+          return PR_TRUE;\\n+      } else {\\n+        // This is not a punctuation boundary.\\n+        if (aWordSelectEatSpace && aState->mSawBeforeType)\\n+          return PR_TRUE;\\n+      }\\n+    }\\n     // Otherwise skip to the other side and note that we encountered non-whitespace.\\n     *aOffset = 1 - startOffset;\\n+    aState->Update(PR_FALSE);\\n     if (!aWordSelectEatSpace)\\n-      *aSawBeforeType = PR_TRUE;\\n+      aState->SetSawBeforeType();\\n   }\\n   return PR_FALSE;\\n }\\n \\n+PRBool\\n+nsFrame::BreakWordBetweenPunctuation(PRBool aAfterPunct, PRBool aIsKeyboardSelect)\\n+{\\n+  if (!nsContentUtils::GetBoolPref(\\\"layout.word_select.stop_at_punctuation\\\")) {\\n+    // When this pref is false, we never stop at a punctuation boundary.\\n+    return PR_FALSE;\\n+  }\\n+  if (!aIsKeyboardSelect) {\\n+    // mouse caret movement (e.g. word selection) always stops at every punctuation boundary\\n+    return PR_TRUE;\\n+  }\\n+  // keyboard caret movement stops after punctuation, not before it\\n+  return aAfterPunct;\\n+}\\n+\\n NS_IMETHODIMP\\n nsFrame::CheckVisibility(nsPresContext* , PRInt32 , PRInt32 , PRBool , PRBool *, PRBool *)\\n {\\ndiff --git a/layout/generic/nsFrame.h b/layout/generic/nsFrame.h\\nindex fd5a8d3..869271e 100644\\n--- a/layout/generic/nsFrame.h\\n+++ b/layout/generic/nsFrame.h\\n@@ -248,7 +248,13 @@ public:\\n   virtual PRBool PeekOffsetNoAmount(PRBool aForward, PRInt32* aOffset);\\n   virtual PRBool PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset);\\n   virtual PRBool PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,\\n-                                PRInt32* aOffset, PRBool* aSawBeforeType);\\n+                                PRInt32* aOffset, PeekWordState *aState);\\n+  /**\\n+   * Check whether we should break at a boundary between punctuation and\\n+   * non-punctuation.\\n+   * @param aAfterPunct true when this point is logically *after* punctuation.\\n+   */\\n+  PRBool BreakWordBetweenPunctuation(PRBool aAfterPunct, PRBool aIsKeyboardSelect);\\n   \\n   NS_IMETHOD  CheckVisibility(nsPresContext* aContext, PRInt32 aStartIndex, PRInt32 aEndIndex, PRBool aRecurse, PRBool *aFinished, PRBool *_retval);\\n \\ndiff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h\\nindex a956849..66f8ca3 100644\\n--- a/layout/generic/nsIFrame.h\\n+++ b/layout/generic/nsIFrame.h\\n@@ -2110,14 +2110,31 @@ protected:\\n    *         as a word on its own.\\n    * @param  aOffset [in/out] At what offset into the frame to start looking.\\n    *         on output - what offset was reached (whether or not we found a place to stop).\\n-   * @param  aSawBeforeType [in/out] Did we encounter a character of the pre-boundary type\\n-   *         (whitespace if aWordSelectEatSpace is true, non-whitespace otherwise).\\n+   * @param  aState [in/out] the state that is carried from frame to frame\\n    * @return PR_TRUE: An appropriate offset was found within this frame,\\n    *         and is given by aOffset.\\n    *         PR_FALSE: Not found within this frame, need to try the next frame.\\n    */\\n+  struct PeekWordState {\\n+    // true when we're still at the start of the search, i.e., we can't return\\n+    // this point as a valid offset!\\n+    PRPackedBool mAtStart;\\n+    // true when we've encountered at least one character of the pre-boundary type\\n+    // (whitespace if aWordSelectEatSpace is true, non-whitespace otherwise)\\n+    PRPackedBool mSawBeforeType;\\n+    // true when the last character encountered was punctuation\\n+    PRPackedBool mLastCharWasPunctuation;\\n+\\n+    PeekWordState() : mAtStart(PR_TRUE), mSawBeforeType(PR_FALSE),\\n+        mLastCharWasPunctuation(PR_FALSE) {}\\n+    void SetSawBeforeType() { mSawBeforeType = PR_TRUE; }\\n+    void Update(PRBool aAfterPunctuation) {\\n+      mLastCharWasPunctuation = aAfterPunctuation;\\n+      mAtStart = PR_FALSE;\\n+    }\\n+  };\\n   virtual PRBool PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,\\n-                                PRInt32* aOffset, PRBool* aSawBeforeType) = 0;\\n+                                PRInt32* aOffset, PeekWordState* aState) = 0;\\n \\n   /**\\n    * Search for the first paragraph boundary before or after the given position\\ndiff --git a/layout/generic/nsTextFrameThebes.cpp b/layout/generic/nsTextFrameThebes.cpp\\nindex 011900e..f1962e4 100644\\n--- a/layout/generic/nsTextFrameThebes.cpp\\n+++ b/layout/generic/nsTextFrameThebes.cpp\\n@@ -82,6 +82,8 @@\\n #include \\\"nsTextFrameTextRunCache.h\\\"\\n #include \\\"nsExpirationTracker.h\\\"\\n #include \\\"nsICaseConversion.h\\\"\\n+#include \\\"nsIUGenCategory.h\\\"\\n+#include \\\"nsUnicharUtilCIID.h\\\"\\n \\n #include \\\"nsTextFragment.h\\\"\\n #include \\\"nsGkAtoms.h\\\"\\n@@ -392,7 +394,7 @@ public:\\n   virtual PRBool PeekOffsetNoAmount(PRBool aForward, PRInt32* aOffset);\\n   virtual PRBool PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset);\\n   virtual PRBool PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,\\n-                                PRInt32* aOffset, PRBool* aSawBeforeType);\\n+                                PRInt32* aOffset, PeekWordState* aState);\\n \\n   NS_IMETHOD CheckVisibility(nsPresContext* aContext, PRInt32 aStartIndex, PRInt32 aEndIndex, PRBool aRecurse, PRBool *aFinished, PRBool *_retval);\\n   \\n@@ -4669,6 +4671,7 @@ public:\\n   PRInt32 GetBeforeOffset();\\n \\n private:\\n+  nsCOMPtr<nsIUGenCategory>   mCategories;\\n   gfxSkipCharsIterator        mIterator;\\n   const nsTextFragment*       mFrag;\\n   nsTextFrame*                mTextFrame;\\n@@ -4742,7 +4745,10 @@ PRBool\\n ClusterIterator::IsPunctuation()\\n {\\n   NS_ASSERTION(mCharIndex >= 0, \\\"No cluster selected\\\");\\n-  return nsTextFrameUtils::IsPunctuationMark(mFrag->CharAt(mCharIndex));\\n+  if (!mCategories)\\n+    return PR_FALSE;\\n+  nsIUGenCategory::nsUGenCategory c = mCategories->Get(mFrag->CharAt(mCharIndex));\\n+  return c == nsIUGenCategory::kPunctuation || c == nsIUGenCategory::kSymbol;\\n }\\n \\n PRBool\\n@@ -4810,26 +4816,32 @@ ClusterIterator::ClusterIterator(nsTextFrame* aTextFrame, PRInt32 aPosition,\\n   }\\n   mIterator.SetOriginalOffset(aPosition);\\n \\n+  mCategories = do_GetService(NS_UNICHARCATEGORY_CONTRACTID);\\n+  \\n   mFrag = aTextFrame->GetContent()->GetText();\\n   mTrimmed = aTextFrame->GetTrimmedOffsets(mFrag, PR_TRUE);\\n \\n   PRInt32 textLen = aTextFrame->GetContentLength();\\n-  if (!mWordBreaks.AppendElements(textLen)) {\\n+  if (!mWordBreaks.AppendElements(textLen + 1)) {\\n     mDirection = 0; // signal failure\\n     return;\\n   }\\n-  memset(mWordBreaks.Elements(), PR_FALSE, textLen);\\n+  memset(mWordBreaks.Elements(), PR_FALSE, textLen + 1);\\n   nsAutoString text;\\n   mFrag->AppendTo(text, aTextFrame->GetContentOffset(), textLen);\\n   nsIWordBreaker* wordBreaker = nsContentUtils::WordBreaker();\\n   PRInt32 i = 0;\\n-  while ((i = wordBreaker->NextWord(text.get(), textLen, i)) >= 0)\\n+  while ((i = wordBreaker->NextWord(text.get(), textLen, i)) >= 0) {\\n     mWordBreaks[i] = PR_TRUE;\\n+  }\\n+  // XXX this never allows word breaks at the start or end of the frame, but to fix\\n+  // this we would need to rewrite word-break detection to use the text from\\n+  // textruns or something. Not a regression, at least.\\n }\\n \\n PRBool\\n nsTextFrame::PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,\\n-                            PRInt32* aOffset, PRBool* aSawBeforeType)\\n+                            PRInt32* aOffset, PeekWordState* aState)\\n {\\n   PRInt32 contentLength = GetContentLength();\\n   NS_ASSERTION (aOffset && *aOffset <= contentLength, \\\"aOffset out of range\\\");\\n@@ -4846,24 +4858,25 @@ nsTextFrame::PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool\\n   if (!cIter.NextCluster())\\n     return PR_FALSE;\\n   \\n-  PRBool stopAfterPunctuation =\\n-\\t  nsContentUtils::GetBoolPref(\\\"layout.word_select.stop_at_punctuation\\\");\\n-  PRBool stopBeforePunctuation = stopAfterPunctuation && !aIsKeyboardSelect;\\n   do {\\n-    if (aWordSelectEatSpace == cIter.IsWhitespace() && !*aSawBeforeType) {\\n-      *aSawBeforeType = PR_TRUE;\\n+    PRBool isPunctuation = cIter.IsPunctuation();\\n+    if (aWordSelectEatSpace == cIter.IsWhitespace() && !aState->mSawBeforeType) {\\n+      aState->SetSawBeforeType();\\n+      aState->Update(isPunctuation);\\n       continue;\\n     }\\n-    if (cIter.GetBeforeOffset() != offset &&\\n-        (cIter.IsPunctuation() ? stopBeforePunctuation\\n-                               : cIter.HaveWordBreakBefore() && *aSawBeforeType)) {\\n-      *aOffset = cIter.GetBeforeOffset() - mContentOffset;\\n-      return PR_TRUE;\\n-    }\\n-    if (stopAfterPunctuation && cIter.IsPunctuation()) {\\n-      *aOffset = cIter.GetAfterOffset() - mContentOffset;\\n-      return PR_TRUE;\\n+    // See if we can break before the current cluster\\n+    if (!aState->mAtStart) {\\n+      PRBool canBreak = isPunctuation != aState->mLastCharWasPunctuation\\n+        ? BreakWordBetweenPunctuation(aForward ? aState->mLastCharWasPunctuation : isPunctuation,\\n+                                      aIsKeyboardSelect)\\n+        : cIter.HaveWordBreakBefore() && aState->mSawBeforeType;\\n+      if (canBreak) {\\n+        *aOffset = cIter.GetBeforeOffset() - mContentOffset;\\n+        return PR_TRUE;\\n+      }\\n     }\\n+    aState->Update(isPunctuation);\\n   } while (cIter.NextCluster());\\n \\n   *aOffset = cIter.GetAfterOffset() - mContentOffset;\\n\""}