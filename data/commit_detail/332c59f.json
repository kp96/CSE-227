{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas332c59f\""},"diff":"\"332c59f bug 393492: move mimeTypes.rdf datasource access code from nsExternalHelperAppService.cpp to nsHandlerService.js, fixing bug 393500 (auto-add preferred handler to possible handlers when retrieving them, since they won't be in there already on legacy datasources) in the process; r=biesi; sr=dmose; a=bsmedberg for 1.9\\ndiff --git a/netwerk/mime/public/nsIMIMEInfo.idl b/netwerk/mime/public/nsIMIMEInfo.idl\\nindex 57286e6..f31b6e5 100644\\n--- a/netwerk/mime/public/nsIMIMEInfo.idl\\n+++ b/netwerk/mime/public/nsIMIMEInfo.idl\\n@@ -21,6 +21,7 @@\\n  *\\n  * Contributor(s):\\n  *   Dan Mosedale <dmose@mozilla.org>\\n+ *   Myk Melez <myk@mozilla.org>\\n  *\\n  * Alternatively, the contents of this file may be used under the terms of\\n  * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n@@ -232,19 +233,32 @@ interface nsIMIMEInfo : nsIHandlerInfo {\\n \\n /**\\n  * nsIHandlerApp represents an external application that can handle content\\n- * of some sort (either a MIME-type or a protocol).  Note that for theoretical\\n- * cleanliness, nsI{Local,Web}HandlerApp really ought to inherit from\\n- * nsIHandlerApp.  After that's done, we should also try and make\\n- * nsIWebContentHandlerInfo inherit from or possibly be replaced by\\n- * nsIWebHandlerApp.\\n+ * of some sort (either a MIME type or a protocol).\\n+ *\\n+ * FIXME: now that we've made nsIWebHandlerApp inherit from nsIHandlerApp,\\n+ * we should also try to make nsIWebContentHandlerInfo inherit from or possibly\\n+ * be replaced by nsIWebHandlerApp (bug 394710).\\n  */\\n-[scriptable, uuid(08a543dc-081f-4933-b325-252cf68d6ad9)]\\n+[scriptable, uuid(b504f39e-d88a-4435-8e0d-e13f1070f7e7)]\\n interface nsIHandlerApp : nsISupports {\\n \\n     /**\\n      * Human readable name for the handler\\n      */\\n     attribute AString name;\\n+\\n+    /**\\n+     * Whether or not the given handler app is logically equivalent to the\\n+     * invokant (i.e. they represent the same app).\\n+     * \\n+     * Two apps are the same if they are both either local or web handlers\\n+     * and their executables/URI templates are the same in a string comparison.\\n+     *\\n+     * @param aHandlerApp the handler app to compare to the invokant\\n+     *\\n+     * @returns true if the two are logically equivalent, false otherwise\\n+     */\\n+    boolean equals(in nsIHandlerApp aHandlerApp);\\n };\\n \\n /**\\ndiff --git a/uriloader/exthandler/Makefile.in b/uriloader/exthandler/Makefile.in\\nindex b86b779..c3c56af 100644\\n--- a/uriloader/exthandler/Makefile.in\\n+++ b/uriloader/exthandler/Makefile.in\\n@@ -77,7 +77,6 @@ REQUIRES\\t= xpcom \\\\\\n \\t\\t  mimetype \\\\\\n \\t\\t  uriloader \\\\\\n \\t\\t  necko \\\\\\n-\\t\\t  rdf \\\\\\n \\t\\t  webshell \\\\\\n \\t\\t  plugin \\\\\\n \\t\\t  pref \\\\\\ndiff --git a/uriloader/exthandler/nsCExternalHandlerService.idl b/uriloader/exthandler/nsCExternalHandlerService.idl\\nindex b6cd551..cb47e20 100644\\n--- a/uriloader/exthandler/nsCExternalHandlerService.idl\\n+++ b/uriloader/exthandler/nsCExternalHandlerService.idl\\n@@ -55,6 +55,9 @@ nsIExternalHelperAppService\\n #define NS_EXTERNALHELPERAPPSERVICE_CONTRACTID \\\\\\n \\\"@mozilla.org/uriloader/external-helper-app-service;1\\\"\\n \\n+#define NS_HANDLERSERVICE_CONTRACTID \\\\\\n+\\\"@mozilla.org/uriloader/handler-service;1\\\"\\n+\\n #define NS_EXTERNALPROTOCOLSERVICE_CONTRACTID \\\\\\n \\\"@mozilla.org/uriloader/external-protocol-service;1\\\"\\n \\ndiff --git a/uriloader/exthandler/nsExternalHelperAppService.cpp b/uriloader/exthandler/nsExternalHelperAppService.cpp\\nindex 1513b3b..6f0f09a 100644\\n--- a/uriloader/exthandler/nsExternalHelperAppService.cpp\\n+++ b/uriloader/exthandler/nsExternalHelperAppService.cpp\\n@@ -68,14 +68,8 @@\\n #include \\\"nsAutoPtr.h\\\"\\n #include \\\"nsIMutableArray.h\\\"\\n \\n-// used to manage our in memory data source of helper applications\\n-#ifdef MOZ_RDF\\n-#include \\\"nsRDFCID.h\\\"\\n-#include \\\"rdf.h\\\"\\n-#include \\\"nsIRDFService.h\\\"\\n-#include \\\"nsIRDFRemoteDataSource.h\\\"\\n-#include \\\"nsHelperAppRDF.h\\\"\\n-#endif //MOZ_RDF\\n+// used to access our datastore of user-configured helper applications\\n+#include \\\"nsIHandlerService.h\\\"\\n #include \\\"nsIMIMEInfo.h\\\"\\n #include \\\"nsIRefreshURI.h\\\" // XXX needed to redirect according to Refresh: URI\\n #include \\\"nsIDocumentLoader.h\\\" // XXX needed to get orig. channel and assoc. refresh uri\\n@@ -140,9 +134,6 @@ static const char NEVER_ASK_PREF_BRANCH[] = \\\"browser.helperApps.neverAsk.\\\";\\n static const char NEVER_ASK_FOR_SAVE_TO_DISK_PREF[] = \\\"saveToDisk\\\";\\n static const char NEVER_ASK_FOR_OPEN_FILE_PREF[]    = \\\"openFile\\\";\\n \\n-#ifdef MOZ_RDF\\n-static NS_DEFINE_CID(kRDFServiceCID, NS_RDFSERVICE_CID);\\n-#endif\\n static NS_DEFINE_CID(kPluginManagerCID, NS_PLUGINMANAGER_CID);\\n \\n /**\\n@@ -496,7 +487,6 @@ NS_IMPL_ISUPPORTS6(\\n   nsISupportsWeakReference)\\n \\n nsExternalHelperAppService::nsExternalHelperAppService()\\n-: mDataSourceInitialized(PR_FALSE)\\n {\\n   gExtProtSvc = this;\\n }\\n@@ -523,71 +513,6 @@ nsExternalHelperAppService::~nsExternalHelperAppService()\\n   gExtProtSvc = nsnull;\\n }\\n \\n-nsresult nsExternalHelperAppService::InitDataSource()\\n-{\\n-#ifdef MOZ_RDF\\n-  nsresult rv = NS_OK;\\n-\\n-  // don't re-initialize the data source if we've already done so...\\n-  if (mDataSourceInitialized)\\n-    return NS_OK;\\n-\\n-  nsCOMPtr<nsIRDFService> rdf = do_GetService(kRDFServiceCID, &rv);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  // Get URI of the mimeTypes.rdf data source.  Do this the same way it's done in\\n-  // pref-applications-edit.xul, for example, to ensure we get the same data source!\\n-  // Note that the way it was done previously (using nsIFileSpec) worked better, but it\\n-  // produced a different uri (it had \\\"file:///C|\\\" instead of \\\"file:///C:\\\".  What can you do?\\n-  nsCOMPtr<nsIFile> mimeTypesFile;\\n-  rv = NS_GetSpecialDirectory(NS_APP_USER_MIMETYPES_50_FILE, getter_AddRefs(mimeTypesFile));\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-  \\n-  // Get file url spec to be used to initialize the DS.\\n-  nsCAutoString urlSpec;\\n-  rv = NS_GetURLSpecFromFile(mimeTypesFile, urlSpec);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  // Get the data source; if it is going to be created, then load is synchronous.\\n-  rv = rdf->GetDataSourceBlocking( urlSpec.get(), getter_AddRefs( mOverRideDataSource ) );\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  // initialize our resources if we haven't done so already...\\n-  if (!kNC_Description)\\n-  {\\n-    rdf->GetResource(NS_LITERAL_CSTRING(NC_RDF_DESCRIPTION),\\n-                     getter_AddRefs(kNC_Description));\\n-    rdf->GetResource(NS_LITERAL_CSTRING(NC_RDF_VALUE),\\n-                     getter_AddRefs(kNC_Value));\\n-    rdf->GetResource(NS_LITERAL_CSTRING(NC_RDF_FILEEXTENSIONS),\\n-                     getter_AddRefs(kNC_FileExtensions));\\n-    rdf->GetResource(NS_LITERAL_CSTRING(NC_RDF_PATH),\\n-                     getter_AddRefs(kNC_Path));\\n-    rdf->GetResource(NS_LITERAL_CSTRING(NC_RDF_SAVETODISK),\\n-                     getter_AddRefs(kNC_SaveToDisk));\\n-    rdf->GetResource(NS_LITERAL_CSTRING(NC_RDF_USESYSTEMDEFAULT),\\n-                     getter_AddRefs(kNC_UseSystemDefault));\\n-    rdf->GetResource(NS_LITERAL_CSTRING(NC_RDF_HANDLEINTERNAL),\\n-                     getter_AddRefs(kNC_HandleInternal));\\n-    rdf->GetResource(NS_LITERAL_CSTRING(NC_RDF_ALWAYSASK),\\n-                     getter_AddRefs(kNC_AlwaysAsk));  \\n-    rdf->GetResource(NS_LITERAL_CSTRING(NC_RDF_POSSIBLEAPPLICATION),\\n-                     getter_AddRefs(kNC_PossibleApplication));\\n-    rdf->GetResource(NS_LITERAL_CSTRING(NC_RDF_PRETTYNAME),\\n-                     getter_AddRefs(kNC_PrettyName));\\n-    rdf->GetResource(NS_LITERAL_CSTRING(NC_RDF_URITEMPLATE),\\n-                     getter_AddRefs(kNC_UriTemplate));\\n-     \\n-  }\\n-  \\n-  mDataSourceInitialized = PR_TRUE;\\n-\\n-  return rv;\\n-#else\\n-  return NS_ERROR_NOT_AVAILABLE;\\n-#endif\\n-}\\n-\\n NS_IMETHODIMP nsExternalHelperAppService::DoContent(const nsACString& aMimeContentType,\\n                                                     nsIRequest *aRequest,\\n                                                     nsIInterfaceRequestor *aWindowContext,\\n@@ -725,446 +650,6 @@ NS_IMETHODIMP nsExternalHelperAppService::ApplyDecodingForExtension(const nsACSt\\n   return NS_OK;\\n }\\n \\n-#ifdef MOZ_RDF\\n-nsresult nsExternalHelperAppService::FillMIMEExtensionProperties(\\n-  nsIRDFResource * aContentTypeNodeResource, nsIRDFService * aRDFService,\\n-  nsIMIMEInfo * aMIMEInfo)\\n-{\\n-  nsresult rv = NS_OK;\\n-  nsCOMPtr<nsIRDFNode> target;\\n-  nsCOMPtr<nsIRDFLiteral> literal;\\n-  const PRUnichar * stringValue;\\n-  \\n-  rv = InitDataSource();\\n-  if (NS_FAILED(rv)) return NS_OK;\\n-\\n-  // iterate over all the file type extensions...\\n-  nsCOMPtr<nsISimpleEnumerator> fileExtensions;\\n-  mOverRideDataSource->GetTargets(aContentTypeNodeResource, kNC_FileExtensions, PR_TRUE, getter_AddRefs(fileExtensions));\\n-\\n-  PRBool hasMoreElements = PR_FALSE;\\n-  nsCAutoString fileExtension; \\n-  nsCOMPtr<nsISupports> element;\\n-\\n-  if (fileExtensions)\\n-  {\\n-    fileExtensions->HasMoreElements(&hasMoreElements);\\n-    while (hasMoreElements)\\n-    { \\n-      fileExtensions->GetNext(getter_AddRefs(element));\\n-      if (element)\\n-      {\\n-        literal = do_QueryInterface(element);\\n-        if (!literal) return NS_ERROR_FAILURE;\\n-\\n-        literal->GetValueConst(&stringValue);\\n-        CopyUTF16toUTF8(stringValue, fileExtension);\\n-        if (!fileExtension.IsEmpty())\\n-          aMIMEInfo->AppendExtension(fileExtension);\\n-      }\\n-  \\n-      fileExtensions->HasMoreElements(&hasMoreElements);\\n-    } // while we have more extensions to parse....\\n-  }\\n-\\n-  return rv;\\n-}\\n-\\n-nsresult nsExternalHelperAppService::FillLiteralValueFromTarget(\\n-  nsIRDFResource * aSource, nsIRDFResource * aProperty,\\n-  const PRUnichar ** aLiteralValue)\\n-{\\n-  nsresult rv = NS_OK;\\n-  nsCOMPtr<nsIRDFLiteral> literal;\\n-  nsCOMPtr<nsIRDFNode> target;\\n-\\n-  *aLiteralValue = nsnull;\\n-  rv = InitDataSource();\\n-  if (NS_FAILED(rv)) return rv;\\n-\\n-  mOverRideDataSource->GetTarget(aSource, aProperty, PR_TRUE, getter_AddRefs(target));\\n-  if (target)\\n-  {\\n-    literal = do_QueryInterface(target);    \\n-    if (!literal)\\n-      return NS_ERROR_FAILURE;\\n-    literal->GetValueConst(aLiteralValue);\\n-  }\\n-  else\\n-    rv = NS_ERROR_FAILURE;\\n-\\n-  return rv;\\n-}\\n-\\n-nsresult nsExternalHelperAppService::FillHandlerAppFromSource(\\n-  nsIRDFResource * aSource, nsIHandlerApp ** aHandlerApp)\\n-{\\n-  nsresult rv = NS_OK;\\n-\\n-  const PRUnichar * appName = nsnull;\\n-  FillLiteralValueFromTarget(aSource, kNC_PrettyName, &appName);\\n-\\n-  // if we've got a path name, this must be a local app\\n-  const PRUnichar * path = nsnull;\\n-  FillLiteralValueFromTarget(aSource, kNC_Path, &path);\\n-  if (path && path[0])\\n-  {\\n-    nsCOMPtr<nsIFile> application;\\n-    GetFileTokenForPath(path, getter_AddRefs(application));\\n-    if (application) {\\n-      nsLocalHandlerApp *handlerApp(new nsLocalHandlerApp(appName, application));\\n-      if (!handlerApp) { \\n-        return NS_ERROR_OUT_OF_MEMORY;\\n-      }\\n-      NS_ADDREF(*aHandlerApp = handlerApp);\\n-    }\\n-  } else {\\n-    // if we got here, there's no path name in the RDF graph, so this must \\n-    // be a web app\\n-    const PRUnichar * uriTemplate = nsnull;\\n-    FillLiteralValueFromTarget(aSource, kNC_UriTemplate, &uriTemplate);\\n-    if (uriTemplate && uriTemplate[0]) {\\n-      nsCOMPtr<nsIWebHandlerApp> handlerApp =\\n-        do_CreateInstance(NS_WEBHANDLERAPP_CONTRACTID, &rv);\\n-      NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-      handlerApp->SetName(nsDependentString(appName));\\n-      handlerApp->SetUriTemplate(NS_ConvertUTF16toUTF8(uriTemplate));\\n-\\n-      NS_ADDREF(*aHandlerApp = handlerApp);\\n-    } else {\\n-      return NS_ERROR_FAILURE; // no path name _and_ no uri template\\n-    }\\n-  }\\n-\\n-  return rv;\\n-}\\n-\\n-nsresult nsExternalHelperAppService::FillPossibleAppsFromSource(\\n-  nsIRDFResource * aSource, nsIMutableArray * aPossibleApps)\\n-{\\n-  nsresult rv = NS_OK;\\n-\\n-  rv = InitDataSource();\\n-  if (NS_FAILED(rv)) return rv;\\n-\\n-  nsCOMPtr<nsISimpleEnumerator> possibleAppResources;\\n-  rv = mOverRideDataSource->GetTargets(aSource, kNC_PossibleApplication, PR_TRUE,\\n-                                       getter_AddRefs(possibleAppResources));\\n-  if (NS_FAILED(rv)) return rv;\\n-\\n-  PRBool more;\\n-  nsCOMPtr<nsISupports> supports;\\n-  while (NS_SUCCEEDED(possibleAppResources->HasMoreElements(&more)) && more) {\\n-    rv = possibleAppResources->GetNext(getter_AddRefs(supports));\\n-    if (NS_FAILED(rv)) return rv;\\n-\\n-    nsCOMPtr<nsIRDFResource> possibleAppResource = do_QueryInterface(supports);\\n-\\n-    if (possibleAppResource) {\\n-      nsCOMPtr<nsIHandlerApp> possibleApp;\\n-      rv = FillHandlerAppFromSource(possibleAppResource, getter_AddRefs(possibleApp));\\n-      // It's ok if we failed to get one of the possible apps, as some of the\\n-      // others might still be good, so merely continue on failure.\\n-      if (NS_FAILED(rv)) continue;\\n-\\n-      rv = aPossibleApps->AppendElement(possibleApp, PR_FALSE);\\n-      if (NS_FAILED(rv)) return rv;\\n-    }\\n-  }\\n-\\n-  return NS_OK;\\n-}\\n-\\n-\\n-nsresult nsExternalHelperAppService::FillContentHandlerProperties(\\n-  const char * aContentType, const char * aTypeNodePrefix,\\n-  nsIRDFService * aRDFService, nsIHandlerInfo * aHandlerInfo)\\n-{\\n-  nsCOMPtr<nsIRDFNode> target;\\n-  nsCOMPtr<nsIRDFLiteral> literal;\\n-  const PRUnichar * stringValue = nsnull;\\n-  nsresult rv = NS_OK;\\n-\\n-  rv = InitDataSource();\\n-  if (NS_FAILED(rv)) return rv;\\n-\\n-  nsCAutoString contentTypeHandlerNodeName(aTypeNodePrefix);\\n-  contentTypeHandlerNodeName.Append(NC_HANDLER_SUFFIX);\\n-  contentTypeHandlerNodeName.Append(aContentType);\\n-\\n-  nsCOMPtr<nsIRDFResource> contentTypeHandlerNodeResource;\\n-  aRDFService->GetResource(contentTypeHandlerNodeName, getter_AddRefs(contentTypeHandlerNodeResource));\\n-  NS_ENSURE_TRUE(contentTypeHandlerNodeResource, NS_ERROR_FAILURE); // that's not good! we have an error in the rdf file\\n-\\n-  // now process the application handler information\\n-  aHandlerInfo->SetPreferredAction(nsIHandlerInfo::useHelperApp);\\n-\\n-  // save to disk\\n-  FillLiteralValueFromTarget(contentTypeHandlerNodeResource,kNC_SaveToDisk, &stringValue);\\n-  NS_NAMED_LITERAL_STRING(trueString, \\\"true\\\");\\n-  NS_NAMED_LITERAL_STRING(falseString, \\\"false\\\");\\n-  if (stringValue && trueString.Equals(stringValue))\\n-       aHandlerInfo->SetPreferredAction(nsIHandlerInfo::saveToDisk);\\n-\\n-  // use system default\\n-  FillLiteralValueFromTarget(contentTypeHandlerNodeResource,kNC_UseSystemDefault, &stringValue);\\n-  if (stringValue && trueString.Equals(stringValue))\\n-      aHandlerInfo->SetPreferredAction(nsIHandlerInfo::useSystemDefault);\\n-\\n-  // handle internal\\n-  FillLiteralValueFromTarget(contentTypeHandlerNodeResource,kNC_HandleInternal, &stringValue);\\n-  if (stringValue && trueString.Equals(stringValue))\\n-       aHandlerInfo->SetPreferredAction(nsIHandlerInfo::handleInternally);\\n-  \\n-  // always ask\\n-  FillLiteralValueFromTarget(contentTypeHandlerNodeResource,kNC_AlwaysAsk, &stringValue);\\n-  // Only skip asking if we are absolutely sure the user does not want\\n-  // to be asked.  Any sort of bofus data should mean we ask.\\n-  aHandlerInfo->SetAlwaysAskBeforeHandling(!stringValue ||\\n-                                           !falseString.Equals(stringValue));\\n-\\n-\\n-  // now digest the external application information\\n-\\n-  // Clear out any possibly set applications to match the datasource.\\n-  aHandlerInfo->SetPreferredApplicationHandler(nsnull);\\n-\\n-  // Get the preferred application, if any.\\n-  nsCAutoString externalAppNodeName(aTypeNodePrefix);\\n-  externalAppNodeName.AppendLiteral(NC_EXTERNALAPP_SUFFIX);\\n-  externalAppNodeName.Append(aContentType);\\n-  nsCOMPtr<nsIRDFResource> externalAppNodeResource;\\n-  aRDFService->GetResource(externalAppNodeName, getter_AddRefs(externalAppNodeResource));\\n-\\n-  if (externalAppNodeResource)\\n-  {\\n-    nsCOMPtr<nsIHandlerApp> preferredApp;\\n-    rv = FillHandlerAppFromSource(externalAppNodeResource, getter_AddRefs(preferredApp));\\n-\\n-    if (NS_SUCCEEDED(rv))\\n-      aHandlerInfo->SetPreferredApplicationHandler(preferredApp);\\n-  }\\n-\\n-  // Get the possible applications, if any.\\n-  nsCOMPtr<nsIMutableArray> possibleApps;\\n-  rv = aHandlerInfo->GetPossibleApplicationHandlers(getter_AddRefs(possibleApps));\\n-  if (NS_FAILED(rv)) return rv;\\n-\\n-  // Clear out any possibly set applications to match the datasource.\\n-  possibleApps->Clear();\\n-\\n-  rv = FillPossibleAppsFromSource(contentTypeHandlerNodeResource, possibleApps);\\n-\\n-  return rv;\\n-}\\n-#endif /* MOZ_RDF */\\n-\\n-PRBool nsExternalHelperAppService::MIMETypeIsInDataSource(const char * aContentType)\\n-{\\n-#ifdef MOZ_RDF\\n-  nsresult rv = InitDataSource();\\n-  if (NS_FAILED(rv)) return PR_FALSE;\\n-  \\n-  if (mOverRideDataSource)\\n-  {\\n-    // Get the RDF service.\\n-    nsCOMPtr<nsIRDFService> rdf = do_GetService(kRDFServiceCID, &rv);\\n-    if (NS_FAILED(rv)) return PR_FALSE;\\n-    \\n-    // Build uri for the mimetype resource.\\n-    nsCAutoString contentTypeNodeName(NC_CONTENT_NODE_PREFIX);\\n-    nsCAutoString contentType(aContentType);\\n-    ToLowerCase(contentType);\\n-    contentTypeNodeName.Append(contentType);\\n-    \\n-    // Get the mime type resource.\\n-    nsCOMPtr<nsIRDFResource> contentTypeNodeResource;\\n-    rv = rdf->GetResource(contentTypeNodeName, getter_AddRefs(contentTypeNodeResource));\\n-    if (NS_FAILED(rv)) return PR_FALSE;\\n-    \\n-    // Test that there's a #value arc from the mimetype resource to the mimetype literal string.\\n-    nsCOMPtr<nsIRDFLiteral> mimeLiteral;\\n-    NS_ConvertUTF8toUTF16 mimeType(contentType);\\n-    rv = rdf->GetLiteral( mimeType.get(), getter_AddRefs( mimeLiteral ) );\\n-    if (NS_FAILED(rv)) return PR_FALSE;\\n-    \\n-    PRBool exists = PR_FALSE;\\n-    rv = mOverRideDataSource->HasAssertion(contentTypeNodeResource, kNC_Value, mimeLiteral, PR_TRUE, &exists );\\n-    \\n-    if (NS_SUCCEEDED(rv) && exists) return PR_TRUE;\\n-  }\\n-#endif\\n-  return PR_FALSE;\\n-}\\n-\\n-nsresult nsExternalHelperAppService::FillMIMEInfoForMimeTypeFromDS(\\n-  const nsACString& aContentType, nsIMIMEInfo * aMIMEInfo)\\n-{\\n-#ifdef MOZ_RDF\\n-  NS_ENSURE_ARG_POINTER(aMIMEInfo);\\n-  nsresult rv = InitDataSource();\\n-  if (NS_FAILED(rv)) return rv;\\n-\\n-  // can't do anything if we have no datasource...\\n-  if (!mOverRideDataSource)\\n-    return NS_ERROR_FAILURE;\\n-\\n-  // Get the RDF service.\\n-  nsCOMPtr<nsIRDFService> rdf = do_GetService(kRDFServiceCID, &rv);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  // get lowercase typename & uri for the handlertype resource.\\n-  nsCAutoString typeNodeName(NC_CONTENT_NODE_PREFIX);\\n-  nsCAutoString type(aContentType);\\n-  ToLowerCase(type);\\n-  typeNodeName.Append(type);\\n-\\n-  // Get the handler type resource.\\n-  nsCOMPtr<nsIRDFResource> typeNodeResource;\\n-  rv = rdf->GetResource(typeNodeName, getter_AddRefs(typeNodeResource));\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  // fill in MIME-specific extension info\\n-  rv = FillMIMEExtensionProperties(typeNodeResource, rdf, aMIMEInfo);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  return FillHandlerInfoForTypeFromDS(typeNodeResource.get(), type, rdf, \\n-                                      NC_CONTENT_NODE_PREFIX, aMIMEInfo); \\n-#else\\n-  return NS_ERROR_NOT_AVAILABLE;\\n-#endif\\n-}\\n-\\n-nsresult nsExternalHelperAppService::FillProtoInfoForSchemeFromDS(\\n-    const nsACString& aType, nsIHandlerInfo * aHandlerInfo)\\n-{\\n-#ifdef MOZ_RDF\\n-  NS_ENSURE_ARG_POINTER(aHandlerInfo);\\n-  nsresult rv = InitDataSource();\\n-  if (NS_FAILED(rv)) return rv;\\n-\\n-  // can't do anything if we have no datasource...\\n-  if (!mOverRideDataSource)\\n-    return NS_ERROR_FAILURE;\\n-\\n-  // Get the RDF service.\\n-  nsCOMPtr<nsIRDFService> rdf = do_GetService(kRDFServiceCID, &rv);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  // get lowercase typename & get uri for the handlertype resource.\\n-  nsCAutoString typeNodeName(NC_SCHEME_NODE_PREFIX);\\n-  nsCAutoString type(aType);\\n-  ToLowerCase(type);\\n-  typeNodeName.Append(type);\\n-\\n-  // Get the handler type resource.\\n-  nsCOMPtr<nsIRDFResource> typeNodeResource;\\n-  rv = rdf->GetResource(typeNodeName, getter_AddRefs(typeNodeResource));\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  return FillHandlerInfoForTypeFromDS(typeNodeResource.get(), type, rdf,\\n-                                      NC_SCHEME_NODE_PREFIX, aHandlerInfo);\\n-#else\\n-  return NS_ERROR_NOT_AVAILABLE;\\n-#endif\\n-}\\n-\\n-#ifdef MOZ_RDF\\n-nsresult nsExternalHelperAppService::FillHandlerInfoForTypeFromDS(\\n-  nsIRDFResource *aTypeNodeResource, const nsCAutoString &aType, \\n-  nsIRDFService *rdf, const char *aTypeNodePrefix,\\n-  nsIHandlerInfo * aHandlerInfo)\\n-{\\n-\\n-  // we need a way to determine if this type resource is really in the graph\\n-  // or not... Test that there's a #value arc from the type resource to the\\n-  // type literal string.\\n-  nsCOMPtr<nsIRDFLiteral> typeLiteral;\\n-  NS_ConvertUTF8toUTF16 UTF16Type(aType);\\n-  nsresult rv = rdf->GetLiteral( UTF16Type.get(), \\n-                                 getter_AddRefs( typeLiteral ) );\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-  \\n-  PRBool exists = PR_FALSE;\\n-  rv = mOverRideDataSource->HasAssertion(aTypeNodeResource, kNC_Value,\\n-                                         typeLiteral, PR_TRUE, &exists );\\n-  if (NS_SUCCEEDED(rv) && exists)\\n-  {\\n-     // fill in the handlerinfo based on the values from the data source\\n-\\n-     // set the pretty name description, if nonempty\\n-     const PRUnichar *stringValue;\\n-     FillLiteralValueFromTarget(aTypeNodeResource, kNC_Description, \\n-                                &stringValue);\\n-     if (stringValue && *stringValue)\\n-       aHandlerInfo->SetDescription(nsDependentString(stringValue));\\n-\\n-     rv = FillContentHandlerProperties(aType.get(), aTypeNodePrefix,\\n-                                       rdf, aHandlerInfo);\\n-\\n-  } // if we have a node in the graph for this content type\\n-  // If we had success, but entry doesn't exist, we don't want to return success\\n-  else if (NS_SUCCEEDED(rv)) {\\n-    rv = NS_ERROR_NOT_AVAILABLE;\\n-  }\\n-\\n-  return rv;\\n-}\\n-#endif /* MOZ_RDF */\\n-\\n-nsresult nsExternalHelperAppService::FillMIMEInfoForExtensionFromDS(\\n-  const nsACString& aFileExtension, nsIMIMEInfo * aMIMEInfo)\\n-{\\n-  nsCAutoString type;\\n-  PRBool found = GetTypeFromDS(aFileExtension, type);\\n-  if (!found)\\n-    return NS_ERROR_NOT_AVAILABLE;\\n-\\n-  return FillMIMEInfoForMimeTypeFromDS(type, aMIMEInfo);\\n-}\\n-\\n-PRBool nsExternalHelperAppService::GetTypeFromDS(const nsACString& aExtension,\\n-                                                 nsACString& aType)\\n-{\\n-#ifdef MOZ_RDF\\n-  nsresult rv = InitDataSource();\\n-  if (NS_FAILED(rv))\\n-    return PR_FALSE;\\n-\\n-  // Can't do anything without a datasource\\n-  if (!mOverRideDataSource)\\n-    return PR_FALSE;\\n-\\n-  // Get the RDF service.\\n-  nsCOMPtr<nsIRDFService> rdf = do_GetService(kRDFServiceCID, &rv);\\n-  NS_ENSURE_SUCCESS(rv, PR_FALSE);\\n-\\n-  NS_ConvertUTF8toUTF16 extension(aExtension);\\n-  ToLowerCase(extension);\\n-  nsCOMPtr<nsIRDFLiteral> extensionLiteral;\\n-  rv = rdf->GetLiteral(extension.get(), getter_AddRefs(extensionLiteral));\\n-  NS_ENSURE_SUCCESS(rv, PR_FALSE);\\n-\\n-  nsCOMPtr<nsIRDFResource> contentTypeNodeResource;\\n-  rv = mOverRideDataSource->GetSource(kNC_FileExtensions,\\n-                                      extensionLiteral,\\n-                                      PR_TRUE,\\n-                                      getter_AddRefs(contentTypeNodeResource));\\n-  nsCAutoString contentTypeStr;\\n-  if (NS_SUCCEEDED(rv) && contentTypeNodeResource)\\n-  {\\n-    const PRUnichar* contentType = nsnull;\\n-    rv = FillLiteralValueFromTarget(contentTypeNodeResource, kNC_Value, &contentType);\\n-    if (contentType) {\\n-      LossyCopyUTF16toASCII(contentType, aType);\\n-      return PR_TRUE;\\n-    }\\n-  }  // if we have a node in the graph for this extension\\n-#endif /* MOZ_RDF */\\n-  return PR_FALSE;\\n-}\\n-\\n nsresult nsExternalHelperAppService::GetFileTokenForPath(const PRUnichar * aPlatformAppPath,\\n                                                          nsIFile ** aFile)\\n {\\n@@ -1413,8 +898,12 @@ nsExternalHelperAppService::GetProtocolHandlerInfo(const nsACString &aScheme,\\n     return NS_ERROR_FAILURE;\\n   }\\n \\n-  nsresult rv = FillProtoInfoForSchemeFromDS(aScheme, *aHandlerInfo);     \\n-  if (NS_ERROR_NOT_AVAILABLE == rv) {\\n+  nsresult rv = NS_ERROR_FAILURE;\\n+  nsCOMPtr<nsIHandlerService> handlerSvc = do_GetService(NS_HANDLERSERVICE_CONTRACTID);\\n+  if (handlerSvc)\\n+    rv = handlerSvc->FillHandlerInfo(*aHandlerInfo, EmptyCString());\\n+\\n+  if (NS_FAILED(rv)) {\\n     // We don't know it, so we always ask the user.  By the time we call this\\n     // method, we already have checked if we should open this protocol and ask\\n     // the user, so these defaults are OK.\\n@@ -1427,9 +916,6 @@ nsExternalHelperAppService::GetProtocolHandlerInfo(const nsACString &aScheme,\\n       (*aHandlerInfo)->SetPreferredAction(nsIHandlerInfo::useSystemDefault);\\n     else\\n       (*aHandlerInfo)->SetPreferredAction(nsIHandlerInfo::alwaysAsk);\\n-  } else if (NS_FAILED(rv)) {\\n-    NS_RELEASE(*aHandlerInfo);\\n-    return rv;\\n   }\\n \\n   return NS_OK;\\n@@ -1441,13 +927,6 @@ nsExternalHelperAppService::Observe(nsISupports *aSubject, const char *aTopic, c\\n {\\n   if (!strcmp(aTopic, \\\"profile-before-change\\\")) {\\n     ExpungeTemporaryFiles();\\n-#ifdef MOZ_RDF\\n-    nsCOMPtr <nsIRDFRemoteDataSource> flushableDataSource = do_QueryInterface(mOverRideDataSource);\\n-    if (flushableDataSource)\\n-      flushableDataSource->Flush();\\n-    mOverRideDataSource = nsnull;\\n-    mDataSourceInitialized = PR_FALSE;\\n-#endif\\n   }\\n   return NS_OK;\\n }\\n@@ -1855,12 +1334,17 @@ NS_IMETHODIMP nsExternalAppHandler::OnStartRequest(nsIRequest *request, nsISuppo\\n   if (alwaysAsk)\\n   {\\n     // But we *don't* ask if this mimeInfo didn't come from\\n-    // our mimeTypes.rdf data source and the user has said\\n+    // our user configuration datastore and the user has said\\n     // at some point in the distant past that they don't\\n     // want to be asked.  The latter fact would have been\\n     // stored in pref strings back in the old days.\\n     NS_ASSERTION(gExtProtSvc, \\\"Service gone away!?\\\");\\n-    if (!gExtProtSvc->MIMETypeIsInDataSource(MIMEType.get()))\\n+\\n+    PRBool mimeTypeIsInDatastore = PR_FALSE;\\n+    nsCOMPtr<nsIHandlerService> handlerSvc = do_GetService(NS_HANDLERSERVICE_CONTRACTID);\\n+    if (handlerSvc)\\n+      handlerSvc->Exists(mMimeInfo, &mimeTypeIsInDatastore);\\n+    if (!handlerSvc || !mimeTypeIsInDatastore)\\n     {\\n       if (!GetNeverAskFlagFromPref(NEVER_ASK_FOR_SAVE_TO_DISK_PREF, MIMEType.get()))\\n       {\\n@@ -2773,20 +2257,27 @@ NS_IMETHODIMP nsExternalHelperAppService::GetFromTypeAndExtension(const nsACStri\\n   if (!*_retval)\\n     return NS_ERROR_OUT_OF_MEMORY;\\n \\n-  // (2) Now, let's see if we can find something in our datasource\\n+  // (2) Now, let's see if we can find something in our datastore\\n   // This will not overwrite the OS information that interests us\\n   // (i.e. default application, default app. description)\\n-  nsresult rv = FillMIMEInfoForMimeTypeFromDS(typeToUse, *_retval);\\n-  found = found || NS_SUCCEEDED(rv);\\n-\\n-  LOG((\\\"Data source: Via type: retval 0x%08x\\\\n\\\", rv));\\n-\\n-  if (!found || NS_FAILED(rv)) {\\n-    // No type match, try extension match\\n-    if (!aFileExt.IsEmpty()) {\\n-      rv = FillMIMEInfoForExtensionFromDS(aFileExt, *_retval);\\n-      LOG((\\\"Data source: Via ext: retval 0x%08x\\\\n\\\", rv));\\n-      found = found || NS_SUCCEEDED(rv);\\n+  nsresult rv;\\n+  nsCOMPtr<nsIHandlerService> handlerSvc = do_GetService(NS_HANDLERSERVICE_CONTRACTID);\\n+  if (handlerSvc) {\\n+    rv = handlerSvc->FillHandlerInfo(*_retval, EmptyCString());\\n+    LOG((\\\"Data source: Via type: retval 0x%08x\\\\n\\\", rv));\\n+    found = found || NS_SUCCEEDED(rv);\\n+\\n+    if (!found || NS_FAILED(rv)) {\\n+      // No type match, try extension match\\n+      if (!aFileExt.IsEmpty()) {\\n+        nsCAutoString overrideType;\\n+        rv = handlerSvc->GetTypeFromExtension(aFileExt, overrideType);\\n+        if (NS_SUCCEEDED(rv)) {\\n+          rv = handlerSvc->FillHandlerInfo(*_retval, overrideType);\\n+          LOG((\\\"Data source: Via ext: retval 0x%08x\\\\n\\\", rv));\\n+          found = found || NS_SUCCEEDED(rv);\\n+        }\\n+      }\\n     }\\n   }\\n \\n@@ -2840,7 +2331,7 @@ NS_IMETHODIMP nsExternalHelperAppService::GetTypeFromExtension(const nsACString&\\n {\\n   // OK. We want to try the following sources of mimetype information, in this order:\\n   // 1. defaultMimeEntries array\\n-  // 2. User-set preferences (mimeTypes.rdf)\\n+  // 2. User-set preferences (managed by the handler service)\\n   // 3. OS-provided information\\n   // 4. our \\\"extras\\\" array\\n   // 5. Information from plugins\\n@@ -2856,12 +2347,15 @@ NS_IMETHODIMP nsExternalHelperAppService::GetTypeFromExtension(const nsACString&\\n     }\\n   }\\n \\n-  // Check RDF DS\\n-  PRBool found = GetTypeFromDS(aFileExt, aContentType);\\n-  if (found)\\n+  // Check user-set prefs\\n+  nsCOMPtr<nsIHandlerService> handlerSvc = do_GetService(NS_HANDLERSERVICE_CONTRACTID);\\n+  if (handlerSvc)\\n+    rv = handlerSvc->GetTypeFromExtension(aFileExt, aContentType);\\n+  if (NS_SUCCEEDED(rv))\\n     return NS_OK;\\n \\n   // Ask OS.\\n+  PRBool found = PR_FALSE;\\n   nsCOMPtr<nsIMIMEInfo> mi = GetMIMEInfoFromOS(EmptyCString(), aFileExt, &found);\\n   if (mi && found)\\n     return mi->GetMIMEType(aContentType);\\ndiff --git a/uriloader/exthandler/nsExternalHelperAppService.h b/uriloader/exthandler/nsExternalHelperAppService.h\\nindex b6e346f..8214f03 100644\\n--- a/uriloader/exthandler/nsExternalHelperAppService.h\\n+++ b/uriloader/exthandler/nsExternalHelperAppService.h\\n@@ -69,10 +69,7 @@\\n #include \\\"nsIChannel.h\\\"\\n #include \\\"nsITimer.h\\\"\\n \\n-#ifdef MOZ_RDF\\n-#include \\\"nsIRDFDataSource.h\\\"\\n-#include \\\"nsIRDFResource.h\\\"\\n-#endif\\n+#include \\\"nsIHandlerService.h\\\"\\n #include \\\"nsCOMPtr.h\\\"\\n #include \\\"nsIObserver.h\\\"\\n #include \\\"nsCOMArray.h\\\"\\n@@ -81,7 +78,6 @@\\n \\n class nsExternalAppHandler;\\n class nsIMIMEInfo;\\n-class nsIRDFService;\\n class nsITransfer;\\n class nsIDOMWindowInternal;\\n \\n@@ -107,13 +103,6 @@ public:\\n \\n   nsExternalHelperAppService();\\n   virtual ~nsExternalHelperAppService();\\n-  /**\\n-   * Initializes the RDF datasource from the profile.\\n-   * @retval NS_OK Loading was successful\\n-   * @retval errorcode Loading failed\\n-   * @see mOverRideDataSource\\n-   */\\n-  NS_HIDDEN_(nsresult) InitDataSource();\\n \\n   /**\\n    * Initializes internal state. Will be called automatically when\\n@@ -122,64 +111,6 @@ public:\\n   NS_HIDDEN_(nsresult) Init();\\n  \\n   /**\\n-   * Given an existing MIME info object and a MIME type, fill in any user\\n-   * override info from the in-memory data source.\\n-   *\\n-   * @param aContentType  The MIME content-type \\n-   * @param aMIMEInfo     The mime info to fill with the information\\n-   */\\n-  NS_HIDDEN_(nsresult) FillMIMEInfoForMimeTypeFromDS(\\n-    const nsACString& aContentType, nsIMIMEInfo * aMIMEInfo);\\n-\\n-  /**\\n-   * Given an existing protocol info object and a protocol scheme, fill in\\n-   * any user override info from the in-memory data source.\\n-   *\\n-   * @param aScheme   The protocol scheme\\n-   * @param aMIMEInfo The mime info to fill with the information\\n-   */\\n-  NS_HIDDEN_(nsresult) FillProtoInfoForSchemeFromDS(\\n-    const nsACString& aScheme, nsIHandlerInfo * aMIMEInfo);\\n-\\n-#ifdef MOZ_RDF\\n-  /**\\n-   * Fill in the generic handler info stuff; called by Fill*InfoFor*FromDS.\\n-   * \\n-   * @param aTypeNodeResource  RDF resource representing the top level scheme\\n-   *                           or MIME-type node in the graph\\n-   * @param aType              content-type or scheme name \\n-   * @param aRDFService        the RDF service\\n-   * @param aTypeNodePrefix    One of NC_{CONTENT,SCHEME}_NODE_PREFIX\\n-   * @param aHandlerInfo       object to be filled in\\n-   */\\n-  NS_HIDDEN_(nsresult) FillHandlerInfoForTypeFromDS(\\n-    nsIRDFResource *aTypeNodeResource, const nsCAutoString& aType,\\n-    nsIRDFService *aRDFService, const char *aTypeNodePrefix, \\n-    nsIHandlerInfo * aHandlerInfo);\\n-#endif\\n-    \\n-  /**\\n-   * Given an extension, look up the user override information to see if we\\n-   * have a mime info object representing this extension. The user over ride\\n-   * information is contained in an in-memory data source.\\n-   *\\n-   * Does not change the MIME Type of the MIME Info.\\n-   *\\n-   * @param aMIMEInfo The mime info to fill with the information\\n-   */\\n-  NS_HIDDEN_(nsresult) FillMIMEInfoForExtensionFromDS(\\n-    const nsACString& aFileExtension, nsIMIMEInfo * aMIMEInfo);\\n-\\n-  /**\\n-   * Looks up the MIME Type for a given extension in the RDF Datasource.\\n-   * @param aExtension The extension to look for\\n-   * @param aType [out] The type, if found\\n-   * @return PR_TRUE if found, PR_FALSE otherwise\\n-   */\\n-  NS_HIDDEN_(PRBool) GetTypeFromDS(const nsACString& aFileExtension,\\n-                                   nsACString& aType);\\n-\\n-  /**\\n    * Given a mimetype and an extension, looks up a mime info from the OS.\\n    * The mime type is given preference. This function follows the same rules\\n    * as nsIMIMEService::GetFromTypeAndExtension.\\n@@ -225,83 +156,11 @@ public:\\n   virtual nsresult GetFileTokenForPath(const PRUnichar * platformAppPath,\\n                                        nsIFile ** aFile);\\n \\n-  /**\\n-   * Helper routine used to test whether a given mime type is in our\\n-   * mimeTypes.rdf data source\\n-   */\\n-  NS_HIDDEN_(PRBool) MIMETypeIsInDataSource(const char * aContentType);\\n-\\n   virtual NS_HIDDEN_(nsresult) OSProtocolHandlerExists(const char *aScheme,\\n                                                        PRBool *aExists) = 0;\\n \\n protected:\\n   /**\\n-   * Pointer to the datasource that contains the user override information.\\n-   * @see InitDataSource\\n-   */\\n-#ifdef MOZ_RDF\\n-  nsCOMPtr<nsIRDFDataSource> mOverRideDataSource;\\n-\\n-  nsCOMPtr<nsIRDFResource> kNC_Description;\\n-  nsCOMPtr<nsIRDFResource> kNC_Value;\\n-  nsCOMPtr<nsIRDFResource> kNC_FileExtensions;\\n-  nsCOMPtr<nsIRDFResource> kNC_Path;\\n-  nsCOMPtr<nsIRDFResource> kNC_UseSystemDefault;\\n-  nsCOMPtr<nsIRDFResource> kNC_SaveToDisk;\\n-  nsCOMPtr<nsIRDFResource> kNC_AlwaysAsk;\\n-  nsCOMPtr<nsIRDFResource> kNC_HandleInternal;\\n-  nsCOMPtr<nsIRDFResource> kNC_PrettyName;\\n-  nsCOMPtr<nsIRDFResource> kNC_UriTemplate;\\n-  nsCOMPtr<nsIRDFResource> kNC_PossibleApplication;\\n-#endif\\n-\\n-  /**\\n-   * Whether mOverRideDataSource is initialized\\n-   */\\n-  PRBool mDataSourceInitialized;\\n-\\n-  /**\\n-   * Helper routines for digesting the data source and filling in a handler\\n-   * info object for a given content type inside that data source. The content\\n-   * type of the handler info object will not be changed.\\n-   */\\n-#ifdef MOZ_RDF\\n-  NS_HIDDEN_(nsresult) FillMIMEExtensionProperties(\\n-    nsIRDFResource * aContentTypeNodeResource, nsIRDFService * aRDFService,\\n-    nsIMIMEInfo * aMIMEInfo);\\n-  \\n-  /**\\n-   * @see FillMIMEExtensionProperties\\n-   */\\n-  NS_HIDDEN_(nsresult) FillContentHandlerProperties(const char * aContentType,\\n-                                                    const char * aNodePrefix,\\n-                                                    nsIRDFService * aRDFService,\\n-                                                    nsIHandlerInfo * aHandler);\\n-\\n-  /**\\n-   * A small helper function which gets the target for a given source and\\n-   * property. QIs to a literal and returns a CONST ptr to the string value\\n-   * of that target\\n-   */\\n-  NS_HIDDEN_(nsresult) FillLiteralValueFromTarget(nsIRDFResource * aSource,\\n-                                                  nsIRDFResource * aProperty,\\n-                                                  const PRUnichar ** aLiteralValue);\\n-\\n-  /**\\n-   * Returns the nsIHandlerApp represented by the source node.\\n-   */\\n-  NS_HIDDEN_(nsresult) FillHandlerAppFromSource(nsIRDFResource * aSource,\\n-                                                nsIHandlerApp ** aHandlerApp);\\n-\\n-  /**\\n-   * Returns an array of nsIHandlerApp objects representing possible apps\\n-   * for the handler represented by the source node.\\n-   */\\n-  NS_HIDDEN_(nsresult) FillPossibleAppsFromSource(nsIRDFResource * aSource,\\n-                                                  nsIMutableArray * aPossibleApps);\\n-#endif\\n-\\n-  /**\\n    * Searches the \\\"extra\\\" array of MIMEInfo objects for an object\\n    * with a specific type. If found, it will modify the passed-in\\n    * MIMEInfo. Otherwise, it will return an error and the MIMEInfo\\ndiff --git a/uriloader/exthandler/nsHandlerService.js b/uriloader/exthandler/nsHandlerService.js\\nindex 36d435f..13b17ca 100755\\n--- a/uriloader/exthandler/nsHandlerService.js\\n+++ b/uriloader/exthandler/nsHandlerService.js\\n@@ -56,6 +56,10 @@ const NC_PROTOCOL_SCHEMES   = NC_NS + \\\"Protocol-Schemes\\\";\\n \\n // nsIHandlerInfo::type\\n const NC_VALUE              = NC_NS + \\\"value\\\";\\n+const NC_DESCRIPTION        = NC_NS + \\\"description\\\";\\n+\\n+// additional extensions\\n+const NC_FILE_EXTENSIONS    = NC_NS + \\\"fileExtensions\\\";\\n \\n // references nsIHandlerInfo record\\n const NC_HANDLER_INFO       = NC_NS + \\\"handlerProp\\\";\\n@@ -89,7 +93,9 @@ const NC_URI_TEMPLATE       = NC_NS + \\\"uriTemplate\\\";\\n Cu.import(\\\"resource://gre/modules/XPCOMUtils.jsm\\\");\\n \\n \\n-function HandlerService() {}\\n+function HandlerService() {\\n+  this._init();\\n+}\\n \\n HandlerService.prototype = {\\n   //**************************************************************************//\\n@@ -102,6 +108,49 @@ HandlerService.prototype = {\\n \\n \\n   //**************************************************************************//\\n+  // Initialization & Destruction\\n+  \\n+  _init: function HS__init() {\\n+    // Observe profile-before-change so we can switch to the datasource\\n+    // in the new profile when the user changes profiles.\\n+    this._observerSvc.addObserver(this, \\\"profile-before-change\\\", false);\\n+\\n+    // Observe xpcom-shutdown so we can remove these observers\\n+    // when the application shuts down.\\n+    this._observerSvc.addObserver(this, \\\"xpcom-shutdown\\\", false);\\n+  },\\n+\\n+  _destroy: function HS__destroy() {\\n+    this._observerSvc.removeObserver(this, \\\"profile-before-change\\\");\\n+    this._observerSvc.removeObserver(this, \\\"xpcom-shutdown\\\");\\n+\\n+    // XXX Should we also null references to all the services that get stored\\n+    // by our memoizing getters in the Convenience Getters section?\\n+  },\\n+\\n+  _onProfileChange: function HS__onProfileChange() {\\n+    // Lose our reference to the datasource so we reacquire it\\n+    // from the new profile the next time we need it.\\n+    this.__ds = null;\\n+  },\\n+\\n+\\n+  //**************************************************************************//\\n+  // nsIObserver\\n+  \\n+  observe: function HS__observe(subject, topic, data) {\\n+    switch(topic) {\\n+      case \\\"profile-before-change\\\":\\n+        this._onProfileChange();\\n+        break;\\n+      case \\\"xpcom-shutdown\\\":\\n+        this._destroy();\\n+        break;\\n+    }\\n+  },\\n+\\n+\\n+  //**************************************************************************//\\n   // nsIHandlerService\\n \\n   enumerate: function HS_enumerate() {\\n@@ -112,6 +161,60 @@ HandlerService.prototype = {\\n     return handlers.enumerate();\\n   },\\n \\n+  fillHandlerInfo: function HS_fillHandlerInfo(aHandlerInfo, aOverrideType) {\\n+    var type = aOverrideType || aHandlerInfo.type;\\n+    var typeID = this._getTypeID(this._getClass(aHandlerInfo), type);\\n+\\n+    // Determine whether or not information about this handler is available\\n+    // in the datastore by looking for its \\\"value\\\" property, which stores its\\n+    // type and should always be present.\\n+    if (!this._hasValue(typeID, NC_VALUE))\\n+      throw Cr.NS_ERROR_NOT_AVAILABLE;\\n+\\n+    // Retrieve the human-readable description of the type.\\n+    if (this._hasValue(typeID, NC_DESCRIPTION))\\n+      aHandlerInfo.description = this._getValue(typeID, NC_DESCRIPTION);\\n+\\n+    // Note: for historical reasons, we don't actually check that the type\\n+    // record has a \\\"handlerProp\\\" property referencing the info record.  It's\\n+    // unclear whether or not we should start doing this check; perhaps some\\n+    // legacy datasources don't have such references.\\n+    var infoID = this._getInfoID(this._getClass(aHandlerInfo), type);\\n+\\n+    aHandlerInfo.preferredAction = this._retrievePreferredAction(infoID);\\n+\\n+    var preferredHandlerID =\\n+      this._getPreferredHandlerID(this._getClass(aHandlerInfo), type);\\n+\\n+    // Retrieve the preferred handler.\\n+    // Note: for historical reasons, we don't actually check that the info\\n+    // record has an \\\"externalApplication\\\" property referencing the preferred\\n+    // handler record.  It's unclear whether or not we should start doing\\n+    // this check; perhaps some legacy datasources don't have such references.\\n+    aHandlerInfo.preferredApplicationHandler =\\n+      this._retrieveHandlerApp(preferredHandlerID);\\n+\\n+    // Fill the array of possible handlers with the ones in the datastore.\\n+    this._fillPossibleHandlers(infoID,\\n+                               aHandlerInfo.possibleApplicationHandlers,\\n+                               aHandlerInfo.preferredApplicationHandler);\\n+\\n+    // Retrieve the \\\"always ask\\\" flag.\\n+    // Note: we only set the flag to false if we are absolutely sure the user\\n+    // does not want to be asked.  Any sort of bogus data should mean we ask.\\n+    // So there must be an \\\"alwaysAsk\\\" property in the datastore for the handler\\n+    // info object, and it must be set to \\\"false\\\", in order for us not to ask.\\n+    aHandlerInfo.alwaysAskBeforeHandling =\\n+      !this._hasValue(infoID, NC_ALWAYS_ASK) ||\\n+      this._getValue(infoID, NC_ALWAYS_ASK) != \\\"false\\\";\\n+\\n+    // If the object represents a MIME type handler, then also retrieve\\n+    // any file extensions.\\n+    if (aHandlerInfo instanceof Ci.nsIMIMEInfo)\\n+      for each (let fileExtension in this._retrieveFileExtensions(typeID))\\n+        aHandlerInfo.appendExtension(fileExtension);\\n+  },\\n+\\n   store: function HS_store(aHandlerInfo) {\\n     // FIXME: when we switch from RDF to something with transactions (like\\n     // SQLite), enclose the following changes in a transaction so they all\\n@@ -130,14 +233,20 @@ HandlerService.prototype = {\\n       this._ds.Flush();\\n   },\\n \\n+  exists: function HS_exists(aHandlerInfo) {\\n+    var typeID = this._getTypeID(this._getClass(aHandlerInfo), aHandlerInfo.type);\\n+    return this._hasLiteralAssertion(typeID, NC_VALUE, aHandlerInfo.type);\\n+  },\\n+\\n   remove: function HS_remove(aHandlerInfo) {\\n-    var preferredHandlerID = this._getPreferredHandlerID(aHandlerInfo);\\n+    var preferredHandlerID =\\n+      this._getPreferredHandlerID(this._getClass(aHandlerInfo), aHandlerInfo.type);\\n     this._removeAssertions(preferredHandlerID);\\n \\n-    var infoID = this._getInfoID(aHandlerInfo);\\n+    var infoID = this._getInfoID(this._getClass(aHandlerInfo), aHandlerInfo.type);\\n     this._removeAssertions(infoID);\\n \\n-    var typeID = this._getTypeID(aHandlerInfo);\\n+    var typeID = this._getTypeID(this._getClass(aHandlerInfo), aHandlerInfo.type);\\n     this._removeAssertions(typeID);\\n \\n     // Now that there's no longer a handler for this type, remove the type\\n@@ -156,12 +265,180 @@ HandlerService.prototype = {\\n       this._ds.Flush();\\n   },\\n \\n+  getTypeFromExtension: function HS_getTypeFromExtension(aFileExtension) {\\n+    var fileExtension = aFileExtension.toLowerCase();\\n+    var typeID;\\n+\\n+    if (this._existsLiteralTarget(NC_FILE_EXTENSIONS, fileExtension))\\n+      typeID = this._getSourceForLiteral(NC_FILE_EXTENSIONS, fileExtension);\\n+\\n+    if (typeID && this._hasValue(typeID, NC_VALUE)) {\\n+      let type = this._getValue(typeID, NC_VALUE);\\n+      if (type == \\\"\\\")\\n+        throw Cr.NS_ERROR_FAILURE;\\n+      return type;\\n+    }\\n+\\n+    throw Cr.NS_ERROR_NOT_AVAILABLE;\\n+  },\\n+\\n+\\n+  //**************************************************************************//\\n+  // Retrieval Methods\\n+\\n+  /**\\n+   * Retrieve the preferred action for the info record with the given ID.\\n+   *\\n+   * @param aInfoID  {string}  the info record ID\\n+   *\\n+   * @returns  {integer}  the preferred action enumeration value\\n+   */\\n+  _retrievePreferredAction: function HS__retrievePreferredAction(aInfoID) {\\n+    if (this._getValue(aInfoID, NC_SAVE_TO_DISK) == \\\"true\\\")\\n+      return Ci.nsIHandlerInfo.saveToDisk;\\n+    \\n+    if (this._getValue(aInfoID, NC_USE_SYSTEM_DEFAULT) == \\\"true\\\")\\n+      return Ci.nsIHandlerInfo.useSystemDefault;\\n+    \\n+    if (this._getValue(aInfoID, NC_HANDLE_INTERNALLY) == \\\"true\\\")\\n+      return Ci.nsIHandlerInfo.handleInternal;\\n+\\n+    return Ci.nsIHandlerInfo.useHelperApp;\\n+  },\\n+\\n+  /**\\n+   * Fill an array of possible handlers with the handlers for the given info ID.\\n+   *\\n+   * @param aInfoID            {string}           the ID of the info record\\n+   * @param aPossibleHandlers  {nsIMutableArray}  the array of possible handlers\\n+   * @param aPreferredHandler  {nsIHandlerApp}    the preferred handler, if any\\n+   */\\n+  _fillPossibleHandlers: function HS__fillPossibleHandlers(aInfoID,\\n+                                                           aPossibleHandlers,\\n+                                                           aPreferredHandler) {\\n+    // The set of possible handlers should include the preferred handler,\\n+    // but legacy datastores (from before we added possible handlers) won't\\n+    // include the preferred handler, so check if it's included as we build\\n+    // the list of handlers, and, if it's not included, add it to the list.\\n+    if (aPreferredHandler)\\n+      aPossibleHandlers.appendElement(aPreferredHandler, false);\\n+\\n+    var possibleHandlerTargets = this._getTargets(aInfoID, NC_POSSIBLE_APP);\\n+\\n+    while (possibleHandlerTargets.hasMoreElements()) {\\n+      let possibleHandlerTarget = possibleHandlerTargets.getNext();\\n+      if (!(possibleHandlerTarget instanceof Ci.nsIRDFResource))\\n+        continue;\\n+\\n+      let possibleHandlerID = possibleHandlerTarget.ValueUTF8;\\n+      let possibleHandler = this._retrieveHandlerApp(possibleHandlerID);\\n+      if (possibleHandler && (!aPreferredHandler ||\\n+                              !possibleHandler.equals(aPreferredHandler)))\\n+        aPossibleHandlers.appendElement(possibleHandler, false);\\n+    }\\n+  },\\n+\\n+  /**\\n+   * Retrieve the handler app object with the given ID.\\n+   *\\n+   * @param aHandlerAppID  {string}  the ID of the handler app to retrieve\\n+   *\\n+   * @returns  {nsIHandlerApp}  the handler app, if any; otherwise null\\n+   */\\n+  _retrieveHandlerApp: function HS__retrieveHandlerApp(aHandlerAppID) {\\n+    var handlerApp;\\n+\\n+    // If it has a path, it's a local handler; otherwise, it's a web handler.\\n+    if (this._hasValue(aHandlerAppID, NC_PATH)) {\\n+      let executable =\\n+        this._getFileWithPath(this._getValue(aHandlerAppID, NC_PATH));\\n+      if (!executable)\\n+        return null;\\n+\\n+      handlerApp = Cc[\\\"@mozilla.org/uriloader/local-handler-app;1\\\"].\\n+                   createInstance(Ci.nsILocalHandlerApp);\\n+      handlerApp.executable = executable;\\n+    }\\n+    else if (this._hasValue(aHandlerAppID, NC_URI_TEMPLATE)) {\\n+      let uriTemplate = this._getValue(aHandlerAppID, NC_URI_TEMPLATE);\\n+      if (!uriTemplate)\\n+        return null;\\n+\\n+      handlerApp = Cc[\\\"@mozilla.org/uriloader/web-handler-app;1\\\"].\\n+                   createInstance(Ci.nsIWebHandlerApp);\\n+      handlerApp.uriTemplate = uriTemplate;\\n+    }\\n+    else\\n+      return null;\\n+\\n+    handlerApp.name = this._getValue(aHandlerAppID, NC_PRETTY_NAME);\\n+\\n+    return handlerApp;\\n+  },\\n+\\n+  /*\\n+   * Retrieve file extensions, if any, for the MIME type with the given type ID.\\n+   *\\n+   * @param aTypeID  {string}  the type record ID\\n+   */\\n+  _retrieveFileExtensions: function HS__retrieveFileExtensions(aTypeID) {\\n+    var fileExtensions = [];\\n+\\n+    var fileExtensionTargets = this._getTargets(aTypeID, NC_FILE_EXTENSIONS);\\n+\\n+    while (fileExtensionTargets.hasMoreElements()) {\\n+      let fileExtensionTarget = fileExtensionTargets.getNext();\\n+      if (fileExtensionTarget instanceof Ci.nsIRDFLiteral &&\\n+          fileExtensionTarget.Value != \\\"\\\")\\n+        fileExtensions.push(fileExtensionTarget.Value);\\n+    }\\n+\\n+    return fileExtensions;\\n+  },\\n+\\n+  /**\\n+   * Get the file with the given path.  This is not as simple as merely\\n+   * initializing a local file object with the path, because the path might be\\n+   * relative to the current process directory, in which case we have to\\n+   * construct a path starting from that directory.\\n+   *\\n+   * @param aPath  {string}  a path to a file\\n+   *\\n+   * @returns {nsILocalFile} the file, or null if the file does not exist\\n+   */\\n+  _getFileWithPath: function HS__getFileWithPath(aPath) {\\n+    var file = Cc[\\\"@mozilla.org/file/local;1\\\"].createInstance(Ci.nsILocalFile);\\n+\\n+    try {\\n+      file.initWithPath(aPath);\\n+\\n+      if (file.exists())\\n+        return file;\\n+    }\\n+    catch(ex) {\\n+      // Note: for historical reasons, we don't actually check to see\\n+      // if the exception is NS_ERROR_FILE_UNRECOGNIZED_PATH, which is what\\n+      // nsILocalFile::initWithPath throws when a path is relative.\\n+\\n+      file = this._dirSvc.get(\\\"XCurProcD\\\", Ci.nsIFile);\\n+\\n+      try {\\n+        file.append(aPath);\\n+        if (file.exists())\\n+          return file;\\n+      }\\n+      catch(ex) {}\\n+    }\\n+\\n+    return null;\\n+  },\\n+\\n \\n   //**************************************************************************//\\n   // Storage Methods\\n \\n   _storePreferredAction: function HS__storePreferredAction(aHandlerInfo) {\\n-    var infoID = this._getInfoID(aHandlerInfo);\\n+    var infoID = this._getInfoID(this._getClass(aHandlerInfo), aHandlerInfo.type);\\n \\n     switch(aHandlerInfo.preferredAction) {\\n       case Ci.nsIHandlerInfo.saveToDisk:\\n@@ -196,8 +473,10 @@ HandlerService.prototype = {\\n   },\\n \\n   _storePreferredHandler: function HS__storePreferredHandler(aHandlerInfo) {\\n-    var infoID = this._getInfoID(aHandlerInfo);\\n-    var handlerID = this._getPreferredHandlerID(aHandlerInfo);\\n+    var infoID = this._getInfoID(this._getClass(aHandlerInfo), aHandlerInfo.type);\\n+    var handlerID =\\n+      this._getPreferredHandlerID(this._getClass(aHandlerInfo), aHandlerInfo.type);\\n+\\n     var handler = aHandlerInfo.preferredApplicationHandler;\\n \\n     if (handler) {\\n@@ -228,7 +507,7 @@ HandlerService.prototype = {\\n    * @param aHandlerInfo  {nsIHandlerInfo}  the handler info object\\n    */\\n   _storePossibleHandlers: function HS__storePossibleHandlers(aHandlerInfo) {\\n-    var infoID = this._getInfoID(aHandlerInfo);\\n+    var infoID = this._getInfoID(this._getClass(aHandlerInfo), aHandlerInfo.type);\\n \\n     // First, retrieve the set of handler apps currently stored for the type,\\n     // keeping track of their IDs in a hash that we'll use to determine which\\n@@ -238,7 +517,7 @@ HandlerService.prototype = {\\n     while (currentHandlerTargets.hasMoreElements()) {\\n       let handlerApp = currentHandlerTargets.getNext();\\n       if (handlerApp instanceof Ci.nsIRDFResource) {\\n-        let handlerAppID = handlerApp.Value;\\n+        let handlerAppID = handlerApp.ValueUTF8;\\n         currentHandlerApps[handlerAppID] = true;\\n       }\\n     }\\n@@ -250,7 +529,7 @@ HandlerService.prototype = {\\n       let handlerApp =\\n         newHandlerApps.getNext().QueryInterface(Ci.nsIHandlerApp);\\n       let handlerAppID = this._getPossibleHandlerAppID(handlerApp);\\n-      if (!this._hasResourceTarget(infoID, NC_POSSIBLE_APP, handlerAppID)) {\\n+      if (!this._hasResourceAssertion(infoID, NC_POSSIBLE_APP, handlerAppID)) {\\n         this._storeHandlerApp(handlerAppID, handlerApp);\\n         this._addResourceTarget(infoID, NC_POSSIBLE_APP, handlerAppID);\\n       }\\n@@ -303,7 +582,7 @@ HandlerService.prototype = {\\n   },\\n \\n   _storeAlwaysAsk: function HS__storeAlwaysAsk(aHandlerInfo) {\\n-    var infoID = this._getInfoID(aHandlerInfo);\\n+    var infoID = this._getInfoID(this._getClass(aHandlerInfo), aHandlerInfo.type);\\n     this._setLiteral(infoID,\\n                      NC_ALWAYS_ASK,\\n                      aHandlerInfo.alwaysAskBeforeHandling ? \\\"true\\\" : \\\"false\\\");\\n@@ -313,6 +592,26 @@ HandlerService.prototype = {\\n   //**************************************************************************//\\n   // Convenience Getters\\n \\n+  // Observer Service\\n+  __observerSvc: null,\\n+  get _observerSvc() {\\n+    if (!this.__observerSvc)\\n+      this.__observerSvc =\\n+        Cc[\\\"@mozilla.org/observer-service;1\\\"].\\n+        getService(Ci.nsIObserverService);\\n+    return this.__observerSvc;\\n+  },\\n+\\n+  // Directory Service\\n+  __dirSvc: null,\\n+  get _dirSvc() {\\n+    if (!this.__dirSvc)\\n+      this.__dirSvc =\\n+        Cc[\\\"@mozilla.org/file/directory_service;1\\\"].\\n+        getService(Ci.nsIProperties);\\n+    return this.__dirSvc;\\n+  },\\n+\\n   // MIME Service\\n   __mimeSvc: null,\\n   get _mimeSvc() {\\n@@ -355,9 +654,7 @@ HandlerService.prototype = {\\n   __ds: null,\\n   get _ds() {\\n     if (!this.__ds) {\\n-      var fileLocator = Cc[\\\"@mozilla.org/file/directory_service;1\\\"].\\n-                        getService(Ci.nsIProperties);\\n-      var file = fileLocator.get(\\\"UMimTyp\\\", Ci.nsIFile);\\n+      var file = this._dirSvc.get(\\\"UMimTyp\\\", Ci.nsIFile);\\n       // FIXME: make this a memoizing getter if we use it anywhere else.\\n       var ioService = Cc[\\\"@mozilla.org/network/io-service;1\\\"].\\n                       getService(Ci.nsIIOService);\\n@@ -372,7 +669,7 @@ HandlerService.prototype = {\\n \\n \\n   //**************************************************************************//\\n-  // Storage Utils\\n+  // Datastore Utils\\n \\n   /**\\n    * Get the string identifying whether this is a MIME or a protocol handler.\\n@@ -380,7 +677,7 @@ HandlerService.prototype = {\\n    * \\n    * @param aHandlerInfo {nsIHandlerInfo} the handler for which to get the class\\n    * \\n-   * @returns {string} the ID\\n+   * @returns {string} the class\\n    */\\n   _getClass: function HS__getClass(aHandlerInfo) {\\n     if (aHandlerInfo instanceof Ci.nsIMIMEInfo)\\n@@ -391,38 +688,39 @@ HandlerService.prototype = {\\n \\n   /**\\n    * Return the unique identifier for a content type record, which stores\\n-   * the value field plus a reference to the type's handler.\\n-   * \\n+   * the value field plus a reference to the content type's handler info record.\\n+   *\\n    * |urn:<class>:<type>|\\n-   * \\n+   *\\n    * XXX: should this be a property of nsIHandlerInfo?\\n-   * \\n-   * @param aHandlerInfo {nsIHandlerInfo} the type for which to get the ID\\n-   * \\n+   *\\n+   * @param aClass {string} the class (CLASS_MIMEINFO or CLASS_PROTOCOLINFO)\\n+   * @param aType  {string} the type (a MIME type or protocol scheme)\\n+   *\\n    * @returns {string} the ID\\n    */\\n-  _getTypeID: function HS__getTypeID(aHandlerInfo) {\\n-    return \\\"urn:\\\" + this._getClass(aHandlerInfo) + \\\":\\\" + aHandlerInfo.type;\\n+  _getTypeID: function HS__getTypeID(aClass, aType) {\\n+    return \\\"urn:\\\" + aClass + \\\":\\\" + aType;\\n   },\\n \\n   /**\\n-   * Return the unique identifier for a type info record, which stores\\n+   * Return the unique identifier for a handler info record, which stores\\n    * the preferredAction and alwaysAsk fields plus a reference to the preferred\\n-   * handler.  Roughly equivalent to the nsIHandlerInfo interface.\\n-   * \\n+   * handler app.  Roughly equivalent to the nsIHandlerInfo interface.\\n+   *\\n    * |urn:<class>:handler:<type>|\\n-   * \\n+   *\\n    * FIXME: the type info record should be merged into the type record,\\n    * since there's a one to one relationship between them, and this record\\n    * merely stores additional attributes of a content type.\\n-   * \\n-   * @param aHandlerInfo {nsIHandlerInfo} the handler for which to get the ID\\n-   * \\n+   *\\n+   * @param aClass {string} the class (CLASS_MIMEINFO or CLASS_PROTOCOLINFO)\\n+   * @param aType  {string} the type (a MIME type or protocol scheme)\\n+   *\\n    * @returns {string} the ID\\n    */\\n-  _getInfoID: function HS__getInfoID(aHandlerInfo) {\\n-    return \\\"urn:\\\" + this._getClass(aHandlerInfo) + \\\":handler:\\\" +\\n-           aHandlerInfo.type;\\n+  _getInfoID: function HS__getInfoID(aClass, aType) {\\n+    return \\\"urn:\\\" + aClass + \\\":handler:\\\" + aType;\\n   },\\n \\n   /**\\n@@ -441,13 +739,13 @@ HandlerService.prototype = {\\n    * have to change IDs when it goes from being a possible handler to being\\n    * the preferred one (once we support possible handlers).\\n    * \\n-   * @param aHandlerInfo {nsIHandlerInfo} the handler for which to get the ID\\n+   * @param aClass {string} the class (CLASS_MIMEINFO or CLASS_PROTOCOLINFO)\\n+   * @param aType  {string} the type (a MIME type or protocol scheme)\\n    * \\n    * @returns {string} the ID\\n    */\\n-  _getPreferredHandlerID: function HS__getPreferredHandlerID(aHandlerInfo) {\\n-    return \\\"urn:\\\" + this._getClass(aHandlerInfo) + \\\":externalApplication:\\\" +\\n-           aHandlerInfo.type;\\n+  _getPreferredHandlerID: function HS__getPreferredHandlerID(aClass, aType) {\\n+    return \\\"urn:\\\" + aClass + \\\":externalApplication:\\\" + aType;\\n   },\\n \\n   /**\\n@@ -487,10 +785,6 @@ HandlerService.prototype = {\\n    * @returns {nsIRDFContainer} the list of types\\n    */\\n   _ensureAndGetTypeList: function HS__ensureAndGetTypeList(aClass) {\\n-    // FIXME: once nsIHandlerInfo supports retrieving the scheme\\n-    // (and differentiating between MIME and protocol content types),\\n-    // implement support for protocols.\\n-\\n     var source = this._rdf.GetResource(\\\"urn:\\\" + aClass + \\\"s\\\");\\n     var property =\\n       this._rdf.GetResource(aClass == CLASS_MIMEINFO ? NC_MIME_TYPES\\n@@ -531,7 +825,7 @@ HandlerService.prototype = {\\n \\n     // If there's already a record in the datastore for this type, then we\\n     // don't need to do anything more.\\n-    var typeID = this._getTypeID(aHandlerInfo);\\n+    var typeID = this._getTypeID(this._getClass(aHandlerInfo), aHandlerInfo.type);\\n     var type = this._rdf.GetResource(typeID);\\n     if (typeList.IndexOf(type) != -1)\\n       return;\\n@@ -541,7 +835,7 @@ HandlerService.prototype = {\\n     this._setLiteral(typeID, NC_VALUE, aHandlerInfo.type);\\n     \\n     // Create a basic info record for this type.\\n-    var infoID = this._getInfoID(aHandlerInfo);\\n+    var infoID = this._getInfoID(this._getClass(aHandlerInfo), aHandlerInfo.type);\\n     this._setLiteral(infoID, NC_ALWAYS_ASK, \\\"false\\\");\\n     this._setResource(typeID, NC_HANDLER_INFO, infoID);\\n     // XXX Shouldn't we set preferredAction to useSystemDefault?\\n@@ -553,7 +847,8 @@ HandlerService.prototype = {\\n     // and nsExternalHelperAppService::FillHandlerInfoForTypeFromDS doesn't seem\\n     // to require the record , but downloadactions.js::_ensureMIMERegistryEntry\\n     // used to create it, so we'll do the same.\\n-    var preferredHandlerID = this._getPreferredHandlerID(aHandlerInfo);\\n+    var preferredHandlerID =\\n+      this._getPreferredHandlerID(this._getClass(aHandlerInfo), aHandlerInfo.type);\\n     this._setLiteral(preferredHandlerID, NC_PATH, \\\"\\\");\\n     this._setResource(infoID, NC_PREFERRED_APP, preferredHandlerID);\\n   },\\n@@ -586,7 +881,7 @@ HandlerService.prototype = {\\n         continue;\\n \\n       var handler;\\n-      if (typeList.Resource.Value == \\\"urn:mimetypes:root\\\")\\n+      if (typeList.Resource.ValueUTF8 == \\\"urn:mimetypes:root\\\")\\n         handler = this._mimeSvc.getFromTypeAndExtension(type, null);\\n       else\\n         handler = this._protocolSvc.getProtocolHandlerInfo(type);\\n@@ -596,6 +891,19 @@ HandlerService.prototype = {\\n   },\\n \\n   /**\\n+   * Whether or not a property of an RDF source has a value.\\n+   *\\n+   * @param sourceURI   {string}  the URI of the source\\n+   * @param propertyURI {string}  the URI of the property\\n+   * @returns           {boolean} whether or not the property has a value\\n+   */\\n+  _hasValue: function HS__hasValue(sourceURI, propertyURI) {\\n+    var source = this._rdf.GetResource(sourceURI);\\n+    var property = this._rdf.GetResource(propertyURI);\\n+    return this._ds.hasArcOut(source, property);\\n+  },\\n+\\n+  /**\\n    * Get the value of a property of an RDF source.\\n    *\\n    * @param sourceURI   {string} the URI of the source\\n@@ -709,18 +1017,15 @@ HandlerService.prototype = {\\n   /**\\n    * Whether or not a property of an RDF source has a given resource target.\\n    * \\n-   * The difference between this method and _setResource is that this one adds\\n-   * an assertion even if one already exists, which allows its callers to make\\n-   * sets of assertions (i.e. to set a property to multiple targets).\\n-   *\\n    * @param sourceURI   {string} the URI of the source\\n    * @param propertyURI {string} the URI of the property\\n    * @param targetURI   {string} the URI of the target\\n    *\\n    * @returns {boolean} whether or not there is such an assertion\\n    */\\n-  _hasResourceTarget: function HS__hasResourceTarget(sourceURI, propertyURI,\\n-                                                     targetURI) {\\n+  _hasResourceAssertion: function HS__hasResourceAssertion(sourceURI,\\n+                                                           propertyURI,\\n+                                                           targetURI) {\\n     var source = this._rdf.GetResource(sourceURI);\\n     var property = this._rdf.GetResource(propertyURI);\\n     var target = this._rdf.GetResource(targetURI);\\n@@ -729,6 +1034,58 @@ HandlerService.prototype = {\\n   },\\n \\n   /**\\n+   * Whether or not a property of an RDF source has a given literal value.\\n+   * \\n+   * @param sourceURI   {string} the URI of the source\\n+   * @param propertyURI {string} the URI of the property\\n+   * @param value       {string} the literal value\\n+   *\\n+   * @returns {boolean} whether or not there is such an assertion\\n+   */\\n+  _hasLiteralAssertion: function HS__hasLiteralAssertion(sourceURI,\\n+                                                         propertyURI,\\n+                                                         value) {\\n+    var source = this._rdf.GetResource(sourceURI);\\n+    var property = this._rdf.GetResource(propertyURI);\\n+    var target = this._rdf.GetLiteral(value);\\n+\\n+    return this._ds.HasAssertion(source, property, target, true);\\n+  },\\n+\\n+  /**\\n+   * Whether or not there is an RDF source that has the given property set to\\n+   * the given literal value.\\n+   * \\n+   * @param propertyURI {string} the URI of the property\\n+   * @param value       {string} the literal value\\n+   *\\n+   * @returns {boolean} whether or not there is a source\\n+   */\\n+  _existsLiteralTarget: function HS__existsLiteralTarget(propertyURI, value) {\\n+    var property = this._rdf.GetResource(propertyURI);\\n+    var target = this._rdf.GetLiteral(value);\\n+\\n+    return this._ds.hasArcIn(target, property);\\n+  },\\n+\\n+  /**\\n+   * Get the source for a property set to a given literal value.\\n+   *\\n+   * @param propertyURI {string} the URI of the property\\n+   * @param value       {string} the literal value\\n+   */\\n+  _getSourceForLiteral: function HS__getSourceForLiteral(propertyURI, value) {\\n+    var property = this._rdf.GetResource(propertyURI);\\n+    var target = this._rdf.GetLiteral(value);\\n+\\n+    var source = this._ds.GetSource(property, target, true);\\n+    if (source)\\n+      return source.ValueUTF8;\\n+\\n+    return null;\\n+  },\\n+\\n+  /**\\n    * Whether or not there is an RDF source that has the given property set to\\n    * the given resource target.\\n    * \\n@@ -779,59 +1136,8 @@ HandlerService.prototype = {\\n       var target = this._ds.GetTarget(source, property, true);\\n       this._ds.Unassert(source, property, target);\\n     }\\n-  },\\n-\\n-\\n-  //**************************************************************************//\\n-  // Utilities\\n-\\n-  // FIXME: given that I keep copying them from JS component to JS component,\\n-  // these utilities should all be in a JavaScript module or FUEL interface.\\n-\\n-  /**\\n-   * Get an app pref or a default value if the pref doesn't exist.\\n-   *\\n-   * @param   aPrefName\\n-   * @param   aDefaultValue\\n-   * @returns the pref's value or the default (if it is missing)\\n-   */\\n-  _getAppPref: function _getAppPref(aPrefName, aDefaultValue) {\\n-    try {\\n-      var prefBranch = Cc[\\\"@mozilla.org/preferences-service;1\\\"].\\n-                       getService(Ci.nsIPrefBranch);\\n-      switch (prefBranch.getPrefType(aPrefName)) {\\n-        case prefBranch.PREF_STRING:\\n-          return prefBranch.getCharPref(aPrefName);\\n-\\n-        case prefBranch.PREF_INT:\\n-          return prefBranch.getIntPref(aPrefName);\\n-\\n-        case prefBranch.PREF_BOOL:\\n-          return prefBranch.getBoolPref(aPrefName);\\n-      }\\n-    }\\n-    catch (ex) { /* return the default value */ }\\n-    \\n-    return aDefaultValue;\\n-  },\\n-\\n-  // Console Service\\n-  __consoleSvc: null,\\n-  get _consoleSvc() {\\n-    if (!this.__consoleSvc)\\n-      this.__consoleSvc = Cc[\\\"@mozilla.org/consoleservice;1\\\"].\\n-                          getService(Ci.nsIConsoleService);\\n-    return this.__consoleSvc;\\n-  },\\n-\\n-  _log: function _log(aMessage) {\\n-    if (!this._getAppPref(\\\"browser.contentHandling.log\\\", false))\\n-      return;\\n-\\n-    aMessage = \\\"*** HandlerService: \\\" + aMessage;\\n-    dump(aMessage + \\\"\\\\n\\\");\\n-    this._consoleSvc.logStringMessage(aMessage);\\n   }\\n+\\n };\\n \\n \\ndiff --git a/uriloader/exthandler/nsHelperAppRDF.h b/uriloader/exthandler/nsHelperAppRDF.h\\ndeleted file mode 100644\\nindex 927b06a..0000000\\n--- a/uriloader/exthandler/nsHelperAppRDF.h\\n+++ /dev/null\\n@@ -1,84 +0,0 @@\\n-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n-/* ***** BEGIN LICENSE BLOCK *****\\n- * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n- *\\n- * The contents of this file are subject to the Mozilla Public License Version\\n- * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n- * the License. You may obtain a copy of the License at\\n- * http://www.mozilla.org/MPL/\\n- *\\n- * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n- * for the specific language governing rights and limitations under the\\n- * License.\\n- *\\n- * The Original Code is mozilla.org code.\\n- *\\n- * The Initial Developer of the Original Code is\\n- * Netscape Communications Corporation.\\n- * Portions created by the Initial Developer are Copyright (C) 1999\\n- * the Initial Developer. All Rights Reserved.\\n- *\\n- * Contributor(s):\\n- *\\n- * Alternatively, the contents of this file may be used under the terms of\\n- * either of the GNU General Public License Version 2 or later (the \\\"GPL\\\"),\\n- * or the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n- * in which case the provisions of the GPL or the LGPL are applicable instead\\n- * of those above. If you wish to allow use of your version of this file only\\n- * under the terms of either the GPL or the LGPL, and not to allow others to\\n- * use your version of this file under the terms of the MPL, indicate your\\n- * decision by deleting the provisions above and replace them with the notice\\n- * and other provisions required by the GPL or the LGPL. If you do not delete\\n- * the provisions above, a recipient may use your version of this file under\\n- * the terms of any one of the MPL, the GPL or the LGPL.\\n- *\\n- * ***** END LICENSE BLOCK ***** */\\n-\\n-/** @file\\n- * This file holds our vocabulary definition for the helper\\n- * app data source. The helper app data source contains user specified helper\\n- * application override information.\\n- *\\n- * @see profile/defaults/mimeTypes.rdf for documentation on these properties\\n- */\\n-\\n-\\n-#define NC_RDF_MIMETYPES\\t\\t\\t\\tNC_NAMESPACE_URI\\\"MIME-Types\\\"\\n-// a mime type has the following properties...\\n-#define NC_RDF_MIMETYPE \\t\\t\\t\\tNC_NAMESPACE_URI\\\"MIME-Type\\\"\\n-#define NC_RDF_DESCRIPTION\\t\\t\\tNC_NAMESPACE_URI\\\"description\\\"\\n-#define NC_RDF_VALUE\\t\\t\\t\\t\\t  NC_NAMESPACE_URI\\\"value\\\"\\n-#define NC_RDF_EDITABLE   \\t\\t\\tNC_NAMESPACE_URI\\\"editable\\\"\\n-#define NC_RDF_LARGEICON\\t\\t\\t\\tNC_NAMESPACE_URI\\\"largeIcon\\\"\\n-#define NC_RDF_SMALLICON\\t\\t\\t\\tNC_NAMESPACE_URI\\\"smallIcon\\\"\\n-#define NC_RDF_HANDLER\\t\\t\\t\\t  NC_NAMESPACE_URI\\\"handler\\\"\\n-#define NC_RDF_FILEEXTENSIONS\\t  NC_NAMESPACE_URI\\\"fileExtensions\\\"\\n-#define NC_RDF_CHILD            NC_NAMESPACE_URI\\\"child\\\"\\n-#define NC_RDF_ROOT \\t\\t\\t      \\\"NC:HelperAppRoot\\\"\\n-#define NC_CONTENT_NODE_PREFIX  \\\"urn:mimetype:\\\"\\n-#define NC_HANDLER_SUFFIX \\\"handler:\\\"\\n-// This should be called preferredApplication to distinguish it from the larger\\n-// set of possible external applications, but it's too late to change this now.\\n-#define NC_EXTERNALAPP_SUFFIX \\\"externalApplication:\\\"\\n-\\n-// for URI schemes.  We re-use NC_RDF_HANDLER as an arc from these nodes.\\n-#define NC_SCHEME_NODE_PREFIX \\\"urn:scheme:\\\"\\n-#define NS_RDF_PROTOCOLSCHEMES NC_NAMESPACE_URI\\\"Protocol-Schemes\\\"\\n-\\n-// File Extensions have file extension properties....\\n-#define NC_RDF_FILEEXTENSION    NC_NAMESPACE_URI\\\"fileExtension\\\"\\n-\\n-// handler properties\\n-#define NC_RDF_SAVETODISK           NC_NAMESPACE_URI\\\"saveToDisk\\\"\\n-#define NC_RDF_USESYSTEMDEFAULT     NC_NAMESPACE_URI\\\"useSystemDefault\\\"\\n-#define NC_RDF_HANDLEINTERNAL       NC_NAMESPACE_URI\\\"handleInternal\\\"\\n-#define NC_RDF_ALWAYSASK            NC_NAMESPACE_URI\\\"alwaysAsk\\\"\\n-#define NC_RDF_POSSIBLEAPPLICATION  NC_NAMESPACE_URI\\\"possibleApplication\\\"\\n-\\n-// external applications properties....\\n-#define NC_RDF_PRETTYNAME \\t\\t\\t    NC_NAMESPACE_URI\\\"prettyName\\\"\\n-// for local apps, we'll have the path (but not uriTemplate)\\n-#define NC_RDF_PATH \\t\\t\\t          NC_NAMESPACE_URI\\\"path\\\"\\n-// for web apps, we'll have the uriTemplate (but not path)\\n-#define NC_RDF_URITEMPLATE NC_NAMESPACE_URI\\\"uriTemplate\\\"  \\ndiff --git a/uriloader/exthandler/nsIHandlerService.idl b/uriloader/exthandler/nsIHandlerService.idl\\nindex 2189d6f..67faa5d 100755\\n--- a/uriloader/exthandler/nsIHandlerService.idl\\n+++ b/uriloader/exthandler/nsIHandlerService.idl\\n@@ -39,7 +39,7 @@\\n interface nsIHandlerInfo;\\n interface nsISimpleEnumerator;\\n \\n-[scriptable, uuid(18bd7cc7-04b5-46d1-ad95-386e51191eb2)]\\n+[scriptable, uuid(53f0ad17-ec62-46a1-adbc-efccc06babcd)]\\n interface nsIHandlerService : nsISupports\\n {\\n   /**\\n@@ -52,21 +52,72 @@ interface nsIHandlerService : nsISupports\\n   nsISimpleEnumerator enumerate();\\n \\n   /**\\n-   * Save the preferred action, preferred handler, and always ask properties\\n-   * of the given handler info object to the datastore.  Updates an existing\\n-   * record or creates a new one if necessary.\\n+   * Fill a handler info object with information from the datastore.\\n+   *\\n+   * Note: because of the way the external helper app service currently mixes\\n+   * OS and user handler info in the same handler info object, this method\\n+   * takes an existing handler info object (probably retrieved from the OS)\\n+   * and \\\"fills it in\\\" with information from the datastore, overriding any\\n+   * existing properties on the object with properties from the datastore.\\n+   *\\n+   * Ultimately, however, we're going to separate OS and user handler info\\n+   * into separate objects, at which point this method should be renamed to\\n+   * something like \\\"get\\\" or \\\"retrieve\\\", take a class and type (or perhaps\\n+   * a type whose class can be determined by querying the type, for example\\n+   * an nsIContentType which is also an nsIMIMEType or an nsIProtocolScheme),\\n+   * and return a handler info object representing only the user info.\\n+   *\\n+   * Note: if you specify an override type, then the service will fill in\\n+   * the handler info object with information about that type instead of\\n+   * the type specified by the object's nsIHandlerInfo::type attribute.\\n+   *\\n+   * This is useful when you are trying to retrieve information about a MIME\\n+   * type that doesn't exist in the datastore, but you have a file extension\\n+   * for that type, and nsIHandlerService::getTypeFromExtension returns another\\n+   * MIME type that does exist in the datastore and can handle that extension.\\n+   *\\n+   * For example, the user clicks on a link, and the content has a MIME type\\n+   * that isn't in the datastore, but the link has a file extension, and that\\n+   * extension is associated with another MIME type in the datastore (perhaps\\n+   * an unofficial MIME type preceded an official one, like with image/x-png\\n+   * and image/png).\\n+   *\\n+   * In that situation, you can call this method to fill in the handler info\\n+   * object with information about that other type by passing the other type\\n+   * as the aOverrideType parameter.\\n+   *\\n+   * @param aHandlerInfo   the handler info object\\n+   * @param aOverrideType  a type to use instead of aHandlerInfo::type\\n+   *\\n+   * Note: if there is no information in the datastore about this type,\\n+   * this method throws NS_ERROR_NOT_AVAILABLE.\\n+   */\\n+  void fillHandlerInfo(in nsIHandlerInfo aHandlerInfo,\\n+                       in ACString aOverrideType);\\n+\\n+  /**\\n+   * Save the preferred action, preferred handler, possible handlers, and\\n+   * always ask properties of the given handler info object to the datastore.\\n+   * Updates an existing record or creates a new one if necessary.\\n    *\\n    * Note: if preferred action is undefined or invalid, then we assume\\n    * the default value nsIHandlerInfo::useHelperApp.\\n    *\\n-   * FIXME: also store any changes to the list of possible handlers\\n-   * (once we support possible handlers).\\n-   *\\n    * @param aHandlerInfo  the handler info object\\n    */\\n   void store(in nsIHandlerInfo aHandlerInfo);\\n \\n   /**\\n+   * Whether or not a record for the given handler info object exists\\n+   * in the datastore.\\n+   *\\n+   * @param aHandlerInfo  a handler info object\\n+   *\\n+   * @returns whether or not a record exists\\n+   */\\n+  boolean exists(in nsIHandlerInfo aHandlerInfo);\\n+\\n+  /**\\n    * Remove the given handler info object from the datastore.  Deletes all\\n    * records associated with the object, including the preferred handler, info,\\n    * and type records plus the entry in the list of types, if they exist.\\n@@ -75,4 +126,21 @@ interface nsIHandlerService : nsISupports\\n    * @param aHandlerInfo  the handler info object\\n    */\\n   void remove(in nsIHandlerInfo aHandlerInfo);\\n+\\n+  /**\\n+   * Get the MIME type mapped to the given file extension in the datastore.\\n+   *\\n+   * XXX If we ever support extension -> protocol scheme mappings, then this\\n+   * method should work for those as well.\\n+   *\\n+   * Note: in general, you should use nsIMIMEService::getTypeFromExtension\\n+   * to get a MIME type from a file extension, as that method checks a variety\\n+   * of other sources besides just the datastore.  Use this only when you want\\n+   * to specifically get only the mapping available in the datastore.\\n+   *\\n+   * @param aFileExtension  the file extension\\n+   *\\n+   * @returns the MIME type, if any; otherwise throws NS_ERROR_NOT_AVAILABLE\\n+   */\\n+  ACString getTypeFromExtension(in ACString aFileExtension);\\n };\\ndiff --git a/uriloader/exthandler/nsLocalHandlerApp.cpp b/uriloader/exthandler/nsLocalHandlerApp.cpp\\nindex 4b7b3ed..8c303ca 100644\\n--- a/uriloader/exthandler/nsLocalHandlerApp.cpp\\n+++ b/uriloader/exthandler/nsLocalHandlerApp.cpp\\n@@ -22,6 +22,7 @@\\n  *\\n  * Contributor(s):\\n  *   Dan Mosedale <dmose@mozilla.org>\\n+ *   Myk Melez <myk@mozilla.org>\\n  *\\n  * Alternatively, the contents of this file may be used under the terms of\\n  * either of the GNU General Public License Version 2 or later (the \\\"GPL\\\"),\\n@@ -66,6 +67,31 @@ NS_IMETHODIMP nsLocalHandlerApp::SetName(const nsAString & aName)\\n   return NS_OK;\\n }\\n \\n+NS_IMETHODIMP\\n+nsLocalHandlerApp::Equals(nsIHandlerApp *aHandlerApp, PRBool *_retval)\\n+{\\n+  NS_ENSURE_ARG_POINTER(aHandlerApp);\\n+\\n+  // If the handler app isn't a local handler app, then it's not the same app.\\n+  nsCOMPtr <nsILocalHandlerApp> localHandlerApp = do_QueryInterface(aHandlerApp);\\n+  if (!localHandlerApp) {\\n+    *_retval = PR_FALSE;\\n+    return NS_OK;\\n+  }\\n+\\n+  // If either handler app doesn't have an executable, then they aren't\\n+  // the same app.\\n+  nsCOMPtr<nsIFile> executable;\\n+  nsresult rv = localHandlerApp->GetExecutable(getter_AddRefs(executable));\\n+  if (NS_FAILED(rv) || !executable || !mExecutable) {\\n+    *_retval = PR_FALSE;\\n+    return NS_OK;\\n+  }\\n+\\n+  return executable->Equals(mExecutable, _retval);\\n+}\\n+\\n+\\n ////////////////////////////////////////////////////////////////////////////////\\n //// nsILocalHandlerApp\\n \\ndiff --git a/uriloader/exthandler/nsWebHandlerApp.js b/uriloader/exthandler/nsWebHandlerApp.js\\nindex ea26472..05ff52b 100644\\n--- a/uriloader/exthandler/nsWebHandlerApp.js\\n+++ b/uriloader/exthandler/nsWebHandlerApp.js\\n@@ -20,6 +20,7 @@\\n  *\\n  * Contributor(s):\\n  *   Shawn Wilsher <me@shawnwilsher.com>\\n+ *   Myk Melez <myk@mozilla.org>\\n  *\\n  * Alternatively, the contents of this file may be used under the terms of\\n  * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n@@ -41,6 +42,7 @@ Components.utils.import(\\\"resource://gre/modules/XPCOMUtils.jsm\\\");\\n //// Constants\\n \\n const Ci = Components.interfaces;\\n+const Cr = Components.results;\\n \\n ////////////////////////////////////////////////////////////////////////////////\\n //// nsWebHandler class\\n@@ -69,6 +71,19 @@ nsWebHandlerApp.prototype = {\\n     this._name = aName;\\n   },\\n \\n+  equals: function(aHandlerApp) {\\n+    if (!aHandlerApp)\\n+      throw Cr.NS_ERROR_NULL_POINTER;\\n+\\n+    if (aHandlerApp instanceof Ci.nsIWebHandlerApp &&\\n+        aHandlerApp.uriTemplate &&\\n+        this.uriTemplate &&\\n+        aHandlerApp.uriTemplate == this.uriTemplate)\\n+      return true;\\n+\\n+    return false;\\n+  },\\n+\\n   //////////////////////////////////////////////////////////////////////////////\\n   //// nsIWebHandlerApp\\n \\ndiff --git a/uriloader/exthandler/tests/unit/test_handlerService.js b/uriloader/exthandler/tests/unit/test_handlerService.js\\nindex cabdc97..1d37464 100755\\n--- a/uriloader/exthandler/tests/unit/test_handlerService.js\\n+++ b/uriloader/exthandler/tests/unit/test_handlerService.js\\n@@ -75,20 +75,6 @@ function run_test() {\\n   webHandler.name = \\\"Web Handler\\\";\\n   webHandler.uriTemplate = \\\"http://www.example.com/?%s\\\";\\n \\n-\\n-  //**************************************************************************//\\n-  // Helper Functions\\n-\\n-  function checkLocalHandlersAreEquivalent(handler1, handler2) {\\n-    do_check_eq(handler1.name, handler2.name);\\n-    do_check_eq(handler1.executable.path, handler2.executable.path);\\n-  }\\n-\\n-  function checkWebHandlersAreEquivalent(handler1, handler2) {\\n-    do_check_eq(handler1.name, handler2.name);\\n-    do_check_eq(handler1.uriTemplate, handler2.uriTemplate);\\n-  }\\n-\\n   // FIXME: these tests create and manipulate enough variables that it would\\n   // make sense to move each test into its own scope so we don't run the risk\\n   // of one test stomping on another's data.\\n@@ -111,9 +97,10 @@ function run_test() {\\n   // Deprecated property, but we should still make sure it's set correctly.\\n   do_check_eq(handlerInfo.MIMEType, \\\"nonexistent/type\\\");\\n \\n-  // These three properties are the ones the handler service knows how to store.\\n+  // These properties are the ones the handler service knows how to store.\\n   do_check_eq(handlerInfo.preferredAction, Ci.nsIHandlerInfo.saveToDisk);\\n   do_check_eq(handlerInfo.preferredApplicationHandler, null);\\n+  do_check_eq(handlerInfo.possibleApplicationHandlers.length, 0);\\n   do_check_true(handlerInfo.alwaysAskBeforeHandling);\\n \\n   // These properties are initialized to default values by the service,\\n@@ -243,8 +230,10 @@ function run_test() {\\n   webPossibleHandler.QueryInterface(Ci.nsIWebHandlerApp);\\n \\n   // Make sure the two handlers are the ones we stored.\\n-  checkLocalHandlersAreEquivalent(localPossibleHandler, localHandler);\\n-  checkWebHandlersAreEquivalent(webPossibleHandler, webHandler);\\n+  do_check_eq(localPossibleHandler.name, localHandler.name);\\n+  do_check_true(localPossibleHandler.equals(localHandler));\\n+  do_check_eq(webPossibleHandler.name, webHandler.name);\\n+  do_check_true(webPossibleHandler.equals(webHandler));\\n \\n   // Remove a handler, store the object, re-retrieve it, and make sure\\n   // it only has one handler.\\n@@ -255,11 +244,10 @@ function run_test() {\\n   do_check_eq(possibleHandlersInfo.possibleApplicationHandlers.length, 1);\\n \\n   // Make sure the handler is the one we didn't remove.\\n-  checkWebHandlersAreEquivalent(possibleHandlersInfo.\\n-                                  possibleApplicationHandlers.\\n-                                  queryElementAt(0, Ci.nsIHandlerApp).\\n-                                  QueryInterface(Ci.nsIWebHandlerApp),\\n-                                webHandler);\\n+  webPossibleHandler = possibleHandlersInfo.possibleApplicationHandlers.\\n+                       queryElementAt(0, Ci.nsIWebHandlerApp);\\n+  do_check_eq(webPossibleHandler.name, webHandler.name);\\n+  do_check_true(webPossibleHandler.equals(webHandler));\\n \\n   // FIXME: test round trip integrity for a protocol.\\n   // FIXME: test round trip integrity for a handler info with a web handler.\\n\""}