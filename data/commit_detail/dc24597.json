{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basdc24597\""},"diff":"\"dc24597 #189480 r=mkaply, sr=blizzard (platform specific), a=mkaply OS/2 only - switch to using Mozilla Unicode encoders/decoders instead of platform decoders\\ndiff --git a/widget/src/os2/nsOS2Uni.cpp b/widget/src/os2/nsOS2Uni.cpp\\nindex b779f58..6f81a89 100644\\n--- a/widget/src/os2/nsOS2Uni.cpp\\n+++ b/widget/src/os2/nsOS2Uni.cpp\\n@@ -35,98 +35,150 @@\\n  * ***** END LICENSE BLOCK ***** */\\n \\n #include \\\"nsOS2Uni.h\\\"\\n+#include \\\"nsIServiceManager.h\\\"\\n+#include \\\"nsIPlatformCharset.h\\\"\\n+#include <stdlib.h>\\n \\n-int WideCharToMultiByte( int CodePage, const PRUnichar *pText, ULONG ulLength, char* szBuffer, ULONG ulSize )\\n-{\\n-  UconvObject Converter = OS2Uni::GetUconvObject(CodePage);\\n-\\n-  UniChar *ucsString = (UniChar*) pText;\\n-  size_t   ucsLen = ulLength;\\n-  size_t   cplen = ulSize;\\n-  size_t   cSubs = 0;\\n-\\n-  char *tmp = szBuffer; // function alters the out pointer\\n \\n-  int unirc = ::UniUconvFromUcs( Converter, &ucsString, &ucsLen,\\n-                                 (void**) &tmp, &cplen, &cSubs);\\n+/**********************************************************\\n+    OS2Uni\\n+ **********************************************************/\\n+nsICharsetConverterManager* OS2Uni::gCharsetManager = nsnull;\\n \\n-  if( unirc != ULS_SUCCESS )\\n-    return 0;\\n+struct ConverterInfo\\n+{\\n+  PRUint16            mCodePage;\\n+  char*               mConvName;\\n+  nsIUnicodeEncoder*  mEncoder;\\n+  nsIUnicodeDecoder*  mDecoder;\\n+};\\n+\\n+#define eCONVERTER_COUNT  17\\n+ConverterInfo gConverterInfo[eCONVERTER_COUNT] =\\n+{\\n+  { 0,    \\\"\\\",              nsnull,  nsnull },\\n+  { 1252, \\\"windows-1252\\\",  nsnull,  nsnull },\\n+  { 1208, \\\"UTF-8\\\",         nsnull,  nsnull },\\n+  { 1250, \\\"windows-1250\\\",  nsnull,  nsnull },\\n+  { 1251, \\\"windows-1251\\\",  nsnull,  nsnull },\\n+  { 813,  \\\"ISO-8859-7\\\",    nsnull,  nsnull },\\n+  { 1254, \\\"windows-1254\\\",  nsnull,  nsnull },\\n+  { 864,  \\\"IBM864\\\",        nsnull,  nsnull },\\n+  { 1257, \\\"windows-1257\\\",  nsnull,  nsnull },\\n+  { 874,  \\\"windows-874\\\",   nsnull,  nsnull },\\n+  { 932,  \\\"Shift_JIS\\\",     nsnull,  nsnull },\\n+  { 943,  \\\"Shift_JIS\\\",     nsnull,  nsnull },\\n+  { 1381, \\\"GB2312\\\",        nsnull,  nsnull },\\n+  { 1386, \\\"GB2312\\\",        nsnull,  nsnull },\\n+  { 949,  \\\"x-windows-949\\\", nsnull,  nsnull },\\n+  { 950,  \\\"Big5\\\",          nsnull,  nsnull },\\n+  { 1361, \\\"x-johab\\\",       nsnull,  nsnull }\\n+};\\n+\\n+static NS_DEFINE_CID(kCharsetConverterManagerCID, NS_ICHARSETCONVERTERMANAGER_CID);\\n+\\n+nsISupports*\\n+OS2Uni::GetUconvObject(int aCodePage, ConverterRequest aReq)\\n+{\\n+  if (gCharsetManager == nsnull) {\\n+    nsServiceManager::GetService(kCharsetConverterManagerCID,\\n+      NS_GET_IID(nsICharsetConverterManager), (nsISupports**) &gCharsetManager);\\n+  }\\n \\n-  if( unirc == UCONV_E2BIG)\\n-  {\\n-    // terminate output string (truncating)\\n-    *(szBuffer + ulSize - 1) = '\\\\0';\\n+  nsresult rv;\\n+  nsISupports* uco = nsnull;\\n+  for (int i = 0; i < eCONVERTER_COUNT; i++) {\\n+    if (aCodePage == gConverterInfo[i].mCodePage) {\\n+      if (gConverterInfo[i].mEncoder == nsnull) {\\n+        const char* convname;\\n+        nsCAutoString charset;\\n+        if (aCodePage == 0) {\\n+          nsCOMPtr<nsIPlatformCharset>\\n+                      plat(do_GetService(NS_PLATFORMCHARSET_CONTRACTID, &rv));\\n+          if (NS_SUCCEEDED(rv)) {\\n+            plat->GetCharset(kPlatformCharsetSel_FileName, charset);\\n+          } else {\\n+            // default to IBM850 if this should fail\\n+            charset = \\\"IBM850\\\";\\n+          }\\n+          convname = charset.get();\\n+        } else {\\n+          convname = gConverterInfo[i].mConvName;\\n+        }\\n+        rv = gCharsetManager->GetUnicodeEncoderRaw(convname,\\n+                                                   &gConverterInfo[i].mEncoder);\\n+        gConverterInfo[i].mEncoder->\\n+                    SetOutputErrorBehavior(nsIUnicodeEncoder::kOnError_Replace,\\n+                                           nsnull, '?');\\n+        gCharsetManager->GetUnicodeDecoderRaw(convname,\\n+                                              &gConverterInfo[i].mDecoder);\\n+        NS_ASSERTION(NS_SUCCEEDED(rv), \\\"Failed to get converter\\\");\\n+      }\\n+      if (aReq == eConv_Encoder) {\\n+        uco = gConverterInfo[i].mEncoder;\\n+      } else {\\n+        uco = gConverterInfo[i].mDecoder;\\n+      }\\n+      break;\\n+    }\\n   }\\n \\n-  return ulSize - cplen;\\n+  return uco;\\n }\\n \\n-int MultiByteToWideChar( int CodePage, const char*pText, ULONG ulLength, PRUnichar *szBuffer, ULONG ulSize )\\n+void OS2Uni::FreeUconvObjects()\\n {\\n-  UconvObject Converter = OS2Uni::GetUconvObject(CodePage);\\n-\\n-  char *ucsString = (char*) pText;\\n-  size_t   ucsLen = ulLength;\\n-  size_t   cplen = ulSize;\\n-  size_t   cSubs = 0;\\n-\\n-  PRUnichar *tmp = szBuffer; // function alters the out pointer\\n-\\n-  int unirc = ::UniUconvToUcs( Converter, (void**)&ucsString, &ucsLen,\\n-                               NS_REINTERPRET_CAST(UniChar**, &tmp),\\n-                               &cplen, &cSubs);\\n-                               \\n-  if( unirc != ULS_SUCCESS )\\n-    return 0;\\n-\\n-  if( unirc == UCONV_E2BIG)\\n-  {\\n-    // terminate output string (truncating)\\n-    *(szBuffer + ulSize - 1) = '\\\\0';\\n+  for (int i = 0; i < eCONVERTER_COUNT; i++) {\\n+    NS_IF_RELEASE(gConverterInfo[i].mEncoder);\\n+    NS_IF_RELEASE(gConverterInfo[i].mDecoder);\\n   }\\n-\\n-  return ulSize - cplen;\\n+  NS_IF_RELEASE(gCharsetManager);\\n }\\n \\n-nsHashtable OS2Uni::gUconvObjects;\\n-\\n-UconvObject\\n-OS2Uni::GetUconvObject(int CodePage)\\n+/**********************************************************\\n+    WideCharToMultiByte\\n+ **********************************************************/\\n+nsresult\\n+WideCharToMultiByte(int aCodePage, const PRUnichar* aSrc,\\n+                    PRInt32 aSrcLength, nsAutoCharBuffer& aResult,\\n+                    PRInt32& aResultLength)\\n {\\n-  nsPRUint32Key key(CodePage);\\n-  UconvObject uco = OS2Uni::gUconvObjects.Get(&key);\\n-  if (!uco) {\\n-    UniChar codepage[20];\\n-    int unirc = ::UniMapCpToUcsCp(CodePage, codepage, 20);\\n-    if (unirc == ULS_SUCCESS) {\\n-       unirc = ::UniCreateUconvObject(codepage, &uco);\\n-       if (unirc == ULS_SUCCESS) {\\n-          uconv_attribute_t attr;\\n-\\n-          ::UniQueryUconvObject(uco, &attr, sizeof(uconv_attribute_t), \\n-                                NULL, NULL, NULL);\\n-          attr.options = UCONV_OPTION_SUBSTITUTE_BOTH;\\n-          attr.subchar_len=1;\\n-          attr.subchar[0]='?';\\n-          ::UniSetUconvObject(uco, &attr);\\n-          OS2Uni::gUconvObjects.Put(&key, uco);\\n-       }\\n-    }\\n+  nsresult rv;\\n+  nsISupports* sup = OS2Uni::GetUconvObject(aCodePage, eConv_Encoder);\\n+  nsCOMPtr<nsIUnicodeEncoder> uco = do_QueryInterface(sup);\\n+\\n+  if (NS_FAILED(uco->GetMaxLength(aSrc, aSrcLength, &aResultLength))) {\\n+    return NS_ERROR_UNEXPECTED;\\n   }\\n-  return uco;\\n-}\\n+  if (!aResult.EnsureElemCapacity(aResultLength + 1))\\n+    return NS_ERROR_OUT_OF_MEMORY;\\n+  char* str = aResult.get();\\n \\n-PR_STATIC_CALLBACK(PRIntn)\\n-UconvObjectEnum(nsHashKey* hashKey, void *aData, void* closure)\\n-{\\n-  UniFreeUconvObject((UconvObject)aData);\\n-  return kHashEnumerateRemove;\\n+  rv = uco->Convert(aSrc, &aSrcLength, str, &aResultLength);\\n+  aResult.get()[aResultLength] = '\\\\0';\\n+  return rv;\\n }\\n \\n-void OS2Uni::FreeUconvObjects()\\n+/**********************************************************\\n+    MultiByteToWideChar\\n+ **********************************************************/\\n+nsresult\\n+MultiByteToWideChar(int aCodePage, const char* aSrc,\\n+                    PRInt32 aSrcLength, nsAutoChar16Buffer& aResult,\\n+                    PRInt32& aResultLength)\\n {\\n-  if (gUconvObjects.Count()) {\\n-    gUconvObjects.Enumerate(UconvObjectEnum, nsnull);\\n+  nsresult rv;\\n+  nsISupports* sup = OS2Uni::GetUconvObject(aCodePage, eConv_Decoder);\\n+  nsCOMPtr<nsIUnicodeDecoder> uco = do_QueryInterface(sup);\\n+\\n+  if (NS_FAILED(uco->GetMaxLength(aSrc, aSrcLength, &aResultLength))) {\\n+    return NS_ERROR_UNEXPECTED;\\n   }\\n+  if (!aResult.EnsureElemCapacity(aResultLength + 1))\\n+    return NS_ERROR_OUT_OF_MEMORY;\\n+  PRUnichar* str = aResult.get();\\n+\\n+  rv = uco->Convert(aSrc, &aSrcLength, str, &aResultLength);\\n+  aResult.get()[aResultLength] = '\\\\0';\\n+  return rv;\\n }\\ndiff --git a/widget/src/os2/nsOS2Uni.h b/widget/src/os2/nsOS2Uni.h\\nindex 9ac2c79..10a8e49 100644\\n--- a/widget/src/os2/nsOS2Uni.h\\n+++ b/widget/src/os2/nsOS2Uni.h\\n@@ -37,19 +37,36 @@\\n #ifndef _nsos2uni_h\\n #define _nsos2uni_h\\n \\n+#define INCL_WIN\\n #include <os2.h>\\n #include <uconv.h>\\n-#include \\\"nsHashTable.h\\\"\\n+#include \\\"nsAutoBuffer.h\\\"\\n+#include \\\"nsICharsetConverterManager.h\\\"\\n+\\n+\\n+enum ConverterRequest {\\n+  eConv_Encoder,\\n+  eConv_Decoder\\n+};\\n \\n class OS2Uni {\\n public:\\n-  static UconvObject GetUconvObject(int CodePage);\\n+  static nsISupports* GetUconvObject(int CodePage, ConverterRequest aReq);\\n   static void FreeUconvObjects();\\n private:\\n-  static nsHashtable gUconvObjects;\\n+  static nsICharsetConverterManager* gCharsetManager;\\n };\\n \\n-int WideCharToMultiByte( int CodePage, const PRUnichar *pText, ULONG ulLength, char* szBuffer, ULONG ulSize );\\n-int MultiByteToWideChar( int CodePage, const char*pText, ULONG ulLength, PRUnichar *szBuffer, ULONG ulSize );\\n+\\n+#define CHAR_BUFFER_SIZE 1024\\n+typedef nsAutoBuffer<char, CHAR_BUFFER_SIZE> nsAutoCharBuffer;\\n+typedef nsAutoBuffer<PRUnichar, CHAR_BUFFER_SIZE> nsAutoChar16Buffer;\\n+\\n+nsresult WideCharToMultiByte(int aCodePage, const PRUnichar* aSrc,\\n+                             PRInt32 aSrcLength, nsAutoCharBuffer& aResult,\\n+                             PRInt32& aResultLength);\\n+nsresult MultiByteToWideChar(int aCodePage, const char* aSrc,\\n+                             PRInt32 aSrcLength, nsAutoChar16Buffer& aResult,\\n+                             PRInt32& aResultLength);\\n \\n #endif\\n\""}