{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Base51e840\""},"diff":"\"e51e840 Make sure to process style updates before reflow, and both before painting. Bug 375436, r+sr=roc, a=dbaron\\ndiff --git a/content/base/public/mozFlushType.h b/content/base/public/mozFlushType.h\\nindex fd058a0..bb2c590 100644\\n--- a/content/base/public/mozFlushType.h\\n+++ b/content/base/public/mozFlushType.h\\n@@ -42,21 +42,14 @@\\n  * decide what to flush.\\n  */\\n enum mozFlushType {\\n-  Flush_Content           = 0x1,   /* flush the content model construction */\\n-  Flush_SinkNotifications = 0x2,   /* flush the frame model construction */\\n-  Flush_StyleReresolves   = 0x4,   /* flush style reresolution */\\n-  Flush_OnlyReflow        = 0x8,   /* flush reflows */\\n-  Flush_OnlyPaint         = 0x10,  /* flush painting */\\n-  Flush_ContentAndNotify  = (Flush_Content | Flush_SinkNotifications),\\n-  Flush_Frames            = (Flush_Content | Flush_SinkNotifications |\\n-                             Flush_StyleReresolves),\\n-  Flush_Style             = (Flush_Content | Flush_SinkNotifications |\\n-                             Flush_StyleReresolves),\\n-  Flush_Layout            = (Flush_Content | Flush_SinkNotifications |\\n-                             Flush_StyleReresolves | Flush_OnlyReflow),\\n-  Flush_Display           = (Flush_Content | Flush_SinkNotifications |\\n-                             Flush_StyleReresolves | Flush_OnlyReflow |\\n-                             Flush_OnlyPaint)\\n+  Flush_Content          = 1, /* flush the content model construction */\\n+  Flush_ContentAndNotify = 2, /* As above, plus flush the frame model\\n+                                 construction and other nsIMutationObserver\\n+                                 notifications. */\\n+  Flush_Style            = 3, /* As above, plus flush style reresolution */\\n+  Flush_Frames           = Flush_Style,\\n+  Flush_Layout           = 4, /* As above, plus flush reflow */\\n+  Flush_Display          = 5  /* As above, plus flush painting */\\n };\\n \\n #endif /* mozFlushType_h___ */\\ndiff --git a/content/base/src/nsDocument.cpp b/content/base/src/nsDocument.cpp\\nindex 04bfe57..a6c0f79 100644\\n--- a/content/base/src/nsDocument.cpp\\n+++ b/content/base/src/nsDocument.cpp\\n@@ -4786,8 +4786,7 @@ nsDocument::FlushPendingNotifications(mozFlushType aType)\\n {\\n   // Determine if it is safe to flush the sink notifications\\n   // by determining if it safe to flush all the presshells.\\n-  if ((aType & Flush_Content) && mParser &&\\n-      (!(aType & Flush_SinkNotifications) || IsSafeToFlush())) {\\n+  if (mParser && (aType == Flush_Content || IsSafeToFlush())) {\\n     nsCOMPtr<nsIContentSink> sink = mParser->GetContentSink();\\n     if (sink) {\\n       sink->FlushPendingNotifications(aType);\\n@@ -4798,8 +4797,7 @@ nsDocument::FlushPendingNotifications(mozFlushType aType)\\n \\n   nsPIDOMWindow *window = GetWindow();\\n \\n-  if (aType == (aType & (Flush_Content | Flush_SinkNotifications)) ||\\n-      !window) {\\n+  if (aType <= Flush_ContentAndNotify || !window) {\\n     // Nothing to do here\\n     return;\\n   }\\ndiff --git a/content/html/document/src/nsHTMLContentSink.cpp b/content/html/document/src/nsHTMLContentSink.cpp\\nindex c9a57c9..90e0a08 100644\\n--- a/content/html/document/src/nsHTMLContentSink.cpp\\n+++ b/content/html/document/src/nsHTMLContentSink.cpp\\n@@ -3199,13 +3199,13 @@ HTMLContentSink::FlushPendingNotifications(mozFlushType aType)\\n   // Only flush tags if we're not doing the notification ourselves\\n   // (since we aren't reentrant)\\n   if (mCurrentContext && !mInNotification) {\\n-    if (aType & Flush_SinkNotifications) {\\n+    if (aType >= Flush_ContentAndNotify) {\\n       mCurrentContext->FlushTags();\\n     }\\n     else {\\n       mCurrentContext->FlushText();\\n     }\\n-    if (aType & Flush_OnlyReflow) {\\n+    if (aType >= Flush_Layout) {\\n       // Make sure that layout has started so that the reflow flush\\n       // will actually happen.\\n       StartLayout(PR_TRUE);\\ndiff --git a/content/xml/document/src/nsXMLContentSink.cpp b/content/xml/document/src/nsXMLContentSink.cpp\\nindex e81d8fd..1d95815 100644\\n--- a/content/xml/document/src/nsXMLContentSink.cpp\\n+++ b/content/xml/document/src/nsXMLContentSink.cpp\\n@@ -1579,13 +1579,13 @@ nsXMLContentSink::FlushPendingNotifications(mozFlushType aType)\\n   // Only flush tags if we're not doing the notification ourselves\\n   // (since we aren't reentrant)\\n   if (!mInNotification) {\\n-    if (aType & Flush_SinkNotifications) {\\n+    if (aType >= Flush_ContentAndNotify) {\\n       FlushTags();\\n     }\\n     else {\\n       FlushText();\\n     }\\n-    if (aType & Flush_OnlyReflow) {\\n+    if (aType >= Flush_Layout) {\\n       // Make sure that layout has started so that the reflow flush\\n       // will actually happen.\\n       MaybeStartLayout(PR_TRUE);\\ndiff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp\\nindex 79e05a4..347047e 100644\\n--- a/layout/base/nsPresShell.cpp\\n+++ b/layout/base/nsPresShell.cpp\\n@@ -1099,6 +1099,11 @@ protected:\\n   // Utility method to restore the root scrollframe state\\n   void RestoreRootScrollPosition();\\n \\n+  // Method to handle actually flushing.  This allows the caller to control\\n+  // whether the reflow flush (if any) should be interruptible.\\n+  nsresult DoFlushPendingNotifications(mozFlushType aType,\\n+                                       PRBool aInterruptibleReflow);\\n+\\n   nsICSSStyleSheet*         mPrefStyleSheet; // mStyleSet owns it but we maintain a ref, may be null\\n #ifdef DEBUG\\n   PRUint32                  mUpdateCount;\\n@@ -4369,9 +4374,14 @@ PresShell::IsSafeToFlush(PRBool& aIsSafeToFlush)\\n NS_IMETHODIMP \\n PresShell::FlushPendingNotifications(mozFlushType aType)\\n {\\n-  NS_ASSERTION(aType & (Flush_StyleReresolves | Flush_OnlyReflow |\\n-                        Flush_OnlyPaint),\\n-               \\\"Why did we get called?\\\");\\n+  return DoFlushPendingNotifications(aType, PR_FALSE);\\n+}\\n+\\n+NS_IMETHODIMP\\n+PresShell::DoFlushPendingNotifications(mozFlushType aType,\\n+                                       PRBool aInterruptibleReflow)\\n+{\\n+  NS_ASSERTION(aType >= Flush_Frames, \\\"Why did we get called?\\\");\\n   \\n   PRBool isSafeToFlush;\\n   IsSafeToFlush(isSafeToFlush);\\n@@ -4391,22 +4401,20 @@ PresShell::FlushPendingNotifications(mozFlushType aType)\\n     // batching if we only have style reresolve\\n     viewManager->BeginUpdateViewBatch();\\n \\n-    if (aType & Flush_StyleReresolves) {\\n-      mFrameConstructor->ProcessPendingRestyles();\\n-    }\\n+    mFrameConstructor->ProcessPendingRestyles();\\n \\n-    if (aType & Flush_OnlyReflow && !mIsDestroying) {\\n+    if (aType >= Flush_Layout && !mIsDestroying) {\\n       mFrameConstructor->RecalcQuotesAndCounters();\\n-      ProcessReflowCommands(PR_FALSE);\\n+      ProcessReflowCommands(aInterruptibleReflow);\\n     }\\n \\n     PRUint32 updateFlags = NS_VMREFRESH_NO_SYNC;\\n-    if (aType & Flush_OnlyPaint) {\\n+    if (aType >= Flush_Display) {\\n       // Flushing paints, so perform the invalidates and drawing\\n       // immediately\\n       updateFlags = NS_VMREFRESH_IMMEDIATE;\\n     }\\n-    else if (!(aType & Flush_OnlyReflow)) {\\n+    else if (aType < Flush_Layout) {\\n       // Not flushing reflows, so do deferred invalidates.  This will keep us\\n       // from possibly flushing out reflows due to invalidates being processed\\n       // at the end of this view batch.\\n@@ -5786,12 +5794,7 @@ PresShell::WillPaint()\\n   // reflow being interspersed.  Note that we _do_ allow this to be\\n   // interruptible; if we can't do all the reflows it's better to flicker a bit\\n   // than to freeze up.\\n-  // XXXbz this update batch may not be strictly necessary, but it's good form.\\n-  // XXXbz should we be flushing out style changes here?  Probably not, I'd say.\\n-  NS_ASSERTION(mViewManager, \\\"Something weird is going on\\\");\\n-  mViewManager->BeginUpdateViewBatch();\\n-  ProcessReflowCommands(PR_TRUE);\\n-  mViewManager->EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);\\n+  DoFlushPendingNotifications(Flush_Layout, PR_TRUE);\\n }\\n \\n nsresult\\n@@ -5929,9 +5932,8 @@ PresShell::ReflowEvent::Run() {\\n     // Set a kung fu death grip on the view manager associated with the pres shell\\n     // before processing that pres shell's reflow commands.  Fixes bug 54868.\\n     nsCOMPtr<nsIViewManager> viewManager = ps->GetViewManager();\\n-    viewManager->BeginUpdateViewBatch();\\n-    ps->ProcessReflowCommands(PR_TRUE);\\n-    viewManager->EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);\\n+\\n+    ps->DoFlushPendingNotifications(Flush_Layout, PR_TRUE);\\n \\n     // Now, explicitly release the pres shell before the view manager\\n     ps = nsnull;\\ndiff --git a/layout/forms/nsComboboxControlFrame.cpp b/layout/forms/nsComboboxControlFrame.cpp\\nindex 52ac115..2036bc5 100644\\n--- a/layout/forms/nsComboboxControlFrame.cpp\\n+++ b/layout/forms/nsComboboxControlFrame.cpp\\n@@ -418,10 +418,9 @@ nsComboboxControlFrame::ShowList(nsPresContext* aPresContext, PRBool aShowList)\\n     mListControlFrame->CaptureMouseEvents(PR_TRUE);\\n   }\\n \\n-  // Don't flush anything but reflows lest it destroy us\\n-  shell->GetDocument()->FlushPendingNotifications(Flush_OnlyReflow);\\n+  // XXXbz so why do we need to flush here, exactly?\\n+  shell->GetDocument()->FlushPendingNotifications(Flush_Layout);\\n   if (!weakFrame.IsAlive()) {\\n-    NS_ERROR(\\\"Flush_OnlyReflow destroyed the frame\\\");\\n     return PR_FALSE;\\n   }\\n \\ndiff --git a/layout/forms/nsListControlFrame.cpp b/layout/forms/nsListControlFrame.cpp\\nindex 4014543..b048221 100644\\n--- a/layout/forms/nsListControlFrame.cpp\\n+++ b/layout/forms/nsListControlFrame.cpp\\n@@ -2738,15 +2738,6 @@ nsListControlFrame::KeyPress(nsIDOMEvent* aKeyEvent)\\n     }\\n #endif\\n \\n-    // XXX - Are we cover up a problem here???\\n-    // Why aren't they getting flushed each time?\\n-    // because this isn't needed for Gfx\\n-    if (IsInDropDownMode()) {\\n-      // Don't flush anything but reflows lest it destroy us\\n-      PresContext()->PresShell()->\\n-        GetDocument()->FlushPendingNotifications(Flush_OnlyReflow);\\n-    }\\n-\\n     // Make sure the SelectArea frame gets painted\\n     Invalidate(nsRect(0,0,mRect.width,mRect.height), PR_TRUE);\\n \\ndiff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp\\nindex 9e7b0b7..473a97b 100644\\n--- a/layout/generic/nsGfxScrollFrame.cpp\\n+++ b/layout/generic/nsGfxScrollFrame.cpp\\n@@ -1875,7 +1875,7 @@ nsGfxScrollFrameInner::AsyncScrollPortEvent::Run()\\n {\\n   if (mInner) {\\n     mInner->mOuter->PresContext()->GetPresShell()->\\n-      FlushPendingNotifications(Flush_OnlyReflow);\\n+      FlushPendingNotifications(Flush_Layout);\\n   }\\n   return mInner ? mInner->FireScrollPortEvent() : NS_OK;\\n }\\ndiff --git a/layout/generic/nsSelection.cpp b/layout/generic/nsSelection.cpp\\nindex 385ce7f..8e07299 100644\\n--- a/layout/generic/nsSelection.cpp\\n+++ b/layout/generic/nsSelection.cpp\\n@@ -212,7 +212,10 @@ public:\\n   nsresult      ScrollRectIntoView(nsIScrollableView *aScrollableView, nsRect& aRect, PRIntn  aVPercent, PRIntn  aHPercent, PRBool aScrollParentViews);\\n \\n   nsresult      PostScrollSelectionIntoViewEvent(SelectionRegion aRegion);\\n-  NS_IMETHOD    ScrollIntoView(SelectionRegion aRegion=nsISelectionController::SELECTION_FOCUS_REGION, PRBool aIsSynchronous=PR_TRUE);\\n+  // aDoFlush only matters if aIsSynchronous is true.  If not, we'll just flush\\n+  // when the scroll event fires so we make sure to scroll to the right place.\\n+  nsresult      ScrollIntoView(SelectionRegion aRegion, PRBool aIsSynchronous,\\n+                               PRBool aDoFlush);\\n   nsresult      AddItem(nsIDOMRange *aRange);\\n   nsresult      RemoveItem(nsIDOMRange *aRange);\\n   nsresult      Clear(nsPresContext* aPresContext);\\n@@ -1262,7 +1265,9 @@ nsFrameSelection::MoveCaret(PRUint32          aKeycode,\\n           }\\n           result = mDomSelections[index]->Collapse(weakNodeUsed, offsetused);\\n           mHint = HINTRIGHT;\\n-          mDomSelections[index]->ScrollIntoView();\\n+          mDomSelections[index]->\\n+            ScrollIntoView(nsISelectionController::SELECTION_FOCUS_REGION,\\n+                           PR_FALSE, PR_FALSE);\\n           return NS_OK;\\n \\n       case nsIDOMKeyEvent::DOM_VK_RIGHT :\\n@@ -1277,7 +1282,9 @@ nsFrameSelection::MoveCaret(PRUint32          aKeycode,\\n           }\\n           result = mDomSelections[index]->Collapse(weakNodeUsed, offsetused);\\n           mHint = HINTLEFT;\\n-          mDomSelections[index]->ScrollIntoView();\\n+          mDomSelections[index]->\\n+            ScrollIntoView(nsISelectionController::SELECTION_FOCUS_REGION,\\n+                           PR_FALSE, PR_FALSE);\\n           return NS_OK;\\n     }\\n   }\\n@@ -1426,7 +1433,9 @@ nsFrameSelection::MoveCaret(PRUint32          aKeycode,\\n   if (NS_SUCCEEDED(result))\\n   {\\n     mHint = tHint; //save the hint parameter now for the next time\\n-    result = mDomSelections[index]->ScrollIntoView();\\n+    result = mDomSelections[index]->\\n+      ScrollIntoView(nsISelectionController::SELECTION_FOCUS_REGION,\\n+                     PR_FALSE, PR_FALSE);\\n   }\\n \\n   return result;\\n@@ -2538,7 +2547,8 @@ nsFrameSelection::ScrollSelectionIntoView(SelectionType   aType,\\n   if (!mDomSelections[index])\\n     return NS_ERROR_NULL_POINTER;\\n \\n-  return mDomSelections[index]->ScrollIntoView(aRegion, aIsSynchronous);\\n+  return mDomSelections[index]->ScrollIntoView(aRegion, aIsSynchronous,\\n+                                               PR_FALSE);\\n }\\n \\n nsresult\\n@@ -5831,7 +5841,8 @@ nsTypedSelection::RemoveRange(nsIDOMRange* aRange)\\n     if (cnt > 0)\\n     {\\n       setAnchorFocusRange(cnt - 1);//reset anchor to LAST range.\\n-      ScrollIntoView();\\n+      ScrollIntoView(nsISelectionController::SELECTION_FOCUS_REGION, PR_FALSE,\\n+                     PR_FALSE);\\n     }\\n   }\\n   if (!mFrameSelection)\\n@@ -7251,7 +7262,7 @@ nsTypedSelection::ScrollSelectionIntoViewEvent::Run()\\n     return NS_OK;  // event revoked\\n \\n   mTypedSelection->mScrollEvent.Forget();\\n-  mTypedSelection->ScrollIntoView(mRegion, PR_TRUE);\\n+  mTypedSelection->ScrollIntoView(mRegion, PR_TRUE, PR_TRUE);\\n   return NS_OK;\\n }\\n \\n@@ -7273,8 +7284,9 @@ nsTypedSelection::PostScrollSelectionIntoViewEvent(SelectionRegion aRegion)\\n   return NS_OK;\\n }\\n \\n-NS_IMETHODIMP\\n-nsTypedSelection::ScrollIntoView(SelectionRegion aRegion, PRBool aIsSynchronous)\\n+nsresult\\n+nsTypedSelection::ScrollIntoView(SelectionRegion aRegion,\\n+                                 PRBool aIsSynchronous, PRBool aDoFlush)\\n {\\n   nsresult result;\\n   if (!mFrameSelection)\\n@@ -7298,13 +7310,21 @@ nsTypedSelection::ScrollIntoView(SelectionRegion aRegion, PRBool aIsSynchronous)\\n   presShell->GetCaret(getter_AddRefs(caret));\\n   if (caret)\\n   {\\n-    StCaretHider  caretHider(caret);      // stack-based class hides and shows the caret\\n+    // Now that text frame character offsets are always valid (though not\\n+    // necessarily correct), the worst that will happen if we don't flush here\\n+    // is that some callers might scroll to the wrong place.  Those should\\n+    // either manually flush if they're in a safe position for it or use the\\n+    // async version of this method.\\n+    if (aDoFlush) {\\n+      presShell->FlushPendingNotifications(Flush_Layout);\\n+\\n+      // Reget the presshell, since it might have gone away.\\n+      result = GetPresShell(getter_AddRefs(presShell));\\n+      if (NS_FAILED(result) || !presShell)\\n+        return result;\\n+    }\\n \\n-    // We are going to scroll to a character offset within a frame by\\n-    // using APIs on the scrollable view directly. So we need to\\n-    // flush out pending reflows to make sure that frames are up-to-date.\\n-    // We crash otherwise - bug 252970#c97\\n-    presShell->FlushPendingNotifications(Flush_OnlyReflow);\\n+    StCaretHider  caretHider(caret);      // stack-based class hides and shows the caret\\n \\n     //\\n     // Scroll the selection region into view.\\ndiff --git a/layout/printing/nsPrintEngine.cpp b/layout/printing/nsPrintEngine.cpp\\nindex cc90d9d..20bd62c 100644\\n--- a/layout/printing/nsPrintEngine.cpp\\n+++ b/layout/printing/nsPrintEngine.cpp\\n@@ -1918,7 +1918,7 @@ nsPrintEngine::ReflowPrintObject(nsPrintObject * aPO)\\n   NS_ASSERTION(aPO->mPresShell, \\\"Presshell should still be here\\\");\\n \\n   // Process the reflow event InitialReflow posted\\n-  aPO->mPresShell->FlushPendingNotifications(Flush_OnlyReflow);\\n+  aPO->mPresShell->FlushPendingNotifications(Flush_Layout);\\n \\n   nsCOMPtr<nsIPresShell> displayShell;\\n   aPO->mDocShell->GetPresShell(getter_AddRefs(displayShell));\\ndiff --git a/layout/style/nsInspectorCSSUtils.cpp b/layout/style/nsInspectorCSSUtils.cpp\\nindex 3da0491..0e38d7f 100644\\n--- a/layout/style/nsInspectorCSSUtils.cpp\\n+++ b/layout/style/nsInspectorCSSUtils.cpp\\n@@ -122,7 +122,7 @@ nsInspectorCSSUtils::GetStyleContextForContent(nsIContent* aContent,\\n                                                nsIPresShell* aPresShell)\\n {\\n     if (!aPseudo) {\\n-        aPresShell->FlushPendingNotifications(Flush_StyleReresolves);\\n+        aPresShell->FlushPendingNotifications(Flush_Style);\\n         nsIFrame* frame = aPresShell->GetPrimaryFrameFor(aContent);\\n         if (frame) {\\n             nsStyleContext* result = GetStyleContextForFrame(frame);\\ndiff --git a/layout/xul/base/src/nsListBoxBodyFrame.cpp b/layout/xul/base/src/nsListBoxBodyFrame.cpp\\nindex 5ba269f..5632c9d 100644\\n--- a/layout/xul/base/src/nsListBoxBodyFrame.cpp\\n+++ b/layout/xul/base/src/nsListBoxBodyFrame.cpp\\n@@ -263,6 +263,11 @@ nsListBoxBodyFrame::Destroy()\\n   if (mReflowCallbackPosted)\\n      PresContext()->PresShell()->CancelReflowCallback(this);\\n \\n+  // Revoke any pending position changed events\\n+  for (PRUint32 i = 0; i < mPendingPositionChangeEvents.Length(); ++i) {\\n+    mPendingPositionChangeEvents[i]->Revoke();\\n+  }\\n+\\n   // Make sure we tell our listbox's box object we're being destroyed.\\n   for (nsIFrame *a = mParent; a; a = a->GetParent()) {\\n     nsIContent *content = a->GetContent();\\n@@ -421,9 +426,6 @@ nsListBoxBodyFrame::PositionChanged(nsISupports* aScrollbar, PRInt32 aOldIndex,\\n \\n      smoother->Stop();\\n \\n-     // Don't flush anything but reflows lest it destroy us\\n-     mContent->GetDocument()->FlushPendingNotifications(Flush_OnlyReflow);\\n-\\n      smoother->mDelta = newTwipIndex > oldTwipIndex ? rowDelta : -rowDelta;\\n \\n      smoother->Start();\\n@@ -568,7 +570,9 @@ nsListBoxBodyFrame::EnsureIndexIsVisible(PRInt32 aRowIndex)\\n     mCurrentIndex += delta; \\n   }\\n \\n-  InternalPositionChanged(up, delta);\\n+  // Safe to not go off an event here, since this is coming from the\\n+  // box object.\\n+  DoInternalPositionChangedSync(up, delta);\\n   return NS_OK;\\n }\\n \\n@@ -595,6 +599,7 @@ nsListBoxBodyFrame::ScrollByLines(PRInt32 aNumLines)\\n   // we have to do a sync update for mac because if we scroll too quickly\\n   // w/out going back to the main event loop we can easily scroll the wrong\\n   // bits and it looks like garbage (bug 63465).\\n+  // XXXbz is this seriously still needed?\\n     \\n   // I'd use Composite here, but it doesn't always work.\\n   // vm->Composite();\\n@@ -844,17 +849,19 @@ nsListBoxBodyFrame::ScrollToIndex(PRInt32 aRowIndex)\\n     return NS_OK;\\n \\n   mCurrentIndex = newIndex;\\n-  InternalPositionChanged(up, delta);\\n+\\n+  // Since we're going to flush anyway, we need to not do this off an event\\n+  DoInternalPositionChangedSync(up, delta);\\n \\n   // This change has to happen immediately.\\n   // Flush any pending reflow commands.\\n-  // Don't flush anything but reflows lest it destroy us\\n-  mContent->GetDocument()->FlushPendingNotifications(Flush_OnlyReflow);\\n+  // XXXbz why, exactly?\\n+  mContent->GetDocument()->FlushPendingNotifications(Flush_Layout);\\n \\n   return NS_OK;\\n }\\n \\n-NS_IMETHODIMP\\n+nsresult\\n nsListBoxBodyFrame::InternalPositionChangedCallback()\\n {\\n   nsListScrollSmoother* smoother = GetSmoother();\\n@@ -867,12 +874,49 @@ nsListBoxBodyFrame::InternalPositionChangedCallback()\\n   if (mCurrentIndex < 0)\\n     mCurrentIndex = 0;\\n \\n-  return InternalPositionChanged(smoother->mDelta < 0, smoother->mDelta < 0 ? -smoother->mDelta : smoother->mDelta);\\n+  return DoInternalPositionChangedSync(smoother->mDelta < 0,\\n+                                       smoother->mDelta < 0 ?\\n+                                         -smoother->mDelta : smoother->mDelta);\\n }\\n \\n-NS_IMETHODIMP\\n+nsresult\\n nsListBoxBodyFrame::InternalPositionChanged(PRBool aUp, PRInt32 aDelta)\\n-{  \\n+{\\n+  nsRefPtr<nsPositionChangedEvent> ev =\\n+    new nsPositionChangedEvent(this, aUp, aDelta);\\n+  nsresult rv = NS_DispatchToCurrentThread(ev);\\n+  if (NS_SUCCEEDED(rv)) {\\n+    if (!mPendingPositionChangeEvents.AppendElement(ev)) {\\n+      rv = NS_ERROR_OUT_OF_MEMORY;\\n+      ev->Revoke();\\n+    }\\n+  }\\n+  return rv;\\n+}\\n+\\n+nsresult\\n+nsListBoxBodyFrame::DoInternalPositionChangedSync(PRBool aUp, PRInt32 aDelta)\\n+{\\n+  nsWeakFrame weak(this);\\n+  \\n+  // Process all the pending position changes first\\n+  nsTArray< nsRefPtr<nsPositionChangedEvent> > temp;\\n+  temp.SwapElements(mPendingPositionChangeEvents);\\n+  for (PRUint32 i = 0; i < temp.Length(); ++i) {\\n+    temp[i]->Run();\\n+    temp[i]->Revoke();\\n+  }\\n+\\n+  if (!weak.IsAlive()) {\\n+    return NS_OK;\\n+  }\\n+\\n+  return DoInternalPositionChanged(aUp, aDelta);\\n+}\\n+\\n+nsresult\\n+nsListBoxBodyFrame::DoInternalPositionChanged(PRBool aUp, PRInt32 aDelta)\\n+{\\n   if (aDelta == 0)\\n     return NS_OK;\\n \\n@@ -882,7 +926,11 @@ nsListBoxBodyFrame::InternalPositionChanged(PRBool aUp, PRInt32 aDelta)\\n   // begin timing how long it takes to scroll a row\\n   PRTime start = PR_Now();\\n \\n-  mContent->GetDocument()->FlushPendingNotifications(Flush_OnlyReflow);\\n+  nsWeakFrame weakThis(this);\\n+  mContent->GetDocument()->FlushPendingNotifications(Flush_Layout);\\n+  if (!weakThis.IsAlive()) {\\n+    return NS_OK;\\n+  }\\n \\n   PRInt32 visibleRows = 0;\\n   if (mRowHeight)\\n@@ -922,7 +970,11 @@ nsListBoxBodyFrame::InternalPositionChanged(PRBool aUp, PRInt32 aDelta)\\n     FrameNeedsReflow(this, nsIPresShell::eResize, NS_FRAME_HAS_DIRTY_CHILDREN);\\n   // Flush calls CreateRows\\n   // XXXbz there has to be a better way to do this than flushing!\\n-  presContext->PresShell()->FlushPendingNotifications(Flush_OnlyReflow);\\n+  presContext->PresShell()->FlushPendingNotifications(Flush_Layout);\\n+  if (!weakThis.IsAlive()) {\\n+    return NS_OK;\\n+  }\\n+\\n   mScrolling = PR_FALSE;\\n   \\n   VerticalScroll(mYPosition);\\ndiff --git a/layout/xul/base/src/nsListBoxBodyFrame.h b/layout/xul/base/src/nsListBoxBodyFrame.h\\nindex 6e6b415..fcb8a10 100644\\n--- a/layout/xul/base/src/nsListBoxBodyFrame.h\\n+++ b/layout/xul/base/src/nsListBoxBodyFrame.h\\n@@ -48,6 +48,7 @@\\n #include \\\"nsIReflowCallback.h\\\"\\n #include \\\"nsPresContext.h\\\"\\n #include \\\"nsBoxLayoutState.h\\\"\\n+#include \\\"nsThreadUtils.h\\\"\\n \\n class nsListScrollSmoother;\\n nsIFrame* NS_NewListBoxBodyFrame(nsIPresShell* aPresShell,\\n@@ -105,8 +106,13 @@ public:\\n   nscoord ComputeIntrinsicWidth(nsBoxLayoutState& aBoxLayoutState);\\n \\n   // scrolling\\n-  NS_IMETHOD InternalPositionChangedCallback();\\n-  NS_IMETHOD InternalPositionChanged(PRBool aUp, PRInt32 aDelta);\\n+  nsresult InternalPositionChangedCallback();\\n+  nsresult InternalPositionChanged(PRBool aUp, PRInt32 aDelta);\\n+  // Process pending position changed events, then do the position change.\\n+  // This can wipe out the frametree.\\n+  nsresult DoInternalPositionChangedSync(PRBool aUp, PRInt32 aDelta);\\n+  // Actually do the internal position change.  This can wipe out the frametree\\n+  nsresult DoInternalPositionChanged(PRBool aUp, PRInt32 aDelta);\\n   nsListScrollSmoother* GetSmoother();\\n   void VerticalScroll(PRInt32 aDelta);\\n \\n@@ -132,6 +138,37 @@ public:\\n   void PostReflowCallback();\\n \\n protected:\\n+  class nsPositionChangedEvent;\\n+  friend class nsPositionChangedEvent;\\n+\\n+  class nsPositionChangedEvent : public nsRunnable\\n+  {\\n+  public:\\n+    nsPositionChangedEvent(nsListBoxBodyFrame* aFrame,\\n+                           PRBool aUp, PRInt32 aDelta) :\\n+      mFrame(aFrame), mUp(aUp), mDelta(aDelta)\\n+    {}\\n+  \\n+    NS_IMETHOD Run()\\n+    {\\n+      if (!mFrame) {\\n+        return NS_OK;\\n+      }\\n+\\n+      mFrame->mPendingPositionChangeEvents.RemoveElement(this);\\n+\\n+      return mFrame->DoInternalPositionChanged(mUp, mDelta);\\n+    }\\n+\\n+    void Revoke() {\\n+      mFrame = nsnull;\\n+    }\\n+\\n+    nsListBoxBodyFrame* mFrame;\\n+    PRBool mUp;\\n+    PRInt32 mDelta;\\n+  };\\n+\\n   void ComputeTotalRowCount();\\n   void RemoveChildFrame(nsBoxLayoutState &aState, nsIFrame *aChild);\\n \\n@@ -157,6 +194,8 @@ protected:\\n   nsListScrollSmoother* mScrollSmoother;\\n   PRInt32 mTimePerRow;\\n \\n+  nsTArray< nsRefPtr<nsPositionChangedEvent> > mPendingPositionChangeEvents;\\n+\\n   PRPackedBool mReflowCallbackPosted;\\n }; \\n \\ndiff --git a/view/src/nsViewManager.cpp b/view/src/nsViewManager.cpp\\nindex c89ce7d..665590e 100644\\n--- a/view/src/nsViewManager.cpp\\n+++ b/view/src/nsViewManager.cpp\\n@@ -1022,7 +1022,7 @@ NS_IMETHODIMP nsViewManager::DispatchEvent(nsGUIEvent *aEvent, nsEventStatus *aS\\n             // XXXbz do we need to notify other view observers for viewmanagers\\n             // in our tree?\\n             // Make sure to not send WillPaint notifications while scrolling\\n-            nsViewManager* rootVM = RootViewManager();\\n+            nsRefPtr<nsViewManager> rootVM = RootViewManager();\\n \\n             nsIWidget *widget = mRootView->GetWidget();\\n             PRBool translucentWindow = PR_FALSE;\\n\""}