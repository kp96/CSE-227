{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas6b0c754\""},"diff":"\"6b0c754 Bug 394975: properly initializing JSContext for evalx. r=mrbkap. No 1.9 aproval as the file is outside browser's build tree.\\ndiff --git a/js/src/js.c b/js/src/js.c\\nindex 85959da..050cafd 100644\\n--- a/js/src/js.c\\n+++ b/js/src/js.c\\n@@ -102,6 +102,9 @@ static jsuword gStackBase;\\n \\n static size_t gScriptStackQuota = JS_DEFAULT_SCRIPT_STACK_QUOTA;\\n \\n+static uint32 gBranchCount;\\n+static uint32 gBranchLimit;\\n+\\n int gExitCode = 0;\\n JSBool gQuitting = JS_FALSE;\\n FILE *gErrFile = NULL;\\n@@ -169,6 +172,52 @@ GetLine(JSContext *cx, char *bufp, FILE *file, const char *prompt) {\\n     return JS_TRUE;\\n }\\n \\n+static JSBool\\n+my_BranchCallback(JSContext *cx, JSScript *script)\\n+{\\n+    if (++gBranchCount == gBranchLimit) {\\n+        if (script) {\\n+            if (script->filename)\\n+                fprintf(gErrFile, \\\"%s:\\\", script->filename);\\n+            fprintf(gErrFile, \\\"%u: script branch callback (%u callbacks)\\\\n\\\",\\n+                    script->lineno, gBranchLimit);\\n+        } else {\\n+            fprintf(gErrFile, \\\"native branch callback (%u callbacks)\\\\n\\\",\\n+                    gBranchLimit);\\n+        }\\n+        gBranchCount = 0;\\n+        return JS_FALSE;\\n+    }\\n+    if ((gBranchCount & 0x3fff) == 1)\\n+        JS_MaybeGC(cx);\\n+    return JS_TRUE;\\n+}\\n+\\n+static void\\n+SetContextOptions(JSContext *cx)\\n+{\\n+    jsuword stackLimit;\\n+\\n+    if (gMaxStackSize == 0) {\\n+        /*\\n+         * Disable checking for stack overflow if limit is zero.\\n+         */\\n+        stackLimit = 0;\\n+    } else {\\n+#if JS_STACK_GROWTH_DIRECTION > 0\\n+        stackLimit = gStackBase + gMaxStackSize;\\n+#else\\n+        stackLimit = gStackBase - gMaxStackSize;\\n+#endif\\n+    }\\n+    JS_SetThreadStackLimit(cx, stackLimit);\\n+    JS_SetScriptStackQuota(cx, gScriptStackQuota);\\n+    if (gBranchLimit != 0) {\\n+        JS_SetBranchCallback(cx, my_BranchCallback);\\n+        JS_ToggleOptions(cx, JSOPTION_NATIVE_BRANCH_CALLBACK);\\n+    }\\n+}\\n+\\n static void\\n Process(JSContext *cx, JSObject *obj, char *filename, JSBool forceTTY)\\n {\\n@@ -181,7 +230,6 @@ Process(JSContext *cx, JSObject *obj, char *filename, JSBool forceTTY)\\n     int lineno;\\n     int startline;\\n     FILE *file;\\n-    jsuword stackLimit;\\n \\n     if (forceTTY || !filename || strcmp(filename, \\\"-\\\") == 0) {\\n         file = stdin;\\n@@ -195,19 +243,7 @@ Process(JSContext *cx, JSObject *obj, char *filename, JSBool forceTTY)\\n         }\\n     }\\n \\n-    if (gMaxStackSize == 0) {\\n-        /*\\n-         * Disable checking for stack overflow if limit is zero.\\n-         */\\n-        stackLimit = 0;\\n-    } else {\\n-#if JS_STACK_GROWTH_DIRECTION > 0\\n-        stackLimit = gStackBase + gMaxStackSize;\\n-#else\\n-        stackLimit = gStackBase - gMaxStackSize;\\n-#endif\\n-    }\\n-    JS_SetThreadStackLimit(cx, stackLimit);\\n+    SetContextOptions(cx);\\n \\n     if (!forceTTY && !isatty(fileno(file))) {\\n         /*\\n@@ -289,30 +325,6 @@ usage(void)\\n     return 2;\\n }\\n \\n-static uint32 gBranchCount;\\n-static uint32 gBranchLimit;\\n-\\n-static JSBool\\n-my_BranchCallback(JSContext *cx, JSScript *script)\\n-{\\n-    if (++gBranchCount == gBranchLimit) {\\n-        if (script) {\\n-            if (script->filename)\\n-                fprintf(gErrFile, \\\"%s:\\\", script->filename);\\n-            fprintf(gErrFile, \\\"%u: script branch callback (%u callbacks)\\\\n\\\",\\n-                    script->lineno, gBranchLimit);\\n-        } else {\\n-            fprintf(gErrFile, \\\"native branch callback (%u callbacks)\\\\n\\\",\\n-                    gBranchLimit);\\n-        }\\n-        gBranchCount = 0;\\n-        return JS_FALSE;\\n-    }\\n-    if ((gBranchCount & 0x3fff) == 1)\\n-        JS_MaybeGC(cx);\\n-    return JS_TRUE;\\n-}\\n-\\n static struct {\\n     const char  *name;\\n     uint32      flag;\\n@@ -450,8 +462,6 @@ ProcessArgs(JSContext *cx, JSObject *obj, char **argv, int argc)\\n \\n         case 'b':\\n             gBranchLimit = atoi(argv[++i]);\\n-            JS_SetBranchCallback(cx, my_BranchCallback);\\n-            JS_ToggleOptions(cx, JSOPTION_NATIVE_BRANCH_CALLBACK);\\n             break;\\n \\n         case 'c':\\n@@ -3141,13 +3151,13 @@ snarf(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)\\n \\n #endif /* NARCISSUS */\\n \\n-JSBool\\n+static JSBool\\n ContextCallback(JSContext *cx, uintN contextOp)\\n {\\n     if (contextOp == JSCONTEXT_NEW) {\\n         JS_SetErrorReporter(cx, my_ErrorReporter);\\n         JS_SetVersion(cx, JSVERSION_LATEST);\\n-        JS_SetScriptStackQuota(cx, gScriptStackQuota);\\n+        SetContextOptions(cx);\\n     }\\n     return JS_TRUE;\\n }\\n\""}