{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas244853d\""},"diff":"\"244853d Bug 387876 - Columns in absolutely positioned div break when changed, r=roc sr=roc blocking1.9=dbaron\\ndiff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp\\nindex f73645e..a463219 100644\\n--- a/layout/generic/nsBlockFrame.cpp\\n+++ b/layout/generic/nsBlockFrame.cpp\\n@@ -1953,16 +1953,35 @@ nsBlockFrame::ReflowDirtyLines(nsBlockReflowState& aState)\\n   // -- it's an incremental reflow of a descendant\\n   // -- and we didn't reflow any floats (so the available space\\n   // didn't change)\\n-  // XXXldb We should also check that the first line of the next-in-flow\\n-  // isn't dirty.\\n+  // -- my chain of next-in-flows either has no first line, or its first\\n+  // line isn't dirty.\\n+  PRBool skipPull = PR_FALSE;\\n   if (aState.mNextInFlow &&\\n       (aState.mReflowState.mFlags.mNextInFlowUntouched &&\\n        !lastLineMovedUp && \\n        !(GetStateBits() & NS_FRAME_IS_DIRTY) &&\\n        !reflowedFloat)) {\\n-    NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);\\n+    // We'll place lineIter at the last line of this block, so that \\n+    // nsBlockInFlowLineIterator::Next() will take us to the first\\n+    // line of my next-in-flow-chain.  (But first, check that I \\n+    // have any lines -- if I don't, just bail out of this\\n+    // optimization.) \\n+    line_iterator lineIter = this->end_lines();\\n+    if (lineIter != this->begin_lines()) {\\n+      lineIter--; // I have lines; step back from dummy iterator to last line.\\n+      nsBlockInFlowLineIterator bifLineIter(this, lineIter, PR_FALSE);\\n+\\n+      // Check for next-in-flow-chain's first line.\\n+      // (First, see if there is such a line, and second, see if it's clean)\\n+      if (!bifLineIter.Next() ||                \\n+          !bifLineIter.GetLine()->IsDirty()) {\\n+        NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);\\n+        skipPull=PR_TRUE;\\n+      }\\n+    }\\n   }\\n-  else if (aState.mNextInFlow) {\\n+  \\n+  if (!skipPull && aState.mNextInFlow) {\\n     // Pull data from a next-in-flow if there's still room for more\\n     // content here.\\n     while (keepGoing && (nsnull != aState.mNextInFlow)) {\\ndiff --git a/layout/generic/nsColumnSetFrame.cpp b/layout/generic/nsColumnSetFrame.cpp\\nindex 9aa4f85..4cdfbe9 100644\\n--- a/layout/generic/nsColumnSetFrame.cpp\\n+++ b/layout/generic/nsColumnSetFrame.cpp\\n@@ -457,7 +457,6 @@ nsColumnSetFrame::ReflowChildren(nsHTMLReflowMetrics&     aDesiredSize,\\n     // (It may also have overflowing content that doesn't care about the available height\\n     // boundary, but if so, too bad, this optimization is defeated.)\\n     PRBool skipResizeHeightShrink = shrinkingHeightOnly\\n-      && !(child->GetStateBits() & NS_FRAME_IS_DIRTY)\\n       && child->GetOverflowRect().YMost() <= aConfig.mColMaxHeight;\\n     if (!reflowNext && (skipIncremental || skipResizeHeightShrink)) {\\n       // This child does not need to be reflowed, but we may need to move it\\n\""}