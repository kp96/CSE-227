{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas5074a3b\""},"diff":"\"5074a3b Add more awesome.  Still some bugs, will try to replace sync-engine.js next (with a more domain-specific version) - beginnings of that already in the code (unused)\\ndiff --git a/services/sync/nsBookmarksSyncService.js b/services/sync/nsBookmarksSyncService.js\\nindex 217117b..46a719c 100644\\n--- a/services/sync/nsBookmarksSyncService.js\\n+++ b/services/sync/nsBookmarksSyncService.js\\n@@ -132,6 +132,10 @@ BookmarksSyncService.prototype = {\\n     items[guid] = item;\\n   },\\n \\n+  // Takes a vanilla command list (fro sync-engine.js) and combines\\n+  // them so that each create/edit/remove fully creates/edits/removes\\n+  // an item (sync-engine.js will give us one command per object\\n+  // property, i.e., a bunch of commands per item)\\n   _combineCommands: function BSS__combineCommands(commandList) {\\n     var newList = [];\\n \\n@@ -156,17 +160,47 @@ BookmarksSyncService.prototype = {\\n \\n       if (!newList.length ||\\n           newList[newList.length - 1].guid != guid ||\\n-          newList[newList.length - 1].action != action) {\\n+          newList[newList.length - 1].action != action)\\n         newList.push({action: action, guid: guid, data: {}});\\n-      }\\n \\n       newList[newList.length - 1].data[key] = value;\\n     }\\n-\\n-    LOG(\\\"Combined list: \\\" + uneval(newList) + \\\"\\\\n\\\");\\n     return newList;\\n   },\\n \\n+  _nodeDepth: function BSS__nodeDepth(guid, depth) {\\n+    let parent = this._snapshot[guid].parentGuid;\\n+    if (parent == null)\\n+      return depth;\\n+    return this._nodeDepth(parent, ++depth);\\n+  },\\n+\\n+  // Takes *combined* commands and sorts them so that parent folders\\n+  // get created first, then children in reverse index order, then\\n+  // removes.\\n+  // Note: this method uses this._snapshot to calculate node depths;\\n+  // so this._snapshot must have server commands applied to it before\\n+  // calling this method.\\n+  _sortCommands: function BSS__sortCommands(commandList) {\\n+    for (let i = 0; i < commandList.length; i++) {\\n+      commandList[i].depth = this._nodeDepth(commandList[i].guid, 0);\\n+    }\\n+    commandList.sort(function compareNodes(a, b) {\\n+      if (a.depth > b.depth)\\n+        return 1;\\n+      if (a.depth < b.depth)\\n+        return -1;\\n+      if (a.index > b.index)\\n+        return -1;\\n+      if (a.index < b.index)\\n+        return 1;\\n+      return 0; // should never happen, but not a big deal if it does\\n+    });\\n+    return commandList;\\n+  },\\n+\\n+  // Takes *combined* and *sorted* commands and applies them to the\\n+  // places db\\n   _applyCommands: function BSS__applyCommands(commandList) {\\n     for (var i = 0; i < commandList.length; i++) {\\n       var command = commandList[i];\\n@@ -188,89 +222,190 @@ BookmarksSyncService.prototype = {\\n     }\\n   },\\n \\n+  _compareItems: function BSS__compareItems(node, data) {\\n+    switch (data.type) {\\n+    case 0:\\n+      if (node &&\\n+          node.type == node.RESULT_TYPE_URI &&\\n+          node.uri == data.uri && node.title == data.title)\\n+        return true;\\n+      return false;\\n+    case 6:\\n+      if (node &&\\n+          node.type == node.RESULT_TYPE_FOLDER &&\\n+          node.title == data.title)\\n+        return true;\\n+      return false;\\n+    case 7:\\n+      if (node && node.type == node.RESULT_TYPE_SEPARATOR)\\n+        return true;\\n+      return false;\\n+    default:\\n+      LOG(\\\"_compareItems: Unknown item type: \\\" + data.type);\\n+      return false;\\n+    }\\n+  },\\n+\\n+  // FIXME: can't skip creations here; they need to get pruned out\\n+  // during reconciliation, sincethere will be \\\"new\\\" items being sent\\n+  // upstream too\\n   _createCommand: function BSS__createCommand(command) {\\n-    var newId;\\n-    var parentId = this._bms.getItemIdForGUID(command.data.parentGuid);\\n+    let newId;\\n+\\n+    // check if it's the root\\n+    if (command.data.parentGuid == null) {\\n+      this._bms.setItemGUID(this._bms.bookmarksRoot, command.guid);\\n+      return;\\n+    }\\n+\\n+    let parentId = this._bms.getItemIdForGUID(command.data.parentGuid);\\n+    if (parentId <= 0) {\\n+      LOG(\\\"Warning: creating node with unknown parent -> reparenting to root\\\");\\n+      parentId = this._bms.bookmarksRoot;\\n+    }\\n+    let parent = this._getBookmarks(parentId);\\n+    parent.QueryInterface(Ci.nsINavHistoryQueryResultNode);\\n+    parent.containerOpen = true;\\n+\\n+    let curItem;\\n+    if (parent.childCount > command.data.index)\\n+      curItem = parent.getChild(command.data.index);\\n+\\n+    if (this._compareItems(curItem, command.data)) {\\n+      LOG(\\\" -> skipping item (already exists)\\\");\\n+      this._bms.setItemGUID(curItem.itemId, command.guid);\\n+      return;\\n+    }\\n+\\n+    LOG(\\\" -> creating item\\\");\\n+\\n     switch (command.data.type) {\\n     case 0:\\n-      LOG(\\\"  -> creating a bookmark: '\\\" + command.data.title +\\n-          \\\"' -> \\\" + command.data.uri);\\n       newId = this._bms.insertBookmark(parentId,\\n                                        makeURI(command.data.uri),\\n                                        command.data.index,\\n                                        command.data.title);\\n       break;\\n     case 6:\\n-      LOG(\\\"  -> creating a folder: '\\\" + command.data.title + \\\"'\\\");\\n       newId = this._bms.createFolder(parentId,\\n                                      command.data.title,\\n                                      command.data.index);\\n       break;\\n     case 7:\\n-      LOG(\\\"  -> creating a separator\\\");\\n       newId = this._bms.insertSeparator(parentId, command.data.index);\\n       break;\\n     default:\\n-      LOG(\\\"createCommand: Unknown item type: \\\" + command.data.type);\\n+      LOG(\\\"_createCommand: Unknown item type: \\\" + command.data.type);\\n       break;\\n     }\\n     if (newId)\\n-      this._bms.setItemGUID(newId, command.data.guid);\\n+      this._bms.setItemGUID(newId, command.guid);\\n   },\\n \\n   _removeCommand: function BSS__removeCommand(command) {\\n-    var iid = this._bss.getItemIdForGUID(aCommand.guid);\\n-    if (command[\\\"path\\\"].length == 0) {\\n-      LOG(\\\"removing item\\\");\\n-      switch (node.type) {\\n-      case node.RESULT_TYPE_URI:\\n-        // FIXME: check it's an actual bookmark?\\n-        this._bms.removeItem(node.itemId);\\n+    var itemId = this._bms.getItemIdForGUID(command.guid);\\n+    var type = this._bms.getItemType(itemId);\\n+\\n+    switch (type) {\\n+    case this._bms.TYPE_BOOKMARK:\\n+      // FIXME: check it's an actual bookmark?\\n+      LOG(\\\"  -> removing bookmark \\\" + command.guid);\\n+      this._bms.removeItem(itemId);\\n+      break;\\n+    case this._bms.TYPE_FOLDER:\\n+      LOG(\\\"  -> removing folder \\\" + command.guid);\\n+      this._bms.removeFolder(itemId);\\n+      break;\\n+    case this._bms.TYPE_SEPARATOR:\\n+      LOG(\\\"  -> removing separator \\\" + command.guid);\\n+      this._bms.removeItem(itemId);\\n+      break;\\n+    default:\\n+      LOG(\\\"removeCommand: Unknown item type: \\\" + type);\\n+      break;\\n+    }\\n+  },\\n+\\n+  _editCommand: function BSS__editCommand(command) {\\n+    var itemId = this._bms.getItemIdForGUID(command.guid);\\n+    var type = this._bms.getItemType(itemId);\\n+\\n+    for (let key in command.data) {\\n+      switch (key) {\\n+      case \\\"title\\\":\\n+        this._bms.setItemTitle(itemId, command.data.title);\\n+        break;\\n+      case \\\"uri\\\":\\n+        this._bms.changeBookmarkURI(itemId, makeURI(command.data.uri));\\n         break;\\n-      case node.RESULT_TYPE_FOLDER:\\n-        this._bms.removeFolder(node.itemId);\\n+      case \\\"index\\\":\\n+        this._bms.moveItem(itemId, this._bms.getFolderIdForItem(itemId),\\n+                           command.data.index);\\n         break;\\n-      case node.RESULT_TYPE_SEPARATOR:\\n-        this._bms.removeItem(node.itemId);\\n+      case \\\"parentGuid\\\":\\n+        this._bms.moveItem(\\n+          itemId, this._bms.getItemIdForGUID(command.data.parentGuid), -1);\\n         break;\\n       default:\\n-        LOG(\\\"removeCommand: Unknown item type: \\\" + node.type);\\n+        LOG(\\\"Warning: Can't change item property: \\\" + key);\\n         break;\\n       }\\n-    } else if (command[\\\"path\\\"].shift() == \\\"children\\\") {\\n-      if (command[\\\"path\\\"].length == 0) {\\n-        LOG(\\\"invalid command?\\\");\\n-        return;\\n-      }\\n+    }\\n+  },\\n \\n-      var index = command[\\\"path\\\"].shift();\\n+  _getEdits: function BSS__getEdits(a, b) {\\n+    // check the type separately, just in case\\n+    if (a.type != b.type)\\n+      return -1;\\n \\n-      node.QueryInterface(Ci.nsINavHistoryQueryResultNode);\\n-      var openState = node.containerOpen;\\n-      node.containerOpen = true;\\n-      this._removeCommand(node.getChild(index), command);\\n-      node.containerOpen = openState;\\n+    let ret = {};\\n+    for (prop in a) {\\n+      if (a[prop] != b[prop])\\n+        ret[prop] = b[prop];\\n     }\\n+\\n+    // FIXME: prune out properties we don't care about\\n+\\n+    return ret;\\n   },\\n \\n-  _editCommand: function BSS__editCommand(node, command) {\\n-    switch (command[\\\"path\\\"].shift()) {\\n-    case \\\"children\\\":\\n-      node.QueryInterface(Ci.nsINavHistoryQueryResultNode);\\n-      var openState = node.containerOpen;\\n-      node.containerOpen = true;\\n-      this._editCommand(node.getChild(command[\\\"path\\\"].shift()), command);\\n-      node.containerOpen = openState;\\n-      break;\\n-    case \\\"type\\\":\\n-      LOG(\\\"Can't change item type!\\\"); // FIXME: is this valid?\\n-      break;\\n-    case \\\"title\\\":\\n-      this._bms.setItemTitle(node.itemId, command[\\\"value\\\"]);\\n-      break;\\n-    case \\\"uri\\\":\\n-      this._bms.changeBookmarkURI(node.itemId, makeURI(command[\\\"value\\\"]));\\n-      break;\\n+  _detectUpdates: function BSS__detectUpdates(a, b) {\\n+    let cmds = [];\\n+    for (let guid in a) {\\n+      if (guid in b) {\\n+        let edits = this._getEdits(a[guid], b[guid]);\\n+        if (edits == -1) // something went very wrong -- FIXME\\n+          continue;\\n+        if (edits == {}) // no changes - skip\\n+          continue;\\n+        cmds.push({action: \\\"edit\\\", guid: guid, data: edits});\\n+      } else {\\n+        cmds.push({action: \\\"remove\\\", guid: guid});\\n+      }\\n+    }\\n+    for (let guid in b) {\\n+      if (guid in a)\\n+        continue;\\n+      cmds.push({action: \\\"create\\\", guid: guid, data: b[guid]});\\n+    }\\n+  },\\n+\\n+  _reconcile: function BSS__reconcile(a, b) {\\n+  },\\n+\\n+  _applyCommandsToObj: function BSS__applyCommandsToObj(commands, obj) {\\n+    for (let i = 0; i < commands.length; i++) {\\n+      switch (command.action) {\\n+      case \\\"create\\\":\\n+        obj[command.guid] = eval(uneval(command.data));\\n+      case \\\"edit\\\":\\n+        for (let prop in command.data) {\\n+          obj[command.guid][prop] = command.data[prop];\\n+        }\\n+      case \\\"remove\\\":\\n+        delete obj[command.guid];\\n+        break;\\n+      }\\n     }\\n   },\\n \\n@@ -285,9 +420,11 @@ BookmarksSyncService.prototype = {\\n     return commands;\\n   },\\n \\n-  _getLocalBookmarks: function BMS__getLocalBookmarks() {\\n+  _getBookmarks: function BMS__getBookmarks(folder) {\\n+    if (!folder)\\n+      folder = this._bms.bookmarksRoot;\\n     var query = this._hsvc.getNewQuery();\\n-    query.setFolders([this._bms.bookmarksRoot], 1);\\n+    query.setFolders([folder], 1);\\n     return this._hsvc.executeQuery(query, this._hsvc.getNewQueryOptions()).root;\\n   },\\n \\n@@ -310,7 +447,7 @@ BookmarksSyncService.prototype = {\\n       //var data = yield;\\n       var data;\\n \\n-      var localBookmarks = this._getLocalBookmarks();\\n+      var localBookmarks = this._getBookmarks();\\n       var localJson = this._wrapNode(localBookmarks);\\n \\n       // 1) Fetch server deltas\\n@@ -356,26 +493,37 @@ BookmarksSyncService.prototype = {\\n \\n       if (!((propagations[0] && propagations[0].length) ||\\n             (propagations[1] && propagations[1].length) ||\\n-            (conflicts[0] && conflicts[0].length) ||\\n-            (conflicts[1] && conflicts[1].length))) {\\n+            (conflicts &&\\n+             (conflicts[0] && conflicts[0].length) ||\\n+             (conflicts[1] && conflicts[1].length)))) {\\n         this._snapshot = this._wrapNode(localBookmarks);\\n         LOG(\\\"Sync complete (2): no changes needed on client or server\\\");\\n         return;\\n       }\\n \\n-      if ((conflicts[0] && conflicts[0].length) ||\\n-          (conflicts[1] && conflicts[1].length)) {\\n+      if (conflicts && conflicts[0] && conflicts[0].length) {\\n+        //var combinedCommands = this._combineCommands(propagations[0]);\\n+        LOG(\\\"\\\\nWARNING: Conflicts found, but we don't resolve conflicts yet!\\\\n\\\");\\n+        LOG(\\\"Conflicts(1) \\\" + uneval(this._combineCommands(conflicts[0])));\\n+      }\\n+\\n+      if (conflicts && conflicts[1] && conflicts[1].length) {\\n+        //var combinedCommands = this._combineCommands(propagations[0]);\\n         LOG(\\\"\\\\nWARNING: Conflicts found, but we don't resolve conflicts yet!\\\\n\\\");\\n+        LOG(\\\"Conflicts(2) \\\" + uneval(this._combineCommands(conflicts[1])));\\n       }\\n \\n       // 3.1) Apply server changes to local store\\n       if (propagations[0] && propagations[0].length) {\\n         LOG(\\\"Applying changes locally\\\");\\n-        localBookmarks = this._getLocalBookmarks(); // fixme: wtf\\n+        localBookmarks = this._getBookmarks(); // fixme: wtf\\n         this._snapshot = this._wrapNode(localBookmarks);\\n         // Note: propagations[0] is changed by applyCommands, so we make a deep copy\\n         this._sync.applyCommands(this._snapshot, eval(uneval(propagations[0])));\\n         var combinedCommands = this._combineCommands(propagations[0]);\\n+        LOG(\\\"Combined commands: \\\" + uneval(combinedCommands) + \\\"\\\\n\\\");\\n+        var sortedCommands = this._sortCommands(combinedCommands);\\n+        LOG(\\\"Sorted commands: \\\" + uneval(sortedCommands) + \\\"\\\\n\\\");\\n         this._applyCommands(combinedCommands);\\n         this._snapshot = this._wrapNode(localBookmarks);\\n       }\\n@@ -434,6 +582,17 @@ BookmarksSyncService.prototype = {\\n       ret.deltas = eval(data.target.responseText);\\n       var tmp = eval(uneval(this._snapshot)); // fixme hack hack hack\\n \\n+      // FIXME: debug here for conditional below...\\n+      LOG(\\\"[sync bowels] local version: \\\" + this._snapshotVersion);\\n+      for (var z in ret.deltas) {\\n+        LOG(\\\"[sync bowels] remote version: \\\" + z);\\n+      }\\n+      LOG(\\\"foo: \\\" + uneval(ret.deltas[this._snapshotVersion + 1]));\\n+      if (ret.deltas[this._snapshotVersion + 1])\\n+        LOG(\\\"-> is true\\\");\\n+      else\\n+        LOG(\\\"-> is false\\\");\\n+\\n       if (ret.deltas[this._snapshotVersion + 1]) {\\n         // Merge the matching deltas into one, find highest version\\n         var keys = [];\\n\""}