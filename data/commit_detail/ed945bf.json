{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Based945bf\""},"diff":"\"ed945bf Bug 394300: Check for updates is offering incompatible updates. r=robstrong\\ndiff --git a/toolkit/mozapps/extensions/src/nsExtensionManager.js.in b/toolkit/mozapps/extensions/src/nsExtensionManager.js.in\\nindex c3b75cb..6317464 100644\\n--- a/toolkit/mozapps/extensions/src/nsExtensionManager.js.in\\n+++ b/toolkit/mozapps/extensions/src/nsExtensionManager.js.in\\n@@ -5848,11 +5848,11 @@ ExtensionItemUpdater.prototype = {\\n     var min = aRemoteItem.minAppVersion;\\n     var max = aRemoteItem.maxAppVersion;\\n     // Check if the update will only run on a newer version of the application.\\n-    if (min && gVersionChecker.compare(appExtensionsVersion, min) < 0)\\n+    if (!min || gVersionChecker.compare(appExtensionsVersion, min) < 0)\\n       return false;\\n \\n     // Check if the update will only run on an older version of the application.\\n-    if (max && gVersionChecker.compare(appExtensionsVersion, max) > 0)\\n+    if (!max || gVersionChecker.compare(appExtensionsVersion, max) > 0)\\n       return false;\\n \\n     if (!gBlocklist)\\n@@ -6167,14 +6167,6 @@ RDFItemUpdater.prototype = {\\n     }\\n \\n     // Parse the response RDF\\n-    function UpdateData() {};\\n-    UpdateData.prototype = { version: \\\"0.0\\\", updateLink: null, updateHash: null,\\n-                             minVersion: \\\"0.0\\\", maxVersion: \\\"0.0\\\",\\n-                             appID: null, found: false };\\n-\\n-    var versionUpdate = new UpdateData();\\n-    var newestUpdate  = new UpdateData();\\n-\\n     var newerItem, sameItem;\\n \\n     // Firefox 1.0PR+ update.rdf format\\n@@ -6183,61 +6175,31 @@ RDFItemUpdater.prototype = {\\n       // mode... see comment by ExtensionItemUpdater_checkForUpdates\\n       // about how we do this in all cases but Install Phone Home - which\\n       // only needs to do a version check.\\n-      this._parseV20UpdateInfo(aDatasource, aLocalItem, newestUpdate,\\n-                               nsIExtensionManager.UPDATE_CHECK_NEWVERSION);\\n-\\n-      if (newestUpdate.found) {\\n-        newerItem = makeItem(aLocalItem.id,\\n-                             newestUpdate.version,\\n-                             aLocalItem.installLocationKey,\\n-                             newestUpdate.minVersion,\\n-                             newestUpdate.maxVersion,\\n-                             aLocalItem.name,\\n-                             newestUpdate.updateLink,\\n-                             newestUpdate.updateHash,\\n-                             \\\"\\\", /* Icon URL */\\n-                             \\\"\\\", /* RDF Update URL */\\n-                             aLocalItem.type,\\n-                             newestUpdate.appID);\\n+      newerItem = this._parseV20UpdateInfo(aDatasource, aLocalItem,\\n+                                           nsIExtensionManager.UPDATE_CHECK_NEWVERSION);\\n+\\n+      if (newerItem) {\\n         ++this._updater._updateCount;\\n+        LOG(\\\"RDFItemUpdater:onDatasourceLoaded: Found a newer version of this item:\\\\r\\\\n\\\" +\\n+            newerItem.objectSource);\\n       }\\n     }\\n \\n     // Now look for updated version compatibility metadata for the currently\\n     // installed version...\\n-    this._parseV20UpdateInfo(aDatasource, aLocalItem, versionUpdate,\\n-                             nsIExtensionManager.UPDATE_CHECK_COMPATIBILITY);\\n-\\n-    if (versionUpdate.found) {\\n-      // Local version exactly matches the \\\"Version Update\\\" remote version,\\n-      // Apply changes into local datasource.\\n-      sameItem = makeItem(aLocalItem.id,\\n-                          versionUpdate.version,\\n-                          aLocalItem.installLocationKey,\\n-                          versionUpdate.minVersion,\\n-                          versionUpdate.maxVersion,\\n-                          aLocalItem.name,\\n-                          \\\"\\\", /* XPI Update URL */\\n-                          \\\"\\\", /* XPI Update Hash */\\n-                          \\\"\\\", /* Icon URL */\\n-                          \\\"\\\", /* RDF Update URL */\\n-                          aLocalItem.type,\\n-                          versionUpdate.appID);\\n+    sameItem = this._parseV20UpdateInfo(aDatasource, aLocalItem,\\n+                                        nsIExtensionManager.UPDATE_CHECK_COMPATIBILITY);\\n+\\n+    if (sameItem) {\\n       // Install-time updates are not written to the DS because there is no\\n       // entry yet, EM just uses the notifications to ascertain (by hand)\\n       // whether or not there is a remote maxVersion tweak that makes the\\n       // item being installed compatible.\\n       if (!this._updater._applyVersionUpdates(aLocalItem, sameItem))\\n         sameItem = null;\\n-    }\\n-\\n-    if (newerItem) {\\n-      LOG(\\\"RDFItemUpdater:onDatasourceLoaded: Found a newer version of this item:\\\\r\\\\n\\\" +\\n-          newerItem.objectSource);\\n-    }\\n-    if (sameItem) {\\n-      LOG(\\\"RDFItemUpdater:onDatasourceLoaded: Found info about the installed\\\\r\\\\n\\\" +\\n-          \\\"version of this item: \\\" + sameItem.objectSource);\\n+      else\\n+        LOG(\\\"RDFItemUpdater:onDatasourceLoaded: Found info about the installed\\\\r\\\\n\\\" +\\n+            \\\"version of this item: \\\" + sameItem.objectSource);\\n     }\\n     var item = null, status = nsIAddonUpdateCheckListener.STATUS_NONE;\\n     if (this._updateCheckType == nsIExtensionManager.UPDATE_CHECK_NEWVERSION\\n@@ -6275,8 +6237,20 @@ RDFItemUpdater.prototype = {\\n     return rv;\\n   },\\n \\n-  // Parses Firefox 1.0RC1+ update.rdf format\\n-  _parseV20UpdateInfo: function(aDataSource, aLocalItem, aUpdateData, aUpdateCheckType) {\\n+  /**\\n+   * Parses the Firefox 1.0RC1+ update manifest format looking for new versions\\n+   * of updated compatibility information about the given add-on. Returns an\\n+   * nsIUpdateItem holding the update's information if a valid update is found\\n+   * or null if not.\\n+   * @param   aDataSource\\n+   *          The update manifest's datasource\\n+   * @param   aLocalItem\\n+   *          The nsIUpdateItem representing the add-on being checked for updates.\\n+   * @param   aUpdateCheckType\\n+   *          The type of update check being performed. See the constants in\\n+   *          nsIExtensionManager\\n+   */\\n+  _parseV20UpdateInfo: function(aDataSource, aLocalItem, aUpdateCheckType) {\\n     var extensionRes  = gRDF.GetResource(getItemPrefix(aLocalItem.type) + aLocalItem.id);\\n \\n     var updatesArc = gRDF.GetResource(EM_NS(\\\"updates\\\"));\\n@@ -6295,60 +6269,98 @@ RDFItemUpdater.prototype = {\\n           \\\" 1. Your RDF File is correct - e.g. check that there is a top level\\\\r\\\\n\\\" +\\n           \\\"    RDF Resource with a URI urn:mozilla:extension:{GUID}, and that\\\\r\\\\n\\\" +\\n           \\\"    the <em:updates> listed all have matching GUIDs.\\\");\\n-      return;\\n+      return null;\\n     }\\n \\n+    // Track the newest update found\\n+    var updatedItem = null;\\n+\\n     var cu = Components.classes[\\\"@mozilla.org/rdf/container-utils;1\\\"]\\n                        .getService(Components.interfaces.nsIRDFContainerUtils);\\n     if (cu.IsContainer(aDataSource, updates)) {\\n       var ctr = getContainer(aDataSource, updates);\\n \\n-      // Initial target version is the currently installed version\\n-      aUpdateData.version = aLocalItem.version;\\n-\\n       var versions = ctr.GetElements();\\n       while (versions.hasMoreElements()) {\\n         // There are two different methodologies for collecting version\\n-        // information depending on whether or not we've bene invoked in\\n+        // information depending on whether or not we've been invoked in\\n         // \\\"version updates only\\\" mode or \\\"version+newest\\\" mode.\\n         var version = versions.getNext().QueryInterface(Components.interfaces.nsIRDFResource);\\n-        this._parseV20Update(aDataSource, version, aLocalItem, aUpdateData, aUpdateCheckType);\\n-        if (aUpdateCheckType && aUpdateData.found)\\n-          break;\\n+        var foundItem = this._parseV20Update(aDataSource, version, aLocalItem,\\n+                                             updatedItem ? updatedItem.version : aLocalItem.version,\\n+                                             aUpdateCheckType);\\n+        if (foundItem) {\\n+          // When not checking for new versions we can bail out on the first\\n+          // result.\\n+          if (aUpdateCheckType)\\n+            return foundItem;\\n+          updatedItem = foundItem;\\n+        }\\n       }\\n     }\\n+    return updatedItem;\\n   },\\n \\n-  _parseV20Update: function(aDataSource, aUpdateResource, aLocalItem, aUpdateData, aUpdateCheckType) {\\n+  /**\\n+   * Parses a single version's update entry looking for the best matching\\n+   * targetApplication entry. Returns an nsIUpdateItem holding the update's\\n+   * information if a valid update is found or null if not.\\n+   * @param   aDataSource\\n+   *          The update manifest's datasource\\n+   * @param   aUpdateResource\\n+   *          The nsIRDFResource of the update entry.\\n+   * @param   aLocalItem\\n+   *          The nsIUpdateItem representing the add-on being checked for updates.\\n+   * @param   aNewestVersionFound\\n+   *          When checking for new versions holds the newest version of this\\n+   *          add-on that we know about. Otherwise holds the current version.\\n+   * @param   aUpdateCheckType\\n+   *          The type of update check being performed. See the constants in\\n+   *          nsIExtensionManager\\n+   */\\n+  _parseV20Update: function(aDataSource, aUpdateResource, aLocalItem, aNewestVersionFound, aUpdateCheckType) {\\n     var version = this._getPropertyFromResource(aDataSource, aUpdateResource,\\n                                                 \\\"version\\\", aLocalItem);\\n+    /* If we are looking for new versions then test whether this discovered\\n+     * version is greater than any previously found update. Otherwise check\\n+     * if this update is for the same version as we have installed. */\\n+    var result = gVersionChecker.compare(version, aNewestVersionFound);\\n+    if (aUpdateCheckType == nsIExtensionManager.UPDATE_CHECK_NEWVERSION ? result <= 0 : result != 0)\\n+      return null;\\n+\\n     var taArc = gRDF.GetResource(EM_NS(\\\"targetApplication\\\"));\\n     var targetApps = aDataSource.GetTargets(aUpdateResource, taArc, true);\\n+    \\n+    // Track the best update we have found so far\\n+    var newestUpdateItem = null;\\n     while (targetApps.hasMoreElements()) {\\n       var targetApp = targetApps.getNext().QueryInterface(Components.interfaces.nsIRDFResource);\\n       var appID = this._getPropertyFromResource(aDataSource, targetApp, \\\"id\\\", aLocalItem);\\n       if (appID != this._updater._appID && appID != TOOLKIT_ID)\\n         continue;\\n \\n-      /* If we are looking for new versions then test whether this discovered\\n-       * version is larger than any previously found update. Otherwise check\\n-       * if this update is for the same version as we have installed. */\\n-      var result = gVersionChecker.compare(version, aUpdateData.version);\\n-      if (aUpdateCheckType == nsIExtensionManager.UPDATE_CHECK_NEWVERSION ? result > 0 : result == 0) {\\n-        aUpdateData.appID = appID;\\n-        aUpdateData.version = version;\\n-        aUpdateData.minVersion = this._getPropertyFromResource(aDataSource, targetApp, \\\"minVersion\\\", aLocalItem);\\n-        aUpdateData.maxVersion = this._getPropertyFromResource(aDataSource, targetApp, \\\"maxVersion\\\", aLocalItem);\\n-        aUpdateData.updateLink = this._getPropertyFromResource(aDataSource, targetApp, \\\"updateLink\\\", aLocalItem);\\n-        aUpdateData.updateHash = this._getPropertyFromResource(aDataSource, targetApp, \\\"updateHash\\\", aLocalItem);\\n-\\n-        aUpdateData.found = this._updater._isValidUpdate(aLocalItem, aUpdateData);\\n+      var updatedItem = makeItem(aLocalItem.id,\\n+                                 version,\\n+                                 aLocalItem.installLocationKey,\\n+                                 this._getPropertyFromResource(aDataSource, targetApp, \\\"minVersion\\\", aLocalItem),\\n+                                 this._getPropertyFromResource(aDataSource, targetApp, \\\"maxVersion\\\", aLocalItem),\\n+                                 aLocalItem.name,\\n+                                 this._getPropertyFromResource(aDataSource, targetApp, \\\"updateLink\\\", aLocalItem),\\n+                                 this._getPropertyFromResource(aDataSource, targetApp, \\\"updateHash\\\", aLocalItem),\\n+                                 \\\"\\\", /* Icon URL */\\n+                                 \\\"\\\", /* RDF Update URL */\\n+                                 aLocalItem.type,\\n+                                 appID);\\n+\\n+      if (this._updater._isValidUpdate(aLocalItem, updatedItem)) {\\n         if (appID == this._updater._appID) {\\n           // App takes precedence over toolkit.  If we found the app, bail out.\\n-          return;\\n+          return updatedItem;\\n         }\\n+        newestUpdateItem = updatedItem;\\n       }\\n     }\\n+    return newestUpdateItem;\\n   }\\n };\\n \\n\""}