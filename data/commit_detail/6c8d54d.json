{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas6c8d54d\""},"diff":"\"6c8d54d Bug 384228 - Implement Search-In-Folder(s) back-end. r=dietrich.\\ndiff --git a/toolkit/components/places/src/nsNavHistory.cpp b/toolkit/components/places/src/nsNavHistory.cpp\\nindex db548a6..df8b219 100644\\n--- a/toolkit/components/places/src/nsNavHistory.cpp\\n+++ b/toolkit/components/places/src/nsNavHistory.cpp\\n@@ -12,15 +12,17 @@\\n  * for the specific language governing rights and limitations under the\\n  * License.\\n  *\\n- * The Original Code is Mozilla History System\\n+ * The Original Code is Mozilla History System.\\n  *\\n- * The Initial Developer of the Original Code is\\n- * Google Inc.\\n+ * The Initial Developer of the Original Code is Google Inc.\\n  * Portions created by the Initial Developer are Copyright (C) 2005\\n  * the Initial Developer. All Rights Reserved.\\n  *\\n  * Contributor(s):\\n  *   Brett Wilson <brettw@gmail.com> (original author)\\n+ *   Dietrich Ayala <dietrich@mozilla.com>\\n+ *   Seth Spitzer <sspitzer@mozilla.com>\\n+ *   Asaf Romano <mano@mozilla.com>\\n  *\\n  * Alternatively, the contents of this file may be used under the terms of\\n  * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n@@ -180,7 +182,8 @@ static PRBool IsNumericHostName(const nsCString& aHost);\\n static PRInt64 GetSimpleBookmarksQueryFolder(\\n     const nsCOMArray<nsNavHistoryQuery>& aQueries,\\n     nsNavHistoryQueryOptions* aOptions);\\n-static void ParseSearchQuery(const nsString& aQuery, nsStringArray* aTerms);\\n+static void ParseSearchTermsFromQueries(const nsCOMArray<nsNavHistoryQuery>& aQueries,\\n+                                        nsTArray<nsStringArray*>* aTerms);\\n \\n inline void ReverseString(const nsString& aInput, nsAString& aReversed)\\n {\\n@@ -1552,8 +1555,10 @@ nsNavHistory::EvaluateQueryForNode(const nsCOMArray<nsNavHistoryQuery>& aQueries\\n       // an array.\\n       nsCOMArray<nsNavHistoryResultNode> inputSet;\\n       inputSet.AppendObject(aNode);\\n+      nsCOMArray<nsNavHistoryQuery> queries;\\n+      queries.AppendObject(query);\\n       nsCOMArray<nsNavHistoryResultNode> filteredSet;\\n-      nsresult rv = FilterResultSet(nsnull, inputSet, &filteredSet, query->SearchTerms());\\n+      nsresult rv = FilterResultSet(nsnull, inputSet, &filteredSet, queries);\\n       if (NS_FAILED(rv))\\n         continue;\\n       if (! filteredSet.Count())\\n@@ -2384,6 +2389,17 @@ nsNavHistory::GetQueryResults(nsNavHistoryQueryResultNode *aResultNode,\\n \\n   // bind parameters\\n   PRInt32 numParameters = 0;\\n+\\n+  // optimize the case where we just want a list with no grouping: this\\n+  // directly fills in the results and we avoid a copy of the whole list\\n+  PRBool resultAsList = PR_TRUE;\\n+  PRUint32 groupCount;\\n+  const PRUint16 *groupings = aOptions->GroupingMode(&groupCount);\\n+\\n+  if (groupCount != 0 || aOptions->ExcludeQueries()) {\\n+    resultAsList = PR_FALSE;\\n+  }\\n+\\n   PRInt32 i;\\n   for (i = 0; i < aQueries.Count(); i ++) {\\n     PRInt32 clauseParameters = 0;\\n@@ -2391,18 +2407,20 @@ nsNavHistory::GetQueryResults(nsNavHistoryQueryResultNode *aResultNode,\\n                                    aQueries[i], aOptions, &clauseParameters);\\n     NS_ENSURE_SUCCESS(rv, rv);\\n     numParameters += clauseParameters;\\n+    if (resultAsList) {\\n+      if (aQueries[i]->Folders().Length() != 0) {\\n+        resultAsList = PR_FALSE;\\n+      } else {\\n+        PRBool hasSearchTerms;\\n+        rv = aQueries[i]->GetHasSearchTerms(&hasSearchTerms);\\n+        if (hasSearchTerms)\\n+          resultAsList = PR_FALSE;\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+      }\\n+    }\\n   }\\n \\n-  PRUint32 groupCount;\\n-  const PRUint16 *groupings = aOptions->GroupingMode(&groupCount);\\n-\\n-  PRBool hasSearchTerms;\\n-  rv = aQueries[0]->GetHasSearchTerms(&hasSearchTerms);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  if (groupCount == 0 && ! hasSearchTerms) {\\n-    // optimize the case where we just want a list with no grouping: this\\n-    // directly fills in the results and we avoid a copy of the whole list\\n+  if (resultAsList) {\\n     rv = ResultsAsList(statement, aOptions, aResults);\\n     NS_ENSURE_SUCCESS(rv, rv);\\n   } else {\\n@@ -2411,22 +2429,13 @@ nsNavHistory::GetQueryResults(nsNavHistoryQueryResultNode *aResultNode,\\n     rv = ResultsAsList(statement, aOptions, &toplevel);\\n     NS_ENSURE_SUCCESS(rv, rv);\\n \\n-    if (hasSearchTerms) {\\n-      // keyword search\\n-      if (groupCount == 0) {\\n-        // keyword search with no grouping: can filter directly into the result\\n-        FilterResultSet(aResultNode, toplevel, aResults, aQueries[0]->SearchTerms());\\n-      } else {\\n-        // keyword searching with grouping: need intermediate filtered results\\n-        nsCOMArray<nsNavHistoryResultNode> filteredResults;\\n-        FilterResultSet(aResultNode, toplevel, &filteredResults, aQueries[0]->SearchTerms());\\n-        rv = RecursiveGroup(aResultNode, filteredResults, groupings, groupCount,\\n-                            aResults);\\n-        NS_ENSURE_SUCCESS(rv, rv);\\n-      }\\n+    if (groupCount == 0) {\\n+      FilterResultSet(aResultNode, toplevel, aResults, aQueries);\\n     } else {\\n-      // group unfiltered results\\n-      rv = RecursiveGroup(aResultNode, toplevel, groupings, groupCount, aResults);\\n+      nsCOMArray<nsNavHistoryResultNode> filteredResults;\\n+      FilterResultSet(aResultNode, toplevel, &filteredResults, aQueries);\\n+      rv = RecursiveGroup(aResultNode, filteredResults, groupings, groupCount,\\n+                          aResults);\\n       NS_ENSURE_SUCCESS(rv, rv);\\n     }\\n   }\\n@@ -3603,19 +3612,8 @@ nsNavHistory::QueryToSelectClause(nsNavHistoryQuery* aQuery, // const\\n   }\\n \\n   \\n-  if (aOptions->QueryType() == nsINavHistoryQueryOptions::QUERY_TYPE_BOOKMARKS) {\\n-    // Folders only have an affect on bookmark queries\\n-    // XXX: add multiple folders support\\n-    if (aQuery->Folders().Length() == 1) {\\n-      if (!aClause->IsEmpty())\\n-        *aClause += NS_LITERAL_CSTRING(\\\" AND \\\");\\n-\\n-      nsCAutoString paramString;\\n-      parameterString(aStartParameter + *aParamCount, paramString);\\n-      (*aParamCount) ++;\\n-      *aClause += NS_LITERAL_CSTRING(\\\" b.parent = \\\") + paramString;\\n-    }\\n-  } else if (aQuery->OnlyBookmarked()) {\\n+  if (aOptions->QueryType() != nsINavHistoryQueryOptions::QUERY_TYPE_BOOKMARKS &&\\n+      aQuery->OnlyBookmarked()) {\\n     // only bookmarked, has no affect on bookmarks-only queries\\n     if (!aClause->IsEmpty())\\n       *aClause += NS_LITERAL_CSTRING(\\\" AND \\\");\\n@@ -3754,18 +3752,6 @@ nsNavHistory::BindQueryClauseParameters(mozIStorageStatement* statement,\\n     (*aParamCount) ++;\\n   }\\n \\n-  // folder\\n-  if (aOptions->QueryType() == nsINavHistoryQueryOptions::QUERY_TYPE_BOOKMARKS) {\\n-    // XXX: add multiple folders support\\n-    if (aQuery->Folders().Length() == 1) {\\n-      rv = statement->BindInt64Parameter(aStartParameter + *aParamCount,\\n-                                         aQuery->Folders()[0]);\\n-      NS_ENSURE_SUCCESS(rv, rv);\\n-      (*aParamCount) ++;\\n-    }\\n-  }\\n-  // onlyBookmarked: nothing to bind\\n-\\n   // domain (see GetReversedHostname for more info on reversed host names)\\n   if (NS_SUCCEEDED(aQuery->GetHasDomain(&hasIt)) && hasIt) {\\n     nsString revDomain;\\n@@ -4143,104 +4129,140 @@ nsNavHistory::URIHasTag(nsIURI* aURI, const nsAString& aTag)\\n //\\n //    This does some post-query-execution filtering:\\n //      - searching on title & url\\n+//      - parent folder (recursively)\\n //      - excludeQueries\\n \\n nsresult\\n-nsNavHistory::FilterResultSet(nsNavHistoryQueryResultNode* aParentNode,\\n+nsNavHistory::FilterResultSet(nsNavHistoryQueryResultNode* aQueryNode,\\n                               const nsCOMArray<nsNavHistoryResultNode>& aSet,\\n                               nsCOMArray<nsNavHistoryResultNode>* aFiltered,\\n-                              const nsString& aSearch)\\n+                              const nsCOMArray<nsNavHistoryQuery>& aQueries)\\n {\\n   nsresult rv;\\n-  nsStringArray terms;\\n-  ParseSearchQuery(aSearch, &terms);\\n+\\n+  // get the bookmarks service\\n+  nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();\\n+  NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);\\n+\\n+  // parse the search terms\\n+  nsTArray<nsStringArray*> terms;\\n+  ParseSearchTermsFromQueries(aQueries, &terms);\\n+\\n+  PRUint32 queryIndex;\\n+\\n+  // The includeFolders array for each query is initialized with its\\n+  // query's folders array. We add sub-folders as we check items.\\n+  nsTArray< nsTArray<PRInt64>* > includeFolders;\\n+  nsTArray< nsTArray<PRInt64>* > excludeFolders;\\n+  for (queryIndex = 0;\\n+       queryIndex < aQueries.Count(); queryIndex++) {\\n+    includeFolders.AppendElement(new nsTArray<PRInt64>(aQueries[queryIndex]->Folders()));\\n+    excludeFolders.AppendElement(new nsTArray<PRInt64>());\\n+  }\\n \\n   // filter against query options\\n   // XXX only excludeQueries is supported at the moment\\n   PRBool excludeQueries = PR_FALSE;\\n-  if (aParentNode) {\\n-    rv = aParentNode->mOptions->GetExcludeQueries(&excludeQueries);\\n+  if (aQueryNode) {\\n+    rv = aQueryNode->mOptions->GetExcludeQueries(&excludeQueries);\\n     NS_ENSURE_SUCCESS(rv, rv);\\n   }\\n \\n-  nsCStringArray searchAnnotations;\\n-  /*\\n-  if (mAnnotationService) {\\n-    searchAnnotations.AppendCString(NS_LITERAL_CSTRING(\\\"qwer\\\"));\\n-    searchAnnotations.AppendCString(NS_LITERAL_CSTRING(\\\"asdf\\\"));\\n-    searchAnnotations.AppendCString(NS_LITERAL_CSTRING(\\\"zxcv\\\"));\\n-    //mAnnotationService->GetSearchableAnnotations();\\n-  }\\n-  */\\n-\\n   for (PRInt32 nodeIndex = 0; nodeIndex < aSet.Count(); nodeIndex ++) {\\n-    if (aParentNode && aParentNode->mItemId != -1) {\\n-      if (aParentNode->mItemId == aSet[nodeIndex]->mItemId) {\\n-        continue; // filter out bookmark nodes that are the same as the parent\\n-      }\\n-    }\\n-\\n     if (excludeQueries && IsQueryURI(aSet[nodeIndex]->mURI))\\n       continue;\\n \\n-    PRBool allTermsFound = PR_TRUE;\\n-\\n-    nsStringArray curAnnotations;\\n-    /*\\n-    if (searchAnnotations.Count()) {\\n-      // come up with a list of all annotation *values* we need to search\\n-      for (PRInt32 annotIndex = 0; annotIndex < searchAnnotations.Count(); annotIndex ++) {\\n-        nsString annot;\\n-        if (NS_SUCCEEDED(mAnnotationService->GetAnnotationString(\\n-                                         aSet[nodeIndex]->mURI,\\n-                                         *searchAnnotations[annotIndex],\\n-                                         annot)))\\n-          curAnnotations.AppendString(annot);\\n-      }\\n+    PRInt64 parentId = -1;\\n+    if (aSet[nodeIndex]->mItemId != -1) {\\n+      if (aQueryNode->mItemId == aSet[nodeIndex]->mItemId)\\n+        continue;\\n+      rv = bookmarks->GetFolderIdForItem(aSet[nodeIndex]->mItemId, &parentId);\\n+      NS_ENSURE_SUCCESS(rv, rv);\\n     }\\n-    */\\n \\n-    if (terms.Count() == 0) {\\n-        allTermsFound = PR_TRUE;\\n-    } else {\\n+    // Append the node if it matches one of the queries\\n+    PRBool appendNode = PR_FALSE;\\n+    for (queryIndex = 0;\\n+         queryIndex < aQueries.Count() && !appendNode; queryIndex++) {\\n+      // parent folder\\n+      if (includeFolders[queryIndex]->Length() != 0) {\\n+        // filter out simple history nodes from bookmark queries\\n+        if (aSet[nodeIndex]->mItemId == -1)\\n+          continue;\\n+\\n+        // filter out the node of which their parent is in the exclude-folders\\n+        // cache\\n+        if (excludeFolders[queryIndex]->IndexOf(parentId) != -1)\\n+          continue;\\n+\\n+        if (includeFolders[queryIndex]->IndexOf(parentId) == -1) {\\n+          // check ancestors\\n+          PRInt64 ancestor = parentId, lastAncestor;\\n+          PRBool belongs = PR_FALSE;\\n+\\n+          while (!belongs) {\\n+            // Avoid using |ancestor| itself if GetFolderIdForItem failed.\\n+            lastAncestor = ancestor;\\n+\\n+            // GetFolderIdForItems throws when called for the places-root\\n+            if (NS_FAILED(bookmarks->GetFolderIdForItem(ancestor,&ancestor))) {\\n+              break;\\n+            } else if (includeFolders[queryIndex]->IndexOf(ancestor) != -1) {\\n+              belongs = PR_TRUE;\\n+            }\\n+          }\\n+          if (belongs) {\\n+            includeFolders[queryIndex]->AppendElement(lastAncestor);\\n+          } else {\\n+            excludeFolders[queryIndex]->AppendElement(lastAncestor);\\n+            continue;\\n+          }\\n+        }\\n+      }\\n \\n-      for (PRInt32 termIndex = 0; termIndex < terms.Count(); termIndex ++) {\\n+      // search terms\\n+      // XXXmano/dietrich: when bug 331487 is fixed, bookmark queries can group\\n+      // by folder or not regardless of specified folders or search terms.\\n+      PRBool allTermsFound = PR_TRUE;\\n+      for (PRInt32 termIndex = 0; termIndex < terms[queryIndex]->Count() &&\\n+           allTermsFound; termIndex ++) {\\n+        // search terms should match title, url or tags\\n         PRBool termFound = PR_FALSE;\\n         // title and URL\\n-        if (CaseInsensitiveFindInReadable(*terms[termIndex],\\n+        if (CaseInsensitiveFindInReadable(*terms[queryIndex]->StringAt(termIndex),\\n                                           NS_ConvertUTF8toUTF16(aSet[nodeIndex]->mTitle)) ||\\n             (aSet[nodeIndex]->IsURI() &&\\n-             CaseInsensitiveFindInReadable(*terms[termIndex],\\n-                                    NS_ConvertUTF8toUTF16(aSet[nodeIndex]->mURI))))\\n+              CaseInsensitiveFindInReadable(*terms[queryIndex]->StringAt(termIndex),\\n+                                            NS_ConvertUTF8toUTF16(aSet[nodeIndex]->mURI))))\\n           termFound = PR_TRUE;\\n \\n-        // searchable annotations\\n-        /*if (! termFound) {\\n-          for (PRInt32 annotIndex = 0; annotIndex < curAnnotations.Count(); annotIndex ++) {\\n-            if (CaseInsensitiveFindInReadable(*terms[termIndex],\\n-                                              *curAnnotations[annotIndex]))\\n-              termFound = PR_TRUE;\\n-          }\\n-        }*/\\n-\\n-        // search tags\\n+        // tags\\n         if (!termFound) {\\n           nsCOMPtr<nsIURI> itemURI;\\n           rv = NS_NewURI(getter_AddRefs(itemURI), aSet[nodeIndex]->mURI);\\n           NS_ENSURE_SUCCESS(rv, rv);\\n-          termFound = URIHasTag(itemURI, *terms[termIndex]);\\n+          termFound = URIHasTag(itemURI, *terms[queryIndex]->StringAt(termIndex));\\n         }\\n \\n-        if (!termFound) {\\n+        if (!termFound)\\n           allTermsFound = PR_FALSE;\\n-          break;\\n-        }\\n       }\\n-    }\\n+      if (!allTermsFound)\\n+        continue;\\n \\n-    if (allTermsFound)\\n+      appendNode = PR_TRUE;\\n+    }\\n+    if (appendNode)\\n       aFiltered->AppendObject(aSet[nodeIndex]);\\n   }\\n+\\n+  // de-allocate the matrixes\\n+  for (PRUint32 i=0; i < aQueries.Count(); i++) {\\n+    delete terms[i];\\n+    delete includeFolders[i];\\n+    delete excludeFolders[i];\\n+  }\\n+\\n   return NS_OK;\\n }\\n \\n@@ -4920,9 +4942,13 @@ GetSimpleBookmarksQueryFolder(const nsCOMArray<nsNavHistoryQuery>& aQueries,\\n }\\n \\n \\n-// ParseSearchQuery\\n+// ParseSearchTermsFromQueries\\n //\\n-//    This just breaks the query up into words. We don't do anything fancy,\\n+//    Construct a matrix of search terms from the given queries array.\\n+//    All of the query objects are ORed together. Within a query, all the terms\\n+//    are ANDed together. See nsINavHistory.idl.\\n+//\\n+//    This just breaks the quer up into words. We don't do anything fancy,\\n //    not even quoting. We do, however, strip quotes, because people might\\n //    try to input quotes expecting them to do something and get no results\\n //    back.\\n@@ -4932,26 +4958,38 @@ inline PRBool isQueryWhitespace(PRUnichar ch)\\n   return ch == ' ';\\n }\\n \\n-void ParseSearchQuery(const nsString& aQuery, nsStringArray* aTerms)\\n+void ParseSearchTermsFromQueries(const nsCOMArray<nsNavHistoryQuery>& aQueries,\\n+                                 nsTArray<nsStringArray*>* aTerms)\\n {\\n   PRInt32 lastBegin = -1;\\n-  for (PRUint32 i = 0; i < aQuery.Length(); i ++) {\\n-    if (isQueryWhitespace(aQuery[i]) || aQuery[i] == '\\\"') {\\n-      if (lastBegin >= 0) {\\n-        // found the end of a word\\n-        aTerms->AppendString(Substring(aQuery, lastBegin, i - lastBegin));\\n-        lastBegin = -1;\\n-      }\\n-    } else {\\n-      if (lastBegin < 0) {\\n-        // found the beginning of a word\\n-        lastBegin = i;\\n+  for (PRUint32 i=0; i < aQueries.Count(); i++) {\\n+    nsStringArray *queryTerms = new nsStringArray();\\n+    PRBool hasSearchTerms;\\n+    if (NS_SUCCEEDED(aQueries[i]->GetHasSearchTerms(&hasSearchTerms)) &&\\n+        hasSearchTerms) {\\n+      const nsString& searchTerms = aQueries[i]->SearchTerms();\\n+      for (PRUint32 j = 0; j < searchTerms.Length(); j++) {\\n+        if (isQueryWhitespace(searchTerms[j]) ||\\n+            searchTerms[j] == '\\\"') {\\n+          if (lastBegin >= 0) {\\n+            // found the end of a word\\n+            queryTerms->AppendString(Substring(searchTerms, lastBegin,\\n+                                               j - lastBegin));\\n+            lastBegin = -1;\\n+          }\\n+        } else {\\n+          if (lastBegin < 0) {\\n+            // found the beginning of a word\\n+            lastBegin = j;\\n+          }\\n+        }\\n       }\\n+      // last word\\n+      if (lastBegin >= 0)\\n+        queryTerms->AppendString(Substring(searchTerms, lastBegin));\\n     }\\n+    aTerms->AppendElement(queryTerms);\\n   }\\n-  // last word\\n-  if (lastBegin >= 0)\\n-    aTerms->AppendString(Substring(aQuery, lastBegin));\\n }\\n \\n \\ndiff --git a/toolkit/components/places/src/nsNavHistory.h b/toolkit/components/places/src/nsNavHistory.h\\nindex d287b57..1ed0611 100644\\n--- a/toolkit/components/places/src/nsNavHistory.h\\n+++ b/toolkit/components/places/src/nsNavHistory.h\\n@@ -516,7 +516,7 @@ protected:\\n   nsresult FilterResultSet(nsNavHistoryQueryResultNode *aParentNode,\\n                            const nsCOMArray<nsNavHistoryResultNode>& aSet,\\n                            nsCOMArray<nsNavHistoryResultNode>* aFiltered,\\n-                           const nsString& aSearch);\\n+                           const nsCOMArray<nsNavHistoryQuery>& aQueries);\\n \\n   // observers\\n   nsMaybeWeakPtrArray<nsINavHistoryObserver> mObservers;\\ndiff --git a/toolkit/components/places/tests/bookmarks/test_384228.js b/toolkit/components/places/tests/bookmarks/test_384228.js\\nnew file mode 100644\\nindex 0000000..30816cd\\n--- /dev/null\\n+++ b/toolkit/components/places/tests/bookmarks/test_384228.js\\n@@ -0,0 +1,97 @@\\n+/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n+/* vim:set ts=2 sw=2 sts=2 et: */\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is mozilla.org code.\\n+ *\\n+ * The Initial Developer of the Original Code is Google Inc.\\n+ * Portions created by the Initial Developer are Copyright (C) 2005\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *  Seth Spitzer <sspitzer@mozilla.com>\\n+ *  Asaf Romano <mano@mozilla.com>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+\\n+// Get bookmark service\\n+try {\\n+  var bmsvc = Cc[\\\"@mozilla.org/browser/nav-bookmarks-service;1\\\"].getService(Ci.nsINavBookmarksService);\\n+} catch(ex) {\\n+  do_throw(\\\"Could not get nav-bookmarks-service\\\\n\\\");\\n+}\\n+\\n+// Get history service\\n+try {\\n+  var histsvc = Cc[\\\"@mozilla.org/browser/nav-history-service;1\\\"].getService(Ci.nsINavHistoryService);\\n+} catch(ex) {\\n+  do_throw(\\\"Could not get history service\\\\n\\\");\\n+} \\n+\\n+// get bookmarks root id\\n+var root = bmsvc.bookmarksRoot;\\n+\\n+// main\\n+function run_test() {\\n+  // test querying for bookmarks in multiple folders\\n+  var testFolder1 = bmsvc.createFolder(root, \\\"bug 384228 test folder 1\\\",\\n+                                       bmsvc.DEFAULT_INDEX);\\n+  var testFolder2 = bmsvc.createFolder(root, \\\"bug 384228 test folder 2\\\",\\n+                                       bmsvc.DEFAULT_INDEX);\\n+  var testFolder3 = bmsvc.createFolder(root, \\\"bug 384228 test folder 3\\\",\\n+                                       bmsvc.DEFAULT_INDEX);\\n+\\n+  var b1 = bmsvc.insertBookmark(testFolder1, uri(\\\"http://foo.tld/\\\"),\\n+                                bmsvc.DEFAULT_INDEX, \\\"title b1 (folder 1)\\\");\\n+  var b2 = bmsvc.insertBookmark(testFolder1, uri(\\\"http://foo.tld/\\\"),\\n+                                bmsvc.DEFAULT_INDEX, \\\"title b2 (folder 1)\\\");\\n+  var b3 = bmsvc.insertBookmark(testFolder2, uri(\\\"http://foo.tld/\\\"),\\n+                                bmsvc.DEFAULT_INDEX, \\\"title b3 (folder 2)\\\");\\n+  var b4 = bmsvc.insertBookmark(testFolder3, uri(\\\"http://foo.tld/\\\"),\\n+                                bmsvc.DEFAULT_INDEX, \\\"title b4 (folder 3)\\\");\\n+  // also test recursive search\\n+  var testFolder1_1 = bmsvc.createFolder(testFolder1, \\\"bug 384228 test folder 1.1\\\",\\n+                                         bmsvc.DEFAULT_INDEX);\\n+  var b5 = bmsvc.insertBookmark(testFolder1_1, uri(\\\"http://a1.com/\\\"),\\n+                                bmsvc.DEFAULT_INDEX, \\\"title b5 (folder 1.1)\\\");\\n+  var options = histsvc.getNewQueryOptions();\\n+  var query = histsvc.getNewQuery();\\n+  query.searchTerms = \\\"title\\\";\\n+  options.queryType = Ci.nsINavHistoryQueryOptions.QUERY_TYPE_BOOKMARKS;\\n+  query.setFolders([testFolder1, testFolder2], 2);\\n+\\n+  var result = histsvc.executeQuery(query, options);\\n+  var rootNode = result.root;\\n+  rootNode.containerOpen = true;\\n+\\n+  // should not match item from folder 3\\n+  do_check_eq(rootNode.childCount, 4);\\n+\\n+  do_check_eq(rootNode.getChild(0).itemId, b1);\\n+  do_check_eq(rootNode.getChild(1).itemId, b2);\\n+  do_check_eq(rootNode.getChild(2).itemId, b3);\\n+  do_check_eq(rootNode.getChild(3).itemId, b5);\\n+}\\ndiff --git a/toolkit/components/places/tests/bookmarks/test_395593.js b/toolkit/components/places/tests/bookmarks/test_395593.js\\nnew file mode 100644\\nindex 0000000..c4c94625\\n--- /dev/null\\n+++ b/toolkit/components/places/tests/bookmarks/test_395593.js\\n@@ -0,0 +1,106 @@\\n+/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n+/* vim:set ts=2 sw=2 sts=2 et: */\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is bug 395593 unit test code.\\n+ *\\n+ * The Initial Developer of the Original Code is Mozilla Corporation.\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *  Asaf Romano <mano@mozilla.com> (Original Author)\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+\\n+// Get bookmark service\\n+try {\\n+  var bmsvc = Cc[\\\"@mozilla.org/browser/nav-bookmarks-service;1\\\"].getService(Ci.nsINavBookmarksService);\\n+} catch(ex) {\\n+  do_throw(\\\"Could not get nav-bookmarks-service\\\\n\\\");\\n+}\\n+\\n+// Get history service\\n+try {\\n+  var histsvc = Cc[\\\"@mozilla.org/browser/nav-history-service;1\\\"].getService(Ci.nsINavHistoryService);\\n+} catch(ex) {\\n+  do_throw(\\\"Could not get history service\\\\n\\\");\\n+} \\n+\\n+// get bookmarks root id\\n+var root = bmsvc.bookmarksRoot;\\n+\\n+// main\\n+function run_test() {\\n+  /**\\n+   * All of the query objects are ORed together. Within a query, all the terms\\n+   * are ANDed together. See nsINavHistory.idl.\\n+   */\\n+  var id1 = bmsvc.insertBookmark(root, uri(\\\"http://foo.tld\\\"),\\n+                                 bmsvc.DEFAULT_INDEX, \\\"123 0\\\");\\n+  var id2 = bmsvc.insertBookmark(root, uri(\\\"http://foo.tld\\\"),\\n+                                 bmsvc.DEFAULT_INDEX, \\\"456\\\");\\n+  var id3 = bmsvc.insertBookmark(root, uri(\\\"http://foo.tld\\\"),\\n+                                 bmsvc.DEFAULT_INDEX, \\\"123 456\\\");\\n+  var id4 = bmsvc.insertBookmark(root, uri(\\\"http://foo.tld\\\"),\\n+                                 bmsvc.DEFAULT_INDEX, \\\"789 456\\\");\\n+\\n+  var queries = [];\\n+  queries.push(histsvc.getNewQuery());\\n+  queries[0].searchTerms = \\\"123\\\";\\n+  queries.push(histsvc.getNewQuery());\\n+  queries[1].searchTerms = \\\"789\\\";\\n+\\n+  var options = histsvc.getNewQueryOptions();\\n+  options.queryType = Ci.nsINavHistoryQueryOptions.QUERY_TYPE_BOOKMARKS;\\n+\\n+  var result = histsvc.executeQueries(queries, queries.length, options);\\n+  var root = result.root;\\n+  root.containerOpen = true;\\n+  do_check_eq(root.childCount, 3);\\n+  do_check_eq(root.getChild(0).itemId, id1);\\n+  do_check_eq(root.getChild(1).itemId, id3);\\n+  do_check_eq(root.getChild(2).itemId, id4);\\n+\\n+  queries[0].searchTerms = \\\"123\\\";\\n+  queries[1].searchTerms = \\\"456\\\";\\n+  result = histsvc.executeQueries(queries, queries.length, options);\\n+  root = result.root;\\n+  root.containerOpen = true;\\n+  do_check_eq(root.childCount, 4);\\n+  do_check_eq(root.getChild(0).itemId, id1);\\n+  do_check_eq(root.getChild(1).itemId, id2);\\n+  do_check_eq(root.getChild(2).itemId, id3);\\n+  do_check_eq(root.getChild(3).itemId, id4);\\n+\\n+  queries[0].searchTerms = \\\"00\\\";\\n+  queries[1].searchTerms = \\\"789\\\";\\n+  result = histsvc.executeQueries(queries, queries.length, options);\\n+  root = result.root;\\n+  root.containerOpen = true;\\n+  do_check_eq(root.childCount, 1);\\n+  do_check_eq(root.getChild(0).itemId, id4);\\n+}\\n\""}