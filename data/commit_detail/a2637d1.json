{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basa2637d1\""},"diff":"\"a2637d1 Bug 392160, improve popup positioning to not use widget calculations, r=sharparrow, sr=bz, a=dbaron\\ndiff --git a/layout/xul/base/src/nsMenuPopupFrame.cpp b/layout/xul/base/src/nsMenuPopupFrame.cpp\\nindex 27d9814..e0405c1 100644\\n--- a/layout/xul/base/src/nsMenuPopupFrame.cpp\\n+++ b/layout/xul/base/src/nsMenuPopupFrame.cpp\\n@@ -599,70 +599,36 @@ nsMenuPopupFrame::GetLayoutFlags(PRUint32& aFlags)\\n }\\n \\n ///////////////////////////////////////////////////////////////////////////////\\n-// GetViewOffset\\n-//   Retrieves the offset of the given view with the root view, in the \\n-//   coordinate system of the root view. \\n-void\\n-nsMenuPopupFrame::GetViewOffset(nsIView* aView, nsPoint& aPoint)\\n-{\\n-  // Notes:\\n-  //   1) The root view is the client area of the toplevel window that\\n-  //      this popup is anchored to. \\n-  //   2) Each menupopup is a child of the root view (see \\n-  //      nsMenuPopupFrame::Init())\\n-  //   3) The coordinates that we return are the total distance between \\n-  //      the top left of the start view and the origin of the root view.\\n-  \\n-  // Keep track of the root view so that we know to stop there\\n-  nsIView* rootView;\\n-  aView->GetViewManager()->GetRootView(rootView);\\n-  aPoint = aView->GetOffsetTo(rootView);\\n-}\\n-\\n-///////////////////////////////////////////////////////////////////////////////\\n // GetRootViewForPopup\\n //   Retrieves the view for the popup widget that contains the given frame. \\n //   If the given frame is not contained by a popup widget, return the\\n-//   root view.  This is the root view of the pres context's\\n-//   viewmanager if aStopAtViewManagerRoot is true; otherwise it's the\\n //   root view of the root viewmanager.\\n nsIView*\\n-nsMenuPopupFrame::GetRootViewForPopup(nsIFrame* aStartFrame,\\n-                                      PRBool    aStopAtViewManagerRoot)\\n+nsMenuPopupFrame::GetRootViewForPopup(nsIFrame* aStartFrame)\\n {\\n   nsIView* view = aStartFrame->GetClosestView();\\n   NS_ASSERTION(view, \\\"frame must have a closest view!\\\");\\n-  if (view) {\\n-    nsIView* rootView = nsnull;\\n-    if (aStopAtViewManagerRoot) {\\n-      view->GetViewManager()->GetRootView(rootView);\\n-    }\\n-    \\n-    while (view) {\\n-      // Walk up the view hierarchy looking for a view whose widget has a \\n-      // window type of eWindowType_popup - in other words a popup window\\n-      // widget. If we find one, this is the view we want. \\n-      nsIWidget* widget = view->GetWidget();\\n-      if (widget) {\\n-        nsWindowType wtype;\\n-        widget->GetWindowType(wtype);\\n-        if (wtype == eWindowType_popup) {\\n-          return view;\\n-        }\\n-      }\\n-\\n-      if (aStopAtViewManagerRoot && view == rootView) {\\n+  nsIView* rootView = nsnull;\\n+  while (view) {\\n+    // Walk up the view hierarchy looking for a view whose widget has a \\n+    // window type of eWindowType_popup - in other words a popup window\\n+    // widget. If we find one, this is the view we want. \\n+    nsIWidget* widget = view->GetWidget();\\n+    if (widget) {\\n+      nsWindowType wtype;\\n+      widget->GetWindowType(wtype);\\n+      if (wtype == eWindowType_popup) {\\n         return view;\\n       }\\n+    }\\n \\n-      nsIView* temp = view->GetParent();\\n-      if (!temp) {\\n-        // Otherwise, we've walked all the way up to the root view and not\\n-        // found a view for a popup window widget. Just return the root view.\\n-        return view;\\n-      }\\n-      view = temp;\\n+    nsIView* temp = view->GetParent();\\n+    if (!temp) {\\n+      // Otherwise, we've walked all the way up to the root view and not\\n+      // found a view for a popup window widget. Just return the root view.\\n+      return view;\\n     }\\n+    view = temp;\\n   }\\n \\n   return nsnull;\\n@@ -854,6 +820,7 @@ nsMenuPopupFrame::SetPopupPosition(nsIFrame* aAnchorFrame)\\n   PRBool sizedToPopup = PR_FALSE;\\n \\n   nsPresContext* presContext = PresContext();\\n+  nsIFrame* rootFrame = presContext->PresShell()->FrameManager()->GetRootFrame();\\n \\n   // if the frame is not specified, use the anchor node passed to ShowPopup. If\\n   // that wasn't specified either, use the root frame. Note that mAnchorContent\\n@@ -871,7 +838,7 @@ nsMenuPopupFrame::SetPopupPosition(nsIFrame* aAnchorFrame)\\n     }\\n \\n     if (!aAnchorFrame) {\\n-      aAnchorFrame = presContext->PresShell()->FrameManager()->GetRootFrame();\\n+      aAnchorFrame = rootFrame;\\n       if (!aAnchorFrame)\\n         return NS_OK;\\n     }\\n@@ -882,96 +849,58 @@ nsMenuPopupFrame::SetPopupPosition(nsIFrame* aAnchorFrame)\\n     sizedToPopup = nsMenuFrame::IsSizedToPopup(aAnchorFrame->GetContent(), PR_FALSE);\\n   }\\n \\n-  // |containingView|\\n-  //   The view that contains the frame that is invoking this popup. This is \\n-  //   the canvas view inside the scrollport view. It can have negative bounds\\n-  //   if the canvas is scrolled so that part is off screen.\\n-  nsIView* containingView = nsnull;\\n-  nsPoint offset;\\n-  nsMargin margin;\\n-  containingView = aAnchorFrame->GetClosestView(&offset);\\n-  if (!containingView)\\n-    return NS_OK;\\n-\\n-  // |parentPos|\\n-  //   The distance between the containingView and the root view. This provides\\n-  //   a hint as to where to position the menu relative to the window. \\n-  nsPoint parentPos;\\n-  GetViewOffset(containingView, parentPos);\\n-\\n   // |parentRect|\\n   //   The dimensions of the frame invoking the popup. \\n   nsRect parentRect = aAnchorFrame->GetRect();\\n \\n-  // get the document and the global script object\\n-  nsIPresShell *presShell = presContext->PresShell();\\n-  nsIDocument *document = presShell->GetDocument();\\n-\\n   // If we stick to our parent's width, set it here before we move the\\n   // window around, because moving is done with respect to the width...\\n   if (sizedToPopup) {\\n     mRect.width = parentRect.width;\\n   }\\n \\n-  // Use containingView instead of parentView, to account for the scrollarrows\\n-  // that a parent menu might have.\\n-  nsPoint parentViewWidgetOffset;\\n-  nsIWidget* parentViewWidget = containingView->GetNearestWidget(&parentViewWidgetOffset);\\n-  nsRect localParentWidgetRect(0,0,0,0), screenParentWidgetRect;\\n-  parentViewWidget->WidgetToScreen ( localParentWidgetRect, screenParentWidgetRect );\\n-\\n   // |xpos| and |ypos| hold the x and y positions of where the popup will be moved to,\\n-  // in _twips_, in the coordinate system of the _parent view_.\\n+  // in app units, in the coordinate system of the _parent view_.\\n   PRBool readjustAboveBelow = PR_FALSE;\\n   PRInt32 xpos = 0, ypos = 0;\\n+  nsMargin margin;\\n+\\n+  // the positon in app units where the popup should appear.\\n   PRInt32 screenViewLocX, screenViewLocY;\\n \\n+  // the screen rectangle of the anchor, or if null, the root frame, in dev pixels.\\n+  nsRect anchorScreenRect;\\n+  nsRect rootScreenRect = rootFrame->GetScreenRect();\\n+\\n   if (mScreenXPos == -1 && mScreenYPos == -1) {\\n     // if we are anchored to our parent, there are certain things we don't want to do\\n     // when repositioning the view to fit on the screen, such as end up positioned over\\n     // the parent. When doing this reposition, we want to move the popup to the side with\\n     // the most room. The combination of anchor and alignment dictate if we readjust \\n     // above/below or to the left/right.\\n-\\n     if (mAnchorContent) {\\n-      xpos = parentPos.x + offset.x;\\n-      ypos = parentPos.y + offset.y;\\n+      anchorScreenRect = aAnchorFrame->GetScreenRect();\\n+      xpos = presContext->DevPixelsToAppUnits(anchorScreenRect.x - rootScreenRect.x);\\n+      ypos = presContext->DevPixelsToAppUnits(anchorScreenRect.y - rootScreenRect.y);\\n \\n       // move the popup according to the anchor and alignment. This will also tell us\\n       // which axis the popup is flush against in case we have to move it around later.\\n       AdjustPositionForAnchorAlign(&xpos, &ypos, parentRect, &readjustAboveBelow);\\n-\\n-      // the x and y position may be used to offset the popup after it has been anchored\\n-      xpos += presContext->DevPixelsToAppUnits(mXPos);\\n-      ypos += presContext->DevPixelsToAppUnits(mYPos);\\n     }\\n     else {\\n+      // with no anchor, the popup is positioned relative to the root frame\\n+      anchorScreenRect = rootScreenRect;\\n       GetStyleMargin()->GetMargin(margin);\\n-      xpos = presContext->DevPixelsToAppUnits(mXPos) + margin.left;\\n-      ypos = presContext->DevPixelsToAppUnits(mYPos) + margin.top;\\n+      xpos = margin.left;\\n+      ypos = margin.top;\\n     }\\n \\n-    // Recall that |xpos| and |ypos| are in the coordinate system of the parent view. In\\n-    // order to determine the screen coordinates of where our view will end up, we\\n-    // need to find the x/y position of the parent view in screen coords. That is done\\n-    // by getting the widget associated with the parent view and determining the offset \\n-    // based on converting (0,0) in its coordinate space to screen coords. We then\\n-    // offset that point by (|xpos|,|ypos|) to get the true screen coordinates of\\n-    // the view. *whew*\\n-\\n-    // |parentView|\\n-    //   The root view for the window that contains the frame, for frames inside \\n-    //   menupopups this is the first view inside the popup window widget, for \\n-    //   frames inside a toplevel window, this is the root view of the toplevel\\n-    //   window.\\n-    nsIView* parentView = GetRootViewForPopup(aAnchorFrame, PR_FALSE);\\n-    if (!parentView)\\n-      return NS_OK;\\n-\\n-    screenViewLocX = presContext->DevPixelsToAppUnits(screenParentWidgetRect.x) +\\n-      (xpos - parentPos.x) + parentViewWidgetOffset.x;\\n-    screenViewLocY = presContext->DevPixelsToAppUnits(screenParentWidgetRect.y) +\\n-      (ypos - parentPos.y) + parentViewWidgetOffset.y;\\n+    // add on the offset\\n+    xpos += presContext->CSSPixelsToAppUnits(mXPos);\\n+    ypos += presContext->CSSPixelsToAppUnits(mYPos);\\n+\\n+    screenViewLocX = presContext->DevPixelsToAppUnits(rootScreenRect.x) + xpos;\\n+    screenViewLocY = presContext->DevPixelsToAppUnits(rootScreenRect.y) + ypos;\\n   }\\n   else {\\n     // positioned on screen\\n@@ -979,19 +908,15 @@ nsMenuPopupFrame::SetPopupPosition(nsIFrame* aAnchorFrame)\\n     screenViewLocX = nsPresContext::CSSPixelsToAppUnits(mScreenXPos) + margin.left;\\n     screenViewLocY = nsPresContext::CSSPixelsToAppUnits(mScreenYPos) + margin.top;\\n \\n-    xpos = screenViewLocX - presContext->DevPixelsToAppUnits(screenParentWidgetRect.x) -\\n-           parentViewWidgetOffset.x - parentPos.x;\\n-    ypos = screenViewLocY - presContext->DevPixelsToAppUnits(screenParentWidgetRect.y) -\\n-           parentViewWidgetOffset.y - parentPos.y;\\n+    // determine the x and y position by subtracting the desired screen\\n+    // position from the screen position of the root frame.\\n+    xpos = screenViewLocX - presContext->DevPixelsToAppUnits(rootScreenRect.x);\\n+    ypos = screenViewLocY - presContext->DevPixelsToAppUnits(rootScreenRect.y);\\n   }\\n \\n   // Compute info about the screen dimensions. Because of multiple monitor systems,\\n   // the left or top sides of the screen may be in negative space (main monitor is on the\\n   // right, etc). We need to be sure to do the right thing.\\n-  nsPIDOMWindow *window = document->GetWindow();\\n-  if (!window)\\n-    return NS_OK;\\n-\\n   nsIDeviceContext* devContext = PresContext()->DeviceContext();\\n   nsRect rect;\\n   if ( mMenuCanOverlapOSBar ) {\\n@@ -1007,7 +932,6 @@ nsMenuPopupFrame::SetPopupPosition(nsIFrame* aAnchorFrame)\\n \\n   // for content shells, clip to the client area rather than the screen area\\n   if (mInContentShell) {\\n-    nsRect rootScreenRect = presShell->GetRootFrame()->GetScreenRect();\\n     rootScreenRect.ScaleRoundIn(presContext->AppUnitsPerDevPixel());\\n     rect.IntersectRect(rect, rootScreenRect);\\n   }\\n@@ -1020,6 +944,8 @@ nsMenuPopupFrame::SetPopupPosition(nsIFrame* aAnchorFrame)\\n   PRInt32 screenBottomTwips = rect.YMost();\\n \\n   if (mPopupAnchor != POPUPALIGNMENT_NONE) {\\n+    NS_ASSERTION(mScreenXPos == -1 && mScreenYPos == -1,\\n+                 \\\"screen position used with anchor\\\");\\n     //\\n     // Popup is anchored to the parent, guarantee that it does not cover the parent. We\\n     // shouldn't do anything funky if it will already fit on the screen as is.\\n@@ -1042,16 +968,6 @@ nsMenuPopupFrame::SetPopupPosition(nsIFrame* aAnchorFrame)\\n     //                |           \\\\/           ||\\n     //                +------------------------+\\n \\n-\\n-\\n-    // compute screen coordinates of parent frame so we can play with it. Make sure we put it\\n-    // into twips as everything else is as well.\\n-    nsRect screenParentFrameRect (presContext->AppUnitsToDevPixels(offset.x), presContext->AppUnitsToDevPixels(offset.y),\\n-                                    parentRect.width, parentRect.height );\\n-    parentViewWidget->WidgetToScreen ( screenParentFrameRect, screenParentFrameRect );\\n-    screenParentFrameRect.x = presContext->DevPixelsToAppUnits(screenParentFrameRect.x);\\n-    screenParentFrameRect.y = presContext->DevPixelsToAppUnits(screenParentFrameRect.y);\\n-\\n     // Don't let it spill off the screen to the top\\n     if (screenViewLocY < screenTopTwips) {\\n       PRInt32 moveDist = screenTopTwips - screenViewLocY;\\n@@ -1063,7 +979,9 @@ nsMenuPopupFrame::SetPopupPosition(nsIFrame* aAnchorFrame)\\n     if ( (screenViewLocX + mRect.width) > screenRightTwips ||\\n            screenViewLocX < screenLeftTwips ||\\n           (screenViewLocY + mRect.height) > screenBottomTwips ) {\\n-      \\n+      nsRect screenParentFrameRect(anchorScreenRect);\\n+      screenParentFrameRect.ScaleRoundOut(PresContext()->AppUnitsPerDevPixel());\\n+\\n       // figure out which side of the parent has the most free space so we can move/resize\\n       // the popup there. This should still work if the parent frame is partially screen.\\n       PRBool switchSides = IsMoreRoomOnOtherSideOfParent ( readjustAboveBelow, screenViewLocX, screenViewLocY,\\n@@ -1576,9 +1494,7 @@ nsMenuPopupFrame::FindMenuWithShortcut(nsIDOMKeyEvent* aKeyEvent, PRBool& doActi\\n NS_IMETHODIMP\\n nsMenuPopupFrame::GetWidget(nsIWidget **aWidget)\\n {\\n-  // Get parent view\\n-  // XXX should this be passing PR_FALSE or PR_TRUE for aStopAtViewManagerRoot?\\n-  nsIView * view = GetRootViewForPopup(this, PR_FALSE);\\n+  nsIView * view = GetRootViewForPopup(this);\\n   if (!view)\\n     return NS_OK;\\n \\ndiff --git a/layout/xul/base/src/nsMenuPopupFrame.h b/layout/xul/base/src/nsMenuPopupFrame.h\\nindex b39d4f1..531d238 100644\\n--- a/layout/xul/base/src/nsMenuPopupFrame.h\\n+++ b/layout/xul/base/src/nsMenuPopupFrame.h\\n@@ -204,9 +204,7 @@ public:\\n   // laid out, so that the view can be shown.\\n   void AdjustView();\\n \\n-  void GetViewOffset(nsIView* aView, nsPoint& aPoint);\\n-  nsIView* GetRootViewForPopup(nsIFrame* aStartFrame,\\n-                               PRBool aStopAtViewManagerRoot);\\n+  nsIView* GetRootViewForPopup(nsIFrame* aStartFrame);\\n \\n   // set the position of the popup either relative to the anchor aAnchorFrame\\n   // (or the frame for mAnchorContent if aAnchorFrame is null) or at a specific\\ndiff --git a/toolkit/content/tests/chrome/Makefile.in b/toolkit/content/tests/chrome/Makefile.in\\nindex 1ce9f35..c3902f6 100644\\n--- a/toolkit/content/tests/chrome/Makefile.in\\n+++ b/toolkit/content/tests/chrome/Makefile.in\\n@@ -58,6 +58,9 @@ _TEST_FILES = \\tbug288254_window.xul \\\\\\n \\t\\twindow_popup_preventdefault_chrome.xul \\\\\\n \\t\\ttest_largemenu.xul \\\\\\n \\t\\twindow_largemenu.xul \\\\\\n+\\t\\ttest_popup_anchor.xul \\\\\\n+\\t\\twindow_popup_anchor.xul \\\\\\n+\\t\\tframe_popup_anchor.xul \\\\\\n \\t\\t$(NULL)\\n \\n ifeq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))\\ndiff --git a/toolkit/content/tests/chrome/frame_popup_anchor.xul b/toolkit/content/tests/chrome/frame_popup_anchor.xul\\nnew file mode 100644\\nindex 0000000..a6c02fd1\\n--- /dev/null\\n+++ b/toolkit/content/tests/chrome/frame_popup_anchor.xul\\n@@ -0,0 +1,44 @@\\n+<?xml version=\\\"1.0\\\"?>\\n+<?xml-stylesheet href=\\\"chrome://global/skin\\\" type=\\\"text/css\\\"?>\\n+\\n+<page xmlns=\\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\">\\n+\\n+<menupopup id=\\\"popup\\\" onpopupshown=\\\"popupShown()\\\">\\n+  <menuitem label=\\\"One\\\"/>\\n+  <menuitem label=\\\"Two\\\"/>\\n+</menupopup>\\n+\\n+<script class=\\\"testbody\\\" type=\\\"application/javascript\\\">\\n+<![CDATA[\\n+\\n+function openPopup()\\n+{\\n+  document.getElementById(\\\"popup\\\").openPopup(parent.document.getElementById(\\\"outerbutton\\\"), \\\"after_start\\\", 3, 1);\\n+}\\n+\\n+function popupShown()\\n+{\\n+  var popuprect = document.getElementById(\\\"popup\\\").getBoundingClientRect();\\n+  var iframerect = parent.document.getElementById(\\\"frame\\\").getBoundingClientRect();\\n+  var buttonrect = parent.document.getElementById(\\\"outerbutton\\\").getBoundingClientRect();\\n+\\n+  // The popup should appear anchored on the bottom left edge of the button, however\\n+  // the client rectangle is relative to the iframe's document. Thus the coordinates\\n+  // are:\\n+  //  left = iframe's left - anchor button's left - 3 pixel offset passed to openPopup +\\n+  //         iframe border (17px) + iframe padding (0)\\n+  //  top = iframe's top - anchor button's bottom - 1 pixel offset passed to openPopup +\\n+  //        iframe border (0) + iframe padding (3px);\\n+  var left = -(Math.round(iframerect.left) - Math.round(buttonrect.left) + 14);\\n+  var top = -(Math.round(iframerect.top) - Math.round(buttonrect.bottom) + 2);\\n+\\n+  parent.opener.wrappedJSObject.SimpleTest.is(Math.round(popuprect.left), left, \\\"popup left\\\");\\n+  parent.opener.wrappedJSObject.SimpleTest.is(Math.round(popuprect.top), top, \\\"popup top\\\");\\n+  parent.opener.wrappedJSObject.SimpleTest.finish();\\n+  parent.close();\\n+}\\n+\\n+]]>\\n+</script>\\n+\\n+</page>\\ndiff --git a/toolkit/content/tests/chrome/test_popup_anchor.xul b/toolkit/content/tests/chrome/test_popup_anchor.xul\\nnew file mode 100644\\nindex 0000000..5a719ce\\n--- /dev/null\\n+++ b/toolkit/content/tests/chrome/test_popup_anchor.xul\\n@@ -0,0 +1,32 @@\\n+<?xml version=\\\"1.0\\\"?>\\n+<?xml-stylesheet href=\\\"chrome://global/skin\\\" type=\\\"text/css\\\"?>\\n+<?xml-stylesheet href=\\\"chrome://mochikit/content/tests/SimpleTest/test.css\\\" type=\\\"text/css\\\"?>\\n+\\n+<window title=\\\"Popup Anchor Tests\\\"\\n+  onload=\\\"setTimeout(runTest, 0);\\\"\\n+  xmlns:html=\\\"http://www.w3.org/1999/xhtml\\\"\\n+  xmlns=\\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\">\\n+\\n+  <script type=\\\"application/javascript\\\" \\n+          src=\\\"chrome://mochikit/content/MochiKit/packed.js\\\"/>\\n+  <script type=\\\"application/javascript\\\"\\n+          src=\\\"chrome://mochikit/content/tests/SimpleTest/SimpleTest.js\\\"/>\\n+\\n+<script>\\n+SimpleTest.waitForExplicitFinish();\\n+function runTest()\\n+{\\n+  window.open(\\\"window_popup_anchor.xul\\\", \\\"_new\\\", \\\"chrome,width=600,height=600\\\");\\n+}\\n+</script>\\n+\\n+<body xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\\n+<p id=\\\"display\\\">\\n+</p>\\n+<div id=\\\"content\\\" style=\\\"display: none\\\">\\n+</div>\\n+<pre id=\\\"test\\\">\\n+</pre>\\n+</body>\\n+\\n+</window>\\ndiff --git a/toolkit/content/tests/chrome/window_popup_anchor.xul b/toolkit/content/tests/chrome/window_popup_anchor.xul\\nnew file mode 100644\\nindex 0000000..693533a\\n--- /dev/null\\n+++ b/toolkit/content/tests/chrome/window_popup_anchor.xul\\n@@ -0,0 +1,27 @@\\n+<?xml version=\\\"1.0\\\"?>\\n+<?xml-stylesheet href=\\\"chrome://global/skin\\\" type=\\\"text/css\\\"?>\\n+\\n+<window title=\\\"Popup Anchor Tests\\\"\\n+        onload=\\\"setTimeout(runTests, 0)\\\"\\n+        xmlns=\\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\">\\n+\\n+<script>\\n+function runTests()\\n+{\\n+  frames[0].openPopup();\\n+}\\n+</script>\\n+\\n+<spacer height=\\\"13\\\"/>\\n+<button id=\\\"outerbutton\\\" label=\\\"Button One\\\" style=\\\"margin-left: 6px; -moz-appearance: none;\\\"/>\\n+<hbox>\\n+  <spacer width=\\\"20\\\"/>\\n+  <deck>\\n+    <vbox>\\n+      <iframe id=\\\"frame\\\" style=\\\"margin-left: 60px; margin-top: 10px; border-left: 17px solid red; padding-left: 0 !important; padding-top: 3px;\\\"\\n+              width=\\\"250\\\" height=\\\"80\\\" src=\\\"frame_popup_anchor.xul\\\"/>\\n+    </vbox>\\n+  </deck>\\n+</hbox>\\n+\\n+</window>\\n\""}