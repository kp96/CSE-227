{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basd70bc17\""},"diff":"\"d70bc17 Fix session restore to save and restore principals, so that about:blank, javascript:, data: stuff gets restored correctly.  Bug 389274, r+sr=jst for the docshell changes, r=zeniko@gmail.com for the session restore changes, a=mconnor\\ndiff --git a/browser/components/sessionstore/src/nsSessionStore.js b/browser/components/sessionstore/src/nsSessionStore.js\\nindex 611ad85..45cff98 100644\\n--- a/browser/components/sessionstore/src/nsSessionStore.js\\n+++ b/browser/components/sessionstore/src/nsSessionStore.js\\n@@ -869,10 +869,14 @@ SessionStoreService.prototype = {\\n     \\n     var cacheKey = aEntry.cacheKey;\\n     if (cacheKey && cacheKey instanceof Ci.nsISupportsPRUint32) {\\n+      // XXXbz would be better to have cache keys implement\\n+      // nsISerializable or something.\\n       entry.cacheKey = cacheKey.data;\\n     }\\n     entry.ID = aEntry.ID;\\n     \\n+    entry.contentType = aEntry.contentType;\\n+    \\n     var x = {}, y = {};\\n     aEntry.getScrollPosition(x, y);\\n     entry.scroll = x.value + \\\",\\\" + y.value;\\n@@ -882,16 +886,48 @@ SessionStoreService.prototype = {\\n       if (prefPostdata && aEntry.postData && this._checkPrivacyLevel(aEntry.URI.schemeIs(\\\"https\\\"))) {\\n         aEntry.postData.QueryInterface(Ci.nsISeekableStream).\\n                         seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);\\n-        var stream = Cc[\\\"@mozilla.org/scriptableinputstream;1\\\"].\\n-                     createInstance(Ci.nsIScriptableInputStream);\\n-        stream.init(aEntry.postData);\\n-        var postdata = stream.read(stream.available());\\n-        if (prefPostdata == -1 || postdata.replace(/^(Content-.*\\\\r\\\\n)+(\\\\r\\\\n)*/, \\\"\\\").length <= prefPostdata) {\\n-          entry.postdata = postdata;\\n+        var stream = Cc[\\\"@mozilla.org/binaryinputstream;1\\\"].\\n+                     createInstance(Ci.nsIBinaryInputStream);\\n+        stream.setInputStream(aEntry.postData);\\n+        var postBytes = stream.readByteArray(stream.available());\\n+        var postdata = String.fromCharCode.apply(null, postBytes);\\n+        if (prefPostdata == -1 ||\\n+            postdata.replace(/^(Content-.*\\\\r\\\\n)+(\\\\r\\\\n)*/, \\\"\\\").length <=\\n+              prefPostdata) {\\n+          // We can stop doing base64 encoding once our serialization into JSON\\n+          // is guaranteed to handle all chars in strings, including embedded\\n+          // nulls.\\n+          entry.postdata_b64 = btoa(postdata);\\n         }\\n       }\\n     }\\n     catch (ex) { debug(ex); } // POSTDATA is tricky - especially since some extensions don't get it right\\n+\\n+    if (aEntry.owner) {\\n+      // Not catching anything specific here, just possible errors\\n+      // from writeCompoundObject and the like.\\n+      try {\\n+        var binaryStream = Cc[\\\"@mozilla.org/binaryoutputstream;1\\\"].\\n+                           createInstance(Ci.nsIObjectOutputStream);\\n+        var pipe = Cc[\\\"@mozilla.org/pipe;1\\\"].createInstance(Ci.nsIPipe);\\n+        pipe.init(false, false, 0, 0xffffffff, null);\\n+        binaryStream.setOutputStream(pipe.outputStream);\\n+        binaryStream.writeCompoundObject(aEntry.owner, Ci.nsISupports, true);\\n+        binaryStream.close();\\n+\\n+        // Now we want to read the data from the pipe's input end and encode it.\\n+        var scriptableStream = Cc[\\\"@mozilla.org/binaryinputstream;1\\\"].\\n+                               createInstance(Ci.nsIBinaryInputStream);\\n+        scriptableStream.setInputStream(pipe.inputStream);\\n+        var ownerBytes =\\n+          scriptableStream.readByteArray(scriptableStream.available());\\n+        // We can stop doing base64 encoding once our serialization into JSON\\n+        // is guaranteed to handle all chars in strings, including embedded\\n+        // nulls.\\n+        entry.owner_b64 = btoa(String.fromCharCode.apply(null, ownerBytes));\\n+      }\\n+      catch (ex) { debug(ex); }\\n+    }\\n     \\n     if (!(aEntry instanceof Ci.nsISHContainer)) {\\n       return entry;\\n@@ -1420,6 +1456,7 @@ SessionStoreService.prototype = {\\n     shEntry.setTitle(aEntry.title || aEntry.url);\\n     shEntry.setIsSubFrame(aEntry.subframe || false);\\n     shEntry.loadType = Ci.nsIDocShellLoadInfo.loadHistory;\\n+    shEntry.contentType = aEntry.contentType;\\n     \\n     if (aEntry.cacheKey) {\\n       var cacheKey = Cc[\\\"@mozilla.org/supports-PRUint32;1\\\"].\\n@@ -1442,13 +1479,38 @@ SessionStoreService.prototype = {\\n     var scrollPos = (aEntry.scroll || \\\"0,0\\\").split(\\\",\\\");\\n     scrollPos = [parseInt(scrollPos[0]) || 0, parseInt(scrollPos[1]) || 0];\\n     shEntry.setScrollPosition(scrollPos[0], scrollPos[1]);\\n-    \\n-    if (aEntry.postdata) {\\n+\\n+    var postdata;\\n+    if (aEntry.postdata_b64) {  // Firefox 3\\n+      postdata = atob(aEntry.postdata_b64);\\n+    } else if (aEntry.postdata) { // Firefox 2\\n+      postdata = aEntry.postdata;\\n+    }\\n+\\n+    if (postdata) {\\n       var stream = Cc[\\\"@mozilla.org/io/string-input-stream;1\\\"].\\n                    createInstance(Ci.nsIStringInputStream);\\n-      stream.setData(aEntry.postdata, -1);\\n+      stream.setData(postdata, postdata.length);\\n       shEntry.postData = stream;\\n     }\\n+\\n+    if (aEntry.owner_b64) {  // Firefox 3\\n+      var ownerInput = Cc[\\\"@mozilla.org/io/string-input-stream;1\\\"].\\n+                       createInstance(Ci.nsIStringInputStream);\\n+      var binaryData = atob(aEntry.owner_b64);\\n+      ownerInput.setData(binaryData, binaryData.length);\\n+      var binaryStream = Cc[\\\"@mozilla.org/binaryinputstream;1\\\"].\\n+                         createInstance(Ci.nsIObjectInputStream);\\n+      binaryStream.setInputStream(ownerInput);\\n+      try { // Catch possible deserialization exceptions\\n+        shEntry.owner = binaryStream.readObject(true);\\n+      } catch (ex) { debug(ex); }\\n+    } else if (aEntry.ownerURI) { // Firefox 2\\n+      var uriObj = ioService.newURI(aEntry.ownerURI, null, null);\\n+      shEntry.owner = Cc[\\\"@mozilla.org/scriptsecuritymanager;1\\\"].\\n+                      getService(Ci.nsIScriptSecurityManager).\\n+                      getCodebasePrincipal(uriObj);\\n+    }\\n     \\n     if (aEntry.children && shEntry instanceof Ci.nsISHContainer) {\\n       for (var i = 0; i < aEntry.children.length; i++) {\\ndiff --git a/docshell/shistory/public/nsISHEntry.idl b/docshell/shistory/public/nsISHEntry.idl\\nindex dcc4efb..064d172 100644\\n--- a/docshell/shistory/public/nsISHEntry.idl\\n+++ b/docshell/shistory/public/nsISHEntry.idl\\n@@ -55,7 +55,7 @@ struct nsRect;\\n %}\\n [ref] native nsRect(nsRect);\\n \\n-[scriptable, uuid(9b4c7bf5-5e68-4406-9bb4-a4408c8e8bb5)]\\n+[scriptable, uuid(abe54136-49e5-44ca-a749-290038c6b85d)]\\n interface nsISHEntry : nsIHistoryEntry\\n {\\n     /** URI for the document */\\n@@ -166,11 +166,11 @@ interface nsISHEntry : nsIHistoryEntry\\n     void getScrollPosition(out long x, out long y);\\n \\n     /** Additional ways to create an entry */\\n-    void create(in nsIURI URI, in AString title,\\n-                in nsIInputStream inputStream,\\n-                in nsILayoutHistoryState layoutHistoryState,\\n-                in nsISupports cacheKey, in ACString contentType,\\n-                in nsISupports owner);\\n+    [noscript] void create(in nsIURI URI, in AString title,\\n+                           in nsIInputStream inputStream,\\n+                           in nsILayoutHistoryState layoutHistoryState,\\n+                           in nsISupports cacheKey, in ACString contentType,\\n+                           in nsISupports owner);\\n \\n     nsISHEntry clone();\\n \\n@@ -187,7 +187,7 @@ interface nsISHEntry : nsIHistoryEntry\\n      * that the document that was loaded to create this history entry\\n      * came from.\\n      */\\n-    readonly attribute nsISupports owner;\\n+    attribute nsISupports owner;\\n };\\n \\n \\ndiff --git a/docshell/shistory/src/nsSHEntry.cpp b/docshell/shistory/src/nsSHEntry.cpp\\nindex e057c1f..9095d1a 100644\\n--- a/docshell/shistory/src/nsSHEntry.cpp\\n+++ b/docshell/shistory/src/nsSHEntry.cpp\\n@@ -500,6 +500,13 @@ nsSHEntry::GetOwner(nsISupports **aOwner)\\n   return NS_OK;\\n }\\n \\n+NS_IMETHODIMP\\n+nsSHEntry::SetOwner(nsISupports *aOwner)\\n+{\\n+  mOwner = aOwner;\\n+  return NS_OK;\\n+}\\n+\\n //*****************************************************************************\\n //    nsSHEntry: nsISHContainer\\n //*****************************************************************************\\n\""}