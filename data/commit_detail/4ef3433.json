{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas4ef3433\""},"diff":"\"4ef3433 Bug 213637: code cleanup: use nsAutoLock instead of manually calling PR_Lock/PR_Unlock, and removed mThreadEventLock.  r=biesi Modified files: nsSocketTransportService2.cpp nsSocketTransportService2.h\\ndiff --git a/netwerk/base/src/nsSocketTransportService2.cpp b/netwerk/base/src/nsSocketTransportService2.cpp\\nindex a27d2fa..23a0a85 100644\\n--- a/netwerk/base/src/nsSocketTransportService2.cpp\\n+++ b/netwerk/base/src/nsSocketTransportService2.cpp\\n@@ -63,7 +63,6 @@ PRThread                 *gSocketThread           = nsnull;\\n nsSocketTransportService::nsSocketTransportService()\\n     : mThread(nsnull)\\n     , mThreadEvent(nsnull)\\n-    , mThreadEventLock(PR_NewLock())\\n     , mAutodialEnabled(PR_FALSE)\\n     , mLock(PR_NewLock())\\n     , mInitialized(PR_FALSE)\\n@@ -89,9 +88,6 @@ nsSocketTransportService::~nsSocketTransportService()\\n     if (mLock)\\n         PR_DestroyLock(mLock);\\n     \\n-    if (mThreadEventLock)\\n-        PR_DestroyLock(mThreadEventLock);\\n-\\n     if (mThreadEvent)\\n         PR_DestroyPollableEvent(mThreadEvent);\\n \\n@@ -355,7 +351,7 @@ NS_IMPL_THREADSAFE_ISUPPORTS5(nsSocketTransportService,\\n NS_IMETHODIMP\\n nsSocketTransportService::Init()\\n {\\n-    NS_ENSURE_TRUE(mThreadEventLock && mLock, NS_ERROR_OUT_OF_MEMORY);\\n+    NS_ENSURE_TRUE(mLock, NS_ERROR_OUT_OF_MEMORY);\\n \\n     if (!NS_IsMainThread()) {\\n         NS_ERROR(\\\"wrong thread\\\");\\n@@ -413,11 +409,9 @@ nsSocketTransportService::Shutdown()\\n         // signal the socket thread to shutdown\\n         mShuttingDown = PR_TRUE;\\n \\n-        PR_Lock(mThreadEventLock);\\n         if (mThreadEvent)\\n             PR_SetPollableEvent(mThreadEvent);\\n         // else wait for Poll timeout\\n-        PR_Unlock(mThreadEventLock);\\n     }\\n \\n     // join with thread\\n@@ -473,10 +467,9 @@ nsSocketTransportService::SetAutodialEnabled(PRBool value)\\n NS_IMETHODIMP\\n nsSocketTransportService::OnDispatchedEvent(nsIThreadInternal *thread)\\n {\\n-    PR_Lock(mThreadEventLock);\\n+    nsAutoLock lock(mLock);\\n     if (mThreadEvent)\\n         PR_SetPollableEvent(mThreadEvent);\\n-    PR_Unlock(mThreadEventLock);\\n     return NS_OK;\\n }\\n \\n@@ -665,10 +658,11 @@ nsSocketTransportService::DoPollIteration(PRBool wait)\\n                 // wakes up from hibernation.  We try to create a\\n                 // new pollable event.  If that fails, we fall back\\n                 // on \\\"busy wait\\\".\\n-                PR_Lock(mThreadEventLock);\\n-                PR_DestroyPollableEvent(mThreadEvent);\\n-                mThreadEvent = PR_NewPollableEvent();\\n-                PR_Unlock(mThreadEventLock);\\n+                {\\n+                    nsAutoLock lock(mLock);\\n+                    PR_DestroyPollableEvent(mThreadEvent);\\n+                    mThreadEvent = PR_NewPollableEvent();\\n+                }\\n                 if (!mThreadEvent) {\\n                     NS_WARNING(\\\"running socket transport thread without \\\"\\n                                \\\"a pollable event\\\");\\ndiff --git a/netwerk/base/src/nsSocketTransportService2.h b/netwerk/base/src/nsSocketTransportService2.h\\nindex 59ebdac..2b5042e 100644\\n--- a/netwerk/base/src/nsSocketTransportService2.h\\n+++ b/netwerk/base/src/nsSocketTransportService2.h\\n@@ -180,15 +180,13 @@ private:\\n \\n     nsIThread  *mThread;\\n     PRFileDesc *mThreadEvent;\\n-    PRLock     *mThreadEventLock;\\n-                            // protects mThreadEvent, which may change\\n+                            // protected by mLock.  mThreadEvent may change\\n                             // if the old pollable event is broken.  only\\n-                            // one thread may change mThreadEvent; that\\n-                            // thread needs to lock mThreadEventLock only\\n-                            // when it changes mThreadEvent.  other threads\\n-                            // don't change mThreadEvent; they need to lock\\n-                            // mThreadEventLock whenever they access\\n-                            // mThreadEvent. \\n+                            // the socket thread may change mThreadEvent;\\n+                            // it needs to lock mLock only when it changes\\n+                            // mThreadEvent.  other threads don't change\\n+                            // mThreadEvent; they need to lock mLock\\n+                            // whenever they access mThreadEvent.\\n     PRBool      mAutodialEnabled;\\n                             // pref to control autodial code\\n \\n\""}