{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basffe2dbe\""},"diff":"\"ffe2dbe Fix window staggering and positioning to make sure new windows are never partly positioned offscreen and don't seeminly arbitrarily get larger by the size of the title bar. b=218214 r=mano r=cbarrett sr=roc a=roc\\ndiff --git a/browser/base/content/browser.js b/browser/base/content/browser.js\\nindex 607df72..a82b6aa 100644\\n--- a/browser/base/content/browser.js\\n+++ b/browser/base/content/browser.js\\n@@ -816,21 +816,14 @@ function BrowserStartup()\\n     else {\\n       // Create a narrower window for large or wide-aspect displays, to suggest\\n       // side-by-side page view.\\n-      if ((screen.availWidth / 2) >= 800)\\n+      if (screen.availWidth >= 1600)\\n         defaultWidth = (screen.availWidth / 2) - 20;\\n       defaultHeight = screen.availHeight - 10;\\n #ifdef MOZ_WIDGET_GTK2\\n-#define USE_HEIGHT_ADJUST\\n-#endif\\n-#ifdef USE_HEIGHT_ADJUST\\n       // On X, we're not currently able to account for the size of the window\\n       // border.  Use 28px as a guess (titlebar + bottom window border)\\n       defaultHeight -= 28;\\n #endif\\n-#ifdef XP_MACOSX\\n-      // account for the Mac OS X title bar\\n-      defaultHeight -= 22;\\n-#endif\\n     }\\n     document.documentElement.setAttribute(\\\"width\\\", defaultWidth);\\n     document.documentElement.setAttribute(\\\"height\\\", defaultHeight);\\ndiff --git a/widget/public/nsIWidget.h b/widget/public/nsIWidget.h\\nindex 82b4533..d43ffa9 100644\\n--- a/widget/public/nsIWidget.h\\n+++ b/widget/public/nsIWidget.h\\n@@ -558,7 +558,8 @@ class nsIWidget : public nsISupports {\\n      * Get this widget's outside dimensions in global coordinates. (One might think this\\n      * could be accomplished by stringing together other methods in this interface, but\\n      * then one would bloody one's nose on different coordinate system handling by different\\n-     * platforms.)\\n+     * platforms.) This includes any title bar on the window.\\n+     *\\n      *\\n      * @param aRect on return it holds the  x, y, width and height of this widget\\n      *\\ndiff --git a/widget/src/cocoa/nsCocoaWindow.mm b/widget/src/cocoa/nsCocoaWindow.mm\\nindex 2c29c62..94221ce 100644\\n--- a/widget/src/cocoa/nsCocoaWindow.mm\\n+++ b/widget/src/cocoa/nsCocoaWindow.mm\\n@@ -65,6 +65,12 @@ extern BOOL                gSomeMenuBarPainted;\\n NS_IMPL_ISUPPORTS_INHERITED1(nsCocoaWindow, Inherited, nsPIWidgetCocoa)\\n \\n \\n+// A note on testing to see if your object is a sheet...\\n+// |mWindowType == eWindowType_sheet| is true if your gecko nsIWidget is a sheet\\n+// widget - whether or not the sheet is showing. |[mWindow isSheet]| will return\\n+// true *only when the sheet is actually showing*. Choose your test wisely.\\n+\\n+\\n // returns the height of the title bar for a given cocoa NSWindow\\n static float TitleBarHeightForWindow(NSWindow* aWindow)\\n {\\n@@ -752,21 +758,10 @@ NS_IMETHODIMP nsCocoaWindow::Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRep\\n     // width is easy, no adjusting necessary\\n     newFrame.size.width = aWidth;\\n \\n-    // Adjusting the height is harder.\\n-    // Note that [mWindow isSheet] is not the same as checking for\\n-    // |mWindowType == eWindowType_sheet|. If this is a sheet object, the latter\\n-    // will always be true. The former is true only when the sheet is being shown.\\n-    // Here we need to know if the sheet is actually being shown because if it is,\\n-    // the content view and the window's frame are equal, despite the fact that\\n-    // the native window object has the title bar flag set. If the window is not\\n-    // being shown as a sheet the content area and window frame differ.\\n-    float newHeight = (float)aHeight;\\n-    if (mWindowType != eWindowType_popup && ![mWindow isSheet])\\n-      newHeight += TitleBarHeightForWindow(mWindow); // add height of title bar\\n-    // Now we need to adjust for the fact that gecko wants the top of the window\\n+    // We need to adjust for the fact that gecko wants the top of the window\\n     // to remain in the same place.\\n-    newFrame.origin.y += newFrame.size.height - newHeight;\\n-    newFrame.size.height = newHeight;\\n+    newFrame.origin.y += newFrame.size.height - aHeight;\\n+    newFrame.size.height = aHeight;\\n \\n     StartResizing();\\n     [mWindow setFrame:newFrame display:NO];\\n@@ -785,16 +780,13 @@ NS_IMETHODIMP nsCocoaWindow::Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRep\\n }\\n \\n \\n-// We return the origin for the entire window (title bar and all) but\\n-// the size of the content area. I have no idea why it was originally done\\n-// this way, but it matches Carbon and makes things work nicely.\\n NS_IMETHODIMP nsCocoaWindow::GetScreenBounds(nsRect &aRect)\\n {\\n   nsRect windowFrame = cocoaRectToGeckoRect([mWindow frame]);\\n   aRect.x = windowFrame.x;\\n   aRect.y = windowFrame.y;\\n-  aRect.width = mBounds.width;\\n-  aRect.height = mBounds.height;\\n+  aRect.width = windowFrame.width;\\n+  aRect.height = windowFrame.height;\\n   // printf(\\\"GetScreenBounds: output: %d,%d,%d,%d\\\\n\\\", aRect.x, aRect.y, aRect.width, aRect.height);\\n   return NS_OK;\\n }\\ndiff --git a/xpfe/appshell/src/nsXULWindow.cpp b/xpfe/appshell/src/nsXULWindow.cpp\\nindex b50206d..35afa93 100644\\n--- a/xpfe/appshell/src/nsXULWindow.cpp\\n+++ b/xpfe/appshell/src/nsXULWindow.cpp\\n@@ -1062,8 +1062,10 @@ PRBool nsXULWindow::LoadPositionFromXUL()\\n         specX += parentX;\\n         specY += parentY;\\n       }\\n-    } else\\n+    }\\n+    else {\\n       StaggerPosition(specX, specY, currWidth, currHeight);\\n+    }\\n   }\\n   mWindow->ConstrainPosition(PR_FALSE, &specX, &specY);\\n   if (specX != currX || specY != currY)\\n@@ -1256,8 +1258,7 @@ void nsXULWindow::StaggerPosition(PRInt32 &aRequestedX, PRInt32 &aRequestedY,\\n     }\\n   }\\n \\n-  // one full pass through all windows of this type. repeat until\\n-  // no collisions.\\n+  // One full pass through all windows of this type, repeat until no collisions.\\n   do {\\n     keepTrying = PR_FALSE;\\n     nsCOMPtr<nsISimpleEnumerator> windowList;\\n@@ -1266,11 +1267,9 @@ void nsXULWindow::StaggerPosition(PRInt32 &aRequestedX, PRInt32 &aRequestedY,\\n     if (!windowList)\\n       break;\\n \\n-    // one full pass through all windows of this type. offset and stop\\n-    // on collision.\\n+    // One full pass through all windows of this type, offset and stop on collision.\\n     do {\\n       PRBool more;\\n-      PRInt32 listX, listY;\\n       windowList->HasMoreElements(&more);\\n       if (!more)\\n         break;\\n@@ -1279,13 +1278,13 @@ void nsXULWindow::StaggerPosition(PRInt32 &aRequestedX, PRInt32 &aRequestedY,\\n       windowList->GetNext(getter_AddRefs(supportsWindow));\\n \\n       nsCOMPtr<nsIXULWindow> listXULWindow(do_QueryInterface(supportsWindow));\\n-      nsCOMPtr<nsIBaseWindow> listBaseWindow(do_QueryInterface(supportsWindow));\\n-\\n       if (listXULWindow != ourXULWindow) {\\n+        PRInt32 listX, listY;\\n+        nsCOMPtr<nsIBaseWindow> listBaseWindow(do_QueryInterface(supportsWindow));\\n         listBaseWindow->GetPosition(&listX, &listY);\\n \\n-        if (PR_ABS(listX-aRequestedX) <= kSlop &&\\n-            PR_ABS(listY-aRequestedY) <= kSlop) {\\n+        if (PR_ABS(listX - aRequestedX) <= kSlop &&\\n+            PR_ABS(listY - aRequestedY) <= kSlop) {\\n           // collision! offset and start over\\n           if (bouncedX & 0x1)\\n             aRequestedX -= kOffset;\\n@@ -1294,16 +1293,19 @@ void nsXULWindow::StaggerPosition(PRInt32 &aRequestedX, PRInt32 &aRequestedY,\\n           aRequestedY += kOffset;\\n \\n           if (gotScreen) {\\n-            // bounce off left and right edges\\n-            if (!(bouncedX & 0x1) && aRequestedX + aSpecWidth > screenRight) {\\n+            // if we're moving to the right and we need to bounce...\\n+            if (!(bouncedX & 0x1) && ((aRequestedX + aSpecWidth) > screenRight)) {\\n               aRequestedX = screenRight - aSpecWidth;\\n               ++bouncedX;\\n             }\\n+\\n+            // if we're moving to the left and we need to bounce...\\n             if ((bouncedX & 0x1) && aRequestedX < screenLeft) {\\n               aRequestedX = screenLeft;\\n               ++bouncedX;\\n             }\\n-            // hit the bottom and start again at the top\\n+\\n+            // if we hit the bottom then bounce to the top\\n             if (aRequestedY + aSpecHeight > screenBottom) {\\n               aRequestedY = screenTop;\\n               ++bouncedY;\\n\""}