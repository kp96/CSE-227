{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basd3cc973\""},"diff":"\"d3cc973 Bug 393361 - CVS remove orphaned tabbrowser bits. r=mconnor as part of bug 339964\\ndiff --git a/toolkit/content/widgets/tabbrowser.xml b/toolkit/content/widgets/tabbrowser.xml\\ndeleted file mode 100644\\nindex 706bf35..0000000\\n--- a/toolkit/content/widgets/tabbrowser.xml\\n+++ /dev/null\\n@@ -1,3198 +0,0 @@\\n-<?xml version=\\\"1.0\\\"?>\\n-\\n-<!-- ***** BEGIN LICENSE BLOCK *****\\n-   - Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n-   -\\n-   - The contents of this file are subject to the Mozilla Public License Version\\n-   - 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n-   - the License. You may obtain a copy of the License at\\n-   - http://www.mozilla.org/MPL/\\n-   -\\n-   - Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n-   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n-   - for the specific language governing rights and limitations under the\\n-   - License.\\n-   -\\n-   - The Original Code is this file as it was released on March 28, 2001.\\n-   -\\n-   - The Initial Developer of the Original Code is\\n-   - David Hyatt.\\n-   - Portions created by the Initial Developer are Copyright (C) 2001\\n-   - the Initial Developer. All Rights Reserved.\\n-   -\\n-   - Contributor(s):\\n-   -   David Hyatt <hyatt@netscape.com> (Original Author of <tabbrowser>)\\n-   -   Mike Connor <mconnor@steelgryphon.com>\\n-   -   Peter Parente <parente@cs.unc.edu>\\n-   -   Giorgio Maone <g.maone@informaction.com>\\n-   -   Asaf Romano <mozilla.mano@sent.com>\\n-   -   Seth Spitzer <sspitzer@mozilla.org>\\n-   -   Simon BÃ¼nzli <zeniko@gmail.com>\\n-   -   Michael Ventnor <ventnor.bugzilla@yahoo.com.au>\\n-   -   Mark Pilgrim <pilgrim@gmail.com>\\n-   -\\n-   - Alternatively, the contents of this file may be used under the terms of\\n-   - either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n-   - the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n-   - in which case the provisions of the GPL or the LGPL are applicable instead\\n-   - of those above. If you wish to allow use of your version of this file only\\n-   - under the terms of either the GPL or the LGPL, and not to allow others to\\n-   - use your version of this file under the terms of the MPL, indicate your\\n-   - decision by deleting the provisions above and replace them with the notice\\n-   - and other provisions required by the GPL or the LGPL. If you do not delete\\n-   - the provisions above, a recipient may use your version of this file under\\n-   - the terms of any one of the MPL, the GPL or the LGPL.\\n-   -\\n-   - ***** END LICENSE BLOCK ***** -->\\n-\\n-<!DOCTYPE bindings [\\n-<!ENTITY % tabBrowserDTD SYSTEM \\\"chrome://global/locale/tabbrowser.dtd\\\" >\\n-%tabBrowserDTD;\\n-<!ENTITY % globalDTD SYSTEM \\\"chrome://global/locale/global.dtd\\\">\\n-%globalDTD;\\n-]>\\n-\\n-<bindings id=\\\"tabBrowserBindings\\\"\\n-          xmlns=\\\"http://www.mozilla.org/xbl\\\"\\n-          xmlns:xul=\\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\"\\n-          xmlns:xbl=\\\"http://www.mozilla.org/xbl\\\">\\n-\\n-  <binding id=\\\"tabbrowser\\\">\\n-    <resources>\\n-      <stylesheet src=\\\"chrome://global/skin/browser.css\\\"/>\\n-    </resources>\\n-\\n-    <content>\\n-      <xul:stringbundle anonid=\\\"tbstringbundle\\\" src=\\\"chrome://global/locale/tabbrowser.properties\\\"/>\\n-      <xul:tabbox anonid=\\\"tabbox\\\" flex=\\\"1\\\" eventnode=\\\"document\\\" xbl:inherits=\\\"handleCtrlPageUpDown\\\"\\n-                  onselect=\\\"if (!('updateCurrentBrowser' in this.parentNode) || event.target.localName != 'tabpanels') return; this.parentNode.updateCurrentBrowser();\\\">\\n-        <xul:hbox class=\\\"tab-drop-indicator-bar\\\">\\n-          <xul:hbox class=\\\"tab-drop-indicator\\\" mousethrough=\\\"always\\\"/>\\n-        </xul:hbox>\\n-        <xul:hbox class=\\\"tabbrowser-strip\\\" collapsed=\\\"true\\\" tooltip=\\\"_child\\\" context=\\\"_child\\\"\\n-                  anonid=\\\"strip\\\"\\n-                  ondraggesture=\\\"nsDragAndDrop.startDrag(event, this.parentNode.parentNode); event.stopPropagation();\\\"\\n-                  ondragover=\\\"nsDragAndDrop.dragOver(event, this.parentNode.parentNode); event.stopPropagation();\\\"\\n-                  ondragdrop=\\\"nsDragAndDrop.drop(event, this.parentNode.parentNode); event.stopPropagation();\\\"\\n-                  ondragexit=\\\"nsDragAndDrop.dragExit(event, this.parentNode.parentNode); event.stopPropagation();\\\">\\n-          <xul:tooltip onpopupshowing=\\\"return this.parentNode.parentNode.parentNode.createTooltip(event);\\\"/>\\n-          <xul:menupopup anonid=\\\"tabContextMenu\\\" onpopupshowing=\\\"this.parentNode.parentNode.parentNode.updatePopupMenu(this);\\\">\\n-            <xul:menuitem label=\\\"&newTab.label;\\\" accesskey=\\\"&newTab.accesskey;\\\"\\n-                          xbl:inherits=\\\"oncommand=onnewtab\\\"/>\\n-            <xul:menuseparator/>\\n-            <xul:menuitem label=\\\"&reloadTab.label;\\\" accesskey=\\\"&reloadTab.accesskey;\\\"\\n-                          oncommand=\\\"var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;\\n-                                     tabbrowser.reloadTab(tabbrowser.mContextTab);\\\"/>\\n-            <xul:menuitem label=\\\"&reloadAllTabs.label;\\\" accesskey=\\\"&reloadAllTabs.accesskey;\\\"\\n-                          tbattr=\\\"tabbrowser-multiple\\\"\\n-                          oncommand=\\\"var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;\\n-                                     tabbrowser.reloadAllTabs(tabbrowser.mContextTab);\\\"/>\\n-            <xul:menuitem label=\\\"&closeOtherTabs.label;\\\" accesskey=\\\"&closeOtherTabs.accesskey;\\\"\\n-                          tbattr=\\\"tabbrowser-multiple\\\"\\n-                          oncommand=\\\"var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;\\n-                                     tabbrowser.removeAllTabsBut(tabbrowser.mContextTab);\\\"/>\\n-            <xul:menuseparator/>\\n-            <xul:menuitem label=\\\"&closeTab.label;\\\" accesskey=\\\"&closeTab.accesskey;\\\"\\n-                          oncommand=\\\"var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;\\n-                                     tabbrowser.removeTab(tabbrowser.mContextTab);\\\"/>\\n-          </xul:menupopup>\\n-\\n-          <xul:tabs class=\\\"tabbrowser-tabs\\\" flex=\\\"1\\\"\\n-                    anonid=\\\"tabcontainer\\\"\\n-                    setfocus=\\\"false\\\"\\n-                    onclick=\\\"this.parentNode.parentNode.parentNode.onTabClick(event);\\\"\\n-                    xbl:inherits=\\\"onnewtab\\\"\\n-                    ondblclick=\\\"this.parentNode.parentNode.parentNode.onTabBarDblClick(event);\\\"\\n-                    onclosetab=\\\"var node = this.parentNode;\\n-                                while (node.localName != 'tabbrowser')\\n-                                  node = node.parentNode;\\n-                                node.removeCurrentTab();\\\">\\n-            <xul:tab selected=\\\"true\\\" validate=\\\"never\\\"\\n-                     onerror=\\\"this.parentNode.parentNode.parentNode.parentNode.addToMissedIconCache(this.getAttribute('image'));\\n-                              this.removeAttribute('image');\\\"\\n-                     maxwidth=\\\"250\\\" width=\\\"0\\\" minwidth=\\\"100\\\" flex=\\\"100\\\"\\n-                     class=\\\"tabbrowser-tab\\\" label=\\\"&untitledTab;\\\" crop=\\\"end\\\"/>\\n-          </xul:tabs>\\n-        </xul:hbox>\\n-        <xul:tabpanels flex=\\\"1\\\" class=\\\"plain\\\" selectedIndex=\\\"0\\\" anonid=\\\"panelcontainer\\\">\\n-          <xul:notificationbox flex=\\\"1\\\">\\n-            <xul:browser flex=\\\"1\\\" type=\\\"content-primary\\\" message=\\\"true\\\" disablehistory=\\\"true\\\"\\n-                         xbl:inherits=\\\"tooltip=contenttooltip,contextmenu=contentcontextmenu,autocompletepopup\\\"/>\\n-          </xul:notificationbox>\\n-        </xul:tabpanels>\\n-      </xul:tabbox>\\n-      <children/>\\n-    </content>\\n-    <implementation>\\n-      <field name=\\\"mPrefs\\\" readonly=\\\"true\\\">\\n-        Components.classes['@mozilla.org/preferences-service;1']\\n-                  .getService(Components.interfaces.nsIPrefService)\\n-                  .getBranch(null);\\n-      </field>\\n-      <field name=\\\"mURIFixup\\\" readonly=\\\"true\\\">\\n-        Components.classes[\\\"@mozilla.org/docshell/urifixup;1\\\"]\\n-                  .getService(Components.interfaces.nsIURIFixup);\\n-      </field>\\n-      <field name=\\\"mTabBox\\\" readonly=\\\"true\\\">\\n-        document.getAnonymousElementByAttribute(this, \\\"anonid\\\", \\\"tabbox\\\");\\n-      </field>\\n-      <field name=\\\"mTabDropIndicatorBar\\\">\\n-        this.mTabBox.childNodes[0]\\n-      </field>\\n-      <field name=\\\"mStrip\\\" readonly=\\\"true\\\">\\n-        document.getAnonymousElementByAttribute(this, \\\"anonid\\\", \\\"strip\\\");\\n-      </field>\\n-      <field name=\\\"mTabContainer\\\" readonly=\\\"true\\\">\\n-        document.getAnonymousElementByAttribute(this, \\\"anonid\\\", \\\"tabcontainer\\\");\\n-      </field>\\n-      <field name=\\\"mPanelContainer\\\" readonly=\\\"true\\\">\\n-        document.getAnonymousElementByAttribute(this, \\\"anonid\\\", \\\"panelcontainer\\\");\\n-      </field>\\n-      <field name=\\\"mTabs\\\" readonly=\\\"true\\\">\\n-        this.mTabContainer.childNodes\\n-      </field>\\n-      <field name=\\\"mStringBundle\\\">\\n-        document.getAnonymousElementByAttribute(this, \\\"anonid\\\", \\\"tbstringbundle\\\");\\n-      </field>\\n-      <field name=\\\"mCurrentTab\\\">\\n-        null\\n-      </field>\\n-      <field name=\\\"mCurrentBrowser\\\">\\n-        null\\n-      </field>\\n-      <field name=\\\"mProgressListeners\\\">\\n-        []\\n-      </field>\\n-      <field name=\\\"mTabListeners\\\">\\n-        new Array()\\n-      </field>\\n-      <field name=\\\"mTabFilters\\\">\\n-        new Array()\\n-      </field>\\n-      <field name=\\\"mTabbedMode\\\">\\n-        false\\n-      </field>\\n-      <field name=\\\"mIsBusy\\\">\\n-        false\\n-      </field>\\n-      <field name=\\\"mMissedIconCache\\\">\\n-        null\\n-      </field>\\n-      <field name=\\\"mContextTab\\\">\\n-        null\\n-      </field>\\n-      <field name=\\\"arrowKeysShouldWrap\\\" readonly=\\\"true\\\">\\n-#ifdef XP_MACOSX\\n-        true\\n-#else\\n-        false\\n-#endif\\n-      </field>\\n-      <field name=\\\"mAddProgressListenerWasCalled\\\">\\n-        false\\n-      </field>\\n-      <field name=\\\"_browsers\\\">\\n-        null\\n-      </field>\\n-\\n-      <field name=\\\"_blockDblClick\\\">\\n-        false\\n-      </field>\\n-      <field name=\\\"_autoScrollPopup\\\">\\n-        null\\n-      </field>\\n-\\n-      <method name=\\\"getBrowserAtIndex\\\">\\n-        <parameter name=\\\"aIndex\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            return this.mTabContainer.childNodes[aIndex].linkedBrowser;\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"getBrowserIndexForDocument\\\">\\n-        <parameter name=\\\"aDocument\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            for (var i = 0; i < this.mPanelContainer.childNodes.length; i++) {\\n-              if (this.getBrowserAtIndex(i).contentDocument == aDocument) {\\n-                return i;\\n-              }\\n-            }\\n-            return -1;\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"getBrowserForDocument\\\">\\n-        <parameter name=\\\"aDocument\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            var index = this.getBrowserIndexForDocument(aDocument);\\n-            if (index < 0)\\n-              return null;\\n-            return this.getBrowserAtIndex(index);\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"getNotificationBox\\\">\\n-        <parameter name=\\\"aBrowser\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            if (aBrowser)\\n-              return aBrowser.parentNode;\\n-            else if (this.mCurrentBrowser)\\n-              return this.mCurrentBrowser.parentNode;\\n-            return null;\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <!-- A web progress listener object definition for a given tab. -->\\n-      <method name=\\\"mTabProgressListener\\\">\\n-        <parameter name=\\\"aTab\\\"/>\\n-        <parameter name=\\\"aBrowser\\\"/>\\n-        <parameter name=\\\"aStartsBlank\\\"/>\\n-        <body>\\n-        <![CDATA[\\n-          return ({\\n-            mTabBrowser: this,\\n-            mTab: aTab,\\n-            mBrowser: aBrowser,\\n-            mBlank: aStartsBlank,\\n-            mLastURI: null,\\n-\\n-            // cache flags for correct status bar update after tab switching\\n-            mStateFlags: 0,\\n-            mStatus: 0,\\n-            mMessage: \\\"\\\",\\n-            mTotalProgress: 0,\\n-\\n-            // count of open requests (should always be 0 or 1)\\n-            mRequestCount: 0,\\n-\\n-            onProgressChange : function (aWebProgress, aRequest,\\n-                                         aCurSelfProgress, aMaxSelfProgress,\\n-                                         aCurTotalProgress, aMaxTotalProgress)\\n-            {\\n-              if (!this.mBlank && this.mTabBrowser.mCurrentTab == this.mTab) {\\n-                for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {\\n-                  var p = this.mTabBrowser.mProgressListeners[i];\\n-                  if (p)\\n-                    p.onProgressChange(aWebProgress, aRequest,\\n-                                       aCurSelfProgress, aMaxSelfProgress,\\n-                                       aCurTotalProgress, aMaxTotalProgress);\\n-                }\\n-              }\\n-\\n-              this.mTotalProgress = aMaxTotalProgress ? aCurTotalProgress / aMaxTotalProgress : 0;\\n-            },\\n-\\n-            onProgressChange64 : function (aWebProgress, aRequest,\\n-                                         aCurSelfProgress, aMaxSelfProgress,\\n-                                         aCurTotalProgress, aMaxTotalProgress)\\n-            {\\n-              return this.onProgressChange(aWebProgress, aRequest,\\n-                aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress,\\n-                aMaxTotalProgress);\\n-            },\\n-\\n-            onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)\\n-            {\\n-              if (!aRequest)\\n-                return;\\n-\\n-              var oldBlank = this.mBlank;\\n-\\n-              const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;\\n-              const nsIChannel = Components.interfaces.nsIChannel;\\n-\\n-              if (aStateFlags & nsIWebProgressListener.STATE_START) {\\n-                this.mRequestCount++;\\n-              }\\n-              else if (aStateFlags & nsIWebProgressListener.STATE_STOP) {\\n-                const NS_ERROR_UNKNOWN_HOST = 2152398878;\\n-                if (--this.mRequestCount > 0 && aStatus == NS_ERROR_UNKNOWN_HOST) {\\n-                  // to prevent bug 235825: wait for the request handled\\n-                  // by the automatic keyword resolver\\n-                  return;\\n-                }\\n-                // since we (try to) only handle STATE_STOP of the last request,\\n-                // the count of open requests should now be 0\\n-                this.mRequestCount = 0;\\n-              }\\n-\\n-              if (aStateFlags & nsIWebProgressListener.STATE_START &&\\n-                  aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {\\n-                // It's okay to clear what the user typed when we start\\n-                // loading a document. If the user types, this counter gets\\n-                // set to zero, if the document load ends without an\\n-                // onLocationChange, this counter gets decremented\\n-                // (so we keep it while switching tabs after failed loads)\\n-                if (aWebProgress.DOMWindow == this.mBrowser.contentWindow)\\n-                  this.mBrowser.userTypedClear++;\\n-\\n-                if (!this.mBlank) {\\n-                  this.mTab.setAttribute(\\\"busy\\\", \\\"true\\\");\\n-                  this.mTabBrowser.updateIcon(this.mTab);\\n-                  this.mTabBrowser.setTabTitleLoading(this.mTab);\\n-\\n-                  if (this.mTabBrowser.mCurrentTab == this.mTab)\\n-                    this.mTabBrowser.mIsBusy = true;\\n-                }\\n-              }\\n-              else if (aStateFlags & nsIWebProgressListener.STATE_STOP &&\\n-                       aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {\\n-                if (aWebProgress.DOMWindow == this.mBrowser.contentWindow) {\\n-                  // The document is done loading, we no longer want the\\n-                  // value cleared.\\n-                  if (this.mBrowser.userTypedClear > 0)\\n-                    this.mBrowser.userTypedClear--;\\n-\\n-                  if (!this.mBrowser.mIconURL)\\n-                    this.mTabBrowser.useDefaultIcon(this.mTab);\\n-                }\\n-\\n-                if (this.mBlank)\\n-                  this.mBlank = false;\\n-\\n-                this.mTab.removeAttribute(\\\"busy\\\");\\n-                this.mTabBrowser.updateIcon(this.mTab);\\n-\\n-                var location = aRequest.QueryInterface(nsIChannel).URI;\\n-\\n-                // For keyword URIs clear the user typed value since they will be changed into real URIs\\n-                if (location.scheme == \\\"keyword\\\")\\n-                  this.mBrowser.userTypedValue = null;\\n-\\n-                if (this.mTab.label == this.mTabBrowser.mStringBundle.getString(\\\"tabs.loading\\\"))\\n-                  this.mTabBrowser.setTabTitle(this.mTab);\\n-\\n-                if (this.mTabBrowser.mCurrentTab == this.mTab)\\n-                  this.mTabBrowser.mIsBusy = false;\\n-              }\\n-\\n-              if (this.mTabBrowser.mCurrentTab == this.mTab) {\\n-                for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {\\n-                  var p = this.mTabBrowser.mProgressListeners[i];\\n-                  if (p && !oldBlank)\\n-                    p.onStateChange(aWebProgress, aRequest, aStateFlags, aStatus);\\n-                  // make sure that the visible status of new blank tabs is correctly set\\n-                  else if (p && \\\"onUpdateCurrentBrowser\\\" in p)\\n-                    p.onUpdateCurrentBrowser(aStateFlags, aStatus, \\\"\\\", 0);\\n-                }\\n-              }\\n-\\n-              if (aStateFlags & (nsIWebProgressListener.STATE_START |\\n-                                 nsIWebProgressListener.STATE_STOP)) {\\n-                // reset cached temporary values at beginning and end\\n-                this.mMessage = \\\"\\\";\\n-                this.mTotalProgress = 0;\\n-              }\\n-              this.mStateFlags = aStateFlags;\\n-              this.mStatus = aStatus;\\n-            },\\n-\\n-            onLocationChange : function(aWebProgress, aRequest, aLocation)\\n-            {\\n-              // The document loaded correctly, clear the value if we should\\n-              if (this.mBrowser.userTypedClear > 0 && aRequest)\\n-                this.mBrowser.userTypedValue = null;\\n-\\n-              if (aWebProgress.DOMWindow == this.mBrowser.contentWindow &&\\n-                  aWebProgress.isLoadingDocument)\\n-                this.mTabBrowser.setIcon(this.mTab, null);\\n-\\n-              // changing location, clear out the missing plugins list\\n-              this.mTab.missingPlugins = null;\\n-\\n-              if (!this.mBlank && this.mTabBrowser.mCurrentTab == this.mTab) {\\n-                for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {\\n-                  var p = this.mTabBrowser.mProgressListeners[i];\\n-                  if (p)\\n-                    p.onLocationChange(aWebProgress, aRequest, aLocation);\\n-                }\\n-              }\\n-            },\\n-\\n-            onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)\\n-            {\\n-              if (this.mBlank)\\n-                return;\\n-\\n-              if (this.mTabBrowser.mCurrentTab == this.mTab) {\\n-                for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {\\n-                  var p = this.mTabBrowser.mProgressListeners[i];\\n-                  if (p)\\n-                    p.onStatusChange(aWebProgress, aRequest, aStatus, aMessage);\\n-                }\\n-              }\\n-\\n-              this.mMessage = aMessage;\\n-            },\\n-\\n-            onSecurityChange : function(aWebProgress, aRequest, aState)\\n-            {\\n-              if (this.mTabBrowser.mCurrentTab == this.mTab) {\\n-                for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {\\n-                  var p = this.mTabBrowser.mProgressListeners[i];\\n-                  if (p)\\n-                    p.onSecurityChange(aWebProgress, aRequest, aState);\\n-                }\\n-              }\\n-            },\\n-\\n-             onRefreshAttempted : function(aWebProgress, aURI, aDelay, aSameURI)\\n-             {\\n-               var allowRefresh = true;\\n-               for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {\\n-                 var p = this.mTabBrowser.mProgressListeners[i];\\n-                 if (p && \\\"onRefreshAttempted\\\" in p) {\\n-                   if (!p.onRefreshAttempted(aWebProgress, aURI, aDelay, aSameURI))\\n-                     allowRefresh = false;\\n-                 }\\n-               }\\n-               return allowRefresh;\\n-             },\\n- \\n-            QueryInterface : function(aIID)\\n-            {\\n-              if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||\\n-                  aIID.equals(Components.interfaces.nsIWebProgressListener2) ||\\n-                  aIID.equals(Components.interfaces.nsISupportsWeakReference) ||\\n-                  aIID.equals(Components.interfaces.nsISupports))\\n-                return this;\\n-              throw Components.results.NS_NOINTERFACE;\\n-            }\\n-          });\\n-        ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"setIcon\\\">\\n-        <parameter name=\\\"aTab\\\"/>\\n-        <parameter name=\\\"aURI\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            var browser = this.getBrowserForTab(aTab);\\n-            browser.mIconURL = aURI;\\n-\\n-            this.updateIcon(aTab);\\n-\\n-            for (var i = 0; i < this.mProgressListeners.length; i++) {\\n-              var p = this.mProgressListeners[i];\\n-              if ('onLinkIconAvailable' in p)\\n-                p.onLinkIconAvailable(browser);\\n-            }\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"updateIcon\\\">\\n-        <parameter name=\\\"aTab\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            var browser = this.getBrowserForTab(aTab);\\n-            if (!aTab.hasAttribute(\\\"busy\\\") && browser.mIconURL)\\n-              aTab.setAttribute(\\\"image\\\", browser.mIconURL);\\n-            else\\n-              aTab.removeAttribute(\\\"image\\\");\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"shouldLoadFavIcon\\\">\\n-        <parameter name=\\\"aURI\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            return (aURI && this.mPrefs.getBoolPref(\\\"browser.chrome.site_icons\\\") &&\\n-                    this.mPrefs.getBoolPref(\\\"browser.chrome.favicons\\\") &&\\n-                    (\\\"schemeIs\\\" in aURI) && (aURI.schemeIs(\\\"http\\\") || aURI.schemeIs(\\\"https\\\")));\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"useDefaultIcon\\\">\\n-        <parameter name=\\\"aTab\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            var browser = this.getBrowserForTab(aTab);\\n-            if (browser.contentDocument instanceof ImageDocument) {\\n-              if (this.mPrefs.getBoolPref(\\\"browser.chrome.site_icons\\\")) {\\n-                try {\\n-                  var sz = this.mPrefs.getIntPref(\\\"browser.chrome.image_icons.max_size\\\");\\n-                  if (!sz)\\n-                    return;\\n-\\n-                  var req = browser.contentDocument.imageRequest;\\n-                  if (!req || !req.image ||\\n-                      req.image.width > sz ||\\n-                      req.image.height > sz)\\n-                    return;\\n-\\n-                  this.setIcon(aTab, browser.currentURI.spec);\\n-                } catch (e) { }\\n-              }\\n-            }\\n-            else if (this.shouldLoadFavIcon(browser.currentURI)) {\\n-              var url = browser.currentURI.prePath + \\\"/favicon.ico\\\";\\n-              if (!this.isIconKnownMissing(url))\\n-                this.setIcon(aTab, url);\\n-            }\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"addToMissedIconCache\\\">\\n-        <parameter name=\\\"aURI\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            var entry = this.openCacheEntry(aURI, Components.interfaces.nsICache.ACCESS_READ_WRITE);\\n-            if (!entry)\\n-              return;\\n-\\n-            if (entry.accessGranted == Components.interfaces.nsICache.ACCESS_WRITE)\\n-              // It's a new entry.  Just write a bit of metadata in to the entry.\\n-              entry.setMetaDataElement(\\\"Icon\\\", \\\"Missed\\\");\\n-            entry.markValid();\\n-            entry.close();\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"openCacheEntry\\\">\\n-        <parameter name=\\\"key\\\"/>\\n-        <parameter name=\\\"access\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            try {\\n-              if (!this.mMissedIconCache) {\\n-                var cacheService = Components.classes['@mozilla.org/network/cache-service;1'].getService(Components.interfaces.nsICacheService);\\n-                this.mMissedIconCache = cacheService.createSession(\\\"MissedIconCache\\\", Components.interfaces.nsICache.STORE_ANYWHERE, true);\\n-                if (!this.mMissedIconCache)\\n-                  return null;\\n-              }\\n-              return this.mMissedIconCache.openCacheEntry(key, access, true);\\n-            }\\n-            catch (e) {\\n-              return null;\\n-            }\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"isIconKnownMissing\\\">\\n-        <parameter name=\\\"key\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            var e = this.openCacheEntry(key, Components.interfaces.nsICache.ACCESS_READ);\\n-            if (e) {\\n-                e.close();\\n-                return true;\\n-            }\\n-            return false;\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"updateTitlebar\\\">\\n-        <body>\\n-          <![CDATA[\\n-            var newTitle = \\\"\\\";\\n-            var docTitle;\\n-            var docElement = this.ownerDocument.documentElement;\\n-            var sep = docElement.getAttribute(\\\"titlemenuseparator\\\");\\n-\\n-            if (this.docShell.contentViewer)\\n-              docTitle = this.contentTitle;\\n-\\n-            if (!docTitle)\\n-              docTitle = docElement.getAttribute(\\\"titledefault\\\");\\n-\\n-            var modifier = docElement.getAttribute(\\\"titlemodifier\\\");\\n-            if (docTitle) {\\n-              newTitle += docElement.getAttribute(\\\"titlepreface\\\");\\n-              newTitle += docTitle;\\n-              if (modifier)\\n-                newTitle += sep;\\n-            }\\n-            newTitle += modifier;\\n-\\n-            // If location bar is hidden and the URL type supports a host,\\n-            // add the scheme and host to the title to prevent spoofing.\\n-            // XXX https://bugzilla.mozilla.org/show_bug.cgi?id=22183#c239\\n-            try {\\n-              if (docElement.getAttribute(\\\"chromehidden\\\").indexOf(\\\"location\\\") != -1) {\\n-                var uri = this.mURIFixup.createExposableURI(\\n-                            this.mCurrentBrowser.currentURI);\\n-                if (uri.scheme == \\\"about\\\")\\n-                  newTitle = uri.spec + sep + newTitle;\\n-                else\\n-                  newTitle = uri.prePath + sep + newTitle;\\n-              }\\n-            } catch (e) {}\\n-\\n-            this.ownerDocument.title = newTitle;\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"updatePopupMenu\\\">\\n-        <parameter name=\\\"aPopupMenu\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            this.mContextTab = document.popupNode;\\n-            var disabled = this.mPanelContainer.childNodes.length == 1;\\n-            var menuItems = aPopupMenu.getElementsByAttribute(\\\"tbattr\\\", \\\"tabbrowser-multiple\\\");\\n-            for (var i = 0; i < menuItems.length; i++)\\n-              menuItems[i].disabled = disabled;\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"updateCurrentBrowser\\\">\\n-        <body>\\n-          <![CDATA[\\n-            var newBrowser = this.getBrowserAtIndex(this.mTabContainer.selectedIndex);\\n-            if (this.mCurrentBrowser == newBrowser)\\n-              return;\\n-\\n-            if (this.mCurrentBrowser) {\\n-              // Only save the focused element if it is in our content window\\n-              // or in an ancestor window.\\n-              var focusedWindow = document.commandDispatcher.focusedWindow;\\n-              var saveFocus = false;\\n-\\n-              if (focusedWindow && focusedWindow.top == window.content) {\\n-                saveFocus = true;\\n-              } else {\\n-                var contentWindow = window;\\n-\\n-                while (contentWindow) {\\n-                  if (contentWindow == focusedWindow) {\\n-                    saveFocus = true;\\n-                    break;\\n-                  }\\n-\\n-                  if (contentWindow.parent == contentWindow) {\\n-                    break;\\n-                  }\\n-\\n-                  contentWindow = contentWindow.parent;\\n-                }\\n-              }\\n-\\n-              if (saveFocus) {\\n-                // Preserve the currently-focused element or DOM window for\\n-                // this tab.\\n-\\n-                this.mCurrentBrowser.focusedWindow = focusedWindow;\\n-                this.mCurrentBrowser.focusedElement = document.commandDispatcher.focusedElement;\\n-              }\\n-\\n-              if (this.mCurrentBrowser.focusedElement &&\\n-                  this.mCurrentBrowser.focusedElement.parentNode !=\\n-                  this.mCurrentTab.parentNode) {\\n-                // Clear focus outline before we draw on top of it.\\n-                // Only blur the focused element if it isn't a tab, \\n-                // to avoid breaking keyboard tab navigation\\n-                var elem = this.mCurrentBrowser.focusedElement;\\n-                if (elem instanceof HTMLElement || elem instanceof XULElement) {\\n-                  elem.blur();\\n-                }\\n-                else {\\n-                  var content = elem.ownerDocument.defaultView;\\n-                  if (content instanceof Components.interfaces.nsIInterfaceRequestor)\\n-                    content.getInterface(Components.interfaces.nsIDOMWindowUtils).focus(null);\\n-                }\\n-              }\\n-              this.mCurrentBrowser.setAttribute(\\\"type\\\", \\\"content-targetable\\\");\\n-            }\\n-\\n-            var updatePageReport = false;\\n-            if ((this.mCurrentBrowser.pageReport && !newBrowser.pageReport) ||\\n-                (!this.mCurrentBrowser.pageReport && newBrowser.pageReport))\\n-              updatePageReport = true;\\n-\\n-            newBrowser.setAttribute(\\\"type\\\", \\\"content-primary\\\");\\n-            this.mCurrentBrowser = newBrowser;\\n-            this.mCurrentTab = this.selectedTab;\\n-\\n-            if (updatePageReport)\\n-              this.mCurrentBrowser.updatePageReport();\\n-\\n-            // Update the URL bar.\\n-            var loc = this.mCurrentBrowser.currentURI;\\n-\\n-            var webProgress = this.mCurrentBrowser.webProgress;\\n-            var securityUI = this.mCurrentBrowser.securityUI;\\n-\\n-            var i, p;\\n-            for (i = 0; i < this.mProgressListeners.length; i++) {\\n-              p = this.mProgressListeners[i];\\n-              if (p) {\\n-                p.onLocationChange(webProgress, null, loc);\\n-                if (securityUI)\\n-                  p.onSecurityChange(webProgress, null, securityUI.state);\\n-\\n-                // make sure that all status indicators are properly updated\\n-                if (\\\"onUpdateCurrentBrowser\\\" in p) {\\n-                  var listener = this.mTabListeners[this.mTabContainer.selectedIndex] || null;\\n-                  if (listener && listener.mStateFlags)\\n-                    p.onUpdateCurrentBrowser(listener.mStateFlags, listener.mStatus,\\n-                                             listener.mMessage, listener.mTotalProgress);\\n-                }\\n-              }\\n-            }\\n-\\n-            this._fastFind.setDocShell(this.mCurrentBrowser.docShell);\\n-\\n-            // Update the window title.\\n-            this.updateTitlebar();\\n-\\n-            // If the new tab is busy, and our current state is not busy, then\\n-            // we need to fire a start to all progress listeners.\\n-            const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;\\n-            if (this.mCurrentTab.hasAttribute(\\\"busy\\\") && !this.mIsBusy) {\\n-              this.mIsBusy = true;\\n-              webProgress = this.mCurrentBrowser.webProgress;\\n-              for (i = 0; i < this.mProgressListeners.length; i++) {\\n-                p = this.mProgressListeners[i];\\n-                if (p)\\n-                  p.onStateChange(webProgress, null, nsIWebProgressListener.STATE_START | nsIWebProgressListener.STATE_IS_NETWORK, 0);\\n-              }\\n-            }\\n-\\n-            // If the new tab is not busy, and our current state is busy, then\\n-            // we need to fire a stop to all progress listeners.\\n-            if (!this.mCurrentTab.hasAttribute(\\\"busy\\\") && this.mIsBusy) {\\n-              this.mIsBusy = false;\\n-              webProgress = this.mCurrentBrowser.webProgress;\\n-              for (i = 0; i < this.mProgressListeners.length; i++) {\\n-                p = this.mProgressListeners[i];\\n-                if (p)\\n-                  p.onStateChange(webProgress, null, nsIWebProgressListener.STATE_STOP | nsIWebProgressListener.STATE_IS_NETWORK, 0);\\n-              }\\n-            }\\n-\\n-            // We've selected the new tab, so go ahead and notify listeners.\\n-            var event = document.createEvent(\\\"Events\\\");\\n-            event.initEvent(\\\"TabSelect\\\", true, false);\\n-            this.mCurrentTab.dispatchEvent(event);\\n-\\n-            if (document.commandDispatcher.focusedElement &&\\n-                document.commandDispatcher.focusedElement.parentNode ==\\n-                this.mCurrentTab.parentNode) {\\n-              // The focus is on a tab in the same tab panel\\n-              return;  // If focus was on a tab, switching tabs focuses the new tab\\n-            }\\n-\\n-            var whatToFocus = window.content;\\n-\\n-            // Focus the previously focused element or window\\n-            if (newBrowser.focusedElement) {\\n-              if (newBrowser.focusedElement.parentNode !=\\n-                  this.mCurrentTab.parentNode) {\\n-                // Focus the remembered element unless it's in the current tab panel\\n-                whatToFocus = newBrowser.focusedElement;\\n-              }\\n-            }\\n-            else if (newBrowser.focusedWindow) {\\n-              whatToFocus = newBrowser.focusedWindow;\\n-            }\\n- \\n-            // Change focus for this window to |whatToFocus|, without\\n-            // focusing the window itself.\\n-            var cmdDispatcher = document.commandDispatcher;\\n-\\n-            var ww =\\n-              Components.classes[\\\"@mozilla.org/embedcomp/window-watcher;1\\\"]\\n-                        .getService(Components.interfaces.nsIWindowWatcher);\\n-            if (ww.activeWindow == window) {\\n-              cmdDispatcher.suppressFocusScroll = true;\\n-              if (whatToFocus instanceof HTMLElement ||\\n-                  whatToFocus instanceof XULElement ||\\n-                  whatToFocus instanceof Window) {\\n-                whatToFocus.focus();\\n-              }\\n-              else if (whatToFocus instanceof Node) {\\n-                var content = window.content;\\n-                if (content instanceof Components.interfaces.nsIInterfaceRequestor)\\n-                  content.getInterface(Components.interfaces.nsIDOMWindowUtils).focus(whatToFocus);\\n-              }\\n-              cmdDispatcher.suppressFocusScroll = false;\\n-            }\\n-            else {\\n-              // set the element in command dispatcher so focus will restore\\n-              // properly when the window does become active\\n-              if (whatToFocus instanceof Window) {\\n-                cmdDispatcher.focusedWindow = whatToFocus;\\n-                cmdDispatcher.focusedElement = null;\\n-              }\\n-              else {\\n-                cmdDispatcher.focusedWindow = whatToFocus.ownerDocument.defaultView;\\n-                cmdDispatcher.focusedElement = whatToFocus;\\n-              }\\n-            }\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"onTabClick\\\">\\n-        <parameter name=\\\"event\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            if (event.button != 1 || event.target.localName != 'tab')\\n-              return;\\n-\\n-            this.removeTab(event.target);\\n-            event.stopPropagation();\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"onLinkAdded\\\">\\n-        <parameter name=\\\"event\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            if (!this.mPrefs.getBoolPref(\\\"browser.chrome.site_icons\\\"))\\n-              return;\\n-\\n-            if (!event.originalTarget.rel.match((/(?:^|\\\\s)icon(?:\\\\s|$)/i)))\\n-              return;\\n-\\n-            // We have an icon.\\n-            var href = event.originalTarget.href;\\n-            if (!href)\\n-              return;\\n-\\n-            const nsIContentPolicy = Components.interfaces.nsIContentPolicy;\\n-            try {\\n-              var contentPolicy =\\n-                Components.classes['@mozilla.org/layout/content-policy;1']\\n-                          .getService(nsIContentPolicy);\\n-            } catch(e) {\\n-              return; // Refuse to load if we can't do a security check.\\n-            }\\n-\\n-            // Get the IOService so we can make URIs\\n-            const ioService =\\n-              Components.classes[\\\"@mozilla.org/network/io-service;1\\\"]\\n-                        .getService(Components.interfaces.nsIIOService);\\n-\\n-            const targetDoc = event.target.ownerDocument;\\n-            // Make a URI out of our href.\\n-            var uri = ioService.newURI(href, targetDoc.characterSet, null);\\n-            try {\\n-              // Verify that the load of this icon is legal.\\n-              // error pages can load their favicon, to be on the safe side,\\n-              // only allow chrome:// favicons\\n-              const nsIScriptSecMan =\\n-                Components.interfaces.nsIScriptSecurityManager;\\n-              var secMan = Components.classes[\\\"@mozilla.org/scriptsecuritymanager;1\\\"]\\n-                                     .getService(nsIScriptSecMan);\\n-              const aboutNeterr = \\\"about:neterror?\\\";\\n-              if (targetDoc.documentURI.substr(0, aboutNeterr.length) != aboutNeterr ||\\n-                  !uri.schemeIs(\\\"chrome\\\"))\\n-                secMan.checkLoadURIWithPrincipal(targetDoc.nodePrincipal, uri,\\n-                                                 nsIScriptSecMan.DISALLOW_SCRIPT);\\n-            } catch(e) {\\n-              return;\\n-            }\\n-\\n-            // Security says okay, now ask content policy\\n-            if (contentPolicy.shouldLoad(nsIContentPolicy.TYPE_IMAGE,\\n-                                         uri, targetDoc.documentURIObject,\\n-                                         event.target, event.target.type,\\n-                                         null) != nsIContentPolicy.ACCEPT)\\n-              return;\\n-\\n-            var browserIndex = this.getBrowserIndexForDocument(targetDoc);\\n-            // no browser? no favicon.\\n-            if (browserIndex == -1)\\n-              return;\\n-\\n-            var tab = this.mTabContainer.childNodes[browserIndex];\\n-            this.setIcon(tab, href);\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"onTitleChanged\\\">\\n-        <parameter name=\\\"evt\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            if (evt.target != this.contentDocument)\\n-              return;\\n-\\n-            var i = 0;\\n-            for ( ; i < this.parentNode.parentNode.childNodes.length; i++) {\\n-              if (this.parentNode.parentNode.childNodes[i].firstChild == this)\\n-                break;\\n-            }\\n-\\n-            var tabBrowser = this.parentNode.parentNode.parentNode.parentNode;\\n-\\n-            var tab = document.getAnonymousElementByAttribute(tabBrowser, \\\"linkedpanel\\\", this.parentNode.id);\\n-            tabBrowser.setTabTitle(tab);\\n-\\n-            if (tab == tabBrowser.mCurrentTab)\\n-              tabBrowser.updateTitlebar();\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"setTabTitleLoading\\\">\\n-        <parameter name=\\\"aTab\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            aTab.label = this.mStringBundle.getString(\\\"tabs.loading\\\");\\n-            aTab.setAttribute(\\\"crop\\\", \\\"end\\\");\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"setTabTitle\\\">\\n-        <parameter name=\\\"aTab\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            var browser = this.getBrowserForTab(aTab);\\n-            var crop = \\\"end\\\";\\n-            var title = browser.contentTitle;\\n-\\n-            if (!title) {\\n-              if (browser.currentURI.spec) {\\n-                try {\\n-                  title = this.mURIFixup.createExposableURI(browser.currentURI).spec;\\n-                } catch(ex) {\\n-                  title = browser.currentURI.spec;\\n-                }\\n-              }\\n-\\n-              if (title && title != \\\"about:blank\\\") {\\n-                // At this point, we now have a URI.\\n-                // Let's try to unescape it using a character set\\n-                // in case the URI is not ASCII.\\n-                try {\\n-                  var characterSet = browser.contentDocument.characterSet;\\n-                  const textToSubURI = Components.classes[\\\"@mozilla.org/intl/texttosuburi;1\\\"]\\n-                                                 .getService(Components.interfaces.nsITextToSubURI);\\n-                  title = textToSubURI.unEscapeNonAsciiURI(characterSet, title);\\n-                } catch(ex) { /* Do nothing. */ }\\n-\\n-                crop = \\\"center\\\";\\n-\\n-              } else // Still no title?  Fall back to our untitled string.\\n-                title = this.mStringBundle.getString(\\\"tabs.untitled\\\");\\n-            }\\n-\\n-            aTab.label = title;\\n-            aTab.setAttribute(\\\"crop\\\", crop);\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"setStripVisibilityTo\\\">\\n-        <parameter name=\\\"aShow\\\"/>\\n-        <body>\\n-        <![CDATA[\\n-          this.mStrip.collapsed = !aShow;\\n-          if (aShow) {\\n-            // XXXdwh temporary unclean dependency on specific menu items in navigator.xul\\n-            document.getElementById(\\\"menu_closeWindow\\\").hidden = false;\\n-            document.getElementById(\\\"menu_close\\\").setAttribute(\\\"label\\\", this.mStringBundle.getString(\\\"tabs.closeTab\\\"));\\n-            if (!this.mTabbedMode)\\n-              this.enterTabbedMode();\\n-          }\\n-          else {\\n-            // XXXdwh temporary unclean dependency on specific menu items in navigator.xul\\n-            document.getElementById(\\\"menu_closeWindow\\\").hidden = true;\\n-            document.getElementById(\\\"menu_close\\\").setAttribute(\\\"label\\\", this.mStringBundle.getString(\\\"tabs.close\\\"));\\n-          }\\n-        ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"getStripVisibility\\\">\\n-        <body>\\n-          return !this.mStrip.collapsed;\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"enterTabbedMode\\\">\\n-        <body>\\n-          <![CDATA[\\n-            this.mTabbedMode = true; // Welcome to multi-tabbed mode.\\n-\\n-            // Get the first tab all hooked up with a title listener and popup blocking listener.\\n-            this.mCurrentBrowser.addEventListener(\\\"DOMTitleChanged\\\", this.onTitleChanged, true);\\n-\\n-            var throbberElement = document.getElementById(\\\"navigator-throbber\\\");\\n-            if (throbberElement && throbberElement.hasAttribute(\\\"busy\\\")) {\\n-              this.mCurrentTab.setAttribute(\\\"busy\\\", \\\"true\\\");\\n-              this.mIsBusy = true;\\n-              this.setTabTitleLoading(this.mCurrentTab);\\n-              this.updateIcon(this.mCurrentTab);\\n-            } else {\\n-              this.setTabTitle(this.mCurrentTab);\\n-              this.setIcon(this.mCurrentTab, this.mCurrentBrowser.mIconURL);\\n-            }\\n-\\n-            var filter;\\n-            if (this.mTabFilters.length > 0) {\\n-              // Use the filter hooked up in our addProgressListener\\n-              filter = this.mTabFilters[0];\\n-            } else {\\n-              // create a filter and hook it up to our first browser\\n-              filter = Components.classes[\\\"@mozilla.org/appshell/component/browser-status-filter;1\\\"]\\n-                                 .createInstance(Components.interfaces.nsIWebProgress);\\n-              this.mTabFilters[0] = filter;\\n-              this.mCurrentBrowser.webProgress.addProgressListener(filter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);\\n-            }\\n-\\n-            // Remove all our progress listeners from the active browser's filter.\\n-            for (var i = 0; i < this.mProgressListeners.length; i++) {\\n-              var p = this.mProgressListeners[i];\\n-              if (p)\\n-                filter.removeProgressListener(p);\\n-            }\\n-\\n-            // Wire up a progress listener to our filter.\\n-            const listener = this.mTabProgressListener(this.mCurrentTab,\\n-                                                       this.mCurrentBrowser,\\n-                                                       false);\\n-            filter.addProgressListener(listener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);\\n-            this.mTabListeners[0] = listener;\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"loadOneTab\\\">\\n-        <parameter name=\\\"aURI\\\"/>\\n-        <parameter name=\\\"aReferrerURI\\\"/>\\n-        <parameter name=\\\"aCharset\\\"/>\\n-        <parameter name=\\\"aPostData\\\"/>\\n-        <parameter name=\\\"aLoadInBackground\\\"/>\\n-        <parameter name=\\\"aAllowThirdPartyFixup\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            var bgLoad = (aLoadInBackground != null) ? aLoadInBackground :\\n-                         this.mPrefs.getBoolPref(\\\"browser.tabs.loadInBackground\\\");\\n-            var owner = bgLoad ? null : this.selectedTab;\\n-            var tab = this.addTab(aURI, aReferrerURI, aCharset, aPostData, owner,\\n-                                  aAllowThirdPartyFixup);\\n-            // Set newly selected tab after quick timeout, otherwise hideous focus problems\\n-            // can occur when \\\"browser.tabs.loadInBackground\\\" is false and presshell is not ready\\n-            if (!bgLoad) {\\n-              function selectNewForegroundTab(browser, tab) {\\n-                browser.selectedTab = tab;\\n-              }\\n-              setTimeout(selectNewForegroundTab, 0, getBrowser(), tab);\\n-            }\\n-            if (!bgLoad)\\n-              this.selectedTab = tab;\\n-            \\n-            return tab;\\n-         ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"loadTabs\\\">\\n-        <parameter name=\\\"aURIs\\\"/>\\n-        <parameter name=\\\"aLoadInBackground\\\"/>\\n-        <parameter name=\\\"aReplace\\\"/>\\n-        <body><![CDATA[\\n-          // The tab selected after this new tab is closed (i.e. the new tab's\\n-          // \\\"owner\\\") is the next adjacent tab (i.e. not the previously viewed tab)\\n-          // when several urls are opened here (i.e. closing the first should select\\n-          // the next of many URLs opened) or if the pref to have UI links opened in\\n-          // the background is set (i.e. the link is not being opened modally)\\n-          //\\n-          // i.e.\\n-          //    Number of URLs    Load UI Links in BG       Focus Last Viewed?\\n-          //    == 1              false                     YES\\n-          //    == 1              true                      NO\\n-          //    > 1               false/true                NO\\n-          var owner = (aURIs.length > 1) || aLoadInBackground ? null : gBrowser.selectedTab;\\n-          var firstTabAdded = null;\\n-          if (aReplace)\\n-            this.loadURI(aURIs[0], null, null);\\n-          else\\n-            firstTabAdded = gBrowser.addTab(aURIs[0], null, null, null, owner, false);\\n-\\n-          var tabNum = this.mTabContainer.selectedIndex;\\n-          for (var i = 1; i < aURIs.length; ++i) {\\n-            var tab = gBrowser.addTab(aURIs[i]);\\n-            if (aReplace)\\n-              this.moveTabTo(tab, ++tabNum);\\n-          }\\n-\\n-          if (!aLoadInBackground) {\\n-            if (firstTabAdded) {\\n-              // .selectedTab setter focuses the content area\\n-              this.selectedTab = firstTabAdded;\\n-            }\\n-            else\\n-              window.content.focus();\\n-          }\\n-        ]]></body>\\n-      </method>\\n-\\n-      <method name=\\\"addTab\\\">\\n-        <parameter name=\\\"aURI\\\"/>\\n-        <parameter name=\\\"aReferrerURI\\\"/>\\n-        <parameter name=\\\"aCharset\\\"/>\\n-        <parameter name=\\\"aPostData\\\"/>\\n-        <parameter name=\\\"aOwner\\\"/>\\n-        <parameter name=\\\"aAllowThirdPartyFixup\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            this._browsers = null; // invalidate cache\\n-\\n-            if (!this.mTabbedMode)\\n-              this.enterTabbedMode();\\n-\\n-            // if we're adding tabs, we're past interrupt mode, ditch the owner\\n-            if (this.mCurrentTab.owner)\\n-              this.mCurrentTab.owner = null;\\n-\\n-            var t = document.createElementNS(\\n-              \\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\",\\n-                                             \\\"tab\\\");\\n-\\n-            var blank = (aURI == \\\"about:blank\\\");\\n-\\n-            if (blank)\\n-              t.setAttribute(\\\"label\\\", this.mStringBundle.getString(\\\"tabs.untitled\\\"));\\n-            else\\n-              t.setAttribute(\\\"label\\\", aURI);\\n-\\n-            t.setAttribute(\\\"crop\\\", \\\"end\\\");\\n-            t.maxWidth = this.mTabContainer.mTabMaxWidth;\\n-            t.minWidth = this.mTabContainer.mTabMinWidth;\\n-            t.width = 0;\\n-            t.setAttribute(\\\"flex\\\", \\\"100\\\");\\n-            t.setAttribute(\\\"validate\\\", \\\"never\\\");\\n-            t.setAttribute(\\\"onerror\\\", \\\"this.parentNode.parentNode.parentNode.parentNode.addToMissedIconCache(this.getAttribute('image')); this.removeAttribute('image');\\\");\\n-            t.className = \\\"tabbrowser-tab\\\";\\n-\\n-            this.mTabContainer.appendChild(t);\\n-\\n-            if (document.defaultView\\n-                        .getComputedStyle(this.mTabContainer, \\\"\\\")\\n-                        .direction == \\\"rtl\\\") {\\n-              /* In RTL UI, the tab is visually added to the left side of the\\n-               * tabstrip. This means the tabstip has to be scrolled back in\\n-               * order to make sure the same set of tabs is visible before and\\n-               * after the new tab is added */\\n-\\n-              this.mTabContainer.mTabstrip.scrollBoxObject\\n-                  .scrollBy(this.mTabContainer.firstChild.boxObject.width, 0);\\n-            }\\n-\\n-            // invalidate cache, because mTabContainer is about to change\\n-            this._browsers = null; \\n-\\n-            // If this new tab is owned by another, assert that relationship\\n-            if (aOwner !== undefined && aOwner !== null) {\\n-              t.owner = aOwner;\\n-\\n-              var self = this;\\n-              function attrChanged(event) {\\n-                if (event.attrName == \\\"selectedIndex\\\" &&\\n-                    event.prevValue != event.newValue)\\n-                  self.resetOwner(parseInt(event.prevValue));\\n-              }\\n-              if (!this.mTabChangedListenerAdded) {\\n-                this.mTabBox.addEventListener(\\\"DOMAttrModified\\\", attrChanged, false);\\n-                this.mTabChangedListenerAdded = true;\\n-              }\\n-            }\\n-\\n-            var b = document.createElementNS(\\n-              \\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\",\\n-                                             \\\"browser\\\");\\n-            b.setAttribute(\\\"type\\\", \\\"content-targetable\\\");\\n-            b.setAttribute(\\\"message\\\", \\\"true\\\");\\n-            b.setAttribute(\\\"contextmenu\\\", this.getAttribute(\\\"contentcontextmenu\\\"));\\n-            b.setAttribute(\\\"tooltip\\\", this.getAttribute(\\\"contenttooltip\\\"));\\n-            if (this.hasAttribute(\\\"autocompletepopup\\\"))\\n-              b.setAttribute(\\\"autocompletepopup\\\", this.getAttribute(\\\"autocompletepopup\\\"));\\n-            b.setAttribute(\\\"autoscrollpopup\\\", this._autoScrollPopup.id);\\n-\\n-            // Add the Message and the Browser to the box\\n-            var notificationbox = document.createElementNS(\\n-                                    \\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\",\\n-                                    \\\"notificationbox\\\");\\n-            notificationbox.setAttribute(\\\"flex\\\", \\\"1\\\");\\n-            notificationbox.appendChild(b);\\n-            b.setAttribute(\\\"flex\\\", \\\"1\\\");\\n-            this.mPanelContainer.appendChild(notificationbox);\\n-\\n-            b.addEventListener(\\\"DOMTitleChanged\\\", this.onTitleChanged, true);\\n-\\n-            if (this.mStrip.collapsed)\\n-              this.setStripVisibilityTo(true);\\n-\\n-            this.mPrefs.setBoolPref(\\\"browser.tabs.forceHide\\\", false);\\n-\\n-            // wire up a progress listener for the new browser object.\\n-            var position = this.mTabContainer.childNodes.length-1;\\n-            var tabListener = this.mTabProgressListener(t, b, blank);\\n-            const filter = Components.classes[\\\"@mozilla.org/appshell/component/browser-status-filter;1\\\"]\\n-                                     .createInstance(Components.interfaces.nsIWebProgress);\\n-            filter.addProgressListener(tabListener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);\\n-            b.webProgress.addProgressListener(filter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);\\n-            this.mTabListeners[position] = tabListener;\\n-            this.mTabFilters[position] = filter;\\n-\\n-            b._fastFind = this.fastFind;\\n-\\n-            var uniqueId = \\\"panel\\\" + Date.now() + position;\\n-            this.mPanelContainer.lastChild.id = uniqueId;\\n-            t.linkedPanel = uniqueId;\\n-            t.linkedBrowser = b;\\n-            t._tPos = position;\\n-            if (t.previousSibling.selected)\\n-              t.setAttribute(\\\"afterselected\\\", true);\\n-\\n-            if (!blank) {\\n-              // Stop the existing about:blank load.  Otherwise, if aURI\\n-              // doesn't stop in-progress loads on its own, we'll get into\\n-              // trouble with multiple parallel loads running at once.\\n-              b.stop();\\n-\\n-              // pretend the user typed this so it'll be available till\\n-              // the document successfully loads\\n-              b.userTypedValue = aURI;\\n-\\n-              if (aPostData === undefined)\\n-                aPostData = null;\\n-              const nsIWebNavigation = Components.interfaces.nsIWebNavigation;\\n-              var flags = nsIWebNavigation.LOAD_FLAGS_NONE;\\n-              if (aAllowThirdPartyFixup) {\\n-                flags = nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP;\\n-              }\\n-              b.loadURIWithFlags(aURI, flags, aReferrerURI, aCharset, aPostData);\\n-            }\\n-\\n-            // |setTimeout| here to ensure we're post reflow\\n-            var _delayedUpdate = function(aTabContainer) {\\n-              aTabContainer.adjustTabstrip();\\n-\\n-              if (aTabContainer.selectedItem != t)\\n-                aTabContainer._notifyBackgroundTab(t);\\n-\\n-              // XXXmano: this is a temporary workaround to bug 343585\\n-              // We need to manually update the scroll buttons disabled state\\n-              // if a tab was inserted to the overflow area or removed from it\\n-              // without any scrolling and when the tabbar has already\\n-              // overflowed.\\n-              aTabContainer.mTabstrip._updateScrollButtonsDisabledState();\\n-            }\\n-            setTimeout(_delayedUpdate, 0, this.mTabContainer);\\n-\\n-            // Dispatch a new tab notification.  We do this once we're\\n-            // entirely done, so that things are in a consistent state\\n-            // even if the event listener opens or closes tabs.\\n-            var evt = document.createEvent(\\\"Events\\\");\\n-            evt.initEvent(\\\"TabOpen\\\", true, false);\\n-            t.dispatchEvent(evt);\\n-\\n-            return t;\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"warnAboutClosingTabs\\\">\\n-      <parameter name=\\\"aAll\\\"/>\\n-      <body>\\n-        <![CDATA[\\n-          var numTabs = this.mTabContainer.childNodes.length;\\n-          var reallyClose = true;\\n-          if (numTabs <= 1)\\n-            return reallyClose;\\n-\\n-          const pref = \\\"browser.tabs.warnOnClose\\\";\\n-          var shouldPrompt = this.mPrefs.getBoolPref(pref);\\n-\\n-          if (shouldPrompt) {\\n-            var promptService = Components.classes[\\\"@mozilla.org/embedcomp/prompt-service;1\\\"]\\n-                                          .getService(Components.interfaces.nsIPromptService);\\n-\\n-            //default to true: if it were false, we wouldn't get this far\\n-            var warnOnClose = { value:true };\\n-            var bundle = this.mStringBundle;\\n-            var tabsToClose = numTabs;  //number of tabs to be removed\\n-            if (!aAll)\\n-              --tabsToClose;\\n-\\n-            var messageKey = (tabsToClose == 1) ? \\\"tabs.closeWarningOneTab\\\" : \\\"tabs.closeWarningMultipleTabs\\\";\\n-            var closeKey = (tabsToClose == 1) ? \\\"tabs.closeButtonOne\\\" : \\\"tabs.closeButtonMultiple\\\";\\n-            // focus the window before prompting.\\n-            // this will raise any minimized window, which will\\n-            // make it obvious which window the prompt is for and will\\n-            // solve the problem of windows \\\"obscuring\\\" the prompt.\\n-            // see bug #350299 for more details\\n-            window.focus();\\n-            var buttonPressed = promptService.confirmEx(window,\\n-                                                        bundle.getString('tabs.closeWarningTitle'),\\n-                                                        bundle.getFormattedString(messageKey, [tabsToClose]),\\n-                                                        (promptService.BUTTON_TITLE_IS_STRING * promptService.BUTTON_POS_0)\\n-                                                        + (promptService.BUTTON_TITLE_CANCEL * promptService.BUTTON_POS_1),\\n-                                                        bundle.getString(closeKey),\\n-                                                        null, null,\\n-                                                        bundle.getString('tabs.closeWarningPromptMe'),\\n-                                                        warnOnClose);\\n-            reallyClose = (buttonPressed == 0);\\n-            // don't set the pref unless they press OK and it's false\\n-            if (reallyClose && !warnOnClose.value)\\n-              this.mPrefs.setBoolPref(pref, false);\\n-          }\\n-          return reallyClose;\\n-        ]]>\\n-      </body>\\n-      </method>\\n-\\n-      <method name=\\\"removeAllTabsBut\\\">\\n-        <parameter name=\\\"aTab\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            if (this.warnAboutClosingTabs(false)) {\\n-              if (aTab.localName != \\\"tab\\\")\\n-                aTab = this.mCurrentTab;\\n-              else\\n-                this.mTabContainer.selectedItem = aTab;\\n-\\n-              var childNodes = this.mTabContainer.childNodes;\\n-\\n-              for (var i = childNodes.length - 1; i >= 0; --i) {\\n-                if (childNodes[i] != aTab)\\n-                  this.removeTab(childNodes[i]);\\n-              }\\n-            }\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"removeCurrentTab\\\">\\n-        <body>\\n-          <![CDATA[\\n-            return this.removeTab(this.mCurrentTab);\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"resetOwner\\\">\\n-        <parameter name=\\\"oldIndex\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            // Reset the owner property, since we're leaving the modally opened\\n-            // tab for another.\\n-            if (oldIndex < this.mTabContainer.childNodes.length) {\\n-              var tab = this.mTabContainer.childNodes[oldIndex];\\n-              tab.owner = null;\\n-            }\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"removeTab\\\">\\n-        <parameter name=\\\"aTab\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            this._browsers = null; // invalidate cache\\n-            if (aTab.localName != \\\"tab\\\")\\n-              aTab = this.mCurrentTab;\\n-\\n-            var l = this.mTabContainer.childNodes.length;\\n-            if (l == 1 && this.mPrefs.getBoolPref(\\\"browser.tabs.autoHide\\\")) {\\n-              // hide the tab bar\\n-              this.mPrefs.setBoolPref(\\\"browser.tabs.forceHide\\\", true);\\n-              this.setStripVisibilityTo(false);\\n-              return;\\n-            }\\n-\\n-            var ds = this.getBrowserForTab(aTab).docShell;\\n-            if (ds.contentViewer && !ds.contentViewer.permitUnload())\\n-              return;\\n-\\n-            // see notes in addTab\\n-            var _delayedUpdate = function(aTabContainer) {\\n-              aTabContainer.adjustTabstrip();\\n-              aTabContainer.mTabstrip._updateScrollButtonsDisabledState();\\n-            }\\n-            setTimeout(_delayedUpdate, 0, this.mTabContainer);\\n-\\n-            if (l == 1) {\\n-              // add a new blank tab to replace the one we're about to close\\n-              // (this ensures that the remaining tab is as good as new)\\n-              this.addTab(\\\"about:blank\\\");\\n-              l++;\\n-            }\\n-            else if (l == 2) {\\n-              var autohide = this.mPrefs.getBoolPref(\\\"browser.tabs.autoHide\\\");\\n-              var tabStripHide = !window.toolbar.visible;\\n-              if (autohide || tabStripHide)\\n-                this.setStripVisibilityTo(false);\\n-            }\\n-\\n-            // We're committed to closing the tab now.  \\n-            // Dispatch a notification.\\n-            // We dispatch it before any teardown so that event listeners can\\n-            // inspect the tab that's about to close.\\n-            var evt = document.createEvent(\\\"Events\\\");\\n-            evt.initEvent(\\\"TabClose\\\", true, false);\\n-            aTab.dispatchEvent(evt);\\n-\\n-            var index = -1;\\n-            if (this.mCurrentTab == aTab)\\n-              index = this.mTabContainer.selectedIndex;\\n-            else {\\n-              // Find and locate the tab in our list.\\n-              for (var i = 0; i < l; i++)\\n-                if (this.mTabContainer.childNodes[i] == aTab)\\n-                  index = i;\\n-            }\\n-\\n-            // Remove the tab's filter and progress listener.\\n-            const filter = this.mTabFilters[index];\\n-            var oldBrowser = this.getBrowserAtIndex(index);\\n-            oldBrowser.webProgress.removeProgressListener(filter);\\n-            filter.removeProgressListener(this.mTabListeners[index]);\\n-            this.mTabFilters.splice(index, 1);\\n-            this.mTabListeners.splice(index, 1);\\n-\\n-            // Remove our title change and blocking listeners\\n-            oldBrowser.removeEventListener(\\\"DOMTitleChanged\\\", this.onTitleChanged, true);\\n-\\n-            // We are no longer the primary content area.\\n-            oldBrowser.setAttribute(\\\"type\\\", \\\"content-targetable\\\");\\n-\\n-            // Get the index of the tab we're removing before unselecting it\\n-            var currentIndex = this.mTabContainer.selectedIndex;\\n-\\n-            var oldTab = aTab;\\n-\\n-            // clean up the before/afterselected attributes before removing the tab\\n-            oldTab._selected = false;\\n-\\n-            // Remove this tab as the owner of any other tabs, since it's going away.\\n-            for (i = 0; i < this.mTabContainer.childNodes.length; ++i) {\\n-              var tab = this.mTabContainer.childNodes[i];\\n-              if (\\\"owner\\\" in tab && tab.owner == oldTab)\\n-                // |tab| is a child of the tab we're removing, make it an orphan\\n-                tab.owner = null;\\n-            }\\n-\\n-            // Because of the way XBL works (fields just set JS\\n-            // properties on the element) and the code we have in place\\n-            // to preserve the JS objects for any elements that have\\n-            // JS properties set on them, the browser element won't be\\n-            // destroyed until the document goes away.  So we force a\\n-            // cleanup ourselves.\\n-            // This has to happen before we remove the child so that the\\n-            // XBL implementation of nsIObserver still works.  But\\n-            // clearing focusedWindow happens below because it gets\\n-            // reset by updateCurrentBrowser.\\n-            oldBrowser.destroy();\\n-\\n-            // Remove the tab\\n-            this.mTabContainer.removeChild(oldTab);\\n-            // invalidate cache, because mTabContainer is about to change\\n-            this._browsers = null; \\n-            this.mPanelContainer.removeChild(oldBrowser.parentNode);\\n-\\n-            try {\\n-              // if we're at the right side (and not the logical end,\\n-              // which is why this works for both LTR and RTL)\\n-              // of the tabstrip, we need to ensure that we stay \\n-              // completely scrolled to the right side\\n-              var tabStrip = this.mTabContainer.mTabstrip;\\n-              var scrollPos = {};\\n-              tabStrip.scrollBoxObject.getPosition(scrollPos, {});\\n-              var scrolledSize = {};\\n-              tabStrip.scrollBoxObject.getScrolledSize(scrolledSize, {});\\n-\\n-              if (scrollPos.value + tabStrip.boxObject.width >= \\n-                  scrolledSize.value) {\\n-                tabStrip.scrollByPixels(-1 * this.mTabContainer.firstChild\\n-                                                 .boxObject.width);\\n-              }\\n-            }\\n-            catch (ex) {\\n-            }\\n-\\n-            // Find the tab to select\\n-            var newIndex = -1;\\n-            if (currentIndex > index)\\n-              newIndex = currentIndex-1;\\n-            else if (currentIndex < index)\\n-              newIndex = currentIndex;\\n-            else {\\n-              if (\\\"owner\\\" in oldTab && oldTab.owner &&\\n-                  this.mPrefs.getBoolPref(\\\"browser.tabs.selectOwnerOnClose\\\")) {\\n-                for (i = 0; i < this.mTabContainer.childNodes.length; ++i) {\\n-                  tab = this.mTabContainer.childNodes[i];\\n-                  if (tab == oldTab.owner) {\\n-                    newIndex = i;\\n-                    break;\\n-                  }\\n-                }\\n-              }\\n-              if (newIndex == -1)\\n-                newIndex = (index == l - 1) ? index - 1 : index;\\n-            }\\n-\\n-            // Select the new tab\\n-            this.selectedTab = this.mTabContainer.childNodes[newIndex];\\n-\\n-            for (i = oldTab._tPos; i < this.mTabContainer.childNodes.length; i++) {\\n-              this.mTabContainer.childNodes[i]._tPos = i;\\n-            }\\n-            this.mTabBox.selectedPanel = this.getBrowserForTab(this.mCurrentTab).parentNode;\\n-            this.mCurrentTab._selected = true;\\n-\\n-            this.updateCurrentBrowser();\\n-\\n-            // see comment above destroy above\\n-            oldBrowser.focusedWindow = null;\\n-            oldBrowser.focusedElement = null;\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"reloadAllTabs\\\">\\n-        <body>\\n-          <![CDATA[\\n-            var l = this.mPanelContainer.childNodes.length;\\n-            for (var i = 0; i < l; i++) {\\n-              try {\\n-                this.getBrowserAtIndex(i).reload();\\n-              } catch (e) {\\n-                // ignore failure to reload so others will be reloaded\\n-              }\\n-            }\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"reloadTab\\\">\\n-        <parameter name=\\\"aTab\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            if (aTab.localName != \\\"tab\\\")\\n-              aTab = this.mCurrentTab;\\n-\\n-            this.getBrowserForTab(aTab).reload();\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"onTabBarDblClick\\\">\\n-        <parameter name=\\\"aEvent\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            // See hack note in the tabbrowser-close-button binding\\n-            if (!this._blockDblClick && aEvent.button == 0 &&\\n-                aEvent.originalTarget.localName == \\\"box\\\") {\\n-              // xxx this needs to check that we're in the empty area of the tabstrip\\n-              var e = document.createEvent(\\\"Events\\\");\\n-              e.initEvent(\\\"NewTab\\\", true, true);\\n-              this.dispatchEvent(e);\\n-            }\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"addProgressListener\\\">\\n-        <parameter name=\\\"aListener\\\"/>\\n-        <parameter name=\\\"aMask\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            if (!this.mAddProgressListenerWasCalled) {\\n-              this.mAddProgressListenerWasCalled = true;\\n-              var autoHide = this.mPrefs.getBoolPref(\\\"browser.tabs.autoHide\\\");\\n-              var forceHide = this.mPrefs.getBoolPref(\\\"browser.tabs.forceHide\\\");\\n-              var tabStripHide = !window.toolbar.visible;\\n-              if (!autoHide && !forceHide && !tabStripHide)\\n-                this.setStripVisibilityTo(true);\\n-            }\\n-\\n-            if (!this.mTabbedMode && this.mProgressListeners.length == 1) {\\n-              // If we are adding a 2nd progress listener, we need to enter tabbed mode\\n-              // because the browser status filter can only handle one progress listener.\\n-              // In tabbed mode, mTabProgressListener is used which will iterate over all listeners.\\n-              this.enterTabbedMode();\\n-            }\\n-\\n-            this.mProgressListeners.push(aListener);\\n-\\n-            if (!this.mTabbedMode) {\\n-              // If someone does this:\\n-              // addProgressListener, removeProgressListener, addProgressListener\\n-              // don't create a new filter; reuse the existing filter.\\n-              if (this.mTabFilters.length == 0) {\\n-                // hook a filter up to our first browser\\n-                const filter = Components.classes[\\\"@mozilla.org/appshell/component/browser-status-filter;1\\\"]\\n-                                         .createInstance(Components.interfaces.nsIWebProgress);\\n-                this.mTabFilters[0] = filter;\\n-                this.mCurrentBrowser.webProgress.addProgressListener(filter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);\\n-              }\\n-\\n-              // Directly hook the listener up to the filter for better performance\\n-              this.mTabFilters[0].addProgressListener(aListener, aMask);\\n-            }\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"removeProgressListener\\\">\\n-        <parameter name=\\\"aListener\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            for (var i = 0; i < this.mProgressListeners.length; i++) {\\n-              if (this.mProgressListeners[i] == aListener) {\\n-                this.mProgressListeners.splice(i, 1);\\n-                break;\\n-              }\\n-            }\\n-\\n-            if (!this.mTabbedMode)\\n-              // Don't forget to remove it from the filter we hooked it up to\\n-              this.mTabFilters[0].removeProgressListener(aListener);\\n-         ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"getBrowserForTab\\\">\\n-        <parameter name=\\\"aTab\\\"/>\\n-        <body>\\n-        <![CDATA[\\n-          return aTab.linkedBrowser;\\n-        ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <property name=\\\"tabContainer\\\" readonly=\\\"true\\\">\\n-        <getter>\\n-          return this.mTabContainer;\\n-        </getter>\\n-      </property>\\n-\\n-      <property name=\\\"selectedTab\\\">\\n-        <getter>\\n-          return this.mTabBox.selectedTab;\\n-        </getter>\\n-        <setter>\\n-          <![CDATA[\\n-          // Update the tab\\n-          this.mTabBox.selectedTab = val;\\n-          return val;\\n-          ]]>\\n-        </setter>\\n-      </property>\\n-\\n-      <property name=\\\"selectedBrowser\\\"\\n-                onget=\\\"return this.mCurrentBrowser;\\\"\\n-                readonly=\\\"true\\\"/>\\n-\\n-      <property name=\\\"browsers\\\" readonly=\\\"true\\\">\\n-       <getter>\\n-          <![CDATA[\\n-            if (!this._browsers) {\\n-              var browsers = [];\\n-              var i;\\n-              browsers.item = function(i) {return this[i];}\\n-              for (i = 0; i < this.mTabContainer.childNodes.length; i++)\\n-                browsers.push(this.mTabContainer.childNodes[i].linkedBrowser);\\n-              this._browsers = browsers;\\n-            }\\n-            return this._browsers;\\n-          ]]>\\n-        </getter>\\n-      </property>\\n-\\n-      <!-- Drag and drop observer API -->\\n-      <method name=\\\"onDragStart\\\">\\n-        <parameter name=\\\"aEvent\\\"/>\\n-        <parameter name=\\\"aXferData\\\"/>\\n-        <parameter name=\\\"aDragAction\\\"/>\\n-        <body>\\n-        <![CDATA[\\n-          if (aEvent.target.localName == \\\"tab\\\" &&\\n-              aEvent.originalTarget.localName != \\\"toolbarbutton\\\") {\\n-            aXferData.data = new TransferData();\\n-\\n-            var URI = this.getBrowserForTab(aEvent.target).currentURI;\\n-            if (URI) {\\n-              aXferData.data.addDataForFlavour(\\\"text/x-moz-url\\\", URI.spec + \\\"\\\\n\\\" + aEvent.target.label);\\n-              aXferData.data.addDataForFlavour(\\\"text/unicode\\\", URI.spec);\\n-              aXferData.data.addDataForFlavour(\\\"text/html\\\", '<a href=\\\"' + URI.spec + '\\\">' + aEvent.target.label + '</a>');\\n-            } else {\\n-              aXferData.data.addDataForFlavour(\\\"text/unicode\\\", \\\"about:blank\\\");\\n-            }\\n-          }\\n-        ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"canDrop\\\">\\n-        <parameter name=\\\"aEvent\\\"/>\\n-        <parameter name=\\\"aDragSession\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            if (aDragSession.sourceNode &&\\n-                aDragSession.sourceNode.parentNode == this.mTabContainer &&\\n-                (aEvent.screenX >= aDragSession.sourceNode.boxObject.screenX &&\\n-                 aEvent.screenX <= (aDragSession.sourceNode.boxObject.screenX +\\n-                                    aDragSession.sourceNode.boxObject.width)))\\n-                return false;\\n-            return true;\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <field name=\\\"mDragTime\\\">0</field>\\n-      <field name=\\\"mDragOverDelay\\\">350</field>\\n-      <method name=\\\"onDragOver\\\">\\n-        <parameter name=\\\"aEvent\\\"/>\\n-        <parameter name=\\\"aFlavour\\\"/>\\n-        <parameter name=\\\"aDragSession\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            var tabStrip = this.mTabContainer.mTabstrip;\\n-\\n-            // autoscroll the tab strip if we drag over the scroll\\n-            // buttons, even if we aren't dragging a tab, but then\\n-            // return to avoid drawing the drop indicator\\n-            var pixelsToScroll = 0;\\n-\\n-            var targetAnonid = aEvent.originalTarget.getAttribute(\\\"anonid\\\");\\n-            if (targetAnonid == \\\"scrollbutton-up\\\") {\\n-              pixelsToScroll = tabStrip.scrollIncrement * -1;\\n-              tabStrip.scrollByPixels(pixelsToScroll);\\n-            }\\n-            else if (targetAnonid == \\\"scrollbutton-down\\\" || \\n-                     (targetAnonid == \\\"alltabs-button\\\" && \\n-                      this.mTabContainer.getAttribute(\\\"overflow\\\") == \\\"true\\\")) {\\n-              pixelsToScroll = tabStrip.scrollIncrement;\\n-              tabStrip.scrollByPixels(pixelsToScroll);\\n-            }\\n-\\n-            var isTabDrag = (aDragSession.sourceNode && \\n-                             aDragSession.sourceNode.parentNode == this.mTabContainer);\\n-            if (!isTabDrag && aEvent.target.localName == \\\"tab\\\") {\\n-              if (!this.mDragTime) \\n-                this.mDragTime = Date.now();\\n-              if (Date.now() >= this.mDragTime + this.mDragOverDelay)\\n-                this.mTabContainer.selectedItem = aEvent.target;\\n-              return;\\n-            }\\n-\\n-            var newIndex = this.getNewIndex(aEvent);\\n-\\n-            var ib = this.mTabDropIndicatorBar;\\n-            var ind = ib.firstChild;\\n-            ib.setAttribute('dragging',\\n-               aDragSession.canDrop ? 'true' : 'false');\\n-\\n-            var tabStripBoxObject = tabStrip.scrollBoxObject;\\n-            var halfIndWidth = Math.floor((ind.boxObject.width + 1) / 2);\\n-            if (window.getComputedStyle(this.parentNode, null)\\n-                      .direction == \\\"ltr\\\") {\\n-              var newMarginLeft;\\n-              var minMarginLeft = tabStripBoxObject.x - halfIndWidth -\\n-                                  ib.boxObject.x;\\n-              // make sure we don't place the tab drop indicator past the\\n-              // edge, or the containing box will flex and stretch\\n-              // the tab drop indicator bar, which will flex the url bar.  \\n-              // XXX todo\\n-              // just use first value if you can figure out how to get\\n-              // the tab drop indicator to crop instead of flex and stretch\\n-              // the tab drop indicator bar.\\n-              var maxMarginLeft = Math.min(\\n-                (minMarginLeft + tabStripBoxObject.width), \\n-                (ib.boxObject.x + ib.boxObject.width - ind.boxObject.width));\\n-\\n-              // if we are scrolling, put the drop indicator at the edge\\n-              // so that it doesn't jump while scrolling\\n-              if (pixelsToScroll > 0)\\n-                newMarginLeft = maxMarginLeft;\\n-              else if (pixelsToScroll < 0)\\n-                newMarginLeft = minMarginLeft;\\n-              else {\\n-              if (newIndex == this.mTabs.length) {\\n-                  newMarginLeft = this.mTabs[newIndex-1].boxObject.screenX +\\n-                                  this.mTabs[newIndex-1].boxObject.width - \\n-                                  this.boxObject.screenX - halfIndWidth;\\n-              } else {\\n-                  newMarginLeft = this.mTabs[newIndex].boxObject.screenX - \\n-                                  this.boxObject.screenX - halfIndWidth;\\n-              }\\n-\\n-              // ensure we never place the drop indicator beyond\\n-              // our limits\\n-              if (newMarginLeft < minMarginLeft)\\n-                newMarginLeft = minMarginLeft;\\n-              else if (newMarginLeft > maxMarginLeft)\\n-                newMarginLeft = maxMarginLeft;\\n-              }\\n-              ind.style.marginLeft = newMarginLeft + 'px';\\n-            } else {\\n-              var newMarginRight;\\n-              var minMarginRight = tabStripBoxObject.x - halfIndWidth -\\n-                                   ib.boxObject.x;\\n-              // make sure we don't place the tab drop indicator past the\\n-              // edge, or the containing box will flex and stretch\\n-              // the tab drop indicator bar, which will flex the url bar.  \\n-              // XXX todo\\n-              // just use first value if you can figure out how to get\\n-              // the tab drop indicator to crop instead of flex and stretch\\n-              // the tab drop indicator bar.\\n-              var maxMarginRight = Math.min(\\n-                (minMarginRight + tabStripBoxObject.width), \\n-                (ib.boxObject.x + ib.boxObject.width - ind.boxObject.width));\\n-\\n-              // if we are scrolling, put the drop indicator at the edge\\n-              // so that it doesn't jump while scrolling\\n-              if (pixelsToScroll > 0)\\n-                newMarginRight = maxMarginRight;\\n-              else if (pixelsToScroll < 0)\\n-                newMarginRight = minMarginRight;\\n-              else {\\n-                if (newIndex == this.mTabs.length) {\\n-                    newMarginRight = this.boxObject.width + \\n-                                     this.boxObject.screenX -\\n-                                     this.mTabs[newIndex-1].boxObject.screenX -\\n-                                     halfIndWidth;\\n-                } else {\\n-                    newMarginRight = this.boxObject.width + \\n-                                     this.boxObject.screenX -\\n-                                     this.mTabs[newIndex].boxObject.screenX -\\n-                                     this.mTabs[newIndex].boxObject.width -\\n-                                     halfIndWidth;\\n-                }\\n-\\n-                // ensure we never place the drop indicator beyond\\n-                // our limits\\n-                if (newMarginRight < minMarginRight)\\n-                  newMarginRight = minMarginRight;\\n-                else if (newMarginRight > maxMarginRight)\\n-                  newMarginRight = maxMarginRight;\\n-              }\\n-              ind.style.marginRight = newMarginRight + 'px';\\n-            }\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"onDrop\\\">\\n-        <parameter name=\\\"aEvent\\\"/>\\n-        <parameter name=\\\"aXferData\\\"/>\\n-        <parameter name=\\\"aDragSession\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            if (aDragSession.sourceNode && aDragSession.sourceNode.parentNode == this.mTabContainer) {\\n-              var newIndex = this.getNewIndex(aEvent);\\n-              var oldIndex = aDragSession.sourceNode._tPos;\\n-\\n-              if (newIndex > oldIndex)\\n-                newIndex--;\\n-              if (newIndex != oldIndex)\\n-                this.moveTabTo(this.mTabs[oldIndex], newIndex);\\n-            } else {\\n-              var url = transferUtils.retrieveURLFromData(aXferData.data, aXferData.flavour.contentType);\\n-\\n-              // valid urls don't contain spaces ' '; if we have a space it isn't a valid url.\\n-              // Also disallow dropping javascript: or data: urls--bail out\\n-              if (!url || !url.length || url.indexOf(\\\" \\\", 0) != -1 ||\\n-                  /^\\\\s*(javascript|data):/.test(url))\\n-                return;\\n-\\n-              nsDragAndDrop.dragDropSecurityCheck(aEvent, aDragSession, url);\\n-\\n-              var bgLoad = true;\\n-              try {\\n-                bgLoad = this.mPrefs.getBoolPref(\\\"browser.tabs.loadInBackground\\\");\\n-              }\\n-              catch (e) { }\\n-\\n-              if (aEvent.shiftKey)\\n-                bgLoad = !bgLoad;\\n-\\n-              if (document.getBindingParent(aEvent.originalTarget).localName != \\\"tab\\\") {\\n-                // We're adding a new tab.\\n-                this.loadOneTab(getShortcutOrURI(url), null, null, null, bgLoad, false);\\n-              }\\n-              else {\\n-                // Load in an existing tab.\\n-                var tab = aEvent.target;\\n-                try {\\n-                  this.getBrowserForTab(tab).loadURI(getShortcutOrURI(url));\\n-                  if (this.mCurrentTab != tab && !bgLoad)\\n-                    this.selectedTab = tab;\\n-                } catch(ex) {\\n-                  // Just ignore invalid urls\\n-                }\\n-              }\\n-            }\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"onDragExit\\\">\\n-        <parameter name=\\\"aEvent\\\"/>\\n-        <parameter name=\\\"aDragSession\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            this.mDragTime = 0;\\n-\\n-            if (aDragSession.sourceNode &&\\n-                aDragSession.sourceNode.parentNode == this.mTabContainer &&\\n-                aDragSession.canDrop) {\\n-              var target = aEvent.relatedTarget;\\n-              while (target && target != this.mStrip)\\n-                target = target.parentNode;\\n-              if (target)\\n-                return;\\n-            }\\n-            this.mTabDropIndicatorBar.setAttribute('dragging','false');\\n-\\n-            // FIXME: bug 390979 - we need to reset the horizontal margins on the\\n-            // tab-drop indicator here to avoid impacting tabbar resizing. This\\n-            // shouldn't be necessary once we can collapse the indicator.\\n-            var dropIndicator = this.mTabDropIndicatorBar.firstChild;\\n-            dropIndicator.style.marginRight = \\\"0px\\\";\\n-            dropIndicator.style.marginLeft = \\\"0px\\\";\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"getSupportedFlavours\\\">\\n-        <body>\\n-        <![CDATA[\\n-          var flavourSet = new FlavourSet();\\n-          flavourSet.appendFlavour(\\\"text/x-moz-url\\\");\\n-          flavourSet.appendFlavour(\\\"text/unicode\\\");\\n-          flavourSet.appendFlavour(\\\"application/x-moz-file\\\", \\\"nsIFile\\\");\\n-          return flavourSet;\\n-        ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"moveTabTo\\\">\\n-        <parameter name=\\\"aTab\\\"/>\\n-        <parameter name=\\\"aIndex\\\"/>\\n-        <body>\\n-        <![CDATA[\\n-          this._browsers = null; // invalidate cache\\n-          this.mTabFilters.splice(aIndex, 0, this.mTabFilters.splice(aTab._tPos, 1)[0]);\\n-          this.mTabListeners.splice(aIndex, 0, this.mTabListeners.splice(aTab._tPos, 1)[0]);\\n-\\n-          var oldPosition = aTab._tPos;\\n-\\n-          aIndex = aIndex < aTab._tPos ? aIndex: aIndex+1;\\n-          this.mCurrentTab._selected = false;\\n-          // use .item() instead of [] because dragging to the end of the strip goes out of\\n-          // bounds: .item() returns null (so it acts like appendChild), but [] throws\\n-          this.mTabContainer.insertBefore(aTab, this.mTabContainer.childNodes.item(aIndex));\\n-          // invalidate cache, because mTabContainer is about to change\\n-          this._browsers = null;\\n-\\n-          var i;\\n-          for (i = 0; i < this.mTabContainer.childNodes.length; i++) {\\n-            this.mTabContainer.childNodes[i]._tPos = i;\\n-            this.mTabContainer.childNodes[i]._selected = false;\\n-          }\\n-          this.mCurrentTab._selected = true;\\n-          this.mTabContainer.mTabstrip.scrollBoxObject.ensureElementIsVisible(this.mCurrentTab);\\n-\\n-          var evt = document.createEvent(\\\"UIEvents\\\");\\n-          evt.initUIEvent(\\\"TabMove\\\", true, false, window, oldPosition);\\n-          aTab.dispatchEvent(evt);\\n-\\n-          return aTab;\\n-        ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"getNewIndex\\\">\\n-        <parameter name=\\\"aEvent\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            var i;\\n-            if (window.getComputedStyle(this.parentNode, null).direction == \\\"ltr\\\") {\\n-              for (i = aEvent.target.localName == \\\"tab\\\" ? aEvent.target._tPos : 0; i < this.mTabs.length; i++)\\n-                if (aEvent.screenX < this.mTabs[i].boxObject.screenX + this.mTabs[i].boxObject.width / 2) \\n-                  return i;\\n-            } else {\\n-               for (i = aEvent.target.localName == \\\"tab\\\" ? aEvent.target._tPos : 0; i < this.mTabs.length; i++)\\n-                if (aEvent.screenX > this.mTabs[i].boxObject.screenX + this.mTabs[i].boxObject.width / 2)\\n-                  return i;\\n-            }\\n-\\n-            return this.mTabs.length;\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-\\n-      <method name=\\\"moveTabForward\\\">\\n-        <body>\\n-          <![CDATA[\\n-            var tabPos = this.mCurrentTab._tPos;\\n-            if (tabPos < this.browsers.length - 1) {\\n-              this.moveTabTo(this.mCurrentTab, tabPos + 1);\\n-              this.mCurrentTab.focus();\\n-            }\\n-            else if (this.arrowKeysShouldWrap)\\n-              this.moveTabToStart();\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"moveTabBackward\\\">\\n-        <body>\\n-          <![CDATA[\\n-            var tabPos = this.mCurrentTab._tPos;\\n-            if (tabPos > 0) {\\n-              this.moveTabTo(this.mCurrentTab, tabPos - 1);\\n-              this.mCurrentTab.focus();\\n-            }\\n-            else if (this.arrowKeysShouldWrap)\\n-              this.moveTabToEnd();\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"moveTabToStart\\\">\\n-        <body>\\n-          <![CDATA[\\n-            var tabPos = this.mCurrentTab._tPos;\\n-            if (tabPos > 0) {\\n-              this.moveTabTo(this.mCurrentTab, 0);\\n-              this.mCurrentTab.focus();\\n-            }\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"moveTabToEnd\\\">\\n-        <body>\\n-          <![CDATA[\\n-            var tabPos = this.mCurrentTab._tPos;\\n-            if (tabPos < this.browsers.length - 1) {\\n-              this.moveTabTo(this.mCurrentTab,\\n-                                        this.browsers.length - 1);\\n-              this.mCurrentTab.focus();\\n-            }\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"moveTabOver\\\">\\n-        <parameter name=\\\"aEvent\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            var direction = window.getComputedStyle(this.parentNode, null).direction;\\n-            if ((direction == \\\"ltr\\\" && aEvent.keyCode == KeyEvent.DOM_VK_RIGHT) ||\\n-                (direction == \\\"rtl\\\" && aEvent.keyCode == KeyEvent.DOM_VK_LEFT))\\n-              this.moveTabForward();\\n-            else\\n-              this.moveTabBackward();\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <!-- BEGIN FORWARDED BROWSER PROPERTIES.  IF YOU ADD A PROPERTY TO THE BROWSER ELEMENT\\n-           MAKE SURE TO ADD IT HERE AS WELL. -->\\n-      <property name=\\\"canGoBack\\\"\\n-                onget=\\\"return this.mCurrentBrowser.canGoBack;\\\"\\n-                readonly=\\\"true\\\"/>\\n-\\n-      <property name=\\\"canGoForward\\\"\\n-                onget=\\\"return this.mCurrentBrowser.canGoForward;\\\"\\n-                readonly=\\\"true\\\"/>\\n-\\n-      <method name=\\\"goBack\\\">\\n-        <body>\\n-          <![CDATA[\\n-            return this.mCurrentBrowser.goBack();\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"goForward\\\">\\n-        <body>\\n-          <![CDATA[\\n-            return this.mCurrentBrowser.goForward();\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"reload\\\">\\n-        <body>\\n-          <![CDATA[\\n-            return this.mCurrentBrowser.reload();\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"reloadWithFlags\\\">\\n-        <parameter name=\\\"aFlags\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            return this.mCurrentBrowser.reloadWithFlags(aFlags);\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"stop\\\">\\n-        <body>\\n-          <![CDATA[\\n-            return this.mCurrentBrowser.stop();\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <!-- throws exception for unknown schemes -->\\n-      <method name=\\\"loadURI\\\">\\n-        <parameter name=\\\"aURI\\\"/>\\n-        <parameter name=\\\"aReferrerURI\\\"/>\\n-        <parameter name=\\\"aCharset\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            return this.mCurrentBrowser.loadURI(aURI, aReferrerURI, aCharset);\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <!-- throws exception for unknown schemes -->\\n-      <method name=\\\"loadURIWithFlags\\\">\\n-        <parameter name=\\\"aURI\\\"/>\\n-        <parameter name=\\\"aFlags\\\"/>\\n-        <parameter name=\\\"aReferrerURI\\\"/>\\n-        <parameter name=\\\"aCharset\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            return this.mCurrentBrowser.loadURIWithFlags(aURI, aFlags, aReferrerURI, aCharset);\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"goHome\\\">\\n-        <body>\\n-          <![CDATA[\\n-            return this.mCurrentBrowser.goHome();\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <property name=\\\"homePage\\\">\\n-        <getter>\\n-          <![CDATA[\\n-            return this.mCurrentBrowser.homePage;\\n-          ]]>\\n-        </getter>\\n-        <setter>\\n-          <![CDATA[\\n-            this.mCurrentBrowser.homePage = val;\\n-            return val;\\n-          ]]>\\n-        </setter>\\n-      </property>\\n-\\n-      <method name=\\\"gotoIndex\\\">\\n-        <parameter name=\\\"aIndex\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            return this.mCurrentBrowser.gotoIndex(aIndex);\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <method name=\\\"attachFormFill\\\">\\n-        <body><![CDATA[\\n-          for (var i = 0; i < this.mPanelContainer.childNodes.length; ++i) {\\n-            var cb = this.getBrowserAtIndex(i);\\n-            cb.attachFormFill();\\n-          }\\n-        ]]></body>\\n-      </method>\\n-\\n-      <method name=\\\"detachFormFill\\\">\\n-        <body><![CDATA[\\n-          for (var i = 0; i < this.mPanelContainer.childNodes.length; ++i) {\\n-            var cb = this.getBrowserAtIndex(i);\\n-            cb.detachFormFill();\\n-          }\\n-        ]]></body>\\n-      </method>\\n-\\n-      <property name=\\\"pageReport\\\"\\n-                onget=\\\"return this.mCurrentBrowser.pageReport;\\\"\\n-                readonly=\\\"true\\\"/>\\n-\\n-      <property name=\\\"currentURI\\\"\\n-                onget=\\\"return this.mCurrentBrowser.currentURI;\\\"\\n-                readonly=\\\"true\\\"/>\\n-\\n-      <field name=\\\"_fastFind\\\">null</field>\\n-      <property name=\\\"fastFind\\\"\\n-                readonly=\\\"true\\\">\\n-        <getter>\\n-        <![CDATA[\\n-          if (!this._fastFind) {\\n-            this._fastFind = Components.classes[\\\"@mozilla.org/typeaheadfind;1\\\"]\\n-                                       .createInstance(Components.interfaces.nsITypeAheadFind);\\n-            this._fastFind.init(this.docShell);\\n-          }\\n-          return this._fastFind;\\n-        ]]>\\n-        </getter>\\n-      </property>\\n-\\n-      <property name=\\\"docShell\\\"\\n-                onget=\\\"return this.mCurrentBrowser.docShell\\\"\\n-                readonly=\\\"true\\\"/>\\n-\\n-      <property name=\\\"webNavigation\\\"\\n-                onget=\\\"return this.mCurrentBrowser.webNavigation\\\"\\n-                readonly=\\\"true\\\"/>\\n-\\n-      <property name=\\\"webBrowserFind\\\"\\n-                readonly=\\\"true\\\"\\n-                onget=\\\"return this.mCurrentBrowser.webBrowserFind\\\"/>\\n-\\n-      <property name=\\\"webProgress\\\"\\n-                readonly=\\\"true\\\"\\n-                onget=\\\"return this.mCurrentBrowser.webProgress\\\"/>\\n-\\n-      <property name=\\\"contentWindow\\\"\\n-                readonly=\\\"true\\\"\\n-                onget=\\\"return this.mCurrentBrowser.contentWindow\\\"/>\\n-\\n-      <property name=\\\"sessionHistory\\\"\\n-                onget=\\\"return this.mCurrentBrowser.sessionHistory;\\\"\\n-                readonly=\\\"true\\\"/>\\n-\\n-      <property name=\\\"markupDocumentViewer\\\"\\n-                onget=\\\"return this.mCurrentBrowser.markupDocumentViewer;\\\"\\n-                readonly=\\\"true\\\"/>\\n-\\n-      <property name=\\\"contentViewerEdit\\\"\\n-                onget=\\\"return this.mCurrentBrowser.contentViewerEdit;\\\"\\n-                readonly=\\\"true\\\"/>\\n-\\n-      <property name=\\\"contentViewerFile\\\"\\n-                onget=\\\"return this.mCurrentBrowser.contentViewerFile;\\\"\\n-                readonly=\\\"true\\\"/>\\n-\\n-      <property name=\\\"documentCharsetInfo\\\"\\n-                onget=\\\"return this.mCurrentBrowser.documentCharsetInfo;\\\"\\n-                readonly=\\\"true\\\"/>\\n-\\n-      <property name=\\\"contentDocument\\\"\\n-                onget=\\\"return this.mCurrentBrowser.contentDocument;\\\"\\n-                readonly=\\\"true\\\"/>\\n-\\n-      <property name=\\\"contentTitle\\\"\\n-                onget=\\\"return this.mCurrentBrowser.contentTitle;\\\"\\n-                readonly=\\\"true\\\"/>\\n-\\n-      <property name=\\\"contentPrincipal\\\"\\n-                onget=\\\"return this.mCurrentBrowser.contentPrincipal;\\\"\\n-                readonly=\\\"true\\\"/>\\n-\\n-      <property name=\\\"securityUI\\\"\\n-                onget=\\\"return this.mCurrentBrowser.securityUI;\\\"\\n-                readonly=\\\"true\\\"/>\\n-\\n-      <method name=\\\"dragDropSecurityCheck\\\">\\n-        <parameter name=\\\"aEvent\\\"/>\\n-        <parameter name=\\\"aDragSession\\\"/>\\n-        <parameter name=\\\"aUri\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            nsDragAndDrop.dragDropSecurityCheck(aEvent, aDragSession, aUri);\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <field name=\\\"_keyEventHandler\\\" readonly=\\\"true\\\">\\n-      <![CDATA[({\\n-        tabbrowser: this,\\n-        handleEvent: function handleEvent(aEvent) {\\n-          if (!aEvent.isTrusted) {\\n-            // Don't let untrusted events mess with tabs.\\n-            return;\\n-          }\\n-\\n-          if (('shiftKey' in aEvent && aEvent.shiftKey) ||\\n-              ('altKey' in aEvent && aEvent.altKey))\\n-            return;\\n-#ifdef XP_MACOSX\\n-          if ('metaKey' in aEvent && aEvent.metaKey) {\\n-#else\\n-          if (('ctrlKey' in aEvent && aEvent.ctrlKey) &&\\n-              !('metaKey' in aEvent && aEvent.metaKey)) {\\n-            if (aEvent.keyCode == KeyEvent.DOM_VK_F4 &&\\n-                this.tabbrowser.mTabBox.handleCtrlPageUpDown) {\\n-              this.tabbrowser.removeCurrentTab();\\n-\\n-              aEvent.stopPropagation();\\n-              aEvent.preventDefault();\\n-              return;\\n-            }\\n-#endif\\n-            if (aEvent.target.localName == \\\"tabbrowser\\\") {\\n-              switch (aEvent.keyCode) {\\n-                case KeyEvent.DOM_VK_UP:\\n-                  this.tabbrowser.moveTabBackward();\\n-                  break;\\n-                case KeyEvent.DOM_VK_DOWN:\\n-                  this.tabbrowser.moveTabForward();\\n-                  break;\\n-                case KeyEvent.DOM_VK_RIGHT:\\n-                case KeyEvent.DOM_VK_LEFT:\\n-                  this.tabbrowser.moveTabOver(aEvent);\\n-                  break;\\n-                case KeyEvent.DOM_VK_HOME:\\n-                  this.tabbrowser.moveTabToStart();\\n-                  break;\\n-                case KeyEvent.DOM_VK_END:\\n-                  this.tabbrowser.moveTabToEnd();\\n-                  break;\\n-                default:\\n-                  // Stop the keypress event for the above keyboard\\n-                  // shortcuts only.\\n-                  return;\\n-              }\\n-              aEvent.stopPropagation();\\n-              aEvent.preventDefault();\\n-            }\\n-          }\\n-        }\\n-      })]]>\\n-      </field>\\n-\\n-      <property name=\\\"userTypedClear\\\"\\n-                onget=\\\"return this.mCurrentBrowser.userTypedClear;\\\"\\n-                onset=\\\"return this.mCurrentBrowser.userTypedClear = val;\\\"/>\\n-\\n-      <property name=\\\"userTypedValue\\\"\\n-                onget=\\\"return this.mCurrentBrowser.userTypedValue;\\\"\\n-                onset=\\\"return this.mCurrentBrowser.userTypedValue = val;\\\"/>\\n-\\n-      <method name=\\\"createTooltip\\\">\\n-        <parameter name=\\\"event\\\"/>\\n-        <body>\\n-          <![CDATA[\\n-            event.stopPropagation();\\n-            var tn = document.tooltipNode;\\n-            if (tn.localName != \\\"tab\\\")\\n-              return false; // Not a tab, so cancel the tooltip\\n-            if (\\\"mOverCloseButton\\\" in tn && tn.mOverCloseButton) {\\n-              event.target.setAttribute(\\\"label\\\", tn.getAttribute(\\\"closetabtext\\\"));\\n-              return true;\\n-            }\\n-            if (tn.hasAttribute(\\\"label\\\")) {\\n-              event.target.setAttribute(\\\"label\\\", tn.getAttribute(\\\"label\\\"));\\n-              return true;\\n-            }\\n-            return false;\\n-          ]]>\\n-        </body>\\n-      </method>\\n-\\n-      <constructor>\\n-        <![CDATA[\\n-          this.mCurrentBrowser = this.mPanelContainer.childNodes[0].firstChild;\\n-          this.mCurrentTab = this.mTabContainer.firstChild;\\n-          document.addEventListener(\\\"keypress\\\", this._keyEventHandler, false);\\n-\\n-          var uniqueId = \\\"panel\\\" + Date.now();\\n-          this.mPanelContainer.childNodes[0].id = uniqueId;\\n-          this.mTabContainer.childNodes[0].linkedPanel = uniqueId;\\n-          this.mTabContainer.childNodes[0]._tPos = 0;\\n-          this.mTabContainer.childNodes[0].linkedBrowser = this.mPanelContainer.childNodes[0].firstChild;\\n-\\n-          // set up the shared autoscroll popup\\n-          this._autoScrollPopup = this.mCurrentBrowser._createAutoScrollPopup();\\n-          this.appendChild(this._autoScrollPopup);\\n-          this.mCurrentBrowser.setAttribute(\\\"autoscrollpopup\\\", this._autoScrollPopup.id);\\n-        ]]>\\n-      </constructor>\\n-\\n-      <destructor>\\n-        <![CDATA[\\n-          for (var i = 0; i < this.mTabListeners.length; ++i) {\\n-            this.getBrowserAtIndex(i).webProgress.removeProgressListener(this.mTabFilters[i]);\\n-            this.mTabFilters[i].removeProgressListener(this.mTabListeners[i]);\\n-            this.mTabFilters[i] = null;\\n-            this.mTabListeners[i] = null;\\n-            this.getBrowserAtIndex(i).removeEventListener(\\\"DOMTitleChanged\\\", this.onTitleChanged, true);\\n-          }\\n-          document.removeEventListener(\\\"keypress\\\", this._keyEventHandler, false);\\n-        ]]>\\n-      </destructor>\\n-    </implementation>\\n-\\n-    <handlers>\\n-      <handler event=\\\"DOMLinkAdded\\\" phase=\\\"capturing\\\" action=\\\"this.onLinkAdded(event);\\\"/>\\n-\\n-      <handler event=\\\"DOMWindowClose\\\" phase=\\\"capturing\\\">\\n-        <![CDATA[\\n-          if (!event.isTrusted)\\n-            return;\\n-\\n-          const browsers = this.mPanelContainer.childNodes;\\n-          if (browsers.length == 1) {\\n-            // There's only one browser left. If a window is being\\n-            // closed and the window is *not* the window in the\\n-            // browser that's still around, prevent the event's default\\n-            // action to prevent closing a window that's being closed\\n-            // already.\\n-            if (this.getBrowserAtIndex(0).contentWindow != event.target)\\n-              event.preventDefault();\\n-\\n-            return;\\n-          }\\n-\\n-          var i = 0;\\n-          for (; i < browsers.length; ++i) {\\n-            if (this.getBrowserAtIndex(i).contentWindow == event.target) {\\n-              this.removeTab(this.mTabContainer.childNodes[i]);\\n-              event.preventDefault();\\n-\\n-              break;\\n-            }\\n-          }\\n-        ]]>\\n-      </handler>\\n-      <handler event=\\\"DOMWillOpenModalDialog\\\" phase=\\\"capturing\\\">\\n-        <![CDATA[\\n-          if (!event.isTrusted)\\n-            return;\\n-\\n-          // We're about to open a modal dialog, make sure the opening\\n-          // tab is brought to the front.\\n-\\n-          var targetTop = event.target.top;\\n-\\n-          for (var i = 0; i < browsers.length; ++i) {\\n-            if (this.getBrowserAtIndex(i).contentWindow == targetTop) {\\n-              this.selectedTab = this.mTabContainer.childNodes[i];\\n-\\n-              break;\\n-            }\\n-          }\\n-        ]]>\\n-      </handler>\\n-    </handlers>\\n-  </binding>\\n-\\n-  <binding id=\\\"tabbrowser-arrowscrollbox\\\" extends=\\\"chrome://global/content/bindings/scrollbox.xml#arrowscrollbox-clicktoscroll\\\">\\n-    <content>\\n-      <xul:toolbarbutton class=\\\"scrollbutton-up\\\" collapsed=\\\"true\\\"\\n-                         xbl:inherits=\\\"orient\\\"\\n-                         anonid=\\\"scrollbutton-up\\\"\\n-                         onmousedown=\\\"_startScroll(-1);\\\"\\n-                         onmouseup=\\\"_stopScroll();\\\"\\n-                         onmouseout=\\\"_stopScroll();\\\"\\n-                         chromedir=\\\"&locale.dir;\\\"/>\\n-      <xul:scrollbox xbl:inherits=\\\"orient,align,pack,dir\\\" flex=\\\"1\\\" anonid=\\\"scrollbox\\\">\\n-        <children/>\\n-      </xul:scrollbox>\\n-      <xul:stack align=\\\"center\\\" pack=\\\"end\\\" class=\\\"scrollbutton-down-stack\\\">\\n-        <xul:hbox flex=\\\"1\\\" class=\\\"scrollbutton-down-box\\\" \\n-                           collapsed=\\\"true\\\" anonid=\\\"down-box\\\"/>\\n-        <xul:hbox flex=\\\"1\\\" class=\\\"scrollbutton-down-box-animate\\\" \\n-                           collapsed=\\\"true\\\" anonid=\\\"down-box-animate\\\"/>\\n-        <xul:toolbarbutton class=\\\"scrollbutton-down\\\" collapsed=\\\"true\\\"\\n-                           xbl:inherits=\\\"orient\\\"\\n-                           anonid=\\\"scrollbutton-down\\\"\\n-                           onmousedown=\\\"_startScroll(1);\\\"\\n-                           onmouseup=\\\"_stopScroll();\\\"\\n-                           onmouseout=\\\"_stopScroll();\\\"\\n-                           chromedir=\\\"&locale.dir;\\\"/>\\n-      </xul:stack>\\n-    </content>\\n-    <implementation>\\n-      <field name=\\\"_scrollButtonDownBox\\\">\\n-        document.getAnonymousElementByAttribute(this, \\\"anonid\\\", \\\"down-box\\\");\\n-      </field>\\n-      <field name=\\\"_scrollButtonDownBoxAnimate\\\">\\n-        document.getAnonymousElementByAttribute(this, \\\"anonid\\\", \\\"down-box-animate\\\");\\n-      </field>\\n-    </implementation>\\n-    <handlers>\\n-      <handler event=\\\"underflow\\\"><![CDATA[\\n-        // filter underflow events which were dispatched on nested scrollboxes\\n-        if (event.target != this)\\n-          return;\\n-\\n-        // Ignore vertical events.\\n-        if (event.detail == 0) {\\n-          return;\\n-        }\\n-\\n-        this._scrollButtonDownBox.collapsed = true;\\n-        this._scrollButtonDownBoxAnimate.collapsed = true;\\n-      ]]></handler>\\n-\\n-      <handler event=\\\"overflow\\\"><![CDATA[\\n-        // filter underflow events which were dispatched on nested scrollboxes\\n-        if (event.target != this)\\n-          return;\\n-\\n-        // Ignore vertical events.\\n-        if (event.detail == 0) {\\n-          return;\\n-        }\\n-\\n-        this._scrollButtonDownBox.collapsed = false;\\n-        this._scrollButtonDownBoxAnimate.collapsed = false;\\n-      ]]></handler>\\n-\\n-      <handler event=\\\"UpdatedScrollButtonsDisabledState\\\"><![CDATA[\\n-        // filter underflow events which were dispatched on nested scrollboxes\\n-        if (event.target != this)\\n-          return;\\n-\\n-        // fix for bug #352353\\n-        // unlike the scrollup button on the tab strip (which is a \\n-        // simple toolbarbutton) the scrolldown button is \\n-        // a more complicated stack of boxes and a toolbarbutton\\n-        // so that we can animate when a tab is opened offscreen.\\n-        // in order to style the box with the actual background image\\n-        // we need to manually set the disable state to match the\\n-        // disable state of the toolbarbutton.\\n-        this._scrollButtonDownBox\\n-            .setAttribute(\\\"disabled\\\", this._scrollButtonDown.disabled);\\n-      ]]></handler>\\n-\\n-    </handlers>\\n-  </binding>\\n-\\n-  <binding id=\\\"tabbrowser-tabs\\\"\\n-           extends=\\\"chrome://global/content/bindings/tabbox.xml#tabs\\\">\\n-    <content>\\n-      <xul:arrowscrollbox anonid=\\\"arrowscrollbox\\\" class=\\\"tabbrowser-arrowscrollbox\\\" flex=\\\"1\\\"\\n-                          xbl:inherits=\\\"smoothscroll\\\" orient=\\\"horizontal\\\" style=\\\"min-width: 1px;\\\">\\n-        <children includes=\\\"tab\\\"/>\\n-      </xul:arrowscrollbox>\\n-      <xul:stack align=\\\"center\\\" pack=\\\"end\\\" class=\\\"tabs-alltabs-stack\\\">\\n-        <xul:hbox flex=\\\"1\\\" class=\\\"tabs-alltabs-box\\\" anonid=\\\"alltabs-box\\\"/>\\n-        <xul:hbox flex=\\\"1\\\" class=\\\"tabs-alltabs-box-animate\\\" \\n-                  anonid=\\\"alltabs-box-animate\\\"/>\\n-        <xul:toolbarbutton class=\\\"tabs-alltabs-button\\\" type=\\\"menu\\\"\\n-                           anonid=\\\"alltabs-button\\\"\\n-                           tooltipstring=\\\"&listAllTabs.label;\\\">\\n-          <xul:menupopup class=\\\"tabs-alltabs-popup\\\"\\n-                         anonid=\\\"alltabs-popup\\\" \\n-                         position=\\\"after_end\\\"/>\\n-        </xul:toolbarbutton>\\n-      </xul:stack>\\n-      <xul:hbox class=\\\"tabs-closebutton-box\\\" align=\\\"center\\\" pack=\\\"end\\\" anonid=\\\"tabstrip-closebutton\\\">\\n-        <xul:toolbarbutton class=\\\"close-button tabs-closebutton\\\"/>\\n-      </xul:hbox>\\n-    </content>\\n-    <implementation implements=\\\"nsITimerCallback, nsIDOMEventListener\\\">\\n-      <constructor>\\n-        <![CDATA[\\n-          var pb2 =\\n-              Components.classes['@mozilla.org/preferences-service;1'].\\n-              getService(Components.interfaces.nsIPrefBranch2);\\n-\\n-          try {\\n-            this.mTabMinWidth = pb2.getIntPref(\\\"browser.tabs.tabMinWidth\\\");\\n-          } catch (e) {\\n-          }\\n-          try {\\n-            this.mTabMaxWidth = pb2.getIntPref(\\\"browser.tabs.tabMaxWidth\\\");\\n-          } catch (e) {\\n-          }\\n-          try {\\n-            this.mTabClipWidth = pb2.getIntPref(\\\"browser.tabs.tabClipWidth\\\");\\n-          } catch (e) {\\n-          }\\n-          try {\\n-            this.mCloseButtons = pb2.getIntPref(\\\"browser.tabs.closeButtons\\\");\\n-          } catch (e) {\\n-          }\\n-\\n-          this.firstChild.minWidth = this.mTabMinWidth;\\n-          this.firstChild.maxWidth = this.mTabMaxWidth;\\n-          this.adjustTabstrip();\\n-\\n-          pb2.addObserver(\\\"browser.tabs.closeButtons\\\", \\n-                          this._prefObserver, false);\\n-\\n-          window.addEventListener(\\\"resize\\\", this, false);\\n-\\n-          // Listen to overflow/underflow events on the tabstrip,\\n-          // we cannot put these as xbl handlers on the entire binding because\\n-          // they would also get called for the all-tabs popup scrollbox.\\n-          // Also, we can't rely on event.target becuase these are all\\n-          // anonymous nodes.\\n-          this.mTabstrip.addEventListener(\\\"overflow\\\", this, false);\\n-          this.mTabstrip.addEventListener(\\\"underflow\\\", this, false);\\n-        ]]>\\n-      </constructor>\\n-\\n-      <destructor>\\n-        <![CDATA[\\n-          var pb2 =\\n-              Components.classes['@mozilla.org/preferences-service;1'].\\n-              getService(Components.interfaces.nsIPrefBranch2);\\n-          pb2.removeObserver(\\\"browser.tabs.closeButtons\\\", this._prefObserver);\\n-\\n-          // Release timer to avoid reference cycles.\\n-          if (this._animateTimer) {\\n-            this._animateTimer.cancel();\\n-            this._animateTimer = null;\\n-          }\\n-\\n-          this.mTabstrip.removeEventListener(\\\"overflow\\\", this, false);\\n-          this.mTabstrip.removeEventListener(\\\"underflow\\\", this, false);\\n-        ]]>\\n-      </destructor>\\n-\\n-      <field name=\\\"mTabstripWidth\\\">0</field>\\n-\\n-      <field name=\\\"mTabstrip\\\">\\n-        document.getAnonymousElementByAttribute(this, \\\"anonid\\\", \\\"arrowscrollbox\\\");\\n-      </field>\\n-\\n-      <field name=\\\"mTabstripClosebutton\\\">\\n-        document.getAnonymousElementByAttribute(this, \\\"anonid\\\", \\\"tabstrip-closebutton\\\");\\n-      </field>\\n-\\n-      <field name=\\\"_prefObserver\\\">({\\n-        tabbox: this,\\n-  \\n-        observe: function(subject, topic, data)\\n-        {\\n-          if (topic == \\\"nsPref:changed\\\") {\\n-            switch (data) {\\n-            case \\\"browser.tabs.closeButtons\\\":\\n-              subject.QueryInterface(Components.interfaces.nsIPrefBranch);\\n-              this.tabbox.mCloseButtons = subject.getIntPref(\\\"browser.tabs.closeButtons\\\");\\n-              this.tabbox.adjustTabstrip();\\n-              break;\\n-            }\\n-          }\\n-        },\\n-  \\n-        QueryInterface: function(aIID)\\n-        {\\n-          if (aIID.equals(Components.interfaces.nsIObserver) ||\\n-              aIID.equals(Components.interfaces.nsISupports))\\n-            return this;\\n-          throw Components.results.NS_NOINTERFACE;\\n-        }\\n-        });\\n-      </field>\\n-      <field name=\\\"mTabMinWidth\\\">100</field>\\n-      <field name=\\\"mTabMaxWidth\\\">250</field>\\n-      <field name=\\\"mTabClipWidth\\\">140</field>\\n-      <field name=\\\"mCloseButtons\\\">1</field>\\n-\\n-      <method name=\\\"adjustTabstrip\\\">\\n-        <body><![CDATA[\\n-          // modes for tabstrip\\n-          // 0 - activetab  = close button on active tab only\\n-          // 1 - alltabs    = close buttons on all tabs\\n-          // 2 - noclose    = no close buttons at all\\n-          // 3 - closeatend = close button at the end of the tabstrip\\n-          switch (this.mCloseButtons) {\\n-          case 0:\\n-            this.setAttribute(\\\"closebuttons\\\", \\\"activetab\\\");\\n-            break;\\n-          case 1:\\n-            var width = this.firstChild.boxObject.width;\\n-            // 0 width is an invalid value and indicates\\n-            // an item without display, so ignore.\\n-            if (width > this.mTabClipWidth || width == 0)\\n-              this.setAttribute(\\\"closebuttons\\\", \\\"alltabs\\\");\\n-            else\\n-              this.setAttribute(\\\"closebuttons\\\", \\\"activetab\\\");\\n-            break;\\n-          case 2:\\n-          case 3:\\n-            this.setAttribute(\\\"closebuttons\\\", \\\"noclose\\\");\\n-            break;\\n-          }\\n-          this.mTabstripClosebutton.collapsed = this.mCloseButtons != 3;\\n-        ]]></body>\\n-      </method>\\n-        \\n-      <field name=\\\"_mPrefs\\\">null</field>\\n-      <property name=\\\"mPrefs\\\" readonly=\\\"true\\\">\\n-        <getter>\\n-        <![CDATA[\\n-          if (!this._mPrefs) {\\n-            this._mPrefs =\\n-              Components.classes['@mozilla.org/preferences-service;1'].\\n-              getService(Components.interfaces.nsIPrefBranch2);\\n-          }\\n-          return this._mPrefs;\\n-        ]]>\\n-        </getter>\\n-      </property>\\n-        \\n-      <method name=\\\"_handleTabSelect\\\">\\n-        <body><![CDATA[\\n-          this.mTabstrip.ensureElementIsVisible(this.selectedItem);\\n-        ]]></body>\\n-      </method>\\n-\\n-      <method name=\\\"handleEvent\\\">\\n-        <parameter name=\\\"aEvent\\\"/>\\n-        <body><![CDATA[\\n-          switch (aEvent.type) {\\n-            case \\\"overflow\\\":\\n-              this.setAttribute(\\\"overflow\\\", \\\"true\\\");\\n-              this.mTabstrip.scrollBoxObject\\n-                            .ensureElementIsVisible(this.selectedItem);\\n-              break;\\n-            case \\\"underflow\\\":\\n-              this.removeAttribute(\\\"overflow\\\");\\n-              break;\\n-            case \\\"resize\\\":\\n-              var width = this.mTabstrip.boxObject.width;\\n-              if (width != this.mTabstripWidth) {\\n-                this.adjustTabstrip();\\n-                // XXX without this line the tab bar won't budge\\n-                this.mTabstrip.scrollByPixels(1);\\n-                this._handleTabSelect();\\n-                this.mTabstripWidth = width;\\n-              }\\n-              break;\\n-          }\\n-        ]]></body>\\n-      </method>\\n-\\n-      <field name=\\\"mAllTabsPopup\\\">\\n-        document.getAnonymousElementByAttribute(this, \\n-                                                \\\"anonid\\\", \\\"alltabs-popup\\\");\\n-      </field>\\n-\\n-      <field name=\\\"mAllTabsBoxAnimate\\\">\\n-        document.getAnonymousElementByAttribute(this, \\n-                                                \\\"anonid\\\",\\n-                                                \\\"alltabs-box-animate\\\");\\n-      </field>\\n-\\n-      <field name=\\\"mDownBoxAnimate\\\">\\n-        this.mTabstrip._scrollButtonDownBoxAnimate;\\n-      </field>\\n-\\n-      <field name=\\\"mAllTabsButton\\\">\\n-        document.getAnonymousElementByAttribute(this, \\n-                                                \\\"anonid\\\", \\\"alltabs-button\\\");\\n-      </field>\\n-\\n-      <field name=\\\"_animateTimer\\\">null</field>\\n-      <field name=\\\"_animateStep\\\">-1</field>\\n-      <field name=\\\"_animateDelay\\\">25</field>\\n-      <field name=\\\"_animatePercents\\\">\\n-       [1.00, 0.85, 0.80, 0.75, 0.71, 0.68, 0.65, 0.62, 0.59, 0.57,\\n-        0.54, 0.52, 0.50, 0.47, 0.45, 0.44, 0.42, 0.40, 0.38, 0.37,\\n-        0.35, 0.34, 0.32, 0.31, 0.30, 0.29, 0.28, 0.27, 0.26, 0.25,\\n-        0.24, 0.23, 0.23, 0.22, 0.22, 0.21, 0.21, 0.21, 0.20, 0.20,\\n-        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.19, 0.19, 0.19, 0.18,\\n-        0.18, 0.17, 0.17, 0.16, 0.15, 0.14, 0.13, 0.11, 0.09, 0.06]\\n-      </field>\\n-\\n-      <method name=\\\"_stopAnimation\\\">\\n-        <body><![CDATA[\\n-          if (this._animateStep != -1) {\\n-            if (this._animateTimer)\\n-              this._animateTimer.cancel();\\n-\\n-            this._animateStep = -1;\\n-            this.mAllTabsBoxAnimate.style.opacity = 0.0;\\n-            this.mDownBoxAnimate.style.opacity = 0.0;\\n-          }\\n-        ]]></body>\\n-      </method>\\n-      \\n-      <method name=\\\"_notifyBackgroundTab\\\">\\n-        <parameter name=\\\"aTab\\\"/>\\n-        <body><![CDATA[\\n-          var tsbo = this.mTabstrip.scrollBoxObject;\\n-          var tsboStart = tsbo.screenX;\\n-          var tsboEnd = tsboStart + tsbo.width;\\n-\\n-          var ctbo = aTab.boxObject;\\n-          var ctboStart = ctbo.screenX;\\n-          var ctboEnd = ctboStart + ctbo.width;\\n-\\n-          // only start the flash timer if the new tab (which was loaded in\\n-          // the background) is not completely visible\\n-          if (tsboStart > ctboStart || ctboEnd > tsboEnd) {\\n-            this._animateStep = 0;\\n-\\n-            if (!this._animateTimer) \\n-              this._animateTimer =\\n-                Components.classes[\\\"@mozilla.org/timer;1\\\"]\\n-                          .createInstance(Components.interfaces.nsITimer);\\n-            else\\n-               this._animateTimer.cancel();\\n-\\n-            this._animateTimer.initWithCallback(this,\\n-                         this._animateDelay,\\n-                         Components.interfaces.nsITimer.TYPE_REPEATING_SLACK);\\n-          }\\n-        ]]></body>\\n-      </method>\\n-      \\n-      <method name=\\\"notify\\\">\\n-        <parameter name=\\\"aTimer\\\"/>\\n-        <body><![CDATA[\\n-          if (!document)\\n-            aTimer.cancel();\\n-\\n-          var percent = this._animatePercents[this._animateStep];\\n-          this.mAllTabsBoxAnimate.style.opacity = percent;\\n-          this.mDownBoxAnimate.style.opacity = percent;\\n-\\n-          if (this._animateStep < (this._animatePercents.length - 1))\\n-            this._animateStep++;\\n-          else\\n-            this._stopAnimation();\\n-        ]]></body>\\n-      </method>\\n-    </implementation>\\n-    <handlers>\\n-      <handler event=\\\"TabSelect\\\" action=\\\"this._handleTabSelect();\\\"/>\\n-      <handler event=\\\"mouseover\\\"><![CDATA[\\n-        if (event.originalTarget == this.mAllTabsButton) {\\n-          this.mAllTabsButton\\n-              .setAttribute(\\\"tooltiptext\\\",\\n-                            this.mAllTabsButton.getAttribute(\\\"tooltipstring\\\"));\\n-        }\\n-        else\\n-          this.mAllTabsButton.removeAttribute(\\\"tooltiptext\\\");\\n-      ]]></handler>\\n-    </handlers>\\n-  </binding>\\n-\\n-  <!-- alltabs-popup binding\\n-       This binding relies on the structure of the tabbrowser binding.\\n-       Therefore it should only be used as a child of the tabs element.\\n-       This binding is exposed as a pseudo-public-API so themes can customize\\n-       the tabbar appearance without having to be scriptable\\n-       (see globalBindings.xml in Pinstripe for example).\\n-  -->\\n-  <binding id=\\\"tabbrowser-alltabs-popup\\\"\\n-           extends=\\\"chrome://global/content/bindings/popup.xml#popup\\\">\\n-    <implementation implements=\\\"nsIDOMEventListener\\\">\\n-      <field name=\\\"_xulWindow\\\">\\n-        null\\n-      </field>\\n-\\n-      <constructor><![CDATA[\\n-        // We cannot cache the XULBrowserWindow object itself since it might\\n-        // be set after this binding is constructed.\\n-        try {\\n-          this._xulWindow = \\n-            window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)\\n-                  .getInterface(Components.interfaces.nsIWebNavigation)\\n-                  .QueryInterface(Components.interfaces.nsIDocShellTreeItem)\\n-                  .treeOwner\\n-                  .QueryInterface(Components.interfaces.nsIInterfaceRequestor)\\n-                  .getInterface(Components.interfaces.nsIXULWindow);\\n-        }\\n-        catch(ex) { }\\n-      ]]></constructor>\\n-\\n-      <method name=\\\"_menuItemOnCommand\\\">\\n-        <parameter name=\\\"aEvent\\\"/>\\n-        <body><![CDATA[\\n-          var tabcontainer = document.getBindingParent(this);\\n-          tabcontainer.selectedItem = aEvent.target.tab;\\n-        ]]></body>\\n-      </method>\\n-\\n-      <method name=\\\"_tabOnAttrModified\\\">\\n-        <parameter name=\\\"aEvent\\\"/>\\n-        <body><![CDATA[\\n-          var menuItem = aEvent.target.mCorrespondingMenuitem;\\n-          if (menuItem) {\\n-            var attrName = aEvent.attrName;\\n-            switch (attrName) {\\n-              case \\\"label\\\":\\n-              case \\\"crop\\\":\\n-              case \\\"busy\\\":\\n-              case \\\"image\\\":\\n-              case \\\"selected\\\":\\n-                if (aEvent.attrChange == aEvent.REMOVAL)\\n-                  menuItem.removeAttribute(attrName);\\n-                else\\n-                  menuItem.setAttribute(attrName, aEvent.newValue);\\n-            }\\n-          }\\n-        ]]></body>\\n-      </method>\\n-\\n-      <method name=\\\"_tabOnTabClose\\\">\\n-        <parameter name=\\\"aEvent\\\"/>\\n-        <body><![CDATA[\\n-          var menuItem = aEvent.target.mCorrespondingMenuitem;\\n-          if (menuItem)\\n-            this.removeChild(menuItem);\\n-        ]]></body>\\n-      </method>\\n-\\n-      <method name=\\\"handleEvent\\\">\\n-        <parameter name=\\\"aEvent\\\"/>\\n-        <body><![CDATA[\\n-          if (!aEvent.isTrusted)\\n-            return;\\n-\\n-          switch (aEvent.type) {\\n-            case \\\"command\\\":\\n-              this._menuItemOnCommand(aEvent);\\n-              break;\\n-            case \\\"DOMAttrModified\\\":\\n-              this._tabOnAttrModified(aEvent);\\n-              break;\\n-            case \\\"TabClose\\\":\\n-              this._tabOnTabClose(aEvent);\\n-              break;\\n-            case \\\"TabOpen\\\":\\n-              this._createTabMenuItem(aEvent.originalTarget);\\n-              break;\\n-            case \\\"scroll\\\":\\n-              this._updateTabsVisibilityStatus();\\n-              break;\\n-          }\\n-        ]]></body>\\n-      </method>\\n-\\n-      <method name=\\\"_updateTabsVisibilityStatus\\\">\\n-        <body><![CDATA[\\n-          var tabContainer = document.getBindingParent(this);\\n-          // We don't want menu item decoration unless there is overflow.\\n-          if (tabContainer.getAttribute(\\\"overflow\\\") != \\\"true\\\")\\n-            return;\\n-\\n-          var tabstripBO = tabContainer.mTabstrip.scrollBoxObject;\\n-          for (var i = 0; i < this.childNodes.length; i++) {\\n-            var curTabBO = this.childNodes[i].tab.boxObject;\\n-            if (curTabBO.screenX >= tabstripBO.screenX &&\\n-                curTabBO.screenX + curTabBO.width <= tabstripBO.screenX + tabstripBO.width)\\n-              this.childNodes[i].setAttribute(\\\"tabIsVisible\\\", \\\"true\\\"); \\n-            else\\n-              this.childNodes[i].removeAttribute(\\\"tabIsVisible\\\");\\n-          }\\n-        ]]></body>\\n-      </method>\\n-\\n-      <method name=\\\"_createTabMenuItem\\\">\\n-        <parameter name=\\\"aTab\\\"/>\\n-        <body><![CDATA[\\n-          var menuItem = document.createElementNS(\\n-            \\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\", \\n-            \\\"menuitem\\\");\\n-\\n-          menuItem.setAttribute(\\\"class\\\", \\\"menuitem-iconic alltabs-item\\\");\\n-\\n-          menuItem.setAttribute(\\\"label\\\", aTab.label);\\n-          menuItem.setAttribute(\\\"crop\\\", aTab.getAttribute(\\\"crop\\\"));\\n-          menuItem.setAttribute(\\\"image\\\", aTab.getAttribute(\\\"image\\\"));\\n-\\n-          if (aTab.hasAttribute(\\\"busy\\\"))\\n-            menuItem.setAttribute(\\\"busy\\\", aTab.getAttribute(\\\"busy\\\"));\\n-          if (aTab.selected)\\n-            menuItem.setAttribute(\\\"selected\\\", \\\"true\\\");\\n-\\n-          // Keep some attributes of the menuitem in sync with its\\n-          // corresponding tab (e.g. the tab label)\\n-          aTab.mCorrespondingMenuitem = menuItem;\\n-          aTab.addEventListener(\\\"DOMAttrModified\\\", this, false);\\n-          aTab.addEventListener(\\\"TabClose\\\", this, false);\\n-          menuItem.tab = aTab;\\n-          menuItem.addEventListener(\\\"command\\\", this, false);\\n-\\n-          this.appendChild(menuItem);\\n-          return menuItem;\\n-        ]]></body>\\n-      </method>\\n-    </implementation>\\n-\\n-    <handlers>\\n-      <handler event=\\\"popupshowing\\\">\\n-      <![CDATA[\\n-        // set up the menu popup\\n-        var tabcontainer = document.getBindingParent(this);\\n-        var tabs = tabcontainer.childNodes;\\n-\\n-        // Listen for changes in the tab bar.\\n-        var tabbrowser = document.getBindingParent(tabcontainer);\\n-        tabbrowser.addEventListener(\\\"TabOpen\\\", this, false);\\n-        tabcontainer.mTabstrip.addEventListener(\\\"scroll\\\", this, false);\\n-\\n-        // if an animation is in progress and the user\\n-        // clicks on the \\\"all tabs\\\" button, stop the animation\\n-        tabcontainer._stopAnimation();\\n-\\n-        for (var i = 0; i < tabs.length; i++) {\\n-          this._createTabMenuItem(tabs[i]);\\n-        }\\n-        this._updateTabsVisibilityStatus();\\n-      ]]></handler>\\n-\\n-      <handler event=\\\"popuphiding\\\">\\n-      <![CDATA[\\n-        // clear out the menu popup and remove the listeners\\n-        while (this.hasChildNodes()) {\\n-          var menuItem = this.lastChild;\\n-          menuItem.removeEventListener(\\\"command\\\", this, false);\\n-          menuItem.tab.removeEventListener(\\\"DOMAttrModified\\\", this, false);\\n-          menuItem.tab.removeEventListener(\\\"TabClose\\\", this, false);\\n-          menuItem.tab.mCorrespondingMenuitem = null;\\n-          this.removeChild(menuItem);\\n-        }\\n-        var tabcontainer = document.getBindingParent(this);\\n-        tabcontainer.mTabstrip.removeEventListener(\\\"scroll\\\", this, false);\\n-        document.getBindingParent(tabcontainer).removeEventListener(\\\"TabOpen\\\", this, false);\\n-      ]]></handler>\\n-\\n-      <handler event=\\\"DOMMenuItemActive\\\">\\n-      <![CDATA[\\n-        if (!this._xulWindow || !this._xulWindow.XULBrowserWindow)\\n-          return;\\n-\\n-        var tab = event.target.tab;\\n-        if (tab) {\\n-          var statusText = tab.linkedBrowser.currentURI.spec;\\n-          if (statusText == \\\"about:blank\\\") {\\n-            // XXXhack: Passing a space here (and not \\\"\\\")\\n-            // to make sure the the browser implementation would\\n-            // still consider it a hovered link.\\n-            statusText = \\\" \\\";\\n-          }\\n-\\n-          this._xulWindow.XULBrowserWindow.setOverLink(statusText, null);\\n-        }\\n-      ]]></handler>\\n-\\n-      <handler event=\\\"DOMMenuItemInactive\\\">\\n-      <![CDATA[\\n-        if (!this._xulWindow || !this._xulWindow.XULBrowserWindow)\\n-          return;\\n-\\n-        this._xulWindow.XULBrowserWindow.setOverLink(\\\"\\\", null);\\n-      ]]></handler>\\n-    </handlers>\\n-  </binding>\\n-\\n-  <!-- close-tab-button binding\\n-       This binding relies on the structure of the tabbrowser binding.\\n-       Therefore it should only be used as a child of the tab or the tabs\\n-       element (in both cases, when they are anonymous nodes of <tabbrowser>).\\n-       This binding is exposed as a pseudo-public-API so themes can customize\\n-       the tabbar appearance without having to be scriptable\\n-       (see globalBindings.xml in Pinstripe for example).\\n-  -->\\n-  <binding id=\\\"tabbrowser-close-tab-button\\\"\\n-           extends=\\\"chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton-image\\\">\\n-    <handlers>\\n-      <handler event=\\\"click\\\" button=\\\"0\\\"><![CDATA[\\n-        var bindingParent = document.getBindingParent(this);\\n-        if (bindingParent) {\\n-          var tabbedBrowser = document.getBindingParent(bindingParent);\\n-          if (bindingParent.localName == \\\"tab\\\") {\\n-            /* The only sequence in which a second click event (i.e. dblclik)\\n-             * can be dispatched on an in-tab close button is when it is shown\\n-             * after the first click (i.e. the first click event was dispatched\\n-             * on the tab). This happens when we show the close button only on\\n-             * the active tab. (bug 352021)\\n-             * The only sequence in which a third click event can be dispatched\\n-             * on an in-tab close button is when the tab was opened with a\\n-             * double click on the tabbar. (bug 378344)\\n-             * In both cases, it is most likely that the close button area has\\n-             * been accidentally clicked, therefore we do not close the tab.\\n-             */\\n-            if (event.detail > 1)\\n-              return;\\n-\\n-            tabbedBrowser.removeTab(bindingParent);\\n-            tabbedBrowser._blockDblClick = true;\\n-\\n-            /* XXXmano hack (see bug 343628):\\n-             * Since we're removing the event target, if the user\\n-             * double-clicks this button, the dblclick event will be dispatched\\n-             * with the tabbar as its event target (and explicit/originalTarget),\\n-             * which treats that as a mouse gesture for opening a new tab.\\n-             * In this context, we're manually blocking the dblclick event\\n-             * (see onTabBarDblClick).\\n-             */\\n-            var clickedOnce = false;\\n-            function enableDblClick(event) {\\n-              if (event.detail == 1 && !clickedOnce) {\\n-                clickedOnce = true;\\n-                return;\\n-              }\\n-              setTimeout(function() {\\n-                tabbedBrowser._blockDblClick = false;\\n-              }, 0);\\n-              tabbedBrowser.removeEventListener(\\\"click\\\", enableDblClick, false);\\n-            }\\n-            tabbedBrowser.addEventListener(\\\"click\\\", enableDblClick, false);\\n-          }\\n-          else // \\\"tabs\\\"\\n-            tabbedBrowser.removeCurrentTab();\\n-        }\\n-      ]]></handler>\\n-      <handler event=\\\"dblclick\\\" button=\\\"0\\\" phase=\\\"capturing\\\">\\n-        // for the one-close-button case\\n-        event.stopPropagation();\\n-      </handler>\\n-    </handlers>\\n-  </binding>\\n-\\n-  <binding id=\\\"tabbrowser-tab\\\" display=\\\"xul:box\\\"\\n-           extends=\\\"chrome://global/content/bindings/tabbox.xml#tab\\\">\\n-    <content chromedir=\\\"&locale.dir;\\\"\\n-             closetabtext=\\\"&closeTab.label;\\\">\\n-      <xul:hbox class=\\\"tab-middle box-inherit\\\" xbl:inherits=\\\"align,dir,pack,orient,selected\\\" flex=\\\"1\\\">\\n-        <xul:image class=\\\"tab-icon\\\" xbl:inherits=\\\"validate,src=image\\\"/>\\n-        <xul:label class=\\\"tab-text\\\" xbl:inherits=\\\"value=label,accesskey,crop,disabled\\\" flex=\\\"1\\\"/>\\n-      </xul:hbox>\\n-      <xul:toolbarbutton anonid=\\\"close-button\\\" tabindex=\\\"-1\\\" class=\\\"tab-close-button\\\"/>\\n-    </content>\\n-\\n-    <implementation>\\n-      <field name=\\\"mOverCloseButton\\\">false</field>\\n-      <field name=\\\"mCorrespondingMenuitem\\\">null</field>\\n-    </implementation>\\n-\\n-    <handlers>\\n-      <handler event=\\\"mouseover\\\">\\n-        var anonid = event.originalTarget.getAttribute(\\\"anonid\\\");\\n-        if (anonid == \\\"close-button\\\")\\n-          this.mOverCloseButton = true;\\n-      </handler>\\n-      <handler event=\\\"mouseout\\\">\\n-        var anonid = event.originalTarget.getAttribute(\\\"anonid\\\");\\n-        if (anonid == \\\"close-button\\\")\\n-          this.mOverCloseButton = false;\\n-      </handler>\\n-      <handler event=\\\"mousedown\\\" button=\\\"0\\\" phase=\\\"capturing\\\">\\n-      <![CDATA[\\n-        if (this.mOverCloseButton)\\n-          event.stopPropagation();\\n-      ]]>\\n-      </handler>\\n-    </handlers>\\n-  </binding>\\n-\\n-</bindings>\\ndiff --git a/toolkit/themes/pinstripe/global/activetab-left.png b/toolkit/themes/pinstripe/global/activetab-left.png\\ndeleted file mode 100644\\nindex bb167c4..0000000\\nBinary files a/toolkit/themes/pinstripe/global/activetab-left.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/activetab-middle.png b/toolkit/themes/pinstripe/global/activetab-middle.png\\ndeleted file mode 100644\\nindex 3eba322..0000000\\nBinary files a/toolkit/themes/pinstripe/global/activetab-middle.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/activetab-right.png b/toolkit/themes/pinstripe/global/activetab-right.png\\ndeleted file mode 100644\\nindex 050d7fe..0000000\\nBinary files a/toolkit/themes/pinstripe/global/activetab-right.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/alltabs-box-bkgnd.png b/toolkit/themes/pinstripe/global/alltabs-box-bkgnd.png\\ndeleted file mode 100644\\nindex 22292d8..0000000\\nBinary files a/toolkit/themes/pinstripe/global/alltabs-box-bkgnd.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/alltabs-box-overflow-bkgnd-animate.png b/toolkit/themes/pinstripe/global/alltabs-box-overflow-bkgnd-animate.png\\ndeleted file mode 100755\\nindex f9092b6..0000000\\nBinary files a/toolkit/themes/pinstripe/global/alltabs-box-overflow-bkgnd-animate.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/alltabs-box-overflow-bkgnd.png b/toolkit/themes/pinstripe/global/alltabs-box-overflow-bkgnd.png\\ndeleted file mode 100644\\nindex bb941eb..0000000\\nBinary files a/toolkit/themes/pinstripe/global/alltabs-box-overflow-bkgnd.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/browser.css b/toolkit/themes/pinstripe/global/browser.css\\ndeleted file mode 100644\\nindex da98a66..0000000\\n--- a/toolkit/themes/pinstripe/global/browser.css\\n+++ /dev/null\\n@@ -1,400 +0,0 @@\\n-@namespace url(\\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\");\\n-\\n-.tabbrowser-tab:not([selected=\\\"true\\\"]):hover {\\n-  background: url(\\\"chrome://global/skin/tabbrowser-tabs-bkgnd.png\\\") repeat-x;\\n-}\\n-\\n-.tabbrowser-tab:hover > .tab-image-middle > .tab-icon > .tab-extra-status {\\n-  background: none;\\n-}\\n-\\n-.tab-icon-image {\\n-  width: 16px;\\n-  height: 16px;\\n-  list-style-image: url(\\\"chrome://global/skin/icons/small-globe-sunken.png\\\");\\n-}\\n-\\n-.tab-icon {\\n-  padding-top: 1px;\\n-  margin: 2px 0px 1px 0px;\\n-}\\n-\\n-.tab-text {\\n-  font: icon;\\n-  padding-top: 1px;\\n-  margin-top: 2px !important;\\n-}\\n-\\n-.tabbrowser-tab[busy] > .tab-icon-image,\\n-.tabbrowser-tab[busy] > .tab-image-middle > .tab-icon > .tab-icon-image {\\n- list-style-image: url(\\\"chrome://global/skin/icons/loading_16_grey.gif\\\") !important; \\n-}\\n-\\n-.tabbrowser-tab {\\n-  -moz-binding: url(\\\"chrome://global/skin/globalBindings.xml#tabbrowser-tab\\\") !important;\\n-  -moz-appearance: none;\\n-  color: #383838;\\n-  -moz-box-pack: center;\\n-  margin: 2px 0px 3px 0px;\\n-  padding: 0px;\\n-  border: none !important;\\n-  height: 22px !important;\\n-  min-width: 1px !important;\\n-  text-align: center;\\n-}\\n-\\n-.tabbrowser-tab[selected=\\\"true\\\"] {\\n-  -moz-user-focus: normal;\\n-}\\n-\\n-.tabbrowser-tab[selected=\\\"true\\\"] > .tab-image-middle > .tab-icon {\\n-  cursor: -moz-grab;\\n-}\\n-\\n-.tabbrowser-tab > .tab-image-middle > .tab-text {\\n-  border: 1.4pt solid transparent;\\n-}\\n-\\n-.tabbrowser-tab:focus > .tab-image-middle > .tab-text {\\n-  border: 1.4pt solid -moz-mac-focusring;\\n-}\\n-\\n-.tabbrowser-tab[selected=\\\"true\\\"], .tabbrowser-tab:hover {\\n-  color: #000000;\\n-}\\n-\\n-.tabbrowser-tab[first-tab=\\\"true\\\"] > .tab-image-left {\\n-  margin-left: 3px !important;\\n-}\\n-\\n-.tab-image-left, .tab-image-right {\\n-  width: 8px;\\n-  margin: 0px;\\n-  padding: 0px;\\n-}\\n-\\n-.tabbrowser-tab > .tab-image-right {\\n-  background: url(\\\"chrome://global/skin/tab-right.png\\\") no-repeat;\\n-}\\n-\\n-.tabbrowser-tab:not([selected=\\\"true\\\"]) > .tab-image-right {\\n-  background: url(\\\"chrome://global/skin/tab-right-bkgnd.png\\\") no-repeat;\\n-  margin-bottom: 1px;\\n-}\\n-\\n-.tabbrowser-tab:hover:not([selected=\\\"true\\\"]) > .tab-image-right {\\n-  background: url(\\\"chrome://global/skin/tab-right-hover.png\\\") no-repeat;\\n-}\\n-\\n-.tabbrowser-tab > .tab-image-left {\\n-  background: url(\\\"chrome://global/skin/tab-left.png\\\") no-repeat;\\n-}\\n-\\n-.tabbrowser-tab:not([selected=\\\"true\\\"]) > .tab-image-left {\\n-  background: url(\\\"chrome://global/skin/tab-left-bkgnd.png\\\") no-repeat;\\n-  margin-bottom: 1px;\\n-}\\n-\\n-.tabbrowser-tab:hover:not([selected=\\\"true\\\"]) > .tab-image-left {\\n-  background: url(\\\"chrome://global/skin/tab-left-hover.png\\\") no-repeat;\\n-}\\n-\\n-.tabbrowser-tab > .tab-image-middle {\\n-  background: url(\\\"chrome://global/skin/tab-middle.png\\\") repeat-x;\\n-  -moz-box-flex: 0 !important;\\n-}\\n-\\n-.tabbrowser-tab:not([selected=\\\"true\\\"]) > .tab-image-middle {\\n-  background: url(\\\"chrome://global/skin/tab-middle-bkgnd.png\\\");\\n-  margin-bottom: 1px;\\n-}\\n-\\n-.tabbrowser-tab:hover:not([selected=\\\"true\\\"]) > .tab-image-middle {\\n-  background: url(\\\"chrome://global/skin/tab-middle-hover.png\\\");\\n-}\\n-\\n-.tabbrowser-tab:not([selected=\\\"true\\\"]) > .tab-image-middle > .tab-icon > .tab-icon-image  {\\n-  list-style-image: url(\\\"chrome://global/skin/icons/small-globe-sunken-grey.png\\\");\\n-}\\n-\\n-/* ::::: close button ::::: */\\n-/**\\n- * XXXben - this looks like something added specifically for tabbrowser.\\n- *       if it turns out no one uses this that can't easily be evangelized to\\n- *       use their own roll-your-own binding, then we should get rid of this\\n- *       to tighten up the toolkit api. This binding made obsolete in Firefox\\n- *       by 308396. \\n- */\\n-.tabs-closebutton {\\n-  padding: 0px 4px 2px 0px;\\n-  margin: 0px;\\n-  list-style-image: url(\\\"chrome://global/skin/icons/closetab.png\\\") !important;\\n-  border: none !important;\\n-}\\n-\\n-.tabs-closebutton:hover {\\n-  list-style-image: url(\\\"chrome://global/skin/icons/closetab-hover.png\\\") !important;\\n-  border: none !important;\\n-}\\n-\\n-.tabs-closebutton:hover:active {\\n-  list-style-image: url(\\\"chrome://global/skin/icons/closetab-active.png\\\") !important;\\n-  border: none !important;\\n-}\\n-\\n-.tabbrowser-strip {\\n-  -moz-box-orient: vertical !important;\\n-  -moz-appearance: dialog;\\n-}\\n-\\n-.tabbrowser-tabs {\\n-  -moz-binding: url(\\\"chrome://global/skin/globalBindings.xml#tabbrowser-tabs\\\");\\n-  border: none;\\n-  padding: 0;\\n-  margin: 0;\\n-  -moz-box-pack: center;\\n-  -moz-box-align: center;\\n-  background: url(\\\"chrome://global/skin/tabbrowser-tabs-bkgnd.png\\\") repeat-x;\\n-}\\n-\\n-.tab-image-right, .tab-image-left {\\n-  height: 18px !important;\\n-}\\n-\\n-.tabs-bottom {\\n-  border: none;\\n-  height: 4px !important;\\n-  background: url(\\\"chrome://global/skin/tabs-bottom-bg.png\\\") repeat !important;\\n-  margin: 0px !important;\\n-}\\n-\\n-tabbrowser > tabbox > tabpanels {\\n-  -moz-appearance: none !important;\\n-}\\n-\\n-.tab-drop-indicator-bar {\\n-   visibility: hidden;\\n-   height: 9px;\\n-   margin-top: -9px;\\n-   position: relative;\\n-}\\n-\\n-.tab-drop-indicator {\\n-   height: 9px;\\n-   width: 9px;\\n-   margin-bottom: -5px;\\n-   position: relative;\\n-   background: url('chrome://global/skin/tabDragDrop/tabDragIndicator.png') 50% 50% no-repeat;\\n-}\\n-\\n-.tab-drop-indicator-bar[dragging=\\\"true\\\"] {\\n-   visibility: visible;\\n-}\\n-\\n-/**\\n- * In-tab close button\\n- */\\n-.tab-close-button > .toolbarbutton-icon {\\n-  -moz-margin-end: 0px !important;\\n-  margin-top: 2px;\\n-}\\n-\\n-.tab-close-button {\\n-  list-style-image: url(\\\"chrome://global/skin/icons/closetab.png\\\");\\n-  -moz-appearance: none;\\n-  border: none !important;\\n-  padding: 0px;\\n-  background: inherit;\\n-  cursor: default;\\n-}\\n-\\n-.tab-close-button:hover,\\n-.tabbrowser-tab[selected=\\\"true\\\"] > .tab-close-button:hover {\\n-  list-style-image: url(\\\"chrome://global/skin/icons/closetab-hover.png\\\");\\n-}\\n-\\n-.tab-close-button:hover:active,\\n-.tabbrowser-tab[selected=\\\"true\\\"] > .tab-close-button:hover:active {\\n-  list-style-image: url(\\\"chrome://global/skin/icons/closetab-active.png\\\");\\n-}\\n-\\n-.tabbrowser-tab > .tab-close-button {\\n-  background-image: url(\\\"chrome://global/skin/tab-middle.png\\\");\\n-  background-repeat: repeat-x;\\n-  -moz-margin-start: -5px;\\n-  -moz-margin-end: -1px;\\n-  -moz-padding-end: 0px;\\n-}\\n-\\n-.tabbrowser-tab[selected=\\\"true\\\"] > .tab-close-button {\\n-  /* Make this button focusable so clicking on it will not focus the tab while\\n-     it's getting closed */\\n-  -moz-user-focus: normal;\\n-}\\n-\\n-.tabbrowser-tab:not([selected=\\\"true\\\"]) > .tab-close-button {\\n-  background-image: url(\\\"chrome://global/skin/tab-middle-bkgnd.png\\\");\\n-  margin-bottom: 1px;\\n-}\\n-\\n-.tabbrowser-tab:not([selected=\\\"true\\\"]):hover > .tab-close-button {\\n-  background-image: url(\\\"chrome://global/skin/tab-middle-hover.png\\\");\\n-}\\n-\\n-/**\\n- * Tab Scrollbox Arrow Buttons\\n- */\\n-\\n-.tabbrowser-arrowscrollbox > .scrollbutton-up {\\n-  width: 18px;\\n-  height: 18px;\\n-  margin: 2px 0px 3px 0px;\\n-  padding-left: 0;\\n-  padding-right: 0;\\n-  border: none;\\n-  list-style-image: url(\\\"chrome://global/skin/tab-arrow-start.png\\\");\\n-  background-image: url(\\\"chrome://global/skin/tab-arrow-start-bkgnd.png\\\");\\n-  background-repeat: no-repeat;\\n-  -moz-image-region: rect(0, 11px, 14px, 0);\\n-  opacity: 0.65;\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > .scrollbutton-up[disabled=\\\"true\\\"] {\\n-  -moz-image-region: rect(0, 33px, 14px, 22px);\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > .scrollbutton-up:not([disabled=\\\"true\\\"]):hover {\\n-  -moz-image-region: rect(0, 22px, 14px, 11px);\\n-  opacity: 1.0;\\n-}\\n- \\n-.tabbrowser-arrowscrollbox > .scrollbutton-up:not([disabled=\\\"true\\\"]):hover:active {\\n-  -moz-image-region: rect(0, 44px, 14px, 33px);\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > .scrollbutton-up > .toolbarbutton-icon {\\n-  margin-top: 4px;\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > stack > .scrollbutton-down-box {\\n-  margin: 2px 0px 3px 0px;\\n-  width: 18px;\\n-  height: 18px;\\n-  background-image: url(\\\"chrome://global/skin/tab-arrow-end-bkgnd.png\\\") !important;\\n-  background-repeat: no-repeat;\\n-  opacity: 0.65;\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > stack > .scrollbutton-down-box-animate {\\n-  margin: 2px 0px 3px 0px;\\n-  width: 18px;\\n-  height: 18px;\\n-  background-image: url(\\\"chrome://global/skin/tab-arrow-end-bkgnd-animate.png\\\") !important;\\n-  background-repeat: no-repeat;\\n-  opacity: 0.0;\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > stack > .scrollbutton-down {\\n-  margin: 2px 0px 3px 0px;\\n-  width: 18px;\\n-  height: 18px;\\n-  padding-left: 0;\\n-  padding-right: 0;\\n-  border: none;\\n-  list-style-image: url(\\\"chrome://global/skin/tab-arrow-end.png\\\") !important;\\n-  -moz-image-region: rect(0, 11px, 14px, 0);\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > stack > .scrollbutton-down[disabled=\\\"true\\\"] {\\n-  -moz-image-region: rect(0, 33px, 14px, 22px);\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > stack > .scrollbutton-down:not([disabled=\\\"true\\\"]):hover {\\n-  background-image: url(\\\"chrome://global/skin/tab-arrow-end-bkgnd.png\\\") !important;\\n-  background-repeat: no-repeat;\\n-  -moz-image-region: rect(0, 22px, 14px, 11px);\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > stack > .scrollbutton-down:not([disabled=\\\"true\\\"]):hover:active {\\n-  -moz-image-region: rect(0, 44px, 14px, 33px);\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > stack > .scrollbutton-down > .toolbarbutton-icon {\\n-  margin-top: 4px;\\n-  -moz-margin-start: 1px;\\n-}\\n-\\n-/**\\n- * All Tabs Button\\n- */\\n-\\n-.tabs-alltabs-box {\\n-  margin: 2px 0px 3px 0px;\\n-  width: 16px;\\n-  height: 18px;\\n-  background-image: url(\\\"chrome://global/skin/alltabs-box-bkgnd.png\\\");\\n-  background-repeat: no-repeat;\\n-  opacity: 0.65;\\n-}\\n-\\n-.tabbrowser-tabs[overflow=\\\"true\\\"] .tabs-alltabs-box {\\n-  background-image: url(\\\"chrome://global/skin/alltabs-box-overflow-bkgnd.png\\\");\\n-}\\n-\\n-.tabs-alltabs-button {\\n-  margin: 2px 0px 3px 0px;\\n-  width: 16px;\\n-  height: 18px;\\n-  padding-left: 0;\\n-  padding-right: 0;\\n-  border: none;\\n-}\\n-\\n-.tabs-alltabs-button  > .toolbarbutton-menu-dropmarker {\\n-  margin-right: 2px;\\n-  margin-top: 4px;\\n-}\\n-\\n-.tabs-alltabs-button  > .toolbarbutton-text {\\n-  display: none;\\n-}\\n-\\n-.tabs-alltabs-button > .toolbarbutton-icon {\\n-  -moz-margin-end: 2px;\\n-}\\n-\\n-.tabs-alltabs-button:hover {\\n-  margin: 2px 0px 3px 0px;\\n-  background-image: url(\\\"chrome://global/skin/alltabs-box-bkgnd.png\\\");\\n-  background-repeat: no-repeat;\\n-  opacity: 1.0;\\n-}\\n-\\n-.tabbrowser-tabs[overflow=\\\"true\\\"] .tabs-alltabs-button:hover {\\n-  background-image: url(\\\"chrome://global/skin/alltabs-box-overflow-bkgnd.png\\\");\\n-}\\n-\\n-.tabs-alltabs-box-animate {\\n-  margin: 2px 0px 3px 0px;\\n-  width: 16px;\\n-  height: 18px;\\n-  background-image: url(\\\"chrome://global/skin/alltabs-box-overflow-bkgnd-animate.png\\\");\\n-  background-repeat: no-repeat;\\n-  opacity: 0.0;\\n-}\\n-\\n-/**\\n- * All Tabs Menupopup \\n- */\\n-\\n-.alltabs-item > .menu-iconic-left > .menu-iconic-icon {\\n-  list-style-image: url(\\\"chrome://global/skin/icons/small-globe-sunken.png\\\");\\n-}\\n-\\n-.alltabs-item[selected=\\\"true\\\"] {\\n-  font-weight: bold;\\n-}\\n-\\n-.alltabs-item[busy] > .menu-iconic-left > .menu-iconic-icon {\\n-  list-style-image: url(\\\"chrome://global/skin/icons/loading_16_grey.gif\\\") !important;\\n-}\\ndiff --git a/toolkit/themes/pinstripe/global/globalBindings.xml b/toolkit/themes/pinstripe/global/globalBindings.xml\\ndeleted file mode 100644\\nindex 1a60d3b..0000000\\n--- a/toolkit/themes/pinstripe/global/globalBindings.xml\\n+++ /dev/null\\n@@ -1,69 +0,0 @@\\n-<?xml version=\\\"1.0\\\"?>\\n-\\n-<!DOCTYPE bindings [\\n-<!ENTITY % tabBrowserDTD SYSTEM \\\"chrome://global/locale/tabbrowser.dtd\\\" >\\n-%tabBrowserDTD;\\n-<!ENTITY % globalDTD SYSTEM \\\"chrome://global/locale/global.dtd\\\">\\n-%globalDTD;\\n-]>\\n-\\n-<bindings id=\\\"globalBindings\\\"\\n-   xmlns=\\\"http://www.mozilla.org/xbl\\\"\\n-   xmlns:xul=\\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\"\\n-   xmlns:xbl=\\\"http://www.mozilla.org/xbl\\\">\\n-\\n-  <binding id=\\\"tabbrowser-tab\\\" extends=\\\"chrome://global/content/bindings/tabbrowser.xml#tabbrowser-tab\\\">\\n-    <content chromedir=\\\"&locale.dir;\\\"\\n-             closetabtext=\\\"&closeTab.label;\\\">\\n-      <xul:hbox class=\\\"tab-image-left\\\" xbl:inherits=\\\"selected\\\"/>\\n-      <xul:hbox flex=\\\"1\\\" class=\\\"tab-image-middle\\\" align=\\\"center\\\" xbl:inherits=\\\"selected\\\">\\n-        <xul:stack class=\\\"tab-icon\\\">\\n-          <xul:image xbl:inherits=\\\"validate,src=image\\\" class=\\\"tab-icon-image\\\"/>\\n-          <xul:image class=\\\"tab-extra-status\\\"/>\\n-        </xul:stack>\\n-        <xul:label flex=\\\"1\\\" xbl:inherits=\\\"value=label,crop,accesskey\\\" crop=\\\"right\\\" class=\\\"tab-text\\\"/>\\n-      </xul:hbox>\\n-      <xul:toolbarbutton anonid=\\\"close-button\\\" class=\\\"tab-close-button\\\" tabindex=\\\"-1\\\"/>\\n-        <xul:hbox class=\\\"tab-image-right\\\" xbl:inherits=\\\"selected\\\"/>\\n-    </content>\\n-  </binding>\\n-  \\n-   <binding id=\\\"tabbrowser-tabs\\\"  \\n-            extends=\\\"chrome://global/content/bindings/tabbrowser.xml#tabbrowser-tabs\\\">\\n-    <content>\\n-      <xul:stack flex=\\\"1\\\" class=\\\"tabs-stack\\\">\\n-        <xul:vbox>\\n-          <xul:spacer flex=\\\"1\\\"/>\\n-          <xul:hbox class=\\\"tabs-bottom\\\" align=\\\"center\\\"/>\\n-        </xul:vbox>\\n-        <xul:vbox>\\n-          <xul:hbox>\\n-            <xul:stack>\\n-              <xul:spacer class=\\\"tabs-left\\\"/>\\n-            </xul:stack>\\n-            <xul:arrowscrollbox anonid=\\\"arrowscrollbox\\\" orient=\\\"horizontal\\\" flex=\\\"1\\\" style=\\\"min-width: 1px;\\\" class=\\\"tabbrowser-arrowscrollbox\\\">\\n-              <children/>\\n-            </xul:arrowscrollbox>\\n-            <xul:stack align=\\\"center\\\" pack=\\\"end\\\">\\n-              <xul:hbox flex=\\\"1\\\" class=\\\"tabs-alltabs-box\\\" \\n-                        anonid=\\\"alltabs-box\\\"/>\\n-              <xul:hbox flex=\\\"1\\\" class=\\\"tabs-alltabs-box-animate\\\" \\n-                        anonid=\\\"alltabs-box-animate\\\"/>\\n-              <xul:toolbarbutton class=\\\"tabs-alltabs-button\\\"\\n-                                 type=\\\"menu\\\"\\n-                                 anonid=\\\"alltabs-button\\\"\\n-                                 tooltipstring=\\\"&listAllTabs.label;\\\">\\n-                <xul:menupopup class=\\\"tabs-alltabs-popup\\\"\\n-                               anonid=\\\"alltabs-popup\\\" position=\\\"after_end\\\"/>\\n-              </xul:toolbarbutton>\\n-            </xul:stack>\\n-            <xul:hbox class=\\\"tabs-closebutton-box\\\" align=\\\"center\\\" pack=\\\"end\\\" anonid=\\\"tabstrip-closebutton\\\">\\n-              <xul:toolbarbutton class=\\\"close-button tabs-closebutton\\\"/>\\n-            </xul:hbox>\\n-          </xul:hbox>\\n-          <xul:spacer class=\\\"tabs-bottom-spacer\\\"/>\\n-        </xul:vbox>\\n-      </xul:stack>\\n-    </content>\\n-  </binding>\\n-</bindings>\\ndiff --git a/toolkit/themes/pinstripe/global/inactive-icon-black.png b/toolkit/themes/pinstripe/global/inactive-icon-black.png\\ndeleted file mode 100644\\nindex da6e3e3..0000000\\nBinary files a/toolkit/themes/pinstripe/global/inactive-icon-black.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/inactivetab-icon-black.png b/toolkit/themes/pinstripe/global/inactivetab-icon-black.png\\ndeleted file mode 100644\\nindex 6054608..0000000\\nBinary files a/toolkit/themes/pinstripe/global/inactivetab-icon-black.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/inactivetab-icon-grey.png b/toolkit/themes/pinstripe/global/inactivetab-icon-grey.png\\ndeleted file mode 100644\\nindex 1f9aca1..0000000\\nBinary files a/toolkit/themes/pinstripe/global/inactivetab-icon-grey.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/inactivetab-left.png b/toolkit/themes/pinstripe/global/inactivetab-left.png\\ndeleted file mode 100644\\nindex ab0c430..0000000\\nBinary files a/toolkit/themes/pinstripe/global/inactivetab-left.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/inactivetab-right.png b/toolkit/themes/pinstripe/global/inactivetab-right.png\\ndeleted file mode 100644\\nindex a5306d6..0000000\\nBinary files a/toolkit/themes/pinstripe/global/inactivetab-right.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tab-arrow-end-bkgnd-animate.png b/toolkit/themes/pinstripe/global/tab-arrow-end-bkgnd-animate.png\\ndeleted file mode 100755\\nindex 9218b0f..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tab-arrow-end-bkgnd-animate.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tab-arrow-end-bkgnd.png b/toolkit/themes/pinstripe/global/tab-arrow-end-bkgnd.png\\ndeleted file mode 100644\\nindex 93bd39c..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tab-arrow-end-bkgnd.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tab-arrow-end.png b/toolkit/themes/pinstripe/global/tab-arrow-end.png\\ndeleted file mode 100644\\nindex 4447bba..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tab-arrow-end.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tab-arrow-start-bkgnd-animate.png b/toolkit/themes/pinstripe/global/tab-arrow-start-bkgnd-animate.png\\ndeleted file mode 100755\\nindex 6ea7576..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tab-arrow-start-bkgnd-animate.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tab-arrow-start-bkgnd.png b/toolkit/themes/pinstripe/global/tab-arrow-start-bkgnd.png\\ndeleted file mode 100644\\nindex 740043b..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tab-arrow-start-bkgnd.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tab-arrow-start.png b/toolkit/themes/pinstripe/global/tab-arrow-start.png\\ndeleted file mode 100644\\nindex 7d12a97..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tab-arrow-start.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tab-left-bkgnd.png b/toolkit/themes/pinstripe/global/tab-left-bkgnd.png\\ndeleted file mode 100755\\nindex 367f9a7..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tab-left-bkgnd.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tab-left-hover.png b/toolkit/themes/pinstripe/global/tab-left-hover.png\\ndeleted file mode 100755\\nindex 2ed0764..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tab-left-hover.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tab-left.png b/toolkit/themes/pinstripe/global/tab-left.png\\ndeleted file mode 100644\\nindex 7a93dc0..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tab-left.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tab-middle-bkgnd.png b/toolkit/themes/pinstripe/global/tab-middle-bkgnd.png\\ndeleted file mode 100755\\nindex b83a381..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tab-middle-bkgnd.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tab-middle-hover.png b/toolkit/themes/pinstripe/global/tab-middle-hover.png\\ndeleted file mode 100755\\nindex b18dbdd..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tab-middle-hover.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tab-middle.png b/toolkit/themes/pinstripe/global/tab-middle.png\\ndeleted file mode 100644\\nindex c161fa4..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tab-middle.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tab-right-bkgnd.png b/toolkit/themes/pinstripe/global/tab-right-bkgnd.png\\ndeleted file mode 100755\\nindex 96d49ce..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tab-right-bkgnd.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tab-right-hover.png b/toolkit/themes/pinstripe/global/tab-right-hover.png\\ndeleted file mode 100755\\nindex db9d4af..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tab-right-hover.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tab-right.png b/toolkit/themes/pinstripe/global/tab-right.png\\ndeleted file mode 100644\\nindex 9ff1d66..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tab-right.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tabDragDrop/tabDragIndicator.png b/toolkit/themes/pinstripe/global/tabDragDrop/tabDragIndicator.png\\ndeleted file mode 100755\\nindex c50c408..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tabDragDrop/tabDragIndicator.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tabbrowser-tabs-bkgnd.png b/toolkit/themes/pinstripe/global/tabbrowser-tabs-bkgnd.png\\ndeleted file mode 100644\\nindex 60734b8..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tabbrowser-tabs-bkgnd.png and /dev/null differ\\ndiff --git a/toolkit/themes/pinstripe/global/tabs-bottom-bg.png b/toolkit/themes/pinstripe/global/tabs-bottom-bg.png\\ndeleted file mode 100644\\nindex f3d739d..0000000\\nBinary files a/toolkit/themes/pinstripe/global/tabs-bottom-bg.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/browser.css b/toolkit/themes/winstripe/global/browser.css\\ndeleted file mode 100644\\nindex 64db7cb..0000000\\n--- a/toolkit/themes/winstripe/global/browser.css\\n+++ /dev/null\\n@@ -1,475 +0,0 @@\\n-\\n-@namespace url(\\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\");\\n-\\n-/**\\n- * Tabbrowser Tabs\\n- */\\n-\\n-.tabbrowser-tabs {\\n-  -moz-binding: url(\\\"chrome://global/skin/globalBindings.xml#tabbrowser-tabs\\\") !important;\\n-  padding-top: 0px;\\n-  background: -moz-dialog url(\\\"chrome://global/skin/icons/tabbrowser-tabs-bkgnd.png\\\") !important;\\n-  -moz-padding-start: 0px;\\n-}\\n-\\n-.tabbrowser-tabs[overflow=\\\"true\\\"] {\\n-  -moz-padding-start: 0px;\\n-}\\n-\\n-/**\\n- * Tab\\n- */\\n-\\n-.tabbrowser-tab {\\n-  -moz-appearance: none !important;\\n-  -moz-binding: url(\\\"chrome://global/skin/globalBindings.xml#tabbrowser-tab\\\") !important;\\n-  background: transparent !important;\\n-  margin: 0px 0px 1px !important;\\n-  padding: 0px !important;\\n-  border: none !important;\\n-  height: 22px !important;\\n-}\\n-\\n-.tabbrowser-tab > .tab-image-middle {\\n-  padding-top: 1px;\\n-  -moz-padding-start: 1px;\\n-}\\n-\\n-.tabbrowser-tab[busy] > .tab-image-middle > .tab-icon > .tab-icon-image {\\n-  list-style-image: url(\\\"chrome://global/skin/throbber/Throbber-small.gif\\\") !important;\\n-  opacity: 0.6;\\n-}\\n-\\n-.tabbrowser-tab[selected=\\\"true\\\"] {\\n-  font-weight: bold;\\n-}\\n-\\n-.tabbrowser-tab[selected=\\\"true\\\"] > .tab-image-middle > .tab-icon {\\n-  cursor: -moz-grab;\\n-}\\n-\\n-.tabbrowser-tab > .tab-image-left {\\n-  width: 8px;\\n-  height: 24px;\\n-  background: url(\\\"chrome://global/skin/icons/tab-left.png\\\") no-repeat;\\n-  background-color: -moz-dialog;\\n-  -moz-border-radius-topleft: 4px;\\n-}\\n-\\n-.tabbrowser-tab[chromedir=\\\"rtl\\\"] > .tab-image-left {\\n-  background: url(\\\"chrome://global/skin/icons/tab-right.png\\\") no-repeat;\\n-  background-color: -moz-dialog;\\n-  -moz-border-radius-topleft: 0px;\\n-  -moz-border-radius-topright: 4px;\\n-}\\n-\\n-.tabbrowser-tab:not([selected=\\\"true\\\"]):not(:hover) > .tab-image-left {\\n-  background: url(\\\"chrome://global/skin/icons/tab-left-bkgnd.png\\\") no-repeat;\\n-  background-color: -moz-dialog;\\n-}\\n-\\n-.tabbrowser-tab[chromedir=\\\"rtl\\\"]:not([selected=\\\"true\\\"]):not(:hover) > .tab-image-left {\\n-  background: url(\\\"chrome://global/skin/icons/tab-right-bkgnd.png\\\") no-repeat;\\n-  background-color: -moz-dialog;\\n-}\\n-\\n-.tabbrowser-tab > .tab-image-middle {\\n-  height: 24px;\\n-  background: url(\\\"chrome://global/skin/icons/tab-middle.png\\\") repeat-x;\\n-  background-color: -moz-dialog;\\n-}\\n-\\n-.tabbrowser-tab:not([selected=\\\"true\\\"]):not(:hover) > .tab-image-middle {\\n-  background: url(\\\"chrome://global/skin/icons/tab-middle-bkgnd.png\\\") repeat-x;\\n-  background-color: -moz-dialog;\\n-}\\n-\\n-.tabbrowser-tab > .tab-image-right {\\n-  width: 8px;\\n-  height: 24px;\\n-  background: url(\\\"chrome://global/skin/icons/tab-right.png\\\") no-repeat;\\n-  background-color: -moz-dialog;\\n-  -moz-border-radius-topright: 4px;\\n-}\\n-\\n-.tabbrowser-tab[chromedir=\\\"rtl\\\"] > .tab-image-right {\\n-  background: url(\\\"chrome://global/skin/icons/tab-left.png\\\") no-repeat;\\n-  background-color: -moz-dialog;\\n-  -moz-border-radius-topleft: 4px;\\n-  -moz-border-radius-topright: 0px;\\n-}\\n-\\n-.tabbrowser-tab:not([selected=\\\"true\\\"]):not(:hover) > .tab-image-right {\\n-  background: url(\\\"chrome://global/skin/icons/tab-right-bkgnd.png\\\") no-repeat;\\n-  background-color: -moz-dialog;\\n-}\\n-\\n-.tabbrowser-tab[chromedir=\\\"rtl\\\"]:not([selected=\\\"true\\\"]):not(:hover) > .tab-image-right {\\n-  background: url(\\\"chrome://global/skin/icons/tab-left-bkgnd.png\\\") no-repeat;\\n-  background-color: -moz-dialog;\\n-}\\n-\\n-.tabbrowser-tab:not([selected=\\\"true\\\"]) > .tab-image-left,\\n-.tabbrowser-tab:not([selected=\\\"true\\\"]) > .tab-image-middle,\\n-.tabbrowser-tab:not([selected=\\\"true\\\"]) > .tab-image-right {\\n-  height: 23px;\\n-  margin-bottom: 1px;\\n-}\\n-\\n-.tab-icon-image {\\n-  margin-top: 1px;\\n-  -moz-margin-end: 3px;\\n-  width: 16px;\\n-  height: 16px;\\n-  list-style-image: url(\\\"chrome://global/skin/icons/folder-item.png\\\");\\n-  -moz-image-region: rect(0px, 16px, 16px, 0px);\\n-}\\n-\\n-.tabs-bottom {\\n-  height: 4px !important;\\n-  margin: 0px !important;\\n-  background: -moz-dialog url(\\\"chrome://global/skin/icons/tabstrip-bottom.png\\\") repeat !important;\\n-  border-top: 1px solid threedshadow; \\n-  border-bottom: 1px solid threedshadow;\\n-}\\n-\\n-tabpanels {\\n-  -moz-appearance: none;\\n-}\\n-\\n-.tabs-left,\\n-.tabs-right {\\n-  width: 3px;\\n-  border-bottom-width: 0px;\\n-}\\n-\\n-/* tabbrowser-tab focus ring */\\n-.tabbrowser-tab >  .tab-image-middle > .tab-text {\\n-  border: 1px dotted transparent;\\n-}\\n-\\n-.tabbrowser-tab:focus > .tab-image-middle > .tab-text {\\n-  border: 1px dotted -moz-DialogText;\\n-}\\n-\\n-/**\\n- * Tab Drag and Drop\\n- */\\n-\\n-.tab-drop-indicator-bar {\\n-    visibility: hidden;\\n-    height: 9px;\\n-    margin-top: -9px;\\n-    position: relative;\\n-}\\n-\\n-.tab-drop-indicator {\\n-    height: 9px;\\n-    width: 9px;\\n-    margin-bottom: -5px;\\n-    position: relative;\\n-    background: url('chrome://global/skin/tabDragDrop/tabDragIndicator.png') 50% 50% no-repeat;\\n-}\\n-\\n-.tab-drop-indicator-bar[dragging=\\\"true\\\"] {\\n-    visibility: visible;\\n-}\\n-\\n-/**\\n- * In-tab close button\\n- */\\n-.tab-close-button > .toolbarbutton-icon {\\n-  -moz-margin-end: 0px !important;\\n-  margin-top: 1px;\\n-}\\n-\\n-.tab-close-button {\\n-  -moz-appearance: none;\\n-  -moz-image-region: rect(0px, 64px, 16px, 48px);\\n-  height: 24px;\\n-  border: none !important;\\n-  padding: 0px;\\n-  cursor: default;\\n-  list-style-image: url(\\\"chrome://global/skin/icons/close.png\\\");\\n-}\\n-\\n-.tabbrowser-tab:not([selected=\\\"true\\\"]) > .tab-close-button {\\n-  height: 23px;\\n-  margin-bottom: 1px;\\n-}\\n-\\n-.tabbrowser-tab:not([selected=\\\"true\\\"]) > .tab-close-button > .toolbarbutton-icon {\\n-  margin-top: 2px;\\n-}\\n-\\n-.tab-close-button:hover,\\n-.tabbrowser-tab[selected=\\\"true\\\"] > .tab-close-button:hover {\\n-  -moz-image-region: rect(0px, 32px, 16px, 16px);\\n-}\\n-\\n-.tab-close-button:hover:active,\\n-.tabbrowser-tab[selected=\\\"true\\\"] > .tab-close-button:hover:active {\\n-  -moz-image-region: rect(0px, 48px, 16px, 32px);\\n-}\\n-\\n-.tabbrowser-tab > .tab-close-button {\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-middle-bkgnd.png\\\");\\n-  background-color: -moz-dialog;\\n-}\\n-\\n-.tabbrowser-tab:hover > .tab-close-button {\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-middle.png\\\");\\n-}\\n-\\n-.tabbrowser-tab[selected=\\\"true\\\"] > .tab-close-button {\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-middle.png\\\");\\n-  -moz-image-region: rect(0px, 16px, 16px, 0px);\\n-  /* Make this button focusable so clicking on it will not focus the tab while\\n-     it's getting closed */\\n-  -moz-user-focus: normal;\\n-}\\n-\\n-.tab-close-button:focus {\\n-  outline: none !important;\\n-}\\n-\\n-/**\\n- * Tab Scrollbox Arrow Buttons\\n- */\\n-\\n-.tabbrowser-tabs[overflow=\\\"true\\\"] .tabs-left {\\n-  display: none;\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > .scrollbutton-up {\\n-  -moz-appearance: none !important;\\n-  border: none !important;\\n-  margin-top: 2px;\\n-  margin-bottom: 4px !important;\\n-  padding: 0px;\\n-  width: 18px;\\n-  height: 23px;\\n-  -moz-margin-start: 0px;\\n-  -moz-margin-end: 0px;\\n-  list-style-image: url(\\\"chrome://global/skin/icons/tab-arrow-start.png\\\");\\n-  -moz-image-region: rect(0, 11px, 14px, 0);\\n-  background-repeat: no-repeat;\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-start-bkgnd-enabled.png\\\");\\n-  background-color: -moz-dialog;\\n-  -moz-border-radius-topright: 4px;\\n-}\\n-\\n-.tabbrowser-arrowscrollbox[chromedir=\\\"rtl\\\"] > .scrollbutton-up {\\n-  list-style-image: url(\\\"chrome://global/skin/icons/tab-arrow-end.png\\\");\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-end-bkgnd-enabled.png\\\");\\n-  -moz-border-radius-topleft: 4px;\\n-  -moz-border-radius-topright: 0px;\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > .scrollbutton-up[disabled=\\\"true\\\"] {\\n-  -moz-image-region: rect(0, 33px, 14px, 22px);\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-start-bkgnd-disabled.png\\\");\\n-}\\n-\\n-.tabbrowser-arrowscrollbox[chromedir=\\\"rtl\\\"] > .scrollbutton-up[disabled=\\\"true\\\"] {\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-end-bkgnd-disabled.png\\\");\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > .scrollbutton-up:not([disabled=\\\"true\\\"]):hover {\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-start-bkgnd-hover.png\\\");\\n-  -moz-image-region: rect(0, 22px, 14px, 11px);\\n-}\\n-\\n-.tabbrowser-arrowscrollbox[chromedir=\\\"rtl\\\"] > .scrollbutton-up:not([disabled=\\\"true\\\"]):hover {\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-end-bkgnd-hover.png\\\");\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > .scrollbutton-up:not([disabled=\\\"true\\\"]):hover:active {\\n-  -moz-image-region: rect(0, 44px, 14px, 33px);\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > .scrollbutton-up > .toolbarbutton-icon {    \\n-  margin: 6px 0px 0px 0px;\\n-}                                                                            \\n-\\n-.tabbrowser-arrowscrollbox > .scrollbutton-down-stack {\\n-  margin-top: 2px;\\n-  margin-bottom: 4px;\\n-  height: 23px;\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > stack > .scrollbutton-down-box {\\n-  -moz-appearance: none !important;\\n-  border: none !important;\\n-  width: 18px;\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-end-bkgnd-enabled.png\\\");\\n-  background-repeat: no-repeat;\\t\\n-  background-color: -moz-dialog;\\n-  -moz-border-radius-topleft: 4px;\\n-}\\n-\\n-.tabbrowser-arrowscrollbox[chromedir=\\\"rtl\\\"] > stack > .scrollbutton-down-box {\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-start-bkgnd-enabled.png\\\");\\n-  -moz-border-radius-topleft: 0px;\\n-  -moz-border-radius-topright: 4px;\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > stack > .scrollbutton-down-box[disabled=\\\"true\\\"] {\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-end-bkgnd-disabled.png\\\");\\n-}\\n-\\n-.tabbrowser-arrowscrollbox[chromedir=\\\"rtl\\\"] > stack > .scrollbutton-down-box[disabled=\\\"true\\\"] {\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-start-bkgnd-disabled.png\\\");\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > stack > .scrollbutton-down-box-animate {\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-end-bkgnd-animate.png\\\");\\n-  background-repeat: no-repeat;\\n-  opacity: 0.0;\\n-}\\n-\\n-.tabbrowser-arrowscrollbox[chromedir=\\\"rtl\\\"] > stack > .scrollbutton-down-box-animate {\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-start-bkgnd-animate.png\\\");\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > stack > .scrollbutton-down {\\n-  -moz-appearance: none !important;\\n-  border: none !important;\\n-  width: 18px;\\n-  list-style-image: url(\\\"chrome://global/skin/icons/tab-arrow-end.png\\\");\\n-  -moz-image-region: rect(0, 11px, 14px, 0);\\n-  margin: 0px;\\n-  padding: 0px;\\n-}\\n-\\n-.tabbrowser-arrowscrollbox[chromedir=\\\"rtl\\\"] > stack > .scrollbutton-down {\\n-  list-style-image: url(\\\"chrome://global/skin/icons/tab-arrow-start.png\\\");\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > stack > .scrollbutton-down[disabled=\\\"true\\\"] {\\n-  -moz-image-region: rect(0, 33px, 14px, 22px);\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > stack > .scrollbutton-down:not([disabled=\\\"true\\\"]):hover {\\n-  -moz-image-region: rect(0, 22px, 14px, 11px);\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-end-bkgnd-hover.png\\\");\\n-  background-repeat: no-repeat;\\n-  background-position: top left;\\n-}\\n-\\n-.tabbrowser-arrowscrollbox[chromedir=\\\"rtl\\\"] > stack > .scrollbutton-down:not([disabled=\\\"true\\\"]):hover {\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-start-bkgnd-hover.png\\\");\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > stack > .scrollbutton-down:not([disabled=\\\"true\\\"]):hover:active {\\n-  -moz-image-region: rect(0, 44px, 14px, 33px);\\n-}\\n-\\n-.tabbrowser-arrowscrollbox > stack > .scrollbutton-down > .toolbarbutton-icon {\\n-  margin: 6px 0px 0px 1px;\\n-}\\n-\\n-/**\\n- * All Tabs Button\\n- */\\n-\\n-.tabs-alltabs-box {\\n-  margin-top: 2px;\\n-  margin-bottom: 4px;\\n-  width: 18px !important;\\n-  height: 23px !important;\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-end-bkgnd-enabled.png\\\");\\n-  background-repeat: no-repeat;\\n-  background-color: -moz-dialog; \\n-  -moz-border-radius-topleft: 4px;\\n-}\\n-\\n-stack[chromedir=\\\"rtl\\\"] > hbox > .tabs-alltabs-box {\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-start-bkgnd-enabled.png\\\");\\n-  -moz-border-radius-topleft: 0px;\\n-  -moz-border-radius-topright: 4px;\\n-}\\n-\\n-.tabbrowser-tabs[overflow=\\\"true\\\"] .tabs-alltabs-box {\\n-  background-image: url(\\\"chrome://global/skin/icons/alltabs-box-overflow-end-bkgnd.png\\\");\\n-  -moz-border-radius-topleft: 0px;\\n-  -moz-border-radius-topright: 0px;\\n-}\\n-\\n-.tabbrowser-tabs[overflow=\\\"true\\\"] stack[chromedir=\\\"rtl\\\"] > hbox > .tabs-alltabs-box {\\n-  background-image: url(\\\"chrome://global/skin/icons/alltabs-box-overflow-start-bkgnd.png\\\");\\n-}\\n-\\n-.tabs-alltabs-button {\\n-  -moz-appearance: none !important;\\n-  border: 0px !important;\\n-  margin-top: 2px;\\n-  margin-bottom: 4px;\\n-  width: 18px !important;\\n-  height: 23px !important;\\n-  border: 0px !important;\\n-  -moz-padding-start: 4px !important;\\n-  -moz-padding-end: 4px !important;\\n-  padding: 0px;\\n-}\\n-\\n-.tabs-alltabs-button > .toolbarbutton-text {\\n-  display: none;\\n-}\\n-\\n-.tabs-alltabs-button > .toolbarbutton-icon {\\n-  -moz-margin-end: 2px;\\n-}\\n-\\n-.tabs-alltabs-button > .toolbarbutton-menu-dropmarker {\\n-  margin-top: 3px !important;\\n-}\\n-\\n-.tabs-alltabs-button:hover {\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-end-bkgnd-hover.png\\\");\\n-  background-repeat: no-repeat;\\n-}\\n-\\n-stack[chromedir=\\\"rtl\\\"] > hbox > .tabs-alltabs-button:hover {\\n-  background-image: url(\\\"chrome://global/skin/icons/tab-arrow-start-bkgnd-hover.png\\\");\\n-}\\n-\\n-.tabbrowser-tabs[overflow=\\\"true\\\"] .tabs-alltabs-button:hover {\\n-  background-image: url(\\\"chrome://global/skin/icons/alltabs-box-overflow-end-bkgnd-hover.png\\\");\\n-}\\n-\\n-.tabbrowser-tabs[overflow=\\\"true\\\"] stack[chromedir=\\\"rtl\\\"] > hbox > .tabs-alltabs-button:hover {\\n-  background-image: url(\\\"chrome://global/skin/icons/alltabs-box-overflow-start-bkgnd-hover.png\\\");\\n-}\\n-\\n-.tabs-alltabs-box-animate {\\n-  margin-top: 2px;\\n-  margin-bottom: 4px;\\n-  width: 18px !important;\\n-  height: 23px !important;\\n-  background-image: url(\\\"chrome://global/skin/icons/alltabs-box-overflow-end-bkgnd-animate.png\\\");\\n-  background-repeat: no-repeat;\\n-  opacity: 0.0;\\n-}\\n-\\n-stack[chromedir=\\\"rtl\\\"] > hbox > .tabs-alltabs-box-animate {\\n-  background-image: url(\\\"chrome://global/skin/icons/alltabs-box-overflow-start-bkgnd-animate.png\\\");\\n-}\\n-\\n-/**\\n- * All Tabs Menupopup \\n- */\\n-\\n-.alltabs-item > .menu-iconic-left > .menu-iconic-icon {\\n-  list-style-image: url(\\\"chrome://global/skin/icons/folder-item.png\\\");\\n-  -moz-image-region: rect(0px, 16px, 16px, 0px);\\n-}\\n-\\n-.alltabs-item[selected=\\\"true\\\"] {\\n-  font-weight: bold;\\n-}\\n-\\n-.alltabs-item[busy] > .menu-iconic-left > .menu-iconic-icon {\\n-  list-style-image: url(\\\"chrome://global/skin/throbber/Throbber-small.gif\\\");\\n-  opacity: 0.6;\\n-}\\ndiff --git a/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-end-bkgnd-animate.png b/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-end-bkgnd-animate.png\\ndeleted file mode 100755\\nindex 3db331b..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-end-bkgnd-animate.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-end-bkgnd-hover.png b/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-end-bkgnd-hover.png\\ndeleted file mode 100755\\nindex 754fd33..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-end-bkgnd-hover.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-end-bkgnd.png b/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-end-bkgnd.png\\ndeleted file mode 100755\\nindex 79e592b..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-end-bkgnd.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-start-bkgnd-animate.png b/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-start-bkgnd-animate.png\\ndeleted file mode 100755\\nindex 2752c48..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-start-bkgnd-animate.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-start-bkgnd-hover.png b/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-start-bkgnd-hover.png\\ndeleted file mode 100755\\nindex 3431d06..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-start-bkgnd-hover.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-start-bkgnd.png b/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-start-bkgnd.png\\ndeleted file mode 100755\\nindex 785f79c..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/alltabs-box-overflow-start-bkgnd.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/alltabs.png b/toolkit/themes/winstripe/global/icons/alltabs.png\\ndeleted file mode 100755\\nindex fc0f869..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/alltabs.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tab-arrow-end-bkgnd-animate.png b/toolkit/themes/winstripe/global/icons/tab-arrow-end-bkgnd-animate.png\\ndeleted file mode 100755\\nindex 7be0580..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tab-arrow-end-bkgnd-animate.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tab-arrow-end-bkgnd-disabled.png b/toolkit/themes/winstripe/global/icons/tab-arrow-end-bkgnd-disabled.png\\ndeleted file mode 100755\\nindex 9c96bef..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tab-arrow-end-bkgnd-disabled.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tab-arrow-end-bkgnd-enabled.png b/toolkit/themes/winstripe/global/icons/tab-arrow-end-bkgnd-enabled.png\\ndeleted file mode 100755\\nindex 91e6813..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tab-arrow-end-bkgnd-enabled.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tab-arrow-end-bkgnd-hover.png b/toolkit/themes/winstripe/global/icons/tab-arrow-end-bkgnd-hover.png\\ndeleted file mode 100755\\nindex ce4a54f..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tab-arrow-end-bkgnd-hover.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tab-arrow-end.png b/toolkit/themes/winstripe/global/icons/tab-arrow-end.png\\ndeleted file mode 100755\\nindex 81c3461..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tab-arrow-end.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tab-arrow-start-bkgnd-animate.png b/toolkit/themes/winstripe/global/icons/tab-arrow-start-bkgnd-animate.png\\ndeleted file mode 100755\\nindex f61accf..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tab-arrow-start-bkgnd-animate.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tab-arrow-start-bkgnd-disabled.png b/toolkit/themes/winstripe/global/icons/tab-arrow-start-bkgnd-disabled.png\\ndeleted file mode 100755\\nindex aa26d3e..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tab-arrow-start-bkgnd-disabled.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tab-arrow-start-bkgnd-enabled.png b/toolkit/themes/winstripe/global/icons/tab-arrow-start-bkgnd-enabled.png\\ndeleted file mode 100755\\nindex 7550d9c..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tab-arrow-start-bkgnd-enabled.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tab-arrow-start-bkgnd-hover.png b/toolkit/themes/winstripe/global/icons/tab-arrow-start-bkgnd-hover.png\\ndeleted file mode 100755\\nindex 89746a4..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tab-arrow-start-bkgnd-hover.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tab-arrow-start.png b/toolkit/themes/winstripe/global/icons/tab-arrow-start.png\\ndeleted file mode 100755\\nindex 27f2d94..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tab-arrow-start.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tab-left-bkgnd.png b/toolkit/themes/winstripe/global/icons/tab-left-bkgnd.png\\ndeleted file mode 100755\\nindex 60cf0c0..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tab-left-bkgnd.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tab-left.png b/toolkit/themes/winstripe/global/icons/tab-left.png\\ndeleted file mode 100755\\nindex bc357cc..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tab-left.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tab-middle-bkgnd.png b/toolkit/themes/winstripe/global/icons/tab-middle-bkgnd.png\\ndeleted file mode 100755\\nindex bc95506..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tab-middle-bkgnd.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tab-middle.png b/toolkit/themes/winstripe/global/icons/tab-middle.png\\ndeleted file mode 100755\\nindex c63a0fd..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tab-middle.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tab-right-bkgnd.png b/toolkit/themes/winstripe/global/icons/tab-right-bkgnd.png\\ndeleted file mode 100755\\nindex 967b59f..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tab-right-bkgnd.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tab-right.png b/toolkit/themes/winstripe/global/icons/tab-right.png\\ndeleted file mode 100755\\nindex 7a25b14..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tab-right.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tabDragDrop/tabDragIndicator.png b/toolkit/themes/winstripe/global/icons/tabDragDrop/tabDragIndicator.png\\ndeleted file mode 100755\\nindex c50c408..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tabDragDrop/tabDragIndicator.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tabbrowser-tabs-bkgnd.png b/toolkit/themes/winstripe/global/icons/tabbrowser-tabs-bkgnd.png\\ndeleted file mode 100755\\nindex eb8e901..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tabbrowser-tabs-bkgnd.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/icons/tabstrip-bottom.png b/toolkit/themes/winstripe/global/icons/tabstrip-bottom.png\\ndeleted file mode 100644\\nindex 945f42d..0000000\\nBinary files a/toolkit/themes/winstripe/global/icons/tabstrip-bottom.png and /dev/null differ\\ndiff --git a/toolkit/themes/winstripe/global/tabDragDrop/tabDragIndicator.png b/toolkit/themes/winstripe/global/tabDragDrop/tabDragIndicator.png\\ndeleted file mode 100755\\nindex 6a18e78..0000000\\nBinary files a/toolkit/themes/winstripe/global/tabDragDrop/tabDragIndicator.png and /dev/null differ\\n\""}