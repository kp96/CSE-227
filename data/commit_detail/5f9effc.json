{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas5f9effc\""},"diff":"\"5f9effc Bug 304048 - \\\"xpconnect getters/setters don't have principals until after they pass or fail their security check.\\\" Patch by jst, sr=bzbarsky, a=jst.\\ndiff --git a/caps/src/nsScriptSecurityManager.cpp b/caps/src/nsScriptSecurityManager.cpp\\nindex 750a314..b9401b0 100644\\n--- a/caps/src/nsScriptSecurityManager.cpp\\n+++ b/caps/src/nsScriptSecurityManager.cpp\\n@@ -493,6 +493,12 @@ nsScriptSecurityManager::CheckObjectAccess(JSContext *cx, JSObject *obj,\\n     if (!ssm)\\n         return JS_FALSE;\\n \\n+    nsCOMPtr<nsISupports> native;\\n+    nsresult rv =\\n+        sXPConnect->GetNativeOfJSObject(cx, obj,\\n+                                        NS_GET_IID(nsISupports),\\n+                                        getter_AddRefs(native));\\n+\\n     // Get the object being accessed.  We protect these cases:\\n     // 1. The Function.prototype.caller property's value, which might lead\\n     //    an attacker up a call-stack to a function or another object from\\n@@ -505,11 +511,13 @@ nsScriptSecurityManager::CheckObjectAccess(JSContext *cx, JSObject *obj,\\n \\n     // Do the same-origin check -- this sets a JS exception if the check fails.\\n     // Pass the parent object's class name, as we have no class-info for it.\\n-    nsresult rv =\\n-        ssm->CheckPropertyAccess(cx, target, JS_GetClass(cx, obj)->name, id,\\n-                                 (mode & JSACC_WRITE) ?\\n-                                 nsIXPCSecurityManager::ACCESS_SET_PROPERTY :\\n-                                 nsIXPCSecurityManager::ACCESS_GET_PROPERTY);\\n+    rv = ssm->CheckPropertyAccessImpl(( (mode & JSACC_WRITE) ?\\n+                                        nsIXPCSecurityManager::ACCESS_SET_PROPERTY :\\n+                                        nsIXPCSecurityManager::ACCESS_GET_PROPERTY ),\\n+                                      nsnull, cx, target, native, nsnull,\\n+                                      nsnull, JS_GET_CLASS(cx, obj)->name, id,\\n+                                      nsnull);\\n+\\n \\n     if (NS_FAILED(rv))\\n         return JS_FALSE; // Security check failed (XXX was an error reported?)\\n@@ -771,14 +779,24 @@ nsScriptSecurityManager::CheckPropertyAccessImpl(PRUint32 aAction,\\n     nsXPIDLCString objectSecurityLevel;\\n     if (checkedComponent)\\n     {\\n-        nsCOMPtr<nsIXPConnectWrappedNative> wrapper;\\n-        nsCOMPtr<nsIInterfaceInfo> interfaceInfo;\\n-        const nsIID* objIID;\\n-        rv = aCallContext->GetCalleeWrapper(getter_AddRefs(wrapper));\\n-        if (NS_SUCCEEDED(rv))\\n-            rv = wrapper->FindInterfaceWithMember(aProperty, getter_AddRefs(interfaceInfo));\\n-        if (NS_SUCCEEDED(rv))\\n-            rv = interfaceInfo->GetIIDShared(&objIID);\\n+        const nsIID* objIID = nsnull;\\n+        if (aCallContext) {\\n+            // If we have a call context, find the wrapper and the IID\\n+            // with the member in question to pass to\\n+            // nsISecurityCheckedComponent, if not, pass a null IID\\n+            // and it's up to the implementation to decide whether or\\n+            // not it wants to permit access.\\n+            nsCOMPtr<nsIXPConnectWrappedNative> wrapper;\\n+            nsCOMPtr<nsIInterfaceInfo> interfaceInfo;\\n+            rv = aCallContext->GetCalleeWrapper(getter_AddRefs(wrapper));\\n+            if (NS_SUCCEEDED(rv))\\n+                rv = wrapper->FindInterfaceWithMember(aProperty, getter_AddRefs(interfaceInfo));\\n+            if (NS_SUCCEEDED(rv))\\n+                rv = interfaceInfo->GetIIDShared(&objIID);\\n+        } else {\\n+            rv = NS_OK;\\n+        }\\n+\\n         if (NS_SUCCEEDED(rv))\\n         {\\n             switch (aAction)\\ndiff --git a/js/src/xpconnect/idl/nsIXPConnect.idl b/js/src/xpconnect/idl/nsIXPConnect.idl\\nindex a523c7c..6922308 100644\\n--- a/js/src/xpconnect/idl/nsIXPConnect.idl\\n+++ b/js/src/xpconnect/idl/nsIXPConnect.idl\\n@@ -675,6 +675,17 @@ interface nsIXPConnect : nsISupports\\n     void flagSystemFilenamePrefix(in string aFilenamePrefix);\\n \\n     /**\\n+     * Get a native pointer of type aIID from aJSObject if the object\\n+     * is a wrapped native or a wrapped JS object, but never create a\\n+     * new wrapper, only use existing ones.\\n+     */\\n+    void\\n+    getNativeOfJSObject(in JSContextPtr aJSContext,\\n+                        in JSObjectPtr  aJSObj,\\n+                        in nsIIDRef     aIID,\\n+                        [iid_is(aIID),retval] out nsQIResult result);\\n+\\n+    /**\\n      * Restore an old prototype for wrapped natives of type\\n      * aClassInfo. This should be used only when restoring an old\\n      * scope into a state close to where it was prior to\\ndiff --git a/js/src/xpconnect/src/XPCDispConvert.cpp b/js/src/xpconnect/src/XPCDispConvert.cpp\\nindex ed94fdf..83d0526 100644\\n--- a/js/src/xpconnect/src/XPCDispConvert.cpp\\n+++ b/js/src/xpconnect/src/XPCDispConvert.cpp\\n@@ -331,6 +331,7 @@ JSBool XPCDispConvert::JSToCOM(XPCCallContext& ccx,\\n                 obj, \\n                 &NSID_IDISPATCH,\\n                 nsnull, \\n+                PR_TRUE, \\n                 &err))\\n             {\\n                 // Avoid cleaning up garbage\\ndiff --git a/js/src/xpconnect/src/nsXPConnect.cpp b/js/src/xpconnect/src/nsXPConnect.cpp\\nindex 91e9f94..bd9048d 100644\\n--- a/js/src/xpconnect/src/nsXPConnect.cpp\\n+++ b/js/src/xpconnect/src/nsXPConnect.cpp\\n@@ -1112,7 +1112,7 @@ nsXPConnect::WrapJS(JSContext * aJSContext,\\n \\n     nsresult rv;\\n     if(!XPCConvert::JSObject2NativeInterface(ccx, result, aJSObj,\\n-                                             &aIID, nsnull, &rv))\\n+                                             &aIID, nsnull, PR_TRUE, &rv))\\n         return rv;\\n     return NS_OK;\\n }\\n@@ -1138,7 +1138,7 @@ nsXPConnect::WrapJSAggregatedToNative(nsISupports *aOuter,\\n \\n     nsresult rv;\\n     if(!XPCConvert::JSObject2NativeInterface(ccx, result, aJSObj,\\n-                                             &aIID, aOuter, &rv))\\n+                                             &aIID, aOuter, PR_TRUE, &rv))\\n         return rv;\\n     return NS_OK;\\n }\\n@@ -2097,6 +2097,30 @@ nsXPConnect::OnDispatchedEvent(nsIThreadInternal* aThread)\\n     return NS_ERROR_UNEXPECTED;\\n }\\n \\n+/* void getNativeOfJSObject(in JSContextPtr aJSContext, in JSObjectPtr aJSObj, in nsIIDRef aIID, [iid_is(aIID),retval] out nsQIResult result); */\\n+NS_IMETHODIMP\\n+nsXPConnect::GetNativeOfJSObject(JSContext * aJSContext,\\n+                                 JSObject * aJSObj,\\n+                                 const nsIID & aIID,\\n+                                 void * *result)\\n+{\\n+    NS_ASSERTION(aJSContext, \\\"bad param\\\");\\n+    NS_ASSERTION(aJSObj, \\\"bad param\\\");\\n+    NS_ASSERTION(result, \\\"bad param\\\");\\n+\\n+    *result = nsnull;\\n+\\n+    XPCCallContext ccx(NATIVE_CALLER, aJSContext);\\n+    if(!ccx.IsValid())\\n+        return UnexpectedFailure(NS_ERROR_FAILURE);\\n+\\n+    nsresult rv;\\n+    if(!XPCConvert::JSObject2NativeInterface(ccx, result, aJSObj,\\n+                                             &aIID, nsnull, PR_FALSE, &rv))\\n+        return rv;\\n+    return NS_OK;\\n+}\\n+\\n #ifdef DEBUG\\n /* These are here to be callable from a debugger */\\n JS_BEGIN_EXTERN_C\\ndiff --git a/js/src/xpconnect/src/xpcconvert.cpp b/js/src/xpconnect/src/xpcconvert.cpp\\nindex 395983b..11c8de8 100644\\n--- a/js/src/xpconnect/src/xpcconvert.cpp\\n+++ b/js/src/xpconnect/src/xpcconvert.cpp\\n@@ -1030,7 +1030,7 @@ XPCConvert::JSData2Native(XPCCallContext& ccx, void* d, jsval s,\\n             }\\n \\n             return JSObject2NativeInterface(ccx, (void**)d, obj, iid,\\n-                                            nsnull, pErr);\\n+                                            nsnull, PR_TRUE, pErr);\\n         }\\n         default:\\n             NS_ASSERTION(0, \\\"bad type\\\");\\n@@ -1230,6 +1230,7 @@ XPCConvert::JSObject2NativeInterface(XPCCallContext& ccx,\\n                                      void** dest, JSObject* src,\\n                                      const nsID* iid,\\n                                      nsISupports* aOuter,\\n+                                     PRBool allowCreateNew,\\n                                      nsresult* pErr)\\n {\\n     NS_ASSERTION(dest, \\\"bad param\\\");\\n@@ -1239,7 +1240,7 @@ XPCConvert::JSObject2NativeInterface(XPCCallContext& ccx,\\n     JSContext* cx = ccx.GetJSContext();\\n \\n     *dest = nsnull;\\n-     if(pErr)\\n+    if(pErr)\\n         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS;\\n \\n     nsISupports* iface;\\n@@ -1288,8 +1289,15 @@ XPCConvert::JSObject2NativeInterface(XPCCallContext& ccx,\\n \\n     // else...\\n \\n+    nsresult rv;\\n+\\n     nsXPCWrappedJS* wrapper;\\n-    nsresult rv = nsXPCWrappedJS::GetNewOrUsed(ccx, src, *iid, aOuter, &wrapper);\\n+    if (allowCreateNew) {\\n+        rv = nsXPCWrappedJS::GetNewOrUsed(ccx, src, *iid, aOuter, &wrapper);\\n+    } else {\\n+        rv = nsXPCWrappedJS::GetUsedOnly(ccx, src, *iid, aOuter, &wrapper);\\n+    }\\n+\\n     if(pErr)\\n         *pErr = rv;\\n     if(NS_SUCCEEDED(rv) && wrapper)\\ndiff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h\\nindex 767db75..1e6593c8 100644\\n--- a/js/src/xpconnect/src/xpcprivate.h\\n+++ b/js/src/xpconnect/src/xpcprivate.h\\n@@ -2356,6 +2356,12 @@ public:\\n                  REFNSIID aIID,\\n                  nsISupports* aOuter,\\n                  nsXPCWrappedJS** wrapper);\\n+    static nsresult\\n+    GetUsedOnly(XPCCallContext& ccx,\\n+                JSObject* aJSObj,\\n+                REFNSIID aIID,\\n+                nsISupports* aOuter,\\n+                nsXPCWrappedJS** wrapperResult);\\n \\n     nsISomeInterface* GetXPTCStub() { return mXPTCStub; }\\n     JSObject* GetJSObject() const {return mJSObj;}\\n@@ -2531,6 +2537,7 @@ public:\\n                                            void** dest, JSObject* src,\\n                                            const nsID* iid,\\n                                            nsISupports* aOuter,\\n+                                           PRBool allowCreateNew,\\n                                            nsresult* pErr);\\n \\n     /**\\ndiff --git a/js/src/xpconnect/src/xpcwrappedjs.cpp b/js/src/xpconnect/src/xpcwrappedjs.cpp\\nindex 32cd5ed..f650564 100644\\n--- a/js/src/xpconnect/src/xpcwrappedjs.cpp\\n+++ b/js/src/xpconnect/src/xpcwrappedjs.cpp\\n@@ -417,6 +417,68 @@ return_wrapper:\\n     return NS_OK;\\n }\\n \\n+// static\\n+nsresult\\n+nsXPCWrappedJS::GetUsedOnly(XPCCallContext& ccx,\\n+                            JSObject* aJSObj,\\n+                            REFNSIID aIID,\\n+                            nsISupports* aOuter,\\n+                            nsXPCWrappedJS** wrapperResult)\\n+{\\n+    JSObject2WrappedJSMap* map;\\n+    JSBool hasProp;\\n+    JSObject* rootJSObj;\\n+    nsXPCWrappedJS* root;\\n+    nsXPCWrappedJS* wrapper = nsnull;\\n+    nsXPCWrappedJSClass *clazz = nsnull;\\n+    XPCJSRuntime* rt = ccx.GetRuntime();\\n+\\n+    map = rt->GetWrappedJSMap();\\n+    if(!map)\\n+    {\\n+        NS_ASSERTION(map,\\\"bad map\\\");\\n+        return NS_ERROR_FAILURE;\\n+    }\\n+\\n+    nsXPCWrappedJSClass::GetNewOrUsed(ccx, aIID, &clazz);\\n+    if(!clazz)\\n+        return NS_ERROR_FAILURE;\\n+\\n+    // GetRootJSObject will attempt to call a QueryInterface function on\\n+    // aJSObj. If QueryInterface doesn't exist on the object then a strict\\n+    // warning will be emitted, so check to make sure that the QueryInterface\\n+    // function exists before proceeding.\\n+    if(JS_HasProperty(ccx.GetJSContext(), aJSObj,\\n+                      rt->GetStringName(XPCJSRuntime::IDX_QUERY_INTERFACE),\\n+                      &hasProp) && hasProp)\\n+        rootJSObj = clazz->GetRootJSObject(ccx, aJSObj);\\n+    else\\n+        rootJSObj = aJSObj;\\n+\\n+    NS_RELEASE(clazz);\\n+\\n+    if(!rootJSObj)\\n+        return NS_ERROR_FAILURE;\\n+\\n+    // look for the root wrapper\\n+    {   // scoped lock\\n+        XPCAutoLock lock(rt->GetMapLock());\\n+        root = map->Find(rootJSObj);\\n+    }\\n+\\n+    if(root)\\n+    {\\n+        if((nsnull != (wrapper = root->Find(aIID))) ||\\n+           (nsnull != (wrapper = root->FindInherited(aIID))))\\n+        {\\n+            NS_ADDREF(wrapper);\\n+        }\\n+    }\\n+\\n+    *wrapperResult = wrapper;\\n+    return NS_OK;\\n+}\\n+\\n nsXPCWrappedJS::nsXPCWrappedJS(XPCCallContext& ccx,\\n                                JSObject* aJSObj,\\n                                nsXPCWrappedJSClass* aClass,\\n\""}