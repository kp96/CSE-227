{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas30d7fb3\""},"diff":"\"30d7fb3 Bug 308073 - Change default downloading folder in Windows Vista from Desktop to Downloads.  Patch by Jim Mathies <jmathies@mozilla.com>.  r=robarnold, r=robert.bugzilla, sr=dougt, a=mconnor\\ndiff --git a/browser/base/content/browser.js b/browser/base/content/browser.js\\nindex 57eaded..4059e59 100644\\n--- a/browser/base/content/browser.js\\n+++ b/browser/base/content/browser.js\\n@@ -1114,6 +1114,25 @@ function delayedStartup()\\n     Components.utils.reportError(\\\"Failed to init content pref service:\\\\n\\\" + ex);\\n   }\\n \\n+#ifdef XP_WIN\\n+  // For Vista, flip the default download folder pref once from Desktop to Downloads\\n+  // on new profiles.\\n+  try {\\r\\n+    var sysInfo = Cc[\\\"@mozilla.org/system-info;1\\\"].\\r\\n+                  getService(Ci.nsIPropertyBag2);\\r\\n+    if (parseFloat(sysInfo.getProperty(\\\"version\\\")) >= 6 &&\\n+        !gPrefService.getPrefType(\\\"browser.download.dir\\\") &&\\n+        gPrefService.getIntPref(\\\"browser.download.folderList\\\") == 0) {\\n+      var dnldMgr = Cc[\\\"@mozilla.org/download-manager;1\\\"]\\n+                              .getService(Ci.nsIDownloadManager);\\n+      gPrefService.setCharPref(\\\"browser.download.dir\\\", \\n+        dnldMgr.defaultDownloadsDirectory.path);\\n+      gPrefService.setIntPref(\\\"browser.download.folderList\\\", 1);\\n+    }\\n+  } catch (ex) {\\n+  }\\n+#endif\\n+\\n   // initialize the session-restore service (in case it's not already running)\\n   if (document.documentElement.getAttribute(\\\"windowtype\\\") == \\\"navigator:browser\\\") {\\n     try {\\ndiff --git a/browser/components/migration/src/nsOperaProfileMigrator.cpp b/browser/components/migration/src/nsOperaProfileMigrator.cpp\\nindex 9e992e7..bc01b46 100644\\n--- a/browser/components/migration/src/nsOperaProfileMigrator.cpp\\n+++ b/browser/components/migration/src/nsOperaProfileMigrator.cpp\\n@@ -314,7 +314,7 @@ nsOperaProfileMigrator::GetSourceHomePageURL(nsACString& aResult)\\n \\n static\\n nsOperaProfileMigrator::PrefTransform gTransforms[] = {\\n-  { \\\"User Prefs\\\", \\\"Download Directory\\\", _OPM(STRING), \\\"browser.download.defaultFolder\\\", _OPM(SetFile), PR_FALSE, -1 },\\n+  { \\\"User Prefs\\\", \\\"Download Directory\\\", _OPM(STRING), \\\"browser.download.dir\\\", _OPM(SetFile), PR_FALSE, -1 },\\n   { nsnull, \\\"Enable Cookies\\\", _OPM(INT), \\\"network.cookie.cookieBehavior\\\", _OPM(SetCookieBehavior), PR_FALSE, -1 },\\n   { nsnull, \\\"Accept Cookies Session Only\\\", _OPM(BOOL), \\\"network.cookie.enableForCurrentSessionOnly\\\", _OPM(SetBool), PR_FALSE, -1 },\\n   { nsnull, \\\"Allow script to resize window\\\", _OPM(BOOL), \\\"dom.disable_window_move_resize\\\", _OPM(SetBool), PR_FALSE, -1 },\\ndiff --git a/browser/components/migration/src/nsSafariProfileMigrator.cpp b/browser/components/migration/src/nsSafariProfileMigrator.cpp\\nindex 59a1dbc..d647352 100644\\n--- a/browser/components/migration/src/nsSafariProfileMigrator.cpp\\n+++ b/browser/components/migration/src/nsSafariProfileMigrator.cpp\\n@@ -516,7 +516,7 @@ nsSafariProfileMigrator::SetDownloadFolder(void* aTransform, nsIPrefBranch* aBra\\n   PRBool equals;\\n   downloadFolder->Equals(desktopFolder, &equals);\\n   aBranch->SetIntPref(\\\"browser.download.folderList\\\", equals ? 0 : 2);\\n-  aBranch->SetComplexValue(\\\"browser.download.defaultFolder\\\",\\n+  aBranch->SetComplexValue(\\\"browser.download.dir\\\",\\n                            NS_GET_IID(nsILocalFile), downloadFolder);\\n \\n   return NS_OK;\\ndiff --git a/browser/components/preferences/main.js b/browser/components/preferences/main.js\\nindex 10a92f8..273c84bd 100644\\n--- a/browser/components/preferences/main.js\\n+++ b/browser/components/preferences/main.js\\n@@ -171,26 +171,35 @@ var gMainPane = {\\n   /*\\n    * Preferences:\\n    * \\n-   * browser.download.showWhenStarting\\n-   *   true if the Download Manager should be opened when a download is started,\\n-   *   false if it shouldn't be opened\\n-   * browser.download.closeWhenDone\\n-   *   true if the Download Manager should be closed when all downloads\\n-   *   complete, false if it shouldn't be closed\\n-   * browser.download.useDownloadDir\\n-   *   true if downloads are saved to a default location with no UI shown, false\\n-   *   if the user should always be asked where to save files\\n-   * browser.download.dir\\n-   *   the last directory to which a download was saved\\n+   * browser.download.showWhenStarting - bool\\n+   *   True if the Download Manager should be opened when a download is\\n+   *   started, false if it shouldn't be opened.\\n+   * browser.download.closeWhenDone - bool\\n+   *   True if the Download Manager should be closed when all downloads\\n+   *   complete, false if it should be left open.\\n+   * browser.download.useDownloadDir - bool\\n+   *   True if downloads are saved with no save-as UI shown, false if\\n+   *   the user should always be asked where to save a file.\\n+   * browser.download.dir - str path\\n+   *   A local path the user may have selected for downloaded files to be\\n+   *   saved. Migration of other browser settings may also set this path.\\n+   *   This path is enabled when folderList is equals 2.\\n+   * browser.download.lastDir - str path\\n+   *   May contain the last folder path accessed when the user browsed\\n+   *   via the file save-as dialog. (see contentAreaUtils.js)\\n+   * browser.download.folderList - int\\n+   *   Indicates the location users wish to save downloaded files too.\\n+   *   It is also used to display special file labels when the default\\n+   *   download location is either the Desktop or the Downloads folder.\\n+   *   Values:\\n+   *     0 - The desktop is the default download location.\\n+   *     1 - The system's downloads folder is the default download location.\\n+   *     2 - The default download location is elsewhere as specified in\\n+   *         browser.download.dir.\\n    * browser.download.downloadDir\\n-   *   the current default download location\\n-   * browser.download.folderList\\n-   *   0 if the desktop is the default download location,\\n-   *   1 if the downloads folder is the default download location,\\n-   *   2 if the default download location is elsewhere;\\n-   *   used to display special UI when the default location is the Desktop or\\n-   *   the Downloads folder in Download Manager UI and in the file field in\\n-   *   preferences\\n+   *   depreciated.\\n+   * browser.download.defaultFolder\\r\\n+   *   depreciated.\\r\\n    */\\n \\n   /**\\n@@ -232,7 +241,7 @@ var gMainPane = {\\n     // don't override the preference's value in UI\\n     return undefined;\\n   },\\n-\\n+  \\n   /**\\n    * Displays a file picker in which the user can choose the location where\\n    * downloads are automatically saved, updating preferences and UI in\\n@@ -241,133 +250,156 @@ var gMainPane = {\\n   chooseFolder: function ()\\n   {\\n     const nsIFilePicker = Components.interfaces.nsIFilePicker;\\n+    const nsILocalFile = Components.interfaces.nsILocalFile;\\n+\\n     var fp = Components.classes[\\\"@mozilla.org/filepicker;1\\\"]\\n                        .createInstance(nsIFilePicker);\\n     var bundlePreferences = document.getElementById(\\\"bundlePreferences\\\");\\n     var title = bundlePreferences.getString(\\\"chooseDownloadFolderTitle\\\");\\n     fp.init(window, title, nsIFilePicker.modeGetFolder);\\n-\\n-    const nsILocalFile = Components.interfaces.nsILocalFile;\\n-    var customDirPref = document.getElementById(\\\"browser.download.dir\\\");\\n-    if (customDirPref.value)\\n-      fp.displayDirectory = customDirPref.value;\\n     fp.appendFilters(nsIFilePicker.filterAll);\\n+\\n+    var folderListPref = document.getElementById(\\\"browser.download.folderList\\\");\\n+    var currentDirPref = this._indexToFolder(folderListPref.value); // file\\n+    var defDownloads = this._indexToFolder(1); // file\\n+\\n+    // First try to open what's currently configured\\n+    if (currentDirPref && currentDirPref.exists()) {\\n+      fp.displayDirectory = currentDirPref;\\n+    } // Try the system's download dir\\n+    else if (defDownloads && defDownloads.exists()) {\\n+      fp.displayDirectory = defDownloads;\\n+    } // Fall back to Desktop\\n+    else {\\n+      fp.displayDirectory = this._indexToFolder(0);\\n+    }\\n+\\n     if (fp.show() == nsIFilePicker.returnOK) {\\n       var file = fp.file.QueryInterface(nsILocalFile);\\n-      var currentDirPref = document.getElementById(\\\"browser.download.downloadDir\\\");\\n-      customDirPref.value = currentDirPref.value = file;\\n+      var currentDirPref = document.getElementById(\\\"browser.download.dir\\\");\\n+      currentDirPref.value = file;\\n       var folderListPref = document.getElementById(\\\"browser.download.folderList\\\");\\n       folderListPref.value = this._folderToIndex(file);\\n+      // Note, the real prefs will not be updated yet, so dnld manager's\\n+      // userDownloadsDirectory may not return the right folder after\\n+      // this code executes. displayDownloadDirPref will be called on\\n+      // the assignment above to update the UI.\\n     }\\n   },\\n \\n   /**\\n-   * Initializes the download folder widget based on the folder as stored in\\n+   * Initializes the download folder display settings based on the user's \\n    * preferences.\\n    */\\n-  readDownloadDirPref: function ()\\n+  displayDownloadDirPref: function ()\\n   {\\n     var folderListPref = document.getElementById(\\\"browser.download.folderList\\\");\\n     var bundlePreferences = document.getElementById(\\\"bundlePreferences\\\");\\n     var downloadFolder = document.getElementById(\\\"downloadFolder\\\");\\n-\\n-    var customDirPref = document.getElementById(\\\"browser.download.dir\\\");\\n-    var customIndex = customDirPref.value ? this._folderToIndex(customDirPref.value) : 0;\\n-    if (folderListPref.value == 0 || customIndex == 0)\\n-      downloadFolder.label = bundlePreferences.getString(\\\"desktopFolderName\\\");\\n-    else if (folderListPref.value == 1 || customIndex == 1)\\n-      downloadFolder.label = bundlePreferences.getString(\\\"myDownloadsFolderName\\\");\\n-    else\\n-      downloadFolder.label = this._getDisplayNameOfFile(customDirPref.value);\\n-\\n+    var currentDirPref = document.getElementById(\\\"browser.download.dir\\\");\\n+\\n+    // The user's download folder is based on the preferences listed above.\\r\\n+    // However, if the system does not support a download folder, the\\r\\n+    // actual path returned will be the system's desktop or home folder.\\r\\n+    // If this is the case, skip off displaying the Download label and\\r\\n+    // display Desktop, even though folderList might be 1.\\r\\n+    var fileLocator = Components.classes[\\\"@mozilla.org/file/directory_service;1\\\"]\\r\\n+                                .getService(Components.interfaces.nsIProperties);\\r\\n+    var desk = fileLocator.get(\\\"Desk\\\", Components.interfaces.nsILocalFile);\\r\\n+    var dnldMgr = Components.classes[\\\"@mozilla.org/download-manager;1\\\"]\\r\\n+                            .getService(Components.interfaces.nsIDownloadManager);\\r\\n+    var supportDownloadLabel = !dnldMgr.defaultDownloadsDirectory.equals(desk);\\r\\n+\\n+    // Used in defining the correct path to the folder icon.\\n     var ios = Components.classes[\\\"@mozilla.org/network/io-service;1\\\"]\\n                         .getService(Components.interfaces.nsIIOService);\\n     var fph = ios.getProtocolHandler(\\\"file\\\")\\n                  .QueryInterface(Components.interfaces.nsIFileProtocolHandler);\\n-    var currentDirPref = document.getElementById(\\\"browser.download.downloadDir\\\");\\n-    var downloadDir = currentDirPref.value || this._indexToFolder(folderListPref.value);\\n-    var urlspec = fph.getURLSpecFromFile(downloadDir);\\n-    downloadFolder.image = \\\"moz-icon://\\\" + urlspec + \\\"?size=16\\\";\\n-\\n+    var iconUrlSpec;\\n+      \\n+    // Display a 'pretty' label or the path in the UI.\\n+    if (folderListPref.value == 2) {\\n+      // Custom path selected and is configured\\n+      downloadFolder.label = this._getDisplayNameOfFile(currentDirPref.value);\\n+      iconUrlSpec = fph.getURLSpecFromFile(currentDirPref.value);\\n+    } else if (folderListPref.value == 1 && supportDownloadLabel) {\\n+      // 'Downloads'\\n+      // In 1.5, this pointed to a folder we created called 'My Downloads'\\n+      // and was available as an option in the 1.5 drop down. On XP this\\n+      // was in My Documents, on OSX it was in User Docs. In 2.0, we did\\n+      // away with the drop down option, although the special label was\\n+      // still supported for the folder if it existed. Because it was\\n+      // not exposed it was rarely used.\\n+      // With 3.0, a new desktop folder - 'Downloads' was introduced for\\n+      // platforms and versions that don't support a default system downloads\\n+      // folder. See nsDownloadManager for details. \\n+      downloadFolder.label = bundlePreferences.getString(\\\"downloadsFolderName\\\");\\n+      iconUrlSpec = fph.getURLSpecFromFile(this._indexToFolder(1));\\n+    } else {\\n+      // 'Desktop'\\n+      downloadFolder.label = bundlePreferences.getString(\\\"desktopFolderName\\\");\\n+      iconUrlSpec = fph.getURLSpecFromFile(desk);\\n+    }\\n+    downloadFolder.image = \\\"moz-icon://\\\" + iconUrlSpec + \\\"?size=16\\\";\\n+    \\n     // don't override the preference's value in UI\\n     return undefined;\\n   },\\n \\n   /**\\n-   * Determines the type of the given folder.\\n-   *\\n-   * @param   aFolder\\n-   *          the folder whose type is to be determined\\n-   * @returns integer\\n-   *          0 if aFolder is the Desktop or is unspecified,\\n-   *          1 if aFolder is the Downloads folder,\\n-   *          2 otherwise\\n+   * Returns the textual path of a folder in readable form.\\n    */\\n-  _folderToIndex: function (aFolder)\\n+  _getDisplayNameOfFile: function (aFolder)\\n   {\\n-    if (!aFolder || aFolder.equals(this._getDownloadsFolder(\\\"Desktop\\\")))\\n-      return 0;\\n-    else if (aFolder.equals(this._getDownloadsFolder(\\\"Downloads\\\")))\\n-      return 1;\\n-    return 2;\\n+    // TODO: would like to add support for 'Downloads on Macintosh HD'\\n+    //       for OS X users.\\n+    return aFolder ? aFolder.path : \\\"\\\";\\n   },\\n \\n   /**\\n    * Returns the Downloads folder.  If aFolder is \\\"Desktop\\\", then the Downloads\\n    * folder returned is the desktop folder; otherwise, it is a folder whose name\\n    * indicates that it is a download folder and whose path is as determined by\\n-   * the XPCOM directory service from aFolder.\\n+   * the XPCOM directory service via the download manager's attribute \\n+   * defaultDownloadsDirectory.\\n    *\\n    * @throws if aFolder is not \\\"Desktop\\\" or \\\"Downloads\\\"\\n    */\\n   _getDownloadsFolder: function (aFolder)\\n   {\\n-    var fileLocator = Components.classes[\\\"@mozilla.org/file/directory_service;1\\\"]\\n-                                .getService(Components.interfaces.nsIProperties);\\n-    var dir = fileLocator.get(this._getSpecialFolderKey(aFolder),\\n-                              Components.interfaces.nsILocalFile);\\n-    if (aFolder != \\\"Desktop\\\")\\n-      dir.append(\\\"My Downloads\\\"); // XXX l12y!\\n-\\n-    return dir;\\n+    switch(aFolder)\\n+    {\\n+      case \\\"Desktop\\\":\\n+        var fileLoc = Components.classes[\\\"@mozilla.org/file/directory_service;1\\\"]\\n+                                    .getService(Components.interfaces.nsIProperties);\\n+        return fileLoc.get(\\\"Desk\\\", Components.interfaces.nsILocalFile);\\n+      break;\\n+      case \\\"Downloads\\\":\\n+        var dnldMgr = Components.classes[\\\"@mozilla.org/download-manager;1\\\"]\\n+                                .getService(Components.interfaces.nsIDownloadManager);\\n+        return dnldMgr.defaultDownloadsDirectory;\\n+      break;\\n+    }\\n+    throw \\\"ASSERTION FAILED: folder type should be 'Desktop' or 'Downloads'\\\";\\n   },\\n \\n   /**\\n-   * Gets the platform-specific key to be fed to the directory service for the\\n-   * given special folder.\\n+   * Determines the type of the given folder.\\n    *\\n    * @param   aFolder\\n-   *          either of the strings \\\"Desktop\\\" or \\\"Downloads\\\"\\n-   * @returns the platform-specific key for the location, which may be used with\\n-   *          the XPCOM directory service\\n-   */\\n-  _getSpecialFolderKey: function (aFolderType)\\n-  {\\n-    if (aFolderType == \\\"Desktop\\\")\\n-      return \\\"Desk\\\";\\n-\\n-    if (aFolderType == \\\"Downloads\\\")\\n-#ifdef XP_WIN\\n-      return \\\"Pers\\\";\\n-#else\\n-#ifdef XP_MACOSX\\n-      return \\\"UsrDocs\\\";\\n-#else\\n-      return \\\"Home\\\";\\n-#endif\\n-#endif\\n-\\n-      throw \\\"ASSERTION FAILED: folder type should be 'Desktop' or 'Downloads'\\\";\\n-  },\\n-\\n-  /**\\n-   * Returns the textual path of a folder in readable form.\\n+   *          the folder whose type is to be determined\\n+   * @returns integer\\n+   *          0 if aFolder is the Desktop or is unspecified,\\n+   *          1 if aFolder is the Downloads folder,\\n+   *          2 otherwise\\n    */\\n-  _getDisplayNameOfFile: function (aFolder)\\n+  _folderToIndex: function (aFolder)\\n   {\\n-    // TODO: would like to add support for 'Downloads on Macintosh HD'\\n-    //       for OS X users.\\n-    return aFolder ? aFolder.path : \\\"\\\";\\n+    if (!aFolder || aFolder.equals(this._getDownloadsFolder(\\\"Desktop\\\")))\\n+      return 0;\\n+    else if (aFolder.equals(this._getDownloadsFolder(\\\"Downloads\\\")))\\n+      return 1;\\n+    return 2;\\n   },\\n \\n   /**\\n@@ -377,7 +409,7 @@ var gMainPane = {\\n    *          an integer\\n    * @returns the Desktop folder if aIndex == 0,\\n    *          the Downloads folder if aIndex == 1,\\n-   *          the folder stored in browser.download.dir otherwise\\n+   *          the folder stored in browser.download.dir\\n    */\\n   _indexToFolder: function (aIndex)\\n   {\\n@@ -387,19 +419,31 @@ var gMainPane = {\\n       case 1:\\n         return this._getDownloadsFolder(\\\"Downloads\\\");\\n     }\\n-\\n-    var customDirPref = document.getElementById(\\\"browser.download.dir\\\");\\n-    return customDirPref.value;\\n+    var currentDirPref = document.getElementById(\\\"browser.download.dir\\\");\\n+    return currentDirPref.value;\\n   },\\n \\n   /**\\n-   * Returns the value for the browser.download.folderList preference determined\\n-   * from the current value of browser.download.downloadDir.\\n+   * Returns the value for the browser.download.folderList preference.\\n    */\\n-  writeFolderList: function ()\\n+  getFolderListPref: function ()\\n   {\\n-    var currentDirPref = document.getElementById(\\\"browser.download.downloadDir\\\");\\n-    return this._folderToIndex(currentDirPref.value);\\n+    var folderListPref = document.getElementById(\\\"browser.download.folderList\\\");\\n+    switch(folderListPref.value) {\\n+      case 0: // Desktop\\n+      case 1: // Downloads\\n+        return folderListPref.value;\\n+      break;\\n+      case 2: // Custom\\n+        var currentDirPref = document.getElementById(\\\"browser.download.dir\\\");\\n+        if (currentDirPref.value) {\\n+          // Resolve to a known location if possible. We are writing out\\n+          // to prefs on this call, so now would be a good time to do it.\\n+          return this._folderToIndex(currentDirPref.value);\\n+        }\\n+        return 0;\\n+      break;\\n+    }\\n   }\\n \\n #ifdef HAVE_SHELL_SERVICE\\ndiff --git a/browser/components/preferences/main.xul b/browser/components/preferences/main.xul\\nindex 9889c86..f0674fc 100644\\n--- a/browser/components/preferences/main.xul\\n+++ b/browser/components/preferences/main.xul\\n@@ -91,7 +91,6 @@\\n                   name=\\\"browser.download.dir\\\"\\n                   type=\\\"file\\\"\\n                   onchange=\\\"gMainPane.readDownloadDirPref();\\\"/>\\n-      <preference id=\\\"browser.download.downloadDir\\\"       name=\\\"browser.download.downloadDir\\\"       type=\\\"file\\\"/>\\n       <preference id=\\\"browser.download.folderList\\\"        name=\\\"browser.download.folderList\\\"        type=\\\"int\\\"/>\\n \\n       <!-- SYSTEM DEFAULTS -->\\n@@ -177,8 +176,8 @@\\n           <filefield id=\\\"downloadFolder\\\" flex=\\\"1\\\"\\n                      preference=\\\"browser.download.folderList\\\"\\n                      preference-editable=\\\"true\\\"\\n-                     onsyncfrompreference=\\\"return gMainPane.readDownloadDirPref();\\\"\\n-                     onsynctopreference=\\\"return gMainPane.writeFolderList()\\\"/>\\n+                     onsyncfrompreference=\\\"return gMainPane.displayDownloadDirPref();\\\"\\n+                     onsynctopreference=\\\"return gMainPane.getFolderListPref()\\\"/>\\n           <button id=\\\"chooseFolder\\\" oncommand=\\\"gMainPane.chooseFolder();\\\"\\n #ifdef XP_MACOSX\\n                   accesskey=\\\"&chooseFolderMac.accesskey;\\\"\\n@@ -188,7 +187,7 @@\\n                   label=\\\"&chooseFolderWin.label;\\\"\\n #endif\\n                   preference=\\\"browser.download.folderList\\\"\\n-                  onsynctopreference=\\\"return gMainPane.writeFolderList();\\\"/>\\n+                  onsynctopreference=\\\"return gMainPane.getFolderListPref();\\\"/>\\n         </hbox>\\n         <radio id=\\\"alwaysAsk\\\" value=\\\"false\\\"\\n                label=\\\"&alwaysAsk.label;\\\"\\ndiff --git a/browser/locales/en-US/chrome/browser/preferences/preferences.properties b/browser/locales/en-US/chrome/browser/preferences/preferences.properties\\nindex cc02033..e9d6b41 100644\\n--- a/browser/locales/en-US/chrome/browser/preferences/preferences.properties\\n+++ b/browser/locales/en-US/chrome/browser/preferences/preferences.properties\\n@@ -40,7 +40,7 @@ languageCodeFormat=%1$S  [%2$S]\\n #### Downloads\\n \\n desktopFolderName=Desktop\\n-myDownloadsFolderName=My Downloads\\n+downloadsFolderName=Downloads\\n chooseDownloadFolderTitle=Choose Download Folder:\\n \\n #### Download Actions\\ndiff --git a/toolkit/components/downloads/public/nsIDownloadManager.idl b/toolkit/components/downloads/public/nsIDownloadManager.idl\\nindex baaaa02..303b259 100644\\n--- a/toolkit/components/downloads/public/nsIDownloadManager.idl\\n+++ b/toolkit/components/downloads/public/nsIDownloadManager.idl\\n@@ -51,7 +51,7 @@ interface nsIDownloadProgressListener;\\n interface nsISimpleEnumerator;\\n interface mozIStorageConnection;\\n \\n-[scriptable, uuid(a44925cb-186a-4e57-846e-8f9504b9f675)]\\n+[scriptable, uuid(b23d291f-2893-48ea-abda-ba9c9fe69c95)]\\n interface nsIDownloadManager : nsISupports {\\n   // Download States\\n   const short DOWNLOAD_NOTSTARTED       = -1;\\n@@ -210,6 +210,33 @@ interface nsIDownloadManager : nsISupports {\\n    * Removes a listener from the download manager.\\n    */\\n   void removeListener(in nsIDownloadProgressListener aListener);\\n+\\n+  /**\\n+   * Returns the platform default downloads directory.\\n+   */\\n+  readonly attribute nsILocalFile defaultDownloadsDirectory;\\n+\\n+  /**\\n+   * Returns the user configured downloads directory. \\n+   * The path is dependent on two user configurable prefs\\n+   * set in preferences:\\n+   *\\n+   * browser.download.folderList\\n+   *   Indicates the location users wish to save downloaded \\r\\n+   *   files too.  \\r\\n+   *   Values: \\r\\n+   *     0 - The desktop is the default download location. \\r\\n+   *     1 - The system's downloads folder is the default download location. \\r\\n+   *     2 - The default download location is elsewhere as specified in  \\r\\n+   *         browser.download.dir. If invalid, userDownloadsDirectory\\r\\n+   *         will fallback on defaultDownloadsDirectory.\\r\\n+   *\\r\\n+   * browser.download.dir - \\n+   *   A local path the user may have selected at some point \\r\\n+   *   where downloaded files are saved. The use of which is\\r\\n+   *   enabled when folderList equals 2. \\r\\n+   */\\n+  readonly attribute nsILocalFile userDownloadsDirectory;\\n };\\n \\n \\ndiff --git a/toolkit/components/downloads/src/nsDownloadManager.cpp b/toolkit/components/downloads/src/nsDownloadManager.cpp\\nindex 869b4d6..b5954f0 100644\\n--- a/toolkit/components/downloads/src/nsDownloadManager.cpp\\n+++ b/toolkit/components/downloads/src/nsDownloadManager.cpp\\n@@ -52,6 +52,7 @@\\n #include \\\"nsIDOMEvent.h\\\"\\n #include \\\"nsIDOMEventTarget.h\\\"\\n #include \\\"nsAppDirectoryServiceDefs.h\\\"\\n+#include \\\"nsDirectoryServiceDefs.h\\\"\\n #include \\\"nsIWindowWatcher.h\\\"\\n #include \\\"nsIWindowMediator.h\\\"\\n #include \\\"nsIPromptService.h\\\"\\n@@ -66,8 +67,8 @@\\n #include \\\"mozStorageHelper.h\\\"\\n #include \\\"nsIMutableArray.h\\\"\\n #include \\\"nsIAlertsService.h\\\"\\n+#include \\\"nsIPropertyBag2.h\\\"\\r\\n #include \\\"nsIHttpChannel.h\\\"\\n-#include \\\"nsIPropertyBag2.h\\\"\\n \\n #ifdef XP_WIN\\n #include <shlobj.h>\\n@@ -708,6 +709,180 @@ nsDownloadManager::GetActiveDownloads(nsISimpleEnumerator **aResult)\\n }\\n \\n NS_IMETHODIMP\\n+nsDownloadManager::GetDefaultDownloadsDirectory(nsILocalFile **aResult)\\n+{\\n+  nsCOMPtr<nsILocalFile> downloadDir;\\r\\n+\\r\\n+  nsresult rv;\\r\\n+  nsCOMPtr<nsIProperties> dirService =\\r\\n+     do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID, &rv);\\r\\n+  NS_ENSURE_SUCCESS(rv, rv);\\r\\n+\\r\\n+  // OSX:\\r\\n+  // Safari download folder or Desktop/Downloads\\r\\n+  // Vista:\\r\\n+  // Downloads\\r\\n+  // XP/2K:\\r\\n+  // Desktop/Downloads\\r\\n+  // Linux:\\r\\n+  // Home/Downloads\\r\\n+\\n+  nsXPIDLString folderName;\\n+  mBundle->GetStringFromName(NS_LITERAL_STRING(\\\"downloadsFolder\\\").get(),\\n+                             getter_Copies(folderName));\\n+\\n+#if defined (XP_MACOSX)\\r\\n+  nsCOMPtr<nsILocalFile> desktopDir;\\r\\n+  rv = dirService->Get(NS_OSX_DEFAULT_DOWNLOAD_DIR,\\r\\n+                       NS_GET_IID(nsILocalFile),\\r\\n+                       getter_AddRefs(downloadDir));\\r\\n+  NS_ENSURE_SUCCESS(rv, rv);\\r\\n+  rv = dirService->Get(NS_OSX_USER_DESKTOP_DIR,\\r\\n+                       NS_GET_IID(nsILocalFile),\\r\\n+                       getter_AddRefs(desktopDir));\\r\\n+  NS_ENSURE_SUCCESS(rv, rv);\\r\\n+\\r\\n+  // Check to see if we have the desktop or the Safari downloads folder\\r\\n+  PRBool equals;\\r\\n+  rv = downloadDir->Equals(desktopDir, &equals);\\r\\n+  NS_ENSURE_SUCCESS(rv, rv);\\r\\n+  if (equals) {\\r\\n+    rv = downloadDir->Append(folderName);\\r\\n+    NS_ENSURE_SUCCESS(rv, rv);\\r\\n+  }\\r\\n+#elif defined (XP_WIN)\\r\\n+  rv = dirService->Get(NS_WIN_DEFAULT_DOWNLOAD_DIR,\\r\\n+                       NS_GET_IID(nsILocalFile),\\r\\n+                       getter_AddRefs(downloadDir));\\r\\n+  NS_ENSURE_SUCCESS(rv, rv);\\r\\n+\\r\\n+  // Check the os version\\r\\n+  #define NS_SYSTEMINFO_CONTRACTID \\\"@mozilla.org/system-info;1\\\"\\r\\n+  nsCOMPtr<nsIPropertyBag2> infoService =\\r\\n+     do_GetService(NS_SYSTEMINFO_CONTRACTID, &rv);\\r\\n+  NS_ENSURE_SUCCESS(rv, rv);\\r\\n+\\r\\n+  PRInt32 version;\\r\\n+  NS_NAMED_LITERAL_STRING(osVersion, \\\"version\\\");\\r\\n+  rv = infoService->GetPropertyAsInt32(osVersion, &version);\\r\\n+  if (version < 6) { // XP/2K\\r\\n+    rv = downloadDir->Append(folderName);\\r\\n+    NS_ENSURE_SUCCESS(rv, rv);\\r\\n+  }\\r\\n+#else\\r\\n+  rv = dirService->Get(NS_OS_HOME_DIR,\\r\\n+                       NS_GET_IID(nsILocalFile),\\r\\n+                       getter_AddRefs(downloadDir));\\r\\n+  NS_ENSURE_SUCCESS(rv, rv);\\r\\n+  rv = downloadDir->Append(folderName);\\r\\n+  NS_ENSURE_SUCCESS(rv, rv);\\r\\n+#endif\\n+\\n+  NS_ADDREF(*aResult = downloadDir);\\n+\\n+  return NS_OK;\\n+}\\n+\\n+#define NS_BRANCH_DOWNLOAD     \\\"browser.download.\\\"\\r\\n+#define NS_PREF_FOLDERLIST     \\\"folderList\\\"\\r\\n+#define NS_PREF_DIR            \\\"dir\\\"\\r\\n+\\n+NS_IMETHODIMP\\n+nsDownloadManager::GetUserDownloadsDirectory(nsILocalFile **aResult)\\n+{\\n+  nsresult rv;\\r\\n+  nsCOMPtr<nsIProperties> dirService =\\r\\n+     do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID, &rv);\\r\\n+  NS_ENSURE_SUCCESS(rv, rv);\\r\\n+\\r\\n+  nsCOMPtr<nsIPrefService> prefService =\\r\\n+     do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);\\r\\n+  NS_ENSURE_SUCCESS(rv, rv);\\r\\n+\\r\\n+  nsCOMPtr<nsIPrefBranch> prefBranch;\\r\\n+  rv = prefService->GetBranch(NS_BRANCH_DOWNLOAD, \\r\\n+                              getter_AddRefs(prefBranch));\\r\\n+  NS_ENSURE_SUCCESS(rv, rv);\\r\\n+\\r\\n+  PRInt32 val;\\r\\n+  rv = prefBranch->GetIntPref(NS_PREF_FOLDERLIST,\\r\\n+                              &val);\\r\\n+  NS_ENSURE_SUCCESS(rv, rv);\\r\\n+\\r\\n+  PRBool bRes = PR_FALSE;\\r\\n+\\r\\n+  switch(val) {\\r\\n+    case 0: // Desktop\\r\\n+      {\\r\\n+        nsCOMPtr<nsILocalFile> downloadDir;\\r\\n+        nsCOMPtr<nsIProperties> dirService =\\r\\n+           do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID, &rv);\\r\\n+        NS_ENSURE_SUCCESS(rv, rv);\\r\\n+        rv = dirService->Get(NS_OS_DESKTOP_DIR,\\r\\n+                             NS_GET_IID(nsILocalFile),\\r\\n+                             getter_AddRefs(downloadDir));\\r\\n+        NS_ENSURE_SUCCESS(rv, rv);\\r\\n+        NS_ADDREF(*aResult = downloadDir);\\r\\n+        return NS_OK;\\r\\n+      }\\r\\n+      break;\\r\\n+    case 1: // Downloads\\r\\n+      {\\r\\n+        rv = GetDefaultDownloadsDirectory(aResult); // refup\\r\\n+        NS_ENSURE_SUCCESS(rv, rv);\\r\\n+        (*aResult)->Exists(&bRes);\\r\\n+        if (!bRes) {\\r\\n+          rv = (*aResult)->Create(nsIFile::DIRECTORY_TYPE, 755);\\r\\n+          NS_ENSURE_SUCCESS(rv, rv);\\r\\n+        }\\r\\n+        return NS_OK;\\n+      }\\n+      break;\\r\\n+    case 2: // Custom\\r\\n+      {\\r\\n+        nsCOMPtr<nsISupportsString> customDirectory;\\r\\n+        prefBranch->GetComplexValue(NS_PREF_DIR, \\r\\n+                                    NS_GET_IID(nsISupportsString),\\r\\n+                                    getter_AddRefs(customDirectory));\\r\\n+        if (customDirectory) {\\r\\n+          nsCOMPtr<nsILocalFile> aFile = \\r\\n+            do_CreateInstance(\\\"@mozilla.org/file/local;1\\\", &rv);\\r\\n+          NS_ENSURE_SUCCESS(rv, rv);\\r\\n+          nsAutoString dir;\\r\\n+          customDirectory->GetData(dir);\\r\\n+          rv = aFile->InitWithNativePath(NS_ConvertUTF16toUTF8(dir));\\r\\n+          NS_ENSURE_SUCCESS(rv, rv);\\r\\n+          aFile->Exists(&bRes);\\r\\n+          if (bRes) {\\r\\n+            NS_ADDREF(*aResult = aFile);\\n+            return NS_OK;\\n+          }\\r\\n+          rv = aFile->Create(nsIFile::DIRECTORY_TYPE, 755);\\r\\n+          NS_ENSURE_SUCCESS(rv, rv);\\r\\n+          if (bRes) {\\r\\n+            NS_ADDREF(*aResult = aFile);\\n+            return NS_OK;\\n+          }\\r\\n+        }\\r\\n+        rv = GetDefaultDownloadsDirectory(aResult); // refup\\r\\n+        NS_ENSURE_SUCCESS(rv, rv);\\r\\n+        (*aResult)->Exists(&bRes);\\r\\n+        if (!bRes) {\\r\\n+          rv = (*aResult)->Create(nsIFile::DIRECTORY_TYPE, 755);\\r\\n+          NS_ENSURE_SUCCESS(rv, rv);\\r\\n+          // Update dir pref\\r\\n+          prefBranch->SetComplexValue(NS_PREF_DIR,\\r\\n+                                      NS_GET_IID(nsILocalFile),\\r\\n+                                      *aResult);\\r\\n+        }\\r\\n+        return NS_OK;\\n+      }\\r\\n+      break;\\r\\n+  }\\r\\n+  return NS_ERROR_INVALID_ARG;\\n+}\\n+\\n+NS_IMETHODIMP\\n nsDownloadManager::AddDownload(DownloadType aDownloadType, \\n                                nsIURI* aSource,\\n                                nsIURI* aTarget,\\ndiff --git a/toolkit/content/contentAreaUtils.js b/toolkit/content/contentAreaUtils.js\\nindex 4acd1fc..c3b5035 100644\\n--- a/toolkit/content/contentAreaUtils.js\\n+++ b/toolkit/content/contentAreaUtils.js\\n@@ -451,79 +451,35 @@ function getTargetFile(aFpP, aSkipPrompt)\\n \\n   const nsILocalFile = Components.interfaces.nsILocalFile;\\n \\n-  // ben 07/31/2003:\\n-  // |browser.download.defaultFolder| holds the default download folder for \\n-  // all files when the user has elected to have all files automatically\\n-  // download to a folder. The values of |defaultFolder| can be either their\\n-  // desktop, their downloads folder (My Documents\\\\My Downloads) or some other\\n-  // location of their choosing (which is mapped to |browser.download.dir|\\n-  // This pref is _unset_ when the user has elected to be asked about where\\n-  // to place every download - this will force the prompt to ask the user\\n-  // where to put saved files. \\n-  var dir = null;\\n-  var useDownloadDir = prefs.getBoolPref(\\\"useDownloadDir\\\");\\n-  \\n-  function getSpecialFolderKey(aFolderType) \\n-  {\\n-    if (aFolderType == \\\"Desktop\\\")\\n-      return \\\"Desk\\\";\\n-    \\n-    if (aFolderType != \\\"Downloads\\\")\\n-      throw \\\"ASSERTION FAILED: folder type should be 'Desktop' or 'Downloads'\\\";\\n-    \\n-#ifdef XP_WIN\\n-    return \\\"Pers\\\";\\n-#else\\n-#ifdef XP_MACOSX\\n-    return \\\"UsrDocs\\\";\\n-#else\\n-    return \\\"Home\\\";\\n-#endif\\n-#endif\\n-  }\\n-  \\n-  function getDownloadsFolder(aFolder)\\n-  {\\n-    var fileLocator = Components.classes[\\\"@mozilla.org/file/directory_service;1\\\"]\\n-                                .getService(Components.interfaces.nsIProperties);\\n-    \\n-    var dir = fileLocator.get(getSpecialFolderKey(aFolder), Components.interfaces.nsILocalFile);\\n-    \\n-    var bundle = Components.classes[\\\"@mozilla.org/intl/stringbundle;1\\\"]\\n-                           .getService(Components.interfaces.nsIStringBundleService);\\n-    bundle = bundle.createBundle(\\\"chrome://mozapps/locale/downloads/unknownContentType.properties\\\");\\n-    \\n-    var description = bundle.GetStringFromName(\\\"myDownloads\\\");\\n-    if (aFolder != \\\"Desktop\\\")\\n-      dir.append(description);\\n-    \\n-    return dir;\\n-  }\\n+  // For information on download folder preferences, see\\n+  // mozilla/browser/components/preferences/main.js\\n   \\n-  switch (prefs.getIntPref(\\\"folderList\\\")) {\\n-  case 0:\\n-    dir = getDownloadsFolder(\\\"Desktop\\\")\\n-    break;\\n-  case 1:\\n-    dir = getDownloadsFolder(\\\"Downloads\\\");\\n-    break;\\n-  case 2:\\n-    dir = prefs.getComplexValue(\\\"dir\\\", nsILocalFile);\\n-    break;\\n+  var useDownloadDir = prefs.getBoolPref(\\\"useDownloadDir\\\");\\n+  var dir = null;\\r\\n+  \\r\\n+  try {\\n+    // On prompt operations, default to lastDir, on direct to folder\\n+    // downloads, default to the user's configured download folder.\\n+    // (right-click save image vs. drag-and-drop into download manager)\\n+    var lastDir = prefs.getComplexValue(\\\"lastDir\\\", nsILocalFile);\\n+    var dnldMgr = Components.classes[\\\"@mozilla.org/download-manager;1\\\"]\\n+                            .getService(Components.interfaces.nsIDownloadManager);\\n+    if (!aSkipPrompt) {\\n+      dir = lastDir;\\n+    } else {\\n+      dir = dnldMgr.userDownloadsDirectory;\\n+    }\\n+  } catch (ex) {\\n   }\\n-  \\n-  if (!aSkipPrompt || !useDownloadDir || !dir) {\\n+\\r\\n+  if (!aSkipPrompt || !useDownloadDir || !dir || (dir && !dir.exists())) {\\n     // If we're asking the user where to save the file, root the Save As...\\n-    // dialog on they place they last picked. \\n-    try {\\n-      dir = prefs.getComplexValue(\\\"lastDir\\\", nsILocalFile);\\n-    }\\n-    catch (e) {\\n-      // No default download location. Default to desktop. \\n+    // dialog on the place they last picked.\\n+    if (!dir || (dir && !dir.exists())) {\\n+      // Default to desktop.\\n       var fileLocator = Components.classes[\\\"@mozilla.org/file/directory_service;1\\\"]\\n                                   .getService(Components.interfaces.nsIProperties);\\n-      \\n-      dir = fileLocator.get(getSpecialFolderKey(\\\"Desktop\\\"), nsILocalFile);\\n+      dir = fileLocator.get(\\\"Desk\\\", nsILocalFile);\\n     }\\n \\n     var fp = makeFilePicker();\\n@@ -548,7 +504,7 @@ function getTargetFile(aFpP, aSkipPrompt)\\n       catch (e) {\\n       }\\n     }\\n-  \\n+\\n     if (fp.show() == Components.interfaces.nsIFilePicker.returnCancel || !fp.file)\\n       return false;\\n     \\ndiff --git a/toolkit/locales/en-US/chrome/mozapps/downloads/downloads.properties b/toolkit/locales/en-US/chrome/mozapps/downloads/downloads.properties\\nindex 3f5aa37..0e9aea6 100644\\n--- a/toolkit/locales/en-US/chrome/mozapps/downloads/downloads.properties\\n+++ b/toolkit/locales/en-US/chrome/mozapps/downloads/downloads.properties\\n@@ -60,3 +60,6 @@ fileExecutableSecurityWarningTitle=Open Executable File?\\n fileExecutableSecurityWarningDontAsk=Don't ask me this again\\n \\n displayNameDesktop=Desktop\\n+\\n+# Desktop folder name for downloaded files\\n+downloadsFolder=Downloads\\ndiff --git a/toolkit/locales/en-US/chrome/mozapps/downloads/unknownContentType.properties b/toolkit/locales/en-US/chrome/mozapps/downloads/unknownContentType.properties\\nindex 2ec9767..6853efe 100755\\n--- a/toolkit/locales/en-US/chrome/mozapps/downloads/unknownContentType.properties\\n+++ b/toolkit/locales/en-US/chrome/mozapps/downloads/unknownContentType.properties\\n@@ -43,7 +43,6 @@ chooseAppFilePickerTitle=Choose Helper Application\\n badApp=The application you chose (\\\"%S\\\") could not be found.  Check the file name or choose another application.\\n badApp.title=Application not found\\n selectDownloadDir=Select Download Folder\\n-myDownloads=My Downloads\\n unknownAccept.label=Save File\\n unknownCancel.label=Cancel\\n fileType=%S file\\ndiff --git a/toolkit/mozapps/downloads/src/nsHelperAppDlg.js.in b/toolkit/mozapps/downloads/src/nsHelperAppDlg.js.in\\nindex a400b1b..80eef2d 100644\\n--- a/toolkit/mozapps/downloads/src/nsHelperAppDlg.js.in\\n+++ b/toolkit/mozapps/downloads/src/nsHelperAppDlg.js.in\\n@@ -121,134 +121,86 @@ nsUnknownContentTypeDialog.prototype = {\\n     // Note - this function is called without a dialog, so it cannot access any part\\n     // of the dialog XUL as other functions on this object do. \\n     promptForSaveToFile: function(aLauncher, aContext, aDefaultFile, aSuggestedFileExtension) {\\n-      var result = \\\"\\\";\\n+      var result = null;\\n       \\n       this.mLauncher = aLauncher;\\n \\n-      // If the user is always downloading to the same location, the default download\\n-      // folder is stored in preferences. If a value is found stored, use that \\n-      // automatically and don't ask via a dialog. \\n+      // Check to see if the user wishes to auto save to the default download\\n+      // folder without prompting.\\n       var prefs = Components.classes[\\\"@mozilla.org/preferences-service;1\\\"].getService(Components.interfaces.nsIPrefBranch);\\n       var autodownload = prefs.getBoolPref(\\\"browser.download.useDownloadDir\\\");\\n+      \\n       if (autodownload) {\\n-        function getSpecialFolderKey(aFolderType) \\n-        {\\n-          if (aFolderType == \\\"Desktop\\\")\\n-            return \\\"Desk\\\";\\n-        \\n-          if (aFolderType != \\\"Downloads\\\")\\n-            throw \\\"ASSERTION FAILED: folder type should be 'Desktop' or 'Downloads'\\\";\\n-        \\n-#ifdef XP_WIN\\n-          return \\\"Pers\\\";\\n-#else\\n-#ifdef XP_MACOSX\\n-          return \\\"UsrDocs\\\";\\n-#else\\n-          return \\\"Home\\\";\\n-#endif\\n-#endif\\n-        }\\n-        \\n-        function getDownloadsFolder(aFolder)\\n-        {\\n-          var fileLocator = Components.classes[\\\"@mozilla.org/file/directory_service;1\\\"].getService(Components.interfaces.nsIProperties);\\n-\\n-          var dir = fileLocator.get(getSpecialFolderKey(aFolder), Components.interfaces.nsILocalFile);\\n-          \\n-          var bundle = Components.classes[\\\"@mozilla.org/intl/stringbundle;1\\\"].getService(Components.interfaces.nsIStringBundleService);\\n-          bundle = bundle.createBundle(\\\"chrome://mozapps/locale/downloads/unknownContentType.properties\\\");\\n-\\n-          var description = bundle.GetStringFromName(\\\"myDownloads\\\");\\n-          if (aFolder != \\\"Desktop\\\")\\n-            dir.append(description);\\n-            \\n-          return dir;\\n-        }\\n-\\n-        var defaultFolder = null;\\n-        switch (prefs.getIntPref(\\\"browser.download.folderList\\\")) {\\n-        case 0:\\n-          defaultFolder = getDownloadsFolder(\\\"Desktop\\\");\\n-          break;\\n-        case 1:\\n-          defaultFolder = getDownloadsFolder(\\\"Downloads\\\");\\n-          break;\\n-        case 2:\\n-          defaultFolder = prefs.getComplexValue(\\\"browser.download.dir\\\", Components.interfaces.nsILocalFile);\\n-          break;\\n-        }\\n-        \\n+        // Retrieve the user's default download directory\\r\\n+        var dnldMgr = Components.classes[\\\"@mozilla.org/download-manager;1\\\"]\\n+                                .getService(Components.interfaces.nsIDownloadManager);\\n+        var defaultFolder = dnldMgr.userDownloadsDirectory;\\n         result = this.validateLeafName(defaultFolder, aDefaultFile, aSuggestedFileExtension);\\n       }\\n       \\n-      if (!result) {\\n-        // Use file picker to show dialog.\\n-        var nsIFilePicker = Components.interfaces.nsIFilePicker;\\n-        var picker = Components.classes[\\\"@mozilla.org/filepicker;1\\\"].createInstance(nsIFilePicker);\\n-\\n-        var bundle = Components.classes[\\\"@mozilla.org/intl/stringbundle;1\\\"].getService(Components.interfaces.nsIStringBundleService);\\n-        bundle = bundle.createBundle(\\\"chrome://mozapps/locale/downloads/unknownContentType.properties\\\");\\n-\\n-        var windowTitle = bundle.GetStringFromName(\\\"saveDialogTitle\\\");\\n-        var parent = aContext.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIDOMWindowInternal);\\n-        picker.init(parent, windowTitle, nsIFilePicker.modeSave);\\n-        picker.defaultString = aDefaultFile;\\n-\\n-        if (aSuggestedFileExtension) {\\n-          // aSuggestedFileExtension includes the period, so strip it\\n-          picker.defaultExtension = aSuggestedFileExtension.substring(1);\\n-        } \\n-        else {\\n-          try {\\n-            picker.defaultExtension = this.mLauncher.MIMEInfo.primaryExtension;\\n-          } \\n-          catch (ex) { }\\n-        }\\n+      // Check to make sure we have a valid directory, otherwise, prompt\\n+      if (result)\\n+        return result;\\n+      \\n+      // Use file picker to show dialog.\\n+      var nsIFilePicker = Components.interfaces.nsIFilePicker;\\n+      var picker = Components.classes[\\\"@mozilla.org/filepicker;1\\\"].createInstance(nsIFilePicker);\\n \\n-        var wildCardExtension = \\\"*\\\";\\n-        if (aSuggestedFileExtension) {\\n-          wildCardExtension += aSuggestedFileExtension;\\n-          picker.appendFilter(this.mLauncher.MIMEInfo.description, wildCardExtension);\\n-        }\\n+      var bundle = Components.classes[\\\"@mozilla.org/intl/stringbundle;1\\\"].getService(Components.interfaces.nsIStringBundleService);\\n+      bundle = bundle.createBundle(\\\"chrome://mozapps/locale/downloads/unknownContentType.properties\\\");\\n \\n-        picker.appendFilters( nsIFilePicker.filterAll );\\n+      var windowTitle = bundle.GetStringFromName(\\\"saveDialogTitle\\\");\\n+      var parent = aContext.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIDOMWindowInternal);\\n+      picker.init(parent, windowTitle, nsIFilePicker.modeSave);\\n+      picker.defaultString = aDefaultFile;\\n \\n-        // Pull in the user's preferences and get the default download directory.\\n-        var prefs = Components.classes[\\\"@mozilla.org/preferences-service;1\\\"].getService(Components.interfaces.nsIPrefBranch);\\n+      if (aSuggestedFileExtension) {\\n+        // aSuggestedFileExtension includes the period, so strip it\\n+        picker.defaultExtension = aSuggestedFileExtension.substring(1);\\n+      } \\n+      else {\\n         try {\\n-          var startDir = prefs.getComplexValue(\\\"browser.download.dir\\\", Components.interfaces.nsILocalFile);\\n-          if (startDir.exists()) {\\n-            picker.displayDirectory = startDir;\\n-          }\\n+          picker.defaultExtension = this.mLauncher.MIMEInfo.primaryExtension;\\n         } \\n-        catch(exception) { }\\n+        catch (ex) { }\\n+      }\\n \\n-        var dlgResult = picker.show();\\n+      var wildCardExtension = \\\"*\\\";\\n+      if (aSuggestedFileExtension) {\\n+        wildCardExtension += aSuggestedFileExtension;\\n+        picker.appendFilter(this.mLauncher.MIMEInfo.description, wildCardExtension);\\n+      }\\n \\n-        if (dlgResult == nsIFilePicker.returnCancel) {\\n-          // null result means user cancelled.\\n-          return null;\\n-        }\\n+      picker.appendFilters( nsIFilePicker.filterAll );\\n+\\n+      // Get the default download directory from download manager\\n+      var dnldMgr = Components.classes[\\\"@mozilla.org/download-manager;1\\\"]\\n+                              .getService(Components.interfaces.nsIDownloadManager);\\n+      var startDir = dnldMgr.defaultDownloadsDirectory;\\n+      picker.displayDirectory = startDir;\\n \\n+      if (picker.show() == nsIFilePicker.returnCancel) {\\n+        // null result means user cancelled.\\n+        return null;\\n+      }\\n \\n-        // Be sure to save the directory the user chose through the Save As... \\n-        // dialog  as the new browser.download.dir\\n-        result = picker.file;\\n+      // Be sure to save the directory the user chose through the Save As... \\n+      // dialog  as the new browser.download.dir since the old one\\n+      // didn't exist.\\n+      result = picker.file;\\n \\n-        if (result) {\\n-          try {\\n-            // Remove the file so that it's not there when we ensure non-existence later;\\n-            // this is safe because for the file to exist, the user would have had to\\n-            // confirm that he wanted the file overwritten.\\n-            if (result.exists())\\n-              result.remove(false);\\n-          }\\n-          catch (e) { }\\n-          var newDir = result.parent;\\n-          prefs.setComplexValue(\\\"browser.download.dir\\\", Components.interfaces.nsILocalFile, newDir);\\n-          result = this.validateLeafName(newDir, result.leafName, null);\\n+      if (result) {\\n+        try {\\n+          // Remove the file so that it's not there when we ensure non-existence later;\\n+          // this is safe because for the file to exist, the user would have had to\\n+          // confirm that he wanted the file overwritten.\\n+          if (result.exists())\\n+            result.remove(false);\\n         }\\n+        catch (e) { }\\n+        var newDir = result.parent;\\n+        prefs.setComplexValue(\\\"browser.download.dir\\\", Components.interfaces.nsILocalFile, newDir);\\n+        result = this.validateLeafName(newDir, result.leafName, null);\\n       }\\n       return result;\\n     },\\ndiff --git a/xpcom/io/SpecialSystemDirectory.cpp b/xpcom/io/SpecialSystemDirectory.cpp\\nindex 03d53c9..5fdd940 100644\\n--- a/xpcom/io/SpecialSystemDirectory.cpp\\n+++ b/xpcom/io/SpecialSystemDirectory.cpp\\n@@ -450,12 +450,20 @@ GetSpecialSystemDirectory(SystemDirectories aSystemSystemDirectory,\\n             return GetWindowsFolder(CSIDL_PROGRAMS, aFile);\\n         }\\n \\n-        case Win_Downloads:\\n-        {\\n-            // Defined in KnownFolders.h.\\n-            GUID folderid_downloads = {0x374de290, 0x123f, 0x4565, {0x91, 0x64, 0x39, 0xc4, 0x92, 0x5e, 0x46, 0x7b}};\\n-            return GetKnownFolder(&folderid_downloads, aFile);\\n-        }\\n+        case Win_Downloads:\\r\\n+        {\\r\\n+            // Defined in KnownFolders.h.\\r\\n+            GUID folderid_downloads = {0x374de290, 0x123f, 0x4565, {0x91, 0x64,\\r\\n+                                       0x39, 0xc4, 0x92, 0x5e, 0x46, 0x7b}};\\r\\n+            nsresult rv = GetKnownFolder(&folderid_downloads, aFile);\\r\\n+            // On WinXP and 2k, there is no downloads folder, default\\r\\n+            // to 'Desktop'.\\r\\n+            if(NS_ERROR_FAILURE == rv)\\r\\n+            {\\r\\n+              rv = GetWindowsFolder(CSIDL_DESKTOP, aFile);\\r\\n+            }\\r\\n+            return rv;\\r\\n+        }\\r\\n \\n         case Win_Controls:\\n         {\\n\""}