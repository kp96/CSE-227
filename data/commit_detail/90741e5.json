{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas90741e5\""},"diff":"\"90741e5 Bug 321517: A text file in a frame is not properly saved (backend patch v3.3), p=sciguyryan, r/sr=cbiesinger, a=bzbarsky\\ndiff --git a/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp b/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp\\nindex a789eb2..443131e 100644\\n--- a/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp\\n+++ b/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp\\n@@ -1447,7 +1447,7 @@ nsWebBrowserPersist::GetDocEncoderContentType(nsIDOMDocument *aDocument, const P\\n     {\\n         // Check if there is an encoder for the desired content type\\n         nsCAutoString contractID(NS_DOC_ENCODER_CONTRACTID_BASE);\\n-        contractID.AppendWithConversion(contentType);\\n+        AppendUTF16toUTF8(contentType, contractID);\\n \\n         nsCOMPtr<nsIComponentRegistrar> registrar;\\n         NS_GetComponentRegistrar(getter_AddRefs(registrar));\\n@@ -2891,10 +2891,6 @@ nsresult nsWebBrowserPersist::OnWalkDOMNode(nsIDOMNode *aNode)\\n             nodeAsFrame->GetContentDocument(getter_AddRefs(content));\\n             if (content)\\n             {\\n-                nsXPIDLString ext;\\n-                GetDocumentExtension(content, getter_Copies(ext));\\n-                data->mSubFrameExt.AssignLiteral(\\\".\\\");\\n-                data->mSubFrameExt.Append(ext);\\n                 SaveSubframeContent(content, data);\\n             }\\n         }\\n@@ -2914,10 +2910,6 @@ nsresult nsWebBrowserPersist::OnWalkDOMNode(nsIDOMNode *aNode)\\n             nodeAsIFrame->GetContentDocument(getter_AddRefs(content));\\n             if (content)\\n             {\\n-                nsXPIDLString ext;\\n-                GetDocumentExtension(content, getter_Copies(ext));\\n-                data->mSubFrameExt.AssignLiteral(\\\".\\\");\\n-                data->mSubFrameExt.Append(ext);\\n                 SaveSubframeContent(content, data);\\n             }\\n         }\\n@@ -3270,13 +3262,7 @@ nsWebBrowserPersist::StoreURI(\\n     const char *aURI, PRBool aNeedsPersisting, URIData **aData)\\n {\\n     NS_ENSURE_ARG_POINTER(aURI);\\n-    if (aData)\\n-    {\\n-        *aData = nsnull;\\n-    }\\n \\n-    // Test if this URI should be persisted. By default\\n-    // we should assume the URI  is persistable.\\n     nsCOMPtr<nsIURI> uri;\\n     nsresult rv = NS_NewURI(getter_AddRefs(uri),\\n                             nsDependentCString(aURI),\\n@@ -3284,10 +3270,25 @@ nsWebBrowserPersist::StoreURI(\\n                             mCurrentBaseURI);\\n     NS_ENSURE_SUCCESS(rv, rv);\\n \\n+    return StoreURI(uri, aNeedsPersisting, aData);\\n+}\\n+\\n+nsresult\\n+nsWebBrowserPersist::StoreURI(\\n+    nsIURI *aURI, PRBool aNeedsPersisting, URIData **aData)\\n+{\\n+    NS_ENSURE_ARG_POINTER(aURI);\\n+    if (aData)\\n+    {\\n+        *aData = nsnull;\\n+    }\\n+\\n+    // Test if this URI should be persisted. By default\\n+    // we should assume the URI  is persistable.\\n     PRBool doNotPersistURI;\\n-    rv = NS_URIChainHasFlags(uri,\\n-                             nsIProtocolHandler::URI_NON_PERSISTABLE,\\n-                             &doNotPersistURI);\\n+    nsresult rv = NS_URIChainHasFlags(aURI,\\n+                                      nsIProtocolHandler::URI_NON_PERSISTABLE,\\n+                                      &doNotPersistURI);\\n     if (NS_FAILED(rv))\\n     {\\n         doNotPersistURI = PR_FALSE;\\n@@ -3299,7 +3300,7 @@ nsWebBrowserPersist::StoreURI(\\n     }\\n \\n     URIData *data = nsnull;\\n-    MakeAndStoreLocalFilenameInURIMap(uri, aNeedsPersisting, &data);\\n+    MakeAndStoreLocalFilenameInURIMap(aURI, aNeedsPersisting, &data);\\n     if (aData)\\n     {\\n         *aData = data;\\n@@ -3518,12 +3519,68 @@ nsWebBrowserPersist::StoreAndFixupStyleSheet(nsIStyleSheet *aStyleSheet)\\n     return NS_OK;\\n }\\n \\n+PRBool\\n+nsWebBrowserPersist::DocumentEncoderExists(const PRUnichar *aContentType)\\n+{\\n+    // Check if there is an encoder for the desired content type.\\n+    nsCAutoString contractID(NS_DOC_ENCODER_CONTRACTID_BASE);\\n+    AppendUTF16toUTF8(aContentType, contractID);\\n+\\n+    nsCOMPtr<nsIComponentRegistrar> registrar;\\n+    NS_GetComponentRegistrar(getter_AddRefs(registrar));\\n+    if (registrar)\\n+    {\\n+        PRBool result;\\n+        nsresult rv = registrar->IsContractIDRegistered(contractID.get(),\\n+                                                        &result);\\n+        if (NS_SUCCEEDED(rv) && result)\\n+        {\\n+            return PR_TRUE;\\n+        }\\n+    }\\n+    return PR_FALSE;\\n+}\\n+\\n nsresult\\n nsWebBrowserPersist::SaveSubframeContent(\\n     nsIDOMDocument *aFrameContent, URIData *aData)\\n {\\n     NS_ENSURE_ARG_POINTER(aData);\\n-    nsresult rv;\\n+\\n+    // Extract the content type for the frame's contents.\\n+    nsCOMPtr<nsIDocument> frameDoc(do_QueryInterface(aFrameContent));\\n+    NS_ENSURE_STATE(frameDoc);\\n+\\n+    nsAutoString contentType;\\n+    nsresult rv = frameDoc->GetContentType(contentType);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    nsXPIDLString ext;\\n+    GetExtensionForContentType(contentType.get(), getter_Copies(ext));\\n+\\n+    // We must always have an extension so we will try to re-assign\\n+    // the original extension if GetExtensionForContentType fails.\\n+    if (ext.IsEmpty())\\n+    {\\n+        nsCOMPtr<nsIURL> url(do_QueryInterface(frameDoc->GetDocumentURI(),\\n+                                               &rv));\\n+        nsCAutoString extension;\\n+        if (NS_SUCCEEDED(rv))\\n+        {\\n+            url->GetFileExtension(extension);\\n+        }\\n+        else\\n+        {\\n+            extension.AssignLiteral(\\\"htm\\\");\\n+        }\\n+        aData->mSubFrameExt.Assign(PRUnichar('.'));\\n+        AppendUTF8toUTF16(extension, aData->mSubFrameExt);\\n+    }\\n+    else\\n+    {\\n+        aData->mSubFrameExt.Assign(PRUnichar('.'));\\n+        aData->mSubFrameExt.Append(ext);\\n+    }\\n \\n     nsString filenameWithExt = aData->mFilename;\\n     filenameWithExt.Append(aData->mSubFrameExt);\\n@@ -3553,7 +3610,17 @@ nsWebBrowserPersist::SaveSubframeContent(\\n     NS_ENSURE_SUCCESS(rv, rv);\\n \\n     mCurrentThingsToPersist++;\\n-    rv = SaveDocumentInternal(aFrameContent, frameURI, frameDataURI);\\n+\\n+    // We shouldn't use SaveDocumentInternal for the contents\\n+    // of frames that are not documents, e.g. images.\\n+    if (DocumentEncoderExists(contentType.get()))\\n+    {\\n+        rv = SaveDocumentInternal(aFrameContent, frameURI, frameDataURI);\\n+    }\\n+    else\\n+    {\\n+        rv = StoreURI(frameDoc->GetDocumentURI());\\n+    }\\n     NS_ENSURE_SUCCESS(rv, rv);\\n \\n     // Store the updated uri to the frame\\ndiff --git a/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.h b/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.h\\nindex 840980b..121a51e 100644\\n--- a/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.h\\n+++ b/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.h\\n@@ -134,6 +134,10 @@ private:\\n         const char *aURI,\\n         PRBool aNeedsPersisting = PR_TRUE,\\n         URIData **aData = nsnull);\\n+    nsresult StoreURI(\\n+        nsIURI *aURI,\\n+        PRBool aNeedsPersisting = PR_TRUE,\\n+        URIData **aData = nsnull);\\n     nsresult StoreURIAttributeNS(\\n         nsIDOMNode *aNode, const char *aNamespaceURI, const char *aAttribute,\\n         PRBool aNeedsPersisting = PR_TRUE,\\n@@ -147,6 +151,7 @@ private:\\n     }\\n     PRBool GetQuotedAttributeValue(\\n     const nsAString &aSource, const nsAString &aAttribute, nsAString &aValue);\\n+    PRBool DocumentEncoderExists(const PRUnichar *aContentType);\\n \\n     nsresult GetNodeToFixup(nsIDOMNode *aNodeIn, nsIDOMNode **aNodeOut);\\n     nsresult FixupURI(nsAString &aURI);\\n\""}