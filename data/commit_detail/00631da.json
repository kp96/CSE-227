{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas00631da\""},"diff":"\"00631da Bug 388927 - getChildAtPoint fails for scrolled content, r=evan.yan, roc, sr=roc, a=dsicore\\ndiff --git a/accessible/src/base/nsAccessible.cpp b/accessible/src/base/nsAccessible.cpp\\nindex 1a2a81a..d995ce2 100644\\n--- a/accessible/src/base/nsAccessible.cpp\\n+++ b/accessible/src/base/nsAccessible.cpp\\n@@ -1082,70 +1082,73 @@ NS_IMETHODIMP nsAccessible::GetFocusedChild(nsIAccessible **aFocusedChild)\\n }\\n \\n   /* nsIAccessible getChildAtPoint (in long x, in long y); */\\n-NS_IMETHODIMP nsAccessible::GetChildAtPoint(PRInt32 tx, PRInt32 ty, nsIAccessible **aAccessible)\\n+NS_IMETHODIMP\\n+nsAccessible::GetChildAtPoint(PRInt32 aX, PRInt32 aY,\\n+                              nsIAccessible **aAccessible)\\n {\\n+  NS_ENSURE_ARG_POINTER(aAccessible);\\n   *aAccessible = nsnull;\\n \\n-  nsCOMPtr<nsIAccessible> child;\\n-  GetFirstChild(getter_AddRefs(child));\\n+  // Search an accessible at the given point starting from accessible document\\n+  // because containing block (see CSS2) for out of flow element (for example,\\n+  // absolutely positioned element) may be different from its DOM parent and\\n+  // therefore accessible for containing block may be different from accessible\\n+  // for DOM parent but GetFrameForPoint() should be called for containing block\\n+  // to get an out of flow element.\\n+  nsCOMPtr<nsIAccessibleDocument> accDocument;\\n+  nsresult rv = GetAccessibleDocument(getter_AddRefs(accDocument));\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n \\n-  PRInt32 x, y, w, h;\\n-  PRUint32 state;\\n+  if (!accDocument)\\n+    return NS_OK;\\n \\n-  nsCOMPtr<nsIAccessible> childAtPoint;\\n-  while (child) {\\n-    child->GetBounds(&x, &y, &w, &h);\\n-    if (tx >= x && tx < x + w && ty >= y && ty < y + h) {\\n-      nsCOMPtr<nsPIAccessNode> accessNode(do_QueryInterface(child));\\n-      if (accessNode) {\\n-        nsIFrame *frame = accessNode->GetFrame();\\n-        if (!frame) {\\n-          state = State(child);\\n-          // In some cases accessibles don't have a frame; examples are\\n-          // tree items or combo box dropdown markers. For these cases\\n-          // just ensure that the returned accessible is visible.\\n-          if ((state & (nsIAccessibleStates::STATE_OFFSCREEN |\\n-              nsIAccessibleStates::STATE_INVISIBLE)) == 0) {\\n-            // Don't walk into offscreen or invisible items\\n-            NS_IF_ADDREF(*aAccessible = child);\\n-            return NS_OK;\\n-          }\\n-        }\\n-        else {\\n-          // If there are multiple accessibles the contain the point \\n-          // and they overlap then pick the one with a frame that contains the point\\n-          // For example, A point that's in block #2 is also in block #1, but we want to return #2:\\n-          // [[block #1 is long wrapped text that continues to\\n-          // another line]]  [[here is a shorter block #2]]\\n-          while (frame) {\\n-            if (frame->GetScreenRectExternal().Contains(tx, ty)) {\\n-              childAtPoint = child;\\n-              break; // Definitely in this accessible, since one of its frame matches the point\\n-            }\\n-            frame = frame->GetNextContinuation();\\n-          }\\n-        }\\n-      }\\n-    }\\n-    nsCOMPtr<nsIAccessible> next;\\n-    child->GetNextSibling(getter_AddRefs(next));\\n-    child = next;\\n-  }\\n+  nsCOMPtr<nsPIAccessNode> accessNodeDocument(do_QueryInterface(accDocument));\\n+  NS_ASSERTION(accessNodeDocument,\\n+               \\\"nsIAccessibleDocument doesn't implement nsPIAccessNode\\\");\\n \\n-  if (childAtPoint) {\\n-    NS_ADDREF(*aAccessible = childAtPoint);\\n+  nsIFrame *frame = accessNodeDocument->GetFrame();\\n+  NS_ENSURE_STATE(frame);\\n+\\n+  nsPresContext *presContext = frame->PresContext();\\n+\\n+  nsIntRect screenRect = frame->GetScreenRectExternal();\\n+  nsPoint offset(presContext->DevPixelsToAppUnits(aX - screenRect.x),\\n+                 presContext->DevPixelsToAppUnits(aY - screenRect.y));\\n+\\n+  nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();\\n+  nsIFrame *foundFrame = presShell->GetFrameForPoint(frame, offset);\\n+  if (!foundFrame)\\n     return NS_OK;\\n-  }\\n-  GetState(&state, nsnull);\\n-  GetBounds(&x, &y, &w, &h);\\n-  if ((state & (nsIAccessibleStates::STATE_OFFSCREEN |\\n-                nsIAccessibleStates::STATE_INVISIBLE)) == 0 &&\\n-      tx >= x && tx < x + w && ty >= y && ty < y + h) {\\n-    *aAccessible = this;\\n-    NS_ADDREF_THIS();\\n+\\n+  nsCOMPtr<nsIContent> content(foundFrame->GetContent());\\n+  if (!content)\\n     return NS_OK;\\n+\\n+  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(content));\\n+  nsCOMPtr<nsIAccessibilityService> accService = GetAccService();\\n+\\n+  nsCOMPtr<nsIDOMNode> relevantNode;\\n+  accService->GetRelevantContentNodeFor(node, getter_AddRefs(relevantNode));\\n+  if (!relevantNode)\\n+    return NS_OK;\\n+\\n+  nsCOMPtr<nsIAccessible> accessible;\\n+  accService->GetAccessibleFor(relevantNode, getter_AddRefs(accessible));\\n+  if (!accessible)\\n+    return NS_OK;\\n+\\n+  nsCOMPtr<nsIAccessible> parent;\\n+  accessible->GetParent(getter_AddRefs(parent));\\n+\\n+  while (parent && parent != this) {\\n+    accessible.swap(parent);\\n+    accessible->GetParent(getter_AddRefs(parent));\\n   }\\n-  return NS_ERROR_FAILURE;\\n+\\n+  if (parent)\\n+    NS_ADDREF(*aAccessible = accessible);\\n+\\n+  return NS_OK;\\n }\\n \\n void nsAccessible::GetBoundsRect(nsRect& aTotalBounds, nsIFrame** aBoundingFrame)\\ndiff --git a/accessible/src/xul/nsXULTreeAccessible.cpp b/accessible/src/xul/nsXULTreeAccessible.cpp\\nindex 6c915a5..09df9c9 100644\\n--- a/accessible/src/xul/nsXULTreeAccessible.cpp\\n+++ b/accessible/src/xul/nsXULTreeAccessible.cpp\\n@@ -319,6 +319,42 @@ NS_IMETHODIMP nsXULTreeAccessible::GetFocusedChild(nsIAccessible **aFocusedChild\\n   return NS_OK;\\n }\\n \\n+// nsIAccessible::getChildAtPoint(in long x, in long y)\\n+NS_IMETHODIMP\\n+nsXULTreeAccessible::GetChildAtPoint(PRInt32 aX, PRInt32 aY,\\n+                                     nsIAccessible **aAccessible)\\n+{\\n+  nsIFrame *frame = GetFrame();\\n+  if (!frame)\\n+    return NS_ERROR_FAILURE;\\n+\\n+  nsPresContext *presContext = frame->PresContext();\\n+  nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();\\n+\\n+  nsIFrame *rootFrame = presShell->GetRootFrame();\\n+  NS_ENSURE_STATE(rootFrame);\\n+\\n+  nsIntRect rootRect = rootFrame->GetScreenRectExternal();\\n+\\n+  PRInt32 clientX = presContext->AppUnitsToIntCSSPixels(\\n+    presContext->DevPixelsToAppUnits(aX - rootRect.x));\\n+  PRInt32 clientY = presContext->AppUnitsToIntCSSPixels(\\n+    presContext->DevPixelsToAppUnits(aY - rootRect.y));\\n+\\n+  PRInt32 row = -1;\\n+  nsCOMPtr<nsITreeColumn> column;\\n+  nsCAutoString childEltUnused;\\n+  mTree->GetCellAt(clientX, clientY, &row, getter_AddRefs(column),\\n+                   childEltUnused);\\n+\\n+  // If we failed to find tree cell for the given point then it might be\\n+  // tree columns.\\n+  if (row == -1 || !column)\\n+    return nsXULSelectableAccessible::GetChildAtPoint(aX, aY, aAccessible);\\n+\\n+  return GetCachedTreeitemAccessible(row, column, aAccessible);\\n+}\\n+\\n // Ask treeselection to get all selected children\\n NS_IMETHODIMP nsXULTreeAccessible::GetSelectedChildren(nsIArray **_retval)\\n {\\ndiff --git a/accessible/src/xul/nsXULTreeAccessible.h b/accessible/src/xul/nsXULTreeAccessible.h\\nindex 9c2aef1..f510228 100644\\n--- a/accessible/src/xul/nsXULTreeAccessible.h\\n+++ b/accessible/src/xul/nsXULTreeAccessible.h\\n@@ -72,6 +72,8 @@ public:\\n   NS_IMETHOD GetLastChild(nsIAccessible **_retval);\\n   NS_IMETHOD GetChildCount(PRInt32 *_retval);\\n   NS_IMETHOD GetFocusedChild(nsIAccessible **aFocusedChild);\\n+  NS_IMETHOD GetChildAtPoint(PRInt32 aX, PRInt32 aY,\\n+                             nsIAccessible **aAccessible);\\n \\n   static void GetTreeBoxObject(nsIDOMNode* aDOMNode, nsITreeBoxObject** aBoxObject);\\n   static nsresult GetColumnCount(nsITreeBoxObject* aBoxObject, PRInt32 *aCount);\\ndiff --git a/layout/base/nsIPresShell.h b/layout/base/nsIPresShell.h\\nindex a713e35a..2068157 100644\\n--- a/layout/base/nsIPresShell.h\\n+++ b/layout/base/nsIPresShell.h\\n@@ -608,6 +608,14 @@ public:\\n   virtual nsresult ReconstructFrames() = 0;\\n \\n   /**\\n+   * Given aFrame, the root frame of a stacking context, find its descendant\\n+   * frame under the point aPt that receives a mouse event at that location,\\n+   * or nsnull if there is no such frame.\\n+   * @param aPt the point, relative to the frame origin\\n+   */\\n+  virtual nsIFrame* GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt) = 0;\\n+\\n+  /**\\n    * See if reflow verification is enabled. To enable reflow verification add\\n    * \\\"verifyreflow:1\\\" to your NSPR_LOG_MODULES environment variable\\n    * (any non-zero debug level will work). Or, call SetVerifyReflowEnable\\ndiff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp\\nindex bc0baa2..696f604 100644\\n--- a/layout/base/nsPresShell.cpp\\n+++ b/layout/base/nsPresShell.cpp\\n@@ -873,7 +873,9 @@ public:\\n   virtual nsresult ReconstructFrames(void);\\n   virtual void Freeze();\\n   virtual void Thaw();\\n-  \\n+\\n+  virtual nsIFrame* GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt);\\n+\\n   NS_IMETHOD RenderDocument(const nsRect& aRect, PRBool aUntrusted,\\n                             PRBool aIgnoreViewportScrolling,\\n                             nscolor aBackgroundColor,\\n@@ -2970,6 +2972,12 @@ PresShell::GetPageSequenceFrame(nsIPageSequenceFrame** aResult) const\\n   return *aResult ? NS_OK : NS_ERROR_FAILURE;\\n }\\n \\n+nsIFrame*\\n+PresShell::GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt)\\n+{\\n+  return nsLayoutUtils::GetFrameForPoint(aFrame, aPt);\\n+}\\n+\\n void\\n PresShell::BeginUpdate(nsIDocument *aDocument, nsUpdateType aUpdateType)\\n {\\n\""}