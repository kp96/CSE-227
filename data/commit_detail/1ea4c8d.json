{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas1ea4c8d\""},"diff":"\"1ea4c8d Bug 317847  Implement \\\"Save this Search\\\" (r=mano)\\ndiff --git a/browser/components/places/content/places.js b/browser/components/places/content/places.js\\nindex 970e294f..7b50a23 100755\\n--- a/browser/components/places/content/places.js\\n+++ b/browser/components/places/content/places.js\\n@@ -192,10 +192,6 @@ var PlacesOrganizer = {\\n     // Items are only excluded on the left pane\\n     var options = node.queryOptions.clone();\\n     options.excludeItems = false;\\n-    // Unset excludeQueries so incremental update is enabled for the content\\n-    // pane.\\n-    // XXXmano: remove that once we unset excludeQueries for the left pane.\\n-    options.excludeQueries = false;\\n \\n     this._content.load(queries, \\n                        OptionsFilter.filter(queries, options, null));\\n@@ -343,6 +339,57 @@ var PlacesOrganizer = {\\n     }\\n     gEditItemOverlay.uninitPanel();\\n     deck.selectedIndex = 0;\\n+  },\\n+\\n+  /**\\n+   * Save the current search (or advanced query) to the bookmarks root.\\n+   */\\n+  saveSearch: function PP_saveSearch() {\\n+    // Get the place: uri for the query.\\n+    // If the advanced query builder is showing, use that.\\n+    var queries = [];\\n+    var options = this.getCurrentOptions();\\n+    options.excludeQueries = true;\\n+    var advancedSearch = document.getElementById(\\\"advancedSearch\\\");\\n+    if (!advancedSearch.collapsed) {\\n+      queries = PlacesQueryBuilder.queries;\\n+    }\\n+    // If not, use the value of the search box.\\n+    else if (PlacesSearchBox.value && PlacesSearchBox.value.length > 0) {\\n+      var query = PlacesUtils.history.getNewQuery();\\n+      query.searchTerms = PlacesSearchBox.value;\\n+      queries.push(query);\\n+    }\\n+    // if there is no query, do nothing.\\n+    else {\\n+      // XXX should probably have a dialog here to explain that the user needs to search first.\\n+     return;\\n+    }\\n+    var placeSpec = PlacesUtils.history.queriesToQueryString(queries,\\n+                                                             queries.length,\\n+                                                             options);\\n+    var placeURI = IO.newURI(placeSpec);\\n+\\n+    // Prompt the user for a name for the query.\\n+    // XXX - using prompt service for now; will need to make\\n+    // a real dialog and localize when we're sure this is the UI we want.\\n+    var title = PlacesUtils.getString(\\\"saveSearch.title\\\");\\n+    var inputLabel = PlacesUtils.getString(\\\"saveSearch.inputLabel\\\");\\n+    var defaultText = PlacesUtils.getString(\\\"saveSearch.defaultText\\\");\\n+\\n+    var prompts = Cc[\\\"@mozilla.org/embedcomp/prompt-service;1\\\"].\\n+                    getService(Ci.nsIPromptService);\\n+    var check = {value: false};\\n+    var input = {value: defaultText};\\n+    var save = prompts.prompt(null, title, inputLabel, input, null, check);\\n+\\n+    // Don't add the query if the user cancels or clears the seach name.\\n+    if (!save || input.value == \\\"\\\")\\n+     return;\\n+\\n+    // Add the place: uri as a bookmark under the places root.\\n+    var txn = PlacesUtils.ptm.createItem(placeURI, PlacesUtils.bookmarks.bookmarksRoot, PlacesUtils.bookmarks.DEFAULT_INDEX, input.value);\\n+    PlacesUtils.ptm.commitTransaction(txn);\\n   }\\n };\\n \\n@@ -384,8 +431,10 @@ var PlacesSearchBox = {\\n       PO.setHeaderText(PO.HEADER_TYPE_SEARCH, filterString);\\n       break;\\n     case \\\"bookmarks\\\":\\n-      if (filterString != \\\"\\\")\\n+      if (filterString) {\\n         content.applyFilter(filterString, true);\\n+        PO.setHeaderText(PO.HEADER_TYPE_SEARCH, filterString);\\n+      }\\n       else\\n         PlacesOrganizer.onPlaceSelected();\\n       break;\\n@@ -445,6 +494,8 @@ var PlacesSearchBox = {\\n   },\\n   set filterCollection(collectionName) {\\n     this.searchFilter.setAttribute(\\\"collection\\\", collectionName);\\n+    if (this.searchFilter.value)\\n+      return; // don't overwrite pre-existing search terms\\n     var newGrayText = null;\\n     if (collectionName == \\\"collection\\\")\\n       newGrayText = PlacesOrganizer._places.selectedNode.title;\\n@@ -484,6 +535,9 @@ var PlacesSearchBox = {\\n  */\\n var PlacesQueryBuilder = {\\n \\n+  queries: [],\\n+  queryOptions: null,\\n+\\n   _numRows: 0,\\n \\n   /**\\n@@ -906,7 +960,7 @@ var PlacesQueryBuilder = {\\n   doSearch: function PQB_doSearch() {\\n     // Create the individual queries.\\n     var queryType = document.getElementById(\\\"advancedSearchType\\\").selectedItem.value;\\n-    var queries = [];\\n+    this.queries = [];\\n     if (queryType == \\\"and\\\")\\n       queries.push(PlacesUtils.history.getNewQuery());\\n     var updated = 0;\\n@@ -922,7 +976,7 @@ var PlacesQueryBuilder = {\\n         // If they're being OR-ed, add a separate query for each row.\\n         var query;\\n         if (queryType == \\\"and\\\")\\n-          query = queries[0];\\n+          query = this.queries[0];\\n         else\\n           query = PlacesUtils.history.getNewQuery();\\n         \\n@@ -930,15 +984,15 @@ var PlacesQueryBuilder = {\\n         this._queryBuilders[querySubject](query, prefix);\\n         \\n         if (queryType == \\\"or\\\")\\n-          queries.push(query);\\n+          this.queries.push(query);\\n           \\n         ++updated;\\n       }\\n     }\\n     \\n     // Make sure we're getting uri results, not visits\\n-    var options = PlacesOrganizer.getCurrentOptions();\\n-    options.resultType = options.RESULT_TYPE_URI;\\n+    this.options = PlacesOrganizer.getCurrentOptions();\\n+    this.options.resultType = options.RESULT_TYPE_URI;\\n \\n     // XXXben - find some public way of doing this!\\n     PlacesOrganizer._content.load(queries, \\ndiff --git a/browser/components/places/content/places.xul b/browser/components/places/content/places.xul\\nindex 5285164..ddbb777 100755\\n--- a/browser/components/places/content/places.xul\\n+++ b/browser/components/places/content/places.xul\\n@@ -86,7 +86,8 @@\\n              oncommand=\\\"PlacesOrganizer.exportBookmarks();\\\"/>\\n     <command id=\\\"OrganizerCommand_import\\\"\\n              oncommand=\\\"PlacesOrganizer.importBookmarks();\\\"/>\\n-    <command id=\\\"OrganizerCommand_search:save\\\"/>\\n+    <command id=\\\"OrganizerCommand_search:save\\\"\\n+             oncommand=\\\"PlacesOrganizer.saveSearch();\\\"/>\\n     <command id=\\\"OrganizerCommand_search:moreCriteria\\\"\\n              oncommand=\\\"PlacesQueryBuilder.addRow();\\\"/>\\n   </commandset>\\ndiff --git a/browser/components/places/content/placesOverlay.xul b/browser/components/places/content/placesOverlay.xul\\nindex 7f59f78..715dbe7 100644\\n--- a/browser/components/places/content/placesOverlay.xul\\n+++ b/browser/components/places/content/placesOverlay.xul\\n@@ -155,25 +155,25 @@\\n               command=\\\"cmd_cut\\\"\\n               label=\\\"&cutCmd.label;\\\"\\n               accesskey=\\\"&cutCmd.accesskey;\\\" \\n-              selection=\\\"separator|link|folder|mixed\\\"\\n+              selection=\\\"separator|link|folder|mixed|query\\\"\\n               forcehideselection=\\\"livemarkChild\\\"/>\\n     <menuitem id=\\\"placesContext_copy\\\"\\n               command=\\\"cmd_copy\\\"\\n               label=\\\"&copyCmd.label;\\\"\\n               accesskey=\\\"&copyCmd.accesskey;\\\" \\n-              selection=\\\"separator|link|folder\\\"/>\\n+              selection=\\\"separator|link|folder|query\\\"/>\\n     <menuitem id=\\\"placesContext_paste\\\"\\n               command=\\\"cmd_paste\\\"\\n               label=\\\"&pasteCmd.label;\\\"\\n               accesskey=\\\"&pasteCmd.accesskey;\\\"\\n-              selection=\\\"mutable\\\"/>\\n+              selection=\\\"mutable|query\\\"/>\\n     <menuseparator id=\\\"placesContext_editSeparator\\\"/>\\n     <menuitem id=\\\"placesContext_delete\\\"\\n               command=\\\"cmd_delete\\\"\\n               label=\\\"&deleteCmd.label;\\\"\\n               accesskey=\\\"&deleteCmd.accesskey;\\\"\\n               closemenu=\\\"single\\\"\\n-              selection=\\\"host|separator|link|folder|day\\\"\\n+              selection=\\\"host|separator|link|folder|day|query\\\"\\n               forcehideselection=\\\"livemarkChild\\\"/>\\n     <menuseparator id=\\\"placesContext_deleteSeparator\\\"/>\\n     <menuitem id=\\\"placesContext_reload\\\"\\ndiff --git a/browser/locales/en-US/chrome/browser/places/places.properties b/browser/locales/en-US/chrome/browser/places/places.properties\\nindex bb8269e..4c2dee4 100644\\n--- a/browser/locales/en-US/chrome/browser/places/places.properties\\n+++ b/browser/locales/en-US/chrome/browser/places/places.properties\\n@@ -77,3 +77,7 @@ status_foldercount = %S object(s)\\n \\n SelectImport=Import Bookmarks File\\n EnterExport=Export Bookmarks File\\n+\\n+saveSearch.title=Save Search\\n+saveSearch.inputLabel=Name:\\n+saveSearch.defaultText=New Query\\ndiff --git a/toolkit/components/places/src/nsNavHistory.cpp b/toolkit/components/places/src/nsNavHistory.cpp\\nindex 53b3653..b03a787 100644\\n--- a/toolkit/components/places/src/nsNavHistory.cpp\\n+++ b/toolkit/components/places/src/nsNavHistory.cpp\\n@@ -1550,7 +1550,7 @@ nsNavHistory::EvaluateQueryForNode(const nsCOMArray<nsNavHistoryQuery>& aQueries\\n       nsCOMArray<nsNavHistoryResultNode> inputSet;\\n       inputSet.AppendObject(aNode);\\n       nsCOMArray<nsNavHistoryResultNode> filteredSet;\\n-      nsresult rv = FilterResultSet(inputSet, &filteredSet, query->SearchTerms());\\n+      nsresult rv = FilterResultSet(nsnull, inputSet, &filteredSet, query->SearchTerms());\\n       if (NS_FAILED(rv))\\n         continue;\\n       if (! filteredSet.Count())\\n@@ -2412,11 +2412,11 @@ nsNavHistory::GetQueryResults(nsNavHistoryQueryResultNode *aResultNode,\\n       // keyword search\\n       if (groupCount == 0) {\\n         // keyword search with no grouping: can filter directly into the result\\n-        FilterResultSet(toplevel, aResults, aQueries[0]->SearchTerms());\\n+        FilterResultSet(aResultNode, toplevel, aResults, aQueries[0]->SearchTerms());\\n       } else {\\n         // keyword searching with grouping: need intermediate filtered results\\n         nsCOMArray<nsNavHistoryResultNode> filteredResults;\\n-        FilterResultSet(toplevel, &filteredResults, aQueries[0]->SearchTerms());\\n+        FilterResultSet(aResultNode, toplevel, &filteredResults, aQueries[0]->SearchTerms());\\n         rv = RecursiveGroup(aResultNode, filteredResults, groupings, groupCount,\\n                             aResults);\\n         NS_ENSURE_SUCCESS(rv, rv);\\n@@ -4096,21 +4096,26 @@ nsNavHistory::GroupByHost(nsNavHistoryQueryResultNode *aResultNode,\\n \\n // nsNavHistory::FilterResultSet\\n //\\n-//    Currently, this just does title/url filtering. This should be expanded in\\n-//    the future.\\n+//    This does some post-query-execution filtering:\\n+//      - searching on title & url\\n+//      - excludeQueries\\n \\n nsresult\\n-nsNavHistory::FilterResultSet(const nsCOMArray<nsNavHistoryResultNode>& aSet,\\n+nsNavHistory::FilterResultSet(nsNavHistoryQueryResultNode* aParentNode,\\n+                              const nsCOMArray<nsNavHistoryResultNode>& aSet,\\n                               nsCOMArray<nsNavHistoryResultNode>* aFiltered,\\n                               const nsString& aSearch)\\n {\\n+  nsresult rv;\\n   nsStringArray terms;\\n   ParseSearchQuery(aSearch, &terms);\\n \\n-  // if there are no search terms, just return everything (i.e. do nothing)\\n-  if (terms.Count() == 0) {\\n-    aFiltered->AppendObjects(aSet);\\n-    return NS_OK;\\n+  // filter against query options\\n+  // XXX only excludeQueries is supported at the moment\\n+  PRBool excludeQueries = PR_FALSE;\\n+  if (aParentNode) {\\n+    rv = aParentNode->mOptions->GetExcludeQueries(&excludeQueries);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n   }\\n \\n   nsCStringArray searchAnnotations;\\n@@ -4124,6 +4129,14 @@ nsNavHistory::FilterResultSet(const nsCOMArray<nsNavHistoryResultNode>& aSet,\\n   */\\n \\n   for (PRInt32 nodeIndex = 0; nodeIndex < aSet.Count(); nodeIndex ++) {\\n+    if (aParentNode) {\\n+      if (aParentNode->mItemId == aSet[nodeIndex]->mItemId)\\n+        continue; // filter out nodes that are the same as the parent\\n+    }\\n+\\n+    if (excludeQueries && IsQueryURI(aSet[nodeIndex]->mURI))\\n+      continue;\\n+\\n     PRBool allTermsFound = PR_TRUE;\\n \\n     nsStringArray curAnnotations;\\n@@ -4141,28 +4154,33 @@ nsNavHistory::FilterResultSet(const nsCOMArray<nsNavHistoryResultNode>& aSet,\\n     }\\n     */\\n \\n-    for (PRInt32 termIndex = 0; termIndex < terms.Count(); termIndex ++) {\\n-      PRBool termFound = PR_FALSE;\\n-      // title and URL\\n-      if (CaseInsensitiveFindInReadable(*terms[termIndex],\\n-                                        NS_ConvertUTF8toUTF16(aSet[nodeIndex]->mTitle)) ||\\n-          (aSet[nodeIndex]->IsURI() &&\\n-           CaseInsensitiveFindInReadable(*terms[termIndex],\\n-                                  NS_ConvertUTF8toUTF16(aSet[nodeIndex]->mURI))))\\n-        termFound = PR_TRUE;\\n-      // searchable annotations\\n-      /*if (! termFound) {\\n-        for (PRInt32 annotIndex = 0; annotIndex < curAnnotations.Count(); annotIndex ++) {\\n-          if (CaseInsensitiveFindInReadable(*terms[termIndex],\\n-                                            *curAnnotations[annotIndex]))\\n-            termFound = PR_TRUE;\\n+    if (terms.Count() == 0) {\\n+        allTermsFound = PR_TRUE;\\n+    } else {\\n+      for (PRInt32 termIndex = 0; termIndex < terms.Count(); termIndex ++) {\\n+        PRBool termFound = PR_FALSE;\\n+        // title and URL\\n+        if (CaseInsensitiveFindInReadable(*terms[termIndex],\\n+                                          NS_ConvertUTF8toUTF16(aSet[nodeIndex]->mTitle)) ||\\n+            (aSet[nodeIndex]->IsURI() &&\\n+             CaseInsensitiveFindInReadable(*terms[termIndex],\\n+                                    NS_ConvertUTF8toUTF16(aSet[nodeIndex]->mURI))))\\n+          termFound = PR_TRUE;\\n+        // searchable annotations\\n+        /*if (! termFound) {\\n+          for (PRInt32 annotIndex = 0; annotIndex < curAnnotations.Count(); annotIndex ++) {\\n+            if (CaseInsensitiveFindInReadable(*terms[termIndex],\\n+                                              *curAnnotations[annotIndex]))\\n+              termFound = PR_TRUE;\\n+          }\\n+        }*/\\n+        if (! termFound) {\\n+          allTermsFound = PR_FALSE;\\n+          break;\\n         }\\n-      }*/\\n-      if (! termFound) {\\n-        allTermsFound = PR_FALSE;\\n-        break;\\n       }\\n     }\\n+\\n     if (allTermsFound)\\n       aFiltered->AppendObject(aSet[nodeIndex]);\\n   }\\n@@ -4318,9 +4336,8 @@ nsNavHistory::RowToResult(mozIStorageValueArray* aRow,\\n \\n   if (IsQueryURI(url)) {\\n     // special case \\\"place:\\\" URIs: turn them into containers\\n-    // XXX: should we set the bookmark identifier for this sort of nodes? It\\n-    // would sure break few assumption on the frontend side\\n-    return QueryRowToResult(url, title, accessCount, time, favicon, aResult);\\n+    PRInt64 itemId = aRow->AsInt64(kGetInfoIndex_ItemId);\\n+    return QueryRowToResult(itemId, url, title, accessCount, time, favicon, aResult);\\n   } else if (aOptions->ResultType() == nsNavHistoryQueryOptions::RESULTS_AS_URI) {\\n     *aResult = new nsNavHistoryResultNode(url, title, accessCount, time,\\n                                           favicon);\\n@@ -4387,7 +4404,8 @@ nsNavHistory::RowToResult(mozIStorageValueArray* aRow,\\n //    folder or query node.\\n \\n nsresult\\n-nsNavHistory::QueryRowToResult(const nsACString& aURI, const nsACString& aTitle,\\n+nsNavHistory::QueryRowToResult(PRInt64 itemId, const nsACString& aURI,\\n+                               const nsACString& aTitle,\\n                                PRUint32 aAccessCount, PRTime aTime,\\n                                const nsACString& aFavicon,\\n                                nsNavHistoryResultNode** aNode)\\n@@ -4422,6 +4440,7 @@ nsNavHistory::QueryRowToResult(const nsACString& aURI, const nsACString& aTitle,\\n                                                queries, options);\\n       if (! *aNode)\\n         return NS_ERROR_OUT_OF_MEMORY;\\n+      (*aNode)->mItemId = itemId;\\n       NS_ADDREF(*aNode);\\n     }\\n   }\\ndiff --git a/toolkit/components/places/src/nsNavHistory.h b/toolkit/components/places/src/nsNavHistory.h\\nindex a007d84..792a074 100644\\n--- a/toolkit/components/places/src/nsNavHistory.h\\n+++ b/toolkit/components/places/src/nsNavHistory.h\\n@@ -249,7 +249,8 @@ public:\\n   nsresult RowToResult(mozIStorageValueArray* aRow,\\n                        nsNavHistoryQueryOptions* aOptions,\\n                        nsNavHistoryResultNode** aResult);\\n-  nsresult QueryRowToResult(const nsACString& aURI, const nsACString& aTitle,\\n+  nsresult QueryRowToResult(PRInt64 aItemId, const nsACString& aURI,\\n+                            const nsACString& aTitle,\\n                             PRUint32 aAccessCount, PRTime aTime,\\n                             const nsACString& aFavicon,\\n                             nsNavHistoryResultNode** aNode);\\n@@ -510,7 +511,8 @@ protected:\\n                        nsCOMArray<nsNavHistoryResultNode>* aDest,\\n                        PRBool aIsDomain);\\n \\n-  nsresult FilterResultSet(const nsCOMArray<nsNavHistoryResultNode>& aSet,\\n+  nsresult FilterResultSet(nsNavHistoryQueryResultNode *aParentNode,\\n+                           const nsCOMArray<nsNavHistoryResultNode>& aSet,\\n                            nsCOMArray<nsNavHistoryResultNode>* aFiltered,\\n                            const nsString& aSearch);\\n \\ndiff --git a/toolkit/components/places/src/nsNavHistoryQuery.cpp b/toolkit/components/places/src/nsNavHistoryQuery.cpp\\nindex a80a88a..008a3632 100644\\n--- a/toolkit/components/places/src/nsNavHistoryQuery.cpp\\n+++ b/toolkit/components/places/src/nsNavHistoryQuery.cpp\\n@@ -470,9 +470,9 @@ nsNavHistory::QueriesToQueryString(nsINavHistoryQuery **aQueries,\\n   }\\n \\n   // expand queries\\n-  if (options->ExpandQueries()) {\\n+  if (!options->ExpandQueries()) {\\n     AppendAmpersandIfNonempty(queryString);\\n-    queryString += NS_LITERAL_CSTRING(QUERYKEY_EXPAND_QUERIES \\\"=1\\\");\\n+    queryString += NS_LITERAL_CSTRING(QUERYKEY_EXPAND_QUERIES \\\"=0\\\");\\n   }\\n \\n   // include hidden\\ndiff --git a/toolkit/components/places/src/nsNavHistoryQuery.h b/toolkit/components/places/src/nsNavHistoryQuery.h\\nindex ddaccb3..f7ea217 100644\\n--- a/toolkit/components/places/src/nsNavHistoryQuery.h\\n+++ b/toolkit/components/places/src/nsNavHistoryQuery.h\\n@@ -122,7 +122,7 @@ public:\\n                                mExcludeItems(PR_FALSE),\\n                                mExcludeQueries(PR_FALSE),\\n                                mExcludeReadOnlyFolders(PR_FALSE),\\n-                               mExpandQueries(PR_FALSE),\\n+                               mExpandQueries(PR_TRUE),\\n                                mIncludeHidden(PR_FALSE),\\n                                mShowSessions(PR_FALSE),\\n                                mMaxResults(0),\\ndiff --git a/toolkit/components/places/src/nsNavHistoryResult.cpp b/toolkit/components/places/src/nsNavHistoryResult.cpp\\nindex ef4aab8..2b7cf7c 100644\\n--- a/toolkit/components/places/src/nsNavHistoryResult.cpp\\n+++ b/toolkit/components/places/src/nsNavHistoryResult.cpp\\n@@ -1894,14 +1894,19 @@ nsNavHistoryQueryResultNode::nsNavHistoryQueryResultNode(\\n //\\n //    Whoever made us may want non-expanding queries. However, we always\\n //    expand when we are the root node, or else asking for non-expanding\\n-//    queries would be useless.\\n+//    queries would be useless. A query node is not expandable if excludeItems=1\\n+//    or expandQueries=0.\\n \\n PRBool\\n nsNavHistoryQueryResultNode::CanExpand()\\n {\\n   nsNavHistoryQueryOptions* options = GetGeneratingOptions();\\n-  if (options && options->ExpandQueries())\\n-    return PR_TRUE;\\n+  if (options) {\\n+    if (options->ExcludeItems())\\n+      return PR_FALSE;\\n+    if (options->ExpandQueries())\\n+      return PR_TRUE;\\n+  }\\n   if (mResult && mResult->mRootNode == this)\\n     return PR_TRUE;\\n   return PR_FALSE;\\n@@ -1939,11 +1944,11 @@ nsNavHistoryQueryResultNode::OnRemoving()\\n nsresult\\n nsNavHistoryQueryResultNode::OpenContainer()\\n {\\n-  NS_ASSERTION(! mExpanded, \\\"Container must be expanded to close it\\\");\\n+  NS_ASSERTION(!mExpanded, \\\"Container must be closed to open it\\\");\\n   mExpanded = PR_TRUE;\\n-  if (! CanExpand())\\n+  if (!CanExpand())\\n     return NS_OK;\\n-  if (! mContentsValid) {\\n+  if (!mContentsValid) {\\n     nsresult rv = FillChildren();\\n     NS_ENSURE_SUCCESS(rv, rv);\\n   }\\n@@ -2568,7 +2573,7 @@ nsNavHistoryQueryResultNode::OnItemChanged(PRInt64 aItemId,\\n   if (mLiveUpdate == QUERYUPDATE_COMPLEX_WITH_BOOKMARKS)\\n     return Refresh();\\n   else\\n-    NS_NOTREACHED(\\\"history observers should not get OnItemChanged, but should get the corresponding history notifications instead\\\");\\n+    NS_WARNING(\\\"history observers should not get OnItemChanged, but should get the corresponding history notifications instead\\\");\\n   return NS_OK;\\n }\\n \\n@@ -3050,8 +3055,21 @@ nsNavHistoryFolderResultNode::OnItemAdded(PRInt64 aItemId,\\n   nsresult rv = bookmarks->GetItemType(aItemId, &itemType);\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n+  // check for query URIs, which are bookmarks, but treated as containers\\n+  // in results and views.\\n+  PRBool isQuery = PR_FALSE;\\n+  if (itemType == nsINavBookmarksService::TYPE_BOOKMARK) {\\n+    nsCOMPtr<nsIURI> itemURI;\\n+    rv = bookmarks->GetBookmarkURI(aItemId, getter_AddRefs(itemURI));\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    nsCAutoString itemURISpec;\\n+    rv = itemURI->GetSpec(itemURISpec);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    isQuery = IsQueryURI(itemURISpec);\\n+  }\\n+\\n   if (itemType != nsINavBookmarksService::TYPE_FOLDER &&\\n-      mOptions->ExcludeItems()) {\\n+      !isQuery && mOptions->ExcludeItems()) {\\n     // don't update items when we aren't displaying them, but we still need\\n     // to adjust bookmark indices to account for the insertion\\n     ReindexRange(aIndex, PR_INT32_MAX, 1);\\n@@ -3517,7 +3535,7 @@ nsNavHistoryResult::AddAllBookmarksObserver(nsNavHistoryQueryResultNode* aNode)\\n     mIsAllBookmarksObserver = PR_TRUE;\\n   }\\n   if (mAllBookmarksObservers.IndexOf(aNode) != mAllBookmarksObservers.NoIndex) {\\n-    NS_NOTREACHED(\\\"Attempting to register an observer twice!\\\");\\n+    NS_WARNING(\\\"Attempting to register an observer twice!\\\");\\n     return;\\n   }\\n   mAllBookmarksObservers.AppendElement(aNode);\\ndiff --git a/toolkit/components/places/tests/bookmarks/test_bookmarks.js b/toolkit/components/places/tests/bookmarks/test_bookmarks.js\\nindex 21192aa..6a5089b 100644\\n--- a/toolkit/components/places/tests/bookmarks/test_bookmarks.js\\n+++ b/toolkit/components/places/tests/bookmarks/test_bookmarks.js\\n@@ -443,7 +443,8 @@ function run_test() {\\n       var node = rootNode.getChild(i);\\n       if (node.type == node.RESULT_TYPE_FOLDER ||\\n           node.type == node.RESULT_TYPE_URI ||\\n-          node.type == node.RESULT_TYPE_SEPARATOR) {\\n+          node.type == node.RESULT_TYPE_SEPARATOR ||\\n+          node.type == node.RESULT_TYPE_QUERY) {\\n         do_check_true(node.itemId > 0);\\n       }\\n       else {\\ndiff --git a/toolkit/components/places/tests/bookmarks/test_savedsearches.js b/toolkit/components/places/tests/bookmarks/test_savedsearches.js\\nnew file mode 100644\\nindex 0000000..4316347\\n--- /dev/null\\n+++ b/toolkit/components/places/tests/bookmarks/test_savedsearches.js\\n@@ -0,0 +1,250 @@\\n+/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n+/* vim:set ts=2 sw=2 sts=2 et: */\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is mozilla.org code.\\n+ *\\n+ * The Initial Developer of the Original Code is Google Inc.\\n+ * Portions created by the Initial Developer are Copyright (C) 2005\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *  Darin Fisher <darin@meer.net>\\n+ *  Dietrich Ayala <dietrich@mozilla.com>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+\\n+// Get bookmark service\\n+try {\\n+  var bmsvc = Cc[\\\"@mozilla.org/browser/nav-bookmarks-service;1\\\"].getService(Ci.nsINavBookmarksService);\\n+} catch(ex) {\\n+  do_throw(\\\"Could not get nav-bookmarks-service\\\\n\\\");\\n+}\\n+\\n+// Get history service\\n+try {\\n+  var histsvc = Cc[\\\"@mozilla.org/browser/nav-history-service;1\\\"].getService(Ci.nsINavHistoryService);\\n+} catch(ex) {\\n+  do_throw(\\\"Could not get history service\\\\n\\\");\\n+} \\n+\\n+// Get annotation service\\n+try {\\n+  var annosvc= Cc[\\\"@mozilla.org/browser/annotation-service;1\\\"].getService(Ci.nsIAnnotationService);\\n+} catch(ex) {\\n+  do_throw(\\\"Could not get annotation service\\\\n\\\");\\n+} \\n+\\n+// Get global history service\\n+try {\\n+  var bhist = Cc[\\\"@mozilla.org/browser/global-history;2\\\"].getService(Ci.nsIBrowserHistory);\\n+} catch(ex) {\\n+  do_throw(\\\"Could not get history service\\\\n\\\");\\n+} \\n+\\n+// get bookmarks root id\\n+var root = bmsvc.bookmarksRoot;\\n+\\n+// main\\n+function run_test() {\\n+  // a search term that matches a default bookmark\\n+  var searchTerm = \\\"about\\\";\\n+\\n+  // create a folder to hold all the tests\\n+  // this makes the tests more tolerant of changes to the default bookmarks set\\n+  // also, name it using the search term, for testing that containers that match don't show up in query results\\n+  var testRoot = bmsvc.createFolder(root, searchTerm, bmsvc.DEFAULT_INDEX);\\n+\\n+  /******************************************\\n+  * saved searches - bookmarks \\n+  ******************************************/\\n+\\n+  // add a bookmark that matches the search term\\n+  var bookmarkId = bmsvc.insertBookmark(root, uri(\\\"http://foo.com\\\"), bmsvc.DEFAULT_INDEX, searchTerm);\\n+\\n+  // create a saved-search that matches a default bookmark\\n+  var searchId = bmsvc.insertBookmark(testRoot,\\n+                                      uri(\\\"place:terms=\\\" + searchTerm + \\\"&excludeQueries=1&expandQueries=1&queryType=1\\\"),\\n+                                      bmsvc.DEFAULT_INDEX, searchTerm);\\n+\\n+  // query for the test root, expandQueries=0\\n+  // the query should show up as a regular bookmark\\n+  try {\\n+    var options = histsvc.getNewQueryOptions();\\n+    options.expandQueries = 0;\\n+    var query = histsvc.getNewQuery();\\n+    query.setFolders([testRoot], 1);\\n+    var result = histsvc.executeQuery(query, options);\\n+    var rootNode = result.root;\\n+    rootNode.containerOpen = true;\\n+    var cc = rootNode.childCount;\\n+    do_check_eq(cc, 1);\\n+    for (var i = 0; i < cc; i++) {\\n+      var node = rootNode.getChild(i);\\n+      // test that queries have valid itemId\\n+      do_check_true(node.itemId > 0);\\n+      // test that the container is closed\\n+      node.QueryInterface(Ci.nsINavHistoryContainerResultNode);\\n+      do_check_eq(node.containerOpen, false);\\n+    }\\n+  }\\n+  catch(ex) {\\n+    do_throw(\\\"expandQueries=0 query error: \\\" + ex);\\n+  }\\n+\\n+  // bookmark saved search\\n+  // query for the test root, expandQueries=1\\n+  // the query should show up as a query container, with 1 child\\n+  try {\\n+    var options = histsvc.getNewQueryOptions();\\n+    options.expandQueries = 1;\\n+    var query = histsvc.getNewQuery();\\n+    query.setFolders([testRoot], 1);\\n+    var result = histsvc.executeQuery(query, options);\\n+    var rootNode = result.root;\\n+    rootNode.containerOpen = true;\\n+    var cc = rootNode.childCount;\\n+    do_check_eq(cc, 1);\\n+    for (var i = 0; i < cc; i++) {\\n+      var node = rootNode.getChild(i);\\n+      // test that query node type is container when expandQueries=1\\n+      do_check_eq(node.type, node.RESULT_TYPE_QUERY);\\n+      // test that queries (as containers) have valid itemId\\n+      do_check_true(node.itemId > 0);\\n+      node.QueryInterface(Ci.nsINavHistoryContainerResultNode);\\n+      node.containerOpen = true;\\n+\\n+      // test that queries have children when excludeItems=1\\n+      // test that query nodes don't show containers (shouldn't have our folder that matches)\\n+      // test that queries don't show themselves in query results (shouldn't have our saved search)\\n+      do_check_eq(node.childCount, 1);\\n+\\n+      // test that bookmark shows in query results\\n+      var item = node.getChild(0);\\n+      do_check_eq(item.itemId, bookmarkId);\\n+\\n+      // XXX - FAILING - test live-update of query results - add a bookmark that matches the query\\n+      //var tmpBmId = bmsvc.insertBookmark(root, uri(\\\"http://\\\" + searchTerm + \\\".com\\\"), bmsvc.DEFAULT_INDEX, searchTerm + \\\"blah\\\");\\n+      //do_check_eq(query.childCount, 2);\\n+\\n+      // XXX - test live-update of query results - delete a bookmark that matches the query\\n+      //bmsvc.removeItem(tmpBMId);\\n+      //do_check_eq(query.childCount, 1);\\n+\\n+      // test live-update of query results - add a folder that matches the query\\n+      bmsvc.createFolder(root, searchTerm + \\\"zaa\\\", bmsvc.DEFAULT_INDEX);\\n+      do_check_eq(node.childCount, 1);\\n+      // test live-update of query results - add a query that matches the query\\n+      bmsvc.insertBookmark(root, uri(\\\"place:terms=foo&excludeQueries=1&expandQueries=1&queryType=1\\\"),\\n+                           bmsvc.DEFAULT_INDEX, searchTerm + \\\"blah\\\");\\n+      do_check_eq(node.childCount, 1);\\n+    }\\n+  }\\n+  catch(ex) {\\n+    do_throw(\\\"expandQueries=1 bookmarks query: \\\" + ex);\\n+  }\\n+\\n+  // delete the bookmark search\\n+  bmsvc.removeItem(searchId);\\n+\\n+  /******************************************\\n+  * saved searches - history \\n+  ******************************************/\\n+\\n+  // add a visit that matches the search term\\n+  var testURI = uri(\\\"http://\\\" + searchTerm + \\\".com\\\");\\n+  bhist.addPageWithDetails(testURI, searchTerm, Date.now());\\n+\\n+  // create a saved-search that matches the visit we added\\n+  var searchId = bmsvc.insertBookmark(testRoot,\\n+                                      uri(\\\"place:terms=\\\" + searchTerm + \\\"&excludeQueries=1&expandQueries=1&queryType=0\\\"),\\n+                                      bmsvc.DEFAULT_INDEX, searchTerm);\\n+\\n+  // query for the test root, expandQueries=1\\n+  // the query should show up as a query container, with 1 child\\n+  try {\\n+    var options = histsvc.getNewQueryOptions();\\n+    options.expandQueries = 1;\\n+    var query = histsvc.getNewQuery();\\n+    query.setFolders([testRoot], 1);\\n+    var result = histsvc.executeQuery(query, options);\\n+    var rootNode = result.root;\\n+    rootNode.containerOpen = true;\\n+    var cc = rootNode.childCount;\\n+    do_check_eq(cc, 1);\\n+    for (var i = 0; i < cc; i++) {\\n+      var node = rootNode.getChild(i);\\n+      // test that query node type is container when expandQueries=1\\n+      do_check_eq(node.type, node.RESULT_TYPE_QUERY);\\n+      // test that queries (as containers) have valid itemId\\n+      do_check_eq(node.itemId, searchId);\\n+      node.QueryInterface(Ci.nsINavHistoryContainerResultNode);\\n+      node.containerOpen = true;\\n+\\n+      // test that queries have children when excludeItems=1\\n+      // test that query nodes don't show containers (shouldn't have our folder that matches)\\n+      // test that queries don't show themselves in query results (shouldn't have our saved search)\\n+      do_check_eq(node.childCount, 1);\\n+\\n+      // test that history visit shows in query results\\n+      var item = node.getChild(0);\\n+      do_check_eq(item.type, item.RESULT_TYPE_URI);\\n+      do_check_eq(item.itemId, -1); // history visit\\n+      do_check_eq(item.uri, testURI.spec); // history visit\\n+\\n+      // test live-update of query results - add a history visit that matches the query\\n+      bhist.addPageWithDetails(uri(\\\"http://foo.com\\\"), searchTerm + \\\"blah\\\", Date.now());\\n+      do_check_eq(node.childCount, 2);\\n+\\n+      // test live-update of query results - delete a history visit that matches the query\\n+      bhist.removePage(uri(\\\"http://foo.com\\\"));\\n+      do_check_eq(node.childCount, 1);\\n+    }\\n+\\n+    // test live-update of moved queries\\n+    var tmpFolderId = bmsvc.createFolder(testRoot, \\\"foo\\\", bmsvc.DEFAULT_INDEX); \\n+    bmsvc.moveItem(searchId, tmpFolderId, bmsvc.DEFAULT_INDEX);\\n+    var tmpFolderNode = rootNode.getChild(0);\\n+    do_check_eq(tmpFolderNode.itemId, tmpFolderId);\\n+    tmpFolderNode.QueryInterface(Ci.nsINavHistoryContainerResultNode);\\n+    tmpFolderNode.containerOpen = true;\\n+    do_check_eq(tmpFolderNode.childCount, 1);\\n+\\n+    // test live-update of renamed queries\\n+    bmsvc.setItemTitle(searchId, \\\"foo\\\");\\n+    do_check_eq(tmpFolderNode.title, \\\"foo\\\");\\n+\\n+    // test live-update of deleted queries\\n+    bmsvc.removeItem(searchId);\\n+    try {\\n+      var tmpFolderNode = root.getChild(1);\\n+      do_throw(\\\"query was not removed\\\");\\n+    } catch(ex) {}\\n+  }\\n+  catch(ex) {\\n+    do_throw(\\\"expandQueries=1 bookmarks query: \\\" + ex);\\n+  }\\n+}\\n\""}