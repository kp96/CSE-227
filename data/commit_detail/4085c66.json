{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas4085c66\""},"diff":"\"4085c66 Bug 366465 - GIF Decoding in Cairo can skip all row buffers, patch by Alfred Kayser <alfredkayser@nl.ibm.com>, r=pavlov, sr=tor, a1.9=pavlov\\ndiff --git a/modules/libpr0n/decoders/gif/GIF2.h b/modules/libpr0n/decoders/gif/GIF2.h\\nindex e2dc2d9..341449b 100644\\n--- a/modules/libpr0n/decoders/gif/GIF2.h\\n+++ b/modules/libpr0n/decoders/gif/GIF2.h\\n@@ -94,16 +94,14 @@ typedef struct gif_struct {\\n     int ipass;                  /* Interlace pass; Ranges 1-4 if interlaced. */\\n     PRUintn rows_remaining;        /* Rows remaining to be output */\\n     PRUintn irow;                  /* Current output row, starting at zero */\\n-    PRUint8 *rowbuf;              /* Single scanline temporary buffer */\\n-    PRUint8 *rowend;              /* Pointer to end of rowbuf */\\n-    PRUint8 *rowp;                /* Current output pointer */\\n+    PRUint32 *rowp;                 /* Current output pointer */\\n \\n     /* Parameters for image frame currently being decoded*/\\n     PRUintn x_offset, y_offset;    /* With respect to \\\"screen\\\" origin */\\n     PRUintn height, width;\\n     int tpixel;                 /* Index of transparent pixel */\\n     PRInt32 disposal_method;    /* Restore to background, leave in place, etc.*/\\n-    PRUint8 *local_colormap;    /* Per-image colormap */\\n+    PRUint32 *local_colormap;   /* Per-image colormap */\\n     int local_colormap_size;    /* Size of local colormap array. */\\n     PRUint32 delay_time;        /* Display time, in milliseconds,\\n                                    for this image in a multi-image GIF */\\n@@ -112,7 +110,7 @@ typedef struct gif_struct {\\n     int version;                /* Either 89 for GIF89 or 87 for GIF87 */\\n     PRUintn screen_width;       /* Logical screen width & height */\\n     PRUintn screen_height;\\n-    int global_colormap_size;   /* Size of global colormap array. */\\n+    PRUint32 global_colormap_size;  /* Size of global colormap array. */\\n     int images_decoded;         /* Counts images for multi-part GIFs */\\n     int loop_count;             /* Netscape specific extension block to control\\n                                    the number of animation loops a GIF renders. */\\n@@ -120,11 +118,10 @@ typedef struct gif_struct {\\n     PRPackedBool progressive_display;    /* If TRUE, do Haeberli interlace hack */\\n     PRPackedBool interlaced;             /* TRUE, if scanlines arrive interlaced order */\\n     PRPackedBool is_transparent;         /* TRUE, if tpixel is valid */\\n-    PRPackedBool is_local_colormap_defined;\\n \\n     PRUint16  prefix[MAX_BITS];          /* LZW decoding tables */\\n     PRUint8   hold[MAX_HOLD_SIZE];       /* Accumulation buffer */\\n-    PRUint8   global_colormap[3*MAX_COLORS];   /* Default colormap if local not supplied, 3 bytes for each color  */\\n+    PRUint32  global_colormap[MAX_COLORS];   /* Default colormap if local not supplied */\\n     PRUint8   suffix[MAX_BITS];          /* LZW decoding tables */\\n     PRUint8   stack[MAX_BITS];           /* Base of LZW decoder stack */\\n \\ndiff --git a/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp b/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp\\nindex c48530e..9028a5a6 100644\\n--- a/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp\\n+++ b/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp\\n@@ -89,6 +89,7 @@ mailing address.\\n \\n #include \\\"imgContainer.h\\\"\\n \\n+#include \\\"gfxColor.h\\\"\\n #include \\\"gfxPlatform.h\\\"\\n #include \\\"lcms.h\\\"\\n \\n@@ -120,10 +121,10 @@ NS_IMPL_ISUPPORTS1(nsGIFDecoder2, imgIDecoder)\\n nsGIFDecoder2::nsGIFDecoder2()\\n   : mCurrentRow(-1)\\n   , mLastFlushedRow(-1)\\n-  , mRGBLine(nsnull)\\n-  , mRGBLineMaxSize(0)\\n+  , mImageData(nsnull)\\n   , mCurrentPass(0)\\n   , mLastFlushedPass(0)\\n+  , mOldColor(0)\\n   , mGIFOpen(PR_FALSE)\\n {\\n   // Clear out the structure, excluding the arrays\\n@@ -168,9 +169,7 @@ NS_IMETHODIMP nsGIFDecoder2::Close()\\n     EndImageFrame();\\n   EndGIF();\\n \\n-  PR_FREEIF(mGIFStruct.rowbuf);\\n   PR_FREEIF(mGIFStruct.local_colormap);\\n-  PR_FREEIF(mRGBLine);\\n \\n   return NS_OK;\\n }\\n@@ -205,37 +204,38 @@ static NS_METHOD ReadDataOut(nsIInputStream* in,\\n // mCurrentRow/mLastFlushedRow.  Note: caller is responsible for\\n // updating mlastFlushed{Row,Pass}.\\n void\\n+nsGIFDecoder2::FlushImageData(PRUint32 fromRow, PRUint32 rows)\\n+{\\n+  nsIntRect r(0, fromRow, mGIFStruct.screen_width, rows);\\n+\\n+  // Update image  \\n+  nsCOMPtr<nsIImage> img(do_GetInterface(mImageFrame));\\n+  img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);\\n+\\n+  // Offset to the frame position\\n+  // Only notify observer(s) for first frame\\n+  if (!mGIFStruct.images_decoded && mObserver) {\\n+    r.y += mGIFStruct.y_offset;\\n+    mObserver->OnDataAvailable(nsnull, mImageFrame, &r);\\n+  }\\n+}\\n+\\n+void\\n nsGIFDecoder2::FlushImageData()\\n {\\n-  PRInt32 imgWidth;\\n-  mImageContainer->GetWidth(&imgWidth);\\n-  nsIntRect frameRect;\\n-  mImageFrame->GetRect(frameRect);\\n-  \\n   switch (mCurrentPass - mLastFlushedPass) {\\n-    case 0: {  // same pass\\n-      PRInt32 remainingRows = mCurrentRow - mLastFlushedRow;\\n-      if (remainingRows) {\\n-        nsIntRect r(0, frameRect.y + mLastFlushedRow + 1,\\n-                    imgWidth, remainingRows);\\n-        mObserver->OnDataAvailable(nsnull, mImageFrame, &r);\\n-      }    \\n-    }\\n-    break;\\n+    case 0:  // same pass\\n+      if (mCurrentRow - mLastFlushedRow)\\n+        FlushImageData(mLastFlushedRow + 1, mCurrentRow - mLastFlushedRow);\\n+      break;\\n   \\n-    case 1: {  // one pass on - need to handle bottom & top rects\\n-      nsIntRect r(0, frameRect.y, imgWidth, mCurrentRow + 1);\\n-      mObserver->OnDataAvailable(nsnull, mImageFrame, &r);\\n-      nsIntRect r2(0, frameRect.y + mLastFlushedRow + 1,\\n-                   imgWidth, frameRect.height - mLastFlushedRow - 1);\\n-      mObserver->OnDataAvailable(nsnull, mImageFrame, &r2);\\n-    }\\n-    break;\\n+    case 1:  // one pass on - need to handle bottom & top rects\\n+      FlushImageData(0, mCurrentRow + 1);\\n+      FlushImageData(mLastFlushedRow + 1, mGIFStruct.height - (mLastFlushedRow + 1));\\n+      break;\\n \\n-    default: {  // more than one pass on - push the whole frame\\n-      nsIntRect r(0, frameRect.y, imgWidth, frameRect.height);\\n-      mObserver->OnDataAvailable(nsnull, mImageFrame, &r);\\n-    }\\n+    default:   // more than one pass on - push the whole frame\\n+      FlushImageData(0, mGIFStruct.height);\\n   }\\n }\\n \\n@@ -247,7 +247,7 @@ nsresult nsGIFDecoder2::ProcessData(unsigned char *data, PRUint32 count, PRUint3\\n   nsresult rv = GifWrite(data, count);\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n-  if (mImageFrame && mObserver) {\\n+  if (mImageFrame) {\\n     FlushImageData();\\n     mLastFlushedRow = mCurrentRow;\\n     mLastFlushedPass = mCurrentPass;\\n@@ -286,9 +286,7 @@ NS_IMETHODIMP nsGIFDecoder2::WriteFrom(nsIInputStream *inStr, PRUint32 count, PR\\n //******************************************************************************\\n void nsGIFDecoder2::BeginGIF()\\n {\\n-  // If we have passed an illogical screen size, bail and hope that we'll get\\n-  // set later by the first frame's local image header.\\n-  if (mGIFStruct.screen_width == 0 || mGIFStruct.screen_height == 0)\\n+  if (mGIFOpen)\\n     return;\\n     \\n   if (mObserver)\\n@@ -323,7 +321,6 @@ void nsGIFDecoder2::EndGIF()\\n void nsGIFDecoder2::BeginImageFrame()\\n {\\n   mImageFrame = nsnull; // clear out our current frame reference\\n-  mFrameHasNoAlpha = PR_TRUE;\\n \\n   if (!mGIFStruct.images_decoded) {\\n     // Send a onetime OnDataAvailable (Display Refresh) for the first frame\\n@@ -336,151 +333,72 @@ void nsGIFDecoder2::BeginImageFrame()\\n       mObserver->OnDataAvailable(nsnull, mImageFrame, &r);\\n     }\\n   }\\n-}\\n-\\n-//******************************************************************************\\n-void nsGIFDecoder2::EndImageFrame()\\n-{\\n-  mGIFStruct.images_decoded++;\\n \\n-  // If mImageFrame hasn't been initialized, call HaveDecodedRow to init it\\n-  // One reason why it may not be initialized is because the frame\\n-  // is out of the bounds of the image.\\n-  if (!mImageFrame) {\\n-    HaveDecodedRow(nsnull,0,0,0);\\n-  } else {\\n-    // We actually have the timeout information before we get the lzw encoded \\n-    // image data, at least according to the spec, but we delay in setting the \\n-    // timeout for the image until here to help ensure that we have the whole \\n-    // image frame decoded before we go off and try to display another frame.\\n-    mImageFrame->SetTimeout(mGIFStruct.delay_time);\\n-\\n-    if (mFrameHasNoAlpha) {\\n-      nsCOMPtr<nsIImage> img(do_GetInterface(mImageFrame));\\n-      img->SetHasNoAlpha();\\n-    }\\n+  gfx_format format = gfxIFormats::RGB;\\n+  if (mGIFStruct.is_transparent) {\\n+    format = gfxIFormats::RGB_A1;  // XXX not really\\n   }\\n-  mImageContainer->EndFrameDecode(mGIFStruct.images_decoded, mGIFStruct.delay_time);\\n-\\n-  if (mObserver && mImageFrame) {\\n-    FlushImageData();\\n \\n-    if (mGIFStruct.images_decoded == 1) {\\n-      // If the first frame is smaller in height than the entire image, send a\\n-      // OnDataAvailable (Display Refresh) for the area it does not have data for.\\n-      // This will clear the remaining bits of the placeholder. (Bug 37589)\\n-      PRInt32 imgHeight;\\n-      PRInt32 realFrameHeight = mGIFStruct.height + mGIFStruct.y_offset;\\n+  // initialize the frame and append it to the container\\n+  mImageFrame = do_CreateInstance(\\\"@mozilla.org/gfx/image/frame;2\\\");\\n+  if (!mImageFrame || NS_FAILED(mImageFrame->Init(\\n+        mGIFStruct.x_offset, mGIFStruct.y_offset, \\n+        mGIFStruct.width, mGIFStruct.height, format, 24))) {\\n+    mImageFrame = 0;\\n+    return;\\n+  }\\n \\n-      mImageContainer->GetHeight(&imgHeight);\\n-      if (imgHeight > realFrameHeight) {\\n-        PRInt32 imgWidth;\\n-        mImageContainer->GetWidth(&imgWidth);\\n+  mImageFrame->SetFrameDisposalMethod(mGIFStruct.disposal_method);\\n+  mImageContainer->AppendFrame(mImageFrame);\\n \\n-        nsIntRect r(0, realFrameHeight, imgWidth, imgHeight - realFrameHeight);\\n-        mObserver->OnDataAvailable(nsnull, mImageFrame, &r);\\n-      }\\n-    }\\n+  if (mObserver)\\n+    mObserver->OnStartFrame(nsnull, mImageFrame);\\n \\n-    mCurrentRow = mLastFlushedRow = -1;\\n-    mCurrentPass = mLastFlushedPass = 0;\\n+  PRUint32 imageDataLength;\\n+  mImageFrame->GetImageData((PRUint8 **)&mImageData, &imageDataLength);\\n+}\\n \\n-    mObserver->OnStopFrame(nsnull, mImageFrame);\\n-  }\\n \\n-  // Clear state from this image\\n-  mImageFrame = nsnull;\\n-  mGIFStruct.is_local_colormap_defined = PR_FALSE;\\n-  mGIFStruct.is_transparent = PR_FALSE;\\n-}\\n-  \\n //******************************************************************************\\n-// GIF decoder callback notification that it has decoded a row\\n-void nsGIFDecoder2::HaveDecodedRow(\\n-  PRUint8* aRowBufPtr,   // Pointer to single scanline temporary buffer\\n-  int aRowNumber,        // Row number?\\n-  int aDuplicateCount,   // Number of times to duplicate the row?\\n-  int aInterlacePass)    // interlace pass (1-4)\\n+void nsGIFDecoder2::EndImageFrame()\\n {\\n-  const PRUint32 bpr = mGIFStruct.width * sizeof(PRUint32);\\n-\\n-  // We have to delay allocation of the image frame until now because\\n-  // we won't have control block info (transparency) until now. The control\\n-  // block of a GIF stream shows up after the image header since transparency\\n-  // is added in GIF89a and control blocks are how the extensions are done.\\n-  // How annoying.\\n-  if (!mImageFrame) {\\n-    gfx_format format = gfxIFormats::RGB;\\n-    if (mGIFStruct.is_transparent) {\\n-      format = gfxIFormats::RGB_A1;  // XXX not really\\n-    }\\n+  // First flush all pending image data \\n+  FlushImageData();\\n+  mCurrentRow = mLastFlushedRow = -1;\\n+  mCurrentPass = mLastFlushedPass = 0;\\n \\n-    // initialize the frame and append it to the container\\n-    mImageFrame = do_CreateInstance(\\\"@mozilla.org/gfx/image/frame;2\\\");\\n-    if (!mImageFrame || NS_FAILED(mImageFrame->Init(\\n-          mGIFStruct.x_offset, mGIFStruct.y_offset, \\n-          mGIFStruct.width, mGIFStruct.height, format, 24))) {\\n-      mImageFrame = 0;\\n-      return;\\n+  if (!mGIFStruct.images_decoded) {\\n+    // If the first frame is smaller in height than the entire image, send a\\n+    // OnDataAvailable (Display Refresh) for the area it does not have data for.\\n+    // This will clear the remaining bits of the placeholder. (Bug 37589)\\n+    const PRUint32 realFrameHeight = mGIFStruct.height + mGIFStruct.y_offset;\\n+    if (realFrameHeight < mGIFStruct.screen_height) {\\n+      nsIntRect r(0, realFrameHeight, \\n+                  mGIFStruct.screen_width, \\n+\\t\\t\\t\\t  mGIFStruct.screen_height - realFrameHeight);\\n+      mObserver->OnDataAvailable(nsnull, mImageFrame, &r);\\n     }\\n+  }\\n \\n-    mImageFrame->SetFrameDisposalMethod(mGIFStruct.disposal_method);\\n-    mImageContainer->AppendFrame(mImageFrame);\\n-\\n-    if (mObserver)\\n-      mObserver->OnStartFrame(nsnull, mImageFrame);\\n+  mGIFStruct.images_decoded++;\\n \\n-    if (bpr > mRGBLineMaxSize) {\\n-      mRGBLine = (PRUint8 *)PR_REALLOC(mRGBLine, bpr);\\n-      mRGBLineMaxSize = bpr;\\n-    }\\n-  }\\n-  \\n-  if (aRowBufPtr) {\\n-    // Map the data into colors\\n-    int cmapsize = mGIFStruct.global_colormap_size;\\n-    PRUint8* cmap = mGIFStruct.global_colormap;\\n-    if (mGIFStruct.is_local_colormap_defined) {\\n-      cmapsize = mGIFStruct.local_colormap_size;\\n-      cmap = mGIFStruct.local_colormap;\\n-    }\\n+  // We actually have the timeout information before we get the lzw encoded \\n+  // image data, at least according to the spec, but we delay in setting the \\n+  // timeout for the image until here to help ensure that we have the whole \\n+  // image frame decoded before we go off and try to display another frame.\\n+  mImageFrame->SetTimeout(mGIFStruct.delay_time);\\n+  mImageContainer->EndFrameDecode(mGIFStruct.images_decoded, mGIFStruct.delay_time);\\n \\n-    if (!cmap) { // cmap could have null value if the global color table flag is 0\\n-      nsIntRect r(0, aRowNumber, mGIFStruct.width, aDuplicateCount);\\n-      imgContainer::ClearFrame(mImageFrame, r);\\n-    } else {\\n-      PRUint8* rowBufIndex = aRowBufPtr;\\n-      PRUint32* rgbRowIndex = (PRUint32*)mRGBLine;\\n-      PRBool rowHasNoAlpha = PR_TRUE;\\n-\\n-      const PRInt32 tpixel = \\n-        mGIFStruct.is_transparent ? mGIFStruct.tpixel : -1;\\n-\\n-      while (rowBufIndex != mGIFStruct.rowend) {\\n-        if (*rowBufIndex >= cmapsize || *rowBufIndex == tpixel) {\\n-          rowHasNoAlpha = PR_FALSE;\\n-          *rgbRowIndex++ = 0x00000000;\\n-          ++rowBufIndex;\\n-          continue;\\n-        }\\n+  if (mObserver)\\n+    mObserver->OnStopFrame(nsnull, mImageFrame);\\n \\n-        PRUint32 colorIndex = *rowBufIndex * 3;\\n-        *rgbRowIndex++ = (0xFF << 24) |\\n-          (cmap[colorIndex] << 16) |\\n-          (cmap[colorIndex+1] << 8) |\\n-          (cmap[colorIndex+2]);\\n-        ++rowBufIndex;\\n-      }\\n-      for (int i=0; i<aDuplicateCount; i++)\\n-        mImageFrame->SetImageData(mRGBLine, bpr, (aRowNumber+i)*bpr);\\n-      if (!rowHasNoAlpha)\\n-        mFrameHasNoAlpha = PR_FALSE;\\n-    }\\n+  // Release reference to this frame\\n+  mImageFrame = nsnull;\\n \\n-    mCurrentRow = aRowNumber + aDuplicateCount - 1;\\n-    mCurrentPass = aInterlacePass;\\n-    if (aInterlacePass == 1)\\n-      mLastFlushedPass = aInterlacePass;   // interlaced starts at 1\\n+  // Reset the transparent pixel\\n+  if (mOldColor) {\\n+    mColormap[mGIFStruct.tpixel] = mOldColor;\\n+    mOldColor = 0;\\n   }\\n }\\n \\n@@ -489,8 +407,7 @@ void nsGIFDecoder2::HaveDecodedRow(\\n // Send the data to the display front-end.\\n PRUint32 nsGIFDecoder2::OutputRow()\\n {\\n-  int width, drow_start, drow_end;\\n-\\n+  int drow_start, drow_end;\\n   drow_start = drow_end = mGIFStruct.irow;\\n \\n   /*\\n@@ -524,24 +441,24 @@ PRUint32 nsGIFDecoder2::OutputRow()\\n     return 0;\\n   }\\n \\n-  /* Check for scanline below edge of logical screen */\\n-  if ((mGIFStruct.y_offset + mGIFStruct.irow) < mGIFStruct.screen_height) {\\n-    /* Clip if right edge of image exceeds limits */\\n-    if ((mGIFStruct.x_offset + mGIFStruct.width) > mGIFStruct.screen_width)\\n-      width = mGIFStruct.screen_width - mGIFStruct.x_offset;\\n-    else\\n-      width = mGIFStruct.width;\\n-\\n-    if (width > 0)\\n-      /* Decoded data available callback */\\n-      HaveDecodedRow(\\n-        mGIFStruct.rowbuf,                // Pointer to single scanline temporary buffer\\n-        drow_start,                // Row number\\n-        drow_end - drow_start + 1, // Number of times to duplicate the row?\\n-        mGIFStruct.ipass);                // interlace pass (1-4)\\n+  \\n+  // Duplicate rows\\n+  if (drow_end > drow_start) {\\n+    // irow is the current row filled\\n+    const PRUint32 width = mGIFStruct.width; \\n+    PRUint32 *rgbRowIndex = mImageData + mGIFStruct.irow * width;\\n+    for (int r = drow_start; r <= drow_end; r++) {\\n+      if (r != mGIFStruct.irow) {\\n+        memcpy(mImageData + r * width, rgbRowIndex, width*sizeof(PRUint32));\\n+      }\\n+    }\\n   }\\n \\n-  mGIFStruct.rowp = mGIFStruct.rowbuf;\\n+  mCurrentRow = drow_end;\\n+  mCurrentPass = mGIFStruct.ipass;\\n+  if (mGIFStruct.ipass == 1)\\n+    mLastFlushedPass = mGIFStruct.ipass;   // interlaced starts at 1\\n+\\n \\n   if (!mGIFStruct.interlaced) {\\n     mGIFStruct.irow++;\\n@@ -583,8 +500,9 @@ nsGIFDecoder2::DoLzw(const PRUint8 *q)\\n   PRUint8 *stackp   = mGIFStruct.stackp;\\n   PRUint8 *suffix   = mGIFStruct.suffix;\\n   PRUint8 *stack    = mGIFStruct.stack;\\n-  PRUint8 *rowp     = mGIFStruct.rowp;\\n-  PRUint8 *rowend   = mGIFStruct.rowend;\\n+  PRUint32 *rowp    = mGIFStruct.rowp;\\n+  PRUint32 *rowend  = mImageData + (mGIFStruct.irow + 1) * mGIFStruct.width;\\n+  PRUint32 *cmap    = mColormap;\\n \\n   if (rowp == rowend)\\n     return PR_TRUE;\\n@@ -593,7 +511,8 @@ nsGIFDecoder2::DoLzw(const PRUint8 *q)\\n   PR_BEGIN_MACRO                                            \\\\\\n     if (!OutputRow())                                       \\\\\\n       goto END;                                             \\\\\\n-    rowp = mGIFStruct.rowp;                                 \\\\\\n+    rowp = mImageData + mGIFStruct.irow * mGIFStruct.width; \\\\\\n+    rowend = rowp + mGIFStruct.width;                       \\\\\\n   PR_END_MACRO\\n \\n   for (const PRUint8* ch = q; count-- > 0; ch++)\\n@@ -626,7 +545,7 @@ nsGIFDecoder2::DoLzw(const PRUint8 *q)\\n       }\\n \\n       if (oldcode == -1) {\\n-        *rowp++ = suffix[code];\\n+        *rowp++ = cmap[suffix[code]];\\n         if (rowp == rowend)\\n           OUTPUT_ROW();\\n \\n@@ -676,7 +595,7 @@ nsGIFDecoder2::DoLzw(const PRUint8 *q)\\n \\n       /* Copy the decoded data out to the scanline buffer. */\\n       do {\\n-        *rowp++ = *--stackp;\\n+        *rowp++ = cmap[*--stackp];\\n         if (rowp == rowend)\\n           OUTPUT_ROW();\\n       } while (stackp > stack);\\n@@ -700,6 +619,33 @@ nsGIFDecoder2::DoLzw(const PRUint8 *q)\\n   return PR_TRUE;\\n }\\n \\n+/** \\n+ * Expand the colormap from RGB to Packed ARGB as needed by Cairo.\\n+ * And apply any LCMS transformation.\\n+ */\\n+static void ConvertColormap(PRUint32 *aColormap, PRUint32 aColors)\\n+{\\n+  // Apply CMS transformation if enabled and available\\n+  if (gfxPlatform::IsCMSEnabled()) {\\n+    cmsHTRANSFORM transform = gfxPlatform::GetCMSRGBTransform();\\n+    if (transform)\\n+      cmsDoTransform(transform, aColormap, aColormap, aColors);\\n+  }\\n+  // Convert from the GIF's RGB format to the Cairo format.\\n+  // Work from end to begin, because of the in-place expansion\\n+  PRUint8 *from = ((PRUint8 *)aColormap) + 3 * aColors;\\n+  PRUint32 *to = aColormap + aColors;\\n+\\n+  // Clear part after defined colors\\n+  memset(to, 0, (MAX_COLORS - aColors)*sizeof(PRUint32));\\n+\\n+  // Convert color entries to Cairo format\\n+  for (PRUint32 c = aColors; c > 0; c--) {\\n+    from -= 3;\\n+    *--to = GFX_PACKED_PIXEL(0xFF, from[0], from[1], from[2]);\\n+  }\\n+}\\n+\\n /******************************************************************************/\\n /*\\n  * process data arriving from the stream for the gif decoder\\n@@ -715,8 +661,8 @@ nsresult nsGIFDecoder2::GifWrite(const PRUint8 *buf, PRUint32 len)\\n   // Add what we have sofar to the block\\n   // If previous call to me left something in the hold first complete current block\\n   // Or if we are filling the colormaps, first complete the colormap\\n-  PRUint8* p = (mGIFStruct.state == gif_global_colormap) ? mGIFStruct.global_colormap :\\n-               (mGIFStruct.state == gif_image_colormap) ? mGIFStruct.local_colormap :\\n+  PRUint8* p = (mGIFStruct.state == gif_global_colormap) ? (PRUint8*)mGIFStruct.global_colormap :\\n+               (mGIFStruct.state == gif_image_colormap) ? (PRUint8*)mGIFStruct.local_colormap :\\n                (mGIFStruct.bytes_in_hold) ? mGIFStruct.hold : nsnull;\\n   if (p) {\\n     // Add what we have sofar to the block\\n@@ -761,6 +707,12 @@ nsresult nsGIFDecoder2::GifWrite(const PRUint8 *buf, PRUint32 len)\\n \\n     case gif_lzw_start:\\n     {\\n+      // Make sure the transparent pixel is transparent in the colormap\\n+      if (mGIFStruct.is_transparent) {\\n+        mOldColor = mColormap[mGIFStruct.tpixel];\\n+        mColormap[mGIFStruct.tpixel] = 0;\\n+      }\\n+\\n       /* Initialize LZW parser/decoder */\\n       mGIFStruct.datasize = *q;\\n       const int clear_code = ClearCode();\\n@@ -817,9 +769,6 @@ nsresult nsGIFDecoder2::GifWrite(const PRUint8 *buf, PRUint32 len)\\n       //   Not used\\n       //   float aspect = (float)((q[6] + 15) / 64.0);\\n \\n-      // Start the GIF container\\n-      BeginGIF();\\n-\\n       if (q[4] & 0x80) { /* global map */\\n         // Get the global colormap\\n         const PRUint32 size = 3*mGIFStruct.global_colormap_size;\\n@@ -840,17 +789,9 @@ nsresult nsGIFDecoder2::GifWrite(const PRUint8 *buf, PRUint32 len)\\n       break;\\n \\n     case gif_global_colormap:\\n-      if (gfxPlatform::IsCMSEnabled()) {\\n-        // Everything is already copied into global_colormap\\n-        cmsHTRANSFORM transform = gfxPlatform::GetCMSRGBTransform();\\n-        if (transform) {\\n-          cmsDoTransform(transform,\\n-                         mGIFStruct.global_colormap,\\n-                         mGIFStruct.global_colormap,\\n-                         mGIFStruct.global_colormap_size);\\n-        }\\n-      }\\n-\\n+      // Everything is already copied into global_colormap\\n+      // Convert into Cairo colors including CMS transformation\\n+      ConvertColormap(mGIFStruct.global_colormap, mGIFStruct.global_colormap_size);\\n       GETN(1, gif_image_start);\\n       break;\\n \\n@@ -1001,20 +942,20 @@ nsresult nsGIFDecoder2::GifWrite(const PRUint8 *buf, PRUint32 len)\\n       mGIFStruct.width  = GETINT16(q + 4);\\n       mGIFStruct.height = GETINT16(q + 6);\\n \\n-      /* Work around broken GIF files where the logical screen\\n-       * size has weird width or height.  We assume that GIF87a\\n-       * files don't contain animations.\\n-       */\\n-      if (!mGIFStruct.images_decoded &&\\n-          ((mGIFStruct.screen_height < mGIFStruct.height) ||\\n-           (mGIFStruct.screen_width < mGIFStruct.width) ||\\n-           (mGIFStruct.version == 87)))\\n-      {\\n-        mGIFStruct.screen_height = mGIFStruct.height;\\n-        mGIFStruct.screen_width = mGIFStruct.width;\\n-        mGIFStruct.x_offset = 0;\\n-        mGIFStruct.y_offset = 0;\\n-\\n+      if (!mGIFStruct.images_decoded) {\\n+        /* Work around broken GIF files where the logical screen\\n+         * size has weird width or height.  We assume that GIF87a\\n+         * files don't contain animations.\\n+         */\\n+        if ((mGIFStruct.screen_height < mGIFStruct.height) ||\\n+            (mGIFStruct.screen_width < mGIFStruct.width) ||\\n+            (mGIFStruct.version == 87)) {\\n+          mGIFStruct.screen_height = mGIFStruct.height;\\n+          mGIFStruct.screen_width = mGIFStruct.width;\\n+          mGIFStruct.x_offset = 0;\\n+          mGIFStruct.y_offset = 0;\\n+        }    \\n+        // Create the image container with the right size.\\n         BeginGIF();\\n       }\\n \\n@@ -1031,25 +972,6 @@ nsresult nsGIFDecoder2::GifWrite(const PRUint8 *buf, PRUint32 len)\\n \\n       BeginImageFrame();\\n \\n-      /* This case will never be taken if this is the first image */\\n-      /* being decoded. If any of the later images are larger     */\\n-      /* than the screen size, we need to reallocate buffers.     */\\n-      if (mGIFStruct.screen_width < mGIFStruct.width) {\\n-        /* XXX Deviant! */\\n-\\n-        mGIFStruct.rowbuf = (PRUint8*)PR_REALLOC(mGIFStruct.rowbuf, mGIFStruct.width);\\n-        mGIFStruct.screen_width = mGIFStruct.width;\\n-      } else if (!mGIFStruct.rowbuf) {\\n-          mGIFStruct.rowbuf = (PRUint8*)PR_MALLOC(mGIFStruct.screen_width);\\n-      }\\n-\\n-      if (!mGIFStruct.rowbuf) {\\n-          mGIFStruct.state = gif_oom;\\n-          break;\\n-      }\\n-      if (mGIFStruct.screen_height < mGIFStruct.height)\\n-        mGIFStruct.screen_height = mGIFStruct.height;\\n-\\n       if (q[8] & 0x40) {\\n         mGIFStruct.interlaced = PR_TRUE;\\n         mGIFStruct.ipass = 1;\\n@@ -1064,8 +986,7 @@ nsresult nsGIFDecoder2::GifWrite(const PRUint8 *buf, PRUint32 len)\\n       /* Clear state from last image */\\n       mGIFStruct.irow = 0;\\n       mGIFStruct.rows_remaining = mGIFStruct.height;\\n-      mGIFStruct.rowend = mGIFStruct.rowbuf + mGIFStruct.width;\\n-      mGIFStruct.rowp = mGIFStruct.rowbuf;\\n+      mGIFStruct.rowp = mImageData;\\n \\n       /* bits per pixel is q[8]&0x07 */\\n \\n@@ -1073,19 +994,18 @@ nsresult nsGIFDecoder2::GifWrite(const PRUint8 *buf, PRUint32 len)\\n       {\\n         const int num_colors = 2 << (q[8] & 0x7);\\n         const PRUint32 size = 3*num_colors;\\n-        PRUint8 *map = mGIFStruct.local_colormap;\\n-        if (!map || (num_colors > mGIFStruct.local_colormap_size)) {\\n-          map = (PRUint8*)PR_REALLOC(map, size);\\n-          if (!map) {\\n+        if (!mGIFStruct.local_colormap) {\\n+          mGIFStruct.local_colormap = \\n+\\t\\t\\t  (PRUint32*)PR_MALLOC(MAX_COLORS * sizeof(PRUint32));\\n+          if (!mGIFStruct.local_colormap) {\\n             mGIFStruct.state = gif_oom;\\n             break;\\n           }\\n-          mGIFStruct.local_colormap = map;\\n         }\\n \\n         /* Switch to the new local palette after it loads */\\n         mGIFStruct.local_colormap_size = num_colors;\\n-        mGIFStruct.is_local_colormap_defined = PR_TRUE;\\n+        mColormap = mGIFStruct.local_colormap;\\n \\n         if (len < size) {\\n           // Use 'hold' pattern to get the image colormap\\n@@ -1100,23 +1020,15 @@ nsresult nsGIFDecoder2::GifWrite(const PRUint8 *buf, PRUint32 len)\\n         break;\\n       } else {\\n         /* Switch back to the global palette */\\n-        mGIFStruct.is_local_colormap_defined = PR_FALSE;\\n+        mColormap = mGIFStruct.global_colormap;\\n       }\\n       GETN(1, gif_lzw_start);\\n       break;\\n \\n     case gif_image_colormap:\\n-      if (gfxPlatform::IsCMSEnabled()) {\\n-        // Everything is already copied into local_colormap\\n-        cmsHTRANSFORM transform = gfxPlatform::GetCMSRGBTransform();\\n-        if (transform) {\\n-          cmsDoTransform(transform,\\n-                         mGIFStruct.local_colormap,\\n-                         mGIFStruct.local_colormap,\\n-                         mGIFStruct.local_colormap_size);\\n-        }\\n-      }\\n-\\n+      // Everything is already copied into local_colormap\\n+      // Convert into Cairo colors including CMS transformation\\n+      ConvertColormap(mGIFStruct.local_colormap, mGIFStruct.local_colormap_size);\\n       GETN(1, gif_lzw_start);\\n       break;\\n \\n@@ -1163,8 +1075,8 @@ nsresult nsGIFDecoder2::GifWrite(const PRUint8 *buf, PRUint32 len)\\n   mGIFStruct.bytes_in_hold = len;\\n   if (len) {\\n     // Add what we have sofar to the block\\n-    PRUint8* p = (mGIFStruct.state == gif_global_colormap) ? mGIFStruct.global_colormap :\\n-                 (mGIFStruct.state == gif_image_colormap) ? mGIFStruct.local_colormap :\\n+    PRUint8* p = (mGIFStruct.state == gif_global_colormap) ? (PRUint8*)mGIFStruct.global_colormap :\\n+                 (mGIFStruct.state == gif_image_colormap) ? (PRUint8*)mGIFStruct.local_colormap :\\n                  mGIFStruct.hold;\\n     memcpy(p, buf, len);\\n     mGIFStruct.bytes_to_consume -= len;\\ndiff --git a/modules/libpr0n/decoders/gif/nsGIFDecoder2.h b/modules/libpr0n/decoders/gif/nsGIFDecoder2.h\\nindex 98e1124..6a7a818 100644\\n--- a/modules/libpr0n/decoders/gif/nsGIFDecoder2.h\\n+++ b/modules/libpr0n/decoders/gif/nsGIFDecoder2.h\\n@@ -79,15 +79,11 @@ private:\\n   void      BeginImageFrame();\\n   void      EndImageFrame();\\n   void      FlushImageData();\\n+  void      FlushImageData(PRUint32 fromRow, PRUint32 rows);\\n \\n   nsresult  GifWrite(const PRUint8 * buf, PRUint32 numbytes);\\n   PRUint32  OutputRow();\\n   PRBool    DoLzw(const PRUint8 *q);\\n-  void      HaveDecodedRow(\\n-    PRUint8* aRowBufPtr,   /* Pointer to single scanline temporary buffer */\\n-    int aRow,              /* Row number? */\\n-    int aDuplicateCount,   /* Number of times to duplicate the row? */\\n-    int aInterlacePass);\\n \\n   inline int ClearCode() const { return 1 << mGIFStruct.datasize; }\\n \\n@@ -97,12 +93,12 @@ private:\\n   PRInt32 mCurrentRow;\\n   PRInt32 mLastFlushedRow;\\n \\n-  PRUint8 *mRGBLine;\\n-  PRUint32 mRGBLineMaxSize;\\n+  PRUint32 *mImageData;      // Pointer to image data in Cairo format\\n+  PRUint32 *mColormap;       // Current colormap to be used in Cairo format\\n+  PRUint32 mOldColor;        // The old value of the transparent pixel\\n   PRUint8 mCurrentPass;\\n   PRUint8 mLastFlushedPass;\\n   PRPackedBool mGIFOpen;\\n-  PRPackedBool mFrameHasNoAlpha;\\n \\n   gif_struct mGIFStruct;\\n };\\n\""}