{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas83b6101\""},"diff":"\"83b6101 Reduce code duplication among platforms, support hooking and unhooking (392009, r=dbaron).\\ndiff --git a/tools/trace-malloc/lib/nsTraceMalloc.c b/tools/trace-malloc/lib/nsTraceMalloc.c\\nindex f137de3..360f9d9 100644\\n--- a/tools/trace-malloc/lib/nsTraceMalloc.c\\n+++ b/tools/trace-malloc/lib/nsTraceMalloc.c\\n@@ -40,12 +40,10 @@\\n  * ***** END LICENSE BLOCK ***** */\\n #ifdef NS_TRACE_MALLOC\\n  /*\\n- * TODO:\\n- * - extend logfile so 'F' record tells free stack\\n- * - diagnose rusty's SMP realloc oldsize corruption bug\\n- * - #ifdef __linux__/x86 and port to other platforms\\n- * - unify calltree with gc/boehm somehow (common utility lib?)\\n- */\\n+  * TODO:\\n+  * - FIXME https://bugzilla.mozilla.org/show_bug.cgi?id=392008\\n+  * - extend logfile so 'F' record tells free stack\\n+  */\\n #include <errno.h>\\n #include <fcntl.h>\\n #include <stdio.h>\\n@@ -77,41 +75,43 @@\\n #define WRITE_FLAGS \\\"w\\\"\\n \\n #define __libc_malloc(x)                malloc(x)\\n-#define __libc_calloc(x, y)             calloc(x, y)\\n #define __libc_realloc(x, y)            realloc(x, y)\\n #define __libc_free(x)                  free(x)\\n \\n #elif defined(XP_UNIX)\\n \\n+#include <malloc.h>\\n+\\n #define WRITE_FLAGS \\\"w\\\"\\n \\n #ifdef WRAP_SYSTEM_INCLUDES\\n #pragma GCC visibility push(default)\\n #endif\\n extern __ptr_t __libc_malloc(size_t);\\n-extern __ptr_t __libc_calloc(size_t, size_t);\\n extern __ptr_t __libc_realloc(__ptr_t, size_t);\\n extern void    __libc_free(__ptr_t);\\n extern __ptr_t __libc_memalign(size_t, size_t);\\n-extern __ptr_t __libc_valloc(size_t);\\n #ifdef WRAP_SYSTEM_INCLUDES\\n #pragma GCC visibility pop\\n #endif\\n \\n #elif defined(XP_WIN32)\\n \\n-#include <sys/timeb.h>/*for timeb*/\\n-#include <sys/stat.h>/*for fstat*/\\n+#include <sys/timeb.h>                  /* for timeb */\\n+#include <sys/stat.h>                   /* for fstat */\\n \\n #include <io.h> /*for write*/\\n \\n #define WRITE_FLAGS \\\"w\\\"\\n \\n #define __libc_malloc(x)                dhw_orig_malloc(x)\\n-#define __libc_calloc(x, y)             dhw_orig_calloc(x,y)\\n #define __libc_realloc(x, y)            dhw_orig_realloc(x,y)\\n #define __libc_free(x)                  dhw_orig_free(x)\\n \\n+#else  /* not XP_MACOSX, XP_UNIX, or XP_WIN32 */\\n+\\n+# error \\\"Unknown build configuration!\\\"\\n+\\n #endif\\n \\n typedef struct logfile logfile;\\n@@ -144,11 +144,11 @@ static char      *sdlogname = NULL; /* filename for shutdown leak log */\\n  * This enables/disables trace-malloc logging.\\n  *\\n  * It is separate from suppress_tracing so that we do not have to pay\\n- * the performance cost of repeated PR_GetThreadPrivate calls when\\n+ * the performance cost of repeated TM_TLS_GET_DATA calls when\\n  * trace-malloc is disabled (which is not as bad as the locking we used\\n  * to have).\\n  */\\n-static int tracing_enabled = 1;\\n+static uint32 tracing_enabled = 1;\\n \\n /*\\n  * This lock must be held while manipulating the calltree, the\\n@@ -575,7 +575,8 @@ static PLHashTable *filenames = NULL;\\n /* Table mapping method names to logged 'N' record serial numbers. */\\n static PLHashTable *methods = NULL;\\n \\n-static callsite *calltree(void **stack, size_t num_stack_entries)\\n+static callsite *\\n+calltree(void **stack, size_t num_stack_entries)\\n {\\n     logfile *fp = logfp;\\n     void *pc;\\n@@ -862,16 +863,17 @@ static callsite *calltree(void **stack, size_t num_stack_entries)\\n         calltree_maxstack_top = site;\\n \\n     TM_EXIT_LOCK();\\n-\\n     return site;\\n+\\n   fail:\\n     TM_EXIT_LOCK();\\n     return NULL;\\n }\\n \\n-\\n-/* buffer the stack so that we can reverse it */\\n-\\n+/*\\n+ * Buffer the stack from top at low index to bottom at high, so that we can\\n+ * reverse it in calltree.\\n+ */\\n PR_STATIC_CALLBACK(void)\\n stack_callback(void *pc, void *closure)\\n {\\n@@ -889,7 +891,6 @@ stack_callback(void *pc, void *closure)\\n /*\\n  * The caller MUST NOT be holding tmlock when calling backtrace.\\n  */\\n-\\n callsite *\\n backtrace(tm_thread *t, int skip)\\n {\\n@@ -1027,417 +1028,166 @@ static PLHashTable *new_allocations(void)\\n \\n #define get_allocations() (allocations ? allocations : new_allocations())\\n \\n-#if defined(XP_UNIX) && !defined(XP_MACOSX)\\n+#if defined(XP_MACOSX)\\n \\n-NS_EXTERNAL_VIS_(__ptr_t)\\n-malloc(size_t size)\\n-{\\n-    PRUint32 start, end;\\n-    __ptr_t ptr;\\n-    callsite *site;\\n-    PLHashEntry *he;\\n-    allocation *alloc;\\n-    tm_thread *t;\\n+/* from malloc.c in Libc */\\n+typedef void\\n+malloc_logger_t(unsigned type, unsigned arg1, unsigned arg2, unsigned arg3,\\n+                unsigned result, unsigned num_hot_frames_to_skip);\\n \\n-    if (!tracing_enabled || !PR_Initialized() ||\\n-        (t = tm_get_thread())->suppress_tracing != 0) {\\n-        return __libc_malloc(size);\\n-    }\\n+extern malloc_logger_t *malloc_logger;\\n \\n-    start = PR_IntervalNow();\\n-    ptr = __libc_malloc(size);\\n-    end = PR_IntervalNow();\\n+#define MALLOC_LOG_TYPE_ALLOCATE        2\\n+#define MALLOC_LOG_TYPE_DEALLOCATE      4\\n+#define MALLOC_LOG_TYPE_HAS_ZONE        8\\n+#define MALLOC_LOG_TYPE_CLEARED         64\\n \\n-    site = backtrace(t, 1);\\n+static void\\n+my_malloc_logger(unsigned type, unsigned arg1, unsigned arg2, unsigned arg3,\\n+                 unsigned result, unsigned num_hot_frames_to_skip)\\n+{\\n+    unsigned all_args[3] = { arg1, arg2, arg3 };\\n+    unsigned *args = all_args + ((type & MALLOC_LOG_TYPE_HAS_ZONE) ? 1 : 0);\\n \\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n-    tmstats.malloc_calls++;\\n-    if (!ptr) {\\n-        tmstats.malloc_failures++;\\n-    } else {\\n-        if (site)\\n-            log_event5(logfp, TM_EVENT_MALLOC,\\n-                       site->serial, start, end - start,\\n-                       (uint32)NS_PTR_TO_INT32(ptr), size);\\n-        if (get_allocations()) {\\n-            he = PL_HashTableAdd(allocations, ptr, site);\\n-            if (he) {\\n-                alloc = (allocation*) he;\\n-                alloc->size = size;\\n-                alloc->trackfp = NULL;\\n-            }\\n-        }\\n-    }\\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n+    unsigned alloc_type =\\n+        type & (MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_DEALLOCATE);\\n+    tm_thread *t = tm_get_thread();\\n \\n-    return ptr;\\n+    if (alloc_type == (MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_DEALLOCATE)) {\\n+        ReallocCallback((void*)args[0], (void*)result, args[1], 0, 0, t);\\n+    } else if (alloc_type == MALLOC_LOG_TYPE_ALLOCATE) {\\n+        /*\\n+         * We don't get size/count information for calloc, so just use\\n+         * MallocCallback.\\n+         */\\n+        MallocCallback((void*)result, args[0], 0, 0, t);\\n+    } else if (alloc_type == MALLOC_LOG_TYPE_DEALLOCATE) {\\n+        FreeCallback((void*)args[0], 0, 0, t);\\n+    }\\n }\\n \\n-NS_EXTERNAL_VIS_(__ptr_t)\\n-calloc(size_t count, size_t size)\\n+static void\\n+StartupHooker(void)\\n {\\n-    PRUint32 start, end;\\n-    __ptr_t ptr;\\n-    callsite *site;\\n-    PLHashEntry *he;\\n-    allocation *alloc;\\n-    tm_thread *t;\\n-\\n-    /**\\n-     * During the initialization of the glibc/libpthread, and\\n-     * before main() is running, ld-linux.so.2 tries to allocate memory\\n-     * using calloc (call from _dl_tls_setup).\\n-     *\\n-     * Thus, our calloc replacement is invoked too early, tries to\\n-     * initialize NSPR, which calls dlopen, which calls into the dl\\n-     * -> crash.\\n-     *\\n-     * Delaying NSPR calls until NSPR is initialized helps.\\n-     */\\n-    if (!tracing_enabled || !PR_Initialized() ||\\n-        (t = tm_get_thread())->suppress_tracing != 0) {\\n-        return __libc_calloc(count, size);\\n-    }\\n+    PR_ASSERT(!malloc_logger);\\n+    malloc_logger = my_malloc_logger;\\n+}\\n \\n-    start = PR_IntervalNow();\\n-    ptr = __libc_calloc(count, size);\\n-    end = PR_IntervalNow();\\n+static void\\n+ShutdownHooker(void)\\n+{\\n+    PR_ASSERT(malloc_logger == my_malloc_logger);\\n+    malloc_logger = NULL;\\n+}\\n \\n-    site = backtrace(t, 1);\\n+#elif defined(XP_UNIX)\\n \\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n-    tmstats.calloc_calls++;\\n-    if (!ptr) {\\n-        tmstats.calloc_failures++;\\n-    } else {\\n-        size *= count;\\n-        if (site) {\\n-            log_event5(logfp, TM_EVENT_CALLOC,\\n-                       site->serial, start, end - start,\\n-                       (uint32)NS_PTR_TO_INT32(ptr), size);\\n-        }\\n-        if (get_allocations()) {\\n-            he = PL_HashTableAdd(allocations, ptr, site);\\n-            if (he) {\\n-                alloc = (allocation*) he;\\n-                alloc->size = size;\\n-                alloc->trackfp = NULL;\\n-            }\\n-        }\\n-    }\\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n-    return ptr;\\n-}\\n+static __ptr_t (*old_malloc_hook)(size_t size, __const __malloc_ptr_t caller);\\n+static __ptr_t (*old_realloc_hook)(__ptr_t ptr, size_t size, __const __malloc_ptr_t caller);\\n+static __ptr_t (*old_memalign_hook)(size_t boundary, size_t size, __const __malloc_ptr_t caller);\\n+static void (*old_free_hook)(__ptr_t ptr, __const __malloc_ptr_t caller);\\n \\n-NS_EXTERNAL_VIS_(__ptr_t)\\n-realloc(__ptr_t ptr, size_t size)\\n+static __ptr_t\\n+my_malloc_hook(size_t size, __const __malloc_ptr_t caller)\\n {\\n-    PRUint32 start, end;\\n-    __ptr_t oldptr;\\n-    callsite *oldsite, *site;\\n-    size_t oldsize;\\n-    PLHashNumber hash;\\n-    PLHashEntry **hep, *he;\\n-    allocation *alloc;\\n-    FILE *trackfp = NULL;\\n     tm_thread *t;\\n+    PRUint32 start, end;\\n+    __ptr_t ptr;\\n \\n-    if (!tracing_enabled || !PR_Initialized() ||\\n-        (t = tm_get_thread())->suppress_tracing != 0) {\\n-        return __libc_realloc(ptr, size);\\n-    }\\n-\\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n-    tmstats.realloc_calls++;\\n-    if (PR_TRUE) {\\n-        oldptr = ptr;\\n-        oldsite = NULL;\\n-        oldsize = 0;\\n-        he = NULL;\\n-        if (oldptr && get_allocations()) {\\n-            hash = hash_pointer(oldptr);\\n-            hep = PL_HashTableRawLookup(allocations, hash, oldptr);\\n-            he = *hep;\\n-            if (he) {\\n-                oldsite = (callsite*) he->value;\\n-                alloc = (allocation*) he;\\n-                oldsize = alloc->size;\\n-                trackfp = alloc->trackfp;\\n-                if (trackfp) {\\n-                    fprintf(alloc->trackfp,\\n-                            \\\"\\\\nrealloc(%p, %lu), oldsize %lu, alloc site %p\\\\n\\\",\\n-                            (void*) ptr, (unsigned long) size,\\n-                            (unsigned long) oldsize, (void*) oldsite);\\n-                    NS_TraceStack(1, trackfp);\\n-                }\\n-            }\\n-        }\\n-    }\\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n-\\n+    PR_ASSERT(tracing_enabled);\\n+    t = tm_get_thread();\\n+    __malloc_hook = old_malloc_hook;\\n     start = PR_IntervalNow();\\n-    ptr = __libc_realloc(ptr, size);\\n+    ptr = __libc_malloc(size);\\n     end = PR_IntervalNow();\\n-\\n-    site = backtrace(t, 1);\\n-\\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n-    if (!ptr && size) {\\n-        /*\\n-         * When realloc() fails, the original block is not freed or moved, so\\n-         * we'll leave the allocation entry untouched.\\n-         */\\n-        tmstats.realloc_failures++;\\n-    } else {\\n-        if (site) {\\n-            log_event8(logfp, TM_EVENT_REALLOC,\\n-                       site->serial, start, end - start,\\n-                       (uint32)NS_PTR_TO_INT32(ptr), size,\\n-                       oldsite ? oldsite->serial : 0,\\n-                       (uint32)NS_PTR_TO_INT32(oldptr), oldsize);\\n-        }\\n-        if (ptr && allocations) {\\n-            if (ptr != oldptr) {\\n-                /*\\n-                 * If we're reallocating (not merely allocating new space by\\n-                 * passing null to realloc) and realloc has moved the block,\\n-                 * free oldptr.\\n-                 */\\n-                if (he)\\n-                    PL_HashTableRemove(allocations, oldptr);\\n-\\n-                /* Record the new allocation now, setting he. */\\n-                he = PL_HashTableAdd(allocations, ptr, site);\\n-            } else {\\n-                /*\\n-                 * If we haven't yet recorded an allocation (possibly due to\\n-                 * a temporary memory shortage), do it now.\\n-                 */\\n-                if (!he)\\n-                    he = PL_HashTableAdd(allocations, ptr, site);\\n-            }\\n-            if (he) {\\n-                alloc = (allocation*) he;\\n-                alloc->size = size;\\n-                alloc->trackfp = trackfp;\\n-            }\\n-        }\\n-    }\\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n+    __malloc_hook = my_malloc_hook;\\n+    MallocCallback(ptr, size, start, end, t);\\n     return ptr;\\n }\\n \\n-NS_EXTERNAL_VIS_(void*)\\n-valloc(size_t size)\\n+static __ptr_t\\n+my_realloc_hook(__ptr_t oldptr, size_t size, __const __malloc_ptr_t caller)\\n {\\n+    tm_thread *t;\\n     PRUint32 start, end;\\n     __ptr_t ptr;\\n-    callsite *site;\\n-    PLHashEntry *he;\\n-    allocation *alloc;\\n-    tm_thread *t;\\n-\\n-    if (!tracing_enabled || !PR_Initialized() ||\\n-        (t = tm_get_thread())->suppress_tracing != 0) {\\n-        return __libc_valloc(size);\\n-    }\\n \\n+    PR_ASSERT(tracing_enabled);\\n+    t = tm_get_thread();\\n+    __realloc_hook = old_realloc_hook;\\n     start = PR_IntervalNow();\\n-    ptr = __libc_valloc(size);\\n+    ptr = __libc_realloc(oldptr, size);\\n     end = PR_IntervalNow();\\n-\\n-    site = backtrace(t, 1);\\n-\\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n-    tmstats.malloc_calls++; /* XXX valloc_calls ? */\\n-    if (!ptr) {\\n-        tmstats.malloc_failures++; /* XXX valloc_failures ? */\\n-    } else {\\n-        if (site)\\n-            log_event5(logfp, TM_EVENT_MALLOC, /* XXX TM_EVENT_VALLOC? */\\n-                       site->serial, start, end - start,\\n-                       (uint32)NS_PTR_TO_INT32(ptr), size);\\n-        if (get_allocations()) {\\n-            he = PL_HashTableAdd(allocations, ptr, site);\\n-            if (he) {\\n-                alloc = (allocation*) he;\\n-                alloc->size = size;\\n-                alloc->trackfp = NULL;\\n-            }\\n-        }\\n-    }\\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n+    __realloc_hook = my_realloc_hook;\\n+    ReallocCallback(oldptr, ptr, size, start, end, t);\\n     return ptr;\\n }\\n \\n-NS_EXTERNAL_VIS_(void*)\\n-memalign(size_t boundary, size_t size)\\n+static __ptr_t\\n+my_memalign_hook(size_t boundary, size_t size, __const __malloc_ptr_t caller)\\n {\\n+    tm_thread *t;\\n     PRUint32 start, end;\\n     __ptr_t ptr;\\n-    callsite *site;\\n-    PLHashEntry *he;\\n-    allocation *alloc;\\n-    tm_thread *t;\\n-\\n-    if (!tracing_enabled || !PR_Initialized() ||\\n-        (t = tm_get_thread())->suppress_tracing != 0) {\\n-        return __libc_memalign(boundary, size);\\n-    }\\n \\n+    PR_ASSERT(tracing_enabled);\\n+    t = tm_get_thread();\\n+    __memalign_hook = old_memalign_hook;\\n     start = PR_IntervalNow();\\n     ptr = __libc_memalign(boundary, size);\\n     end = PR_IntervalNow();\\n-\\n-    site = backtrace(t, 1);\\n-\\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n-    tmstats.malloc_calls++; /* XXX memalign_calls ? */\\n-    if (!ptr) {\\n-        tmstats.malloc_failures++; /* XXX memalign_failures ? */\\n-    } else {\\n-        if (site) {\\n-            log_event5(logfp, TM_EVENT_MALLOC, /* XXX TM_EVENT_MEMALIGN? */\\n-                       site->serial, start, end - start,\\n-                       (uint32)NS_PTR_TO_INT32(ptr), size);\\n-        }\\n-        if (get_allocations()) {\\n-            he = PL_HashTableAdd(allocations, ptr, site);\\n-            if (he) {\\n-                alloc = (allocation*) he;\\n-                alloc->size = size;\\n-                alloc->trackfp = NULL;\\n-            }\\n-        }\\n-    }\\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n+    __memalign_hook = my_memalign_hook;\\n+    MallocCallback(ptr, size, start, end, t);\\n     return ptr;\\n }\\n \\n-NS_EXTERNAL_VIS_(int)\\n-posix_memalign(void **memptr, size_t alignment, size_t size)\\n-{\\n-    __ptr_t ptr = memalign(alignment, size);\\n-    if (!ptr)\\n-        return ENOMEM;\\n-    *memptr = ptr;\\n-    return 0;\\n-}\\n-\\n-NS_EXTERNAL_VIS_(void)\\n-free(__ptr_t ptr)\\n+static void\\n+my_free_hook(__ptr_t ptr, __const __malloc_ptr_t caller)\\n {\\n-    PLHashEntry **hep, *he;\\n-    callsite *site;\\n-    allocation *alloc;\\n-    uint32 serial = 0, size = 0;\\n-    PRUint32 start, end;\\n     tm_thread *t;\\n+    PRUint32 start, end;\\n \\n-    if (!tracing_enabled || !PR_Initialized() ||\\n-        (t = tm_get_thread())->suppress_tracing != 0) {\\n-        __libc_free(ptr);\\n-        return;\\n-    }\\n-\\n-    t->suppress_tracing++;\\n-    TM_ENTER_LOCK();\\n-    tmstats.free_calls++;\\n-    if (!ptr) {\\n-        tmstats.null_free_calls++;\\n-    } else {\\n-        if (get_allocations()) {\\n-            hep = PL_HashTableRawLookup(allocations, hash_pointer(ptr), ptr);\\n-            he = *hep;\\n-            if (he) {\\n-                site = (callsite*) he->value;\\n-                if (site) {\\n-                    alloc = (allocation*) he;\\n-                    serial = site->serial;\\n-                    size = alloc->size;\\n-                    if (alloc->trackfp) {\\n-                        fprintf(alloc->trackfp, \\\"\\\\nfree(%p), alloc site %p\\\\n\\\",\\n-                                (void*) ptr, (void*) site);\\n-                        NS_TraceStack(1, alloc->trackfp);\\n-                    }\\n-                }\\n-                PL_HashTableRawRemove(allocations, hep, he);\\n-            }\\n-        }\\n-    }\\n-    TM_EXIT_LOCK();\\n-    t->suppress_tracing--;\\n-\\n+    PR_ASSERT(tracing_enabled);\\n+    t = tm_get_thread();\\n+    __free_hook = old_free_hook;\\n     start = PR_IntervalNow();\\n     __libc_free(ptr);\\n     end = PR_IntervalNow();\\n-\\n-    if (size != 0) {\\n-        t->suppress_tracing++;\\n-        TM_ENTER_LOCK();\\n-        log_event5(logfp, TM_EVENT_FREE,\\n-                   serial, start, end - start,\\n-                   (uint32)NS_PTR_TO_INT32(ptr), size);\\n-        TM_EXIT_LOCK();\\n-        t->suppress_tracing--;\\n-    }\\n+    __free_hook = my_free_hook;\\n+    FreeCallback(ptr, start, end, t);\\n }\\n \\n-NS_EXTERNAL_VIS_(void)\\n-cfree(void *ptr)\\n+static void\\n+StartupHooker(void)\\n {\\n-    free(ptr);\\n-}\\n+    PR_ASSERT(__malloc_hook != my_malloc_hook);\\n \\n-#endif /* XP_UNIX */\\n+    old_malloc_hook = __malloc_hook;\\n+    old_realloc_hook = __realloc_hook;\\n+    old_memalign_hook = __memalign_hook;\\n+    old_free_hook = __free_hook;\\n \\n-#ifdef XP_MACOSX\\n-\\n-/* from malloc.c in Libc */\\n-typedef void (malloc_logger_t)(unsigned type, unsigned arg1, unsigned arg2, unsigned arg3, unsigned result, unsigned num_hot_frames_to_skip);\\n-extern malloc_logger_t *malloc_logger;\\n-\\n-#define MALLOC_LOG_TYPE_ALLOCATE        2\\n-#define MALLOC_LOG_TYPE_DEALLOCATE      4\\n-#define MALLOC_LOG_TYPE_HAS_ZONE        8\\n-#define MALLOC_LOG_TYPE_CLEARED         64\\n+    __malloc_hook = my_malloc_hook;\\n+    __realloc_hook = my_realloc_hook;\\n+    __memalign_hook = my_memalign_hook;\\n+    __free_hook = my_free_hook;\\n+}\\n \\n static void\\n-my_malloc_logger(unsigned type, unsigned arg1, unsigned arg2, unsigned arg3,\\n-                 unsigned result, unsigned num_hot_frames_to_skip)\\n+ShutdownHooker(void)\\n {\\n-    unsigned all_args[3] = { arg1, arg2, arg3 };\\n-    unsigned *args = all_args + ((type & MALLOC_LOG_TYPE_HAS_ZONE) ? 1 : 0);\\n-\\n-    unsigned alloc_type =\\n-        type & (MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_DEALLOCATE);\\n-    tm_thread *t = tm_get_thread();\\n+    PR_ASSERT(__malloc_hook == my_malloc_hook);\\n \\n-    if (alloc_type == (MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_DEALLOCATE)) {\\n-        ReallocCallback((void*)args[0], (void*)result, args[1], 0, 0, t);\\n-    } else if (alloc_type == MALLOC_LOG_TYPE_ALLOCATE) {\\n-        /*\\n-         * We don't get size/count information for calloc, so just use\\n-         * MallocCallback.\\n-         */\\n-        MallocCallback((void*)result, args[0], 0, 0, t);\\n-    } else if (alloc_type == MALLOC_LOG_TYPE_DEALLOCATE) {\\n-        FreeCallback((void*)args[0], 0, 0, t);\\n-    }\\n+    __malloc_hook = old_malloc_hook;\\n+    __realloc_hook = old_realloc_hook;\\n+    __memalign_hook = old_memalign_hook;\\n+    __free_hook = old_free_hook;\\n }\\n \\n+#elif defined(XP_WIN32)\\n+\\n+/* See nsWinTraceMalloc.cpp. */\\n+\\n #endif\\n \\n static const char magic[] = NS_TRACE_MALLOC_MAGIC;\\n@@ -1450,7 +1200,8 @@ log_header(int logfd)\\n     (void) write(logfd, &ticksPerSec, sizeof ticksPerSec);\\n }\\n \\n-PR_IMPLEMENT(void) NS_TraceMallocStartup(int logfd)\\n+PR_IMPLEMENT(void)\\n+NS_TraceMallocStartup(int logfd)\\n {\\n     /* We must be running on the primordial thread. */\\n     PR_ASSERT(tracing_enabled == 1);\\n@@ -1482,18 +1233,10 @@ PR_IMPLEMENT(void) NS_TraceMallocStartup(int logfd)\\n     tmlock = PR_NewLock();\\n     main_thread.suppress_tracing--;\\n \\n-#ifdef XP_WIN32\\n-    /* Register listeners for win32. */\\n-    if (tracing_enabled) {\\n+    if (tracing_enabled)\\n         StartupHooker();\\n-    }\\n-#endif\\n-#ifdef XP_MACOSX\\n-    malloc_logger = my_malloc_logger;\\n-#endif\\n }\\n \\n-\\n /*\\n  * Options for log files, with the log file name either as the next option\\n  * or separated by '=' (e.g. \\\"./mozilla --trace-malloc * malloc.log\\\" or\\n@@ -1517,7 +1260,8 @@ static const char SDLOG_OPTION[] = \\\"--shutdown-leaks\\\";\\n         }                                                                     \\\\\\n     PR_END_MACRO\\n \\n-PR_IMPLEMENT(int) NS_TraceMallocStartupArgs(int argc, char* argv[])\\n+PR_IMPLEMENT(int)\\n+NS_TraceMallocStartupArgs(int argc, char **argv)\\n {\\n     int i, logfd = -1, consumed, logflags;\\n     char *tmlogname = NULL; /* note global |sdlogname| */\\n@@ -1636,7 +1380,8 @@ PR_IMPLEMENT(int) NS_TraceMallocStartupArgs(int argc, char* argv[])\\n     return argc;\\n }\\n \\n-PR_IMPLEMENT(void) NS_TraceMallocShutdown(void)\\n+PR_IMPLEMENT(void)\\n+NS_TraceMallocShutdown(void)\\n {\\n     logfile *fp;\\n \\n@@ -1669,39 +1414,52 @@ PR_IMPLEMENT(void) NS_TraceMallocShutdown(void)\\n         tmlock = NULL;\\n         PR_DestroyLock(lock);\\n     }\\n-#ifdef XP_WIN32\\n     if (tracing_enabled) {\\n+        tracing_enabled = 0;\\n         ShutdownHooker();\\n     }\\n-#endif\\n }\\n \\n-PR_IMPLEMENT(void) NS_TraceMallocDisable(void)\\n+PR_IMPLEMENT(void)\\n+NS_TraceMallocDisable(void)\\n {\\n-    logfile *fp;\\n     tm_thread *t = tm_get_thread();\\n+    logfile *fp;\\n+    uint32 sample;\\n+\\n+    /* Robustify in case of duplicate call. */\\n+    PR_ASSERT(tracing_enabled);\\n+    if (tracing_enabled == 0)\\n+        return;\\n \\n     t->suppress_tracing++;\\n     TM_ENTER_LOCK();\\n     for (fp = logfile_list; fp; fp = fp->next)\\n         flush_logfile(fp);\\n-    tracing_enabled = 0;\\n+    sample = --tracing_enabled;\\n     TM_EXIT_LOCK();\\n     t->suppress_tracing--;\\n+    if (sample == 0)\\n+        ShutdownHooker();\\n }\\n \\n-PR_IMPLEMENT(void) NS_TraceMallocEnable(void)\\n+PR_IMPLEMENT(void)\\n+NS_TraceMallocEnable(void)\\n {\\n     tm_thread *t = tm_get_thread();\\n+    uint32 sample;\\n \\n     t->suppress_tracing++;\\n     TM_ENTER_LOCK();\\n-    tracing_enabled = 1;\\n+    sample = ++tracing_enabled;\\n     TM_EXIT_LOCK();\\n     t->suppress_tracing--;\\n+    if (sample == 1)\\n+        StartupHooker();\\n }\\n \\n-PR_IMPLEMENT(int) NS_TraceMallocChangeLogFD(int fd)\\n+PR_IMPLEMENT(int)\\n+NS_TraceMallocChangeLogFD(int fd)\\n {\\n     logfile *oldfp, *fp;\\n     struct stat sb;\\n@@ -1841,8 +1599,9 @@ allocation_enumerator(PLHashEntry *he, PRIntn i, void *arg)\\n \\n     for (p   = (unsigned long*) he->key,\\n          end = (unsigned long*) ((char*)he->key + alloc->size);\\n-         p < end; ++p)\\n+         p < end; ++p) {\\n         fprintf(ofp, \\\"\\\\t0x%08lX\\\\n\\\", *p);\\n+    }\\n \\n     while (site) {\\n         if (site->name || site->parent) {\\n@@ -1884,9 +1643,10 @@ NS_TraceMallocDumpAllocations(const char *pathname)\\n \\n     ofp = fopen(pathname, WRITE_FLAGS);\\n     if (ofp) {\\n-        if (allocations)\\n+        if (allocations) {\\n             PL_HashTableEnumerateEntries(allocations, allocation_enumerator,\\n                                          ofp);\\n+        }\\n         rv = ferror(ofp) ? -1 : 0;\\n         fclose(ofp);\\n     } else {\\n@@ -1918,7 +1678,6 @@ NS_TraceMallocFlushLogfiles(void)\\n PR_IMPLEMENT(void)\\n NS_TrackAllocation(void* ptr, FILE *ofp)\\n {\\n-    PLHashEntry **hep;\\n     allocation *alloc;\\n     tm_thread *t = tm_get_thread();\\n \\n@@ -1928,8 +1687,8 @@ NS_TrackAllocation(void* ptr, FILE *ofp)\\n     t->suppress_tracing++;\\n     TM_ENTER_LOCK();\\n     if (get_allocations()) {\\n-        hep = PL_HashTableRawLookup(allocations, hash_pointer(ptr), ptr);\\n-        alloc = (allocation*) *hep;\\n+        alloc = (allocation*)\\n+                *PL_HashTableRawLookup(allocations, hash_pointer(ptr), ptr);\\n         if (alloc) {\\n             fprintf(ofp, \\\"Tracking %p\\\\n\\\", (void*) ptr);\\n             alloc->trackfp = ofp;\\n@@ -1941,8 +1700,6 @@ NS_TrackAllocation(void* ptr, FILE *ofp)\\n     t->suppress_tracing--;\\n }\\n \\n-#if defined(XP_WIN32) || defined(XP_MACOSX)\\n-\\n PR_IMPLEMENT(void)\\n MallocCallback(void *ptr, size_t size, PRUint32 start, PRUint32 end, tm_thread *t)\\n {\\n@@ -1961,15 +1718,17 @@ MallocCallback(void *ptr, size_t size, PRUint32 start, PRUint32 end, tm_thread *\\n     if (!ptr) {\\n         tmstats.malloc_failures++;\\n     } else {\\n-        if (site)\\n+        if (site) {\\n             log_event5(logfp, TM_EVENT_MALLOC,\\n                        site->serial, start, end - start,\\n                        (uint32)NS_PTR_TO_INT32(ptr), size);\\n+        }\\n         if (get_allocations()) {\\n             he = PL_HashTableAdd(allocations, ptr, site);\\n             if (he) {\\n                 alloc = (allocation*) he;\\n                 alloc->size = size;\\n+                alloc->trackfp = NULL;\\n             }\\n         }\\n     }\\n@@ -1996,15 +1755,17 @@ CallocCallback(void *ptr, size_t count, size_t size, PRUint32 start, PRUint32 en\\n         tmstats.calloc_failures++;\\n     } else {\\n         size *= count;\\n-        if (site)\\n+        if (site) {\\n             log_event5(logfp, TM_EVENT_CALLOC,\\n                        site->serial, start, end - start,\\n                        (uint32)NS_PTR_TO_INT32(ptr), size);\\n+        }\\n         if (get_allocations()) {\\n             he = PL_HashTableAdd(allocations, ptr, site);\\n             if (he) {\\n                 alloc = (allocation*) he;\\n                 alloc->size = size;\\n+                alloc->trackfp = NULL;\\n             }\\n         }\\n     }\\n@@ -2013,13 +1774,15 @@ CallocCallback(void *ptr, size_t count, size_t size, PRUint32 start, PRUint32 en\\n }\\n \\n PR_IMPLEMENT(void)\\n-ReallocCallback(void * oldptr, void *ptr, size_t size, PRUint32 start, PRUint32 end, tm_thread *t)\\n+ReallocCallback(void * oldptr, void *ptr, size_t size,\\n+                PRUint32 start, PRUint32 end, tm_thread *t)\\n {\\n     callsite *oldsite, *site;\\n     size_t oldsize;\\n     PLHashNumber hash;\\n     PLHashEntry **hep, *he;\\n     allocation *alloc;\\n+    FILE *trackfp = NULL;\\n \\n     if (!tracing_enabled || t->suppress_tracing != 0)\\n         return;\\n@@ -2029,28 +1792,34 @@ ReallocCallback(void * oldptr, void *ptr, size_t size, PRUint32 start, PRUint32\\n     t->suppress_tracing++;\\n     TM_ENTER_LOCK();\\n     tmstats.realloc_calls++;\\n-    if (PR_TRUE) {\\n-        oldsite = NULL;\\n-        oldsize = 0;\\n-        he = NULL;\\n-        if (oldptr && get_allocations()) {\\n-            hash = hash_pointer(oldptr);\\n-            hep = PL_HashTableRawLookup(allocations, hash, oldptr);\\n-            he = *hep;\\n-            if (he) {\\n-                oldsite = (callsite*) he->value;\\n-                alloc = (allocation*) he;\\n-                oldsize = alloc->size;\\n+    oldsite = NULL;\\n+    oldsize = 0;\\n+    hep = NULL;\\n+    he = NULL;\\n+    if (oldptr && get_allocations()) {\\n+        hash = hash_pointer(oldptr);\\n+        hep = PL_HashTableRawLookup(allocations, hash, oldptr);\\n+        he = *hep;\\n+        if (he) {\\n+            oldsite = (callsite*) he->value;\\n+            alloc = (allocation*) he;\\n+            oldsize = alloc->size;\\n+            trackfp = alloc->trackfp;\\n+            if (trackfp) {\\n+                fprintf(alloc->trackfp,\\n+                        \\\"\\\\nrealloc(%p, %lu), oldsize %lu, alloc site %p\\\\n\\\",\\n+                        (void*) ptr, (unsigned long) size,\\n+                        (unsigned long) oldsize, (void*) oldsite);\\n+                NS_TraceStack(1, trackfp);\\n             }\\n         }\\n     }\\n     if (!ptr && size) {\\n-        tmstats.realloc_failures++;\\n-\\n         /*\\n          * When realloc() fails, the original block is not freed or moved, so\\n          * we'll leave the allocation entry untouched.\\n          */\\n+        tmstats.realloc_failures++;\\n     } else {\\n         if (site) {\\n             log_event8(logfp, TM_EVENT_REALLOC,\\n@@ -2081,6 +1850,7 @@ ReallocCallback(void * oldptr, void *ptr, size_t size, PRUint32 start, PRUint32\\n             if (he) {\\n                 alloc = (allocation*) he;\\n                 alloc->size = size;\\n+                alloc->trackfp = trackfp;\\n             }\\n         }\\n     }\\n@@ -2111,6 +1881,11 @@ FreeCallback(void * ptr, PRUint32 start, PRUint32 end, tm_thread *t)\\n                 site = (callsite*) he->value;\\n                 if (site) {\\n                     alloc = (allocation*) he;\\n+                    if (alloc->trackfp) {\\n+                        fprintf(alloc->trackfp, \\\"\\\\nfree(%p), alloc site %p\\\\n\\\",\\n+                                (void*) ptr, (void*) site);\\n+                        NS_TraceStack(1, alloc->trackfp);\\n+                    }\\n                     log_event5(logfp, TM_EVENT_FREE,\\n                                site->serial, start, end - start,\\n                                (uint32)NS_PTR_TO_INT32(ptr), alloc->size);\\n@@ -2123,6 +1898,4 @@ FreeCallback(void * ptr, PRUint32 start, PRUint32 end, tm_thread *t)\\n     t->suppress_tracing--;\\n }\\n \\n-#endif /* defined(XP_WIN32) || defined(XP_MACOSX) */\\n-\\n #endif /* NS_TRACE_MALLOC */\\ndiff --git a/tools/trace-malloc/lib/nsTraceMallocCallbacks.h b/tools/trace-malloc/lib/nsTraceMallocCallbacks.h\\nindex e3f2db2..61f5a46b 100644\\n--- a/tools/trace-malloc/lib/nsTraceMallocCallbacks.h\\n+++ b/tools/trace-malloc/lib/nsTraceMallocCallbacks.h\\n@@ -69,13 +69,11 @@ struct tm_thread {\\n /* implemented in nsTraceMalloc.c */\\n tm_thread * tm_get_thread(void);\\n \\n-#if defined(XP_WIN32) || defined(XP_MACOSX)\\n /* implemented in nsTraceMalloc.c */\\n PR_EXTERN(void) MallocCallback(void *aPtr, size_t aSize, PRUint32 start, PRUint32 end, tm_thread *t);\\n PR_EXTERN(void) CallocCallback(void *aPtr, size_t aCount, size_t aSize, PRUint32 start, PRUint32 end, tm_thread *t);\\n PR_EXTERN(void) ReallocCallback(void *aPin, void* aPout, size_t aSize, PRUint32 start, PRUint32 end, tm_thread *t);\\n PR_EXTERN(void) FreeCallback(void *aPtr, PRUint32 start, PRUint32 end, tm_thread *t);\\n-#endif\\n \\n #ifdef XP_WIN32\\n /* implemented in nsTraceMalloc.c */\\n\""}