{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas84930cd\""},"diff":"\"84930cd Fix leak of mPendingHTTPRequest in nsSSLThread::rememberPendingHTTPRequest by converting it to an nsCOMPtr.  b=394528  r=kengert  sr=bzbarsky  a=bsmedberg\\ndiff --git a/security/manager/ssl/src/nsSSLThread.cpp b/security/manager/ssl/src/nsSSLThread.cpp\\nindex c6ba607..fd60e18 100644\\n--- a/security/manager/ssl/src/nsSSLThread.cpp\\n+++ b/security/manager/ssl/src/nsSSLThread.cpp\\n@@ -48,8 +48,7 @@ extern PRLogModuleInfo* gPIPNSSLog;\\n \\n nsSSLThread::nsSSLThread()\\n : mBusySocket(nsnull),\\n-  mSocketScheduledToBeDestroyed(nsnull),\\n-  mPendingHTTPRequest(nsnull)\\n+  mSocketScheduledToBeDestroyed(nsnull)\\n {\\n   NS_ASSERTION(!ssl_thread_singleton, \\\"nsSSLThread is a singleton, caller attempts to create another instance!\\\");\\n   \\n@@ -379,7 +378,7 @@ PRStatus nsSSLThread::requestClose(nsNSSSocketInfo *si)\\n     return PR_FAILURE;\\n \\n   PRBool close_later = PR_FALSE;\\n-  nsIRequest* requestToCancel = nsnull;\\n+  nsCOMPtr<nsIRequest> requestToCancel;\\n \\n   {\\n     nsAutoLock threadLock(ssl_thread_singleton->mMutex);\\n@@ -395,8 +394,7 @@ PRStatus nsSSLThread::requestClose(nsNSSSocketInfo *si)\\n       \\n       if (ssl_thread_singleton->mPendingHTTPRequest)\\n       {\\n-        requestToCancel = ssl_thread_singleton->mPendingHTTPRequest;\\n-        ssl_thread_singleton->mPendingHTTPRequest = nsnull;\\n+        requestToCancel.swap(ssl_thread_singleton->mPendingHTTPRequest);\\n       }\\n       \\n       close_later = PR_TRUE;\\n@@ -417,7 +415,7 @@ PRStatus nsSSLThread::requestClose(nsNSSSocketInfo *si)\\n       NS_WARNING(\\\"Attempt to close SSL socket from a thread that is not the main thread. Can not cancel pending HTTP request from NSS\\\");\\n     }\\n   \\n-    NS_RELEASE(requestToCancel);\\n+    requestToCancel = nsnull;\\n   }\\n   \\n   if (!close_later)\\n@@ -1129,7 +1127,6 @@ void nsSSLThread::rememberPendingHTTPRequest(nsIRequest *aRequest)\\n \\n   nsAutoLock threadLock(ssl_thread_singleton->mMutex);\\n \\n-  NS_IF_ADDREF(aRequest);\\n   ssl_thread_singleton->mPendingHTTPRequest = aRequest;\\n }\\n \\n@@ -1143,9 +1140,6 @@ void nsSSLThread::cancelPendingHTTPRequest()\\n   if (ssl_thread_singleton->mPendingHTTPRequest)\\n   {\\n     ssl_thread_singleton->mPendingHTTPRequest->Cancel(NS_ERROR_ABORT);\\n-\\n-    NS_RELEASE(ssl_thread_singleton->mPendingHTTPRequest);\\n-\\n     ssl_thread_singleton->mPendingHTTPRequest = nsnull;\\n   }\\n }\\ndiff --git a/security/manager/ssl/src/nsSSLThread.h b/security/manager/ssl/src/nsSSLThread.h\\nindex e72062f..5e60f11 100644\\n--- a/security/manager/ssl/src/nsSSLThread.h\\n+++ b/security/manager/ssl/src/nsSSLThread.h\\n@@ -79,7 +79,7 @@ private:\\n   // As this HTTP request depends on some original SSL socket,\\n   // we can use this handle to cancel the dependent HTTP request,\\n   // should we be asked to close the original SSL socket.\\n-  nsIRequest* mPendingHTTPRequest;\\n+  nsCOMPtr<nsIRequest> mPendingHTTPRequest;\\n \\n   virtual void Run(void);\\n \\n\""}