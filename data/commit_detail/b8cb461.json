{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basb8cb461\""},"diff":"\"b8cb461 Possible fix for performance regressions from bug 395397 appshell patch. b=396796 r+joshmoz+mark sr=roc a=roc\\ndiff --git a/widget/src/cocoa/nsAppShell.mm b/widget/src/cocoa/nsAppShell.mm\\nindex b39da53..3a34fd7 100644\\n--- a/widget/src/cocoa/nsAppShell.mm\\n+++ b/widget/src/cocoa/nsAppShell.mm\\n@@ -241,7 +241,7 @@ nsAppShell::ProcessGeckoEvents(void* aInfo)\\n   if (self->mRunningEventLoop) {\\n     self->mRunningEventLoop = PR_FALSE;\\n \\n-    // The run loop may be sleeping -- [NSRunLoop acceptInputForMode:...]\\n+    // The run loop may be sleeping -- [NSRunLoop runMode:...]\\n     // won't return until it's given a reason to wake up.  Awaken it by\\n     // posting a bogus event.  There's no need to make the event\\n     // presentable.\\n@@ -362,8 +362,8 @@ nsAppShell::ScheduleNativeEventCallback()\\n //\\n // Returns true if more events are waiting in the native event queue.\\n //\\n-// But (now that we're using [NSRunLoop acceptInputForMode:beforeDate:]) it's\\n-// too expensive to call ProcessNextNativeEvent() many times in a row (in a\\n+// But (now that we're using [NSRunLoop runMode:beforeDate:]) it's too\\n+// expensive to call ProcessNextNativeEvent() many times in a row (in a\\n // tight loop), so we never return true more than kHadMoreEventsCountMax\\n // times in a row.  This doesn't seem to cause native event starvation.\\n //\\n@@ -384,6 +384,8 @@ nsAppShell::ProcessNextNativeEvent(PRBool aMayWait)\\n   if (aMayWait)\\n     waitUntil = [NSDate distantFuture];\\n \\n+  NSRunLoop* currentRunLoop = [NSRunLoop currentRunLoop];\\n+\\n   do {\\n     // No autorelease pool is provided here, because OnProcessNextEvent\\n     // and AfterProcessNextEvent are responsible for maintaining it.\\n@@ -403,40 +405,67 @@ nsAppShell::ProcessNextNativeEvent(PRBool aMayWait)\\n     // You also sometimes had to ctrl-click or right-click multiple times to\\n     // bring up a context menu.)\\n \\n-    // Now that we're using [NSRunLoop acceptInputForMode:beforeDate:], it's\\n-    // too expensive to call ProcessNextNativeEvent() many times in a row, so\\n-    // we never return true more than kHadMoreEventsCountMax in a row.  I'm\\n-    // not entirely sure why [NSRunLoop acceptInputForMode:beforeDate:] is too\\n-    // expensive, since it and its cousin [NSRunLoop runMode:beforeDate:] are\\n+    // Now that we're using [NSRunLoop runMode:beforeDate:], it's too\\n+    // expensive to call ProcessNextNativeEvent() many times in a row, so we\\n+    // never return true more than kHadMoreEventsCountMax in a row.  I'm not\\n+    // entirely sure why [NSRunLoop runMode:beforeDate:] is too expensive,\\n+    // since it and its cousin [NSRunLoop acceptInputForMode:beforeDate:] are\\n     // designed to be called in a tight loop.  Possibly the problem is due to\\n-    // combining [NSRunLoop acceptInputForMode:beforeDate] with [NSApp\\n+    // combining [NSRunLoop runMode:beforeDate] with [NSApp\\n     // nextEventMatchingMask:...].\\n \\n+    // We need to special-case timer events (events of type NSPeriodic),\\n+    // otherwise we will starve them.  (Which can have strange results --\\n+    // among other things it causes a ~10% increase in the number of calls\\n+    // to malloc and a ~2% Tdhtml regression.  See bmo bug 396796.)  Apple's\\n+    // documentation is very scanty, and it's now more scanty than it used to\\n+    // be.  But it appears that [NSRunLoop acceptInputForMode:beforeDate:]\\n+    // doesn't process timer events at all, that it is called from\\n+    // [NSRunLoop runMode:beforeDate:], and that [NSRunLoop runMode:beforeDate:],\\n+    // though it does process timer events, doesn't return after doing so.\\n+    // To get around this, when aWait is PR_FALSE we check for timer events\\n+    // and process them using [NSApp sendEvent:].  When aWait is PR_TRUE\\n+    // [NSRunLoop runMode:beforeDate:] will only return on a \\\"real\\\" event.\\n+    // But there's code in ProcessGeckoEvents() that should (when need be)\\n+    // wake us up by sending a \\\"fake\\\" \\\"real\\\" event.  (See Apple's current doc\\n+    // on [NSRunLoop runMode:beforeDate:] and a quote from what appears to be\\n+    // an older version of this doc at\\n+    // http://lists.apple.com/archives/cocoa-dev/2001/May/msg00559.html.)\\n+\\n     // If the current mode is something else than NSDefaultRunLoopMode, look\\n     // for events in that mode.\\n-    currentMode = [[NSRunLoop currentRunLoop] currentMode];\\n+    currentMode = [currentRunLoop currentMode];\\n     if (!currentMode)\\n       currentMode = NSDefaultRunLoopMode;\\n \\n+    NSEvent* nextEvent = nil;\\n+\\n     // If we're running modal (either Cocoa modal or XUL modal) we still need\\n     // to use nextEventMatchingMask and sendEvent -- otherwise (in Minefield)\\n     // the modal window won't receive key events or most mouse events.\\n     if ([NSApp _isRunningModal] || (gXULModalLevel > 0)) {\\n-      if (NSEvent* event = [NSApp nextEventMatchingMask:NSAnyEventMask\\n-                                              untilDate:waitUntil\\n-                                                 inMode:currentMode\\n-                                                dequeue:YES]) {\\n-        [NSApp sendEvent:event];\\n+      if (nextEvent = [NSApp nextEventMatchingMask:NSAnyEventMask\\n+                                         untilDate:waitUntil\\n+                                            inMode:currentMode\\n+                                           dequeue:YES]) {\\n+        [NSApp sendEvent:nextEvent];\\n         eventProcessed = PR_TRUE;\\n       }\\n     } else {\\n       if (aMayWait ||\\n-          [NSApp nextEventMatchingMask:NSAnyEventMask\\n-                             untilDate:nil\\n-                                inMode:currentMode\\n-                               dequeue:NO]) {\\n-        [[NSRunLoop currentRunLoop] acceptInputForMode:currentMode\\n-                                            beforeDate:waitUntil];\\n+          (nextEvent = [NSApp nextEventMatchingMask:NSAnyEventMask\\n+                                          untilDate:nil\\n+                                             inMode:currentMode\\n+                                            dequeue:NO])) {\\n+        if (nextEvent && ([nextEvent type] == NSPeriodic)) {\\n+          nextEvent = [NSApp nextEventMatchingMask:NSAnyEventMask\\n+                                         untilDate:waitUntil\\n+                                            inMode:currentMode\\n+                                           dequeue:YES];\\n+          [NSApp sendEvent:nextEvent];\\n+        } else {\\n+          [currentRunLoop runMode:currentMode beforeDate:waitUntil];\\n+        }\\n         eventProcessed = PR_TRUE;\\n       }\\n     }\\n\""}