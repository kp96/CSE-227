{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bascffc854\""},"diff":"\"cffc854 Bug 394403 - \\\"Crash Viewing Image [ @ nsGIFDecoder2::DoLzw]\\\" (don't write image pixels outside of image) [p=alfredkayser@nl.ibm.com (Alfred Kayser) r=pavlov sr=tor a1.9=dsicore]\\ndiff --git a/modules/libpr0n/decoders/gif/GIF2.h b/modules/libpr0n/decoders/gif/GIF2.h\\nindex 341449b..1541c61 100644\\n--- a/modules/libpr0n/decoders/gif/GIF2.h\\n+++ b/modules/libpr0n/decoders/gif/GIF2.h\\n@@ -42,6 +42,14 @@\\n #define MAX_COLORS           256\\n #define MAX_HOLD_SIZE        256\\n \\n+enum { GIF_TRAILER                     = 0x3B }; //';'\\n+enum { GIF_IMAGE_SEPARATOR             = 0x2C }; //','\\n+enum { GIF_EXTENSION_INTRODUCER        = 0x21 }; //'!'\\n+enum { GIF_GRAPHIC_CONTROL_LABEL       = 0xF9 };\\n+enum { GIF_COMMENT_LABEL               = 0xFE };\\n+enum { GIF_PLAIN_TEXT_LABEL            = 0x01 };\\n+enum { GIF_APPLICATION_EXTENSION_LABEL = 0xFF };\\n+\\n /* gif2.h  \\n    The interface for the GIF87/89a decoder. \\n */\\n@@ -50,7 +58,7 @@ typedef enum {\\n     gif_type,\\n     gif_global_header,\\n     gif_global_colormap,\\n-    gif_image_start,            \\n+    gif_image_start,\\n     gif_image_header,\\n     gif_image_colormap,\\n     gif_image_body,\\ndiff --git a/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp b/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp\\nindex 9028a5a6..f9a0a3e 100644\\n--- a/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp\\n+++ b/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp\\n@@ -483,6 +483,9 @@ PRUint32 nsGIFDecoder2::OutputRow()\\n PRBool\\n nsGIFDecoder2::DoLzw(const PRUint8 *q)\\n {\\n+  if (!mGIFStruct.rows_remaining)\\n+    return PR_TRUE;\\n+\\n   /* Copy all the decoder state variables into locals so the compiler\\n    * won't worry about them being aliased.  The locals will be homed\\n    * back into the GIF decoder structure when we exit.\\n@@ -503,10 +506,6 @@ nsGIFDecoder2::DoLzw(const PRUint8 *q)\\n   PRUint32 *rowp    = mGIFStruct.rowp;\\n   PRUint32 *rowend  = mImageData + (mGIFStruct.irow + 1) * mGIFStruct.width;\\n   PRUint32 *cmap    = mColormap;\\n-\\n-  if (rowp == rowend)\\n-    return PR_TRUE;\\n-\\n #define OUTPUT_ROW()                                        \\\\\\n   PR_BEGIN_MACRO                                            \\\\\\n     if (!OutputRow())                                       \\\\\\n@@ -797,21 +796,21 @@ nsresult nsGIFDecoder2::GifWrite(const PRUint8 *buf, PRUint32 len)\\n \\n     case gif_image_start:\\n       switch (*q) {\\n-        case ';':  /* terminator */\\n+        case GIF_TRAILER:\\n           mGIFStruct.state = gif_done;\\n           break;\\n \\n-        case '!': /* extension */\\n+        case GIF_EXTENSION_INTRODUCER:\\n           GETN(2, gif_extension);\\n           break;\\n \\n-        case ',':\\n+        case GIF_IMAGE_SEPARATOR:\\n           GETN(9, gif_image_header);\\n           break;\\n \\n         default:\\n-          /* If we get anything other than ',' (image separator), '!'\\n-           * (extension), or ';' (trailer), there is extraneous data\\n+          /* If we get anything other than GIF_IMAGE_SEPARATOR, \\n+           * GIF_EXTENSION_INTRODUCER, or GIF_TRAILER, there is extraneous data\\n            * between blocks. The GIF87a spec tells us to keep reading\\n            * until we find an image separator, but GIF89a says such\\n            * a file is corrupt. We follow GIF89a and bail out. */\\n@@ -833,15 +832,15 @@ nsresult nsGIFDecoder2::GifWrite(const PRUint8 *buf, PRUint32 len)\\n       mGIFStruct.bytes_to_consume = q[1];\\n       if (mGIFStruct.bytes_to_consume) {\\n         switch (*q) {\\n-        case 0xf9:\\n+        case GIF_GRAPHIC_CONTROL_LABEL:\\n           mGIFStruct.state = gif_control_extension;\\n           break;\\n   \\n-        case 0xff:\\n+        case GIF_APPLICATION_EXTENSION_LABEL:\\n           mGIFStruct.state = gif_application_extension;\\n           break;\\n   \\n-        case 0xfe:\\n+        case GIF_COMMENT_LABEL:\\n           mGIFStruct.state = gif_consume_comment;\\n           break;\\n   \\n@@ -1046,6 +1045,11 @@ nsresult nsGIFDecoder2::GifWrite(const PRUint8 *buf, PRUint32 len)\\n           /* This is an illegal GIF, but we remain tolerant. */\\n           GETN(1, gif_sub_block);\\n #endif\\n+          if (mGIFStruct.count == GIF_TRAILER) {\\n+            /* Found a terminator anyway, so consider the image done */\\n+            GETN(1, gif_done);\\n+            break;\\n+          }\\n         }\\n         GETN(mGIFStruct.count, gif_lzw);\\n       } else {\\n\""}