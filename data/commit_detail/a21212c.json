{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basa21212c\""},"diff":"\"a21212c Bug 396632. Don't require namespaces when using ARIA properties in text/html\\ndiff --git a/accessible/public/nsIAccessibleDocument.idl b/accessible/public/nsIAccessibleDocument.idl\\nindex 4582d64..7227d3a 100644\\n--- a/accessible/public/nsIAccessibleDocument.idl\\n+++ b/accessible/public/nsIAccessibleDocument.idl\\n@@ -58,7 +58,7 @@ interface nsIDOMWindow;\\n  *\\n  * @status UNDER_REVIEW\\n  */\\n-[scriptable, uuid(6cc11286-e02d-4a8d-960a-e7a61161b230)]\\n+[scriptable, uuid(d118c0e9-b5e7-4671-854a-65b4713d9552)]\\n interface nsIAccessibleDocument : nsISupports\\n {\\n   /**\\n@@ -121,4 +121,27 @@ interface nsIAccessibleDocument : nsISupports\\n    *         to the document root.\\n    */\\n   nsIAccessible getAccessibleInParentChain(in nsIDOMNode aDOMNode);\\n+\\n+  /**\\n+   * A bit flag representing the type of ARIA properties which should be\\n+   * checked in this document:\\n+   * either eUnknownPropType, eCheckNamespaced, eCheckHyphenated or eCheckAny\\n+   */\\n+  readonly attribute unsigned long ariaPropTypes;\\n+  \\n+  /**\\n+   * Check attributes in the form of:\\n+   * [someprefix]:[propname]  (e.g. aria:live) where ancestor defines: \\n+   * xmlns:[someprefix]=\\\"http://www.w3.org/2005/07/aaa\\\"\\n+   */\\n+  const unsigned long eCheckNamespaced = 1;\\n+  \\n+  /**\\n+   * Check hyphenated attributes in the form of aria-[propname].\\n+   * This is the default in text/html documents.\\n+   * Can be combined with eCheckNamespaced flag. This may\\n+   * change during the life of the document, if setAttributeNS()\\n+   * is used to set an ARIA property.\\n+   */\\n+  const unsigned long eCheckHyphenated = 2;\\n };\\ndiff --git a/accessible/src/base/nsARIAMap.cpp b/accessible/src/base/nsARIAMap.cpp\\nindex 66d93071..1493690 100644\\n--- a/accessible/src/base/nsARIAMap.cpp\\n+++ b/accessible/src/base/nsARIAMap.cpp\\n@@ -41,15 +41,26 @@\\n #include \\\"nsIAccessibleRole.h\\\"\\n #include \\\"nsIAccessibleStates.h\\\"\\n \\n+#define ARIA_PROPERTY(atom) &nsAccessibilityAtoms::##atom,\\n+nsIAtom** nsARIAMap::gAriaAtomPtrsNS[eAria_none] = {\\n+#include \\\"nsAriaPropertyList.h\\\"\\n+};\\n+#undef ARIA_PROPERTY\\n+\\n+#define ARIA_PROPERTY(atom) &nsAccessibilityAtoms::aria_##atom,\\n+nsIAtom** nsARIAMap::gAriaAtomPtrsHyphenated[eAria_none] = {\\n+#include \\\"nsAriaPropertyList.h\\\"\\n+};\\n+#undef ARIA_PROPERTY\\n+\\n /**\\n  *  This list of WAI-defined roles are currently hardcoded.\\n  *  Eventually we will most likely be loading an RDF resource that contains this information\\n  *  Using RDF will also allow for role extensibility. See bug 280138.\\n  *\\n- *  XXX Should we store attribute names in this table as atoms instead of strings?\\n  *  Definition of nsRoleMapEntry and nsStateMapEntry contains comments explaining this table.\\n  *\\n- *  When no nsIAccessibleRole neum mapping exists for an ARIA role, the\\n+ *  When no nsIAccessibleRole enum mapping exists for an ARIA role, the\\n  *  role will be exposed via the object attribute \\\"xml-roles\\\".\\n  *  In addition, in MSAA, the unmapped role will also be exposed as a BSTR string role.\\n  *\\n@@ -57,7 +68,7 @@\\n  *    banner, contentinfo, main, navigation, note, search, secondary, seealso, breadcrumbs\\n  */ \\n \\n-static const nsStateMapEntry kEndEntry = {0, 0, 0};  // To fill in array of state mappings\\n+static const nsStateMapEntry kEndEntry = {eAria_none, 0, 0};  // To fill in array of state mappings\\n \\n nsRoleMapEntry nsARIAMap::gWAIRoleMap[] = \\n {\\n@@ -65,141 +76,141 @@ nsRoleMapEntry nsARIAMap::gWAIRoleMap[] =\\n   {\\\"alertdialog\\\", nsIAccessibleRole::ROLE_ALERT, eNameOkFromChildren, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"application\\\", nsIAccessibleRole::ROLE_APPLICATION, eNameLabelOrTitle, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"button\\\", nsIAccessibleRole::ROLE_PUSHBUTTON, eNameOkFromChildren, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"pressed\\\", kBoolState, nsIAccessibleStates::STATE_PRESSED},\\n-            {\\\"pressed\\\", \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_pressed, kBoolState, nsIAccessibleStates::STATE_PRESSED},\\n+            {eAria_pressed, \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED}, kEndEntry},\\n   {\\\"checkbox\\\", nsIAccessibleRole::ROLE_CHECKBUTTON, eNameOkFromChildren, eNoValue, nsIAccessibleStates::STATE_CHECKABLE,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED},\\n-            {\\\"checked\\\", \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED},\\n-            {\\\"readonly\\\", kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_checked, kBoolState, nsIAccessibleStates::STATE_CHECKED},\\n+            {eAria_checked, \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED},\\n+            {eAria_readonly, kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n   {\\\"columnheader\\\", nsIAccessibleRole::ROLE_COLUMNHEADER, eNameOkFromChildren, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"selected\\\", kBoolState, nsIAccessibleStates::STATE_SELECTED | nsIAccessibleStates::STATE_SELECTABLE},\\n-            {\\\"selected\\\", \\\"false\\\", nsIAccessibleStates::STATE_SELECTABLE},\\n-            {\\\"readonly\\\", kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_selected, kBoolState, nsIAccessibleStates::STATE_SELECTED | nsIAccessibleStates::STATE_SELECTABLE},\\n+            {eAria_selected, \\\"false\\\", nsIAccessibleStates::STATE_SELECTABLE},\\n+            {eAria_readonly, kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n   {\\\"combobox\\\", nsIAccessibleRole::ROLE_COMBOBOX, eNameLabelOrTitle, eHasValueMinMax,\\n                nsIAccessibleStates::STATE_COLLAPSED | nsIAccessibleStates::STATE_HASPOPUP,\\n             // Manually map EXT_STATE_SUPPORTS_AUTOCOMPLETION aaa:autocomplete\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"readonly\\\", kBoolState, nsIAccessibleStates::STATE_READONLY},\\n-            {\\\"expanded\\\", kBoolState, nsIAccessibleStates::STATE_EXPANDED}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_readonly, kBoolState, nsIAccessibleStates::STATE_READONLY},\\n+            {eAria_expanded, kBoolState, nsIAccessibleStates::STATE_EXPANDED}, kEndEntry},\\n   {\\\"description\\\", nsIAccessibleRole::ROLE_TEXT_CONTAINER, eNameOkFromChildren, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"dialog\\\", nsIAccessibleRole::ROLE_DIALOG, eNameLabelOrTitle, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"document\\\", nsIAccessibleRole::ROLE_DOCUMENT, eNameLabelOrTitle, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"grid\\\", nsIAccessibleRole::ROLE_TABLE, eNameLabelOrTitle, eNoValue, nsIAccessibleStates::STATE_FOCUSABLE,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"multiselectable\\\", kBoolState, nsIAccessibleStates::STATE_MULTISELECTABLE | nsIAccessibleStates::STATE_EXTSELECTABLE},\\n-            {\\\"readonly\\\", kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_multiselectable, kBoolState, nsIAccessibleStates::STATE_MULTISELECTABLE | nsIAccessibleStates::STATE_EXTSELECTABLE},\\n+            {eAria_readonly, kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n   {\\\"gridcell\\\", nsIAccessibleRole::ROLE_CELL, eNameOkFromChildren, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"expanded\\\", kBoolState, nsIAccessibleStates::STATE_EXPANDED},\\n-            {\\\"expanded\\\", \\\"false\\\", nsIAccessibleStates::STATE_COLLAPSED},\\n-            {\\\"selected\\\", kBoolState, nsIAccessibleStates::STATE_SELECTED | nsIAccessibleStates::STATE_SELECTABLE},\\n-            {\\\"selected\\\", \\\"false\\\", nsIAccessibleStates::STATE_SELECTABLE},\\n-            {\\\"readonly\\\", kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_expanded, kBoolState, nsIAccessibleStates::STATE_EXPANDED},\\n+            {eAria_expanded, \\\"false\\\", nsIAccessibleStates::STATE_COLLAPSED},\\n+            {eAria_selected, kBoolState, nsIAccessibleStates::STATE_SELECTED | nsIAccessibleStates::STATE_SELECTABLE},\\n+            {eAria_selected, \\\"false\\\", nsIAccessibleStates::STATE_SELECTABLE},\\n+            {eAria_readonly, kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n   {\\\"group\\\", nsIAccessibleRole::ROLE_GROUPING, eNameLabelOrTitle, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"heading\\\", nsIAccessibleRole::ROLE_HEADING, eNameLabelOrTitle, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"img\\\", nsIAccessibleRole::ROLE_GRAPHIC, eNameLabelOrTitle, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"label\\\", nsIAccessibleRole::ROLE_LABEL, eNameOkFromChildren, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"link\\\", nsIAccessibleRole::ROLE_LINK, eNameOkFromChildren, eNoValue, nsIAccessibleStates::STATE_LINKED,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE}, kEndEntry},\\n   {\\\"list\\\", nsIAccessibleRole::ROLE_LIST, eNameLabelOrTitle, eNoValue, kNoReqStates,\\n-            {\\\"readonly\\\", kBoolState, nsIAccessibleStates::STATE_READONLY},\\n-            {\\\"multiselectable\\\", kBoolState, nsIAccessibleStates::STATE_MULTISELECTABLE | nsIAccessibleStates::STATE_EXTSELECTABLE}, kEndEntry},\\n+            {eAria_readonly, kBoolState, nsIAccessibleStates::STATE_READONLY},\\n+            {eAria_multiselectable, kBoolState, nsIAccessibleStates::STATE_MULTISELECTABLE | nsIAccessibleStates::STATE_EXTSELECTABLE}, kEndEntry},\\n   {\\\"listbox\\\", nsIAccessibleRole::ROLE_LIST, eNameLabelOrTitle, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"readonly\\\", kBoolState, nsIAccessibleStates::STATE_READONLY},\\n-            {\\\"multiselectable\\\", kBoolState, nsIAccessibleStates::STATE_MULTISELECTABLE | nsIAccessibleStates::STATE_EXTSELECTABLE}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_readonly, kBoolState, nsIAccessibleStates::STATE_READONLY},\\n+            {eAria_multiselectable, kBoolState, nsIAccessibleStates::STATE_MULTISELECTABLE | nsIAccessibleStates::STATE_EXTSELECTABLE}, kEndEntry},\\n   {\\\"listitem\\\", nsIAccessibleRole::ROLE_LISTITEM, eNameOkFromChildren, eNoValue, kNoReqStates,\\n-            {\\\"selected\\\", kBoolState, nsIAccessibleStates::STATE_SELECTED | nsIAccessibleStates::STATE_SELECTABLE},\\n-            {\\\"selected\\\", \\\"false\\\", nsIAccessibleStates::STATE_SELECTABLE},\\n-            {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED | nsIAccessibleStates::STATE_CHECKABLE},\\n-            {\\\"checked\\\", \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED | nsIAccessibleStates::STATE_CHECKABLE},\\n-            {\\\"checked\\\", \\\"false\\\", nsIAccessibleStates::STATE_CHECKABLE}, kEndEntry},\\n+            {eAria_selected, kBoolState, nsIAccessibleStates::STATE_SELECTED | nsIAccessibleStates::STATE_SELECTABLE},\\n+            {eAria_selected, \\\"false\\\", nsIAccessibleStates::STATE_SELECTABLE},\\n+            {eAria_checked, kBoolState, nsIAccessibleStates::STATE_CHECKED | nsIAccessibleStates::STATE_CHECKABLE},\\n+            {eAria_checked, \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED | nsIAccessibleStates::STATE_CHECKABLE},\\n+            {eAria_checked, \\\"false\\\", nsIAccessibleStates::STATE_CHECKABLE}, kEndEntry},\\n   {\\\"menu\\\", nsIAccessibleRole::ROLE_MENUPOPUP, eNameLabelOrTitle, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE}, kEndEntry},\\n   {\\\"menubar\\\", nsIAccessibleRole::ROLE_MENUBAR, eNameLabelOrTitle, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE}, kEndEntry},\\n   {\\\"menuitem\\\", nsIAccessibleRole::ROLE_MENUITEM, eNameOkFromChildren, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED | nsIAccessibleStates::STATE_CHECKABLE},\\n-            {\\\"checked\\\", \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED | nsIAccessibleStates::STATE_CHECKABLE},\\n-            {\\\"checked\\\", \\\"false\\\", nsIAccessibleStates::STATE_CHECKABLE}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_checked, kBoolState, nsIAccessibleStates::STATE_CHECKED | nsIAccessibleStates::STATE_CHECKABLE},\\n+            {eAria_checked, \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED | nsIAccessibleStates::STATE_CHECKABLE},\\n+            {eAria_checked, \\\"false\\\", nsIAccessibleStates::STATE_CHECKABLE}, kEndEntry},\\n   {\\\"menuitemcheckbox\\\", nsIAccessibleRole::ROLE_CHECK_MENU_ITEM, eNameOkFromChildren, eNoValue, nsIAccessibleStates::STATE_CHECKABLE,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED },\\n-            {\\\"checked\\\", \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_checked, kBoolState, nsIAccessibleStates::STATE_CHECKED },\\n+            {eAria_checked, \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED}, kEndEntry},\\n   {\\\"menuitemradio\\\", nsIAccessibleRole::ROLE_RADIO_MENU_ITEM, eNameOkFromChildren, eNoValue, nsIAccessibleStates::STATE_CHECKABLE,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED }, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_checked, kBoolState, nsIAccessibleStates::STATE_CHECKED }, kEndEntry},\\n   {\\\"option\\\", nsIAccessibleRole::ROLE_LISTITEM, eNameOkFromChildren, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"selected\\\", kBoolState, nsIAccessibleStates::STATE_SELECTED | nsIAccessibleStates::STATE_SELECTABLE},\\n-            {\\\"selected\\\", \\\"false\\\", nsIAccessibleStates::STATE_SELECTABLE},\\n-            {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED | nsIAccessibleStates::STATE_CHECKABLE},\\n-            {\\\"checked\\\", \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED | nsIAccessibleStates::STATE_CHECKABLE},\\n-            {\\\"checked\\\", \\\"false\\\", nsIAccessibleStates::STATE_CHECKABLE}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_selected, kBoolState, nsIAccessibleStates::STATE_SELECTED | nsIAccessibleStates::STATE_SELECTABLE},\\n+            {eAria_selected, \\\"false\\\", nsIAccessibleStates::STATE_SELECTABLE},\\n+            {eAria_checked, kBoolState, nsIAccessibleStates::STATE_CHECKED | nsIAccessibleStates::STATE_CHECKABLE},\\n+            {eAria_checked, \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED | nsIAccessibleStates::STATE_CHECKABLE},\\n+            {eAria_checked, \\\"false\\\", nsIAccessibleStates::STATE_CHECKABLE}, kEndEntry},\\n   {\\\"progressbar\\\", nsIAccessibleRole::ROLE_PROGRESSBAR, eNameLabelOrTitle, eHasValueMinMax, nsIAccessibleStates::STATE_READONLY,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE}, kEndEntry},\\n   {\\\"radio\\\", nsIAccessibleRole::ROLE_RADIOBUTTON, eNameOkFromChildren, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_checked, kBoolState, nsIAccessibleStates::STATE_CHECKED}, kEndEntry},\\n   {\\\"radiogroup\\\", nsIAccessibleRole::ROLE_GROUPING, eNameLabelOrTitle, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE}, kEndEntry},\\n   {\\\"region\\\", nsIAccessibleRole::ROLE_PANE, eNameLabelOrTitle, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"row\\\", nsIAccessibleRole::ROLE_ROW, eNameOkFromChildren, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"selected\\\", kBoolState, nsIAccessibleStates::STATE_SELECTED | nsIAccessibleStates::STATE_SELECTABLE},\\n-            {\\\"selected\\\", \\\"false\\\", nsIAccessibleStates::STATE_SELECTABLE},\\n-            {\\\"expanded\\\", kBoolState, nsIAccessibleStates::STATE_EXPANDED},\\n-            {\\\"expanded\\\", \\\"false\\\", nsIAccessibleStates::STATE_COLLAPSED}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_selected, kBoolState, nsIAccessibleStates::STATE_SELECTED | nsIAccessibleStates::STATE_SELECTABLE},\\n+            {eAria_selected, \\\"false\\\", nsIAccessibleStates::STATE_SELECTABLE},\\n+            {eAria_expanded, kBoolState, nsIAccessibleStates::STATE_EXPANDED},\\n+            {eAria_expanded, \\\"false\\\", nsIAccessibleStates::STATE_COLLAPSED}, kEndEntry},\\n   {\\\"rowheader\\\", nsIAccessibleRole::ROLE_ROWHEADER, eNameOkFromChildren, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"selected\\\", kBoolState, nsIAccessibleStates::STATE_SELECTED | nsIAccessibleStates::STATE_SELECTABLE},\\n-            {\\\"selected\\\", \\\"false\\\", nsIAccessibleStates::STATE_SELECTABLE},\\n-            {\\\"readonly\\\", kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_selected, kBoolState, nsIAccessibleStates::STATE_SELECTED | nsIAccessibleStates::STATE_SELECTABLE},\\n+            {eAria_selected, \\\"false\\\", nsIAccessibleStates::STATE_SELECTABLE},\\n+            {eAria_readonly, kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n   {\\\"section\\\", nsIAccessibleRole::ROLE_SECTION, eNameLabelOrTitle, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"separator\\\", nsIAccessibleRole::ROLE_SEPARATOR, eNameLabelOrTitle, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"slider\\\", nsIAccessibleRole::ROLE_SLIDER, eNameLabelOrTitle, eHasValueMinMax, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"readonly\\\", kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_readonly, kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n   {\\\"spinbutton\\\", nsIAccessibleRole::ROLE_SPINBUTTON, eNameLabelOrTitle, eHasValueMinMax, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"readonly\\\", kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_readonly, kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n   {\\\"status\\\", nsIAccessibleRole::ROLE_STATUSBAR, eNameLabelOrTitle, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"tab\\\", nsIAccessibleRole::ROLE_PAGETAB, eNameOkFromChildren, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE}, kEndEntry},\\n   {\\\"tablist\\\", nsIAccessibleRole::ROLE_PAGETABLIST, eNameLabelOrTitle, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"tabpanel\\\", nsIAccessibleRole::ROLE_PROPERTYPAGE, eNameLabelOrTitle, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"textbox\\\", nsIAccessibleRole::ROLE_ENTRY, eNameLabelOrTitle, eNoValue, kNoReqStates,\\n             // Manually map EXT_STATE_SINGLE_LINE and EXT_STATE_MULTI_LINE FROM aaa:multiline\\n             // Manually map EXT_STATE_SUPPORTS_AUTOCOMPLETION aaa:autocomplete\\n-            {\\\"autocomplete\\\", \\\"list\\\", nsIAccessibleStates::STATE_HASPOPUP},\\n-            {\\\"autocomplete\\\", \\\"both\\\", nsIAccessibleStates::STATE_HASPOPUP},\\n-            {\\\"secret\\\", kBoolState, nsIAccessibleStates::STATE_PROTECTED},\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"readonly\\\", kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n+            {eAria_autocomplete, \\\"list\\\", nsIAccessibleStates::STATE_HASPOPUP},\\n+            {eAria_autocomplete, \\\"both\\\", nsIAccessibleStates::STATE_HASPOPUP},\\n+            {eAria_secret, kBoolState, nsIAccessibleStates::STATE_PROTECTED},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_readonly, kBoolState, nsIAccessibleStates::STATE_READONLY}, kEndEntry},\\n   {\\\"toolbar\\\", nsIAccessibleRole::ROLE_TOOLBAR, eNameLabelOrTitle, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE}, kEndEntry},\\n   {\\\"tooltip\\\", nsIAccessibleRole::ROLE_TOOLTIP, eNameOkFromChildren, eNoValue, kNoReqStates, kEndEntry},\\n   {\\\"tree\\\", nsIAccessibleRole::ROLE_OUTLINE, eNameLabelOrTitle, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"readonly\\\", kBoolState, nsIAccessibleStates::STATE_READONLY},\\n-            {\\\"multiselectable\\\", kBoolState, nsIAccessibleStates::STATE_MULTISELECTABLE | nsIAccessibleStates::STATE_EXTSELECTABLE}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_readonly, kBoolState, nsIAccessibleStates::STATE_READONLY},\\n+            {eAria_multiselectable, kBoolState, nsIAccessibleStates::STATE_MULTISELECTABLE | nsIAccessibleStates::STATE_EXTSELECTABLE}, kEndEntry},\\n   {\\\"treegrid\\\", nsIAccessibleRole::ROLE_TREE_TABLE, eNameLabelOrTitle, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"readonly\\\", kBoolState, nsIAccessibleStates::STATE_READONLY},\\n-            {\\\"multiselectable\\\", kBoolState, nsIAccessibleStates::STATE_MULTISELECTABLE | nsIAccessibleStates::STATE_EXTSELECTABLE}, kEndEntry},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_readonly, kBoolState, nsIAccessibleStates::STATE_READONLY},\\n+            {eAria_multiselectable, kBoolState, nsIAccessibleStates::STATE_MULTISELECTABLE | nsIAccessibleStates::STATE_EXTSELECTABLE}, kEndEntry},\\n   {\\\"treeitem\\\", nsIAccessibleRole::ROLE_OUTLINEITEM, eNameOkFromChildren, eNoValue, kNoReqStates,\\n-            {\\\"disabled\\\", kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n-            {\\\"selected\\\", kBoolState, nsIAccessibleStates::STATE_SELECTED | nsIAccessibleStates::STATE_SELECTABLE},\\n-            {\\\"selected\\\", \\\"false\\\", nsIAccessibleStates::STATE_SELECTABLE},\\n-            {\\\"expanded\\\", kBoolState, nsIAccessibleStates::STATE_EXPANDED},\\n-            {\\\"expanded\\\", \\\"false\\\", nsIAccessibleStates::STATE_COLLAPSED},\\n-            {\\\"checked\\\", kBoolState, nsIAccessibleStates::STATE_CHECKED | nsIAccessibleStates::STATE_CHECKABLE},\\n-            {\\\"checked\\\", \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED | nsIAccessibleStates::STATE_CHECKABLE},\\n-            {\\\"checked\\\", \\\"false\\\", nsIAccessibleStates::STATE_CHECKABLE},},\\n+            {eAria_disabled, kBoolState, nsIAccessibleStates::STATE_UNAVAILABLE},\\n+            {eAria_selected, kBoolState, nsIAccessibleStates::STATE_SELECTED | nsIAccessibleStates::STATE_SELECTABLE},\\n+            {eAria_selected, \\\"false\\\", nsIAccessibleStates::STATE_SELECTABLE},\\n+            {eAria_expanded, kBoolState, nsIAccessibleStates::STATE_EXPANDED},\\n+            {eAria_expanded, \\\"false\\\", nsIAccessibleStates::STATE_COLLAPSED},\\n+            {eAria_checked, kBoolState, nsIAccessibleStates::STATE_CHECKED | nsIAccessibleStates::STATE_CHECKABLE},\\n+            {eAria_checked, \\\"mixed\\\", nsIAccessibleStates::STATE_MIXED | nsIAccessibleStates::STATE_CHECKABLE},\\n+            {eAria_checked, \\\"false\\\", nsIAccessibleStates::STATE_CHECKABLE},},\\n   {nsnull, nsIAccessibleRole::ROLE_NOTHING, eNameLabelOrTitle, eNoValue, kNoReqStates, kEndEntry} // Last item\\n };\\n \\n@@ -209,11 +220,11 @@ nsRoleMapEntry nsARIAMap::gWAIRoleMap[] =\\n  * whether there is an ARIA role or not:\\n  */\\n nsStateMapEntry nsARIAMap::gWAIUnivStateMap[] = {\\n-  {\\\"required\\\", kBoolState, nsIAccessibleStates::STATE_REQUIRED},\\n-  {\\\"invalid\\\",  kBoolState, nsIAccessibleStates::STATE_INVALID},\\n-  {\\\"haspopup\\\", kBoolState, nsIAccessibleStates::STATE_HASPOPUP},\\n-  {\\\"busy\\\",     \\\"true\\\",     nsIAccessibleStates::STATE_BUSY},\\n-  {\\\"busy\\\",     \\\"error\\\",    nsIAccessibleStates::STATE_INVALID},\\n+  {eAria_required, kBoolState, nsIAccessibleStates::STATE_REQUIRED},\\n+  {eAria_invalid,  kBoolState, nsIAccessibleStates::STATE_INVALID},\\n+  {eAria_haspopup, kBoolState, nsIAccessibleStates::STATE_HASPOPUP},\\n+  {eAria_busy,     \\\"true\\\",     nsIAccessibleStates::STATE_BUSY},\\n+  {eAria_busy,     \\\"error\\\",    nsIAccessibleStates::STATE_INVALID},\\n   kEndEntry\\n };\\n \\ndiff --git a/accessible/src/base/nsARIAMap.h b/accessible/src/base/nsARIAMap.h\\nindex b03a222..ada0181 100644\\n--- a/accessible/src/base/nsARIAMap.h\\n+++ b/accessible/src/base/nsARIAMap.h\\n@@ -41,6 +41,13 @@\\n #define _nsARIAMap_H_\\n \\n #include \\\"prtypes.h\\\"\\n+#include \\\"nsAccessibilityAtoms.h\\\"\\n+\\n+#define ARIA_PROPERTY(atom) eAria_##atom,\\n+enum EAriaProperty {\\n+#include \\\"nsAriaPropertyList.h\\\"\\n+  eAria_none };\\n+#undef ARIA_PROPERTY\\n \\n // Name mapping rule: can the name be computed from descendants?\\n enum ENameRule\\n@@ -79,7 +86,7 @@ enum EValueRule\\n // nsStateMapEntry.state\\n struct nsStateMapEntry\\n {\\n-  const char* attributeName;  // magic value of nsnull means last entry in map\\n+  EAriaProperty attributeName;  // eARIA_none indicates last entry in map\\n   const char* attributeValue; // magic value of kBoolState (0) means supports \\\"true\\\" and \\\"false\\\"\\n   PRUint32 state;             // If match, this is the nsIAccessibleStates to map to\\n };\\n@@ -124,6 +131,8 @@ struct nsRoleMapEntry\\n  */\\n struct nsARIAMap\\n {\\n+  static nsIAtom** gAriaAtomPtrsNS[eAria_none];\\n+  static nsIAtom** gAriaAtomPtrsHyphenated[eAria_none];\\n   static nsRoleMapEntry gWAIRoleMap[];\\n   static nsStateMapEntry gWAIUnivStateMap[];\\n };\\ndiff --git a/accessible/src/base/nsARIAPropertyList.h b/accessible/src/base/nsARIAPropertyList.h\\nnew file mode 100644\\nindex 0000000..e5391f1\\n--- /dev/null\\n+++ b/accessible/src/base/nsARIAPropertyList.h\\n@@ -0,0 +1,74 @@\\n+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n+/* vim:expandtab:shiftwidth=2:tabstop=2:\\n+ */\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is mozilla.org code.\\n+ *\\n+ * The Initial Developer of the Original Code is IBM Corporation\\n+ * Portions created by the Initial Developer are Copyright (C)2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *   Aaron Leventhal <aleventh@us.ibm.com>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+\\n+  // ARIA properties\\n+ARIA_PROPERTY(activedescendant)\\n+ARIA_PROPERTY(atomic)\\n+ARIA_PROPERTY(autocomplete)\\n+ARIA_PROPERTY(busy)\\n+ARIA_PROPERTY(channel)\\n+ARIA_PROPERTY(checked)\\n+ARIA_PROPERTY(controls)\\n+ARIA_PROPERTY(datatype)\\n+ARIA_PROPERTY(describedby)\\n+ARIA_PROPERTY(disabled)\\n+ARIA_PROPERTY(dropeffect)\\n+ARIA_PROPERTY(expanded)\\n+ARIA_PROPERTY(flowto)\\n+ARIA_PROPERTY(grab)\\n+ARIA_PROPERTY(haspopup)\\n+ARIA_PROPERTY(invalid)\\n+ARIA_PROPERTY(labelledby)\\n+ARIA_PROPERTY(level)\\n+ARIA_PROPERTY(live)\\n+ARIA_PROPERTY(multiline)\\n+ARIA_PROPERTY(multiselectable)\\n+ARIA_PROPERTY(owns)\\n+ARIA_PROPERTY(posinset)\\n+ARIA_PROPERTY(pressed)\\n+ARIA_PROPERTY(readonly)\\n+ARIA_PROPERTY(relevant)\\n+ARIA_PROPERTY(required)\\n+ARIA_PROPERTY(secret)\\n+ARIA_PROPERTY(selected)\\n+ARIA_PROPERTY(setsize)\\n+ARIA_PROPERTY(sort)\\n+ARIA_PROPERTY(valuenow)\\n+ARIA_PROPERTY(valuemin)\\n+ARIA_PROPERTY(valuemax)\\ndiff --git a/accessible/src/base/nsAccessibilityAtomList.h b/accessible/src/base/nsAccessibilityAtomList.h\\nindex aa4f8e4..48f0d37 100755\\n--- a/accessible/src/base/nsAccessibilityAtomList.h\\n+++ b/accessible/src/base/nsAccessibilityAtomList.h\\n@@ -140,25 +140,16 @@ ACCESSIBILITY_ATOM(tooltip, \\\"tooltip\\\")   // XUL\\n ACCESSIBILITY_ATOM(tr, \\\"tr\\\")\\n ACCESSIBILITY_ATOM(ul, \\\"ul\\\")\\n \\n-  // DHTML accessibility relationship attributes\\n-ACCESSIBILITY_ATOM(controls, \\\"controls\\\")\\n-ACCESSIBILITY_ATOM(describedby, \\\"describedby\\\")\\n-ACCESSIBILITY_ATOM(flowto, \\\"flowto\\\")\\n-ACCESSIBILITY_ATOM(labelledby, \\\"labelledby\\\")\\n-ACCESSIBILITY_ATOM(owns, \\\"owns\\\")\\n-\\n   // Alphabetical list of attributes\\n ACCESSIBILITY_ATOM(acceltext, \\\"acceltext\\\")\\n ACCESSIBILITY_ATOM(accesskey, \\\"accesskey\\\")\\n ACCESSIBILITY_ATOM(alt, \\\"alt\\\")\\n ACCESSIBILITY_ATOM(anonid, \\\"anonid\\\") // Used for ID's in XBL\\n-ACCESSIBILITY_ATOM(autocomplete, \\\"autocomplete\\\") // Used as attribute value too\\n ACCESSIBILITY_ATOM(contenteditable, \\\"contenteditable\\\")\\n ACCESSIBILITY_ATOM(control, \\\"control\\\")\\n ACCESSIBILITY_ATOM(cycles, \\\"cycles\\\") // used for XUL cycler attribute\\n ACCESSIBILITY_ATOM(curpos, \\\"curpos\\\") // XUL\\n ACCESSIBILITY_ATOM(data, \\\"data\\\")\\n-ACCESSIBILITY_ATOM(disabled, \\\"disabled\\\")\\n ACCESSIBILITY_ATOM(droppable, \\\"droppable\\\")   // XUL combo box\\n ACCESSIBILITY_ATOM(editable, \\\"editable\\\")\\n ACCESSIBILITY_ATOM(_for, \\\"for\\\")\\n@@ -168,10 +159,8 @@ ACCESSIBILITY_ATOM(increment, \\\"increment\\\") // XUL\\n ACCESSIBILITY_ATOM(lang, \\\"lang\\\")\\n ACCESSIBILITY_ATOM(maxpos, \\\"maxpos\\\") // XUL\\n ACCESSIBILITY_ATOM(minpos, \\\"minpos\\\") // XUL\\n-ACCESSIBILITY_ATOM(multiline, \\\"multiline\\\")\\n ACCESSIBILITY_ATOM(name, \\\"name\\\")\\n ACCESSIBILITY_ATOM(onclick, \\\"onclick\\\")\\n-ACCESSIBILITY_ATOM(readonly, \\\"readonly\\\")\\n ACCESSIBILITY_ATOM(src, \\\"src\\\")\\n ACCESSIBILITY_ATOM(summary, \\\"summary\\\")\\n ACCESSIBILITY_ATOM(tabindex, \\\"tabindex\\\")\\n@@ -181,31 +170,18 @@ ACCESSIBILITY_ATOM(type, \\\"type\\\")\\n ACCESSIBILITY_ATOM(value, \\\"value\\\")\\n \\n   // ARIA (DHTML accessibility) attributes\\n-ACCESSIBILITY_ATOM(atomic, \\\"atomic\\\")\\n-ACCESSIBILITY_ATOM(busy, \\\"busy\\\")\\n-ACCESSIBILITY_ATOM(channel, \\\"channel\\\")\\n-ACCESSIBILITY_ATOM(activedescendant, \\\"activedescendant\\\")\\n-ACCESSIBILITY_ATOM(checked, \\\"checked\\\")\\n-ACCESSIBILITY_ATOM(datatype, \\\"datatype\\\")\\n-ACCESSIBILITY_ATOM(dropeffect, \\\"dropeffect\\\")\\n-ACCESSIBILITY_ATOM(expanded, \\\"expanded\\\")\\n-ACCESSIBILITY_ATOM(grab, \\\"grab\\\")\\n-ACCESSIBILITY_ATOM(haspopup, \\\"haspopup\\\")\\n-ACCESSIBILITY_ATOM(invalid, \\\"invalid\\\")\\n-ACCESSIBILITY_ATOM(level, \\\"level\\\")\\n-ACCESSIBILITY_ATOM(live, \\\"live\\\")\\n-ACCESSIBILITY_ATOM(multiselectable, \\\"multiselectable\\\")\\n-ACCESSIBILITY_ATOM(posinset, \\\"posinset\\\")\\n-ACCESSIBILITY_ATOM(pressed, \\\"pressed\\\")\\n-ACCESSIBILITY_ATOM(relevant, \\\"relevant\\\")\\n-ACCESSIBILITY_ATOM(required, \\\"required\\\")\\n+  // Also add to nsARIAMap.cpp and nsARIAMap.h\\n+  // ARIA role attribute\\n ACCESSIBILITY_ATOM(role, \\\"role\\\")\\n-ACCESSIBILITY_ATOM(secret, \\\"secret\\\")\\n-ACCESSIBILITY_ATOM(selected, \\\"selected\\\")\\n-ACCESSIBILITY_ATOM(setsize, \\\"setsize\\\")\\n-ACCESSIBILITY_ATOM(valuenow, \\\"valuenow\\\")    // For DHTML widget values\\n-ACCESSIBILITY_ATOM(valuemin, \\\"valuemin\\\")\\n-ACCESSIBILITY_ATOM(valuemax, \\\"valuemax\\\")\\n+\\n+  // ARIA properties\\n+#define ARIA_PROPERTY(atom) ACCESSIBILITY_ATOM(atom, #atom)\\n+#include \\\"nsAriaPropertyList.h\\\"\\n+#undef ARIA_PROPERTY\\n+\\n+#define ARIA_PROPERTY(atom) ACCESSIBILITY_ATOM(aria_##atom, \\\"aria-\\\"#atom)\\n+#include \\\"nsAriaPropertyList.h\\\"\\n+#undef ARIA_PROPERTY\\n \\n   // misc atoms\\n // a form property used to obtain the default label\\ndiff --git a/accessible/src/base/nsAccessibilityService.cpp b/accessible/src/base/nsAccessibilityService.cpp\\nindex 63331bc..be0ca1d 100644\\n--- a/accessible/src/base/nsAccessibilityService.cpp\\n+++ b/accessible/src/base/nsAccessibilityService.cpp\\n@@ -1431,22 +1431,7 @@ NS_IMETHODIMP nsAccessibilityService::GetAccessible(nsIDOMNode *aNode,\\n   if (!newAcc && content->Tag() != nsAccessibilityAtoms::body && content->GetParent() && \\n       (content->IsFocusable() ||\\n       (isHTML && nsAccUtils::HasListener(content, NS_LITERAL_STRING(\\\"click\\\"))) ||\\n-       content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::describedby) ||\\n-       content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::labelledby) ||\\n-       content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::flowto) ||\\n-       content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::controls) ||\\n-       content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::atomic) ||\\n-       content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::busy) ||\\n-       content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::channel) ||\\n-       content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::datatype) ||\\n-       content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::dropeffect) ||\\n-       content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::grab) ||\\n-       content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::haspopup) ||\\n-       content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::live) ||\\n-       content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::relevant) ||\\n-       content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::required) ||\\n-       content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::invalid) ||\\n-       !role.IsEmpty())) {\\n+       HasUniversalAriaProperty(content, aWeakShell) || !role.IsEmpty())) {\\n     // This content is focusable or has an interesting dynamic content accessibility property.\\n     // If it's interesting we need it in the accessibility hierarchy so that events or\\n     // other accessibles can point to it, or so that it can hold a state, etc.\\n@@ -1463,6 +1448,39 @@ NS_IMETHODIMP nsAccessibilityService::GetAccessible(nsIDOMNode *aNode,\\n   return InitAccessible(newAcc, aAccessible);\\n }\\n \\n+PRBool\\n+nsAccessibilityService::HasUniversalAriaProperty(nsIContent *aContent,\\n+                                                 nsIWeakReference *aWeakShell)\\n+{\\n+  nsCOMPtr<nsIAccessibleDocument> docAccessible =\\n+    nsAccessNode::GetDocAccessibleFor(aWeakShell);\\n+  if (!docAccessible) {\\n+    return PR_FALSE;\\n+  }\\n+\\n+  // Precalculate |ariaPropTypes| so that HasAriaProperty() doesn't have to do that each time\\n+  PRUint32 ariaPropTypes;\\n+  docAccessible->GetAriaPropTypes(&ariaPropTypes);\\n+\\n+  return nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_atomic, ariaPropTypes) ||\\n+         nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_busy, ariaPropTypes) ||\\n+         nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_channel, ariaPropTypes) ||\\n+         nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_controls, ariaPropTypes) ||\\n+         nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_datatype, ariaPropTypes) ||\\n+         nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_describedby, ariaPropTypes) ||\\n+         nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_dropeffect, ariaPropTypes) ||\\n+         nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_flowto, ariaPropTypes) ||\\n+         nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_grab, ariaPropTypes) ||\\n+         nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_haspopup, ariaPropTypes) ||\\n+         nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_invalid, ariaPropTypes) ||\\n+         nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_labelledby, ariaPropTypes) ||\\n+         nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_live, ariaPropTypes) ||\\n+         nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_owns, ariaPropTypes) ||\\n+         nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_relevant, ariaPropTypes) ||\\n+         nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_required, ariaPropTypes) ||\\n+         nsAccUtils::HasAriaProperty(aContent, aWeakShell, eAria_sort, ariaPropTypes);\\n+}\\n+\\n NS_IMETHODIMP\\n nsAccessibilityService::GetRelevantContentNodeFor(nsIDOMNode *aNode,\\n                                                   nsIDOMNode **aRelevantNode)\\ndiff --git a/accessible/src/base/nsAccessibilityService.h b/accessible/src/base/nsAccessibilityService.h\\nindex 341266c..42704ef 100644\\n--- a/accessible/src/base/nsAccessibilityService.h\\n+++ b/accessible/src/base/nsAccessibilityService.h\\n@@ -119,6 +119,16 @@ private:\\n                                         nsIAccessible **aAccessible);\\n \\n   static nsAccessibilityService *gAccessibilityService;\\n+\\n+  /**\\n+   * Does this content node have a universal ARIA property set on it?\\n+   * A universal ARIA property is one that can be defined on any element even if there is no role.\\n+   *\\n+   * @param aContent The content node to test\\n+   * @param aWeakShell  A weak reference to the pres shell\\n+   * @return PR_TRUE if there is a universal ARIA property set on the node\\n+   */\\n+  PRBool HasUniversalAriaProperty(nsIContent *aContent, nsIWeakReference *aWeakShell);\\n };\\n \\n /**\\ndiff --git a/accessible/src/base/nsAccessibilityUtils.cpp b/accessible/src/base/nsAccessibilityUtils.cpp\\nindex 328ca96..1ea8875 100755\\n--- a/accessible/src/base/nsAccessibilityUtils.cpp\\n+++ b/accessible/src/base/nsAccessibilityUtils.cpp\\n@@ -42,10 +42,14 @@\\n #include \\\"nsPIAccessible.h\\\"\\n #include \\\"nsAccessibleEventData.h\\\"\\n \\n+#include \\\"nsAccessNode.h\\\"\\n+#include \\\"nsARIAMap.h\\\"\\n #include \\\"nsIDocument.h\\\"\\n #include \\\"nsIDOMAbstractView.h\\\"\\n #include \\\"nsIDOMDocument.h\\\"\\n #include \\\"nsIDOMDocumentView.h\\\"\\n+#include \\\"nsIDOMDocumentXBL.h\\\"\\n+#include \\\"nsIDOMNodeList.h\\\"\\n #include \\\"nsIDOMRange.h\\\"\\n #include \\\"nsIDOMXULSelectCntrlEl.h\\\"\\n #include \\\"nsIDOMXULSelectCntrlItemEl.h\\\"\\n@@ -410,3 +414,225 @@ nsAccUtils::GetID(nsIContent *aContent, nsAString& aID)\\n   nsIAtom *idAttribute = aContent->GetIDAttributeName();\\n   return idAttribute ? aContent->GetAttr(kNameSpaceID_None, idAttribute, aID) : PR_FALSE;\\n }\\n+\\n+PRUint32\\n+nsAccUtils::GetAriaPropTypes(nsIContent *aContent, nsIWeakReference *aWeakShell)\\n+{\\n+  NS_ENSURE_ARG_POINTER(aContent);\\n+\\n+  PRUint32 ariaPropTypes = 0;\\n+\\n+  // Get the doc accessible using the optimsal methodology\\n+  nsCOMPtr<nsIAccessibleDocument> docAccessible;\\n+  if (aWeakShell) {\\n+    docAccessible = nsAccessNode::GetDocAccessibleFor(aWeakShell);\\n+  }\\n+  else {\\n+      nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aContent);\\n+    if (node) {\\n+      docAccessible = nsAccessNode::GetDocAccessibleFor(node);\\n+    }\\n+  }\\n+  if (docAccessible) {\\n+    docAccessible->GetAriaPropTypes(&ariaPropTypes);\\n+  }\\n+  return ariaPropTypes;\\n+}\\n+\\n+PRBool\\n+nsAccUtils::HasAriaProperty(nsIContent *aContent, nsIWeakReference *aWeakShell,\\n+                            EAriaProperty aProperty, PRUint32 aAriaPropTypes)\\n+{\\n+  if (!aAriaPropTypes) {\\n+    // The property types to check for is unknown, get it from the doc accessible\\n+    aAriaPropTypes = GetAriaPropTypes(aContent, aWeakShell);\\n+  }\\n+\\n+  return ((aAriaPropTypes & nsIAccessibleDocument::eCheckNamespaced) &&\\n+          aContent->HasAttr(kNameSpaceID_WAIProperties,\\n+                            *nsARIAMap::gAriaAtomPtrsNS[aProperty])) ||\\n+         ((aAriaPropTypes & nsIAccessibleDocument::eCheckHyphenated) &&\\n+          aContent->HasAttr(kNameSpaceID_None,\\n+                            *nsARIAMap::gAriaAtomPtrsHyphenated[aProperty]));\\n+}\\n+\\n+PRBool\\n+nsAccUtils::GetAriaProperty(nsIContent *aContent, nsIWeakReference *aWeakShell,\\n+                            EAriaProperty aProperty, nsAString& aValue,\\n+                            PRUint32 aAriaPropTypes)\\n+{\\n+  aValue.Truncate();\\n+  if (!aAriaPropTypes) {\\n+    // The property types to check for is unknown, get it from the doc accessible\\n+    aAriaPropTypes = GetAriaPropTypes(aContent, aWeakShell);\\n+  }\\n+  return ((aAriaPropTypes & nsIAccessibleDocument::eCheckNamespaced) &&\\n+          aContent->GetAttr(kNameSpaceID_WAIProperties,\\n+                            *nsARIAMap::gAriaAtomPtrsNS[aProperty],\\n+                            aValue)) ||\\n+         ((aAriaPropTypes & nsIAccessibleDocument::eCheckHyphenated) &&\\n+          aContent->GetAttr(kNameSpaceID_None,\\n+                            *nsARIAMap::gAriaAtomPtrsHyphenated[aProperty],\\n+                            aValue));\\n+}\\n+\\n+nsIContent*\\n+nsAccUtils::FindNeighbourPointingToNode(nsIContent *aForNode, \\n+                                        EAriaProperty aAriaProperty, \\n+                                        nsIAtom *aTagName,\\n+                                        nsIAtom *aRelationAttr,\\n+                                        PRUint32 aAncestorLevelsToSearch)\\n+{\\n+  NS_ASSERTION(aAriaProperty == eAria_none || !aRelationAttr,\\n+               \\\"Cannot pass in both an ARIA relation property and an atom relation. Choose one\\\");\\n+  NS_ASSERTION(aAriaProperty != eAria_none || !aTagName,\\n+               \\\"Cannot use aTagName with ARIA relation property, because ARIA relations apply to any tag\\\");\\n+  nsCOMPtr<nsIContent> binding;\\n+  nsAutoString controlID;\\n+  if (!nsAccUtils::GetID(aForNode, controlID)) {\\n+    binding = aForNode->GetBindingParent();\\n+    if (binding == aForNode)\\n+      return nsnull;\\n+\\n+    aForNode->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::anonid, controlID);\\n+    if (controlID.IsEmpty())\\n+      return nsnull;\\n+  }\\n+\\n+  // Look for label in subtrees of nearby ancestors\\n+  PRUint32 count = 0;\\n+  nsIContent *labelContent = nsnull;\\n+  nsIContent *prevSearched = nsnull;\\n+\\n+  while (!labelContent && ++count <= aAncestorLevelsToSearch &&\\n+         (aForNode = aForNode->GetParent()) != nsnull) {\\n+\\n+    if (aForNode == binding) {\\n+      // When we reach the binding parent, make sure to check\\n+      // all of its anonymous child subtrees\\n+      nsCOMPtr<nsIDocument> doc = aForNode->GetCurrentDoc();\\n+      nsCOMPtr<nsIDOMDocumentXBL> xblDoc(do_QueryInterface(doc));\\n+      if (!xblDoc)\\n+        return nsnull;\\n+\\n+      nsCOMPtr<nsIDOMNodeList> nodes;\\n+      nsCOMPtr<nsIDOMElement> forElm(do_QueryInterface(aForNode));\\n+      xblDoc->GetAnonymousNodes(forElm, getter_AddRefs(nodes));\\n+      if (!nodes)\\n+        return nsnull;\\n+\\n+      PRUint32 length;\\n+      nsresult rv = nodes->GetLength(&length);\\n+      if (NS_FAILED(rv))\\n+        return nsnull;\\n+\\n+      for (PRUint32 index = 0; index < length && !labelContent; index++) {\\n+        nsCOMPtr<nsIDOMNode> node;\\n+        rv = nodes->Item(index, getter_AddRefs(node));\\n+        if (NS_FAILED(rv))\\n+          return nsnull;\\n+\\n+        nsCOMPtr<nsIContent> content = do_QueryInterface(node);\\n+        if (!content)\\n+          return nsnull;\\n+\\n+        if (content != prevSearched) {\\n+          labelContent = FindDescendantPointingToID(&controlID, content, aAriaProperty,\\n+                                                    aRelationAttr, nsnull, aTagName);\\n+        }\\n+      }\\n+      break;\\n+    }\\n+\\n+    labelContent = FindDescendantPointingToID(&controlID, aForNode, aAriaProperty,\\n+                                              aRelationAttr, prevSearched, aTagName);\\n+    prevSearched = aForNode;\\n+  }\\n+\\n+  return labelContent;\\n+}\\n+\\n+// Pass in aAriaProperty = null and aRelationAttr == nsnull if any <label> will do\\n+nsIContent*\\n+nsAccUtils::FindDescendantPointingToID(const nsString *aId,\\n+                                       nsIContent *aLookContent,\\n+                                       EAriaProperty aAriaProperty,\\n+                                       nsIAtom *aRelationAttr,\\n+                                       nsIContent *aExcludeContent,\\n+                                       nsIAtom *aTagType)\\n+{\\n+  // Surround id with spaces for search\\n+  nsCAutoString idWithSpaces(' ');\\n+  LossyAppendUTF16toASCII(*aId, idWithSpaces);\\n+  idWithSpaces += ' ';\\n+  PRUint32 ariaPropTypes = (aAriaProperty == eAria_none) ? 0 :\\n+                            nsAccUtils::GetAriaPropTypes(aLookContent);\\n+  return FindDescendantPointingToIDImpl(idWithSpaces, aLookContent,\\n+                                        aAriaProperty, ariaPropTypes,\\n+                                        aRelationAttr, aExcludeContent, aTagType);\\n+}\\n+\\n+nsIContent*\\n+nsAccUtils::FindDescendantPointingToIDImpl(nsCString& aIdWithSpaces,\\n+                                           nsIContent *aLookContent,\\n+                                           EAriaProperty aAriaProperty,\\n+                                           PRUint32 aAriaPropTypes,\\n+                                           nsIAtom *aRelationAttr,\\n+                                           nsIContent *aExcludeContent,\\n+                                           nsIAtom *aTagType)\\n+{\\n+  if (aAriaProperty != eAria_none) {  // Tag ignored for ARIA properties, which can apply to anything\\n+    nsAutoString idList;\\n+    if (nsAccUtils::GetAriaProperty(aLookContent, nsnull, aAriaProperty,\\n+                                    idList, aAriaPropTypes)) {\\n+      idList.Insert(' ', 0);  // Surround idlist with spaces for search\\n+      idList.Append(' ');\\n+      // idList is now a set of id's with spaces around each,\\n+      // and id also has spaces around it.\\n+      // If id is a substring of idList then we have a match\\n+      if (idList.Find(aIdWithSpaces) != -1) {\\n+        return aLookContent;\\n+      }\\n+    }\\n+  }\\n+  else if (!aTagType || aLookContent->Tag() == aTagType) {\\n+    // Tag matches\\n+    if (aRelationAttr) {\\n+      // Check for ID in the attribute aRelationAttr, which can be a list\\n+      nsAutoString idList;\\n+      if (aLookContent->GetAttr(kNameSpaceID_None, aRelationAttr, idList)) {\\n+        idList.Insert(' ', 0);  // Surround idlist with spaces for search\\n+        idList.Append(' ');\\n+        // idList is now a set of id's with spaces around each,\\n+        // and id also has spaces around it.\\n+        // If id is a substring of idList then we have a match\\n+        if (idList.Find(aIdWithSpaces) != -1) {\\n+          return aLookContent;\\n+        }\\n+      }\\n+    }\\n+    if (aTagType) {\\n+      // Don't bother to search descendants of an element with matching tag.\\n+      // That would be like looking for a nested <label> or <description>\\n+      return nsnull;\\n+    }\\n+  }\\n+\\n+  // Recursively search descendants for match\\n+  PRUint32 count  = 0;\\n+  nsIContent *child;\\n+  nsIContent *labelContent = nsnull;\\n+\\n+  while ((child = aLookContent->GetChildAt(count++)) != nsnull) {\\n+    if (child != aExcludeContent) {\\n+      labelContent = FindDescendantPointingToIDImpl(aIdWithSpaces, child,\\n+                                                    aAriaProperty, aAriaPropTypes,\\n+                                                    aRelationAttr, aExcludeContent, aTagType);\\n+      if (labelContent) {\\n+        return labelContent;\\n+      }\\n+    }\\n+  }\\n+  return nsnull;\\n+}\\n+\\ndiff --git a/accessible/src/base/nsAccessibilityUtils.h b/accessible/src/base/nsAccessibilityUtils.h\\nindex 718d843..fc6454c 100755\\n--- a/accessible/src/base/nsAccessibilityUtils.h\\n+++ b/accessible/src/base/nsAccessibilityUtils.h\\n@@ -41,6 +41,7 @@\\n \\n #include \\\"nsAccessibilityAtoms.h\\\"\\n #include \\\"nsIAccessible.h\\\"\\n+#include \\\"nsARIAMap.h\\\"\\n \\n #include \\\"nsIDOMNode.h\\\"\\n #include \\\"nsIPersistentProperties2.h\\\"\\n@@ -48,6 +49,7 @@\\n #include \\\"nsIFrame.h\\\"\\n #include \\\"nsIDocShellTreeItem.h\\\"\\n #include \\\"nsPoint.h\\\"\\n+#include \\\"nsIAccessibleDocument.h\\\"\\n \\n class nsAccUtils\\n {\\n@@ -188,6 +190,92 @@ public:\\n    * @return          PR_TRUE if there is an ID set for this node\\n    */\\n   static PRBool GetID(nsIContent *aContent, nsAString& aID);\\n+\\n+  /**\\n+   * Find out what kinds of properties are checked for this content node's document\\n+   * @param aContent     The content node we're going to look for ARIA properties on\\n+   * @param aWeakShell   The presshell for the document we're looking for ARIA properties on (optional optimization)\\n+   * @return             The types of properties checked\\n+   */\\n+  static PRUint32 GetAriaPropTypes(nsIContent *aContent, nsIWeakReference *aWeakShell = nsnull);\\n+\\n+  /**\\n+   *  Check for the relevant ARIA property. Can check either for a properly namespaced property,\\n+   *  or a fake hyphenated namespace using \\\"aria-\\\" as a prefix in HTML. Is optimized to only\\n+   *  check for each type when it is possible to exist on a given node.\\n+   *  @param aContent     Node to check for property on\\n+   *  @param aWeakShell   The current pres shell if known (as an optimization), or nsnull if not known by caller\\n+   *  @param aProperty    An enumeration indicating which ARIA property we are checking\\n+   *  @param aAriaPropTypes  A bitflag for the property types to check for (namespaced, hyphenated or both), if known by caller\\n+   *  @return             PR_TRUE if the property is defined\\n+   */\\n+  static PRBool HasAriaProperty(nsIContent *aContent, nsIWeakReference *aWeakShell,\\n+                                EAriaProperty aProperty,\\n+                                PRUint32 aCheckFlags = 0);\\n+\\n+  /**\\n+   *  Get the relevant ARIA property. Can check either for a properly namespaced property,\\n+   *  or a fake hyphenated namespace using \\\"aria-\\\" as a prefix in HTML. Is optimized to only\\n+   *  check for each type when it is possible to exist on a given node.\\n+   *  @param aContent     Node to check for property on\\n+   *  @param aWeakShell   The current pres shell if known (as an optimization), or nsnull if not known by caller\\n+   *  @param aProperty    An enumeration indicating which ARIA property we are checking\\n+   *  @param aValue       Where to store the property value\\n+   *  @param aAriaPropTypes  A bitflag for the property types to check for (namespaced, hyphenated or both), if known by caller\\n+   *  @return             PR_TRUE if the property is defined\\n+   */\\n+  static PRBool GetAriaProperty(nsIContent *aContent, nsIWeakReference *aWeakShell,\\n+                                EAriaProperty aProperty, nsAString& aValue, \\n+                                PRUint32 aCheckFlags = 0);\\n+\\n+  /**\\n+   * Search element in neighborhood of the given element by tag name and\\n+   * attribute value that equals to ID attribute of the given element.\\n+   * ID attribute can be either 'id' attribute or 'anonid' if the element is\\n+   * anonymous.\\n+   *\\n+   * @param aAriaProperty - the ARIA property to search for or eAria_none, if aRelationAttr is passed in\\n+   * @param aForNode - the given element the search is performed for\\n+   * @param aTagName - tag name of searched element, or nsnull for any -- ignored if aAriaProperty passed in\\n+   * @param aRelationAttr - attribute name of searched element, ignored if aAriaProperty passed in\\n+   * @param aAncestorLevelsToSearch - points how is the neighborhood of the\\n+   *                                  given element big.\\n+   */\\n+  static nsIContent *FindNeighbourPointingToNode(nsIContent *aForNode,\\n+                                                 EAriaProperty aAriaProperty,\\n+                                                 nsIAtom *aTagName = nsnull,\\n+                                                 nsIAtom *aRelationAttr = nsnull,\\n+                                                 PRUint32 aAncestorLevelsToSearch = 5);\\n+\\n+  /**\\n+   * Search for element that satisfies the requirements in subtree of the given\\n+   * element. The requirements are tag name, attribute name and value of\\n+   * attribute.\\n+   *\\n+   * @param aId - value of searched attribute\\n+   * @param aLookContent - element that search is performed inside\\n+   * @param aAriaProperty - the ARIA property to search for or eAria_none, if aRelationAttr is passed in\\n+   * @param aRelationAttr - searched attribute-- ignored if aAriaProperty passed in\\n+   * @param                 if both aAriaProperty and aRelationAttr are null, then any element with aTagType will do\\n+   * @param aExcludeContent - element that is skiped for search\\n+   * @param aTagType - tag name of searched element, by default it is 'label' --\\n+   *                   ignored if aAriaProperty passed in\\n+   */\\n+  static nsIContent *FindDescendantPointingToID(const nsString *aId,\\n+                                                nsIContent *aLookContent,\\n+                                                EAriaProperty aAriaProperty,\\n+                                                nsIAtom *aRelationAttr = nsnull,\\n+                                                nsIContent *aExcludeContent = nsnull,\\n+                                                nsIAtom *aTagType = nsAccessibilityAtoms::label);\\n+\\n+  // Helper for FindDescendantPointingToID(), same args\\n+  static nsIContent *FindDescendantPointingToIDImpl(nsCString& aIdWithSpaces,\\n+                                                    nsIContent *aLookContent,\\n+                                                    EAriaProperty aAriaProperty,\\n+                                                    PRUint32 aAriaPropTypes,\\n+                                                    nsIAtom *aRelationAttr = nsnull,\\n+                                                    nsIContent *aExcludeContent = nsnull,\\n+                                                    nsIAtom *aTagType = nsAccessibilityAtoms::label);\\n };\\n \\n #endif\\ndiff --git a/accessible/src/base/nsAccessible.cpp b/accessible/src/base/nsAccessible.cpp\\nindex 897fcd9..ed9b9d0 100644\\n--- a/accessible/src/base/nsAccessible.cpp\\n+++ b/accessible/src/base/nsAccessible.cpp\\n@@ -75,6 +75,7 @@\\n \\n #include \\\"nsXPIDLString.h\\\"\\n #include \\\"nsUnicharUtils.h\\\"\\n+#include \\\"nsReadableUtils.h\\\"\\n #include \\\"prdtoa.h\\\"\\n #include \\\"nsIAtom.h\\\"\\n #include \\\"nsIPrefService.h\\\"\\n@@ -197,16 +198,13 @@ nsresult nsAccessible::QueryInterface(REFNSIID aIID, void** aInstancePtr)\\n     }\\n     if (HasRoleAttribute(content)) {\\n       // If we have an XHTML role attribute present and the\\n-      // waistate multiselectable attribute not empty or false, then we need\\n+      // waistate multiselectable attribute is true, then we need\\n       // to support nsIAccessibleSelectable\\n       // If either attribute (role or multiselectable) change, then we'll\\n       // destroy this accessible so that we can follow COM identity rules.\\n-      static nsIContent::AttrValuesArray strings[] =\\n-        {&nsAccessibilityAtoms::_empty, &nsAccessibilityAtoms::_false, nsnull};\\n-      if (content->FindAttrValueIn(kNameSpaceID_WAIProperties ,\\n-                                   nsAccessibilityAtoms::multiselectable,\\n-                                   strings, eCaseMatters) ==\\n-          nsIContent::ATTR_VALUE_NO_MATCH) {\\n+      nsAutoString multiselectable;\\n+      if (nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_multiselectable, multiselectable) &&\\n+          multiselectable.EqualsLiteral(\\\"true\\\")) {\\n         *aInstancePtr = static_cast<nsIAccessibleSelectable*>(this);\\n         NS_ADDREF_THIS();\\n         return NS_OK;\\n@@ -303,14 +301,15 @@ NS_IMETHODIMP nsAccessible::GetDescription(nsAString& aDescription)\\n   }\\n   if (!content->IsNodeOfType(nsINode::eTEXT)) {\\n     nsAutoString description;\\n-    nsresult rv = GetTextFromRelationID(nsAccessibilityAtoms::describedby, description);\\n+    nsresult rv = GetTextFromRelationID(eAria_describedby, description);\\n     if (NS_FAILED(rv)) {\\n       PRBool isXUL = content->IsNodeOfType(nsINode::eXUL);\\n       if (isXUL) {\\n         // Try XUL <description control=\\\"[id]\\\">description text</description>\\n         nsIContent *descriptionContent =\\n-          FindNeighbourPointingToNode(content, nsAccessibilityAtoms::description,\\n-                                      nsAccessibilityAtoms::control);\\n+          nsAccUtils::FindNeighbourPointingToNode(content, eAria_none,\\n+                                                  nsAccessibilityAtoms::description,\\n+                                                  nsAccessibilityAtoms::control);\\n \\n         if (descriptionContent) {\\n           // We have a description content node\\n@@ -1377,10 +1376,24 @@ NS_IMETHODIMP nsAccessible::SetSelected(PRBool aSelect)\\n     nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));\\n     NS_ASSERTION(content, \\\"Called for dead accessible\\\");\\n \\n-    // For DHTML widgets use WAI namespace\\n-    PRUint32 nameSpaceID = mRoleMapEntry ? kNameSpaceID_WAIProperties : kNameSpaceID_None;\\n+    // For ARIA widgets use WAI namespace or hyphenated property, depending on what doc accepts\\n+    PRUint32 nameSpaceID = kNameSpaceID_None;  // Default\\n+    if (mRoleMapEntry) {\\n+      if (0 == (nsAccUtils::GetAriaPropTypes(content, mWeakShell) &\\n+                nsIAccessibleDocument::eCheckNamespaced)) {\\n+        // No WAI namespaced properties used in this doc, use hyphenated property\\n+        if (aSelect) {\\n+          return content->SetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_selected,\\n+                                  NS_LITERAL_STRING(\\\"true\\\"), PR_TRUE);\\n+        }\\n+        return content->UnsetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_selected, PR_TRUE);\\n+      }\\n+      nameSpaceID = kNameSpaceID_WAIProperties;\\n+    }\\n+    // Use normal property\\n     if (aSelect) {\\n-      return content->SetAttr(nameSpaceID, nsAccessibilityAtoms::selected, NS_LITERAL_STRING(\\\"true\\\"), PR_TRUE);\\n+      return content->SetAttr(nameSpaceID, nsAccessibilityAtoms::selected,\\n+                              NS_LITERAL_STRING(\\\"true\\\"), PR_TRUE);\\n     }\\n     return content->UnsetAttr(nameSpaceID, nsAccessibilityAtoms::selected, PR_TRUE);\\n   }\\n@@ -1633,8 +1646,9 @@ nsresult nsAccessible::AppendFlatStringFromSubtreeRecurse(nsIContent *aContent,\\n nsIContent *nsAccessible::GetLabelContent(nsIContent *aForNode)\\n {\\n   if (aForNode->IsNodeOfType(nsINode::eXUL))\\n-    return FindNeighbourPointingToNode(aForNode, nsAccessibilityAtoms::label,\\n-                                       nsAccessibilityAtoms::control);\\n+    return nsAccUtils::FindNeighbourPointingToNode(aForNode, eAria_none,\\n+                                                   nsAccessibilityAtoms::label,\\n+                                                   nsAccessibilityAtoms::control);\\n \\n   return GetHTMLLabelContent(aForNode);\\n }\\n@@ -1662,15 +1676,15 @@ nsIContent* nsAccessible::GetHTMLLabelContent(nsIContent *aForNode)\\n         break;\\n       }\\n       // Actually we'll be walking down the content this time, with a depth first search\\n-      return FindDescendantPointingToID(&forId, walkUpContent,\\n-                                        nsAccessibilityAtoms::_for);\\n+      return nsAccUtils::FindDescendantPointingToID(&forId, walkUpContent, eAria_none,\\n+                                                    nsAccessibilityAtoms::_for);\\n     }\\n   }\\n \\n   return nsnull;\\n }\\n \\n-nsresult nsAccessible::GetTextFromRelationID(nsIAtom *aIDAttrib, nsString &aName)\\n+nsresult nsAccessible::GetTextFromRelationID(EAriaProperty aIDProperty, nsString &aName)\\n {\\n   // Get DHTML name from content subtree pointed to by ID attribute\\n   aName.Truncate();\\n@@ -1678,7 +1692,7 @@ nsresult nsAccessible::GetTextFromRelationID(nsIAtom *aIDAttrib, nsString &aName\\n   NS_ASSERTION(content, \\\"Called from shutdown accessible\\\");\\n \\n   nsAutoString ids;\\n-  if (!content->GetAttr(kNameSpaceID_WAIProperties, aIDAttrib, ids)) {\\n+  if (!nsAccUtils::GetAriaProperty(content, mWeakShell, aIDProperty, ids)) {\\n     return NS_ERROR_FAILURE;\\n   }\\n   ids.CompressWhitespace(PR_TRUE, PR_TRUE);\\n@@ -1721,129 +1735,6 @@ nsresult nsAccessible::GetTextFromRelationID(nsIAtom *aIDAttrib, nsString &aName\\n   return rv;\\n }\\n \\n-nsIContent*\\n-nsAccessible::FindNeighbourPointingToNode(nsIContent *aForNode,\\n-                                          nsIAtom *aTagName, nsIAtom *aRelationAttr,\\n-                                          PRUint32 aRelationNameSpaceID,\\n-                                          PRUint32 aAncestorLevelsToSearch)\\n-{\\n-  nsCOMPtr<nsIContent> binding;\\n-  nsAutoString controlID;\\n-  if (!nsAccUtils::GetID(aForNode, controlID)) {\\n-    binding = aForNode->GetBindingParent();\\n-    if (binding == aForNode)\\n-      return nsnull;\\n-\\n-    aForNode->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::anonid, controlID);\\n-    if (controlID.IsEmpty())\\n-      return nsnull;\\n-  }\\n-\\n-  // Look for label in subtrees of nearby ancestors\\n-  PRUint32 count = 0;\\n-  nsIContent *labelContent = nsnull;\\n-  nsIContent *prevSearched = nsnull;\\n-\\n-  while (!labelContent && ++count <= aAncestorLevelsToSearch &&\\n-         (aForNode = aForNode->GetParent()) != nsnull) {\\n-\\n-    if (aForNode == binding) {\\n-      // When we reach the binding parent, make sure to check\\n-      // all of its anonymous child subtrees\\n-      nsCOMPtr<nsIDocument> doc = aForNode->GetCurrentDoc();\\n-      nsCOMPtr<nsIDOMDocumentXBL> xblDoc(do_QueryInterface(doc));\\n-      if (!xblDoc)\\n-        return nsnull;\\n-\\n-      nsCOMPtr<nsIDOMNodeList> nodes;\\n-      nsCOMPtr<nsIDOMElement> forElm(do_QueryInterface(aForNode));\\n-      xblDoc->GetAnonymousNodes(forElm, getter_AddRefs(nodes));\\n-      if (!nodes)\\n-        return nsnull;\\n-\\n-      PRUint32 length;\\n-      nsresult rv = nodes->GetLength(&length);\\n-      if (NS_FAILED(rv))\\n-        return nsnull;\\n-\\n-      for (PRUint32 index = 0; index < length && !labelContent; index++) {\\n-        nsCOMPtr<nsIDOMNode> node;\\n-        rv = nodes->Item(index, getter_AddRefs(node));\\n-        if (NS_FAILED(rv))\\n-          return nsnull;\\n-\\n-        nsCOMPtr<nsIContent> content = do_QueryInterface(node);\\n-        if (!content)\\n-          return nsnull;\\n-\\n-        if (content != prevSearched) {\\n-          labelContent = FindDescendantPointingToID(&controlID, content,  aRelationAttr,\\n-                                                    aRelationNameSpaceID, nsnull,\\n-                                                    aTagName);\\n-        }\\n-      }\\n-      break;\\n-    }\\n-\\n-    labelContent = FindDescendantPointingToID(&controlID, aForNode,\\n-                                              aRelationAttr, aRelationNameSpaceID,\\n-                                              prevSearched, aTagName);\\n-    prevSearched = aForNode;\\n-  }\\n-\\n-  return labelContent;\\n-}\\n-\\n-// Pass in aRelationAttr == nsnull if any <label> will do\\n-nsIContent*\\n-nsAccessible::FindDescendantPointingToID(const nsAString *aId,\\n-                                         nsIContent *aLookContent,\\n-                                         nsIAtom *aRelationAttr,\\n-                                         PRUint32 aRelationNameSpaceID,\\n-                                         nsIContent *aExcludeContent,\\n-                                         nsIAtom *aTagType)\\n-{\\n-  if (!aTagType || aLookContent->Tag() == aTagType) {\\n-    if (aRelationAttr) {\\n-      // Check for ID in the attribute aRelationAttr, which can be a list\\n-      nsAutoString idList;\\n-      if (aLookContent->GetAttr(aRelationNameSpaceID, aRelationAttr, idList)) {\\n-        idList.Insert(' ', 0);  // Surround idlist with spaces for search\\n-        idList.Append(' ');\\n-        nsAutoString id(*aId);\\n-        id.Insert(' ', 0); // Surround id with spaces for search\\n-        id.Append(' ');\\n-        // idList is now a set of id's with spaces around each,\\n-        // and id also has spaces around it.\\n-        // If id is a substring of idList then we have a match\\n-        if (idList.Find(id) != -1) {\\n-          return aLookContent;\\n-        }\\n-      }\\n-    }\\n-    if (aTagType) {\\n-      return nsnull;\\n-    }\\n-  }\\n-\\n-  // Recursively search descendants for labels\\n-  PRUint32 count  = 0;\\n-  nsIContent *child;\\n-  nsIContent *labelContent = nsnull;\\n-\\n-  while ((child = aLookContent->GetChildAt(count++)) != nsnull) {\\n-    if (child != aExcludeContent) {\\n-      labelContent = FindDescendantPointingToID(aId, child, aRelationAttr,\\n-                                                aRelationNameSpaceID, aExcludeContent,\\n-                                                aTagType);\\n-      if (labelContent) {\\n-        return labelContent;\\n-      }\\n-    }\\n-  }\\n-  return nsnull;\\n-}\\n-\\n /**\\n   * Only called if the element is not a nsIDOMXULControlElement. Initially walks up\\n   *   the DOM tree to the form, concatonating label elements as it goes. Then checks for\\n@@ -1858,7 +1749,7 @@ nsresult nsAccessible::GetHTMLName(nsAString& aLabel, PRBool aCanAggregateSubtre\\n \\n   // Check for DHTML accessibility labelledby relationship property\\n   nsAutoString label;\\n-  nsresult rv = GetTextFromRelationID(nsAccessibilityAtoms::labelledby, label);\\n+  nsresult rv = GetTextFromRelationID(eAria_labelledby, label);\\n   if (NS_SUCCEEDED(rv)) {\\n     aLabel = label;\\n     return rv;\\n@@ -1909,7 +1800,7 @@ nsresult nsAccessible::GetXULName(nsAString& aLabel, PRBool aCanAggregateSubtree\\n \\n   // First check for label override via accessibility labelledby relationship\\n   nsAutoString label;\\n-  nsresult rv = GetTextFromRelationID(nsAccessibilityAtoms::labelledby, label);\\n+  nsresult rv = GetTextFromRelationID(eAria_labelledby, label);\\n   if (NS_SUCCEEDED(rv)) {\\n     aLabel = label;\\n     return rv;\\n@@ -1942,8 +1833,9 @@ nsresult nsAccessible::GetXULName(nsAString& aLabel, PRBool aCanAggregateSubtree\\n   if (NS_FAILED(rv) || label.IsEmpty()) {\\n     label.Truncate();\\n     nsIContent *labelContent =\\n-      FindNeighbourPointingToNode(content, nsAccessibilityAtoms::label,\\n-                                  nsAccessibilityAtoms::control);\\n+      nsAccUtils::FindNeighbourPointingToNode(content, eAria_none,\\n+                                              nsAccessibilityAtoms::label,\\n+                                              nsAccessibilityAtoms::control);\\n \\n     nsCOMPtr<nsIDOMXULLabelElement> xulLabel(do_QueryInterface(labelContent));\\n     // Check if label's value attribute is used\\n@@ -2040,9 +1932,9 @@ NS_IMETHODIMP nsAccessible::GetFinalRole(PRUint32 *aRole)\\n     // This is where the nsIAccessible role depends on both the role and ARIA state\\n     if (*aRole == nsIAccessibleRole::ROLE_ENTRY) {\\n       nsCOMPtr<nsIContent> content = do_QueryInterface(mDOMNode);\\n-      if (content && \\n-          content->AttrValueIs(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::secret,\\n-                               nsAccessibilityAtoms::_true, eCaseMatters)) {\\n+      nsAutoString secret;\\n+      if (content && nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_secret, secret) &&\\n+          secret.EqualsLiteral(\\\"true\\\")) {\\n         // For entry field with aaa:secret=\\\"true\\\"\\n         *aRole = nsIAccessibleRole::ROLE_PASSWORD_TEXT;\\n       }\\n@@ -2050,15 +1942,18 @@ NS_IMETHODIMP nsAccessible::GetFinalRole(PRUint32 *aRole)\\n     else if (*aRole == nsIAccessibleRole::ROLE_PUSHBUTTON) {\\n       nsCOMPtr<nsIContent> content = do_QueryInterface(mDOMNode);\\n       if (content) {\\n-        if (content->HasAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::pressed)) {\\n+        if (nsAccUtils::HasAriaProperty(content, mWeakShell, eAria_pressed)) {\\n           // For aaa:pressed=\\\"false\\\" or aaa:pressed=\\\"true\\\"\\n           // For simplicity, any pressed attribute indicates it's a toggle button\\n           *aRole = nsIAccessibleRole::ROLE_TOGGLE_BUTTON;\\n         }\\n-        else if (content->AttrValueIs(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::haspopup,\\n-                                      nsAccessibilityAtoms::_true, eCaseMatters)) {\\n-          // For button with aaa:haspopup=\\\"true\\\"\\n-          *aRole = nsIAccessibleRole::ROLE_BUTTONMENU;\\n+        else {\\n+          nsAutoString haspopup;\\n+          if (nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_haspopup, haspopup) &&\\n+              haspopup.EqualsLiteral(\\\"true\\\")) {\\n+            // For button with aaa:haspopup=\\\"true\\\"\\n+            *aRole = nsIAccessibleRole::ROLE_BUTTONMENU;\\n+          }\\n         }\\n       }\\n     }\\n@@ -2099,16 +1994,20 @@ nsAccessible::GetAttributes(nsIPersistentProperties **aAttributes)\\n       attributes->SetStringProperty(NS_LITERAL_CSTRING(\\\"xml-roles\\\"), xmlRole, oldValueUnused);          \\n     }\\n \\n-    char *ariaProperties[] = { \\\"live\\\", \\\"channel\\\", \\\"atomic\\\", \\\"relevant\\\", \\\"datatype\\\", \\\"level\\\",\\n+    // Make sure to keep these two arrays in sync\\n+    PRUint32 ariaPropTypes = nsAccUtils::GetAriaPropTypes(content, mWeakShell);\\n+    char *ariaPropertyString[] = { \\\"live\\\", \\\"channel\\\", \\\"atomic\\\", \\\"relevant\\\", \\\"datatype\\\", \\\"level\\\",\\n                                \\\"posinset\\\", \\\"setsize\\\", \\\"sort\\\", \\\"grab\\\", \\\"dropeffect\\\"};\\n-\\n-    for (PRUint32 index = 0; index < NS_ARRAY_LENGTH(ariaProperties); index ++) {\\n+    EAriaProperty ariaPropertyEnum[] = { eAria_live, eAria_channel, eAria_atomic, eAria_relevant,\\n+                                       eAria_datatype, eAria_level, eAria_posinset, eAria_setsize,\\n+                                       eAria_sort, eAria_grab, eAria_dropeffect};\\n+    NS_ASSERTION(NS_ARRAY_LENGTH(ariaPropertyString) == NS_ARRAY_LENGTH(ariaPropertyEnum),\\n+                 \\\"ARIA attributes and object property name arrays out of sync\\\");\\n+    for (PRUint32 index = 0; index < NS_ARRAY_LENGTH(ariaPropertyString); index ++) {\\n       nsAutoString value;\\n-      nsCOMPtr<nsIAtom> attr = do_GetAtom(ariaProperties[index]);\\n-      NS_ENSURE_TRUE(attr, NS_ERROR_OUT_OF_MEMORY);\\n-      if (content->GetAttr(kNameSpaceID_WAIProperties, attr, value)) {\\n+      if (nsAccUtils::GetAriaProperty(content, mWeakShell, ariaPropertyEnum[index], value, ariaPropTypes)) {\\n         ToLowerCase(value);\\n-        attributes->SetStringProperty(nsDependentCString(ariaProperties[index]), value, oldValueUnused);    \\n+        attributes->SetStringProperty(nsDependentCString(ariaPropertyString[index]), value, oldValueUnused);    \\n       }\\n     }\\n \\n@@ -2116,20 +2015,20 @@ nsAccessible::GetAttributes(nsIPersistentProperties **aAttributes)\\n     // the live region attribute\\n     nsAutoString atomic, live, relevant, channel, busy;\\n     while (content) {\\n-      if (relevant.IsEmpty() && \\n-          content->GetAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::relevant, relevant))\\n+      if (relevant.IsEmpty() &&\\n+          nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_relevant, relevant, ariaPropTypes))\\n         attributes->SetStringProperty(NS_LITERAL_CSTRING(\\\"container-relevant\\\"), relevant, oldValueUnused);\\n       if (live.IsEmpty() &&\\n-          content->GetAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::live, live))\\n+          nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_live, live, ariaPropTypes))\\n         attributes->SetStringProperty(NS_LITERAL_CSTRING(\\\"container-live\\\"), live, oldValueUnused);\\n       if (channel.IsEmpty() &&\\n-          content->GetAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::channel, channel))\\n+          nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_channel, channel, ariaPropTypes))\\n         attributes->SetStringProperty(NS_LITERAL_CSTRING(\\\"container-channel\\\"), channel, oldValueUnused);\\n       if (atomic.IsEmpty() &&\\n-          content->GetAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::atomic, atomic))\\n+          nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_atomic, atomic, ariaPropTypes))\\n         attributes->SetStringProperty(NS_LITERAL_CSTRING(\\\"container-atomic\\\"), atomic, oldValueUnused);\\n       if (busy.IsEmpty() &&\\n-          content->GetAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::busy, busy))\\n+          nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_busy, busy, ariaPropTypes))\\n         attributes->SetStringProperty(NS_LITERAL_CSTRING(\\\"container-busy\\\"), busy, oldValueUnused);\\n       content = content->GetParent();\\n     }\\n@@ -2264,14 +2163,12 @@ PRBool nsAccessible::MappedAttrState(nsIContent *aContent, PRUint32 *aStateInOut\\n                                      nsStateMapEntry *aStateMapEntry)\\n {\\n   // Return true if we should continue\\n-  if (!aStateMapEntry->attributeName) {\\n+  if (aStateMapEntry->attributeName == eAria_none) {\\n     return PR_FALSE;  // Stop looking -- no more states\\n   }\\n \\n   nsAutoString attribValue;\\n-  nsCOMPtr<nsIAtom> attribAtom = do_GetAtom(aStateMapEntry->attributeName); // XXX put atoms directly in entry\\n-  NS_ENSURE_TRUE(attribAtom, NS_ERROR_OUT_OF_MEMORY);\\n-  if (aContent->GetAttr(kNameSpaceID_WAIProperties, attribAtom, attribValue)) {\\n+  if (nsAccUtils::GetAriaProperty(aContent, mWeakShell, aStateMapEntry->attributeName, attribValue)) {\\n     if (aStateMapEntry->attributeValue == kBoolState) {\\n       // No attribute value map specified in state map entry indicates state cleared\\n       if (attribValue.EqualsLiteral(\\\"false\\\")) {\\n@@ -2335,8 +2232,7 @@ nsAccessible::GetFinalState(PRUint32 *aState, PRUint32 *aExtraState)\\n     NS_ENSURE_STATE(content);\\n \\n     nsAutoString autocomplete;\\n-    if (content->GetAttr(kNameSpaceID_WAIProperties,\\n-                         nsAccessibilityAtoms::autocomplete, autocomplete) &&\\n+    if (nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_autocomplete, autocomplete) &&\\n         (autocomplete.EqualsIgnoreCase(\\\"inline\\\") ||\\n          autocomplete.EqualsIgnoreCase(\\\"list\\\") ||\\n          autocomplete.EqualsIgnoreCase(\\\"both\\\"))) {\\n@@ -2345,9 +2241,9 @@ nsAccessible::GetFinalState(PRUint32 *aState, PRUint32 *aExtraState)\\n \\n     // XXX We can remove this hack once we support RDF-based role & state maps\\n     if (mRoleMapEntry && mRoleMapEntry->role == nsIAccessibleRole::ROLE_ENTRY) {\\n-      if (content->AttrValueIs(kNameSpaceID_WAIProperties,\\n-                               nsAccessibilityAtoms::multiline,\\n-                               nsAccessibilityAtoms::_true, eCaseMatters)) {\\n+      nsAutoString multiline;\\n+      if (nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_multiline, multiline) &&\\n+          multiline.EqualsLiteral(\\\"true\\\")) {\\n         *aExtraState |= nsIAccessibleStates::EXT_STATE_MULTI_LINE;\\n       }\\n       else {\\n@@ -2393,8 +2289,7 @@ nsAccessible::GetARIAState()\\n \\n   PRUint32 ariaState = 0;\\n   PRUint32 index = 0;\\n-  while (nsARIAMap::gWAIUnivStateMap[index].attributeName != nsnull) {\\n-    MappedAttrState(content, &ariaState, &nsARIAMap::gWAIUnivStateMap[index]);\\n+  while (MappedAttrState(content, &ariaState, &nsARIAMap::gWAIUnivStateMap[index])) {\\n     ++ index;\\n   }\\n \\n@@ -2438,8 +2333,7 @@ NS_IMETHODIMP nsAccessible::GetValue(nsAString& aValue)\\n       return NS_OK;\\n     }\\n     nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));\\n-    if (content && content->GetAttr(kNameSpaceID_WAIProperties,\\n-                                    nsAccessibilityAtoms::valuenow, aValue)) {\\n+    if (content && nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_valuenow, aValue)) {\\n       return NS_OK;\\n     }\\n   }\\n@@ -2450,15 +2344,13 @@ NS_IMETHODIMP nsAccessible::GetValue(nsAString& aValue)\\n NS_IMETHODIMP\\n nsAccessible::GetMaximumValue(double *aMaximumValue)\\n {\\n-  return GetAttrValue(kNameSpaceID_WAIProperties,\\n-                      nsAccessibilityAtoms::valuemax, aMaximumValue);\\n+  return GetAttrValue(eAria_valuemax, aMaximumValue);\\n }\\n \\n NS_IMETHODIMP\\n nsAccessible::GetMinimumValue(double *aMinimumValue)\\n {\\n-  return GetAttrValue(kNameSpaceID_WAIProperties,\\n-                      nsAccessibilityAtoms::valuemin, aMinimumValue);\\n+  return GetAttrValue(eAria_valuemin, aMinimumValue);\\n }\\n \\n NS_IMETHODIMP\\n@@ -2474,8 +2366,7 @@ nsAccessible::GetMinimumIncrement(double *aMinIncrement)\\n NS_IMETHODIMP\\n nsAccessible::GetCurrentValue(double *aValue)\\n {\\n-  return GetAttrValue(kNameSpaceID_WAIProperties,\\n-                      nsAccessibilityAtoms::valuenow, aValue);\\n+  return GetAttrValue(eAria_valuenow, aValue);\\n }\\n \\n NS_IMETHODIMP\\n@@ -2506,6 +2397,12 @@ nsAccessible::SetCurrentValue(double aValue)\\n \\n   nsAutoString newValue;\\n   newValue.AppendFloat(aValue);\\n+  if (0 == (nsAccUtils::GetAriaPropTypes(content, mWeakShell) &\\n+            nsIAccessibleDocument::eCheckNamespaced)) {\\n+    // No WAI namespaced properties used in this doc\\n+    return content->SetAttr(kNameSpaceID_None,\\n+                            nsAccessibilityAtoms::aria_valuenow, newValue, PR_TRUE);\\n+  }\\n   return content->SetAttr(kNameSpaceID_WAIProperties,\\n                           nsAccessibilityAtoms::valuenow, newValue, PR_TRUE);\\n }\\n@@ -2612,39 +2509,16 @@ NS_IMETHODIMP nsAccessible::GetAccessibleBelow(nsIAccessible **_retval)\\n   return NS_ERROR_NOT_IMPLEMENTED;\\n }\\n \\n-already_AddRefed<nsIDOMNode>\\n-nsAccessible::FindNeighbourPointingToThis(nsIAtom *aRelationAttr,\\n-                                          PRUint32 aRelationNameSpaceID,\\n-                                          PRUint32 aAncestorLevelsToSearch)\\n-{\\n-  nsIContent *content = GetRoleContent(mDOMNode);\\n-  if (!content)\\n-    return nsnull; // Node shut down\\n-\\n-  nsIContent* description = FindNeighbourPointingToNode(content, nsnull,\\n-                                                        aRelationAttr,\\n-                                                        aRelationNameSpaceID,\\n-                                                        aAncestorLevelsToSearch);\\n-\\n-  if (!description)\\n-    return nsnull;\\n-\\n-  nsIDOMNode *relatedNode;\\n-  CallQueryInterface(description, &relatedNode);\\n-  return relatedNode;\\n-}\\n-\\n nsIDOMNode* nsAccessible::GetAtomicRegion()\\n {\\n   nsCOMPtr<nsIContent> content = do_QueryInterface(mDOMNode);\\n   nsIContent *loopContent = content;\\n   nsAutoString atomic;\\n+  PRUint32 ariaPropTypes = nsAccUtils::GetAriaPropTypes(content, mWeakShell);\\n \\n-  while (loopContent) {\\n-    loopContent->GetAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::atomic, atomic);\\n-    if (!atomic.IsEmpty()) {\\n-      break;\\n-    }\\n+  while (loopContent && !nsAccUtils::GetAriaProperty(loopContent, mWeakShell,\\n+                                                     eAria_atomic, atomic,\\n+                                                     ariaPropTypes)) {\\n     loopContent = loopContent->GetParent();\\n   }\\n \\n@@ -2683,43 +2557,33 @@ NS_IMETHODIMP nsAccessible::GetAccessibleRelated(PRUint32 aRelationType, nsIAcce\\n         content->GetAttr(kNameSpaceID_None, relatedIDAttr, relatedID);\\n       }\\n       if (relatedID.IsEmpty()) {\\n-        const PRUint32 kAncestorLevelsToSearch = 3;\\n-        relatedNode = FindNeighbourPointingToThis(nsAccessibilityAtoms::labelledby,\\n-                                                  kNameSpaceID_WAIProperties,\\n-                                                  kAncestorLevelsToSearch);\\n+        relatedNode =\\n+          do_QueryInterface(nsAccUtils::FindNeighbourPointingToNode(content, eAria_labelledby));\\n       }\\n       break;\\n     }\\n   case nsIAccessibleRelation::RELATION_LABELLED_BY:\\n     {\\n-      content->GetAttr(kNameSpaceID_WAIProperties,\\n-                       nsAccessibilityAtoms::labelledby, relatedID);\\n-      if (relatedID.IsEmpty()) {\\n+      if (!nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_labelledby, relatedID)) {\\n         relatedNode = do_QueryInterface(GetLabelContent(content));\\n       }\\n       break;\\n     }\\n   case nsIAccessibleRelation::RELATION_DESCRIBED_BY:\\n     {\\n-      content->GetAttr(kNameSpaceID_WAIProperties,\\n-                       nsAccessibilityAtoms::describedby, relatedID);\\n-      if (relatedID.IsEmpty()) {\\n-        nsIContent *description =\\n-          FindNeighbourPointingToNode(content,\\n-                                      nsAccessibilityAtoms::description,\\n-                                      nsAccessibilityAtoms::control);\\n+      if (!nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_describedby, relatedID)) {\\n+        relatedNode = do_QueryInterface(\\n+          nsAccUtils::FindNeighbourPointingToNode(content, eAria_none,\\n+                                                  nsAccessibilityAtoms::description,\\n+                                                  nsAccessibilityAtoms::control));\\n \\n-        relatedNode = do_QueryInterface(description);\\n       }\\n       break;\\n     }\\n   case nsIAccessibleRelation::RELATION_DESCRIPTION_FOR:\\n     {\\n-      const PRUint32 kAncestorLevelsToSearch = 3;\\n       relatedNode =\\n-        FindNeighbourPointingToThis(nsAccessibilityAtoms::describedby,\\n-                                    kNameSpaceID_WAIProperties,\\n-                                    kAncestorLevelsToSearch);\\n+        do_QueryInterface(nsAccUtils::FindNeighbourPointingToNode(content, eAria_describedby));\\n \\n       if (!relatedNode && content->Tag() == nsAccessibilityAtoms::description &&\\n           content->IsNodeOfType(nsINode::eXUL)) {\\n@@ -2733,35 +2597,32 @@ NS_IMETHODIMP nsAccessible::GetAccessibleRelated(PRUint32 aRelationType, nsIAcce\\n     }\\n   case nsIAccessibleRelation::RELATION_NODE_CHILD_OF:\\n     {\\n-      relatedNode = FindNeighbourPointingToThis(nsAccessibilityAtoms::owns,\\n-                                                kNameSpaceID_WAIProperties);\\n+      relatedNode =\\n+        do_QueryInterface(nsAccUtils::FindNeighbourPointingToNode(content, eAria_owns));\\n       break;\\n     }\\n   case nsIAccessibleRelation::RELATION_CONTROLLED_BY:\\n     {\\n-      relatedNode = FindNeighbourPointingToThis(nsAccessibilityAtoms::controls,\\n-                                                kNameSpaceID_WAIProperties);\\n+      relatedNode =\\n+        do_QueryInterface(nsAccUtils::FindNeighbourPointingToNode(content, eAria_controls));\\n       break;\\n     }\\n   case nsIAccessibleRelation::RELATION_CONTROLLER_FOR:\\n     {\\n-      content->GetAttr(kNameSpaceID_WAIProperties,\\n-                       nsAccessibilityAtoms::controls, relatedID);\\n+      nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_controls, relatedID);\\n       break;\\n     }\\n   case nsIAccessibleRelation::RELATION_FLOWS_TO:\\n     {\\n-      content->GetAttr(kNameSpaceID_WAIProperties,\\n-                       nsAccessibilityAtoms::flowto, relatedID);\\n+      nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_flowto, relatedID);\\n       break;\\n     }\\n   case nsIAccessibleRelation::RELATION_FLOWS_FROM:\\n     {\\n-      relatedNode = FindNeighbourPointingToThis(nsAccessibilityAtoms::flowto,\\n-                                                kNameSpaceID_WAIProperties);\\n+      relatedNode =\\n+        do_QueryInterface(nsAccUtils::FindNeighbourPointingToNode(content, eAria_flowto));\\n       break;\\n     }\\n-\\n   case nsIAccessibleRelation::RELATION_DEFAULT_BUTTON:\\n     {\\n       if (content->IsNodeOfType(nsINode::eHTML)) {\\n@@ -3346,8 +3207,7 @@ PRBool nsAccessible::CheckVisibilityInParentChain(nsIDocument* aDocument, nsIVie\\n }\\n \\n nsresult\\n-nsAccessible::GetAttrValue(PRUint32 aNameSpaceID, nsIAtom *aName,\\n-                           double *aValue)\\n+nsAccessible::GetAttrValue(EAriaProperty aProperty, double *aValue)\\n {\\n   NS_ENSURE_ARG_POINTER(aValue);\\n   *aValue = 0;\\n@@ -3363,7 +3223,7 @@ nsAccessible::GetAttrValue(PRUint32 aNameSpaceID, nsIAtom *aName,\\n \\n   PRInt32 result = NS_OK;\\n   nsAutoString value;\\n-  if (content->GetAttr(aNameSpaceID, aName, value) && !value.IsEmpty())\\n+  if (nsAccUtils::GetAriaProperty(content, mWeakShell, aProperty, value))\\n     *aValue = value.ToFloat(&result);\\n \\n   return result;\\ndiff --git a/accessible/src/base/nsAccessible.h b/accessible/src/base/nsAccessible.h\\nindex 1111886..8ae21d6 100644\\n--- a/accessible/src/base/nsAccessible.h\\n+++ b/accessible/src/base/nsAccessible.h\\n@@ -168,63 +168,16 @@ protected:\\n   PRBool IsVisible(PRBool *aIsOffscreen); \\n \\n   // Relation helpers\\n-  nsresult GetTextFromRelationID(nsIAtom *aIDAttrib, nsString &aName);\\n \\n   /**\\n-   * Search element in neighborhood of the given element by tag name and\\n-   * attribute value that equals to ID attribute of the current element.\\n-   * ID attribute can be either 'id' attribute or 'anonid' if the element is\\n-   * anonymous.\\n+   * For a given ARIA relation, such as labelledby or describedby, get the collated text\\n+   * for the subtree that's pointed to.\\n    *\\n-   * @param aRelationAttr - attribute name of searched element\\n-   * @param aRelationNamespaceID - namespace id of searched attribute, by default\\n-   *                               empty namespace\\n-   * @param aAncestorLevelsToSearch - points how is the neighborhood of the\\n-   *                                  given element big.\\n+   * @param aIDProperty  The ARIA relationship property to get the text for\\n+   * @param aName        Where to put the text\\n+   * @return error or success code\\n    */\\n-  already_AddRefed<nsIDOMNode> FindNeighbourPointingToThis(nsIAtom *aRelationAttr,\\n-                                                           PRUint32 aRelationNameSpaceID = kNameSpaceID_None,\\n-                                                           PRUint32 aAncestorLevelsToSearch = 0);\\n-\\n-  /**\\n-   * Search element in neighborhood of the given element by tag name and\\n-   * attribute value that equals to ID attribute of the given element.\\n-   * ID attribute can be either 'id' attribute or 'anonid' if the element is\\n-   * anonymous.\\n-   *\\n-   * @param aForNode - the given element the search is performed for\\n-   * @param aTagName - tag name of searched element\\n-   * @param aRelationAttr - attribute name of searched element\\n-   * @param aRelationNamespaceID - namespace id of searched attribute, by default\\n-   *                               empty namespace\\n-   * @param aAncestorLevelsToSearch - points how is the neighborhood of the\\n-   *                                  given element big.\\n-   */\\n-  static nsIContent *FindNeighbourPointingToNode(nsIContent *aForNode,\\n-                                                 nsIAtom *aTagName,\\n-                                                 nsIAtom *aRelationAttr,\\n-                                                 PRUint32 aRelationNameSpaceID = kNameSpaceID_None,\\n-                                                 PRUint32 aAncestorLevelsToSearch = 5);\\n-\\n-  /**\\n-   * Search for element that satisfies the requirements in subtree of the given\\n-   * element. The requirements are tag name, attribute name and value of\\n-   * attribute.\\n-   *\\n-   * @param aId - value of searched attribute\\n-   * @param aLookContent - element that search is performed inside\\n-   * @param aRelationAttr - searched attribute\\n-   * @param aRelationNamespaceID - namespace id of searched attribute, by default\\n-   *                               empty namespace\\n-   * @param aExcludeContent - element that is skiped for search\\n-   * @param aTagType - tag name of searched element, by default it is 'label'\\n-   */\\n-  static nsIContent *FindDescendantPointingToID(const nsAString *aId,\\n-                                                nsIContent *aLookContent,\\n-                                                nsIAtom *aRelationAttr,\\n-                                                PRUint32 aRelationNamespaceID = kNameSpaceID_None,\\n-                                                nsIContent *aExcludeContent = nsnull,\\n-                                                nsIAtom *aTagType = nsAccessibilityAtoms::label);\\n+  nsresult GetTextFromRelationID(EAriaProperty aIDProperty, nsString &aName);\\n \\n   static nsIContent *GetHTMLLabelContent(nsIContent *aForNode);\\n   static nsIContent *GetLabelContent(nsIContent *aForNode);\\n@@ -284,15 +237,14 @@ protected:\\n   nsIDOMNode* GetAtomicRegion();\\n \\n   /**\\n-   * Get numeric value of the given attribute.\\n+   * Get numeric value of the given ARIA attribute.\\n    *\\n-   * @param aNameSpaceID - namespace ID of the attribute\\n-   * @param aName - name of the attribute\\n+   * @param aAriaProperty - the ARIA property we're using\\n    * @param aValue - value of the attribute\\n    *\\n    * @return - NS_OK_NO_ARIA_VALUE if there is no setted ARIA attribute\\n    */\\n-  nsresult GetAttrValue(PRUint32 aNameSpaceID, nsIAtom *aName, double *aValue);\\n+  nsresult GetAttrValue(EAriaProperty aAriaProperty, double *aValue);\\n \\n   // Data Members\\n   nsCOMPtr<nsIAccessible> mParent;\\ndiff --git a/accessible/src/base/nsDocAccessible.cpp b/accessible/src/base/nsDocAccessible.cpp\\nindex 3e5496a..6f81ecc 100644\\n--- a/accessible/src/base/nsDocAccessible.cpp\\n+++ b/accessible/src/base/nsDocAccessible.cpp\\n@@ -84,7 +84,8 @@ PRUint32 nsDocAccessible::gLastFocusedAccessiblesState = 0;\\n //-----------------------------------------------------\\n nsDocAccessible::nsDocAccessible(nsIDOMNode *aDOMNode, nsIWeakReference* aShell):\\n   nsHyperTextAccessibleWrap(aDOMNode, aShell), mWnd(nsnull),\\n-  mScrollPositionChangedTicks(0), mIsContentLoaded(PR_FALSE)\\n+  mScrollPositionChangedTicks(0), mIsContentLoaded(PR_FALSE),\\n+  mAriaPropTypes(eCheckNamespaced)\\n {\\n   // For GTK+ native window, we do nothing here.\\n   if (!mDOMNode)\\n@@ -97,7 +98,24 @@ nsDocAccessible::nsDocAccessible(nsIDOMNode *aDOMNode, nsIWeakReference* aShell)\\n \\n   nsCOMPtr<nsIPresShell> shell(do_QueryReferent(mWeakShell));\\n   if (shell) {\\n+    // Find mDocument\\n     mDocument = shell->GetDocument();\\n+    // Find mAriaPropTypes: the initial type of ARIA properties that should be checked for\\n+    if (!mDocument) {\\n+      NS_WARNING(\\\"No document!\\\");\\n+      return;\\n+    }\\n+    \\n+    nsCOMPtr<nsIDOMNSHTMLDocument> htmlDoc(do_QueryInterface(mDocument));\\n+    if (htmlDoc) {\\n+      nsAutoString mimeType;\\n+      GetMimeType(mimeType);\\n+      mAriaPropTypes = eCheckHyphenated;\\n+      if (! mimeType.EqualsLiteral(\\\"text/html\\\")) {\\n+        mAriaPropTypes |= eCheckNamespaced;\\n+      }\\n+    }\\n+    // Find mWnd\\n     nsIViewManager* vm = shell->GetViewManager();\\n     if (vm) {\\n       nsCOMPtr<nsIWidget> widget;\\n@@ -904,7 +922,14 @@ NS_IMETHODIMP nsDocAccessible::Observe(nsISupports *aSubject, const char *aTopic\\n   return NS_OK;\\n }\\n \\n-///////////////////////////////////////////////////////////////////////\\n+NS_IMETHODIMP\\n+nsDocAccessible::GetAriaPropTypes(PRUint32 *aAriaPropTypes) \\n+{\\n+  *aAriaPropTypes = mAriaPropTypes;\\n+  return NS_OK;\\n+}\\n+\\n+  ///////////////////////////////////////////////////////////////////////\\n // nsIDocumentObserver\\n \\n NS_IMPL_NSIDOCUMENTOBSERVER_CORE_STUB(nsDocAccessible)\\n@@ -948,6 +973,14 @@ nsDocAccessible::AttributeChangedImpl(nsIContent* aContent, PRInt32 aNameSpaceID\\n   if (!docShell) {\\n     return;\\n   }\\n+  if (aNameSpaceID == kNameSpaceID_WAIProperties) {\\n+    // Using setAttributeNS() in HTML to set namespaced ARIA properties.\\n+    // From this point forward, check namespaced properties, which\\n+    // take precedence over hyphenated properties, since in text/html\\n+    // that can only be set dynamically.\\n+    mAriaPropTypes |= eCheckNamespaced;\\n+  }\\n+\\n   PRUint32 busyFlags;\\n   docShell->GetBusyFlags(&busyFlags);\\n   if (busyFlags) {\\n@@ -971,7 +1004,8 @@ nsDocAccessible::AttributeChangedImpl(nsIContent* aContent, PRInt32 aNameSpaceID\\n   nsAccEvent::PrepareForEvent(targetNode);\\n \\n   // Universal boolean properties that don't require a role.\\n-  if (aAttribute == nsAccessibilityAtoms::disabled) {\\n+  if (aAttribute == nsAccessibilityAtoms::disabled ||\\n+      (aAttribute == nsAccessibilityAtoms::aria_disabled && (mAriaPropTypes & eCheckHyphenated))) {\\n     // Fire the state change whether disabled attribute is\\n     // set for XUL, HTML or ARIA namespace.\\n     // Checking the namespace would not seem to gain us anything, because\\n@@ -991,8 +1025,22 @@ nsDocAccessible::AttributeChangedImpl(nsIContent* aContent, PRInt32 aNameSpaceID\\n     return;\\n   }\\n \\n+  // Check for namespaced ARIA attribute\\n+  nsCOMPtr<nsIAtom> ariaAttribute;\\n   if (aNameSpaceID == kNameSpaceID_WAIProperties) {\\n-    ARIAAttributeChanged(aContent, aAttribute);\\n+    ariaAttribute = aAttribute;\\n+  }\\n+  else if (mAriaPropTypes & eCheckHyphenated && aNameSpaceID == kNameSpaceID_None) {\\n+    // Check for hyphenated aria-foo property?\\n+    const char* attributeName;\\n+    aAttribute->GetUTF8String(&attributeName);\\n+    if (!PL_strncmp(\\\"aria-\\\", attributeName, 5)) {\\n+      // Convert to WAI property atom attribute\\n+      ariaAttribute = do_GetAtom(attributeName + 5);\\n+    }\\n+  }\\n+  if (ariaAttribute) {  // We have an ARIA attribute\\n+    ARIAAttributeChanged(aContent, ariaAttribute);\\n     return;\\n   }\\n \\ndiff --git a/accessible/src/base/nsDocAccessible.h b/accessible/src/base/nsDocAccessible.h\\nindex 76d7b6c..f6f1047 100644\\n--- a/accessible/src/base/nsDocAccessible.h\\n+++ b/accessible/src/base/nsDocAccessible.h\\n@@ -204,6 +204,7 @@ class nsDocAccessible : public nsHyperTextAccessibleWrap,\\n protected:\\n     PRBool mIsAnchor;\\n     PRBool mIsAnchorJumped;\\n+    PRUint32 mAriaPropTypes;\\n     static PRUint32 gLastFocusedAccessiblesState;\\n \\n private:\\ndiff --git a/accessible/src/base/nsRootAccessible.cpp b/accessible/src/base/nsRootAccessible.cpp\\nindex 40075d6..2f0a7f9 100644\\n--- a/accessible/src/base/nsRootAccessible.cpp\\n+++ b/accessible/src/base/nsRootAccessible.cpp\\n@@ -388,6 +388,12 @@ void nsRootAccessible::TryFireEarlyLoadEvent(nsIDOMNode *aDocNode)\\n   if (itemType != nsIDocShellTreeItem::typeContent) {\\n     return;\\n   }\\n+\\n+  // At minimum, create doc accessible so that events are listened to,\\n+  // allowing us to see any mutations from a page load handler\\n+  nsCOMPtr<nsIAccessible> docAccessible;\\n+  GetAccService()->GetAccessibleFor(aDocNode, getter_AddRefs(docAccessible));\\n+\\n   nsCOMPtr<nsIDocShellTreeNode> treeNode(do_QueryInterface(treeItem));\\n   if (treeNode) {\\n     PRInt32 subDocuments;\\n@@ -460,7 +466,7 @@ PRBool nsRootAccessible::FireAccessibleFocusEvent(nsIAccessible *aAccessible,\\n   nsCOMPtr<nsIContent> finalFocusContent  = do_QueryInterface(aNode);\\n   if (finalFocusContent) {\\n     nsAutoString id;\\n-    if (finalFocusContent->GetAttr(kNameSpaceID_WAIProperties, nsAccessibilityAtoms::activedescendant, id)) {\\n+    if (nsAccUtils::GetAriaProperty(finalFocusContent, nsnull, eAria_activedescendant, id)) {\\n       nsCOMPtr<nsIDOMDocument> domDoc;\\n       aNode->GetOwnerDocument(getter_AddRefs(domDoc));\\n       if (!domDoc) {\\ndiff --git a/accessible/src/xforms/nsXFormsAccessible.cpp b/accessible/src/xforms/nsXFormsAccessible.cpp\\nindex d5c7ca2..c0a4c81 100755\\n--- a/accessible/src/xforms/nsXFormsAccessible.cpp\\n+++ b/accessible/src/xforms/nsXFormsAccessible.cpp\\n@@ -216,7 +216,7 @@ NS_IMETHODIMP\\n nsXFormsAccessible::GetName(nsAString& aName)\\n {\\n   nsAutoString name;\\n-  nsresult rv = GetTextFromRelationID(nsAccessibilityAtoms::labelledby, name);\\n+  nsresult rv = GetTextFromRelationID(eAria_labelledby, name);\\n   if (NS_SUCCEEDED(rv) && !name.IsEmpty()) {\\n     aName = name;\\n     return NS_OK;\\n@@ -230,8 +230,7 @@ NS_IMETHODIMP\\n nsXFormsAccessible::GetDescription(nsAString& aDescription)\\n {\\n   nsAutoString description;\\n-  nsresult rv = GetTextFromRelationID(nsAccessibilityAtoms::describedby,\\n-                                      description);\\n+  nsresult rv = GetTextFromRelationID(eAria_describedby, description);\\n \\n   if (NS_SUCCEEDED(rv) && !description.IsEmpty()) {\\n     aDescription = description;\\ndiff --git a/accessible/src/xforms/nsXFormsFormControlsAccessible.cpp b/accessible/src/xforms/nsXFormsFormControlsAccessible.cpp\\nindex 4c2b5b4..5312794 100755\\n--- a/accessible/src/xforms/nsXFormsFormControlsAccessible.cpp\\n+++ b/accessible/src/xforms/nsXFormsFormControlsAccessible.cpp\\n@@ -59,7 +59,7 @@ NS_IMETHODIMP\\n nsXFormsLabelAccessible::GetName(nsAString& aName)\\n {\\n   nsAutoString name;\\n-  nsresult rv = GetTextFromRelationID(nsAccessibilityAtoms::labelledby, name);\\n+  nsresult rv = GetTextFromRelationID(eAria_labelledby, name);\\n   aName = name;\\n   return rv;\\n }\\n@@ -68,8 +68,7 @@ NS_IMETHODIMP\\n nsXFormsLabelAccessible::GetDescription(nsAString& aDescription)\\n {\\n   nsAutoString description;\\n-  nsresult rv = GetTextFromRelationID(nsAccessibilityAtoms::describedby,\\n-                                      description);\\n+  nsresult rv = GetTextFromRelationID(eAria_describedby, description);\\n   aDescription = description;\\n   return rv;\\n }\\n\""}