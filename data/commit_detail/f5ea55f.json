{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basf5ea55f\""},"diff":"\"f5ea55f Backing out due to test bustage\\ndiff --git a/content/canvas/src/nsCanvasRenderingContext2D.cpp b/content/canvas/src/nsCanvasRenderingContext2D.cpp\\nindex 4202085..ee767cf 100644\\n--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp\\n+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp\\n@@ -1589,8 +1589,8 @@ nsCanvasRenderingContext2D::MozMeasureText(const nsAString& textToMeasure, float\\n \\n     PRBool tightBoundingBox = PR_FALSE;\\n     gfxTextRun::Metrics metrics = textRun->MeasureText(/* offset = */ 0, textToMeasure.Length(),\\n-                                                       tightBoundingBox, mThebesContext,\\n-                                                       nsnull);\\n+                                                         tightBoundingBox,\\n+                                                         nsnull);\\n     *retVal = metrics.mAdvanceWidth/gfxFloat(elemDocument->GetPrimaryShell()->GetPresContext()->AppUnitsPerCSSPixel());\\n     return NS_OK;\\n }\\ndiff --git a/gfx/cairo/cairo/src/cairo-win32-font.c b/gfx/cairo/cairo/src/cairo-win32-font.c\\nindex 9f01bc8..81213e7 100644\\n--- a/gfx/cairo/cairo/src/cairo-win32-font.c\\n+++ b/gfx/cairo/cairo/src/cairo-win32-font.c\\n@@ -99,7 +99,6 @@ typedef struct {\\n     HFONT scaled_hfont;\\n     HFONT unscaled_hfont;\\n \\n-    cairo_bool_t is_truetype;\\n     cairo_bool_t glyph_indexing;\\n \\n     cairo_bool_t delete_scaled_hfont;\\n@@ -745,11 +744,11 @@ _cairo_win32_scaled_font_set_metrics (cairo_win32_scaled_font_t *scaled_font)\\n \\n     }\\n \\n-    scaled_font->is_truetype = (metrics.tmPitchAndFamily & TMPF_TRUETYPE) != 0;\\n-    scaled_font->glyph_indexing = scaled_font->is_truetype ||\\n-        (GetFontData (hdc, OPENTYPE_CFF_TAG, 0, NULL, 0) != GDI_ERROR);\\n-    // XXX in what situations does this OPENTYPE_CFF thing not have the\\n-    // TMPF_TRUETYPE flag? GetFontData says it only works on Truetype fonts...\\n+    if ((metrics.tmPitchAndFamily & TMPF_TRUETYPE) ||\\n+        (GetFontData (hdc, OPENTYPE_CFF_TAG, 0, NULL, 0) != GDI_ERROR))\\n+        scaled_font->glyph_indexing = TRUE;\\n+    else\\n+        scaled_font->glyph_indexing = FALSE;\\n \\n     _cairo_scaled_font_set_metrics (&scaled_font->base, &extents);\\n \\n@@ -765,35 +764,18 @@ _cairo_win32_scaled_font_init_glyph_metrics (cairo_win32_scaled_font_t *scaled_f\\n     cairo_status_t status;\\n     cairo_text_extents_t extents;\\n     HDC hdc;\\n+    UINT glyph_index_option;\\n \\n     hdc = _get_global_font_dc ();\\n     if (!hdc)\\n \\treturn CAIRO_STATUS_NO_MEMORY;\\n \\n-    if (!scaled_font->is_truetype) {\\n-        /* GetGlyphOutline will not work. Assume that the glyph does not extend outside the font box. */\\n-        cairo_font_extents_t font_extents;\\n-        INT width = 0;\\n-        UINT charIndex =  _cairo_scaled_glyph_index (scaled_glyph);\\n-\\n-        cairo_scaled_font_extents (&scaled_font->base, &font_extents);\\n+    if (scaled_font->glyph_indexing)\\n+        glyph_index_option = GGO_GLYPH_INDEX;\\n+    else\\n+        glyph_index_option = 0;\\n \\n-        status = cairo_win32_scaled_font_select_font (&scaled_font->base, hdc);\\n-        if (!status) {\\n-            if (!GetCharWidth32(hdc, charIndex, charIndex, &width)) {\\n-                status = _cairo_win32_print_gdi_error (\\\"_cairo_win32_scaled_font_init_glyph_metrics:GetCharWidth32\\\");\\n-                width = 0;\\n-            }\\n-        }\\n-        cairo_win32_scaled_font_done_font (&scaled_font->base);\\n-\\n-        extents.x_bearing = 0;\\n-        extents.y_bearing = -font_extents.ascent / scaled_font->y_scale;\\n-        extents.width = width / scaled_font->x_scale;\\n-        extents.height = (font_extents.ascent + font_extents.descent) / scaled_font->y_scale;\\n-        extents.x_advance = extents.width;\\n-        extents.y_advance = 0;\\n-    } else if (scaled_font->preserve_axes && scaled_font->base.options.hint_style != CAIRO_HINT_METRICS_OFF) {\\n+    if (scaled_font->preserve_axes && scaled_font->base.options.hint_style != CAIRO_HINT_METRICS_OFF) {\\n \\t/* If we aren't rotating / skewing the axes, then we get the metrics\\n \\t * from the GDI in device space and convert to font space.\\n \\t */\\n@@ -801,7 +783,7 @@ _cairo_win32_scaled_font_init_glyph_metrics (cairo_win32_scaled_font_t *scaled_f\\n \\tif (status)\\n \\t    return status;\\n \\tif (GetGlyphOutlineW (hdc, _cairo_scaled_glyph_index (scaled_glyph),\\n-\\t\\t\\t      GGO_METRICS | GGO_GLYPH_INDEX,\\n+\\t\\t\\t      GGO_METRICS | glyph_index_option,\\n \\t\\t\\t      &metrics, 0, NULL, &matrix) == GDI_ERROR) {\\n \\t  status = _cairo_win32_print_gdi_error (\\\"_cairo_win32_scaled_font_init_glyph_metrics:GetGlyphOutlineW\\\");\\n \\t  memset (&metrics, 0, sizeof (GLYPHMETRICS));\\n@@ -840,7 +822,7 @@ _cairo_win32_scaled_font_init_glyph_metrics (cairo_win32_scaled_font_t *scaled_f\\n \\t */\\n \\tstatus = _cairo_win32_scaled_font_select_unscaled_font (&scaled_font->base, hdc);\\n \\tif (GetGlyphOutlineW (hdc, _cairo_scaled_glyph_index (scaled_glyph),\\n-\\t                      GGO_METRICS | GGO_GLYPH_INDEX,\\n+\\t\\t\\t      GGO_METRICS | glyph_index_option,\\n \\t\\t\\t      &metrics, 0, NULL, &matrix) == GDI_ERROR) {\\n \\t  status = _cairo_win32_print_gdi_error (\\\"_cairo_win32_scaled_font_init_glyph_metrics:GetGlyphOutlineW\\\");\\n \\t  memset (&metrics, 0, sizeof (GLYPHMETRICS));\\ndiff --git a/gfx/thebes/public/gfxAtsuiFonts.h b/gfx/thebes/public/gfxAtsuiFonts.h\\nindex 31e70f3..5191093 100644\\n--- a/gfx/thebes/public/gfxAtsuiFonts.h\\n+++ b/gfx/thebes/public/gfxAtsuiFonts.h\\n@@ -72,9 +72,6 @@ public:\\n     \\n     PRBool HasMirroringInfo();\\n \\n-    virtual void SetupGlyphExtents(gfxContext *aContext, PRUint32 aGlyphID,\\n-            PRBool aNeedTight, gfxGlyphExtents *aExtents);\\n-\\n protected:\\n     const gfxFontStyle *mFontStyle;\\n \\n@@ -96,7 +93,7 @@ protected:\\n \\n     void InitMetrics(ATSUFontID aFontID, ATSFontRef aFontRef);\\n \\n-    virtual PRBool SetupCairoFont(gfxContext *aContext);\\n+    virtual PRBool SetupCairoFont(cairo_t *aCR);\\n };\\n \\n class THEBES_API gfxAtsuiFontGroup : public gfxFontGroup {\\ndiff --git a/gfx/thebes/public/gfxFont.h b/gfx/thebes/public/gfxFont.h\\nindex f2c53a8..80d0d6c 100644\\n--- a/gfx/thebes/public/gfxFont.h\\n+++ b/gfx/thebes/public/gfxFont.h\\n@@ -56,6 +56,7 @@ class gfxTextRun;\\n class nsIAtom;\\n class gfxFont;\\n class gfxFontGroup;\\n+typedef struct _cairo cairo_t;\\n \\n #define FONT_STYLE_NORMAL              0\\n #define FONT_STYLE_ITALIC              1\\n@@ -229,75 +230,6 @@ protected:\\n     nsTHashtable<HashEntry> mFonts;\\n };\\n \\n-/**\\n- * This stores glyph bounds information for a particular gfxFont, at\\n- * a particular appunits-per-dev-pixel ratio (because the compressed glyph\\n- * width array is stored in appunits).\\n- * \\n- * We store a hashtable from glyph IDs to float bounding rects. For the\\n- * common case where the glyph has no horizontal left bearing, and no\\n- * y overflow above the font ascent or below the font descent, and tight\\n- * bounding boxes are not required, we avoid storing the glyph ID in the hashtable\\n- * and instead consult an array of 16-bit glyph XMost values (in appunits).\\n- * This array always has an entry for the font's space glyph --- the width is\\n- * assumed to be zero.\\n- */\\n-class THEBES_API gfxGlyphExtents {\\n-public:\\n-    gfxGlyphExtents(PRUint32 aAppUnitsPerDevUnit) :\\n-        mAppUnitsPerDevUnit(aAppUnitsPerDevUnit) {\\n-        mTightGlyphExtents.Init();\\n-    }\\n-\\n-    enum { INVALID_WIDTH = 0xFFFF };\\n-\\n-    // returns INVALID_WIDTH => not a contained glyph\\n-    // Otherwise the glyph has no before-bearing or vertical bearings,\\n-    // and the result is its width measured from the baseline origin, in\\n-    // appunits.\\n-    PRUint16 GetContainedGlyphWidthAppUnits(PRUint32 aGlyphID) const {\\n-        if (aGlyphID >= mWidthsForContainedGlyphsAppUnits.Length())\\n-            return INVALID_WIDTH;\\n-        return mWidthsForContainedGlyphsAppUnits[aGlyphID];\\n-    }\\n-    \\n-    PRBool IsGlyphKnown(PRUint32 aGlyphID) const {\\n-        if (aGlyphID < mWidthsForContainedGlyphsAppUnits.Length() &&\\n-            mWidthsForContainedGlyphsAppUnits[aGlyphID] != INVALID_WIDTH)\\n-            return PR_TRUE;\\n-        return mTightGlyphExtents.GetEntry(aGlyphID) != nsnull;\\n-    }\\n-\\n-    PRBool IsGlyphKnownWithTightExtents(PRUint32 aGlyphID) const {\\n-        return mTightGlyphExtents.GetEntry(aGlyphID) != nsnull;\\n-    }\\n-\\n-    // Get glyph extents; a rectangle relative to the left baseline origin\\n-    gfxRect GetTightGlyphExtentsAppUnits(gfxFont *aFont, gfxContext *aContext, PRUint32 aGlyphID);\\n-\\n-    void SetContainedGlyphWidthAppUnits(PRUint32 aGlyphID, PRUint16 aWidth);\\n-    void SetTightGlyphExtents(PRUint32 aGlyphID, const gfxRect& aExtentsAppUnits);\\n-\\n-    PRUint32 GetAppUnitsPerDevUnit() { return mAppUnitsPerDevUnit; }\\n-\\n-private:\\n-    class HashEntry : public nsUint32HashKey {\\n-    public:\\n-        // When constructing a new entry in the hashtable, we'll leave this\\n-        // blank. The caller of Put() will fill this in.\\n-        HashEntry(KeyTypePointer aPtr) : nsUint32HashKey(aPtr) {}\\n-        HashEntry(const HashEntry& toCopy) : nsUint32HashKey(toCopy) {\\n-          x = toCopy.x; y = toCopy.y; width = toCopy.width; height = toCopy.height;\\n-        }\\n-\\n-        float x, y, width, height;\\n-    };\\n-\\n-    nsTArray<PRUint16>      mWidthsForContainedGlyphsAppUnits;\\n-    nsTHashtable<HashEntry> mTightGlyphExtents;\\n-    PRUint32                mAppUnitsPerDevUnit;\\n-};\\n-\\n /* a SPECIFIC single font family */\\n class THEBES_API gfxFont {\\n public:\\n@@ -327,7 +259,7 @@ protected:\\n \\n public:\\n     gfxFont(const nsAString &aName, const gfxFontStyle *aFontGroup);\\n-    virtual ~gfxFont();\\n+    virtual ~gfxFont() {}\\n \\n     const nsString& GetName() const { return mName; }\\n     const gfxFontStyle *GetStyle() const { return &mStyle; }\\n@@ -457,7 +389,6 @@ public:\\n     virtual RunMetrics Measure(gfxTextRun *aTextRun,\\n                                PRUint32 aStart, PRUint32 aEnd,\\n                                PRBool aTightBoundingBox,\\n-                               gfxContext *aContextForTightBoundingBox,\\n                                Spacing *aSpacing);\\n     /**\\n      * Line breaks have been changed at the beginning and/or end of a substring\\n@@ -474,21 +405,14 @@ public:\\n     // Get the glyphID of a space\\n     virtual PRUint32 GetSpaceGlyph() = 0;\\n \\n-    gfxGlyphExtents *GetOrCreateGlyphExtents(PRUint32 aAppUnitsPerDevUnit);\\n-\\n-    // You need to call SetupCairoFont on the aCR just before calling this\\n-    virtual void SetupGlyphExtents(gfxContext *aContext, PRUint32 aGlyphID,\\n-                                   PRBool aNeedTight, gfxGlyphExtents *aExtents);\\n-\\n-    // This is called by the default Draw() implementation above.\\n-    virtual PRBool SetupCairoFont(gfxContext *aContext) = 0;\\n-\\n protected:\\n     // The family name of the font\\n-    nsString                   mName;\\n-    nsExpirationState          mExpirationState;\\n-    gfxFontStyle               mStyle;\\n-    nsAutoTArray<gfxGlyphExtents*,1> mGlyphExtentsArray;\\n+    nsString          mName;\\n+    nsExpirationState mExpirationState;\\n+    gfxFontStyle      mStyle;\\n+\\n+    // This is called by the default Draw() implementation above.\\n+    virtual PRBool SetupCairoFont(cairo_t *aCR) = 0;\\n };\\n \\n class THEBES_API gfxTextRunFactory {\\n@@ -762,7 +686,6 @@ public:\\n      */\\n     Metrics MeasureText(PRUint32 aStart, PRUint32 aLength,\\n                         PRBool aTightBoundingBox,\\n-                        gfxContext *aRefContextForTightBoundingBox,\\n                         PropertyProvider *aProvider);\\n \\n     /**\\n@@ -841,8 +764,6 @@ public:\\n      * @param aMetrics if non-null, we fill this in for the returned substring.\\n      * If a hyphenation break was used, the hyphen is NOT included in the returned metrics.\\n      * @param aTightBoundingBox if true, we make the bounding box in aMetrics tight\\n-     * @param aRefContextForTightBoundingBox a reference context to get the\\n-     * tight bounding box, if aTightBoundingBox is true\\n      * @param aUsedHyphenation if non-null, records if we selected a hyphenation break\\n      * @param aLastBreak if non-null and result is aMaxLength, we set this to\\n      * the maximal N such that\\n@@ -861,7 +782,6 @@ public:\\n                                  PRBool aSuppressInitialBreak,\\n                                  gfxFloat *aTrimWhitespace,\\n                                  Metrics *aMetrics, PRBool aTightBoundingBox,\\n-                                 gfxContext *aRefContextForTightBoundingBox,\\n                                  PRBool *aUsedHyphenation,\\n                                  PRUint32 *aLastBreak);\\n \\n@@ -1012,8 +932,6 @@ public:\\n         PRBool CanBreakBefore() const { return (mValue & FLAG_CAN_BREAK_BEFORE) != 0; }\\n         // Returns FLAG_CAN_BREAK_BEFORE if the setting changed, 0 otherwise\\n         PRUint32 SetCanBreakBefore(PRBool aCanBreakBefore) {\\n-            NS_ASSERTION(aCanBreakBefore == PR_FALSE || aCanBreakBefore == PR_TRUE,\\n-                         \\\"Bogus break-before value!\\\");\\n             PRUint32 breakMask = aCanBreakBefore*FLAG_CAN_BREAK_BEFORE;\\n             PRUint32 toggle = breakMask ^ (mValue & FLAG_CAN_BREAK_BEFORE);\\n             mValue ^= toggle;\\n@@ -1152,8 +1070,6 @@ public:\\n                            PRUint32 aNumGlyphs);\\n     void SetMissingGlyph(PRUint32 aCharIndex, PRUint32 aChar);\\n     void SetSpaceGlyph(gfxFont *aFont, gfxContext *aContext, PRUint32 aCharIndex);\\n-    \\n-    void FetchGlyphExtents(gfxContext *aRefContext);\\n \\n     // API for access to the raw glyph data, needed by gfxFont::Draw\\n     // and gfxFont::GetBoundingBox\\n@@ -1163,7 +1079,6 @@ public:\\n         // Missing glyphs need not have details.\\n         return mDetailedGlyphs ? mDetailedGlyphs[aCharIndex].get() : nsnull;\\n     }\\n-    PRBool HasDetailedGlyphs() { return mDetailedGlyphs.get() != nsnull; }\\n     PRUint32 CountMissingGlyphs();\\n     const GlyphRun *GetGlyphRuns(PRUint32 *aNumGlyphRuns) {\\n         *aNumGlyphRuns = mGlyphRuns.Length();\\n@@ -1242,14 +1157,12 @@ private:\\n     gfxFloat GetPartialLigatureWidth(PRUint32 aStart, PRUint32 aEnd, PropertyProvider *aProvider);\\n     void AccumulatePartialLigatureMetrics(gfxFont *aFont,\\n                                           PRUint32 aStart, PRUint32 aEnd, PRBool aTight,\\n-                                          gfxContext *aRefContext,\\n                                           PropertyProvider *aProvider,\\n                                           Metrics *aMetrics);\\n \\n     // **** measurement helper ****\\n     void AccumulateMetricsForRun(gfxFont *aFont, PRUint32 aStart,\\n                                  PRUint32 aEnd, PRBool aTight,\\n-                                 gfxContext *aRefContext,\\n                                  PropertyProvider *aProvider,\\n                                  PRUint32 aSpacingStart, PRUint32 aSpacingEnd,\\n                                  Metrics *aMetrics);\\ndiff --git a/gfx/thebes/public/gfxPangoFonts.h b/gfx/thebes/public/gfxPangoFonts.h\\nindex a90ff13..54dc20b 100644\\n--- a/gfx/thebes/public/gfxPangoFonts.h\\n+++ b/gfx/thebes/public/gfxPangoFonts.h\\n@@ -111,7 +111,7 @@ protected:\\n     void GetCharSize(const char aChar, gfxSize& aInkSize, gfxSize& aLogSize,\\n                      PRUint32 *aGlyphID = nsnull);\\n \\n-    virtual PRBool SetupCairoFont(gfxContext *aContext);\\n+    virtual PRBool SetupCairoFont(cairo_t *aCR);\\n };\\n \\n class FontSelector;\\ndiff --git a/gfx/thebes/public/gfxWindowsFonts.h b/gfx/thebes/public/gfxWindowsFonts.h\\nindex cde9632..7cb35c7 100644\\n--- a/gfx/thebes/public/gfxWindowsFonts.h\\n+++ b/gfx/thebes/public/gfxWindowsFonts.h\\n@@ -533,7 +533,7 @@ private:\\n \\n     nsRefPtr<FontEntry> mFontEntry;\\n     \\n-    virtual PRBool SetupCairoFont(gfxContext *aContext);\\n+    virtual PRBool SetupCairoFont(cairo_t *aCR);\\n };\\n \\n /**********************************************************************\\ndiff --git a/gfx/thebes/src/gfxAtsuiFonts.cpp b/gfx/thebes/src/gfxAtsuiFonts.cpp\\nindex f6de6aa..e9686fa 100644\\n--- a/gfx/thebes/src/gfxAtsuiFonts.cpp\\n+++ b/gfx/thebes/src/gfxAtsuiFonts.cpp\\n@@ -171,8 +171,8 @@ gfxAtsuiFont::InitMetrics(ATSUFontID aFontID, ATSFontRef aFontRef)\\n \\n     mMetrics.emHeight = size;\\n \\n-    mMetrics.maxAscent = NS_ceil(atsMetrics.ascent * size);\\n-    mMetrics.maxDescent = NS_ceil(- (atsMetrics.descent * size));\\n+    mMetrics.maxAscent = atsMetrics.ascent * size;\\n+    mMetrics.maxDescent = - (atsMetrics.descent * size);\\n \\n     mMetrics.maxHeight = mMetrics.maxAscent + mMetrics.maxDescent;\\n \\n@@ -226,7 +226,7 @@ gfxAtsuiFont::InitMetrics(ATSUFontID aFontID, ATSFontRef aFontRef)\\n }\\n \\n PRBool\\n-gfxAtsuiFont::SetupCairoFont(gfxContext *aContext)\\n+gfxAtsuiFont::SetupCairoFont(cairo_t *aCR)\\n {\\n     cairo_scaled_font_t *scaledFont = CairoScaledFont();\\n     if (cairo_scaled_font_status(scaledFont) != CAIRO_STATUS_SUCCESS) {\\n@@ -234,7 +234,7 @@ gfxAtsuiFont::SetupCairoFont(gfxContext *aContext)\\n         // the cairo_t, precluding any further drawing.\\n         return PR_FALSE;\\n     }\\n-    cairo_set_scaled_font(aContext->GetCairo(), scaledFont);\\n+    cairo_set_scaled_font(aCR, scaledFont);\\n     return PR_TRUE;\\n }\\n \\n@@ -329,35 +329,6 @@ CreateFontFallbacksFromFontList(nsTArray< nsRefPtr<gfxFont> > *aFonts,\\n     return status == noErr ? NS_OK : NS_ERROR_FAILURE;\\n }\\n \\n-void\\n-gfxAtsuiFont::SetupGlyphExtents(gfxContext *aContext, PRUint32 aGlyphID,\\n-        PRBool aNeedTight, gfxGlyphExtents *aExtents)\\n-{\\n-    ATSGlyphScreenMetrics metrics;\\n-    GlyphID glyph = aGlyphID;\\n-    OSStatus err = ATSUGlyphGetScreenMetrics(mATSUStyle, 1, &glyph, 0, false, false,\\n-                                             &metrics);\\n-    if (err != noErr)\\n-        return;\\n-    PRUint32 appUnitsPerDevUnit = aExtents->GetAppUnitsPerDevUnit();\\n-    \\n-    if (!aNeedTight && metrics.topLeft.x >= 0 &&\\n-        -metrics.topLeft.y + metrics.height <= mMetrics.maxAscent &&\\n-        metrics.topLeft.y <= mMetrics.maxDescent) {\\n-        PRUint32 appUnitsWidth =\\n-        \\tPRUint32(NS_ceil((metrics.topLeft.x + metrics.width)*appUnitsPerDevUnit));\\n-        if (appUnitsWidth < gfxGlyphExtents::INVALID_WIDTH) {\\n-            aExtents->SetContainedGlyphWidthAppUnits(aGlyphID, PRUint16(appUnitsWidth));\\n-            return;\\n-        }\\n-    }\\n-\\n-    double d2a = appUnitsPerDevUnit;\\n-    gfxRect bounds(metrics.topLeft.x*d2a, (metrics.topLeft.y - metrics.height)*d2a,\\n-                   metrics.width*d2a, metrics.height*d2a);\\n-    aExtents->SetTightGlyphExtents(aGlyphID, bounds);\\n-}\\n-\\n PRBool \\n gfxAtsuiFont::HasMirroringInfo()\\n {\\n@@ -601,8 +572,6 @@ gfxAtsuiFontGroup::MakeTextRun(const PRUnichar *aString, PRUint32 aLength,\\n             break;\\n         textRun->ResetGlyphRuns();\\n     }\\n-    \\n-    textRun->FetchGlyphExtents(aParams->mContext);\\n \\n     return textRun;\\n }\\n@@ -645,8 +614,6 @@ gfxAtsuiFontGroup::MakeTextRun(const PRUint8 *aString, PRUint32 aLength,\\n         textRun->ResetGlyphRuns();\\n     }\\n \\n-    textRun->FetchGlyphExtents(aParams->mContext);\\n-\\n     return textRun;\\n }\\n \\ndiff --git a/gfx/thebes/src/gfxFont.cpp b/gfx/thebes/src/gfxFont.cpp\\nindex 3623bca..925c94f 100644\\n--- a/gfx/thebes/src/gfxFont.cpp\\n+++ b/gfx/thebes/src/gfxFont.cpp\\n@@ -162,17 +162,6 @@ gfxFont::gfxFont(const nsAString &aName, const gfxFontStyle *aFontStyle) :\\n {\\n }\\n \\n-gfxFont::~gfxFont()\\n-{\\n-    PRUint32 i;\\n-    // We destroy the contents of mGlyphExtentsArray explicitly instead of\\n-    // using nsAutoPtr because VC++ can't deal with nsTArrays of nsAutoPtrs\\n-    // of classes that lack a proper copy constructor\\n-    for (i = 0; i < mGlyphExtentsArray.Length(); ++i) {\\n-        delete mGlyphExtentsArray[i];\\n-    }\\n-}\\n-\\n /**\\n  * A helper function in case we need to do any rounding or other\\n  * processing here.\\n@@ -224,13 +213,13 @@ gfxFont::Draw(gfxTextRun *aTextRun, PRUint32 aStart, PRUint32 aEnd,\\n     double x = aPt->x;\\n     double y = aPt->y;\\n \\n-    PRBool success = SetupCairoFont(aContext);\\n+    cairo_t *cr = aContext->GetCairo();\\n+    PRBool success = SetupCairoFont(cr);\\n     if (NS_UNLIKELY(!success))\\n         return;\\n \\n     GlyphBuffer glyphs;\\n     cairo_glyph_t *glyph;\\n-    cairo_t *cr = aContext->GetCairo();\\n     \\n     if (aSpacing) {\\n         x += direction*aSpacing[0].mBefore;\\n@@ -317,220 +306,53 @@ gfxFont::Draw(gfxTextRun *aTextRun, PRUint32 aStart, PRUint32 aEnd,\\n     *aPt = gfxPoint(x, y);\\n }\\n \\n-static void\\n-UnionWithXPoint(gfxRect *aRect, double aX)\\n-{\\n-    if (aX < aRect->pos.x) {\\n-        aRect->size.width += aRect->pos.x - aX;\\n-        aRect->pos.x = aX;\\n-    } else if (aX > aRect->XMost()) {\\n-        aRect->size.width = aX - aRect->pos.x;\\n-    }\\n-}\\n-\\n-static PRBool\\n-NeedsGlyphExtents(gfxTextRun *aTextRun)\\n-{\\n-    return (aTextRun->GetFlags() & gfxTextRunFactory::TEXT_OPTIMIZE_SPEED) == 0;\\n-    // return PR_TRUE;\\n-}\\n-\\n gfxFont::RunMetrics\\n gfxFont::Measure(gfxTextRun *aTextRun,\\n                  PRUint32 aStart, PRUint32 aEnd,\\n-                 PRBool aTightBoundingBox, gfxContext *aRefContext,\\n+                 PRBool aTightBoundingBox,\\n                  Spacing *aSpacing)\\n {\\n-    const gfxTextRun::CompressedGlyph *charGlyphs = aTextRun->GetCharacterGlyphs();\\n-    const PRUint32 appUnitsPerDevUnit = aTextRun->GetAppUnitsPerDevUnit();\\n-    PRBool isRTL = aTextRun->IsRightToLeft();\\n-    double direction = aTextRun->GetDirection();\\n-    // Current position in appunits\\n-    const gfxFont::Metrics& fontMetrics = GetMetrics();\\n-\\n-    RunMetrics metrics;\\n-    metrics.mAscent = fontMetrics.maxAscent*appUnitsPerDevUnit;\\n-    metrics.mDescent = fontMetrics.maxDescent*appUnitsPerDevUnit;\\n-    metrics.mAdvanceWidth = 0;\\n-    if (aTightBoundingBox) {\\n-        metrics.mBoundingBox = gfxRect(0, 0, 0, 0);\\n-    } else {\\n-        metrics.mBoundingBox = gfxRect(0, -metrics.mAscent, 0, metrics.mAscent + metrics.mDescent);\\n-    }\\n-\\n-    gfxGlyphExtents *extents =\\n-        (!aTightBoundingBox && !NeedsGlyphExtents(aTextRun) && !aTextRun->HasDetailedGlyphs()) ? nsnull\\n-        : GetOrCreateGlyphExtents(aTextRun->GetAppUnitsPerDevUnit());\\n-    double x = 0;\\n-    if (aSpacing) {\\n-        x += direction*aSpacing[0].mBefore;\\n-    }\\n+    // XXX temporary code, does not handle glyphs outside the font-box\\n+    // XXX comment out the assertion for now since it fires too much\\n+    // NS_ASSERTION(!(aTextRun->GetFlags() & gfxTextRunFactory::TEXT_NEED_BOUNDING_BOX),\\n+    //              \\\"Glyph extents not yet supported\\\");\\n+    PRInt32 advance = 0;\\n     PRUint32 i;\\n+    const gfxTextRun::CompressedGlyph *charGlyphs = aTextRun->GetCharacterGlyphs();\\n     for (i = aStart; i < aEnd; ++i) {\\n-        const gfxTextRun::CompressedGlyph *glyphData = &charGlyphs[i];\\n-        if (glyphData->IsSimpleGlyph()) {\\n-            double advance = glyphData->GetSimpleAdvance();\\n-            // Only get the real glyph horizontal extent if we were asked\\n-            // for the tight bounding box or we're in quality mode\\n-            if (aTightBoundingBox || NeedsGlyphExtents(aTextRun)) {\\n-                PRUint32 glyphIndex = glyphData->GetSimpleGlyph();\\n-                PRUint16 extentsWidth = extents->GetContainedGlyphWidthAppUnits(glyphIndex);\\n-                if (extentsWidth != gfxGlyphExtents::INVALID_WIDTH && !aTightBoundingBox) {\\n-                    UnionWithXPoint(&metrics.mBoundingBox, x + direction*extentsWidth);\\n-                } else {\\n-                    gfxRect glyphRect =\\n-                        extents->GetTightGlyphExtentsAppUnits(this, aRefContext, glyphIndex);\\n-                    if (isRTL) {\\n-                        glyphRect.pos.x -= advance;\\n-                    }\\n-                    glyphRect.pos.x += x;\\n-                    metrics.mBoundingBox = metrics.mBoundingBox.Union(glyphRect);\\n-                }\\n-            }\\n-            x += direction*advance;\\n-        } else if (glyphData->IsComplexCluster()) {\\n-            const gfxTextRun::DetailedGlyph *details = aTextRun->GetDetailedGlyphs(i);\\n-            for (;;) {\\n-                PRUint32 glyphIndex = details->mGlyphID;\\n-                gfxPoint glyphPt(x + details->mXOffset, details->mYOffset);\\n-                double advance = details->mAdvance;\\n-                gfxRect glyphRect =\\n-                    extents->GetTightGlyphExtentsAppUnits(this, aRefContext, glyphIndex);\\n-                if (isRTL) {\\n-                    glyphRect.pos.x -= advance;\\n-                }\\n-                glyphRect.pos.x += x;\\n-                metrics.mBoundingBox = metrics.mBoundingBox.Union(glyphRect);\\n-                x += direction*advance;\\n-                if (details->mIsLastGlyph)\\n-                    break;\\n-                ++details;\\n-            }\\n-        } else if (glyphData->IsMissing()) {\\n-            const gfxTextRun::DetailedGlyph *details = aTextRun->GetDetailedGlyphs(i);\\n-            if (details) {\\n-                double advance = details->mAdvance;\\n-                gfxRect glyphRect(x, -metrics.mAscent, advance, metrics.mAscent);\\n-                if (isRTL) {\\n-                    glyphRect.pos.x -= advance;\\n+        gfxTextRun::CompressedGlyph g = charGlyphs[i];\\n+        if (g.IsClusterStart()) {\\n+            if (g.IsSimpleGlyph()) {\\n+                advance += charGlyphs[i].GetSimpleAdvance();\\n+            } else if (g.IsComplexOrMissing()) {\\n+                const gfxTextRun::DetailedGlyph *details = aTextRun->GetDetailedGlyphs(i);\\n+                while (details) {\\n+                    advance += details->mAdvance;\\n+                    if (details->mIsLastGlyph)\\n+                        break;\\n+                    ++details;\\n                 }\\n-                metrics.mBoundingBox = metrics.mBoundingBox.Union(glyphRect);\\n-                x += direction*advance;\\n             }\\n         }\\n-        // Every other glyph type is ignored\\n-        if (aSpacing) {\\n-            double space = aSpacing[i - aStart].mAfter;\\n-            if (i + 1 < aEnd) {\\n-                space += aSpacing[i + 1 - aStart].mBefore;\\n-            }\\n-            x += direction*space;\\n-        }\\n-    }\\n-\\n-    if (!aTightBoundingBox) {\\n-        // Make sure the non-tight bounding box includes the entire advance\\n-        UnionWithXPoint(&metrics.mBoundingBox, x);\\n     }\\n-    if (isRTL) {\\n-        metrics.mBoundingBox.pos.x -= x;\\n-    }\\n-\\n-    metrics.mAdvanceWidth = x*direction;\\n-    return metrics;\\n-}\\n \\n-gfxGlyphExtents *\\n-gfxFont::GetOrCreateGlyphExtents(PRUint32 aAppUnitsPerDevUnit) {\\n-    PRUint32 i;\\n-    for (i = 0; i < mGlyphExtentsArray.Length(); ++i) {\\n-        if (mGlyphExtentsArray[i]->GetAppUnitsPerDevUnit() == aAppUnitsPerDevUnit)\\n-            return mGlyphExtentsArray[i];\\n-    }\\n-    gfxGlyphExtents *glyphExtents = new gfxGlyphExtents(aAppUnitsPerDevUnit);\\n-    if (glyphExtents) {\\n-        mGlyphExtentsArray.AppendElement(glyphExtents);\\n-        // Initialize the extents of a space glyph, assuming that spaces don't\\n-        // render anything!\\n-        glyphExtents->SetContainedGlyphWidthAppUnits(GetSpaceGlyph(), 0);\\n-    }\\n-    return glyphExtents;\\n-}\\n-\\n-void\\n-gfxFont::SetupGlyphExtents(gfxContext *aContext, PRUint32 aGlyphID, PRBool aNeedTight,\\n-                           gfxGlyphExtents *aExtents)\\n-{\\n-    cairo_glyph_t glyph;\\n-    glyph.index = aGlyphID;\\n-    glyph.x = 0;\\n-    glyph.y = 0;\\n-    cairo_text_extents_t extents;\\n-    cairo_glyph_extents(aContext->GetCairo(), &glyph, 1, &extents);\\n-\\n-    const Metrics& fontMetrics = GetMetrics();\\n-    PRUint32 appUnitsPerDevUnit = aExtents->GetAppUnitsPerDevUnit();\\n-    if (!aNeedTight && extents.x_bearing >= 0 &&\\n-        extents.y_bearing >= -fontMetrics.maxAscent &&\\n-        extents.height + extents.y_bearing <= fontMetrics.maxDescent) {\\n-        PRUint32 appUnitsWidth =\\n-            PRUint32(NS_ceil((extents.x_bearing + extents.width)*appUnitsPerDevUnit));\\n-        if (appUnitsWidth < gfxGlyphExtents::INVALID_WIDTH) {\\n-            aExtents->SetContainedGlyphWidthAppUnits(aGlyphID, PRUint16(appUnitsWidth));\\n-            return;\\n-        }\\n-    }\\n-\\n-    double d2a = appUnitsPerDevUnit;\\n-    gfxRect bounds(extents.x_bearing*d2a, extents.y_bearing*d2a,\\n-                   extents.width*d2a, extents.height*d2a);\\n-    aExtents->SetTightGlyphExtents(aGlyphID, bounds);\\n-}\\n-\\n-gfxRect\\n-gfxGlyphExtents::GetTightGlyphExtentsAppUnits(gfxFont *aFont,\\n-    gfxContext *aContext, PRUint32 aGlyphID)\\n-{\\n-    HashEntry *entry = mTightGlyphExtents.GetEntry(aGlyphID);\\n-    if (!entry) {\\n-        aFont->SetupCairoFont(aContext);\\n-        aFont->SetupGlyphExtents(aContext, aGlyphID, PR_TRUE, this);\\n-        entry = mTightGlyphExtents.GetEntry(aGlyphID);\\n-        if (!entry) {\\n-            NS_WARNING(\\\"Could not get glyph extents\\\");\\n-            return gfxRect(0,0,0,0);\\n-        }\\n-    }\\n-    \\n-    return gfxRect(entry->x, entry->y, entry->width, entry->height);\\n-}\\n-\\n-void\\n-gfxGlyphExtents::SetContainedGlyphWidthAppUnits(PRUint32 aGlyphID, PRUint16 aWidth)\\n-{\\n-    PRUint32 len = mWidthsForContainedGlyphsAppUnits.Length();\\n-    if (aGlyphID >= len) {\\n-        PRUint16 *elems = mWidthsForContainedGlyphsAppUnits.AppendElements(aGlyphID + 1 - len);\\n-        if (!elems)\\n-            return;\\n-        PRUint32 i;\\n-        for (i = len; i < aGlyphID; ++i) {\\n-            mWidthsForContainedGlyphsAppUnits[i] = INVALID_WIDTH;\\n+    gfxFloat floatAdvance = advance;\\n+    if (aSpacing) {\\n+        for (i = 0; i < aEnd - aStart; ++i) {\\n+            floatAdvance += aSpacing[i].mBefore + aSpacing[i].mAfter;\\n         }\\n     }\\n-    mWidthsForContainedGlyphsAppUnits[aGlyphID] = aWidth;\\n-}\\n-\\n-void\\n-gfxGlyphExtents::SetTightGlyphExtents(PRUint32 aGlyphID, const gfxRect& aExtentsAppUnits)\\n-{\\n-    HashEntry *entry = mTightGlyphExtents.PutEntry(aGlyphID);\\n-    if (!entry)\\n-        return;\\n-    entry->x = aExtentsAppUnits.pos.x;\\n-    entry->y = aExtentsAppUnits.pos.y;\\n-    entry->width = aExtentsAppUnits.size.width;\\n-    entry->height = aExtentsAppUnits.size.height;\\n+    RunMetrics metrics;\\n+    const gfxFont::Metrics& fontMetrics = GetMetrics();\\n+    metrics.mAdvanceWidth = floatAdvance;\\n+    const PRUint32 appUnitsPerDevUnit = aTextRun->GetAppUnitsPerDevUnit();\\n+    metrics.mAscent = fontMetrics.maxAscent*appUnitsPerDevUnit;\\n+    gfxFloat descentForUnderline =\\n+        NS_round(fontMetrics.underlineSize) + NS_round(metrics.mAscent - fontMetrics.underlineOffset) - metrics.mAscent;\\n+    metrics.mDescent = PR_MAX(fontMetrics.maxDescent, descentForUnderline)*appUnitsPerDevUnit;\\n+    metrics.mBoundingBox =\\n+        gfxRect(0, -metrics.mAscent, floatAdvance, metrics.mAscent + metrics.mDescent);\\n+    return metrics;\\n }\\n \\n gfxFontGroup::gfxFontGroup(const nsAString& aFamilies, const gfxFontStyle *aStyle)\\n@@ -757,9 +579,6 @@ gfxFontGroup::MakeSpaceTextRun(const Parameters *aParams, PRUint32 aFlags)\\n \\n     gfxFont *font = GetFontAt(0);\\n     textRun->SetSpaceGlyph(font, aParams->mContext, 0);\\n-    // Note that the gfxGlyphExtents glyph bounds storage for the font will\\n-    // always contain an entry for the font's space glyph, so we don't have\\n-    // to call FetchGlyphExtents here.\\n     return textRun.forget();\\n }\\n \\n@@ -1284,15 +1103,14 @@ gfxTextRun::DrawToPath(gfxContext *aContext, gfxPoint aPt,\\n void\\n gfxTextRun::AccumulateMetricsForRun(gfxFont *aFont,\\n                                     PRUint32 aStart, PRUint32 aEnd,\\n-                                    PRBool aTight, gfxContext *aRefContext,\\n-                                    PropertyProvider *aProvider,\\n+                                    PRBool aTight, PropertyProvider *aProvider,\\n                                     PRUint32 aSpacingStart, PRUint32 aSpacingEnd,\\n                                     Metrics *aMetrics)\\n {\\n     nsAutoTArray<PropertyProvider::Spacing,200> spacingBuffer;\\n     PRBool haveSpacing = GetAdjustedSpacingArray(aStart, aEnd, aProvider,\\n         aSpacingStart, aSpacingEnd, &spacingBuffer);\\n-    Metrics metrics = aFont->Measure(this, aStart, aEnd, aTight, aRefContext,\\n+    Metrics metrics = aFont->Measure(this, aStart, aEnd, aTight,\\n                                      haveSpacing ? spacingBuffer.Elements() : nsnull);\\n  \\n     if (IsRightToLeft()) {\\n@@ -1305,7 +1123,7 @@ gfxTextRun::AccumulateMetricsForRun(gfxFont *aFont,\\n \\n void\\n gfxTextRun::AccumulatePartialLigatureMetrics(gfxFont *aFont,\\n-    PRUint32 aStart, PRUint32 aEnd, PRBool aTight, gfxContext *aRefContext,\\n+    PRUint32 aStart, PRUint32 aEnd, PRBool aTight,\\n     PropertyProvider *aProvider, Metrics *aMetrics)\\n {\\n     if (aStart >= aEnd)\\n@@ -1318,7 +1136,7 @@ gfxTextRun::AccumulatePartialLigatureMetrics(gfxFont *aFont,\\n     // First measure the complete ligature\\n     Metrics metrics;\\n     AccumulateMetricsForRun(aFont, data.mLigatureStart, data.mLigatureEnd,\\n-                            aTight, aRefContext, aProvider, aStart, aEnd, &metrics);\\n+                            aTight, aProvider, aStart, aEnd, &metrics);\\n     \\n     // Clip the bounding box to the ligature part\\n     gfxFloat bboxLeft = metrics.mBoundingBox.X();\\n@@ -1346,7 +1164,7 @@ gfxTextRun::AccumulatePartialLigatureMetrics(gfxFont *aFont,\\n \\n gfxTextRun::Metrics\\n gfxTextRun::MeasureText(PRUint32 aStart, PRUint32 aLength,\\n-                        PRBool aTightBoundingBox, gfxContext *aRefContext,\\n+                        PRBool aTightBoundingBox,\\n                         PropertyProvider *aProvider)\\n {\\n     NS_ASSERTION(aStart + aLength <= mCharacterCount, \\\"Substring out of range\\\");\\n@@ -1362,7 +1180,7 @@ gfxTextRun::MeasureText(PRUint32 aStart, PRUint32 aLength,\\n         ShrinkToLigatureBoundaries(&ligatureRunStart, &ligatureRunEnd);\\n \\n         AccumulatePartialLigatureMetrics(font, start, ligatureRunStart,\\n-            aTightBoundingBox, aRefContext, aProvider, &accumulatedMetrics);\\n+            aTightBoundingBox, aProvider, &accumulatedMetrics);\\n \\n         // XXX This sucks. We have to get glyph extents just so we can detect\\n         // glyphs outside the font box, even when aTightBoundingBox is false,\\n@@ -1370,12 +1188,12 @@ gfxTextRun::MeasureText(PRUint32 aStart, PRUint32 aLength,\\n         // by getting some ascent/descent from the font and using our stored\\n         // advance widths.\\n         AccumulateMetricsForRun(font,\\n-            ligatureRunStart, ligatureRunEnd, aTightBoundingBox,\\n-            aRefContext, aProvider, ligatureRunStart, ligatureRunEnd,\\n+            ligatureRunStart, ligatureRunEnd, aTightBoundingBox, aProvider,\\n+            ligatureRunStart, ligatureRunEnd,\\n             &accumulatedMetrics);\\n \\n         AccumulatePartialLigatureMetrics(font, ligatureRunEnd, end,\\n-            aTightBoundingBox, aRefContext, aProvider, &accumulatedMetrics);\\n+            aTightBoundingBox, aProvider, &accumulatedMetrics);\\n     }\\n \\n     return accumulatedMetrics;\\n@@ -1390,7 +1208,6 @@ gfxTextRun::BreakAndMeasureText(PRUint32 aStart, PRUint32 aMaxLength,\\n                                 PRBool aSuppressInitialBreak,\\n                                 gfxFloat *aTrimWhitespace,\\n                                 Metrics *aMetrics, PRBool aTightBoundingBox,\\n-                                gfxContext *aRefContext,\\n                                 PRBool *aUsedHyphenation,\\n                                 PRUint32 *aLastBreak)\\n {\\n@@ -1532,8 +1349,7 @@ gfxTextRun::BreakAndMeasureText(PRUint32 aStart, PRUint32 aMaxLength,\\n     }\\n \\n     if (aMetrics) {\\n-        *aMetrics = MeasureText(aStart, charsFit - trimmableChars,\\n-    \\t    aTightBoundingBox, aRefContext, aProvider);\\n+        *aMetrics = MeasureText(aStart, charsFit - trimmableChars, aTightBoundingBox, aProvider);\\n     }\\n     if (aTrimWhitespace) {\\n         *aTrimWhitespace = trimmableAdvance;\\n@@ -1902,55 +1718,3 @@ gfxTextRun::SetSpaceGlyph(gfxFont *aFont, gfxContext *aContext, PRUint32 aCharIn\\n     g.SetSimpleGlyph(spaceWidthAppUnits, spaceGlyph);\\n     SetCharacterGlyph(aCharIndex, g);\\n }\\n-\\n-void\\n-gfxTextRun::FetchGlyphExtents(gfxContext *aRefContext)\\n-{\\n-    if (!NeedsGlyphExtents(this) && !mDetailedGlyphs)\\n-        return;\\n-\\n-    PRUint32 i;\\n-    CompressedGlyph *charGlyphs = mCharacterGlyphs;\\n-    for (i = 0; i < mGlyphRuns.Length(); ++i) {\\n-        gfxFont *font = mGlyphRuns[i].mFont;\\n-        PRUint32 start = mGlyphRuns[i].mCharacterOffset;\\n-        PRUint32 end = i + 1 < mGlyphRuns.Length()\\n-            ? mGlyphRuns[i + 1].mCharacterOffset : GetLength();\\n-        PRBool fontIsSetup = PR_FALSE;\\n-        PRUint32 j;\\n-        gfxGlyphExtents *extents = font->GetOrCreateGlyphExtents(mAppUnitsPerDevUnit);\\n-  \\n-        for (j = start; j < end; ++j) {\\n-            const gfxTextRun::CompressedGlyph *glyphData = &charGlyphs[j];\\n-            if (glyphData->IsSimpleGlyph()) {\\n-                // If we're in speed mode, don't set up glyph extents here; we'll\\n-                // just return \\\"optimistic\\\" glyph bounds later\\n-                if (NeedsGlyphExtents(this)) {\\n-                    PRUint32 glyphIndex = glyphData->GetSimpleGlyph();\\n-                    if (!extents->IsGlyphKnown(glyphIndex)) {\\n-                        if (!fontIsSetup) {\\n-                            font->SetupCairoFont(aRefContext);\\n-                            fontIsSetup = PR_TRUE;\\n-                        }\\n-                        font->SetupGlyphExtents(aRefContext, glyphIndex, PR_FALSE, extents);\\n-                    }\\n-                }\\n-            } else if (glyphData->IsComplexCluster()) {\\n-                const gfxTextRun::DetailedGlyph *details = GetDetailedGlyphs(j);\\n-                for (;;) {\\n-                    PRUint32 glyphIndex = details->mGlyphID;\\n-                    if (!extents->IsGlyphKnownWithTightExtents(glyphIndex)) {\\n-                        if (!fontIsSetup) {\\n-                            font->SetupCairoFont(aRefContext);\\n-                            fontIsSetup = PR_TRUE;\\n-                        }\\n-                        font->SetupGlyphExtents(aRefContext, glyphIndex, PR_TRUE, extents);\\n-                    }\\n-                    if (details->mIsLastGlyph)\\n-                        break;\\n-                    ++details;\\n-                }\\n-            }\\n-        }\\n-    }\\n-}\\ndiff --git a/gfx/thebes/src/gfxPangoFonts.cpp b/gfx/thebes/src/gfxPangoFonts.cpp\\nindex 1696cd1..e7f3476 100644\\n--- a/gfx/thebes/src/gfxPangoFonts.cpp\\n+++ b/gfx/thebes/src/gfxPangoFonts.cpp\\n@@ -828,7 +828,6 @@ gfxPangoFontGroup::MakeTextRun(const PRUint8 *aString, PRUint32 aLength,\\n         AppendUTF16toUTF8(unicodeString, utf8);\\n         InitTextRun(run, utf8.get(), utf8.Length(), headerLen, PR_TRUE);\\n     }\\n-    run->FetchGlyphExtents(aParams->mContext);\\n     return run;\\n }\\n \\n@@ -867,7 +866,6 @@ gfxPangoFontGroup::MakeTextRun(const PRUnichar *aString, PRUint32 aLength,\\n     }\\n #endif\\n     InitTextRun(run, utf8.get(), utf8.Length(), headerLen, is8Bit);\\n-    run->FetchGlyphExtents(aParams->mContext);\\n     return run;\\n }\\n \\n@@ -918,11 +916,10 @@ CreateScaledFont(cairo_t *aCR, cairo_matrix_t *aCTM, PangoFont *aPangoFont)\\n }\\n \\n PRBool\\n-gfxPangoFont::SetupCairoFont(gfxContext *aContext)\\n+gfxPangoFont::SetupCairoFont(cairo_t *aCR)\\n {\\n-    cairo_t *cr = aContext->GetCairo();\\n     cairo_matrix_t currentCTM;\\n-    cairo_get_matrix(cr, &currentCTM);\\n+    cairo_get_matrix(aCR, &currentCTM);\\n \\n     if (mCairoFont) {\\n         // Need to validate that its CTM is OK\\n@@ -936,14 +933,14 @@ gfxPangoFont::SetupCairoFont(gfxContext *aContext)\\n         }\\n     }\\n     if (!mCairoFont) {\\n-        mCairoFont = CreateScaledFont(cr, &currentCTM, GetPangoFont());\\n+        mCairoFont = CreateScaledFont(aCR, &currentCTM, GetPangoFont());\\n     }\\n     if (cairo_scaled_font_status(mCairoFont) != CAIRO_STATUS_SUCCESS) {\\n         // Don't cairo_set_scaled_font as that would propagate the error to\\n         // the cairo_t, precluding any further drawing.\\n         return PR_FALSE;\\n     }\\n-    cairo_set_scaled_font(cr, mCairoFont);\\n+    cairo_set_scaled_font(aCR, mCairoFont);\\n     return PR_TRUE;\\n }\\n \\ndiff --git a/gfx/thebes/src/gfxWindowsFonts.cpp b/gfx/thebes/src/gfxWindowsFonts.cpp\\nindex 69d811a..4e7d5bc 100644\\n--- a/gfx/thebes/src/gfxWindowsFonts.cpp\\n+++ b/gfx/thebes/src/gfxWindowsFonts.cpp\\n@@ -434,7 +434,7 @@ gfxWindowsFont::Draw(gfxTextRun *aTextRun, PRUint32 aStart, PRUint32 aEnd,\\n }\\n \\n PRBool\\n-gfxWindowsFont::SetupCairoFont(gfxContext *aContext)\\n+gfxWindowsFont::SetupCairoFont(cairo_t *aCR)\\n {\\n     cairo_scaled_font_t *scaledFont = CairoScaledFont();\\n     if (cairo_scaled_font_status(scaledFont) != CAIRO_STATUS_SUCCESS) {\\n@@ -442,7 +442,7 @@ gfxWindowsFont::SetupCairoFont(gfxContext *aContext)\\n         // the cairo_t, precluding any further drawing.\\n         return PR_FALSE;\\n     }\\n-    cairo_set_scaled_font(aContext->GetCairo(), scaledFont);\\n+    cairo_set_scaled_font(aCR, scaledFont);\\n     return PR_TRUE;\\n }\\n \\n@@ -566,8 +566,6 @@ gfxWindowsFontGroup::MakeTextRun(const PRUnichar *aString, PRUint32 aLength,\\n     else\\n         InitTextRunGDI(aParams->mContext, textRun, aString, aLength);\\n \\n-    textRun->FetchGlyphExtents(aParams->mContext);\\n-\\n     return textRun;\\n }\\n \\n@@ -607,8 +605,6 @@ gfxWindowsFontGroup::MakeTextRun(const PRUint8 *aString, PRUint32 aLength,\\n         }\\n     }\\n \\n-    textRun->FetchGlyphExtents(aParams->mContext);\\n-\\n     return textRun;\\n }\\n \\ndiff --git a/layout/generic/nsBRFrame.cpp b/layout/generic/nsBRFrame.cpp\\nindex e4deda3..5c819cb 100644\\n--- a/layout/generic/nsBRFrame.cpp\\n+++ b/layout/generic/nsBRFrame.cpp\\n@@ -184,8 +184,6 @@ BRFrame::Reflow(nsPresContext* aPresContext,\\n   else {\\n     aStatus = NS_FRAME_COMPLETE;\\n   }\\n-  \\n-  aMetrics.mOverflowArea = nsRect(0, 0, aMetrics.width, aMetrics.height);\\n \\n   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);\\n   return NS_OK;\\ndiff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp\\nindex fda6b7d..ffe0434 100644\\n--- a/layout/generic/nsLineLayout.cpp\\n+++ b/layout/generic/nsLineLayout.cpp\\n@@ -65,7 +65,6 @@\\n #include \\\"nsTextFragment.h\\\"\\n #include \\\"nsBidiUtils.h\\\"\\n #include \\\"nsLayoutUtils.h\\\"\\n-#include \\\"nsTextFrame.h\\\"\\n \\n #ifdef DEBUG\\n #undef  NOISY_HORIZONTAL_ALIGN\\n@@ -2421,10 +2420,6 @@ nsLineLayout::ApplyFrameJustification(PerSpanData* aPSD, FrameJustificationState\\n \\n           aState->mWidthForLettersProcessed = newAllocatedWidthForLetters;\\n         }\\n-        \\n-        if (dw) {\\n-          pfd->SetFlag(PFD_RECOMPUTEOVERFLOW, PR_TRUE);\\n-        }\\n       }\\n       else {\\n         if (nsnull != pfd->mSpan) {\\n@@ -2648,12 +2643,11 @@ nsLineLayout::RelativePositionFrames(PerSpanData* psd, nsRect& aCombinedArea)\\n       // aggregating it into our combined area.\\n       RelativePositionFrames(pfd->mSpan, r);\\n     } else {\\n-      r = pfd->mCombinedArea;\\n-      if (pfd->GetFlag(PFD_RECOMPUTEOVERFLOW)) {\\n-        nsTextFrame* f = static_cast<nsTextFrame*>(frame);\\n-        r = f->RecomputeOverflowRect();\\n-      }\\n-      frame->FinishAndStoreOverflow(&r, frame->GetSize());\\n+      // For simple text frames we take the union of the combined area\\n+      // and the width/height. I think the combined area should always\\n+      // equal the bounds in this case, but this is safe.\\n+      nsRect adjustedBounds(0, 0, pfd->mBounds.width, pfd->mBounds.height);\\n+      r.UnionRect(pfd->mCombinedArea, adjustedBounds);\\n \\n       // If we have something that's not an inline but with a complex frame\\n       // hierarchy inside that contains views, they need to be\\ndiff --git a/layout/generic/nsLineLayout.h b/layout/generic/nsLineLayout.h\\nindex 649f794..0b96848 100644\\n--- a/layout/generic/nsLineLayout.h\\n+++ b/layout/generic/nsLineLayout.h\\n@@ -502,7 +502,6 @@ protected:\\n #define PFD_ISNONEMPTYTEXTFRAME         0x00000004\\n #define PFD_ISNONWHITESPACETEXTFRAME    0x00000008\\n #define PFD_ISLETTERFRAME               0x00000010\\n-#define PFD_RECOMPUTEOVERFLOW           0x00000020\\n #define PFD_ISBULLET                    0x00000040\\n #define PFD_SKIPWHENTRIMMINGWHITESPACE  0x00000080\\n #define PFD_LASTFLAG                    PFD_SKIPWHENTRIMMINGWHITESPACE\\ndiff --git a/layout/generic/nsTextFrame.h b/layout/generic/nsTextFrame.h\\ndeleted file mode 100644\\nindex d7fe59e..0000000\\n--- a/layout/generic/nsTextFrame.h\\n+++ /dev/null\\n@@ -1,346 +0,0 @@\\n-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n-/* ***** BEGIN LICENSE BLOCK *****\\n- * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n- *\\n- * The contents of this file are subject to the Mozilla Public License Version\\n- * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n- * the License. You may obtain a copy of the License at\\n- * http://www.mozilla.org/MPL/\\n- *\\n- * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n- * for the specific language governing rights and limitations under the\\n- * License.\\n- *\\n- * The Original Code is mozilla.org code.\\n- *\\n- * The Initial Developer of the Original Code is\\n- * Netscape Communications Corporation.\\n- * Portions created by the Initial Developer are Copyright (C) 1998\\n- * the Initial Developer. All Rights Reserved.\\n- *\\n- * Contributor(s):\\n- *   Robert O'Callahan <robert@ocallahan.org>\\n- *   Roger B. Sidje <rbs@maths.uq.edu.au>\\n- *   Pierre Phaneuf <pp@ludusdesign.com>\\n- *   Prabhat Hegde <prabhat.hegde@sun.com>\\n- *   Tomi Leppikangas <tomi.leppikangas@oulu.fi>\\n- *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>\\n- *   Daniel Glazman <glazman@netscape.com>\\n- *   Neil Deakin <neil@mozdevgroup.com>\\n- *   Masayuki Nakano <masayuki@d-toybox.com>\\n- *   Mats Palmgren <mats.palmgren@bredband.net>\\n- *   Uri Bernstein <uriber@gmail.com>\\n- *   Stephen Blackheath <entangled.mooched.stephen@blacksapphire.com>\\n- *\\n- * Alternatively, the contents of this file may be used under the terms of\\n- * either of the GNU General Public License Version 2 or later (the \\\"GPL\\\"),\\n- * or the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n- * in which case the provisions of the GPL or the LGPL are applicable instead\\n- * of those above. If you wish to allow use of your version of this file only\\n- * under the terms of either the GPL or the LGPL, and not to allow others to\\n- * use your version of this file under the terms of the MPL, indicate your\\n- * decision by deleting the provisions above and replace them with the notice\\n- * and other provisions required by the GPL or the LGPL. If you do not delete\\n- * the provisions above, a recipient may use your version of this file under\\n- * the terms of any one of the MPL, the GPL or the LGPL.\\n- *\\n- * ***** END LICENSE BLOCK ***** */\\n-\\n-#ifndef nsTextFrame_h__\\n-#define nsTextFrame_h__\\n-\\n-#include \\\"nsFrame.h\\\"\\n-#include \\\"nsLineBox.h\\\"\\n-#include \\\"gfxFont.h\\\"\\n-#include \\\"gfxSkipChars.h\\\"\\n-\\n-class nsTextPaintStyle;\\n-class PropertyProvider;\\n-\\n-class nsTextFrame : public nsFrame {\\n-public:\\n-  nsTextFrame(nsStyleContext* aContext) : nsFrame(aContext)\\n-  {\\n-    NS_ASSERTION(mContentOffset == 0, \\\"Bogus content offset\\\");\\n-  }\\n-  \\n-  // nsIFrame\\n-  NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,\\n-                              const nsRect&           aDirtyRect,\\n-                              const nsDisplayListSet& aLists);\\n-\\n-  NS_IMETHOD Init(nsIContent*      aContent,\\n-                  nsIFrame*        aParent,\\n-                  nsIFrame*        aPrevInFlow);\\n-\\n-  virtual void Destroy();\\n-  \\n-  NS_IMETHOD GetCursor(const nsPoint& aPoint,\\n-                       nsIFrame::Cursor& aCursor);\\n-  \\n-  NS_IMETHOD CharacterDataChanged(nsPresContext* aPresContext,\\n-                                  nsIContent*     aChild,\\n-                                  PRBool          aAppend);\\n-                                  \\n-  NS_IMETHOD DidSetStyleContext();\\n-  \\n-  virtual nsIFrame* GetNextContinuation() const {\\n-    return mNextContinuation;\\n-  }\\n-  NS_IMETHOD SetNextContinuation(nsIFrame* aNextContinuation) {\\n-    NS_ASSERTION (!aNextContinuation || GetType() == aNextContinuation->GetType(),\\n-                  \\\"setting a next continuation with incorrect type!\\\");\\n-    NS_ASSERTION (!nsSplittableFrame::IsInNextContinuationChain(aNextContinuation, this),\\n-                  \\\"creating a loop in continuation chain!\\\");\\n-    mNextContinuation = aNextContinuation;\\n-    if (aNextContinuation)\\n-      aNextContinuation->RemoveStateBits(NS_FRAME_IS_FLUID_CONTINUATION);\\n-    return NS_OK;\\n-  }\\n-  virtual nsIFrame* GetNextInFlowVirtual() const { return GetNextInFlow(); }\\n-  nsIFrame* GetNextInFlow() const {\\n-    return mNextContinuation && (mNextContinuation->GetStateBits() & NS_FRAME_IS_FLUID_CONTINUATION) ? \\n-      mNextContinuation : nsnull;\\n-  }\\n-  NS_IMETHOD SetNextInFlow(nsIFrame* aNextInFlow) {\\n-    NS_ASSERTION (!aNextInFlow || GetType() == aNextInFlow->GetType(),\\n-                  \\\"setting a next in flow with incorrect type!\\\");\\n-    NS_ASSERTION (!nsSplittableFrame::IsInNextContinuationChain(aNextInFlow, this),\\n-                  \\\"creating a loop in continuation chain!\\\");\\n-    mNextContinuation = aNextInFlow;\\n-    if (aNextInFlow)\\n-      aNextInFlow->AddStateBits(NS_FRAME_IS_FLUID_CONTINUATION);\\n-    return NS_OK;\\n-  }\\n-  virtual nsIFrame* GetLastInFlow() const;\\n-  virtual nsIFrame* GetLastContinuation() const;\\n-  \\n-  virtual nsSplittableType GetSplittableType() const {\\n-    return NS_FRAME_SPLITTABLE;\\n-  }\\n-  \\n-  /**\\n-    * Get the \\\"type\\\" of the frame\\n-   *\\n-   * @see nsGkAtoms::textFrame\\n-   */\\n-  virtual nsIAtom* GetType() const;\\n-  \\n-  virtual PRBool IsFrameOfType(PRUint32 aFlags) const\\n-  {\\n-    // Set the frame state bit for text frames to mark them as replaced.\\n-    // XXX kipp: temporary\\n-    return nsFrame::IsFrameOfType(aFlags & ~(nsIFrame::eReplaced |\\n-                                             nsIFrame::eLineParticipant));\\n-  }\\n-\\n-#ifdef DEBUG\\n-  NS_IMETHOD List(FILE* out, PRInt32 aIndent) const;\\n-  NS_IMETHOD GetFrameName(nsAString& aResult) const;\\n-  NS_IMETHOD_(nsFrameState) GetDebugStateBits() const ;\\n-#endif\\n-  \\n-  virtual ContentOffsets CalcContentOffsetsFromFramePoint(nsPoint aPoint);\\n-   \\n-  NS_IMETHOD SetSelected(nsPresContext* aPresContext,\\n-                         nsIDOMRange *aRange,\\n-                         PRBool aSelected,\\n-                         nsSpread aSpread);\\n-  \\n-  virtual PRBool PeekOffsetNoAmount(PRBool aForward, PRInt32* aOffset);\\n-  virtual PRBool PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset);\\n-  virtual PRBool PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,\\n-                                PRInt32* aOffset, PeekWordState* aState);\\n-\\n-  NS_IMETHOD CheckVisibility(nsPresContext* aContext, PRInt32 aStartIndex, PRInt32 aEndIndex, PRBool aRecurse, PRBool *aFinished, PRBool *_retval);\\n-  \\n-  // Update offsets to account for new length. This may clear mTextRun.\\n-  void SetLength(PRInt32 aLength);\\n-  \\n-  NS_IMETHOD GetOffsets(PRInt32 &start, PRInt32 &end)const;\\n-  \\n-  virtual void AdjustOffsetsForBidi(PRInt32 start, PRInt32 end);\\n-  \\n-  NS_IMETHOD GetPointFromOffset(PRInt32                 inOffset,\\n-                                nsPoint*                outPoint);\\n-  \\n-  NS_IMETHOD  GetChildFrameContainingOffset(PRInt32     inContentOffset,\\n-                                            PRBool                  inHint,\\n-                                            PRInt32*                outFrameContentOffset,\\n-                                            nsIFrame*               *outChildFrame);\\n-  \\n-  virtual PRBool IsVisibleInSelection(nsISelection* aSelection);\\n-  \\n-  virtual PRBool IsEmpty();\\n-  virtual PRBool IsSelfEmpty() { return IsEmpty(); }\\n-  \\n-  /**\\n-   * @return PR_TRUE if this text frame ends with a newline character.  It\\n-   * should return PR_FALSE if this is not a text frame.\\n-   */\\n-  virtual PRBool HasTerminalNewline() const;\\n-  \\n-#ifdef ACCESSIBILITY\\n-  NS_IMETHOD GetAccessible(nsIAccessible** aAccessible);\\n-#endif\\n-  \\n-  virtual void MarkIntrinsicWidthsDirty();\\n-  virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);\\n-  virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext);\\n-  virtual void AddInlineMinWidth(nsIRenderingContext *aRenderingContext,\\n-                                 InlineMinWidthData *aData);\\n-  virtual void AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,\\n-                                  InlinePrefWidthData *aData);\\n-  virtual nsSize ComputeSize(nsIRenderingContext *aRenderingContext,\\n-                             nsSize aCBSize, nscoord aAvailableWidth,\\n-                             nsSize aMargin, nsSize aBorder, nsSize aPadding,\\n-                             PRBool aShrinkWrap);\\n-  NS_IMETHOD Reflow(nsPresContext* aPresContext,\\n-                    nsHTMLReflowMetrics& aMetrics,\\n-                    const nsHTMLReflowState& aReflowState,\\n-                    nsReflowStatus& aStatus);\\n-  virtual PRBool CanContinueTextRun() const;\\n-  NS_IMETHOD TrimTrailingWhiteSpace(nsPresContext* aPresContext,\\n-                                    nsIRenderingContext& aRC,\\n-                                    nscoord& aDeltaWidth,\\n-                                    PRBool& aLastCharIsJustifiable);\\n-  virtual nsresult GetRenderedText(nsAString* aString = nsnull,\\n-                                   gfxSkipChars* aSkipChars = nsnull,\\n-                                   gfxSkipCharsIterator* aSkipIter = nsnull,\\n-                                   PRUint32 aSkippedStartOffset = 0,\\n-                                   PRUint32 aSkippedMaxLength = PR_UINT32_MAX);\\n-\\n-  nsRect RecomputeOverflowRect();\\n-\\n-  void AddInlineMinWidthForFlow(nsIRenderingContext *aRenderingContext,\\n-                                nsIFrame::InlineMinWidthData *aData);\\n-  void AddInlinePrefWidthForFlow(nsIRenderingContext *aRenderingContext,\\n-                                 InlinePrefWidthData *aData);\\n-\\n-  gfxFloat GetSnappedBaselineY(gfxContext* aContext, gfxFloat aY);\\n-\\n-  // primary frame paint method called from nsDisplayText\\n-  void PaintText(nsIRenderingContext* aRenderingContext, nsPoint aPt,\\n-                 const nsRect& aDirtyRect);\\n-  // helper: paint quirks-mode CSS text decorations\\n-  void PaintTextDecorations(gfxContext* aCtx, const gfxRect& aDirtyRect,\\n-                            const gfxPoint& aFramePt,\\n-                            const gfxPoint& aTextBaselinePt,\\n-                            nsTextPaintStyle& aTextStyle,\\n-                            PropertyProvider& aProvider);\\n-  // helper: paint text frame when we're impacted by at least one selection.\\n-  // Return PR_FALSE if the text was not painted and we should continue with\\n-  // the fast path.\\n-  PRBool PaintTextWithSelection(gfxContext* aCtx,\\n-                                const gfxPoint& aFramePt,\\n-                                const gfxPoint& aTextBaselinePt,\\n-                                const gfxRect& aDirtyRect,\\n-                                PropertyProvider& aProvider,\\n-                                nsTextPaintStyle& aTextPaintStyle);\\n-  // helper: paint text with foreground and background colors determined\\n-  // by selection(s). Also computes a mask of all selection types applying to\\n-  // our text, returned in aAllTypes.\\n-  void PaintTextWithSelectionColors(gfxContext* aCtx,\\n-                                    const gfxPoint& aFramePt,\\n-                                    const gfxPoint& aTextBaselinePt,\\n-                                    const gfxRect& aDirtyRect,\\n-                                    PropertyProvider& aProvider,\\n-                                    nsTextPaintStyle& aTextPaintStyle,\\n-                                    SelectionDetails* aDetails,\\n-                                    SelectionType* aAllTypes);\\n-  // helper: paint text decorations for text selected by aSelectionType\\n-  void PaintTextSelectionDecorations(gfxContext* aCtx,\\n-                                     const gfxPoint& aFramePt,\\n-                                     const gfxPoint& aTextBaselinePt,\\n-                                     const gfxRect& aDirtyRect,\\n-                                     PropertyProvider& aProvider,\\n-                                     nsTextPaintStyle& aTextPaintStyle,\\n-                                     SelectionDetails* aDetails,\\n-                                     SelectionType aSelectionType);\\n-\\n-  PRInt16 GetSelectionStatus(PRInt16* aSelectionFlags);\\n-\\n-#ifdef DEBUG\\n-  void ToCString(nsString& aBuf, PRInt32* aTotalContentLength) const;\\n-#endif\\n-\\n-  PRInt32 GetContentOffset() const { return mContentOffset; }\\n-  PRInt32 GetContentLength() const { return GetContentEnd() - mContentOffset; }\\n-  PRInt32 GetContentEnd() const;\\n-  // This returns the length the frame thinks it *should* have after it was\\n-  // last reflowed (0 if it hasn't been reflowed yet). This should be used only\\n-  // when setting up the text offsets for a new continuation frame.\\n-  PRInt32 GetContentLengthHint() const { return mContentLengthHint; }\\n-\\n-  // Compute the length of the content mapped by this frame\\n-  // and all its in-flow siblings. Basically this means starting at mContentOffset\\n-  // and going to the end of the text node or the next bidi continuation\\n-  // boundary.\\n-  PRInt32 GetInFlowContentLength();\\n-\\n-  // Clears out mTextRun from this frame and all other frames that hold a reference\\n-  // to it, then deletes the textrun.\\n-  void ClearTextRun();\\n-  /**\\n-   * Acquires the text run for this content, if necessary.\\n-   * @param aRC the rendering context to use as a reference for creating\\n-   * the textrun, if available (if not, we'll create one which will just be slower)\\n-   * @param aBlock the block ancestor for this frame, or nsnull if unknown\\n-   * @param aLine the line that this frame is on, if any, or nsnull if unknown\\n-   * @param aFlowEndInTextRun if non-null, this returns the textrun offset of\\n-   * end of the text associated with this frame and its in-flow siblings\\n-   * @return a gfxSkipCharsIterator set up to map DOM offsets for this frame\\n-   * to offsets into the textrun; its initial offset is set to this frame's\\n-   * content offset\\n-   */\\n-  gfxSkipCharsIterator EnsureTextRun(nsIRenderingContext* aRC = nsnull,\\n-                                     nsIFrame* aLineContainer = nsnull,\\n-                                     const nsLineList::iterator* aLine = nsnull,\\n-                                     PRUint32* aFlowEndInTextRun = nsnull);\\n-\\n-  gfxTextRun* GetTextRun() { return mTextRun; }\\n-  void SetTextRun(gfxTextRun* aTextRun) { mTextRun = aTextRun; }\\n-\\n-  // Get the DOM content range mapped by this frame after excluding\\n-  // whitespace subject to start-of-line and end-of-line trimming.\\n-  // The textrun must have been created before calling this.\\n-  struct TrimmedOffsets {\\n-    PRInt32 mStart;\\n-    PRInt32 mLength;\\n-    PRInt32 GetEnd() { return mStart + mLength; }\\n-  };\\n-  TrimmedOffsets GetTrimmedOffsets(const nsTextFragment* aFrag,\\n-                                   PRBool aTrimAfter);\\n-\\n-protected:\\n-  virtual ~nsTextFrame();\\n-  \\n-  nsIFrame*   mNextContinuation;\\n-  // The key invariant here is that mContentOffset never decreases along\\n-  // a next-continuation chain. And of course mContentOffset is always <= the\\n-  // the text node's content length, and the mContentOffset for the first frame\\n-  // is always 0. Furthermore the text mapped by a frame is determined by\\n-  // GetContentOffset() and GetContentLength()/GetContentEnd(), which get\\n-  // the length from the difference between this frame's offset and the next\\n-  // frame's offset, or the text length if there is no next frame. This means\\n-  // the frames always map the text node without overlapping or leaving any gaps.\\n-  PRInt32     mContentOffset;\\n-  // This does *not* indicate the length of text currently mapped by the frame;\\n-  // instead it's a hint saying that this frame *wants* to map this much text\\n-  // so if we create a new continuation, this is where that continuation should\\n-  // start.\\n-  PRInt32     mContentLengthHint;\\n-  nscoord     mAscent;\\n-  gfxTextRun* mTextRun;\\n-\\n-  SelectionDetails* GetSelectionDetails();\\n-  \\n-  void AdjustSelectionPointsForBidi(SelectionDetails *sdptr,\\n-                                    PRInt32 textLength,\\n-                                    PRBool isRTLChars,\\n-                                    PRBool isOddLevel,\\n-                                    PRBool isBidiSystem);\\n-};\\n-\\n-#endif\\ndiff --git a/layout/generic/nsTextFrameThebes.cpp b/layout/generic/nsTextFrameThebes.cpp\\nindex 8293e14..237d8b4 100644\\n--- a/layout/generic/nsTextFrameThebes.cpp\\n+++ b/layout/generic/nsTextFrameThebes.cpp\\n@@ -81,7 +81,6 @@\\n #include \\\"nsFrameManager.h\\\"\\n #include \\\"nsTextFrameTextRunCache.h\\\"\\n #include \\\"nsExpirationTracker.h\\\"\\n-#include \\\"nsTextFrame.h\\\"\\n #include \\\"nsICaseConversion.h\\\"\\n #include \\\"nsIUGenCategory.h\\\"\\n #include \\\"nsUnicharUtilCIID.h\\\"\\n@@ -183,6 +182,9 @@\\n  *   <b>Kit&shy;</b>ty\\n  */\\n \\n+class nsTextFrame;\\n+class PropertyProvider;\\n+\\n /**\\n  * We use an array of these objects to record which text frames\\n  * are associated with the textrun. mStartFrame is the start of a list of\\n@@ -293,6 +295,289 @@ protected:\\n                                nscolor aBackColor);\\n };\\n \\n+class nsTextFrame : public nsFrame {\\n+public:\\n+  nsTextFrame(nsStyleContext* aContext) : nsFrame(aContext)\\n+  {\\n+    NS_ASSERTION(mContentOffset == 0, \\\"Bogus content offset\\\");\\n+  }\\n+  \\n+  // nsIFrame\\n+  NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,\\n+                              const nsRect&           aDirtyRect,\\n+                              const nsDisplayListSet& aLists);\\n+\\n+  NS_IMETHOD Init(nsIContent*      aContent,\\n+                  nsIFrame*        aParent,\\n+                  nsIFrame*        aPrevInFlow);\\n+\\n+  virtual void Destroy();\\n+  \\n+  NS_IMETHOD GetCursor(const nsPoint& aPoint,\\n+                       nsIFrame::Cursor& aCursor);\\n+  \\n+  NS_IMETHOD CharacterDataChanged(nsPresContext* aPresContext,\\n+                                  nsIContent*     aChild,\\n+                                  PRBool          aAppend);\\n+                                  \\n+  NS_IMETHOD DidSetStyleContext();\\n+  \\n+  virtual nsIFrame* GetNextContinuation() const {\\n+    return mNextContinuation;\\n+  }\\n+  NS_IMETHOD SetNextContinuation(nsIFrame* aNextContinuation) {\\n+    NS_ASSERTION (!aNextContinuation || GetType() == aNextContinuation->GetType(),\\n+                  \\\"setting a next continuation with incorrect type!\\\");\\n+    NS_ASSERTION (!nsSplittableFrame::IsInNextContinuationChain(aNextContinuation, this),\\n+                  \\\"creating a loop in continuation chain!\\\");\\n+    mNextContinuation = aNextContinuation;\\n+    if (aNextContinuation)\\n+      aNextContinuation->RemoveStateBits(NS_FRAME_IS_FLUID_CONTINUATION);\\n+    return NS_OK;\\n+  }\\n+  virtual nsIFrame* GetNextInFlowVirtual() const { return GetNextInFlow(); }\\n+  nsIFrame* GetNextInFlow() const {\\n+    return mNextContinuation && (mNextContinuation->GetStateBits() & NS_FRAME_IS_FLUID_CONTINUATION) ? \\n+      mNextContinuation : nsnull;\\n+  }\\n+  NS_IMETHOD SetNextInFlow(nsIFrame* aNextInFlow) {\\n+    NS_ASSERTION (!aNextInFlow || GetType() == aNextInFlow->GetType(),\\n+                  \\\"setting a next in flow with incorrect type!\\\");\\n+    NS_ASSERTION (!nsSplittableFrame::IsInNextContinuationChain(aNextInFlow, this),\\n+                  \\\"creating a loop in continuation chain!\\\");\\n+    mNextContinuation = aNextInFlow;\\n+    if (aNextInFlow)\\n+      aNextInFlow->AddStateBits(NS_FRAME_IS_FLUID_CONTINUATION);\\n+    return NS_OK;\\n+  }\\n+  virtual nsIFrame* GetLastInFlow() const;\\n+  virtual nsIFrame* GetLastContinuation() const;\\n+  \\n+  virtual nsSplittableType GetSplittableType() const {\\n+    return NS_FRAME_SPLITTABLE;\\n+  }\\n+  \\n+  /**\\n+    * Get the \\\"type\\\" of the frame\\n+   *\\n+   * @see nsGkAtoms::textFrame\\n+   */\\n+  virtual nsIAtom* GetType() const;\\n+  \\n+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const\\n+  {\\n+    // Set the frame state bit for text frames to mark them as replaced.\\n+    // XXX kipp: temporary\\n+    return nsFrame::IsFrameOfType(aFlags & ~(nsIFrame::eReplaced |\\n+                                             nsIFrame::eLineParticipant));\\n+  }\\n+\\n+#ifdef DEBUG\\n+  NS_IMETHOD List(FILE* out, PRInt32 aIndent) const;\\n+  NS_IMETHOD GetFrameName(nsAString& aResult) const;\\n+  NS_IMETHOD_(nsFrameState) GetDebugStateBits() const ;\\n+#endif\\n+  \\n+  virtual ContentOffsets CalcContentOffsetsFromFramePoint(nsPoint aPoint);\\n+   \\n+  NS_IMETHOD SetSelected(nsPresContext* aPresContext,\\n+                         nsIDOMRange *aRange,\\n+                         PRBool aSelected,\\n+                         nsSpread aSpread);\\n+  \\n+  virtual PRBool PeekOffsetNoAmount(PRBool aForward, PRInt32* aOffset);\\n+  virtual PRBool PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset);\\n+  virtual PRBool PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,\\n+                                PRInt32* aOffset, PeekWordState* aState);\\n+\\n+  NS_IMETHOD CheckVisibility(nsPresContext* aContext, PRInt32 aStartIndex, PRInt32 aEndIndex, PRBool aRecurse, PRBool *aFinished, PRBool *_retval);\\n+  \\n+  // Update offsets to account for new length. This may clear mTextRun.\\n+  void SetLength(PRInt32 aLength);\\n+  \\n+  NS_IMETHOD GetOffsets(PRInt32 &start, PRInt32 &end)const;\\n+  \\n+  virtual void AdjustOffsetsForBidi(PRInt32 start, PRInt32 end);\\n+  \\n+  NS_IMETHOD GetPointFromOffset(PRInt32                 inOffset,\\n+                                nsPoint*                outPoint);\\n+  \\n+  NS_IMETHOD  GetChildFrameContainingOffset(PRInt32     inContentOffset,\\n+                                            PRBool                  inHint,\\n+                                            PRInt32*                outFrameContentOffset,\\n+                                            nsIFrame*               *outChildFrame);\\n+  \\n+  virtual PRBool IsVisibleInSelection(nsISelection* aSelection);\\n+  \\n+  virtual PRBool IsEmpty();\\n+  virtual PRBool IsSelfEmpty() { return IsEmpty(); }\\n+  \\n+  /**\\n+   * @return PR_TRUE if this text frame ends with a newline character.  It\\n+   * should return PR_FALSE if this is not a text frame.\\n+   */\\n+  virtual PRBool HasTerminalNewline() const;\\n+  \\n+#ifdef ACCESSIBILITY\\n+  NS_IMETHOD GetAccessible(nsIAccessible** aAccessible);\\n+#endif\\n+  \\n+  virtual void MarkIntrinsicWidthsDirty();\\n+  virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);\\n+  virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext);\\n+  virtual void AddInlineMinWidth(nsIRenderingContext *aRenderingContext,\\n+                                 InlineMinWidthData *aData);\\n+  virtual void AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,\\n+                                  InlinePrefWidthData *aData);\\n+  virtual nsSize ComputeSize(nsIRenderingContext *aRenderingContext,\\n+                             nsSize aCBSize, nscoord aAvailableWidth,\\n+                             nsSize aMargin, nsSize aBorder, nsSize aPadding,\\n+                             PRBool aShrinkWrap);\\n+  NS_IMETHOD Reflow(nsPresContext* aPresContext,\\n+                    nsHTMLReflowMetrics& aMetrics,\\n+                    const nsHTMLReflowState& aReflowState,\\n+                    nsReflowStatus& aStatus);\\n+  virtual PRBool CanContinueTextRun() const;\\n+  NS_IMETHOD TrimTrailingWhiteSpace(nsPresContext* aPresContext,\\n+                                    nsIRenderingContext& aRC,\\n+                                    nscoord& aDeltaWidth,\\n+                                    PRBool& aLastCharIsJustifiable);\\n+  virtual nsresult GetRenderedText(nsAString* aString = nsnull,\\n+                                   gfxSkipChars* aSkipChars = nsnull,\\n+                                   gfxSkipCharsIterator* aSkipIter = nsnull,\\n+                                   PRUint32 aSkippedStartOffset = 0,\\n+                                   PRUint32 aSkippedMaxLength = PR_UINT32_MAX);\\n+\\n+  void AddInlineMinWidthForFlow(nsIRenderingContext *aRenderingContext,\\n+                                nsIFrame::InlineMinWidthData *aData);\\n+  void AddInlinePrefWidthForFlow(nsIRenderingContext *aRenderingContext,\\n+                                 InlinePrefWidthData *aData);\\n+\\n+  gfxFloat GetSnappedBaselineY(gfxContext* aContext, gfxFloat aY);\\n+\\n+  // primary frame paint method called from nsDisplayText\\n+  void PaintText(nsIRenderingContext* aRenderingContext, nsPoint aPt,\\n+                 const nsRect& aDirtyRect);\\n+  // helper: paint quirks-mode CSS text decorations\\n+  void PaintTextDecorations(gfxContext* aCtx, const gfxRect& aDirtyRect,\\n+                            const gfxPoint& aFramePt,\\n+                            const gfxPoint& aTextBaselinePt,\\n+                            nsTextPaintStyle& aTextStyle,\\n+                            PropertyProvider& aProvider);\\n+  // helper: paint text frame when we're impacted by at least one selection.\\n+  // Return PR_FALSE if the text was not painted and we should continue with\\n+  // the fast path.\\n+  PRBool PaintTextWithSelection(gfxContext* aCtx,\\n+                                const gfxPoint& aFramePt,\\n+                                const gfxPoint& aTextBaselinePt,\\n+                                const gfxRect& aDirtyRect,\\n+                                PropertyProvider& aProvider,\\n+                                nsTextPaintStyle& aTextPaintStyle);\\n+  // helper: paint text with foreground and background colors determined\\n+  // by selection(s). Also computes a mask of all selection types applying to\\n+  // our text, returned in aAllTypes.\\n+  void PaintTextWithSelectionColors(gfxContext* aCtx,\\n+                                    const gfxPoint& aFramePt,\\n+                                    const gfxPoint& aTextBaselinePt,\\n+                                    const gfxRect& aDirtyRect,\\n+                                    PropertyProvider& aProvider,\\n+                                    nsTextPaintStyle& aTextPaintStyle,\\n+                                    SelectionDetails* aDetails,\\n+                                    SelectionType* aAllTypes);\\n+  // helper: paint text decorations for text selected by aSelectionType\\n+  void PaintTextSelectionDecorations(gfxContext* aCtx,\\n+                                     const gfxPoint& aFramePt,\\n+                                     const gfxPoint& aTextBaselinePt,\\n+                                     const gfxRect& aDirtyRect,\\n+                                     PropertyProvider& aProvider,\\n+                                     nsTextPaintStyle& aTextPaintStyle,\\n+                                     SelectionDetails* aDetails,\\n+                                     SelectionType aSelectionType);\\n+\\n+  PRInt16 GetSelectionStatus(PRInt16* aSelectionFlags);\\n+\\n+#ifdef DEBUG\\n+  void ToCString(nsString& aBuf, PRInt32* aTotalContentLength) const;\\n+#endif\\n+\\n+  PRInt32 GetContentOffset() const { return mContentOffset; }\\n+  PRInt32 GetContentLength() const { return GetContentEnd() - mContentOffset; }\\n+  PRInt32 GetContentEnd() const;\\n+  // This returns the length the frame thinks it *should* have after it was\\n+  // last reflowed (0 if it hasn't been reflowed yet). This should be used only\\n+  // when setting up the text offsets for a new continuation frame.\\n+  PRInt32 GetContentLengthHint() const { return mContentLengthHint; }\\n+\\n+  // Compute the length of the content mapped by this frame\\n+  // and all its in-flow siblings. Basically this means starting at mContentOffset\\n+  // and going to the end of the text node or the next bidi continuation\\n+  // boundary.\\n+  PRInt32 GetInFlowContentLength();\\n+\\n+  // Clears out mTextRun from this frame and all other frames that hold a reference\\n+  // to it, then deletes the textrun.\\n+  void ClearTextRun();\\n+  /**\\n+   * Acquires the text run for this content, if necessary.\\n+   * @param aRC the rendering context to use as a reference for creating\\n+   * the textrun, if available (if not, we'll create one which will just be slower)\\n+   * @param aBlock the block ancestor for this frame, or nsnull if unknown\\n+   * @param aLine the line that this frame is on, if any, or nsnull if unknown\\n+   * @param aFlowEndInTextRun if non-null, this returns the textrun offset of\\n+   * end of the text associated with this frame and its in-flow siblings\\n+   * @return a gfxSkipCharsIterator set up to map DOM offsets for this frame\\n+   * to offsets into the textrun; its initial offset is set to this frame's\\n+   * content offset\\n+   */\\n+  gfxSkipCharsIterator EnsureTextRun(nsIRenderingContext* aRC = nsnull,\\n+                                     nsIFrame* aLineContainer = nsnull,\\n+                                     const nsLineList::iterator* aLine = nsnull,\\n+                                     PRUint32* aFlowEndInTextRun = nsnull);\\n+\\n+  gfxTextRun* GetTextRun() { return mTextRun; }\\n+  void SetTextRun(gfxTextRun* aTextRun) { mTextRun = aTextRun; }\\n+\\n+  // Get the DOM content range mapped by this frame after excluding\\n+  // whitespace subject to start-of-line and end-of-line trimming.\\n+  // The textrun must have been created before calling this.\\n+  struct TrimmedOffsets {\\n+    PRInt32 mStart;\\n+    PRInt32 mLength;\\n+    PRInt32 GetEnd() { return mStart + mLength; }\\n+  };\\n+  TrimmedOffsets GetTrimmedOffsets(const nsTextFragment* aFrag,\\n+                                   PRBool aTrimAfter);\\n+\\n+protected:\\n+  virtual ~nsTextFrame();\\n+  \\n+  nsIFrame*   mNextContinuation;\\n+  // The key invariant here is that mContentOffset never decreases along\\n+  // a next-continuation chain. And of course mContentOffset is always <= the\\n+  // the text node's content length, and the mContentOffset for the first frame\\n+  // is always 0. Furthermore the text mapped by a frame is determined by\\n+  // GetContentOffset() and GetContentLength()/GetContentEnd(), which get\\n+  // the length from the difference between this frame's offset and the next\\n+  // frame's offset, or the text length if there is no next frame. This means\\n+  // the frames always map the text node without overlapping or leaving any gaps.\\n+  PRInt32     mContentOffset;\\n+  // This does *not* indicate the length of text currently mapped by the frame;\\n+  // instead it's a hint saying that this frame *wants* to map this much text\\n+  // so if we create a new continuation, this is where that continuation should\\n+  // start.\\n+  PRInt32     mContentLengthHint;\\n+  nscoord     mAscent;\\n+  gfxTextRun* mTextRun;\\n+\\n+  SelectionDetails* GetSelectionDetails();\\n+  \\n+  void AdjustSelectionPointsForBidi(SelectionDetails *sdptr,\\n+                                    PRInt32 textLength,\\n+                                    PRBool isRTLChars,\\n+                                    PRBool isOddLevel,\\n+                                    PRBool isBidiSystem);\\n+};\\n+\\n static void\\n DestroyUserData(void* aUserData)\\n {\\n@@ -3360,9 +3645,7 @@ public:\\n   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {\\n     return mFrame->GetOverflowRect() + aBuilder->ToReferenceFrame(mFrame);\\n   }\\n-  virtual nsIFrame* HitTest(nsDisplayListBuilder* aBuilder, nsPoint aPt) {\\n-    return nsRect(aBuilder->ToReferenceFrame(mFrame), mFrame->GetSize()).Contains(aPt) ? mFrame : nsnull;\\n-  }\\n+  virtual nsIFrame* HitTest(nsDisplayListBuilder* aBuilder, nsPoint aPt) { return mFrame; }\\n   virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx,\\n      const nsRect& aDirtyRect);\\n   NS_DISPLAY_DECL_NAME(\\\"Text\\\")\\n@@ -4917,15 +5200,14 @@ nsTextFrame::ComputeSize(nsIRenderingContext *aRenderingContext,\\n \\n static void\\n AddCharToMetrics(gfxTextRun* aCharTextRun, gfxTextRun* aBaseTextRun,\\n-                 gfxTextRun::Metrics* aMetrics, PRBool aTightBoundingBox,\\n-                 gfxContext* aContext)\\n+                 gfxTextRun::Metrics* aMetrics, PRBool aTightBoundingBox)\\n {\\n   gfxRect charRect;\\n   // assume char does not overflow font metrics!!!\\n   gfxFloat width = aCharTextRun->GetAdvanceWidth(0, aCharTextRun->GetLength(), nsnull);\\n   if (aTightBoundingBox) {\\n     gfxTextRun::Metrics charMetrics =\\n-        aCharTextRun->MeasureText(0, aCharTextRun->GetLength(), PR_TRUE, aContext, nsnull);\\n+        aCharTextRun->MeasureText(0, aCharTextRun->GetLength(), PR_TRUE, nsnull);\\n     charRect = charMetrics.mBoundingBox;\\n   } else {\\n     charRect = gfxRect(0, -aMetrics->mAscent, width,\\n@@ -5170,15 +5452,13 @@ nsTextFrame::Reflow(nsPresContext*           aPresContext,\\n   gfxFloat availWidth = aReflowState.availableWidth;\\n   PRBool canTrimTrailingWhitespace = !textStyle->WhiteSpaceIsSignificant() &&\\n     textStyle->WhiteSpaceCanWrap();\\n-  gfxContext* ctx = static_cast<gfxContext*>\\n-    (aReflowState.rendContext->GetNativeGraphicData(nsIRenderingContext::NATIVE_THEBES_CONTEXT));\\n   PRUint32 transformedCharsFit =\\n     mTextRun->BreakAndMeasureText(transformedOffset, transformedLength,\\n                                   (GetStateBits() & TEXT_START_OF_LINE) != 0,\\n                                   availWidth,\\n                                   &provider, suppressInitialBreak,\\n                                   canTrimTrailingWhitespace ? &trimmedWidth : nsnull,\\n-                                  &textMetrics, needTightBoundingBox, ctx,\\n+                                  &textMetrics, needTightBoundingBox,\\n                                   &usedHyphenation, &transformedLastBreak);\\n   // The \\\"end\\\" iterator points to the first character after the string mapped\\n   // by this frame. Basically, its original-string offset is offset+charsFit\\n@@ -5209,7 +5489,7 @@ nsTextFrame::Reflow(nsPresContext*           aPresContext,\\n     gfxTextRunCache::AutoTextRun hyphenTextRun(GetHyphenTextRun(mTextRun, aReflowState.rendContext));\\n     if (hyphenTextRun.get()) {\\n       AddCharToMetrics(hyphenTextRun.get(),\\n-                       mTextRun, &textMetrics, needTightBoundingBox, ctx);\\n+                       mTextRun, &textMetrics, needTightBoundingBox);\\n     }\\n     AddStateBits(TEXT_HYPHEN_BREAK);\\n   }\\n@@ -5456,28 +5736,6 @@ nsTextFrame::TrimTrailingWhiteSpace(nsPresContext* aPresContext,\\n   return NS_OK;\\n }\\n \\n-nsRect\\n-nsTextFrame::RecomputeOverflowRect()\\n-{\\n-  gfxSkipCharsIterator iter = EnsureTextRun();\\n-  if (!mTextRun)\\n-    return nsRect(nsPoint(0,0), GetSize());\\n-\\n-  PropertyProvider provider(this, iter);\\n-  provider.InitializeForDisplay(PR_TRUE);\\n-\\n-  gfxTextRun::Metrics textMetrics =\\n-    mTextRun->MeasureText(provider.GetStart().GetSkippedOffset(),\\n-                          ComputeTransformedLength(provider), PR_FALSE, nsnull,\\n-                          &provider);\\n-\\n-  nsRect boundingBox =\\n-    ConvertGfxRectOutward(textMetrics.mBoundingBox + gfxPoint(0, textMetrics.mAscent));\\n-  boundingBox.UnionRect(boundingBox,\\n-                        nsRect(nsPoint(0,0), GetSize()));\\n-  return boundingBox;\\n-}\\n-\\n static PRUnichar TransformChar(const nsStyleText* aStyle, gfxTextRun* aTextRun,\\n                                PRUint32 aSkippedOffset, PRUnichar aChar)\\n {\\n@@ -5699,11 +5957,6 @@ nsTextFrame::List(FILE* out, PRInt32 aIndent) const\\n     }\\n   }\\n   fprintf(out, \\\" [content=%p]\\\", static_cast<void*>(mContent));\\n-  nsRect* overflowArea = const_cast<nsTextFrame*>(this)->GetOverflowAreaProperty(PR_FALSE);\\n-  if (overflowArea) {\\n-    fprintf(out, \\\" [overflow=%d,%d,%d,%d]\\\", overflowArea->x, overflowArea->y,\\n-            overflowArea->width, overflowArea->height);\\n-  }\\n   fprintf(out, \\\" sc=%p\\\", static_cast<void*>(mStyleContext));\\n   nsIAtom* pseudoTag = mStyleContext->GetPseudoType();\\n   if (pseudoTag) {\\ndiff --git a/layout/svg/base/src/nsSVGGlyphFrame.cpp b/layout/svg/base/src/nsSVGGlyphFrame.cpp\\nindex ae207ed..e2c8add 100644\\n--- a/layout/svg/base/src/nsSVGGlyphFrame.cpp\\n+++ b/layout/svg/base/src/nsSVGGlyphFrame.cpp\\n@@ -409,7 +409,7 @@ nsSVGGlyphFrame::UpdateCoveredRegion()\\n       textRun->DrawToPath(gfx, mPosition, 0, text.Length(), nsnull, nsnull);\\n     } else {\\n       gfxTextRun::Metrics metrics =\\n-        textRun->MeasureText(0, text.Length(), PR_FALSE, nsnull, nsnull);\\n+        textRun->MeasureText(0, text.Length(), PR_FALSE, nsnull);\\n       gfx->Rectangle(metrics.mBoundingBox + mPosition);\\n     }\\n   } else {\\n@@ -434,7 +434,7 @@ nsSVGGlyphFrame::UpdateCoveredRegion()\\n         gfx->Rotate(cp[i].angle);\\n \\n         gfxTextRun::Metrics metrics =\\n-          textRun->MeasureText(i, 1, PR_FALSE, nsnull, nsnull);\\n+          textRun->MeasureText(i, 1, PR_FALSE, nsnull);\\n \\n         gfx->Rectangle(metrics.mBoundingBox + gfx->CurrentPoint());\\n       }\\n@@ -867,7 +867,7 @@ nsSVGGlyphFrame::GetExtentOfChar(PRUint32 charnum, nsIDOMSVGRect **_retval)\\n     return NS_ERROR_OUT_OF_MEMORY;\\n \\n   gfxTextRun::Metrics metrics =\\n-    textRun->MeasureText(charnum, 1, PR_FALSE, nsnull, nsnull);\\n+    textRun->MeasureText(charnum, 1, PR_FALSE, nsnull);\\n \\n   if (cp) {\\n     if (cp[charnum].draw == PR_FALSE) {\\n@@ -943,7 +943,7 @@ nsSVGGlyphFrame::GetBaselineOffset(PRUint16 baselineIdentifier)\\n     return 0.0f;\\n \\n   gfxTextRun::Metrics metrics =\\n-    textRun->MeasureText(0, text.Length(), PR_FALSE, nsnull, nsnull);\\n+    textRun->MeasureText(0, text.Length(), PR_FALSE, nsnull);\\n \\n   switch (baselineIdentifier) {\\n   case BASELINE_HANGING:\\n@@ -1171,7 +1171,7 @@ nsSVGGlyphFrame::GetCharNumAtPosition(nsIDOMSVGPoint *point)\\n     }\\n \\n     gfxTextRun::Metrics metrics =\\n-      textRun->MeasureText(charnum, 1, PR_FALSE, nsnull, nsnull);\\n+      textRun->MeasureText(charnum, 1, PR_FALSE, nsnull);\\n \\n     gfx->Rectangle(metrics.mBoundingBox + gfx->CurrentPoint());\\n \\n@@ -1293,7 +1293,7 @@ nsSVGGlyphFrame::ContainsPoint(float x, float y)\\n     }\\n \\n     gfxTextRun::Metrics metrics =\\n-      textRun->MeasureText(i, 1, PR_FALSE, nsnull, nsnull);\\n+      textRun->MeasureText(i, 1, PR_FALSE, nsnull);\\n \\n     gfx->Rectangle(metrics.mBoundingBox + gfx->CurrentPoint());\\n \\n\""}