{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas14b19e8\""},"diff":"\"14b19e8 Bug 392435. Make ClearTextRun work no matter which frame of a continuation chain we call it on. r=smontagu,a=dbaron\\ndiff --git a/layout/generic/nsTextFrameThebes.cpp b/layout/generic/nsTextFrameThebes.cpp\\nindex 71e64ab..07c9b61 100644\\n--- a/layout/generic/nsTextFrameThebes.cpp\\n+++ b/layout/generic/nsTextFrameThebes.cpp\\n@@ -154,10 +154,6 @@\\n \\n #define TEXT_WHITESPACE_FLAGS      0x18000000\\n \\n-// This bit is set if this frame is an owner of the textrun (i.e., occurs\\n-// as the mStartFrame of some flow associated with the textrun)\\n-#define TEXT_IS_RUN_OWNER          0x20000000\\n-\\n // This bit is set while the frame is registered as a blinking frame.\\n #define TEXT_BLINK_ON              0x80000000\\n \\n@@ -201,8 +197,6 @@ class PropertyProvider;\\n  * positive (when a text node starts in the middle of a text run) or\\n  * negative (when a text run starts in the middle of a text node). Of course\\n  * it can also be zero.\\n- * \\n- * mStartFrame has TEXT_IS_RUN_OWNER set.\\n  */\\n struct TextRunMappedFlow {\\n   nsTextFrame* mStartFrame;\\n@@ -598,9 +592,6 @@ DestroyUserData(void* aUserData)\\n static void\\n ClearAllTextRunReferences(nsTextFrame* aFrame, gfxTextRun* aTextRun)\\n {\\n-  NS_ASSERTION(aFrame->GetStateBits() & TEXT_IS_RUN_OWNER,\\n-               \\\"aFrame should be marked as a textrun owner\\\");\\n-  aFrame->RemoveStateBits(TEXT_IS_RUN_OWNER);\\n   while (aFrame) {\\n     if (aFrame->GetTextRun() != aTextRun)\\n       break;\\n@@ -1944,13 +1935,9 @@ BuildTextRunsScanner::AssignTextRun(gfxTextRun* aTextRun)\\n       f->ClearTextRun();\\n       f->SetTextRun(aTextRun);\\n     }\\n-    nsIContent* content = startFrame->GetContent();\\n     // BuildTextRunForFrames mashes together mapped flows for the same element,\\n     // so we do that here too.\\n-    if (content != lastContent) {\\n-      startFrame->AddStateBits(TEXT_IS_RUN_OWNER);\\n-      lastContent = content;\\n-    }    \\n+    lastContent = startFrame->GetContent();\\n   }\\n }\\n \\n@@ -3254,10 +3241,10 @@ nsTextFrame::Init(nsIContent*      aContent,\\n void\\n nsTextFrame::Destroy()\\n {\\n+  ClearTextRun();\\n   if (mNextContinuation) {\\n     mNextContinuation->SetPrevInFlow(nsnull);\\n   }\\n-  ClearTextRun();\\n   // Let the base class destroy the frame\\n   nsFrame::Destroy();\\n }\\n@@ -3369,10 +3356,10 @@ nsContinuingTextFrame::Init(nsIContent* aContent,\\n void\\n nsContinuingTextFrame::Destroy()\\n {\\n+  ClearTextRun();\\n   if (mPrevContinuation || mNextContinuation) {\\n     nsSplittableFrame::RemoveFromFlow(this);\\n   }\\n-  ClearTextRun();\\n   // Let the base class destroy the frame\\n   nsFrame::Destroy();\\n }\\n@@ -3548,7 +3535,7 @@ nsTextFrame::ClearTextRun()\\n   // save textrun because ClearAllTextRunReferences will clear ours\\n   gfxTextRun* textRun = mTextRun;\\n   \\n-  if (!textRun || !(GetStateBits() & TEXT_IS_RUN_OWNER))\\n+  if (!textRun)\\n     return;\\n \\n   UnhookTextRunFromFrames(textRun);\\n\""}