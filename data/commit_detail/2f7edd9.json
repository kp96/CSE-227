{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas2f7edd9\""},"diff":"\"2f7edd9 Bug 397100. Make non-namespaced role values also work in XHTML, SVG and XUL (synch with html). r=surkov, a=dsicore\\ndiff --git a/accessible/src/base/nsAccessNode.cpp b/accessible/src/base/nsAccessNode.cpp\\nindex 38cf7de..6436cec 100755\\n--- a/accessible/src/base/nsAccessNode.cpp\\n+++ b/accessible/src/base/nsAccessNode.cpp\\n@@ -837,32 +837,28 @@ nsAccessNode::GetLanguage(nsAString& aLanguage)\\n PRBool\\n nsAccessNode::GetARIARole(nsIContent *aContent, nsString& aRole)\\n {\\n-  nsAutoString prefix;\\n-  PRBool strictPrefixChecking = PR_TRUE;\\n   aRole.Truncate();\\n \\n-  if (aContent->IsNodeOfType(nsINode::eHTML)) { // HTML node\\n+  PRBool allowPrefixLookup = PR_TRUE;\\n+\\n+  if (aContent->IsNodeOfType(nsINode::eHTML)) {\\n     // Allow non-namespaced role attribute in HTML\\n-    aContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::role, aRole);\\n-    // Find non-namespaced role attribute on HTML node\\n+    if (!aContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::role, aRole)) {\\n+      return PR_FALSE;\\n+    }\\n     nsCOMPtr<nsIDOMNSDocument> doc(do_QueryInterface(aContent->GetDocument()));\\n     if (doc) {\\n-      // In text/html we are hardcoded to allow the exact prefix \\\"wairole:\\\" to \\n-      // always indicate that we are using the WAI roles.\\n-      // This allows ARIA to be used within text/html where namespaces cannot be defined.\\n-      // We also now relax the prefix checking, which means no prefix is required to use WAI Roles\\n       nsAutoString mimeType;\\n       doc->GetContentType(mimeType);\\n       if (mimeType.EqualsLiteral(\\\"text/html\\\")) {\\n-        prefix = NS_LITERAL_STRING(\\\"wairole:\\\");\\n-        strictPrefixChecking = PR_FALSE;\\n+        allowPrefixLookup = PR_FALSE;\\n       }\\n     }\\n   }\\n-\\n-  // Try namespaced-role attribute (xhtml or xhtml2 namespace) -- allowed in any kind of content\\n-  if (aRole.IsEmpty() && !aContent->GetAttr(kNameSpaceID_XHTML, nsAccessibilityAtoms::role, aRole) &&\\n-      !aContent->GetAttr(kNameSpaceID_XHTML2_Unofficial, nsAccessibilityAtoms::role, aRole)) {\\n+  // In non-HTML content, use XHTML namespaced-role attribute\\n+  // XXX We still support XHTML2 for now because of XUL content, but will migrate to XHTML after FF3\\n+  else if (!aContent->GetAttr(kNameSpaceID_XHTML, nsAccessibilityAtoms::role, aRole) &&\\n+           !aContent->GetAttr(kNameSpaceID_XHTML2_Unofficial, nsAccessibilityAtoms::role, aRole)) {\\n     return PR_FALSE;\\n   }\\n \\n@@ -871,16 +867,23 @@ nsAccessNode::GetARIARole(nsIContent *aContent, nsString& aRole)\\n   if (!hasPrefix) {\\n     // * No prefix* -- not a QName\\n     // Just return entire string as long as prefix is not currently required\\n-    if (strictPrefixChecking) {\\n-      // Prefix was required and we didn't have one\\n-      aRole.Truncate();\\n-      return PR_FALSE;\\n-    }\\n     return PR_TRUE;\\n   }\\n \\n-  // * Has prefix * -- is a QName (role=\\\"prefix:rolename\\\")\\n-  if (strictPrefixChecking) {  // Not text/html, we need to actually find the WAIRole prefix\\n+  // Has prefix -- is a QName (role=\\\"prefix:rolename\\\")\\n+\\n+  // Check hardcoded 'wairole:' prefix\\n+  NS_NAMED_LITERAL_STRING(hardcodedWairolePrefix, \\\"wairole:\\\");\\n+  if (StringBeginsWith(aRole, hardcodedWairolePrefix)) {\\n+    // The exact prefix \\\"wairole:\\\" is reserved to \\n+    // always indicate that we are using WAI roles.\\n+    aRole.Cut(0, hardcodedWairolePrefix.Length());\\n+    return PR_TRUE;\\n+  }\\n+\\n+  // Check for prefix mapped with xmlns:prefixname=\\\"\\\"\\n+  nsAutoString prefix;\\n+  if (allowPrefixLookup) {  // Not text/html, so we will try to find the WAIRole prefix\\n     // QI to nsIDOM3Node causes some overhead. Unfortunately we need to do this each\\n     // time there is a prefixed role attribute, because the prefix to namespace mappings\\n     // can change within any subtree via the xmlns attribute\\n@@ -890,15 +893,14 @@ nsAccessNode::GetARIARole(nsIContent *aContent, nsString& aRole)\\n       NS_NAMED_LITERAL_STRING(kWAIRoles_Namespace, \\\"http://www.w3.org/2005/01/wai-rdf/GUIRoleTaxonomy#\\\");\\n       dom3Node->LookupPrefix(kWAIRoles_Namespace, prefix);\\n       prefix += ':';\\n+      PRUint32 length = prefix.Length();\\n+      if (length > 1 && StringBeginsWith(aRole, prefix)) {\\n+        // Is a QName (role=\\\"prefix:rolename\\\"), and prefix matches WAI Role prefix\\n+        // Trim the WAI Role prefix off\\n+        aRole.Cut(0, length);\\n+      }\\n     }\\n   }\\n \\n-  PRUint32 length = prefix.Length();\\n-  if (length > 1 && StringBeginsWith(aRole, prefix)) {\\n-    // Is a QName (role=\\\"prefix:rolename\\\"), and prefix matches WAI Role prefix\\n-    // Trim the WAI Role prefix off\\n-    aRole.Cut(0, length);\\n-  }\\n-\\n   return PR_TRUE;\\n }\\ndiff --git a/accessible/src/base/nsAccessibilityUtils.cpp b/accessible/src/base/nsAccessibilityUtils.cpp\\nindex fd4806a..121ca04 100755\\n--- a/accessible/src/base/nsAccessibilityUtils.cpp\\n+++ b/accessible/src/base/nsAccessibilityUtils.cpp\\n@@ -585,7 +585,7 @@ nsAccUtils::FindNeighbourPointingToNode(nsIContent *aForNode,\\n {\\n   NS_ASSERTION(aAriaProperty == eAria_none || !aRelationAttr,\\n                \\\"Cannot pass in both an ARIA relation property and an atom relation. Choose one\\\");\\n-  NS_ASSERTION(aAriaProperty != eAria_none || !aTagName,\\n+  NS_ASSERTION(aAriaProperty == eAria_none || !aTagName,\\n                \\\"Cannot use aTagName with ARIA relation property, because ARIA relations apply to any tag\\\");\\n   nsCOMPtr<nsIContent> binding;\\n   nsAutoString controlID;\\ndiff --git a/accessible/src/base/nsDocAccessible.cpp b/accessible/src/base/nsDocAccessible.cpp\\nindex da3829c..be72aba 100644\\n--- a/accessible/src/base/nsDocAccessible.cpp\\n+++ b/accessible/src/base/nsDocAccessible.cpp\\n@@ -1044,16 +1044,13 @@ nsDocAccessible::AttributeChangedImpl(nsIContent* aContent, PRInt32 aNameSpaceID\\n     return;\\n   }\\n \\n-  if (aNameSpaceID == kNameSpaceID_XHTML2_Unofficial ||\\n-      aNameSpaceID == kNameSpaceID_XHTML) {\\n-    if (aAttribute == nsAccessibilityAtoms::role)\\n-      InvalidateCacheSubtree(aContent, nsIAccessibleEvent::EVENT_DOM_SIGNIFICANT_CHANGE);\\n-    return;\\n-  }\\n-\\n-  if (aAttribute == nsAccessibilityAtoms::href ||\\n+  if (aAttribute == nsAccessibilityAtoms::role ||\\n+      aAttribute == nsAccessibilityAtoms::href ||\\n       aAttribute == nsAccessibilityAtoms::onclick ||\\n       aAttribute == nsAccessibilityAtoms::droppable) {\\n+    // Not worth the expense to ensure which namespace these are in\\n+    // It doesn't kill use to recreate the accessible even if the attribute was used\\n+    // in the wrong namespace or an element that doesn't support it\\n     InvalidateCacheSubtree(aContent, nsIAccessibleEvent::EVENT_DOM_SIGNIFICANT_CHANGE);\\n     return;\\n   }\\n\""}