{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas67f0237\""},"diff":"\"67f0237 Bug 373462 / bug 385322, Better scheduling of cycle collection/gc, r+sr=jst\\ndiff --git a/content/base/src/nsXMLHttpRequest.cpp b/content/base/src/nsXMLHttpRequest.cpp\\nindex 01a99f5..40e3c9d 100644\\n--- a/content/base/src/nsXMLHttpRequest.cpp\\n+++ b/content/base/src/nsXMLHttpRequest.cpp\\n@@ -56,6 +56,7 @@\\n #include \\\"prprf.h\\\"\\n #include \\\"nsIDOMEventListener.h\\\"\\n #include \\\"nsIJSContextStack.h\\\"\\n+#include \\\"nsJSEnvironment.h\\\"\\n #include \\\"nsIScriptSecurityManager.h\\\"\\n #include \\\"nsWeakPtr.h\\\"\\n #include \\\"nsICharsetAlias.h\\\"\\n@@ -1776,6 +1777,7 @@ nsXMLHttpRequest::RequestCompleted()\\n     ChangeState(XML_HTTP_REQUEST_OPENED);\\n   }\\n \\n+  nsJSContext::MaybeCC(PR_FALSE);\\n   return rv;\\n }\\n \\n@@ -2318,6 +2320,7 @@ nsXMLHttpRequest::Error(nsIDOMEvent* aEvent)\\n     NotifyEventListeners(errorEventListeners, event);\\n   }\\n \\n+  nsJSContext::MaybeCC(PR_FALSE);\\n   return NS_OK;\\n }\\n \\ndiff --git a/content/events/src/nsEventStateManager.cpp b/content/events/src/nsEventStateManager.cpp\\nindex 2cd1b14b..83fa7a2 100644\\n--- a/content/events/src/nsEventStateManager.cpp\\n+++ b/content/events/src/nsEventStateManager.cpp\\n@@ -136,6 +136,9 @@\\n #include \\\"nsEventDispatcher.h\\\"\\n #include \\\"nsPresShellIterator.h\\\"\\n \\n+#include \\\"nsServiceManagerUtils.h\\\"\\n+#include \\\"nsITimer.h\\\"\\n+\\n #ifdef XP_MACOSX\\n #include <Events.h>\\n #endif\\n@@ -144,6 +147,8 @@\\n //#define DEBUG_DOCSHELL_FOCUS\\n #endif\\n \\n+#define NS_USER_INTERACTION_INTERVAL 5000 // ms\\n+\\n static NS_DEFINE_CID(kFrameTraversalCID, NS_FRAMETRAVERSAL_CID);\\n \\n \\n@@ -171,6 +176,41 @@ static PRUint32 sESMInstanceCount = 0;\\n static PRInt32 sChromeAccessModifier = 0, sContentAccessModifier = 0;\\n PRInt32 nsEventStateManager::sUserInputEventDepth = 0;\\n \\n+static PRUint32 gMouseOrKeyboardEventCounter = 0;\\n+static nsITimer* gUserInteractionTimer = nsnull;\\n+static nsITimerCallback* gUserInteractionTimerCallback = nsnull;\\n+\\n+class nsUITimerCallback : public nsITimerCallback\\n+{\\n+public:\\n+  nsUITimerCallback() : mPreviousCount(0) {}\\n+  NS_DECL_ISUPPORTS\\n+  NS_DECL_NSITIMERCALLBACK\\n+private:\\n+  PRUint32 mPreviousCount;\\n+};\\n+\\n+NS_IMPL_ISUPPORTS1(nsUITimerCallback, nsITimerCallback)\\n+\\n+// If aTimer is nsnull, this method always sends \\\"user-interaction-inactive\\\"\\n+// notification.\\n+NS_IMETHODIMP\\n+nsUITimerCallback::Notify(nsITimer* aTimer)\\n+{\\n+  nsresult rv;\\n+  nsCOMPtr<nsIObserverService> obs =\\n+      do_GetService(\\\"@mozilla.org/observer-service;1\\\", &rv);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+  if ((gMouseOrKeyboardEventCounter == mPreviousCount) || !aTimer) {\\n+    gMouseOrKeyboardEventCounter = 0;\\n+    obs->NotifyObservers(nsnull, \\\"user-interaction-inactive\\\", nsnull);\\n+  } else {\\n+    obs->NotifyObservers(nsnull, \\\"user-interaction-active\\\", nsnull);\\n+  }\\n+  mPreviousCount = gMouseOrKeyboardEventCounter;\\n+  return NS_OK;\\n+}\\n+\\n enum {\\n  MOUSE_SCROLL_N_LINES,\\n  MOUSE_SCROLL_PAGE,\\n@@ -431,6 +471,18 @@ nsEventStateManager::nsEventStateManager()\\n     mTabbedThroughDocument(PR_FALSE),\\n     mAccessKeys(nsnull)\\n {\\n+  if (sESMInstanceCount == 0) {\\n+    gUserInteractionTimerCallback = new nsUITimerCallback();\\n+    if (gUserInteractionTimerCallback) {\\n+      NS_ADDREF(gUserInteractionTimerCallback);\\n+      CallCreateInstance(\\\"@mozilla.org/timer;1\\\", &gUserInteractionTimer);\\n+      if (gUserInteractionTimer) {\\n+        gUserInteractionTimer->InitWithCallback(gUserInteractionTimerCallback,\\n+                                                NS_USER_INTERACTION_INTERVAL,\\n+                                                nsITimer::TYPE_REPEATING_SLACK);\\n+      }\\n+    }\\n+  }\\n   ++sESMInstanceCount;\\n }\\n \\n@@ -509,6 +561,14 @@ nsEventStateManager::~nsEventStateManager()\\n   if(sESMInstanceCount == 0) {\\n     NS_IF_RELEASE(gLastFocusedContent);\\n     NS_IF_RELEASE(gLastFocusedDocument);\\n+    if (gUserInteractionTimerCallback) {\\n+      gUserInteractionTimerCallback->Notify(nsnull);\\n+      NS_RELEASE(gUserInteractionTimerCallback);\\n+    }\\n+    if (gUserInteractionTimer) {\\n+      gUserInteractionTimer->Cancel();\\n+      NS_RELEASE(gUserInteractionTimer);\\n+    }\\n   }\\n \\n   delete mAccessKeys;\\n@@ -724,6 +784,21 @@ nsEventStateManager::PreHandleEvent(nsPresContext* aPresContext,\\n     if (!mCurrentTarget) return NS_ERROR_NULL_POINTER;\\n   }\\n \\n+  if (NS_IS_TRUSTED_EVENT(aEvent) &&\\n+      ((aEvent->eventStructType == NS_MOUSE_EVENT  &&\\n+        static_cast<nsMouseEvent*>(aEvent)->reason == nsMouseEvent::eReal) ||\\n+       aEvent->eventStructType == NS_MOUSE_SCROLL_EVENT ||\\n+       aEvent->eventStructType == NS_KEY_EVENT)) {\\n+    if (gMouseOrKeyboardEventCounter == 0) {\\n+      nsCOMPtr<nsIObserverService> obs =\\n+        do_GetService(\\\"@mozilla.org/observer-service;1\\\");\\n+      if (obs) {\\n+        obs->NotifyObservers(nsnull, \\\"user-interaction-active\\\", nsnull);\\n+      }\\n+    }\\n+    ++gMouseOrKeyboardEventCounter;\\n+  }\\n+\\n   *aStatus = nsEventStatus_eIgnore;\\n \\n   nsMouseWheelTransaction::OnEvent(aEvent);\\ndiff --git a/dom/src/base/nsJSEnvironment.cpp b/dom/src/base/nsJSEnvironment.cpp\\nindex db881ff..bcef36f 100644\\n--- a/dom/src/base/nsJSEnvironment.cpp\\n+++ b/dom/src/base/nsJSEnvironment.cpp\\n@@ -154,8 +154,26 @@ static PRLogModuleInfo* gJSDiagnostics;\\n \\n #define JAVASCRIPT nsIProgrammingLanguage::JAVASCRIPT\\n \\n+// The max number of delayed cycle collects..\\n+#define NS_MAX_DELAYED_CCOLLECT     45\\n+// The max number of user interaction notifications in inactive state before\\n+// we try to call cycle collector more aggressively.\\n+#define NS_CC_SOFT_LIMIT_INACTIVE   6\\n+// The max number of user interaction notifications in active state before\\n+// we try to call cycle collector more aggressively.\\n+#define NS_CC_SOFT_LIMIT_ACTIVE     12\\n+// When higher probability MaybeCC is used, the number of sDelayedCCollectCount\\n+// is multiplied with this number.\\n+#define NS_PROBABILITY_MULTIPLIER   3\\n+// Cycle collector should never run more often than this value\\n+#define NS_MIN_CC_INTERVAL          5000 // ms\\n+\\n // if you add statics here, add them to the list in nsJSRuntime::Startup\\n \\n+static PRUint32 sDelayedCCollectCount;\\n+static PRUint32 sCCollectCount;\\n+static PRTime sPreviousCCTime;\\n+static PRBool sPreviousCCDidCollect;\\n static nsITimer *sGCTimer;\\n static PRBool sReadyForGC;\\n \\n@@ -199,6 +217,75 @@ static nsICollation *gCollation;\\n \\n static nsIUnicodeDecoder *gDecoder;\\n \\n+// nsUserActivityObserver observes user-interaction-active and\\n+// user-interaction-inactive notifications. It counts the number of\\n+// notifications and if the number is bigger than NS_CC_SOFT_LIMIT_ACTIVE\\n+// (in case the current notification is user-interaction-active) or\\n+// NS_CC_SOFT_LIMIT_INACTIVE (current notification is user-interaction-inactive)\\n+// MaybeCC is called with aHigherParameter set to PR_TRUE, otherwise PR_FALSE.\\n+//\\n+// When moving from active state to inactive, nsJSContext::CC() is called\\n+// unless the timer related to page load is active.\\n+\\n+class nsUserActivityObserver : public nsIObserver\\n+{\\n+public:\\n+  nsUserActivityObserver()\\n+  : mUserActivityCounter(0), mOldCCollectCount(0), mUserIsActive(PR_FALSE) {}\\n+  NS_DECL_ISUPPORTS\\n+  NS_DECL_NSIOBSERVER\\n+private:\\n+  PRUint32 mUserActivityCounter;\\n+  PRUint32 mOldCCollectCount;\\n+  PRBool   mUserIsActive;\\n+};\\n+\\n+NS_IMPL_ISUPPORTS1(nsUserActivityObserver, nsIObserver)\\n+\\n+NS_IMETHODIMP\\n+nsUserActivityObserver::Observe(nsISupports* aSubject, const char* aTopic,\\n+                                const PRUnichar* aData)\\n+{\\n+  if (mOldCCollectCount != sCCollectCount) {\\n+    mOldCCollectCount = sCCollectCount;\\n+    // Cycle collector was called between user interaction notifications, so\\n+    // we can reset the counter.\\n+    mUserActivityCounter = 0;\\n+  }\\n+  PRBool higherProbability = PR_FALSE;\\n+  ++mUserActivityCounter;\\n+  if (!strcmp(aTopic, \\\"user-interaction-inactive\\\")) {\\n+#ifdef DEBUG_smaug\\n+    printf(\\\"user-interaction-inactive\\\\n\\\");\\n+#endif\\n+    if (mUserIsActive) {\\n+      mUserIsActive = PR_FALSE;\\n+      if (!sGCTimer) {\\n+        nsJSContext::CC();\\n+        return NS_OK;\\n+      }\\n+    }\\n+    higherProbability = (mUserActivityCounter > NS_CC_SOFT_LIMIT_INACTIVE);\\n+  } else if (!strcmp(aTopic, \\\"user-interaction-active\\\")) {\\n+#ifdef DEBUG_smaug\\n+    printf(\\\"user-interaction-active\\\\n\\\");\\n+#endif\\n+    mUserIsActive = PR_TRUE;\\n+    higherProbability = (mUserActivityCounter > NS_CC_SOFT_LIMIT_ACTIVE);\\n+  } else if (!strcmp(aTopic, \\\"xpcom-shutdown\\\")) {\\n+    nsCOMPtr<nsIObserverService> obs =\\n+      do_GetService(\\\"@mozilla.org/observer-service;1\\\");\\n+    if (obs) {\\n+      obs->RemoveObserver(this, \\\"user-interaction-active\\\");\\n+      obs->RemoveObserver(this, \\\"user-interaction-inactive\\\");\\n+      obs->RemoveObserver(this, \\\"xpcom-shutdown\\\");\\n+    }\\n+    return NS_OK;\\n+  }\\n+  nsJSContext::MaybeCC(higherProbability);\\n+  return NS_OK;\\n+}\\n+\\n /****************************************************************\\n  ************************** AutoFree ****************************\\n  ****************************************************************/\\n@@ -3220,6 +3307,73 @@ nsJSContext::PreserveWrapper(nsIXPConnectWrappedNative *aWrapper)\\n   return nsDOMClassInfo::PreserveNodeWrapper(aWrapper);\\n }\\n \\n+//static\\n+void\\n+nsJSContext::MaybeCCOrGC(nsIScriptContext* aContext)\\n+{\\n+  if (!nsJSContext::MaybeCC(PR_TRUE)) {\\n+    nsCOMPtr<nsIScriptContext> context = aContext;\\n+    if (context) {\\n+      JSContext* cx = static_cast<JSContext*>(context->GetNativeContext());\\n+      if (cx) {\\n+#ifdef DEBUG_smaug\\n+        printf(\\\"Will call JS_GC\\\\n\\\");\\n+#endif\\n+        ::JS_GC(cx);\\n+#ifdef DEBUG_smaug\\n+        printf(\\\"Did call JS_GC\\\\n\\\");\\n+#endif\\n+      }\\n+    }\\n+  }\\n+}\\n+\\n+//static\\n+void\\n+nsJSContext::CC()\\n+{\\n+  sPreviousCCTime = PR_Now();\\n+  sDelayedCCollectCount = 0;\\n+  ++sCCollectCount;\\n+#ifdef DEBUG_smaug\\n+  printf(\\\"Will run cycle collector (%i)\\\\n\\\", sCCollectCount);\\n+#endif\\n+  // nsCycleCollector_collect() will run a ::JS_GC() indirectly, so\\n+  // we do not explicitly call ::JS_GC() here.\\n+  sPreviousCCDidCollect = nsCycleCollector_collect();\\n+#ifdef DEBUG_smaug\\n+  printf(\\\"%s\\\\n\\\", sPreviousCCDidCollect ?\\n+                   \\\"Cycle collector did collect nodes\\\" :\\n+                   \\\"Cycle collector did not collect nodes\\\");\\n+#endif\\n+}\\n+\\n+//static\\n+PRBool\\n+nsJSContext::MaybeCC(PRBool aHigherProbability)\\n+{\\n+  ++sDelayedCCollectCount;\\n+  // Increase the probability also if the previous call to cycle collector\\n+  // collected something.\\n+  if (aHigherProbability || sPreviousCCDidCollect) {\\n+    sDelayedCCollectCount *= NS_PROBABILITY_MULTIPLIER;\\n+  }\\n+\\n+  if (!sGCTimer && (sDelayedCCollectCount > NS_MAX_DELAYED_CCOLLECT)) {\\n+    if ((PR_Now() - sPreviousCCTime) >=\\n+        PRTime(NS_MIN_CC_INTERVAL * PR_USEC_PER_MSEC)) {\\n+      nsJSContext::CC();\\n+      return PR_TRUE;\\n+    }\\n+#ifdef DEBUG_smaug\\n+    else {\\n+      printf(\\\"Running cycle collector was delayed: NS_MIN_CC_INTERVAL\\\\n\\\");\\n+    }\\n+#endif\\n+  }\\n+  return PR_FALSE;\\n+}\\n+\\n NS_IMETHODIMP\\n nsJSContext::Notify(nsITimer *timer)\\n {\\n@@ -3238,9 +3392,7 @@ nsJSContext::Notify(nsITimer *timer)\\n     // loading and move on as if they weren't.\\n     sPendingLoadCount = 0;\\n \\n-    // nsCycleCollector_collect() will run a ::JS_GC() indirectly,\\n-    // so we do not explicitly call ::JS_GC() here. \\n-    nsCycleCollector_collect();\\n+    MaybeCCOrGC(this);\\n   } else {\\n     FireGCTimer(PR_TRUE);\\n   }\\n@@ -3259,7 +3411,7 @@ nsJSContext::LoadStart()\\n \\n // static\\n void\\n-nsJSContext::LoadEnd()\\n+nsJSContext::LoadEnd(nsIScriptGlobalObject* aGlobalObject)\\n {\\n   // sPendingLoadCount is not a well managed load counter (and doesn't\\n   // need to be), so make sure we don't make it wrap backwards here.\\n@@ -3269,13 +3421,10 @@ nsJSContext::LoadEnd()\\n \\n   if (!sPendingLoadCount && sLoadInProgressGCTimer) {\\n     sGCTimer->Cancel();\\n-\\n     NS_RELEASE(sGCTimer);\\n     sLoadInProgressGCTimer = PR_FALSE;\\n \\n-    // nsCycleCollector_collect() will run a ::JS_GC() indirectly, so\\n-    // we do not explicitly call ::JS_GC() here.\\n-    nsCycleCollector_collect();\\n+    MaybeCCOrGC(aGlobalObject ? aGlobalObject->GetContext() : nsnull);\\n   }\\n }\\n \\n@@ -3302,10 +3451,7 @@ nsJSContext::FireGCTimer(PRBool aLoadInProgress)\\n     // timer.\\n     sLoadInProgressGCTimer = PR_FALSE;\\n \\n-    // nsCycleCollector_collect() will run a ::JS_GC() indirectly, so\\n-    // we do not explicitly call ::JS_GC() here.\\n-    nsCycleCollector_collect();\\n-\\n+    MaybeCCOrGC(this);\\n     return;\\n   }\\n \\n@@ -3413,6 +3559,10 @@ void\\n nsJSRuntime::Startup()\\n {\\n   // initialize all our statics, so that we can restart XPCOM\\n+  sDelayedCCollectCount = 0;\\n+  sCCollectCount = 0;\\n+  sPreviousCCTime = 0;\\n+  sPreviousCCDidCollect = PR_FALSE;\\n   sGCTimer = nsnull;\\n   sReadyForGC = PR_FALSE;\\n   sLoadInProgressGCTimer = PR_FALSE;\\n@@ -3547,6 +3697,15 @@ nsJSRuntime::Init()\\n   MaxScriptRunTimePrefChangedCallback(\\\"dom.max_chrome_script_run_time\\\",\\n                                       nsnull);\\n \\n+  nsCOMPtr<nsIObserverService> obs =\\n+    do_GetService(\\\"@mozilla.org/observer-service;1\\\", &rv);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+  nsIObserver* activityObserver = new nsUserActivityObserver();\\n+  NS_ENSURE_TRUE(activityObserver, NS_ERROR_OUT_OF_MEMORY);\\n+  obs->AddObserver(activityObserver, \\\"user-interaction-inactive\\\", PR_FALSE);\\n+  obs->AddObserver(activityObserver, \\\"user-interaction-active\\\", PR_FALSE);\\n+  obs->AddObserver(activityObserver, \\\"xpcom-shutdown\\\", PR_FALSE);\\n+\\n   rv = CallGetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &sSecurityManager);\\n \\n   sIsInitialized = NS_SUCCEEDED(rv);\\ndiff --git a/dom/src/base/nsJSEnvironment.h b/dom/src/base/nsJSEnvironment.h\\nindex 01d0187..e074b30 100644\\n--- a/dom/src/base/nsJSEnvironment.h\\n+++ b/dom/src/base/nsJSEnvironment.h\\n@@ -168,7 +168,26 @@ public:\\n   NS_DECL_NSITIMERCALLBACK\\n \\n   static void LoadStart();\\n-  static void LoadEnd();\\n+  static void LoadEnd(nsIScriptGlobalObject* aGlobalObject);\\n+\\n+  // CC does always call cycle collector and it also updates the counters\\n+  // that MaybeCC uses.\\n+  static void CC();\\n+\\n+  // MaybeCC calls cycle collector if certain conditions are fulfilled.\\n+  // The conditions are:\\n+  // - The timer related to page load (sGCTimer) must not be active.\\n+  // - At least NS_MIN_CC_INTERVAL milliseconds must have elapsed since the\\n+  //   previous cycle collector call.\\n+  // - Certain number of MaybeCC calls have occurred.\\n+  //   The number of needed MaybeCC calls depends on the aHigherProbability\\n+  //   parameter. If the parameter is true, probability for calling cycle\\n+  //   collector rises increasingly. If the parameter is all the time false,\\n+  //   at least NS_MAX_DELAYED_CCOLLECT MaybeCC calls are needed.\\n+  //   If the previous call to cycle collector did collect something,\\n+  //   MaybeCC works effectively as if aHigherProbability was true.\\n+  // @return PR_TRUE if cycle collector was called.\\n+  static PRBool MaybeCC(PRBool aHigherProbability);\\n \\n protected:\\n   nsresult InitializeExternalClasses();\\n@@ -191,6 +210,8 @@ protected:\\n   nsresult JSObjectFromInterface(nsISupports *aSup, void *aScript, \\n                                  JSObject **aRet);\\n \\n+  static void MaybeCCOrGC(nsIScriptContext* aContext);\\n+\\n private:\\n   JSContext *mContext;\\n   PRUint32 mNumEvaluations;\\ndiff --git a/layout/base/nsDocumentViewer.cpp b/layout/base/nsDocumentViewer.cpp\\nindex f5d5717..e75864f 100644\\n--- a/layout/base/nsDocumentViewer.cpp\\n+++ b/layout/base/nsDocumentViewer.cpp\\n@@ -993,7 +993,7 @@ DocumentViewerImpl::LoadComplete(nsresult aStatus)\\n     mPresShell->UnsuppressPainting();\\n   }\\n \\n-  nsJSContext::LoadEnd();\\n+  nsJSContext::LoadEnd(mDocument ? mDocument->GetScriptGlobalObject() : nsnull);\\n \\n #ifdef NS_PRINTING\\n   // Check to see if someone tried to print during the load\\ndiff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp\\nindex 3bfbcea..b362041 100644\\n--- a/xpcom/base/nsCycleCollector.cpp\\n+++ b/xpcom/base/nsCycleCollector.cpp\\n@@ -869,7 +869,7 @@ struct nsCycleCollector\\n     PRBool Forget(nsISupports *n);\\n     void Allocated(void *n, size_t sz);\\n     void Freed(void *n);\\n-    void Collect(PRUint32 aTryCollections = 1);\\n+    PRBool Collect(PRUint32 aTryCollections = 1);\\n     void Shutdown();\\n \\n #ifdef DEBUG_CC\\n@@ -2021,9 +2021,10 @@ nsCycleCollector::Freed(void *n)\\n }\\n #endif\\n \\n-void\\n+PRBool\\n nsCycleCollector::Collect(PRUint32 aTryCollections)\\n {\\n+    PRBool didCollect = PR_FALSE;\\n #if defined(DEBUG_CC) && !defined(__MINGW32__)\\n     if (!mParams.mDoNothing && mParams.mHookMalloc)\\n         InitMemHook();\\n@@ -2031,7 +2032,7 @@ nsCycleCollector::Collect(PRUint32 aTryCollections)\\n \\n     // This can legitimately happen in a few cases. See bug 383651.\\n     if (mCollectionInProgress)\\n-        return;\\n+        return didCollect;\\n \\n #ifdef COLLECT_TIME_DEBUG\\n     printf(\\\"cc: Starting nsCycleCollector::Collect(%d)\\\\n\\\", aTryCollections);\\n@@ -2168,8 +2169,11 @@ nsCycleCollector::Collect(PRUint32 aTryCollections)\\n                 // mBuf.GetSize() == 0 check above), we should stop\\n                 // repeating collections if we didn't collect anything\\n                 // this time.\\n-                if (!collected)\\n+                if (!collected) {\\n                     aTryCollections = 0;\\n+                } else {\\n+                    didCollect = PR_TRUE;\\n+                }\\n             }\\n \\n #ifdef DEBUG_CC\\n@@ -2194,6 +2198,7 @@ nsCycleCollector::Collect(PRUint32 aTryCollections)\\n #ifdef DEBUG_CC\\n     ExplainLiveExpectedGarbage();\\n #endif\\n+    return didCollect;\\n }\\n \\n void\\n@@ -2594,11 +2599,10 @@ NS_CycleCollectorForget(nsISupports *n)\\n }\\n \\n \\n-void \\n+PRBool\\n nsCycleCollector_collect()\\n {\\n-    if (sCollector)\\n-        sCollector->Collect();\\n+    return sCollector ? sCollector->Collect() : PR_FALSE;\\n }\\n \\n nsresult \\ndiff --git a/xpcom/base/nsCycleCollector.h b/xpcom/base/nsCycleCollector.h\\nindex 0809ee6..ac8ceb5 100644\\n--- a/xpcom/base/nsCycleCollector.h\\n+++ b/xpcom/base/nsCycleCollector.h\\n@@ -66,7 +66,8 @@ struct nsCycleCollectionLanguageRuntime\\n NS_COM void nsCycleCollector_suspectCurrent(nsISupports *n);\\n // NS_COM PRBool nsCycleCollector_forget(nsISupports *n);\\n nsresult nsCycleCollector_startup();\\n-NS_COM void nsCycleCollector_collect();\\n+// Returns PR_TRUE if some nodes were collected.\\n+NS_COM PRBool nsCycleCollector_collect();\\n void nsCycleCollector_shutdown();\\n \\n #ifdef DEBUG\\n\""}