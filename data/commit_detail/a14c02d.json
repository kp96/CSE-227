{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basa14c02d\""},"diff":"\"a14c02d fix up the way we handle menu separators. this is cleaner and allows them to be hidden and unhidden after creation. b=375011 r=cbarrett sr=roc a=roc\\ndiff --git a/widget/public/nsIMenu.h b/widget/public/nsIMenu.h\\nindex bc6af85..400771f 100644\\n--- a/widget/public/nsIMenu.h\\n+++ b/widget/public/nsIMenu.h\\n@@ -41,7 +41,6 @@\\n #include \\\"nsISupports.h\\\"\\n #include \\\"nsStringFwd.h\\\"\\n \\n-class nsIDocShell;\\n class nsIMenuBar;\\n class nsIMenu;\\n class nsIMenuItem;\\n@@ -68,8 +67,8 @@ class nsIMenu : public nsISupports {\\n     * Creates the Menu\\n     *\\n     */\\n-    NS_IMETHOD Create ( nsISupports * aParent, const nsAString &aLabel, const nsAString &aAccessKey, \\n-                          nsIChangeManager* aManager, nsIDocShell* aShell, nsIContent* aNode ) = 0;\\n+    NS_IMETHOD Create(nsISupports * aParent, const nsAString &aLabel, const nsAString &aAccessKey, \\n+                      nsIChangeManager* aManager, nsIContent* aNode) = 0;\\n \\n    /**\\n     * Get the Menu's Parent.  This addrefs.\\n@@ -121,13 +120,6 @@ class nsIMenu : public nsISupports {\\n     NS_IMETHOD AddItem(nsISupports* aItem) = 0;\\n \\n    /**\\n-    * Adds a separator. Do not use outside of widget menu implementations.\\n-    * Add and modify menu separators via DOM content.\\n-    *\\n-    */\\n-    NS_IMETHOD AddSeparator() = 0;\\n-\\n-   /**\\n     * Returns the number of visible menu items\\n     * This includes separators. It does not include hidden items.\\n     *\\ndiff --git a/widget/public/nsIMenuItem.h b/widget/public/nsIMenuItem.h\\nindex 6d86b68..729ccac 100644\\n--- a/widget/public/nsIMenuItem.h\\n+++ b/widget/public/nsIMenuItem.h\\n@@ -42,7 +42,6 @@\\n #include \\\"nsISupports.h\\\"\\n #include \\\"nsString.h\\\"\\n \\n-#include \\\"nsIDocShell.h\\\"\\n #include \\\"nsIDOMElement.h\\\"\\n \\n // {F9A30AA5-D526-4C19-8418-C21BF6B31837}\\n@@ -72,16 +71,15 @@ class nsIMenuItem : public nsISupports {\\n   public:\\n     NS_DECLARE_STATIC_IID_ACCESSOR(NS_IMENUITEM_IID)\\n \\n-    enum EMenuItemType { eRegular = 0, eCheckbox, eRadio } ;\\n+    enum EMenuItemType { eRegular = 0, eCheckbox, eRadio, eSeparator} ;\\n \\n    /**\\n     * Creates the MenuItem\\n     *\\n     */\\n-    NS_IMETHOD Create(nsIMenu* aParent, const nsString & aLabel, PRBool isSeparator, \\n-                      EMenuItemType aItemType, nsIChangeManager* aManager,\\n-                      nsIDocShell* aShell, nsIContent* aNode) = 0;\\n-    \\n+    NS_IMETHOD Create(nsIMenu* aParent, const nsString & aLabel, EMenuItemType aItemType,\\n+                      nsIChangeManager* aManager, nsIContent* aNode) = 0;\\n+\\n    /**\\n     * Get the MenuItem label\\n     *\\ndiff --git a/widget/src/cocoa/nsMenuBarX.mm b/widget/src/cocoa/nsMenuBarX.mm\\nindex 15e341b..71ef1dc 100644\\n--- a/widget/src/cocoa/nsMenuBarX.mm\\n+++ b/widget/src/cocoa/nsMenuBarX.mm\\n@@ -445,14 +445,13 @@ nsMenuBarX::MenuConstruct(const nsMenuEvent & aMenuEvent, nsIWidget* aParentWind\\n         menu->GetAttr(kNameSpaceID_None, nsWidgetAtoms::accesskey, menuAccessKey);\\n \\n         // Don't create the whole menu yet, just add in the top level names\\n-        \\n+\\n         // Create nsMenu, the menubar will own it\\n         nsCOMPtr<nsIMenu> pnsMenu(do_CreateInstance(kMenuCID));\\n         if (pnsMenu) {\\n           pnsMenu->Create(static_cast<nsIMenuBar*>(this), menuName, menuAccessKey, \\n-                          static_cast<nsIChangeManager *>(this), \\n-                          nsnull, menu);\\n-          \\n+                          static_cast<nsIChangeManager *>(this), menu);\\n+\\n           // Make nsMenu a child of nsMenuBar. nsMenuBar takes ownership.\\n           AddMenu(pnsMenu);\\n           \\ndiff --git a/widget/src/cocoa/nsMenuItemIconX.mm b/widget/src/cocoa/nsMenuItemIconX.mm\\nindex dc5ed03..96e30e1 100644\\n--- a/widget/src/cocoa/nsMenuItemIconX.mm\\n+++ b/widget/src/cocoa/nsMenuItemIconX.mm\\n@@ -154,8 +154,7 @@ nsMenuItemIconX::GetIconURI(nsIURI** aIconURI)\\n   if (menuItem) {\\n     nsIMenuItem::EMenuItemType menuItemType;\\n     menuItem->GetMenuItemType(&menuItemType);\\n-    if (menuItemType == nsIMenuItem::eCheckbox ||\\n-        menuItemType == nsIMenuItem::eRadio)\\n+    if (menuItemType != nsIMenuItem::eRegular)\\n       return NS_ERROR_FAILURE;\\n   }\\n \\ndiff --git a/widget/src/cocoa/nsMenuItemX.h b/widget/src/cocoa/nsMenuItemX.h\\nindex e264830..ff83676 100644\\n--- a/widget/src/cocoa/nsMenuItemX.h\\n+++ b/widget/src/cocoa/nsMenuItemX.h\\n@@ -71,9 +71,8 @@ public:\\n   NS_DECL_NSICHANGEOBSERVER\\n \\n   // nsIMenuItem Methods\\n-  NS_IMETHOD Create(nsIMenu* aParent, const nsString & aLabel, PRBool aIsSeparator,\\n-                    EMenuItemType aItemType, nsIChangeManager* aManager,\\n-                    nsIDocShell* aShell, nsIContent* aNode);\\n+  NS_IMETHOD Create(nsIMenu* aParent, const nsString & aLabel, EMenuItemType aItemType,\\n+                    nsIChangeManager* aManager, nsIContent* aNode);\\n   NS_IMETHOD GetLabel(nsString &aText);\\n   NS_IMETHOD SetShortcutChar(const nsString &aText);\\n   NS_IMETHOD GetShortcutChar(nsString &aText);\\n@@ -122,10 +121,9 @@ protected:\\n   nsRefPtr<nsMenuItemIconX> mIcon;\\n   \\n   PRUint8           mModifiers;\\n-  PRPackedBool      mIsSeparator;\\n   PRPackedBool      mEnabled;\\n   PRPackedBool      mIsChecked;\\n-  EMenuItemType     mMenuType;\\n+  EMenuItemType     mType; // regular, checkbox, radio, or separator\\n };\\n \\n #endif // nsMenuItemX_h_\\ndiff --git a/widget/src/cocoa/nsMenuItemX.mm b/widget/src/cocoa/nsMenuItemX.mm\\nindex 1a48dc5..1ca20ee 100644\\n--- a/widget/src/cocoa/nsMenuItemX.mm\\n+++ b/widget/src/cocoa/nsMenuItemX.mm\\n@@ -67,11 +67,10 @@ nsMenuItemX::nsMenuItemX()\\n   mNativeMenuItem     = nil;\\n   mMenuParent         = nsnull;\\n   mManager            = nsnull;\\n-  mIsSeparator        = PR_FALSE;\\n   mKeyEquivalent.AssignLiteral(\\\" \\\");\\n   mEnabled            = PR_TRUE;\\n   mIsChecked          = PR_FALSE;\\n-  mMenuType           = eRegular;\\n+  mType               = eRegular;\\n }\\n \\n \\n@@ -85,15 +84,14 @@ nsMenuItemX::~nsMenuItemX()\\n }\\n \\n \\n-NS_METHOD nsMenuItemX::Create(nsIMenu* aParent, const nsString & aLabel, PRBool aIsSeparator,\\n-                              EMenuItemType aItemType, nsIChangeManager* aManager,\\n-                              nsIDocShell* aShell, nsIContent* aNode)\\n+NS_METHOD nsMenuItemX::Create(nsIMenu* aParent, const nsString & aLabel, EMenuItemType aItemType,\\n+                              nsIChangeManager* aManager, nsIContent* aNode)\\n {\\n   mContent = aNode;      // addref\\n   mMenuParent = aParent; // weak\\n-  \\n-  mMenuType = aItemType;\\n-  \\n+\\n+  mType = aItemType;\\n+\\n   // register for AttributeChanged messages\\n   mManager = aManager;\\n   nsCOMPtr<nsIChangeObserver> obs = do_QueryInterface(static_cast<nsIChangeObserver*>(this));\\n@@ -126,11 +124,10 @@ NS_METHOD nsMenuItemX::Create(nsIMenu* aParent, const nsString & aLabel, PRBool\\n   else\\n     mEnabled = !mContent->AttrValueIs(kNameSpaceID_None, nsWidgetAtoms::disabled, nsWidgetAtoms::_true, eCaseMatters);\\n   \\n-  mIsSeparator = aIsSeparator;\\n   mLabel = aLabel;\\n   \\n   // set up the native menu item\\n-  if (aIsSeparator) {\\n+  if (mType == nsIMenuItem::eSeparator) {\\n     mNativeMenuItem = [[NSMenuItem separatorItem] retain];\\n   }\\n   else {\\n@@ -218,7 +215,7 @@ NS_METHOD nsMenuItemX::GetChecked(PRBool *aIsEnabled)\\n \\n NS_METHOD nsMenuItemX::GetMenuItemType(EMenuItemType *aType)\\n {\\n-  *aType = mMenuType;\\n+  *aType = mType;\\n   return NS_OK;\\n }\\n \\n@@ -247,7 +244,7 @@ NS_METHOD nsMenuItemX::RemoveMenuListener(nsIMenuListener * aMenuListener)\\n \\n NS_METHOD nsMenuItemX::IsSeparator(PRBool & aIsSep)\\n {\\n-  aIsSep = mIsSeparator;\\n+  aIsSep = (mType == nsIMenuItem::eSeparator);\\n   return NS_OK;\\n }\\n \\n@@ -312,11 +309,11 @@ nsEventStatus nsMenuItemX::SetRebuild(PRBool aNeedsRebuild)\\n \\n // Executes the \\\"cached\\\" javaScript command.\\n // Returns NS_OK if the command was executed properly, otherwise an error code.\\n-NS_METHOD nsMenuItemX::DoCommand()\\n+NS_IMETHODIMP nsMenuItemX::DoCommand()\\n {\\n   // flip \\\"checked\\\" state if we're a checkbox menu, or an un-checked radio menu\\n-  if (mMenuType == nsIMenuItem::eCheckbox ||\\n-      (mMenuType == nsIMenuItem::eRadio && !mIsChecked)) {\\n+  if (mType == nsIMenuItem::eCheckbox ||\\n+      (mType == nsIMenuItem::eRadio && !mIsChecked)) {\\n     if (!mContent->AttrValueIs(kNameSpaceID_None, nsWidgetAtoms::autocheck,\\n                                nsWidgetAtoms::_false, eCaseMatters))\\n     SetChecked(!mIsChecked);\\n@@ -327,7 +324,7 @@ NS_METHOD nsMenuItemX::DoCommand()\\n   nsXULCommandEvent event(PR_TRUE, NS_XUL_COMMAND, nsnull);\\n \\n   mContent->DispatchDOMEvent(&event, nsnull, nsnull, &status);\\n-  return nsEventStatus_eConsumeNoDefault;\\n+  return NS_OK;\\n }\\n     \\n \\n@@ -460,7 +457,7 @@ nsMenuItemX::AttributeChanged(nsIDocument *aDocument, PRInt32 aNameSpaceID, nsIC\\n     if (aAttribute == nsWidgetAtoms::checked) {\\n       // if we're a radio menu, uncheck our sibling radio items. No need to\\n       // do any of this if we're just a normal check menu.\\n-      if (mMenuType == eRadio) {\\n+      if (mType == nsIMenuItem::eRadio) {\\n         if (mContent->AttrValueIs(kNameSpaceID_None, nsWidgetAtoms::checked,\\n                                   nsWidgetAtoms::_true, eCaseMatters))\\n           UncheckRadioSiblings(mContent);\\ndiff --git a/widget/src/cocoa/nsMenuX.h b/widget/src/cocoa/nsMenuX.h\\nindex c79f2c6..b4cd55c 100644\\n--- a/widget/src/cocoa/nsMenuX.h\\n+++ b/widget/src/cocoa/nsMenuX.h\\n@@ -96,15 +96,14 @@ public:\\n     nsEventStatus SetRebuild(PRBool aMenuEvent);\\n \\n     // nsIMenu Methods\\n-    NS_IMETHOD Create (nsISupports * aParent, const nsAString &aLabel, const nsAString &aAccessKey, \\n-                       nsIChangeManager* aManager, nsIDocShell* aShell, nsIContent* aNode);\\n+    NS_IMETHOD Create(nsISupports * aParent, const nsAString &aLabel, const nsAString &aAccessKey, \\n+                      nsIChangeManager* aManager, nsIContent* aNode);\\n     NS_IMETHOD GetParent(nsISupports *&aParent);\\n     NS_IMETHOD GetLabel(nsString &aText);\\n     NS_IMETHOD SetLabel(const nsAString &aText);\\n     NS_IMETHOD GetAccessKey(nsString &aText);\\n     NS_IMETHOD SetAccessKey(const nsAString &aText);\\n     NS_IMETHOD AddItem(nsISupports* aText);\\n-    NS_IMETHOD AddSeparator();\\n     NS_IMETHOD GetItemCount(PRUint32 &aCount);\\n     NS_IMETHOD GetItemAt(const PRUint32 aPos, nsISupports *& aMenuItem);\\n     NS_IMETHOD GetVisibleItemCount(PRUint32 &aCount);\\n@@ -145,7 +144,6 @@ protected:\\n \\n     void LoadMenuItem(nsIContent* inMenuItemContent);  \\n     void LoadSubMenu(nsIContent* inMenuContent);\\n-    void LoadSeparator(nsIContent* inSeparatorContent);\\n \\n     NSMenu* CreateMenuWithGeckoString(nsString& menuTitle);\\n \\ndiff --git a/widget/src/cocoa/nsMenuX.mm b/widget/src/cocoa/nsMenuX.mm\\nindex 3d7fd0b..1e5162d 100644\\n--- a/widget/src/cocoa/nsMenuX.mm\\n+++ b/widget/src/cocoa/nsMenuX.mm\\n@@ -86,22 +86,6 @@ static PRBool gConstructingMenu = PR_FALSE;\\n static NS_DEFINE_CID(kMenuCID,     NS_MENU_CID);\\n static NS_DEFINE_CID(kMenuItemCID, NS_MENUITEM_CID);\\n \\n-// Refcounted class for dummy menu items like separators\\n-class nsDummyMenuItemX : public nsISupports {\\n-public:\\n-    NS_DECL_ISUPPORTS\\n-\\n-    nsDummyMenuItemX()\\n-    {\\n-    }\\n-};\\n-\\n-NS_IMETHODIMP_(nsrefcnt) nsDummyMenuItemX::AddRef() { return ++mRefCnt; }\\n-NS_IMETHODIMP nsDummyMenuItemX::Release() { return --mRefCnt; }\\n-NS_IMPL_QUERY_INTERFACE0(nsDummyMenuItemX)\\n-static nsDummyMenuItemX gDummyMenuItemX;\\n-\\n-\\n NS_IMPL_ISUPPORTS4(nsMenuX, nsIMenu, nsIMenuListener, nsIChangeObserver, nsISupportsWeakReference)\\n \\n \\n@@ -133,7 +117,7 @@ nsMenuX::~nsMenuX()\\n \\n NS_IMETHODIMP \\n nsMenuX::Create(nsISupports * aParent, const nsAString &aLabel, const nsAString &aAccessKey, \\n-                nsIChangeManager* aManager, nsIDocShell* aShell, nsIContent* aNode)\\n+                nsIChangeManager* aManager, nsIContent* aNode)\\n {\\n   mMenuContent = aNode;\\n \\n@@ -308,17 +292,6 @@ nsresult nsMenuX::AddMenu(nsIMenu * aMenu)\\n }\\n \\n \\n-NS_IMETHODIMP nsMenuX::AddSeparator()\\n-{\\n-  // We're not really appending an nsMenuItem but a placeholder needs to be\\n-  // here to make sure that event dispatching isn't off by one.\\n-  mMenuItemsArray.AppendObject(&gDummyMenuItemX);  // owning ref\\n-  ++mVisibleItemsCount;\\n-  [mMacMenu addItem:[NSMenuItem separatorItem]];\\n-  return NS_OK;\\n-}\\n-\\n-\\n // Includes all items, including hidden/collapsed ones\\n NS_IMETHODIMP nsMenuX::GetItemCount(PRUint32 &aCount)\\n {\\n@@ -346,10 +319,7 @@ static PRBool MenuNodeIsVisible(nsISupports *item)\\n   // Find the content for this item in the menu, be it a MenuItem or a Menu\\n   nsCOMPtr<nsIContent> itemContent;\\n   nsCOMPtr<nsIMenuItem> menuItem = do_QueryInterface(item);\\n-  if (item == &gDummyMenuItemX) {\\n-    return PR_TRUE;\\n-  }\\n-  else if (menuItem) {\\n+  if (menuItem) {\\n     menuItem->GetMenuItemContent(getter_AddRefs(itemContent));\\n   }\\n   else {\\n@@ -596,10 +566,8 @@ nsEventStatus nsMenuX::MenuConstruct(\\n     if (child) {\\n       // depending on the type, create a menu item, separator, or submenu\\n       nsIAtom *tag = child->Tag();\\n-      if (tag == nsWidgetAtoms::menuitem)\\n+      if (tag == nsWidgetAtoms::menuitem || tag == nsWidgetAtoms::menuseparator)\\n         LoadMenuItem(child);\\n-      else if (tag == nsWidgetAtoms::menuseparator)\\n-        LoadSeparator(child);\\n       else if (tag == nsWidgetAtoms::menu)\\n         LoadSubMenu(child);\\n     }\\n@@ -707,18 +675,22 @@ void nsMenuX::LoadMenuItem(nsIContent* inMenuItemContent)\\n \\n   // printf(\\\"menuitem %s \\\\n\\\", NS_LossyConvertUTF16toASCII(menuitemName).get());\\n \\n-  static nsIContent::AttrValuesArray strings[] =\\n-  {&nsWidgetAtoms::checkbox, &nsWidgetAtoms::radio, nsnull};\\n   nsIMenuItem::EMenuItemType itemType = nsIMenuItem::eRegular;\\n-  switch (inMenuItemContent->FindAttrValueIn(kNameSpaceID_None, nsWidgetAtoms::type,\\n-                                             strings, eCaseMatters)) {\\n-    case 0: itemType = nsIMenuItem::eCheckbox; break;\\n-    case 1: itemType = nsIMenuItem::eRadio; break;\\n+  if (inMenuItemContent->Tag() == nsWidgetAtoms::menuseparator) {\\n+    itemType = nsIMenuItem::eSeparator;\\n+  }\\n+  else {\\n+    static nsIContent::AttrValuesArray strings[] =\\n+  {&nsWidgetAtoms::checkbox, &nsWidgetAtoms::radio, nsnull};\\n+    switch (inMenuItemContent->FindAttrValueIn(kNameSpaceID_None, nsWidgetAtoms::type,\\n+                                               strings, eCaseMatters)) {\\n+      case 0: itemType = nsIMenuItem::eCheckbox; break;\\n+      case 1: itemType = nsIMenuItem::eRadio; break;\\n+    }\\n   }\\n \\n   // Create the item.\\n-  pnsMenuItem->Create(this, menuitemName, PR_FALSE, itemType, mManager,\\n-                      nsnull, inMenuItemContent);\\n+  pnsMenuItem->Create(this, menuitemName, itemType, mManager, inMenuItemContent);\\n \\n   AddMenuItem(pnsMenuItem);\\n \\n@@ -739,7 +711,7 @@ void nsMenuX::LoadSubMenu(nsIContent* inMenuContent)\\n   if (!pnsMenu)\\n     return;\\n \\n-  pnsMenu->Create(reinterpret_cast<nsISupports*>(this), menuName, EmptyString(), mManager, nsnull, inMenuContent);\\n+  pnsMenu->Create(reinterpret_cast<nsISupports*>(this), menuName, EmptyString(), mManager, inMenuContent);\\n \\n   AddMenu(pnsMenu);\\n \\n@@ -749,17 +721,6 @@ void nsMenuX::LoadSubMenu(nsIContent* inMenuContent)\\n }\\n \\n \\n-void nsMenuX::LoadSeparator(nsIContent* inSeparatorContent) \\n-{\\n-  // See bug 375011.\\n-  // Currently we don't create nsIMenuItem objects for separators so we can't\\n-  // track changes in their hidden/collapsed attributes. If it is hidden now it\\n-  // is hidden forever.\\n-  if (!NodeIsHiddenOrCollapsed(inSeparatorContent))\\n-    AddSeparator();\\n-}\\n-\\n-\\n // Fire our oncreate handler. Returns TRUE if we should keep processing the event,\\n // FALSE if the handler wants to stop the creation of the menu\\n PRBool nsMenuX::OnCreate()\\n\""}