{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas4ad1986\""},"diff":"\"4ad1986 Fix for protocol handling dialog throwing exception when a web handler is selected (bug 392957), r=biesi, sr=mconnor, a=bz\\ndiff --git a/docshell/base/nsWebShell.cpp b/docshell/base/nsWebShell.cpp\\nindex 35c2eca..d561c75 100644\\n--- a/docshell/base/nsWebShell.cpp\\n+++ b/docshell/base/nsWebShell.cpp\\n@@ -818,7 +818,7 @@ nsWebShell::OnLinkClickSync(nsIContent *aContent,\\n         PRBool isExposed;\\n         nsresult rv = extProtService->IsExposedProtocol(scheme.get(), &isExposed);\\n         if (NS_SUCCEEDED(rv) && !isExposed) {\\n-          return extProtService->LoadUrl(aURI);\\n+          return extProtService->LoadURI(aURI, this); \\n         }\\n       }\\n     }\\ndiff --git a/netwerk/mime/public/nsIMIMEInfo.idl b/netwerk/mime/public/nsIMIMEInfo.idl\\nindex 1534c94..57286e6 100644\\n--- a/netwerk/mime/public/nsIMIMEInfo.idl\\n+++ b/netwerk/mime/public/nsIMIMEInfo.idl\\n@@ -43,6 +43,7 @@ interface nsIFile;\\n interface nsIUTF8StringEnumerator;\\n interface nsIHandlerApp;\\n interface nsIMutableArray;\\n+interface nsIInterfaceRequestor;\\n \\n typedef long nsHandlerInfoAction;\\n \\n@@ -50,7 +51,7 @@ typedef long nsHandlerInfoAction;\\n  * nsIHandlerInfo gives access to the information about how a given protocol\\n  * scheme or MIME-type is handled.\\n  */\\n-[scriptable, uuid(4c7f5603-cfa9-4576-a769-c3343cb0135b)]\\n+[scriptable, uuid(325e56a7-3762-4312-aec7-f1fcf84b4145)]\\n interface nsIHandlerInfo : nsISupports {\\n     /**\\n      * The type of this handler info.  For MIME handlers, this is the MIME type.\\n@@ -106,12 +107,22 @@ interface nsIHandlerInfo : nsISupports {\\n      * and our code will not make any decision based on the content-type or\\n      * extension, though the invoked file: handler is free to do so. \\n      *\\n-     * @param aURI The URI to launch this application with\\n+     * @param aURI\\n+     *        The URI to launch this application with\\n      *\\n-     * @throw NS_ERROR_INVALID_ARG if action is not valid for this function.\\n-     * Other exceptions may be thrown.\\n+     * @param aWindowContext \\n+     *        The window to parent the dialog against, and, if a web handler\\n+     *        is chosen, it is loaded in this window as well.  This parameter\\n+     *        may be ultimately passed nsIURILoader.openURI in the case of a\\n+     *        web handler, and aWindowContext is null or not present, web\\n+     *        handlers will fail.  We need to do better than that; bug 394483\\n+     *        filed in order to track.\\n+     *       \\n+     * @throw NS_ERROR_INVALID_ARG if preferredAction is not valid for this\\n+     * call. Other exceptions may be thrown.\\n      */\\n-    void launchWithURI(in nsIURI aURI);\\n+    void launchWithURI(in nsIURI aURI, \\n+                       [optional] in nsIInterfaceRequestor aWindowContext);\\n \\n     /**\\n      * preferredAction is how the user specified they would like to handle\\ndiff --git a/toolkit/mozapps/handling/content/dialog.js b/toolkit/mozapps/handling/content/dialog.js\\nindex 90b5b32..2bb1b2d 100644\\n--- a/toolkit/mozapps/handling/content/dialog.js\\n+++ b/toolkit/mozapps/handling/content/dialog.js\\n@@ -20,6 +20,7 @@\\n  *\\n  * Contributor(s):\\n  *   Shawn Wilsher <me@shawnwilsher.com> (original author)\\n+ *   Dan Mosedale <dmose@mozilla.org>\\n  *\\n  * Alternatively, the contents of this file may be used under the terms of\\n  * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n@@ -55,6 +56,8 @@\\n  *   This is the nsIHandlerInfo that gives us all our precious information.\\n  * window.arguments[7]:\\n  *   This is the nsIURI that we are being brought up for in the first place.\\n+ * window.arguments[8]:\\n+ *   The nsIInterfaceRequestor of the parent window; may be null\\n  */\\n \\n const Cc = Components.classes;\\n@@ -69,7 +72,8 @@ var dialog = {\\n   _URI: null,\\n   _itemChoose: null,\\n   _okButton: null,\\n-\\n+  _windowCtxt: null,\\n+  \\n   //////////////////////////////////////////////////////////////////////////////\\n   //// Methods\\n \\n@@ -80,6 +84,9 @@ var dialog = {\\n   {\\n     this._handlerInfo = window.arguments[6].QueryInterface(Ci.nsIHandlerInfo);\\n     this._URI         = window.arguments[7].QueryInterface(Ci.nsIURI);\\n+    this._windowCtxt  = window.arguments[8];\\n+    if (this._windowCtxt)\\n+      this._windowCtxt.QueryInterface(Ci.nsIInterfaceRequestor);\\n     this._itemChoose  = document.getElementById(\\\"item-choose\\\");\\n     this._okButton    = document.documentElement.getButton(\\\"accept\\\");\\n \\n@@ -202,7 +209,7 @@ var dialog = {\\n              getService(Ci.nsIHandlerService);\\n     hs.store(this._handlerInfo);\\n \\n-    this._handlerInfo.launchWithURI(this._URI);\\n+    this._handlerInfo.launchWithURI(this._URI, this._windowCtxt);\\n \\n     return true;\\n   },\\ndiff --git a/toolkit/mozapps/handling/src/nsContentDispatchChooser.js b/toolkit/mozapps/handling/src/nsContentDispatchChooser.js\\nindex 156fb31..02a8d0c 100644\\n--- a/toolkit/mozapps/handling/src/nsContentDispatchChooser.js\\n+++ b/toolkit/mozapps/handling/src/nsContentDispatchChooser.js\\n@@ -20,6 +20,7 @@\\n  *\\n  * Contributor(s):\\n  *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)\\n+ *   Dan Mosedale <dmose@mozilla.org>\\n  *\\n  * Alternatively, the contents of this file may be used under the terms of\\n  * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n@@ -99,7 +100,8 @@ nsContentDispatchChooser.prototype =\\n     }\\n     params.appendElement(aHandler, false);\\n     params.appendElement(aURI, false);\\n-\\n+    params.appendElement(aWindowContext, false);\\n+    \\n     var ww = Cc[\\\"@mozilla.org/embedcomp/window-watcher;1\\\"].\\n              getService(Ci.nsIWindowWatcher);\\n     ww.openWindow(window,\\ndiff --git a/uriloader/exthandler/mac/nsMIMEInfoMac.cpp b/uriloader/exthandler/mac/nsMIMEInfoMac.cpp\\nindex 685e2c6..b6e5ad0 100755\\n--- a/uriloader/exthandler/mac/nsMIMEInfoMac.cpp\\n+++ b/uriloader/exthandler/mac/nsMIMEInfoMac.cpp\\n@@ -100,7 +100,8 @@ nsMIMEInfoMac::LaunchWithFile(nsIFile *aFile)\\n }\\n \\n NS_IMETHODIMP\\n-nsMIMEInfoMac::LaunchWithURI(nsIURI* aURI)\\n+nsMIMEInfoMac::LaunchWithURI(nsIURI* aURI,\\n+                             nsIInterfaceRequestor* aWindowContext)\\n {\\n   nsCOMPtr<nsIFile> application;\\n   nsresult rv;\\n@@ -117,7 +118,7 @@ nsMIMEInfoMac::LaunchWithURI(nsIURI* aURI)\\n     nsCOMPtr<nsIWebHandlerApp> webHandlerApp =\\n       do_QueryInterface(mPreferredApplication, &rv);\\n     if (NS_SUCCEEDED(rv)) {\\n-      return LaunchWithWebHandler(webHandlerApp, aURI);         \\n+      return LaunchWithWebHandler(webHandlerApp, aURI, aWindowContext);         \\n     }\\n \\n     // otherwise, get the application executable from the handler\\ndiff --git a/uriloader/exthandler/mac/nsMIMEInfoMac.h b/uriloader/exthandler/mac/nsMIMEInfoMac.h\\nindex 6ac99b1..bc302ef1 100755\\n--- a/uriloader/exthandler/mac/nsMIMEInfoMac.h\\n+++ b/uriloader/exthandler/mac/nsMIMEInfoMac.h\\n@@ -46,7 +46,8 @@ class nsMIMEInfoMac : public nsMIMEInfoImpl {\\n     nsMIMEInfoMac(const nsACString& aType, HandlerClass aClass) :\\n       nsMIMEInfoImpl(aType, aClass) {}\\n \\n-    NS_IMETHOD LaunchWithURI(nsIURI* aURI);\\n+    NS_IMETHOD LaunchWithURI(nsIURI* aURI,\\n+                             nsIInterfaceRequestor* aWindowContext);\\n     NS_IMETHOD LaunchWithFile(nsIFile* aFile);\\n     NS_IMETHOD GetHasDefaultHandler(PRBool *_retval);\\n   protected:\\ndiff --git a/uriloader/exthandler/nsExternalHelperAppService.cpp b/uriloader/exthandler/nsExternalHelperAppService.cpp\\nindex a032ba5..1513b3b 100644\\n--- a/uriloader/exthandler/nsExternalHelperAppService.cpp\\n+++ b/uriloader/exthandler/nsExternalHelperAppService.cpp\\n@@ -124,7 +124,6 @@\\n \\n #include \\\"nsCRT.h\\\"\\n \\n-#include \\\"nsMIMEInfoImpl.h\\\"\\n #include \\\"nsLocalHandlerApp.h\\\"\\n \\n #ifdef PR_LOGGING\\n@@ -1339,7 +1338,7 @@ nsExternalHelperAppService::LoadURI(nsIURI *aURI,\\n   if (!warn &&\\n       !alwaysAsk && (preferredAction == nsIHandlerInfo::useHelperApp ||\\n                      preferredAction == nsIHandlerInfo::useSystemDefault))\\n-    return handler->LaunchWithURI(uri);\\n+    return handler->LaunchWithURI(uri, aWindowContext);\\n   \\n   nsCOMPtr<nsIContentDispatchChooser> chooser =\\n     do_CreateInstance(\\\"@mozilla.org/content-dispatch-chooser;1\\\", &rv);\\n@@ -1407,10 +1406,6 @@ nsExternalHelperAppService::GetProtocolHandlerInfo(const nsACString &aScheme,\\n   // XXX enterprise customers should be able to turn this support off with a\\n   // single master pref (maybe use one of the \\\"exposed\\\" prefs here?)\\n \\n-  // nsIMIMEInfo is a superset of nsIHandlerInfo.  Furthermore, nsMimeInfoImpl\\n-  // and subclasses have lots of good platform specific-knowledge of local\\n-  // applications which we might need later.  For now, just use nsMIMEInfoImpl\\n-  // instead of implementating a separate nsIHandlerInfo object.\\n   PRBool exists;\\n   *aHandlerInfo = GetProtocolInfoFromOS(aScheme, &exists).get();\\n   if (!(*aHandlerInfo)) {\\ndiff --git a/uriloader/exthandler/nsExternalProtocolHandler.cpp b/uriloader/exthandler/nsExternalProtocolHandler.cpp\\nindex d164654..8133136 100644\\n--- a/uriloader/exthandler/nsExternalProtocolHandler.cpp\\n+++ b/uriloader/exthandler/nsExternalProtocolHandler.cpp\\n@@ -53,9 +53,6 @@\\n #include \\\"nsIPrefService.h\\\"\\n #include \\\"nsIPrompt.h\\\"\\n #include \\\"nsNetUtil.h\\\"\\n-#include \\\"nsIChannelEventSink.h\\\"\\n-#include \\\"nsThreadUtils.h\\\"\\n-#include \\\"nsEscape.h\\\"\\n #include \\\"nsExternalHelperAppService.h\\\"\\n \\n // used to dispatch urls to default protocol handlers\\n@@ -69,8 +66,6 @@\\n \\n class nsExtProtocolChannel : public nsIChannel\\n {\\n-    friend class nsProtocolRedirect;\\n-\\n public:\\n     NS_DECL_ISUPPORTS\\n     NS_DECL_NSICHANNEL\\n@@ -89,13 +84,10 @@ private:\\n     nsCOMPtr<nsIURI> mOriginalURI;\\n     nsresult mStatus;\\n     nsLoadFlags mLoadFlags;\\n-    PRBool mIsPending;\\n     PRBool mWasOpened;\\n     \\n     nsCOMPtr<nsIInterfaceRequestor> mCallbacks;\\n     nsCOMPtr<nsILoadGroup> mLoadGroup;\\n-    nsCOMPtr<nsIStreamListener> mListener;\\n-    nsCOMPtr<nsISupports> mContext;\\n };\\n \\n NS_IMPL_THREADSAFE_ADDREF(nsExtProtocolChannel)\\n@@ -108,7 +100,6 @@ NS_INTERFACE_MAP_BEGIN(nsExtProtocolChannel)\\n NS_INTERFACE_MAP_END_THREADSAFE\\n \\n nsExtProtocolChannel::nsExtProtocolChannel() : mStatus(NS_OK), \\n-                                               mIsPending(PR_FALSE),\\n                                                mWasOpened(PR_FALSE)\\n {\\n }\\n@@ -188,233 +179,40 @@ nsresult nsExtProtocolChannel::OpenURL()\\n     NS_ASSERTION(haveHandler, \\\"Why do we have a channel for this url if we don't support the protocol?\\\");\\n #endif\\n \\n-    rv = extProtService->LoadURI(mUrl, mCallbacks);\\n+    nsCOMPtr<nsIInterfaceRequestor> aggCallbacks;\\n+    rv = NS_NewNotificationCallbacksAggregation(mCallbacks, mLoadGroup,\\n+                                                getter_AddRefs(aggCallbacks));\\n+    if (NS_FAILED(rv)) {\\n+      goto finish;\\n+    }\\n+                                                \\n+    rv = extProtService->LoadURI(mUrl, aggCallbacks);\\n+    if (NS_SUCCEEDED(rv)) {\\n+        // despite success, we need to abort this channel, at the very least \\n+        // to make it clear to the caller that no on{Start,Stop}Request\\n+        // should be expected.\\n+        rv = NS_ERROR_NO_CONTENT;\\n+    }\\n   }\\n \\n-  // Drop notification callbacks to prevent cycles.\\n+finish:\\n   mCallbacks = 0;\\n-\\n   return rv;\\n }\\n \\n NS_IMETHODIMP nsExtProtocolChannel::Open(nsIInputStream **_retval)\\n {\\n-  OpenURL();\\n-  return NS_ERROR_NO_CONTENT; // force caller to abort.\\n+  return OpenURL();\\n }\\n \\n-class nsProtocolRedirect : public nsRunnable {\\n-  public:\\n-    nsProtocolRedirect(nsIURI *aURI, nsIHandlerInfo *aHandlerInfo,\\n-                       nsIStreamListener *aListener, nsISupports *aContext,\\n-                       nsExtProtocolChannel *aOriginalChannel)\\n-      : mURI(aURI), mHandlerInfo(aHandlerInfo), mListener(aListener), \\n-        mContext(aContext), mOriginalChannel(aOriginalChannel) {}\\n-\\n-    NS_IMETHOD Run() \\n-    {\\n-      // for now, this code path is only take for a web-based protocol handler\\n-      nsCOMPtr<nsIHandlerApp> handlerApp;\\n-      nsresult rv = \\n-        mHandlerInfo->GetPreferredApplicationHandler(getter_AddRefs(handlerApp));\\n-      if (NS_FAILED(rv)) {\\n-        mOriginalChannel->Finish(rv);\\n-        return NS_OK;\\n-      }\\n-\\n-      nsCOMPtr<nsIWebHandlerApp> webHandlerApp = do_QueryInterface(handlerApp,\\n-                                                                   &rv);\\n-      if (NS_FAILED(rv)) {\\n-        mOriginalChannel->Finish(rv);\\n-        return NS_OK; \\n-      }\\n-\\n-      nsCAutoString uriTemplate;\\n-      rv = webHandlerApp->GetUriTemplate(uriTemplate);\\n-      if (NS_FAILED(rv)) {\\n-        mOriginalChannel->Finish(rv);\\n-        return NS_OK; \\n-      }\\n-            \\n-      // get the URI spec so we can escape it for insertion into the template \\n-      nsCAutoString uriSpecToHandle;\\n-      rv = mURI->GetSpec(uriSpecToHandle);\\n-      if (NS_FAILED(rv)) {\\n-        mOriginalChannel->Finish(rv);\\n-        return NS_OK; \\n-      }\\n-\\n-      // XXX need to strip passwd & username from URI to handle, as per the\\n-      // WhatWG HTML5 draft.  nsSimpleURL, which is what we're going to get,\\n-      // can't do this directly.  Ideally, we'd fix nsStandardURL to make it\\n-      // possible to turn off all of its quirks handling, and use that...\\n-\\n-      // XXX this doesn't exactly match how the HTML5 draft is requesting us to\\n-      // escape; at the very least, it should be escaping @ signs, and there\\n-      // may well be more issues.  However, this code will probably be thrown\\n-      // out when we do the front-end work, as we'll be using a refactored \\n-      // nsIWebContentConverterInfo to do this work for us\\n-      nsCAutoString escapedUriSpecToHandle;\\n-      NS_EscapeURL(uriSpecToHandle, esc_Minimal | esc_Forced | esc_Colon,\\n-                   escapedUriSpecToHandle);\\n-\\n-      // Note that this replace all occurrences of %s with the URL to be\\n-      // handled.  The HTML5 draft doesn't prohibit %s from occurring more than\\n-      // once, and if it does, I can't think of any problems that could\\n-      // cause, (though I don't know why anyone would need or want to do it). \\n-      uriTemplate.ReplaceSubstring(NS_LITERAL_CSTRING(\\\"%s\\\"),\\n-                                   escapedUriSpecToHandle);\\n-\\n-      // convert spec to URI; no original charset needed since there's no way\\n-      // to communicate that information to any handler\\n-      nsCOMPtr<nsIURI> uriToSend;\\n-      rv = NS_NewURI(getter_AddRefs(uriToSend), uriTemplate);\\n-      if (NS_FAILED(rv)) {\\n-        mOriginalChannel->Finish(rv);\\n-        return NS_OK; \\n-      }\\n-\\n-      // create a channel\\n-      nsCOMPtr<nsIChannel> newChannel;\\n-      rv = NS_NewChannel(getter_AddRefs(newChannel), uriToSend, nsnull,\\n-                         mOriginalChannel->mLoadGroup,\\n-                         mOriginalChannel->mCallbacks,\\n-                         mOriginalChannel->mLoadFlags \\n-                         | nsIChannel::LOAD_REPLACE);\\n-      if (NS_FAILED(rv)) {\\n-        mOriginalChannel->Finish(rv);\\n-        return NS_OK; \\n-      }\\n-\\n-      nsCOMPtr<nsIChannelEventSink> eventSink;\\n-      NS_QueryNotificationCallbacks(mOriginalChannel->mCallbacks,\\n-                                    mOriginalChannel->mLoadGroup, eventSink);\\n-\\n-      if (eventSink) {\\n-        // XXX decide on and audit for correct session & global hist behavior \\n-        rv = eventSink->OnChannelRedirect(mOriginalChannel, newChannel, \\n-                                          nsIChannelEventSink::REDIRECT_TEMPORARY |\\n-                                          nsIChannelEventSink::REDIRECT_INTERNAL);\\n-        if (NS_FAILED(rv)) {\\n-          mOriginalChannel->Finish(rv);\\n-          return NS_OK;\\n-        }\\n-      }\\n-\\n-      rv = newChannel->AsyncOpen(mListener, mContext);\\n-      if (NS_FAILED(rv)) {\\n-        mOriginalChannel->Finish(rv);\\n-        return NS_OK; \\n-      }\\n-      \\n-      mOriginalChannel->Finish(NS_BINDING_REDIRECTED);\\n-      return NS_OK;\\n-    }\\n-\\n-  private:\\n-    nsCOMPtr<nsIURI> mURI;\\n-    nsCOMPtr<nsIHandlerInfo> mHandlerInfo;\\n-    nsCOMPtr<nsIStreamListener> mListener;\\n-    nsCOMPtr<nsISupports> mContext;\\n-    nsCOMPtr<nsExtProtocolChannel> mOriginalChannel;\\n-};\\n-\\n NS_IMETHODIMP nsExtProtocolChannel::AsyncOpen(nsIStreamListener *listener, nsISupports *ctxt)\\n {\\n   NS_ENSURE_ARG_POINTER(listener);\\n-  NS_ENSURE_TRUE(!mIsPending, NS_ERROR_IN_PROGRESS);\\n   NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);\\n \\n   mWasOpened = PR_TRUE;\\n-  mListener = listener;\\n-  mContext = ctxt;\\n-\\n-  if (!gExtProtSvc) {\\n-    return NS_ERROR_FAILURE;\\n-  }\\n \\n-  nsCAutoString urlScheme;  \\n-  nsresult rv = mUrl->GetScheme(urlScheme);\\n-  if (NS_FAILED(rv)) {\\n-    return rv;\\n-  }\\n-\\n-  // check whether the scheme is one that we have a web handler for\\n-  nsCOMPtr<nsIHandlerInfo> handlerInfo;\\n-  rv = gExtProtSvc->GetProtocolHandlerInfo(urlScheme, \\n-                                           getter_AddRefs(handlerInfo));\\n-  // TODO all this code should be moved to nsIHandlerInfo::LaunchWithURI\\n-  if (NS_SUCCEEDED(rv)) {\\n-    PRInt32 preferredAction;                                           \\n-    rv = handlerInfo->GetPreferredAction(&preferredAction);\\n-\\n-    if (preferredAction == nsIHandlerInfo::useHelperApp) {\\n-\\n-      nsCOMPtr<nsIHandlerApp> handler;\\n-      rv = handlerInfo->GetPreferredApplicationHandler(getter_AddRefs(handler));\\n-      NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-      // Now we check to see if this is a local handler or not\\n-      nsCOMPtr<nsILocalHandlerApp> localHandler =\\n-        do_QueryInterface(handler, &rv);\\n-      if (NS_SUCCEEDED(rv)) {\\n-        OpenURL();\\n-        return NS_ERROR_NO_CONTENT; // force caller to abort\\n-      }\\n-\\n-      // We must have a web handler\\n-      // redirecting to the web handler involves calling OnChannelRedirect\\n-      // (which is supposed to happen after AsyncOpen completes) or possibly\\n-      // opening a dialog, so we do it in an event\\n-      nsCOMPtr<nsIRunnable> event = new nsProtocolRedirect(mUrl, handlerInfo,\\n-                                                           listener, ctxt,\\n-                                                           this);\\n-\\n-      // We don't check if |event| was successfully created because\\n-      // |NS_DispatchToCurrentThread| will do that for us.\\n-      rv = NS_DispatchToCurrentThread(event);\\n-      if (NS_SUCCEEDED(rv)) {\\n-        mIsPending = PR_TRUE;\\n-\\n-        // add ourselves to the load group, since this isn't going to finish\\n-        // immediately\\n-        if (mLoadGroup)\\n-          (void)mLoadGroup->AddRequest(this, nsnull);\\n-\\n-        return rv;\\n-      }\\n-    }\\n-  }\\n-  \\n-  // no protocol info found, just fall back on whatever the OS has to offer\\n-  OpenURL();\\n-  return NS_ERROR_NO_CONTENT; // force caller to abort.\\n-}\\n-\\n-/**\\n- * Finish out what was started in AsyncOpen.  This can be called in either the\\n- * success or the failure case.  \\n- *\\n- * @param aStatus  used to set the channel's status, and, if this set to \\n- *                 anything other than NS_BINDING_REDIRECTED, OnStartRequest\\n- *                 and OnStopRequest will be called, since Necko guarantees\\n- *                 this will happen unless the redirect took place.\\n- */\\n-void nsExtProtocolChannel::Finish(nsresult aStatus)\\n-{\\n-  mStatus = aStatus;\\n-\\n-  if (aStatus != NS_BINDING_REDIRECTED && mListener) {\\n-    (void)mListener->OnStartRequest(this, mContext);\\n-    (void)mListener->OnStopRequest(this, mContext, aStatus);\\n-  }\\n-  \\n-  mIsPending = PR_FALSE;\\n-  \\n-  if (mLoadGroup) {\\n-    (void)mLoadGroup->RemoveRequest(this, nsnull, aStatus);\\n-  }\\n-  return;\\n+  return OpenURL();\\n }\\n \\n NS_IMETHODIMP nsExtProtocolChannel::GetLoadFlags(nsLoadFlags *aLoadFlags)\\n@@ -485,7 +283,7 @@ NS_IMETHODIMP nsExtProtocolChannel::GetName(nsACString &result)\\n \\n NS_IMETHODIMP nsExtProtocolChannel::IsPending(PRBool *result)\\n {\\n-  *result = mIsPending;\\n+  *result = PR_FALSE;\\n   return NS_OK; \\n }\\n \\ndiff --git a/uriloader/exthandler/nsIExternalProtocolService.idl b/uriloader/exthandler/nsIExternalProtocolService.idl\\nindex f7e3f5d..2d20708 100644\\n--- a/uriloader/exthandler/nsIExternalProtocolService.idl\\n+++ b/uriloader/exthandler/nsIExternalProtocolService.idl\\n@@ -23,6 +23,7 @@\\n  * Contributor(s):\\n  *   Scott MacGregor <mscott@netscape.com>\\n  *   Myk Melez <myk@mozilla.org>\\n+ *   Dan Mosedale <dmose@mozilla.org>\\n  *\\n  * Alternatively, the contents of this file may be used under the terms of\\n  * either of the GNU General Public License Version 2 or later (the \\\"GPL\\\"),\\n@@ -105,8 +106,20 @@ interface nsIExternalProtocolService : nsISupports\\n    * Used to load a URI via an external application. Might prompt the user for\\n    * permission to load the external application.\\n    *\\n-   * @param aURI           The URI to load\\n-   * @param aWindowContext The parent window to open the dialog with.\\n+   * @param aURI\\n+   *        The URI to load\\n+   *\\n+   * @param aWindowContext \\n+   *        The window to parent the dialog against, and, if a web handler\\n+   *        is chosen, it is loaded in this window as well.  This parameter\\n+   *        may be ultimately passed nsIURILoader.openURI in the case of a\\n+   *        web handler, and aWindowContext is null or not present, web\\n+   *        handlers will fail.  We need to do better than that; bug 394483\\n+   *        filed in order to track.\\n+   * \\n+   * @note  Embedders that do not expose the http protocol should not currently\\n+   *        use web-based protocol handlers, as handoff won't work correctly\\n+   *        (bug 394479).  \\n    */\\n   void loadURI(in nsIURI aURI,\\n                [optional] in nsIInterfaceRequestor aWindowContext);\\ndiff --git a/uriloader/exthandler/nsMIMEInfoImpl.cpp b/uriloader/exthandler/nsMIMEInfoImpl.cpp\\nindex 9e61bfa8..63f650e 100644\\n--- a/uriloader/exthandler/nsMIMEInfoImpl.cpp\\n+++ b/uriloader/exthandler/nsMIMEInfoImpl.cpp\\n@@ -43,6 +43,10 @@\\n #include \\\"nsIProcess.h\\\"\\n #include \\\"nsILocalFile.h\\\"\\n #include \\\"nsIFileURL.h\\\"\\n+#include \\\"nsEscape.h\\\"\\n+#include \\\"nsNetUtil.h\\\"\\n+#include \\\"nsIURILoader.h\\\"\\n+#include \\\"nsCURILoader.h\\\"\\n \\n // nsISupports methods\\n NS_IMPL_THREADSAFE_ADDREF(nsMIMEInfoBase)\\n@@ -380,7 +384,8 @@ nsMIMEInfoBase::LaunchWithFile(nsIFile* aFile)\\n }\\n \\n NS_IMETHODIMP\\n-nsMIMEInfoBase::LaunchWithURI(nsIURI* aURI)\\n+nsMIMEInfoBase::LaunchWithURI(nsIURI* aURI,\\n+                              nsIInterfaceRequestor* aWindowContext)\\n {\\n   nsresult rv;\\n \\n@@ -402,7 +407,7 @@ nsMIMEInfoBase::LaunchWithURI(nsIURI* aURI)\\n     nsCOMPtr<nsIWebHandlerApp> webHandler = \\n       do_QueryInterface(mPreferredApplication, &rv);\\n     if (NS_SUCCEEDED(rv)) {\\n-      return LaunchWithWebHandler(webHandler, aURI);         \\n+      return LaunchWithWebHandler(webHandler, aURI, aWindowContext);         \\n     }\\n \\n     // ok, we must have a local handler app\\n@@ -456,10 +461,66 @@ nsMIMEInfoBase::LaunchWithIProcess(nsIFile* aApp, const nsCString& aArg)\\n \\n /* static */\\n nsresult\\n-nsMIMEInfoBase::LaunchWithWebHandler(nsIWebHandlerApp *aApp, nsIURI *aURI) \\n+nsMIMEInfoBase::LaunchWithWebHandler(nsIWebHandlerApp *aApp, nsIURI *aURI,\\n+                                     nsIInterfaceRequestor *aWindowContext) \\n {\\n-  // we'll be implementing this Real Soon Now!\\n-  return NS_ERROR_NOT_IMPLEMENTED;\\n+  \\n+  nsCAutoString uriTemplate;\\n+  nsresult rv = aApp->GetUriTemplate(uriTemplate);\\n+  if (NS_FAILED(rv)) {\\n+    return NS_ERROR_INVALID_ARG;\\n+  }\\n+\\n+  // get the URI spec so we can escape it for insertion into the template \\n+  nsCAutoString uriSpecToHandle;\\n+  rv = aURI->GetSpec(uriSpecToHandle);\\n+  if (NS_FAILED(rv)) {\\n+    return NS_ERROR_INVALID_ARG;\\n+  }\\n+\\n+  // XXX need to strip passwd & username from URI to handle, as per the\\n+  // WhatWG HTML5 draft.  nsSimpleURL, which is what we're going to get,\\n+  // can't do this directly.  Ideally, we'd fix nsStandardURL to make it\\n+  // possible to turn off all of its quirks handling, and use that...\\n+\\n+  // XXX this doesn't exactly match how the HTML5 draft is requesting us to\\n+  // escape; at the very least, it should be escaping @ signs, and there\\n+  // may well be more issues (bug 382019).\\n+  nsCAutoString escapedUriSpecToHandle;\\n+  NS_EscapeURL(uriSpecToHandle, esc_Minimal | esc_Forced | esc_Colon,\\n+               escapedUriSpecToHandle);\\n+\\n+  // XXX note that this replace all occurrences of %s with the URL to be\\n+  // handled, instead of just the first, as specified by the current draft\\n+  // of the spec.  Bug 394476 filed to track this.\\n+  uriTemplate.ReplaceSubstring(NS_LITERAL_CSTRING(\\\"%s\\\"),\\n+                               escapedUriSpecToHandle);\\n+\\n+  // convert spec to URI; no original charset needed since there's no way\\n+  // to communicate that information to any handler\\n+  nsCOMPtr<nsIURI> uriToSend;\\n+  rv = NS_NewURI(getter_AddRefs(uriToSend), uriTemplate);\\n+  if (NS_FAILED(rv))\\n+    return rv;\\n+\\n+  // create a channel\\n+  nsCOMPtr<nsIChannel> newChannel;\\n+  rv = NS_NewChannel(getter_AddRefs(newChannel), uriToSend, nsnull, nsnull,\\n+                     nsnull, nsIChannel::LOAD_DOCUMENT_URI);\\n+  if (NS_FAILED(rv))\\n+    return rv;\\n+\\n+  // load the URI\\n+  nsCOMPtr<nsIURILoader> uriLoader = do_GetService(NS_URI_LOADER_CONTRACTID, \\n+                                                   &rv);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  // XXX ideally, aIsContentPreferred (the second param) should really be\\n+  // passed in from above.  Practically, PR_TRUE is probably a reasonable\\n+  // default since browsers don't care much, and link click is likely to be\\n+  // the more interesting case for non-browser apps.  See \\n+  // <https://bugzilla.mozilla.org/show_bug.cgi?id=392957#c9> for details.\\n+  return uriLoader->OpenURI(newChannel, PR_TRUE, aWindowContext);\\n }\\n \\n // nsMIMEInfoImpl implementation\\ndiff --git a/uriloader/exthandler/nsMIMEInfoImpl.h b/uriloader/exthandler/nsMIMEInfoImpl.h\\nindex a7f257d..ba32249 100644\\n--- a/uriloader/exthandler/nsMIMEInfoImpl.h\\n+++ b/uriloader/exthandler/nsMIMEInfoImpl.h\\n@@ -89,7 +89,8 @@ class nsMIMEInfoBase : public nsIMIMEInfo {\\n     NS_IMETHOD GetPossibleApplicationHandlers(nsIMutableArray * *aPossibleAppHandlers);\\n     NS_IMETHOD GetDefaultDescription(nsAString & aDefaultDescription);\\n     NS_IMETHOD LaunchWithFile(nsIFile *aFile);\\n-    NS_IMETHOD LaunchWithURI(nsIURI *aURI);\\n+    NS_IMETHOD LaunchWithURI(nsIURI *aURI,\\n+                             nsIInterfaceRequestor *aWindowContext);\\n     NS_IMETHOD GetPreferredAction(nsHandlerInfoAction *aPreferredAction);\\n     NS_IMETHOD SetPreferredAction(nsHandlerInfoAction aPreferredAction);\\n     NS_IMETHOD GetAlwaysAskBeforeHandling(PRBool *aAlwaysAskBeforeHandling);\\n@@ -158,9 +159,19 @@ class nsMIMEInfoBase : public nsIMIMEInfo {\\n      * Used to launch a web-based handler with this URI.\\n      * \\n      * @param aURI  The URI to launch with.\\n+     * \\n+     * @param aWindowContext \\n+     *        The window to parent the dialog against, and, if a web handler\\n+     *        is chosen, it is loaded in this window as well.  This parameter\\n+     *        may be ultimately passed nsIURILoader.openURI in the case of a\\n+     *        web handler, and aWindowContext is null or not present, web\\n+     *        handlers will fail.  We need to do better than that; bug 394483\\n+     *        filed in order to track.\\n+     * \\n      */\\n-    static NS_HIDDEN_(nsresult) LaunchWithWebHandler(nsIWebHandlerApp *aApp, \\n-                                                     nsIURI *aURI);\\n+    static NS_HIDDEN_(nsresult) \\n+        LaunchWithWebHandler(nsIWebHandlerApp *aApp, nsIURI *aURI,\\n+                             nsIInterfaceRequestor *aWindowContext);\\n \\n     /**\\n      * Given a file: nsIURI, return the associated nsILocalFile\\ndiff --git a/uriloader/exthandler/os2/nsMIMEInfoOS2.cpp b/uriloader/exthandler/os2/nsMIMEInfoOS2.cpp\\nindex 1440eb0..e5e9521 100755\\n--- a/uriloader/exthandler/os2/nsMIMEInfoOS2.cpp\\n+++ b/uriloader/exthandler/os2/nsMIMEInfoOS2.cpp\\n@@ -59,7 +59,8 @@ nsMIMEInfoOS2::~nsMIMEInfoOS2()\\n {\\n }\\n \\n-NS_IMETHODIMP nsMIMEInfoOS2::LaunchWithURI(nsIURI* aURI)\\n+NS_IMETHODIMP nsMIMEInfoOS2::LaunchWithURI(nsIURI* aURI,\\n+                                           nsIInterfaceRequestor* aWindowContext)\\n {\\n   nsresult rv = NS_OK;\\n \\ndiff --git a/uriloader/exthandler/os2/nsMIMEInfoOS2.h b/uriloader/exthandler/os2/nsMIMEInfoOS2.h\\nindex 15b76c3..c7f500e 100755\\n--- a/uriloader/exthandler/os2/nsMIMEInfoOS2.h\\n+++ b/uriloader/exthandler/os2/nsMIMEInfoOS2.h\\n@@ -64,7 +64,8 @@ class nsMIMEInfoOS2 : public nsMIMEInfoImpl\\n       nsMIMEInfoImpl(aType, aClass) {}\\n     virtual ~nsMIMEInfoOS2();\\n \\n-    NS_IMETHOD LaunchWithURI(nsIURI* aURI);\\n+    NS_IMETHOD LaunchWithURI(nsIURI* aURI,\\n+                             nsIInterfaceRequestor* aWindowContext);\\n   protected:\\n     virtual NS_HIDDEN_(nsresult) LoadUriInternal(nsIURI *aURI);\\n #ifdef DEBUG\\n\""}