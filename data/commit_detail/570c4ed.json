{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas570c4ed\""},"diff":"\"570c4ed Bug 391951 don't strip escaped spaces for non-base64 data URIs r+sr=bz\\ndiff --git a/netwerk/protocol/data/src/nsDataChannel.cpp b/netwerk/protocol/data/src/nsDataChannel.cpp\\nindex b7e3e1a..106e51e 100644\\n--- a/netwerk/protocol/data/src/nsDataChannel.cpp\\n+++ b/netwerk/protocol/data/src/nsDataChannel.cpp\\n@@ -38,6 +38,7 @@\\n // data implementation\\n \\n #include \\\"nsDataChannel.h\\\"\\n+#include \\\"nsDataHandler.h\\\"\\n #include \\\"nsNetUtil.h\\\"\\n #include \\\"nsIPipe.h\\\"\\n #include \\\"nsIInputStream.h\\\"\\n@@ -55,71 +56,22 @@ nsDataChannel::OpenContentStream(PRBool async, nsIInputStream **result)\\n     NS_ENSURE_TRUE(URI(), NS_ERROR_NOT_INITIALIZED);\\n \\n     nsresult rv;\\n-    PRBool lBase64 = PR_FALSE;\\n \\n     nsCAutoString spec;\\n     rv = URI()->GetAsciiSpec(spec);\\n     if (NS_FAILED(rv)) return rv;\\n \\n-    // move past \\\"data:\\\"\\n-    char *buffer = (char *) strstr(spec.BeginWriting(), \\\"data:\\\");\\n-    if (!buffer) {\\n-        // malformed uri\\n-        return NS_ERROR_MALFORMED_URI;\\n-    }\\n-    buffer += 5;\\n-\\n-    // First, find the start of the data\\n-    char *comma = strchr(buffer, ',');\\n-    if (!comma)\\n-        return NS_ERROR_MALFORMED_URI;\\n-\\n-    *comma = '\\\\0';\\n-\\n-    // determine if the data is base64 encoded.\\n-    char *base64 = strstr(buffer, \\\";base64\\\");\\n-    if (base64) {\\n-        lBase64 = PR_TRUE;\\n-        *base64 = '\\\\0';\\n-    }\\n-\\n-    nsCString contentType, contentCharset;\\n-\\n-    if (comma == buffer) {\\n-        // nothing but data\\n-        contentType.AssignLiteral(\\\"text/plain\\\");\\n-        contentCharset.AssignLiteral(\\\"US-ASCII\\\");\\n-    } else {\\n-        // everything else is content type\\n-        char *semiColon = (char *) strchr(buffer, ';');\\n-        if (semiColon)\\n-            *semiColon = '\\\\0';\\n-        \\n-        if (semiColon == buffer || base64 == buffer) {\\n-            // there is no content type, but there are other parameters\\n-            contentType.AssignLiteral(\\\"text/plain\\\");\\n-        } else {\\n-            contentType = buffer;\\n-            ToLowerCase(contentType);\\n-        }\\n-\\n-        if (semiColon) {\\n-            char *charset = PL_strcasestr(semiColon + 1, \\\"charset=\\\");\\n-            if (charset)\\n-                contentCharset = charset + sizeof(\\\"charset=\\\") - 1;\\n-\\n-            *semiColon = ';';\\n-        }\\n-    }\\n-    contentType.StripWhitespace();\\n-    contentCharset.StripWhitespace();\\n+    nsCString contentType, contentCharset, dataBuffer;\\n+    PRBool lBase64;\\n+    rv = nsDataHandler::ParseURI(spec, contentType, contentCharset,\\n+                                 lBase64, dataBuffer);\\n \\n-    nsCAutoString dataBuffer(comma + 1);\\n     NS_UnescapeURL(dataBuffer);\\n \\n-    if (lBase64 || ((strncmp(contentType.get(),\\\"text/\\\",5) != 0) &&\\n-                     contentType.Find(\\\"xml\\\") == kNotFound)) {\\n-        // it's ascii encoded binary, don't let any spaces in\\n+    if (lBase64) {\\n+        // Don't allow spaces in base64-encoded content. This is only\\n+        // relevant for escaped spaces; other spaces are stripped in\\n+        // NewURI.\\n         dataBuffer.StripWhitespace();\\n     }\\n     \\n@@ -136,7 +88,6 @@ nsDataChannel::OpenContentStream(PRBool async, nsIInputStream **result)\\n \\n     PRUint32 contentLen;\\n     if (lBase64) {\\n-        *base64 = ';';\\n         const PRUint32 dataLen = dataBuffer.Length();\\n         PRInt32 resultLen = 0;\\n         if (dataLen >= 1 && dataBuffer[dataLen-1] == '=') {\\n@@ -166,8 +117,6 @@ nsDataChannel::OpenContentStream(PRBool async, nsIInputStream **result)\\n     if (NS_FAILED(rv))\\n         return rv;\\n \\n-    *comma = ',';\\n-\\n     SetContentType(contentType);\\n     SetContentCharset(contentCharset);\\n     SetContentLength64(contentLen);\\ndiff --git a/netwerk/protocol/data/src/nsDataHandler.cpp b/netwerk/protocol/data/src/nsDataHandler.cpp\\nindex 8c53b99..15c7b68 100644\\n--- a/netwerk/protocol/data/src/nsDataHandler.cpp\\n+++ b/netwerk/protocol/data/src/nsDataHandler.cpp\\n@@ -46,6 +46,7 @@\\n #include \\\"nsIInterfaceRequestorUtils.h\\\"\\n #include \\\"nsIProgressEventSink.h\\\"\\n #include \\\"nsNetCID.h\\\"\\n+#include \\\"nsNetError.h\\\"\\n \\n static NS_DEFINE_CID(kSimpleURICID, NS_SIMPLEURI_CID);\\n \\n@@ -101,11 +102,27 @@ nsDataHandler::NewURI(const nsACString &aSpec,\\n                       nsIURI **result) {\\n     nsresult rv;\\n \\n+    nsCString spec(aSpec);\\n+    nsCAutoString contentType, contentCharset, dataBuffer;\\n+    PRBool base64;\\n+    rv = ParseURI(spec, contentType, contentCharset, base64, dataBuffer);\\n+    if (NS_FAILED(rv))\\n+        return rv;\\n+\\n+    // Strip whitespace unless this is text, where whitespace is important\\n+    // Don't strip escaped whitespace though (bug 391951)\\n+    if (base64 || (strncmp(contentType.get(),\\\"text/\\\",5) != 0 &&\\n+                   contentType.Find(\\\"xml\\\") == kNotFound)) {\\n+        // it's ascii encoded binary, don't let any spaces in\\n+        spec.StripWhitespace();\\n+    }\\n+ \\n+\\n     nsIURI* url;\\n     rv = CallCreateInstance(kSimpleURICID, &url);\\n     if (NS_FAILED(rv)) return rv;\\n \\n-    rv = url->SetSpec(aSpec);\\n+    rv = url->SetSpec(spec);\\n     if (NS_FAILED(rv)) {\\n         NS_RELEASE(url);\\n         return rv;\\n@@ -116,8 +133,7 @@ nsDataHandler::NewURI(const nsACString &aSpec,\\n }\\n \\n NS_IMETHODIMP\\n-nsDataHandler::NewChannel(nsIURI* uri, nsIChannel* *result)\\n-{\\n+nsDataHandler::NewChannel(nsIURI* uri, nsIChannel* *result) {\\n     NS_ENSURE_ARG_POINTER(uri);\\n     nsDataChannel* channel = new nsDataChannel(uri);\\n     if (!channel)\\n@@ -135,9 +151,77 @@ nsDataHandler::NewChannel(nsIURI* uri, nsIChannel* *result)\\n }\\n \\n NS_IMETHODIMP \\n-nsDataHandler::AllowPort(PRInt32 port, const char *scheme, PRBool *_retval)\\n-{\\n+nsDataHandler::AllowPort(PRInt32 port, const char *scheme, PRBool *_retval) {\\n     // don't override anything.  \\n     *_retval = PR_FALSE;\\n     return NS_OK;\\n }\\n+\\n+nsresult\\n+nsDataHandler::ParseURI(nsCString& spec,\\n+                        nsCString& contentType,\\n+                        nsCString& contentCharset,\\n+                        PRBool&    isBase64,\\n+                        nsCString& dataBuffer) {\\n+    isBase64 = PR_FALSE;\\n+\\n+    // move past \\\"data:\\\"\\n+    char *buffer = (char *) strstr(spec.BeginWriting(), \\\"data:\\\");\\n+    if (!buffer) {\\n+        // malformed uri\\n+        return NS_ERROR_MALFORMED_URI;\\n+    }\\n+    buffer += 5;\\n+\\n+    // First, find the start of the data\\n+    char *comma = strchr(buffer, ',');\\n+    if (!comma)\\n+        return NS_ERROR_MALFORMED_URI;\\n+\\n+    *comma = '\\\\0';\\n+\\n+    // determine if the data is base64 encoded.\\n+    char *base64 = strstr(buffer, \\\";base64\\\");\\n+    if (base64) {\\n+        isBase64 = PR_TRUE;\\n+        *base64 = '\\\\0';\\n+    }\\n+\\n+    if (comma == buffer) {\\n+        // nothing but data\\n+        contentType.AssignLiteral(\\\"text/plain\\\");\\n+        contentCharset.AssignLiteral(\\\"US-ASCII\\\");\\n+    } else {\\n+        // everything else is content type\\n+        char *semiColon = (char *) strchr(buffer, ';');\\n+        if (semiColon)\\n+            *semiColon = '\\\\0';\\n+        \\n+        if (semiColon == buffer || base64 == buffer) {\\n+            // there is no content type, but there are other parameters\\n+            contentType.AssignLiteral(\\\"text/plain\\\");\\n+        } else {\\n+            contentType = buffer;\\n+            ToLowerCase(contentType);\\n+        }\\n+\\n+        if (semiColon) {\\n+            char *charset = PL_strcasestr(semiColon + 1, \\\"charset=\\\");\\n+            if (charset)\\n+                contentCharset = charset + sizeof(\\\"charset=\\\") - 1;\\n+\\n+            *semiColon = ';';\\n+        }\\n+    }\\n+\\n+    *comma = ',';\\n+    if (isBase64)\\n+        *base64 = ';';\\n+\\n+    contentType.StripWhitespace();\\n+    contentCharset.StripWhitespace();\\n+\\n+    dataBuffer.Assign(comma + 1);\\n+\\n+    return NS_OK;\\n+}\\ndiff --git a/netwerk/protocol/data/src/nsDataHandler.h b/netwerk/protocol/data/src/nsDataHandler.h\\nindex 0a0887b..28c14e9 100644\\n--- a/netwerk/protocol/data/src/nsDataHandler.h\\n+++ b/netwerk/protocol/data/src/nsDataHandler.h\\n@@ -55,6 +55,15 @@ public:\\n     // Define a Create method to be used with a factory:\\n     static NS_METHOD\\n     Create(nsISupports* aOuter, const nsIID& aIID, void* *aResult);\\n+\\n+    // Parse a data: URI and return the individual parts\\n+    // (the given spec will temporarily be modified but will be returned\\n+    //  to the original before returning)\\n+    static NS_HIDDEN_(nsresult) ParseURI(nsCString& spec,\\n+                                         nsCString& contentType,\\n+                                         nsCString& contentCharset,\\n+                                         PRBool&    isBase64,\\n+                                         nsCString& dataBuffer);\\n };\\n \\n #endif /* nsDataHandler_h___ */\\ndiff --git a/netwerk/test/unit/test_data_protocol.js b/netwerk/test/unit/test_data_protocol.js\\nindex 7481a08..cc19b43 100644\\n--- a/netwerk/test/unit/test_data_protocol.js\\n+++ b/netwerk/test/unit/test_data_protocol.js\\n@@ -4,10 +4,18 @@ const Cc = Components.classes;\\n const Ci = Components.interfaces;\\n const Cr = Components.results;\\n \\n+// The behaviour wrt spaces is:\\n+// - Textual content keeps all spaces\\n+// - Other content strips unescaped spaces\\n+// - Base64 content strips escaped and unescaped spaces\\n var urls = [\\n-  [\\\"data:,foo\\\", \\\"foo\\\"],\\n-  [\\\"data:text/plain,foo%00 bar\\\", \\\"foo\\\\x00 bar\\\"],\\n-  [\\\"data:text/plain;base64,Zm9 vI%20GJ%0Dhc%0Ag==\\\", \\\"foo bar\\\"]\\n+  [\\\"data:,foo\\\",                                     \\\"text/plain\\\",               \\\"foo\\\"],\\n+  [\\\"data:application/octet-stream,foo bar\\\",         \\\"application/octet-stream\\\", \\\"foobar\\\"],\\n+  [\\\"data:application/octet-stream,foo%20bar\\\",       \\\"application/octet-stream\\\", \\\"foo bar\\\"],\\n+  [\\\"data:application/xhtml+xml,foo bar\\\",            \\\"application/xhtml+xml\\\",    \\\"foo bar\\\"],\\n+  [\\\"data:application/xhtml+xml,foo%20bar\\\",          \\\"application/xhtml+xml\\\",    \\\"foo bar\\\"],\\n+  [\\\"data:text/plain,foo%00 bar\\\",                    \\\"text/plain\\\",               \\\"foo\\\\x00 bar\\\"],\\n+  [\\\"data:text/plain;base64,Zm9 vI%20GJ%0Dhc%0Ag==\\\", \\\"text/plain\\\",               \\\"foo bar\\\"]\\n ];\\n \\n function run_next_test() {\\n@@ -93,21 +101,21 @@ Listener.prototype = {\\n     if (this._contentLen != -1 && this._buffer.length != this._contentLen)\\n       do_throw(\\\"did not read nsIChannel.contentLength number of bytes!\\\");\\n \\n-    this._closure(this._buffer, this._closurectx);\\n+    this._closure(request, this._buffer, this._closurectx);\\n   }\\n };\\n \\n function run_test() {\\n   dump(\\\"*** run_test\\\\n\\\");\\n \\n-  function on_read_complete(data, idx) {\\n+  function on_read_complete(request, data, idx) {\\n     dump(\\\"*** run_test.on_read_complete\\\\n\\\");\\n \\n-    if (chan.contentType != \\\"text/plain\\\")\\n-      do_throw(\\\"Type mismatch! Is <\\\" + chan.contentType + \\\">, should be text/plain\\\")\\n+    if (request.nsIChannel.contentType != urls[idx][1])\\n+      do_throw(\\\"Type mismatch! Is <\\\" + chan.contentType + \\\">, should be <\\\" + urls[idx][1] + \\\">\\\");\\n \\n     /* read completed successfully.  now compare the data. */\\n-    if (data != urls[idx][1])\\n+    if (data != urls[idx][2])\\n       do_throw(\\\"Stream contents do not match with direct read!\\\");\\n     do_test_finished();\\n   }\\n\""}