{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas2402d7d\""},"diff":"\"2402d7d Bug 386844 - \\\"Crash when running Java Applets [@ XSync - JavaPluginInstance5::SetWindow]\\\" (move ws_info and xtbin code from ns4xPluginInstance to nsPluginNativeWindowGtk2) [p=karlt r+sr+a1.9=jst]\\ndiff --git a/modules/plugin/base/src/ns4xPluginInstance.cpp b/modules/plugin/base/src/ns4xPluginInstance.cpp\\nindex 313c5c0..f7022a3 100644\\n--- a/modules/plugin/base/src/ns4xPluginInstance.cpp\\n+++ b/modules/plugin/base/src/ns4xPluginInstance.cpp\\n@@ -59,12 +59,6 @@\\n #include \\\"nsILegacyPluginWrapperOS2.h\\\"\\n #endif\\n \\n-#ifdef MOZ_WIDGET_GTK2\\n-#include <gdk/gdk.h>\\n-#include <gdk/gdkx.h>\\n-#include \\\"gtk2xtbin.h\\\"\\n-#endif\\n-\\n ////////////////////////////////////////////////////////////////////////\\n // CID's && IID's\\n static NS_DEFINE_IID(kCPluginManagerCID, NS_PLUGINMANAGER_CID); // needed for NS_TRY_SAFE_CALL\\n@@ -820,11 +814,6 @@ ns4xPluginInstance::~ns4xPluginInstance(void)\\n {\\n   PLUGIN_LOG(PLUGIN_LOG_BASIC, (\\\"ns4xPluginInstance dtor: this=%p\\\\n\\\",this));\\n \\n-#if defined (MOZ_WIDGET_GTK2)\\n-  if (mXtBin)\\n-    gtk_widget_destroy(mXtBin);\\n-#endif\\n-\\n   // clean the stream list if any\\n   for(nsInstanceStream *is = mStreams; is != nsnull;) {\\n     nsInstanceStream * next = is->mNext;\\n@@ -847,9 +836,6 @@ NS_IMETHODIMP ns4xPluginInstance::Initialize(nsIPluginInstancePeer* peer)\\n {\\n   PLUGIN_LOG(PLUGIN_LOG_NORMAL, (\\\"ns4xPluginInstance::Initialize this=%p\\\\n\\\",this));\\n \\n-#if defined (MOZ_WIDGET_GTK2)\\n-  mXtBin = nsnull;\\n-#endif\\n   return InitializePlugin(peer);\\n }\\n \\n@@ -890,13 +876,6 @@ NS_IMETHODIMP ns4xPluginInstance::Stop(void)\\n     }\\n   }\\n \\n-#if defined (MOZ_WIDGET_GTK2)\\n-  if (mXtBin) {\\n-    gtk_widget_destroy(mXtBin);\\n-    mXtBin = 0;\\n-  }\\n-#endif\\n-\\n   if(!mStarted)\\n     return NS_OK;\\n \\n@@ -1117,109 +1096,12 @@ NS_IMETHODIMP ns4xPluginInstance::SetWindow(nsPluginWindow* window)\\n   \\n   NPError error;\\n \\n-  // It would be nice if this was all moved to\\n-  // nsPluginNativeWindowGtk2::CallSetWindow or nsWindow or somewhere else?\\n #if defined (MOZ_WIDGET_GTK2)\\n-  if (window->type == nsPluginWindowType_Window) {\\n-    PRBool isXembed = PR_FALSE;\\n-    // bug 108337, flash plugin on linux doesn't like window->width <= 0\\n-    if ((PRInt32) window->width <= 0 || (PRInt32) window->height <= 0)\\n-      return NS_OK;\\n-\\n-    // We need to test if this is an xembed window before doing checks\\n-    // below, as they might be used on the first pass or on later passes\\n-    // when we resize the plugin window.\\n-    GdkWindow *win = gdk_window_lookup((XID)window->window);\\n-    if (!win)\\n-      return NS_ERROR_FAILURE;\\n-\\n-    gpointer user_data = nsnull;\\n-    gdk_window_get_user_data(win, &user_data);\\n-    if (user_data && GTK_IS_WIDGET(user_data)) {\\n-      GtkWidget* widget = GTK_WIDGET(user_data);\\n-\\n-      if (GTK_IS_SOCKET(widget))\\n-        isXembed = PR_TRUE;\\n-    }\\n-\\n-    // Fill out the ws_info data.\\n-    // (ws_info should be non-null but check just in case.)\\n-    if (!mXtBin && window->ws_info) {\\n-\\n-      NPSetWindowCallbackStruct* ws =\\n-        static_cast<NPSetWindowCallbackStruct*>(window->ws_info);\\n-\\n-      if (!isXembed) {  \\n-#ifdef NS_DEBUG      \\n-        printf(\\\"About to create new xtbin of %i X %i from %p...\\\\n\\\",\\n-               window->width, window->height, (void*)win);\\n-#endif\\n-\\n-#if 0\\n-        // if we destroyed the plugin when we left the page, we could remove this\\n-        // code (i believe) the problem here is that the window gets destroyed when\\n-        // its parent, etc does by changing a page the plugin instance is being\\n-        // held on to, so when we return to the page, we have a mXtBin, but it is\\n-        // in a not-so-good state.\\n-        // --\\n-        // this is lame.  we shouldn't be destroying this everytime, but I can't find\\n-        // a good way to tell if we need to destroy/recreate the xtbin or not\\n-        // what if the plugin wants to change the window and not just resize it??\\n-        // (pav)\\n-\\n-        if (mXtBin) {\\n-          gtk_widget_destroy(mXtBin);\\n-          mXtBin = NULL;\\n-        }\\n-#endif\\n-\\n-\\n-        if (!mXtBin) {\\n-          mXtBin = gtk_xtbin_new(win, 0);\\n-          // Check to see if creating mXtBin failed for some reason.\\n-          // if it did, we can't go any further.\\n-          if (!mXtBin)\\n-            return NS_ERROR_FAILURE;\\n-        } \\n-\\n-        gtk_widget_set_usize(mXtBin, window->width, window->height);\\n-\\n-#ifdef NS_DEBUG\\n-        printf(\\\"About to show xtbin(%p)...\\\\n\\\", (void*)mXtBin); fflush(NULL);\\n-#endif\\n-        gtk_widget_show(mXtBin);\\n-#ifdef NS_DEBUG\\n-        printf(\\\"completed gtk_widget_show(%p)\\\\n\\\", (void*)mXtBin); fflush(NULL);\\n-#endif\\n-      }\\n-\\n-      // fill in window info structure \\n-      ws->type = 0; // OK, that was a guess!!\\n-#ifdef MOZ_X11\\n-      ws->depth = gdk_window_get_visual(win)->depth;\\n-      if (!isXembed)\\n-        ws->display = GTK_XTBIN(mXtBin)->xtdisplay;\\n-      else\\n-        ws->display = GDK_WINDOW_XDISPLAY(win);\\n-      ws->visual = GDK_VISUAL_XVISUAL(gdk_window_get_visual(win));\\n-      ws->colormap = GDK_COLORMAP_XCOLORMAP(gdk_window_get_colormap(win));\\n-\\n-      XFlush(ws->display);\\n-#endif\\n-    } // !mXtBin\\n-\\n-    if (!mXtBin && !isXembed)\\n-      return NS_ERROR_FAILURE;\\n-\\n-    if (!isXembed) {\\n-      // And now point the NPWindow structures window \\n-      // to the actual X window\\n-      window->window = (nsPluginPort *)GTK_XTBIN(mXtBin)->xtwindow;\\n-    \\n-      gtk_xtbin_resize(mXtBin, window->width, window->height);\\n-    }\\n+  if (window->type == nsPluginWindowType_Window &&\\n+      (window->width <= 0 || window->height <= 0)) {\\n+    // bug 108347, flash plugin on linux doesn't like window->width <= 0\\n+    return NS_OK;\\n   }\\n-  \\n #endif // MOZ_WIDGET\\n \\n   if (fCallbacks->setwindow) {\\ndiff --git a/modules/plugin/base/src/ns4xPluginInstance.h b/modules/plugin/base/src/ns4xPluginInstance.h\\nindex 595b313..d1a4181 100644\\n--- a/modules/plugin/base/src/ns4xPluginInstance.h\\n+++ b/modules/plugin/base/src/ns4xPluginInstance.h\\n@@ -63,10 +63,6 @@\\n #endif\\n #include \\\"prlink.h\\\"  // for PRLibrary\\n \\n-#if defined (MOZ_WIDGET_GTK2)\\n-#include <gtk/gtk.h>\\n-#endif\\n-\\n ////////////////////////////////////////////////////////////////////////\\n \\n class ns4xPluginStreamListener;\\n@@ -174,14 +170,6 @@ protected:\\n      */\\n     NPPluginFuncs* fCallbacks;\\n \\n-#if defined (MOZ_WIDGET_GTK2)\\n-   /**\\n-    * Special GtkXtBin widget that encapsulates the Xt toolkit\\n-    * within a Gtk Application\\n-    */\\n-   GtkWidget *mXtBin;\\n-#endif\\n-\\n     /**\\n      * The 4.x-style structure used to communicate between the plugin\\n      * instance and the browser.\\ndiff --git a/modules/plugin/base/src/nsPluginNativeWindowGtk2.cpp b/modules/plugin/base/src/nsPluginNativeWindowGtk2.cpp\\nindex 42a99ba..f43c2a1 100644\\n--- a/modules/plugin/base/src/nsPluginNativeWindowGtk2.cpp\\n+++ b/modules/plugin/base/src/nsPluginNativeWindowGtk2.cpp\\n@@ -48,6 +48,7 @@\\n #include <gtk/gtk.h>\\n #include <gdk/gdkx.h>\\n #include <gdk/gdk.h>\\n+#include \\\"gtk2xtbin.h\\\"\\n #ifdef OJI\\n #include \\\"plstr.h\\\"\\n #include \\\"nsIPlugin.h\\\"\\n@@ -63,9 +64,14 @@ public:\\n \\n   virtual nsresult CallSetWindow(nsCOMPtr<nsIPluginInstance> &aPluginInstance);\\n private:\\n-  GtkWidget*  mGtkSocket;\\n-  NPSetWindowCallbackStruct m_ws_info;\\n+  NPSetWindowCallbackStruct mWsInfo;\\n+  /**\\n+   * Either a GtkSocket or a special GtkXtBin widget (derived from GtkSocket)\\n+   * that encapsulates the Xt toolkit within a Gtk Application.\\n+   */\\n+  GtkWidget* mSocketWidget;\\n   nsresult  CreateXEmbedWindow();\\n+  nsresult  CreateXtWindow();\\n   void      SetAllocation();\\n   PRBool    CanGetValueFromPlugin(nsCOMPtr<nsIPluginInstance> &aPluginInstance);\\n };\\n@@ -81,21 +87,20 @@ nsPluginNativeWindowGtk2::nsPluginNativeWindowGtk2() : nsPluginNativeWindow()\\n   width = 0; \\n   height = 0; \\n   memset(&clipRect, 0, sizeof(clipRect));\\n-  ws_info = &m_ws_info;\\n+  ws_info = &mWsInfo;\\n   type = nsPluginWindowType_Window;\\n-  mGtkSocket = 0;\\n-  m_ws_info.type = 0;\\n-  m_ws_info.display = nsnull;\\n-  m_ws_info.visual = nsnull;\\n-  m_ws_info.colormap = 0;\\n-  m_ws_info.depth = 0;\\n+  mSocketWidget = 0;\\n+  mWsInfo.type = 0;\\n+  mWsInfo.display = nsnull;\\n+  mWsInfo.visual = nsnull;\\n+  mWsInfo.colormap = 0;\\n+  mWsInfo.depth = 0;\\n }\\n \\n nsPluginNativeWindowGtk2::~nsPluginNativeWindowGtk2() \\n {\\n-  if(mGtkSocket) {\\n-    gtk_widget_destroy(mGtkSocket);\\n-    mGtkSocket = 0;\\n+  if(mSocketWidget) {\\n+    gtk_widget_destroy(mSocketWidget);\\n   }\\n }\\n \\n@@ -119,28 +124,42 @@ nsresult nsPluginNativeWindowGtk2::CallSetWindow(nsCOMPtr<nsIPluginInstance> &aP\\n   if(aPluginInstance) {\\n     if (type == nsPluginWindowType_Window) {\\n       nsresult rv;\\n-      PRBool val = PR_FALSE;\\n-      if(!mGtkSocket) {\\n-        if (CanGetValueFromPlugin(aPluginInstance))\\n+      if(!mSocketWidget) {\\n+        PRBool needXEmbed = PR_FALSE;\\n+        if (CanGetValueFromPlugin(aPluginInstance)) {\\n           rv = aPluginInstance->GetValue\\n-            ((nsPluginInstanceVariable)NPPVpluginNeedsXEmbed, &val);\\n-      }\\n+            ((nsPluginInstanceVariable)NPPVpluginNeedsXEmbed, &needXEmbed);\\n #ifdef DEBUG\\n-      printf(\\\"nsPluginNativeWindowGtk2: NPPVpluginNeedsXEmbed=%d\\\\n\\\", val);\\n+          printf(\\\"nsPluginNativeWindowGtk2: NPPVpluginNeedsXEmbed=%d\\\\n\\\", needXEmbed);\\n #endif\\n-      if(val) {\\n-        CreateXEmbedWindow();\\n+        }\\n+        if(needXEmbed) {\\n+          CreateXEmbedWindow();\\n+        }\\n+        else {\\n+          CreateXtWindow();\\n+        }\\n       }\\n \\n-      if(mGtkSocket) {\\n-        // Make sure to resize and re-place the window if required\\n+      if(!mSocketWidget)\\n+        return NS_ERROR_FAILURE;\\n+\\n+      // Make sure to resize and re-place the window if required.\\n+      // Need to reset \\\"window\\\" each time as nsObjectFrame::DidReflow sets it\\n+      // to the ancestor window.\\n+      if(GTK_IS_XTBIN(mSocketWidget)) {\\n+        gtk_xtbin_resize(mSocketWidget, width, height);\\n+        // Point the NPWindow structures window to the actual X window\\n+        window = (nsPluginPort *)GTK_XTBIN(mSocketWidget)->xtwindow;\\n+      }\\n+      else { // XEmbed\\n         SetAllocation();\\n-        window = (nsPluginPort *)gtk_socket_get_id(GTK_SOCKET(mGtkSocket));\\n+        window = (nsPluginPort *)gtk_socket_get_id(GTK_SOCKET(mSocketWidget));\\n       }\\n #ifdef DEBUG\\n       printf(\\\"nsPluginNativeWindowGtk2: call SetWindow with xid=%p\\\\n\\\", (void *)window);\\n #endif\\n-    }\\n+    } // nsPluginWindowType_Window\\n     aPluginInstance->SetWindow(this);\\n   }\\n   else if (mPluginInstance)\\n@@ -151,41 +170,50 @@ nsresult nsPluginNativeWindowGtk2::CallSetWindow(nsCOMPtr<nsIPluginInstance> &aP\\n }\\n \\n nsresult nsPluginNativeWindowGtk2::CreateXEmbedWindow() {\\n-  if(!mGtkSocket) {\\n-    GdkWindow *win = gdk_window_lookup((XID)window);\\n-    mGtkSocket = gtk_socket_new();\\n+  NS_ASSERTION(!mSocketWidget,\\\"Already created a socket widget!\\\");\\n \\n-    //attach the socket to the container widget\\n-    gtk_widget_set_parent_window(mGtkSocket, win);\\n+  GdkWindow *parent_win = gdk_window_lookup((XID)window);\\n+  mSocketWidget = gtk_socket_new();\\n \\n-    // Make sure to handle the plug_removed signal.  If we don't the\\n-    // socket will automatically be destroyed when the plug is\\n-    // removed, which means we're destroying it more than once.\\n-    // SYNTAX ERROR.\\n-    g_signal_connect(mGtkSocket, \\\"plug_removed\\\",\\n-                     G_CALLBACK(plug_removed_cb), NULL);\\n+  //attach the socket to the container widget\\n+  gtk_widget_set_parent_window(mSocketWidget, parent_win);\\n \\n-    gpointer user_data = NULL;\\n-    gdk_window_get_user_data(win, &user_data);\\n+  // Make sure to handle the plug_removed signal.  If we don't the\\n+  // socket will automatically be destroyed when the plug is\\n+  // removed, which means we're destroying it more than once.\\n+  // SYNTAX ERROR.\\n+  g_signal_connect(mSocketWidget, \\\"plug_removed\\\",\\n+                   G_CALLBACK(plug_removed_cb), NULL);\\n \\n-    GtkContainer *container = GTK_CONTAINER(user_data);\\n-    gtk_container_add(container, mGtkSocket);\\n-    gtk_widget_realize(mGtkSocket);\\n+  gpointer user_data = NULL;\\n+  gdk_window_get_user_data(parent_win, &user_data);\\n \\n-    // Resize before we show\\n-    SetAllocation();\\n+  GtkContainer *container = GTK_CONTAINER(user_data);\\n+  gtk_container_add(container, mSocketWidget);\\n+  gtk_widget_realize(mSocketWidget);\\n \\n-    gtk_widget_show(mGtkSocket);\\n+  // Resize before we show\\n+  SetAllocation();\\n \\n-    gdk_flush();\\n-    window = (nsPluginPort *)gtk_socket_get_id(GTK_SOCKET(mGtkSocket));\\n-  }\\n+  gtk_widget_show(mSocketWidget);\\n+\\n+  gdk_flush();\\n+  window = (nsPluginPort *)gtk_socket_get_id(GTK_SOCKET(mSocketWidget));\\n+\\n+  // Fill out the ws_info structure.\\n+  // (The windowless case is done in nsObjectFrame.cpp.)\\n+  GdkWindow *gdkWindow = gdk_window_lookup((XID)window);\\n+  mWsInfo.display = GDK_WINDOW_XDISPLAY(gdkWindow);\\n+  mWsInfo.colormap = GDK_COLORMAP_XCOLORMAP(gdk_drawable_get_colormap(gdkWindow));\\n+  GdkVisual* gdkVisual = gdk_drawable_get_visual(gdkWindow);\\n+  mWsInfo.visual = GDK_VISUAL_XVISUAL(gdkVisual);\\n+  mWsInfo.depth = gdkVisual->depth;\\n \\n   return NS_OK;\\n }\\n \\n void nsPluginNativeWindowGtk2::SetAllocation() {\\n-  if (!mGtkSocket)\\n+  if (!mSocketWidget)\\n     return;\\n \\n   GtkAllocation new_allocation;\\n@@ -193,7 +221,45 @@ void nsPluginNativeWindowGtk2::SetAllocation() {\\n   new_allocation.y = 0;\\n   new_allocation.width = width;\\n   new_allocation.height = height;\\n-  gtk_widget_size_allocate(mGtkSocket, &new_allocation);\\n+  gtk_widget_size_allocate(mSocketWidget, &new_allocation);\\n+}\\n+\\n+nsresult nsPluginNativeWindowGtk2::CreateXtWindow() {\\n+  NS_ASSERTION(!mSocketWidget,\\\"Already created a socket widget!\\\");\\n+\\n+#ifdef NS_DEBUG      \\n+  printf(\\\"About to create new xtbin of %i X %i from %p...\\\\n\\\",\\n+         width, height, (void*)window);\\n+#endif\\n+  GdkWindow *gdkWindow = gdk_window_lookup((XID)window);\\n+  mSocketWidget = gtk_xtbin_new(gdkWindow, 0);\\n+  // Check to see if creating the xtbin failed for some reason.\\n+  // if it did, we can't go any further.\\n+  if (!mSocketWidget)\\n+    return NS_ERROR_FAILURE;\\n+\\n+  gtk_widget_set_size_request(mSocketWidget, width, height);\\n+\\n+#ifdef NS_DEBUG\\n+  printf(\\\"About to show xtbin(%p)...\\\\n\\\", (void*)mSocketWidget); fflush(NULL);\\n+#endif\\n+  gtk_widget_show(mSocketWidget);\\n+#ifdef NS_DEBUG\\n+  printf(\\\"completed gtk_widget_show(%p)\\\\n\\\", (void*)mSocketWidget); fflush(NULL);\\n+#endif\\n+\\n+  // Fill out the ws_info structure.\\n+  GtkXtBin* xtbin = GTK_XTBIN(mSocketWidget);\\n+  // The xtbin has its own Display structure.\\n+  mWsInfo.display = xtbin->xtdisplay;\\n+  mWsInfo.colormap = xtbin->xtclient.xtcolormap;\\n+  mWsInfo.visual = xtbin->xtclient.xtvisual;\\n+  mWsInfo.depth = xtbin->xtclient.xtdepth;\\n+  // Leave mWsInfo.type = 0 - Who knows what this is meant to be?\\n+\\n+  XFlush(mWsInfo.display);\\n+\\n+  return NS_OK;\\n }\\n \\n PRBool nsPluginNativeWindowGtk2::CanGetValueFromPlugin(nsCOMPtr<nsIPluginInstance> &aPluginInstance)\\ndiff --git a/widget/src/gtkxtbin/gtk2xtbin.c b/widget/src/gtkxtbin/gtk2xtbin.c\\nindex 85d2dd5..2230129 100644\\n--- a/widget/src/gtkxtbin/gtk2xtbin.c\\n+++ b/widget/src/gtkxtbin/gtk2xtbin.c\\n@@ -413,11 +413,17 @@ gtk_xtbin_resize (GtkWidget *widget,\\n   printf(\\\"gtk_xtbin_resize %p %d %d\\\\n\\\", (void *)widget, width, height);\\n #endif\\n \\n+  xtbin->height = height;\\n+  xtbin->width  = width;\\n+\\n+  // Avoid BadValue errors in XtSetValues\\n+  if (height <= 0 || width <=0) {\\n+    height = 1;\\n+    width = 1;\\n+  }\\n   XtSetArg(args[0], XtNheight, height);\\n   XtSetArg(args[1], XtNwidth,  width);\\n   XtSetValues(xtbin->xtclient.top_widget, args, 2);\\n-  xtbin->height = height;\\n-  xtbin->width  = width;\\n \\n   /* we need to send a size allocate so the socket knows about the\\n      size changes */\\n\""}