{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas50fd4b8\""},"diff":"\"50fd4b8 Backing out bug 372769 due to leaks.\\ndiff --git a/content/xbl/src/Makefile.in b/content/xbl/src/Makefile.in\\nindex ae32022..3c4986d 100644\\n--- a/content/xbl/src/Makefile.in\\n+++ b/content/xbl/src/Makefile.in\\n@@ -111,7 +111,6 @@ LOCAL_INCLUDES\\t= \\\\\\n \\t\\t-I$(srcdir)/../../xul/document/src \\\\\\n \\t\\t-I$(srcdir)/../../events/src \\\\\\n \\t\\t-I$(srcdir)/../../../layout/style \\\\\\n-\\t\\t-I$(srcdir)/../../../dom/src/base \\\\\\n \\t\\t$(NULL)\\n \\n DEFINES += -D_IMPL_NS_LAYOUT\\ndiff --git a/content/xbl/src/nsXBLBinding.cpp b/content/xbl/src/nsXBLBinding.cpp\\nindex 00ff758..08b226b 100644\\n--- a/content/xbl/src/nsXBLBinding.cpp\\n+++ b/content/xbl/src/nsXBLBinding.cpp\\n@@ -102,127 +102,27 @@\\n #include \\\"prprf.h\\\"\\n #include \\\"nsNodeUtils.h\\\"\\n \\n-// Nasty hack.  Maybe we could move some of the classinfo utility methods\\n-// (e.g. WrapNative and ThrowJSException) over to nsContentUtils?\\n-#include \\\"nsDOMClassInfo.h\\\"\\n-#include \\\"nsJSUtils.h\\\"\\n-\\n // Helper classes\\n \\n /***********************************************************************/\\n //\\n // The JS class for XBLBinding\\n //\\n-JS_STATIC_DLL_CALLBACK(void)\\n+PR_STATIC_CALLBACK(void)\\n XBLFinalize(JSContext *cx, JSObject *obj)\\n {\\n-  nsXBLPrototypeBinding* protoBinding =\\n-    static_cast<nsXBLPrototypeBinding*>(::JS_GetPrivate(cx, obj));\\n-  protoBinding->XBLDocumentInfo()->Release();\\n-  \\n   nsXBLJSClass* c = static_cast<nsXBLJSClass*>(::JS_GetClass(cx, obj));\\n   c->Drop();\\n }\\n \\n-JS_STATIC_DLL_CALLBACK(JSBool)\\n-XBLResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,\\n-           JSObject **objp)\\n-{\\n-  // Note: if we get here, that means that the implementation for some binding\\n-  // was installed, which means that AllowScripts() tested true.  Hence no need\\n-  // to do checks like that here.\\n-  \\n-  // Default to not resolving things.\\n-  NS_ASSERTION(*objp, \\\"Must have starting object\\\");\\n-\\n-  JSObject* origObj = *objp;\\n-  *objp = NULL;\\n-\\n-  if (!JSVAL_IS_STRING(id)) {\\n-    return JS_TRUE;\\n-  }\\n-\\n-  nsDependentJSString fieldName(id);\\n-                     \\n-  nsXBLPrototypeBinding* protoBinding =\\n-    static_cast<nsXBLPrototypeBinding*>(::JS_GetPrivate(cx, obj));\\n-  NS_ASSERTION(protoBinding, \\\"Must have prototype binding!\\\");\\n-\\n-  nsXBLProtoImplField* field = protoBinding->FindField(fieldName);\\n-  if (!field) {\\n-    return JS_TRUE;\\n-  }\\n-\\n-  // We have this field.  Time to install it.  Get our node.\\n-  JSClass* nodeClass = ::JS_GetClass(cx, origObj);\\n-  if (!nodeClass) {\\n-    return JS_FALSE;\\n-  }\\n-  \\n-  if (~nodeClass->flags &\\n-      (JSCLASS_HAS_PRIVATE | JSCLASS_PRIVATE_IS_NSISUPPORTS)) {\\n-    // Looks like whatever |origObj| is it's not our nsIContent.  It might well\\n-    // be the proto our binding installed, however, so just baul out quietly.\\n-    // Do NOT throw an exception here.\\n-    // We could make this stricter by checking the class maybe, but whatever\\n-    return JS_TRUE;\\n-  }\\n-\\n-  nsCOMPtr<nsIXPConnectWrappedNative> xpcWrapper =\\n-    do_QueryInterface(static_cast<nsISupports*>(::JS_GetPrivate(cx, origObj)));\\n-  if (!xpcWrapper) {\\n-    nsDOMClassInfo::ThrowJSException(cx, NS_ERROR_UNEXPECTED);\\n-    return JS_FALSE;\\n-  }\\n-\\n-  nsCOMPtr<nsIContent> content = do_QueryWrappedNative(xpcWrapper);\\n-  if (!content) {\\n-    nsDOMClassInfo::ThrowJSException(cx, NS_ERROR_UNEXPECTED);\\n-    return JS_FALSE;\\n-  }\\n-\\n-  // This mirrors code in nsXBLProtoImpl::InstallImplementation\\n-  nsIDocument* doc = content->GetOwnerDoc();\\n-  if (!doc) {\\n-    return JS_TRUE;\\n-  }\\n-\\n-  nsIScriptGlobalObject* global = doc->GetScriptGlobalObject();\\n-  if (!global) {\\n-    return JS_TRUE;\\n-  }\\n-\\n-  nsCOMPtr<nsIScriptContext> context = global->GetContext();\\n-  if (!context) {\\n-    return JS_TRUE;\\n-  }\\n-\\n-\\n-  // Now we either resolve or fail\\n-  *objp = origObj;\\n-  nsresult rv = field->InstallField(context, origObj,\\n-                                    protoBinding->DocURI());\\n-  if (NS_FAILED(rv)) {\\n-    if (!::JS_IsExceptionPending(cx)) {\\n-      nsDOMClassInfo::ThrowJSException(cx, rv);\\n-    }\\n-\\n-    return JS_FALSE;\\n-  }\\n-\\n-  return JS_TRUE;\\n-}\\n-\\n nsXBLJSClass::nsXBLJSClass(const nsAFlatCString& aClassName)\\n {\\n   memset(this, 0, sizeof(nsXBLJSClass));\\n   next = prev = static_cast<JSCList*>(this);\\n   name = ToNewCString(aClassName);\\n-  flags =\\n-    JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE | JSCLASS_NEW_RESOLVE_GETS_START;\\n   addProperty = delProperty = setProperty = getProperty = ::JS_PropertyStub;\\n   enumerate = ::JS_EnumerateStub;\\n-  resolve = (JSResolveOp)XBLResolve;\\n+  resolve = ::JS_ResolveStub;\\n   convert = ::JS_ConvertStub;\\n   finalize = XBLFinalize;\\n }\\n@@ -1134,7 +1034,6 @@ nsXBLBinding::WalkRules(nsIStyleRuleProcessor::EnumFunc aFunc, void* aData)\\n nsresult\\n nsXBLBinding::DoInitJSClass(JSContext *cx, JSObject *global, JSObject *obj,\\n                             const nsAFlatCString& aClassName,\\n-                            nsXBLPrototypeBinding* aProtoBinding,\\n                             void **aClassObject)\\n {\\n   // First ensure our JS class is initialized.\\n@@ -1240,11 +1139,6 @@ nsXBLBinding::DoInitJSClass(JSContext *cx, JSObject *global, JSObject *obj,\\n       return NS_ERROR_OUT_OF_MEMORY;\\n     }\\n \\n-    ::JS_SetPrivate(cx, proto, aProtoBinding);\\n-\\n-    // Keep this proto binding alive while we're alive\\n-    aProtoBinding->XBLDocumentInfo()->AddRef();\\n-\\n     *aClassObject = (void*)proto;\\n   }\\n   else {\\n@@ -1261,6 +1155,63 @@ nsXBLBinding::DoInitJSClass(JSContext *cx, JSObject *global, JSObject *obj,\\n   return NS_OK;\\n }\\n \\n+\\n+nsresult\\n+nsXBLBinding::InitClass(const nsCString& aClassName,\\n+                        nsIScriptContext* aContext, \\n+                        nsIDocument* aDocument, void** aScriptObject,\\n+                        void** aClassObject)\\n+{\\n+  *aClassObject = nsnull;\\n+  *aScriptObject = nsnull;\\n+\\n+  nsresult rv;\\n+\\n+  // Obtain the bound element's current script object.\\n+  JSContext* cx = (JSContext*)aContext->GetNativeContext();\\n+\\n+  nsIDocument *ownerDoc = mBoundElement->GetOwnerDoc();\\n+  nsIScriptGlobalObject *sgo;\\n+\\n+  if (!ownerDoc || !(sgo = ownerDoc->GetScriptGlobalObject())) {\\n+    NS_ERROR(\\\"Can't find global object for bound content!\\\");\\n+\\n+    return NS_ERROR_UNEXPECTED;\\n+  }\\n+\\n+  nsCOMPtr<nsIXPConnectJSObjectHolder> wrapper;\\n+  rv = nsContentUtils::XPConnect()->WrapNative(cx, sgo->GetGlobalJSObject(),\\n+                                               mBoundElement,\\n+                                               NS_GET_IID(nsISupports),\\n+                                               getter_AddRefs(wrapper));\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  JSObject* object = nsnull;\\n+  rv = wrapper->GetJSObject(&object);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  *aScriptObject = object;\\n+\\n+  // First ensure our JS class is initialized.\\n+\\n+  rv = DoInitJSClass(cx, sgo->GetGlobalJSObject(), object, aClassName,\\n+                     aClassObject);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  // Root mBoundElement so that it doesn't lose it's binding\\n+  nsIDocument* doc = mBoundElement->GetOwnerDoc();\\n+\\n+  if (doc) {\\n+    nsCOMPtr<nsIXPConnectWrappedNative> native_wrapper =\\n+      do_QueryInterface(wrapper);\\n+    if (native_wrapper) {\\n+      doc->AddReference(mBoundElement, native_wrapper);\\n+    }\\n+  }\\n+\\n+  return NS_OK;\\n+}\\n+\\n PRBool\\n nsXBLBinding::AllowScripts()\\n {\\n@@ -1393,20 +1344,6 @@ nsXBLBinding::GetFirstStyleBinding()\\n   return mNextBinding ? mNextBinding->GetFirstStyleBinding() : nsnull;\\n }\\n \\n-PRBool\\n-nsXBLBinding::ResolveAllFields(JSContext *cx, JSObject *obj) const\\n-{\\n-  if (!mPrototypeBinding->ResolveAllFields(cx, obj)) {\\n-    return PR_FALSE;\\n-  }\\n-\\n-  if (mNextBinding) {\\n-    return mNextBinding->ResolveAllFields(cx, obj);\\n-  }\\n-\\n-  return PR_TRUE;\\n-}\\n-\\n void\\n nsXBLBinding::MarkForDeath()\\n {\\ndiff --git a/content/xbl/src/nsXBLBinding.h b/content/xbl/src/nsXBLBinding.h\\nindex 55b571f..744c418 100644\\n--- a/content/xbl/src/nsXBLBinding.h\\n+++ b/content/xbl/src/nsXBLBinding.h\\n@@ -132,10 +132,6 @@ public:\\n   nsXBLBinding* RootBinding();\\n   nsXBLBinding* GetFirstStyleBinding();\\n \\n-  // Resolve all the fields for this binding and all ancestor bindings on the\\n-  // object |obj|.  False return means a JS exception was set.\\n-  PRBool ResolveAllFields(JSContext *cx, JSObject *obj) const;\\n-\\n   // Get the list of insertion points for aParent. The nsInsertionPointList\\n   // is owned by the binding, you should not delete it.\\n   nsresult GetInsertionPointsFor(nsIContent* aParent,\\n@@ -159,11 +155,16 @@ public:\\n \\n   static nsresult DoInitJSClass(JSContext *cx, JSObject *global, JSObject *obj,\\n                                 const nsAFlatCString& aClassName,\\n-                                nsXBLPrototypeBinding* aProtoBinding,\\n                                 void **aClassObject);\\n \\n   PRBool AllowScripts();  // XXX make const\\n \\n+// Internal member functions\\n+protected:\\n+  nsresult InitClass(const nsCString& aClassName, nsIScriptContext* aContext,\\n+                     nsIDocument* aDocument, void** aScriptObject,\\n+                     void** aClassObject);\\n+\\n // MEMBER VARIABLES\\n protected:\\n   nsAutoRefCnt mRefCnt;\\ndiff --git a/content/xbl/src/nsXBLContentSink.cpp b/content/xbl/src/nsXBLContentSink.cpp\\nindex ea2ee5c..19bdf77 100644\\n--- a/content/xbl/src/nsXBLContentSink.cpp\\n+++ b/content/xbl/src/nsXBLContentSink.cpp\\n@@ -83,13 +83,12 @@ nsXBLContentSink::nsXBLContentSink()\\n   : mState(eXBL_InDocument),\\n     mSecondaryState(eXBL_None),\\n     mDocInfo(nsnull),\\n-    mIsChromeOrResource(PR_FALSE),\\n     mFoundFirstBinding(PR_FALSE),    \\n+    mIsChromeOrResource(PR_FALSE),\\n     mBinding(nsnull),\\n     mHandler(nsnull),\\n     mImplementation(nsnull),\\n     mImplMember(nsnull),\\n-    mImplField(nsnull),\\n     mProperty(nsnull),\\n     mMethod(nsnull),\\n     mField(nsnull)\\n@@ -264,18 +263,6 @@ nsXBLContentSink::AddMember(nsXBLProtoImplMember* aMember)\\n   mImplMember = aMember; // Adjust our pointer to point to the new last member in the chain.\\n }\\n \\n-void\\n-nsXBLContentSink::AddField(nsXBLProtoImplField* aField)\\n-{\\n-  // Add this field to our chain.\\n-  if (mImplField)\\n-    mImplField->SetNext(aField); // Already have a chain. Just append to the end.\\n-  else\\n-    mImplementation->SetFieldList(aField); // We're the first member in the chain.\\n-\\n-  mImplField = aField; // Adjust our pointer to point to the new last field in the chain.\\n-}\\n-\\n NS_IMETHODIMP \\n nsXBLContentSink::HandleStartElement(const PRUnichar *aName, \\n                                      const PRUnichar **aAtts, \\n@@ -716,8 +703,7 @@ nsXBLContentSink::ConstructImplementation(const PRUnichar **aAtts)\\n {\\n   mImplementation = nsnull;\\n   mImplMember = nsnull;\\n-  mImplField = nsnull;\\n-  \\n+      \\n   if (!mBinding)\\n     return;\\n \\n@@ -791,7 +777,7 @@ nsXBLContentSink::ConstructField(const PRUnichar **aAtts, PRUint32 aLineNumber)\\n     mField = new nsXBLProtoImplField(name, readonly);\\n     if (mField) {\\n       mField->SetLineNumber(aLineNumber);\\n-      AddField(mField);\\n+      AddMember(mField);\\n     }\\n   }\\n }\\ndiff --git a/content/xbl/src/nsXBLContentSink.h b/content/xbl/src/nsXBLContentSink.h\\nindex 2cb1368..0d59fff 100644\\n--- a/content/xbl/src/nsXBLContentSink.h\\n+++ b/content/xbl/src/nsXBLContentSink.h\\n@@ -157,7 +157,6 @@ protected:\\n   nsresult ReportUnexpectedElement(nsIAtom* aElementName, PRUint32 aLineNumber);\\n \\n   void AddMember(nsXBLProtoImplMember* aMember);\\n-  void AddField(nsXBLProtoImplField* aField);\\n   \\n   XBLPrimaryState mState;\\n   XBLSecondaryState mSecondaryState;\\n@@ -169,7 +168,6 @@ protected:\\n   nsXBLPrototypeHandler* mHandler; // current handler, owned by its PrototypeBinding\\n   nsXBLProtoImpl* mImplementation;\\n   nsXBLProtoImplMember* mImplMember;\\n-  nsXBLProtoImplField* mImplField;\\n   nsXBLProtoImplProperty* mProperty;\\n   nsXBLProtoImplMethod* mMethod;\\n   nsXBLProtoImplField* mField;\\ndiff --git a/content/xbl/src/nsXBLProtoImpl.cpp b/content/xbl/src/nsXBLProtoImpl.cpp\\nindex 61f4562..1a1feff 100644\\n--- a/content/xbl/src/nsXBLProtoImpl.cpp\\n+++ b/content/xbl/src/nsXBLProtoImpl.cpp\\n@@ -47,7 +47,6 @@\\n #include \\\"nsIServiceManager.h\\\"\\n #include \\\"nsIXBLDocumentInfo.h\\\"\\n #include \\\"nsIDOMNode.h\\\"\\n-#include \\\"nsXBLPrototypeBinding.h\\\"\\n \\n nsresult\\n nsXBLProtoImpl::InstallImplementation(nsXBLPrototypeBinding* aBinding, nsIContent* aBoundElement)\\n@@ -56,7 +55,7 @@ nsXBLProtoImpl::InstallImplementation(nsXBLPrototypeBinding* aBinding, nsIConten\\n   // this prototype implementation as a guide.  The prototype implementation is compiled lazily,\\n   // so for the first bound element that needs a concrete implementation, we also build the\\n   // prototype implementation.\\n-  if (!mMembers && !mFields)  // Constructor and destructor also live in mMembers\\n+  if (!mMembers)  // Constructor and destructor also live in mMembers\\n     return NS_OK; // Nothing to do, so let's not waste time.\\n \\n   // If the way this gets the script context changes, fix\\n@@ -215,37 +214,6 @@ nsXBLProtoImpl::Traverse(nsCycleCollectionTraversalCallback &cb) const\\n   }\\n }\\n \\n-nsXBLProtoImplField*\\n-nsXBLProtoImpl::FindField(const nsString& aFieldName) const\\n-{\\n-  for (nsXBLProtoImplField* f = mFields; f; f = f->GetNext()) {\\n-    if (aFieldName.Equals(f->GetName())) {\\n-      return f;\\n-    }\\n-  }\\n-\\n-  return nsnull;\\n-}\\n-\\n-PRBool\\n-nsXBLProtoImpl::ResolveAllFields(JSContext *cx, JSObject *obj) const\\n-{\\n-  for (nsXBLProtoImplField* f = mFields; f; f = f->GetNext()) {\\n-    // Using OBJ_LOOKUP_PROPERTY is a pain, since what we have is a\\n-    // PRUnichar* for the property name.  Let's just use the public API and\\n-    // all.\\n-    nsDependentString name(f->GetName());\\n-    jsval dummy;\\n-    if (!::JS_LookupUCProperty(cx, obj,\\n-                               reinterpret_cast<const jschar*>(name.get()),\\n-                               name.Length(), &dummy)) {\\n-      return PR_FALSE;\\n-    }\\n-  }\\n-\\n-  return PR_TRUE;\\n-}\\n-\\n void\\n nsXBLProtoImpl::DestroyMembers(nsXBLProtoImplMember* aBrokenMember)\\n {\\ndiff --git a/content/xbl/src/nsXBLProtoImpl.h b/content/xbl/src/nsXBLProtoImpl.h\\nindex 15609f5..54f36b1 100644\\n--- a/content/xbl/src/nsXBLProtoImpl.h\\n+++ b/content/xbl/src/nsXBLProtoImpl.h\\n@@ -42,11 +42,9 @@\\n #include \\\"nsMemory.h\\\"\\n #include \\\"nsXBLPrototypeHandler.h\\\"\\n #include \\\"nsXBLProtoImplMember.h\\\"\\n-#include \\\"nsXBLProtoImplField.h\\\"\\n+#include \\\"nsXBLPrototypeBinding.h\\\"\\n \\n class nsIXPConnectJSObjectHolder;\\n-class nsXBLPrototypeBinding;\\n-class nsXBLProtoImplAnonymousMethod;\\n \\n class nsXBLProtoImpl\\n {\\n@@ -54,7 +52,6 @@ public:\\n   nsXBLProtoImpl() \\n     : mClassObject(nsnull),\\n       mMembers(nsnull),\\n-      mFields(nsnull),\\n       mConstructor(nsnull),\\n       mDestructor(nsnull)\\n   { \\n@@ -67,8 +64,7 @@ public:\\n     // clean them up automatically.\\n     for (nsXBLProtoImplMember* curr = mMembers; curr; curr=curr->GetNext())\\n       curr->Destroy(mClassObject != nsnull);\\n-    delete mMembers;\\n-    delete mFields;\\n+    delete mMembers; \\n   }\\n   \\n   nsresult InstallImplementation(nsXBLPrototypeBinding* aBinding, nsIContent* aBoundElement);\\n@@ -78,26 +74,10 @@ public:\\n                              void** aTargetClassObject);\\n   nsresult CompilePrototypeMembers(nsXBLPrototypeBinding* aBinding);\\n \\n-  void SetMemberList(nsXBLProtoImplMember* aMemberList)\\n-  {\\n-    delete mMembers;\\n-    mMembers = aMemberList;\\n-  }\\n-\\n-  void SetFieldList(nsXBLProtoImplField* aFieldList)\\n-  {\\n-    delete mFields;\\n-    mFields = aFieldList;\\n-  }\\n+  void SetMemberList(nsXBLProtoImplMember* aMemberList) { delete mMembers; mMembers = aMemberList; }\\n \\n   void Traverse(nsCycleCollectionTraversalCallback &cb) const;\\n \\n-  nsXBLProtoImplField* FindField(const nsString& aFieldName) const;\\n-\\n-  // Resolve all the fields for this implementation on the object |obj| False\\n-  // return means a JS exception was set.\\n-  PRBool ResolveAllFields(JSContext *cx, JSObject *obj) const;\\n-\\n protected:\\n   // Function to call if compilation of a member fails.  When this is called,\\n   // all members before aBrokenMember are compiled, compilation of\\n@@ -113,8 +93,6 @@ protected:\\n                         // and methods for the binding.\\n \\n   nsXBLProtoImplMember* mMembers; // The members of an implementation are chained in this singly-linked list.\\n-\\n-  nsXBLProtoImplField* mFields; // Our fields\\n   \\n public:\\n   nsXBLProtoImplAnonymousMethod* mConstructor; // Our class constructor.\\ndiff --git a/content/xbl/src/nsXBLProtoImplField.cpp b/content/xbl/src/nsXBLProtoImplField.cpp\\nindex cf129df..4c7480a 100644\\n--- a/content/xbl/src/nsXBLProtoImplField.cpp\\n+++ b/content/xbl/src/nsXBLProtoImplField.cpp\\n@@ -46,17 +46,14 @@\\n #include \\\"nsXBLProtoImplField.h\\\"\\n #include \\\"nsIScriptContext.h\\\"\\n #include \\\"nsContentUtils.h\\\"\\n-#include \\\"nsIURI.h\\\"\\n \\n nsXBLProtoImplField::nsXBLProtoImplField(const PRUnichar* aName, const PRUnichar* aReadOnly)\\n-  : mNext(nsnull),\\n+  : nsXBLProtoImplMember(aName),\\n     mFieldText(nsnull),\\n     mFieldTextLength(0),\\n     mLineNumber(0)\\n {\\n   MOZ_COUNT_CTOR(nsXBLProtoImplField);\\n-  mName = NS_strdup(aName);  // XXXbz make more sense to use a stringbuffer?\\n-  \\n   mJSAttributes = JSPROP_ENUMERATE;\\n   if (aReadOnly) {\\n     nsAutoString readOnly; readOnly.Assign(*aReadOnly);\\n@@ -70,8 +67,11 @@ nsXBLProtoImplField::~nsXBLProtoImplField()\\n   MOZ_COUNT_DTOR(nsXBLProtoImplField);\\n   if (mFieldText)\\n     nsMemory::Free(mFieldText);\\n-  NS_Free(mName);\\n-  delete mNext;\\n+}\\n+\\n+void\\n+nsXBLProtoImplField::Destroy(PRBool aIsCompiled)\\n+{\\n }\\n \\n void \\n@@ -92,15 +92,27 @@ nsXBLProtoImplField::AppendFieldText(const nsAString& aText)\\n }\\n \\n nsresult\\n-nsXBLProtoImplField::InstallField(nsIScriptContext* aContext,\\n-                                  JSObject* aBoundNode,\\n-                                  nsIURI* aBindingDocURI) const\\n+nsXBLProtoImplField::InstallMember(nsIScriptContext* aContext,\\n+                                   nsIContent* aBoundElement, \\n+                                   void* aScriptObject,\\n+                                   void* aTargetClassObject,\\n+                                   const nsCString& aClassStr)\\n {\\n-  NS_PRECONDITION(aBoundNode,\\n-                  \\\"uh-oh, bound node should NOT be null or bad things will \\\"\\n-                  \\\"happen\\\");\\n+  if (mFieldTextLength == 0)\\n+    return NS_OK; // nothing to do.\\n+\\n+  JSContext* cx = (JSContext*) aContext->GetNativeContext();\\n+  NS_ASSERTION(aScriptObject, \\\"uh-oh, script Object should NOT be null or bad things will happen\\\");\\n+  if (!aScriptObject)\\n+    return NS_ERROR_FAILURE;\\n \\n-  jsval result = JSVAL_VOID;\\n+  nsCAutoString bindingURI(aClassStr);\\n+  PRInt32 hash = bindingURI.RFindChar('#');\\n+  if (hash != kNotFound)\\n+    bindingURI.Truncate(hash);\\n+  \\n+  // compile the literal string \\n+  jsval result = JSVAL_NULL;\\n   \\n   // EvaluateStringWithValue and JS_DefineUCProperty can both trigger GC, so\\n   // protect |result| here.\\n@@ -108,40 +120,39 @@ nsXBLProtoImplField::InstallField(nsIScriptContext* aContext,\\n   nsAutoGCRoot root(&result, &rv);\\n   if (NS_FAILED(rv))\\n     return rv;\\n+  PRBool undefined;\\n+  // XXX Need a URI here!\\n+  nsCOMPtr<nsIScriptContext> context = aContext;\\n+  rv = context->EvaluateStringWithValue(nsDependentString(mFieldText,\\n+                                                          mFieldTextLength), \\n+                                        aScriptObject,\\n+                                        nsnull, bindingURI.get(),\\n+                                        mLineNumber, nsnull,\\n+                                        (void*) &result, &undefined);\\n+  if (NS_FAILED(rv))\\n+    return rv;\\n \\n-  if (mFieldTextLength != 0) {\\n-    nsCAutoString uriSpec;\\n-    aBindingDocURI->GetSpec(uriSpec);\\n-  \\n-    // compile the literal string\\n-    // XXX Could we produce a better principal here?  Should be able\\n-    // to, really!\\n-    PRBool undefined;\\n-    nsCOMPtr<nsIScriptContext> context = aContext;\\n-    rv = context->EvaluateStringWithValue(nsDependentString(mFieldText,\\n-                                                            mFieldTextLength), \\n-                                          aBoundNode,\\n-                                          nsnull, uriSpec.get(),\\n-                                          mLineNumber, nsnull,\\n-                                          (void*) &result, &undefined);\\n-    if (NS_FAILED(rv))\\n-      return rv;\\n-\\n-    if (undefined) {\\n-      result = JSVAL_VOID;\\n-    }\\n-  }\\n-\\n-  // Define the evaluated result as a JS property\\n-  nsDependentString name(mName);\\n-  JSContext* cx = (JSContext*) aContext->GetNativeContext();\\n-  JSAutoRequest ar(cx);\\n-  if (!::JS_DefineUCProperty(cx, aBoundNode,\\n-                             reinterpret_cast<const jschar*>(mName), \\n-                             name.Length(), result, nsnull, nsnull,\\n-                             mJSAttributes)) {\\n-    return NS_ERROR_OUT_OF_MEMORY;\\n+  if (!undefined) {\\n+    // Define the evaluated result as a JS property\\n+    nsDependentString name(mName);\\n+    JSAutoRequest ar(cx);\\n+    if (!::JS_DefineUCProperty(cx, static_cast<JSObject *>(aScriptObject),\\n+                               reinterpret_cast<const jschar*>(mName), \\n+                               name.Length(), result, nsnull, nsnull, mJSAttributes))\\n+      return NS_ERROR_OUT_OF_MEMORY;\\n   }\\n   \\n   return NS_OK;\\n }\\n+\\n+nsresult \\n+nsXBLProtoImplField::CompileMember(nsIScriptContext* aContext, const nsCString& aClassStr,\\n+                                   void* aClassObject)\\n+{\\n+  return NS_OK;\\n+}\\n+\\n+void\\n+nsXBLProtoImplField::Traverse(nsCycleCollectionTraversalCallback &cb) const\\n+{\\n+}\\ndiff --git a/content/xbl/src/nsXBLProtoImplField.h b/content/xbl/src/nsXBLProtoImplField.h\\nindex 8c1d582..06758e2 100644\\n--- a/content/xbl/src/nsXBLProtoImplField.h\\n+++ b/content/xbl/src/nsXBLProtoImplField.h\\n@@ -46,31 +46,30 @@\\n #include \\\"nsString.h\\\"\\n #include \\\"nsXBLProtoImplMember.h\\\"\\n \\n-class nsIURI;\\n-\\n-class nsXBLProtoImplField\\n+class nsXBLProtoImplField: public nsXBLProtoImplMember\\n {\\n public:\\n   nsXBLProtoImplField(const PRUnichar* aName, const PRUnichar* aReadOnly);\\n-  ~nsXBLProtoImplField();\\n+  virtual ~nsXBLProtoImplField();\\n+  virtual void Destroy(PRBool aIsCompiled);\\n \\n   void AppendFieldText(const nsAString& aText);\\n   void SetLineNumber(PRUint32 aLineNumber) {\\n     mLineNumber = aLineNumber;\\n   }\\n   \\n-  nsXBLProtoImplField* GetNext() const { return mNext; }\\n-  void SetNext(nsXBLProtoImplField* aNext) { mNext = aNext; }\\n-\\n-  nsresult InstallField(nsIScriptContext* aContext,\\n-                        JSObject* aBoundNode, nsIURI*\\n-                        aBindingDocURI) const;\\n+  virtual nsresult InstallMember(nsIScriptContext* aContext,\\n+                                 nsIContent* aBoundElement, \\n+                                 void* aScriptObject,\\n+                                 void* aTargetClassObject,\\n+                                 const nsCString& aClassStr);\\n+  virtual nsresult CompileMember(nsIScriptContext* aContext,\\n+                                 const nsCString& aClassStr,\\n+                                 void* aClassObject);\\n \\n-  const PRUnichar* GetName() const { return mName; }\\n+  virtual void Traverse(nsCycleCollectionTraversalCallback &cb) const;\\n \\n protected:\\n-  nsXBLProtoImplField* mNext;\\n-  PRUnichar* mName;\\n   PRUnichar* mFieldText;\\n   PRUint32 mFieldTextLength;\\n   PRUint32 mLineNumber;\\ndiff --git a/content/xbl/src/nsXBLPrototypeBinding.cpp b/content/xbl/src/nsXBLPrototypeBinding.cpp\\nindex db393bf..24f6205 100644\\n--- a/content/xbl/src/nsXBLPrototypeBinding.cpp\\n+++ b/content/xbl/src/nsXBLPrototypeBinding.cpp\\n@@ -822,7 +822,7 @@ nsXBLPrototypeBinding::InitClass(const nsCString& aClassName,\\n   *aClassObject = nsnull;\\n \\n   return nsXBLBinding::DoInitJSClass(aContext, aGlobal, aScriptObject,\\n-                                     aClassName, this, aClassObject);\\n+                                     aClassName, aClassObject);\\n }\\n \\n nsIContent*\\ndiff --git a/content/xbl/src/nsXBLPrototypeBinding.h b/content/xbl/src/nsXBLPrototypeBinding.h\\nindex bb0d924..ee6e770 100644\\n--- a/content/xbl/src/nsXBLPrototypeBinding.h\\n+++ b/content/xbl/src/nsXBLPrototypeBinding.h\\n@@ -50,7 +50,6 @@\\n #include \\\"nsHashtable.h\\\"\\n #include \\\"nsIXBLDocumentInfo.h\\\"\\n #include \\\"nsCOMArray.h\\\"\\n-#include \\\"nsXBLProtoImpl.h\\\"\\n \\n class nsIAtom;\\n class nsIDocument;\\n@@ -59,7 +58,7 @@ class nsISupportsArray;\\n class nsSupportsHashtable;\\n class nsIXBLService;\\n class nsFixedSizeAllocator;\\n-class nsXBLProtoImplField;\\n+class nsXBLProtoImpl;\\n class nsXBLBinding;\\n \\n // *********************************************************************/\\n@@ -95,22 +94,6 @@ public:\\n   nsXBLProtoImplAnonymousMethod* GetDestructor();\\n   nsresult SetDestructor(nsXBLProtoImplAnonymousMethod* aDestructor);\\n \\n-  nsXBLProtoImplField* FindField(const nsString& aFieldName) const\\n-  {\\n-    return mImplementation ? mImplementation->FindField(aFieldName) : nsnull;\\n-  }\\n-\\n-  // Resolve all the fields for this binding on the object |obj|.\\n-  // False return means a JS exception was set.\\n-  PRBool ResolveAllFields(JSContext* cx, JSObject* obj) const\\n-  {\\n-    return !mImplementation || mImplementation->ResolveAllFields(cx, obj);\\n-  }\\n-\\n-  const nsCString& ClassName() const {\\n-    return mImplementation ? mImplementation->mClassName : EmptyCString();\\n-  }\\n-\\n   nsresult InitClass(const nsCString& aClassName, JSContext * aContext,\\n                      JSObject * aGlobal, JSObject * aScriptObject,\\n                      void ** aClassObject);\\ndiff --git a/content/xbl/test/Makefile.in b/content/xbl/test/Makefile.in\\nindex 26db993..029ec10 100644\\n--- a/content/xbl/test/Makefile.in\\n+++ b/content/xbl/test/Makefile.in\\n@@ -50,7 +50,6 @@ _TEST_FILES =\\t\\\\\\n \\t\\ttest_bug296375.xul \\\\\\n \\t\\ttest_bug366770.html \\\\\\n \\t\\ttest_bug371724.xhtml \\\\\\n-\\t\\ttest_bug372769.xhtml \\\\\\n \\t\\t$(NULL)\\n \\n libs:: $(_TEST_FILES)\\ndiff --git a/dom/src/base/nsDOMClassInfo.cpp b/dom/src/base/nsDOMClassInfo.cpp\\nindex 0ff7b6a..5c18513 100644\\n--- a/dom/src/base/nsDOMClassInfo.cpp\\n+++ b/dom/src/base/nsDOMClassInfo.cpp\\n@@ -477,8 +477,7 @@ static const char kDOMStringBundleURL[] =\\n // possible.\\n \\n #define ELEMENT_SCRIPTABLE_FLAGS                                              \\\\\\n-  ((NODE_SCRIPTABLE_FLAGS & ~nsIXPCScriptable::CLASSINFO_INTERFACES_ONLY) |   \\\\\\n-   nsIXPCScriptable::WANT_ENUMERATE)\\n+  (NODE_SCRIPTABLE_FLAGS & ~nsIXPCScriptable::CLASSINFO_INTERFACES_ONLY)\\n \\n #define EXTERNAL_OBJ_SCRIPTABLE_FLAGS                                         \\\\\\n   (ELEMENT_SCRIPTABLE_FLAGS & ~nsIXPCScriptable::USE_JSSTUB_FOR_SETPROPERTY | \\\\\\n@@ -6941,32 +6940,6 @@ nsElementSH::PostCreate(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\\n   return NS_OK;\\n }\\n \\n-NS_IMETHODIMP\\n-nsElementSH::Enumerate(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\\n-                       JSObject *obj, PRBool *_retval)\\n-{\\n-  // Make sure to not call the superclass here!\\n-  nsCOMPtr<nsIContent> content(do_QueryWrappedNative(wrapper));\\n-  NS_ENSURE_TRUE(content, NS_ERROR_UNEXPECTED);\\n-\\n-  nsIDocument* doc = content->GetOwnerDoc();\\n-  if (!doc) {\\n-    // Nothing else to do here\\n-    return NS_OK;\\n-  }\\n-\\n-  nsXBLBinding* binding = doc->BindingManager()->GetBinding(content);\\n-  if (!binding) {\\n-    // Nothing else to do here\\n-    return NS_OK;\\n-  }\\n-\\n-  *_retval = binding->ResolveAllFields(cx, obj);\\n-  \\n-  return NS_OK;\\n-}\\n-  \\n-\\n // Generic array scriptable helper.\\n \\n NS_IMETHODIMP\\ndiff --git a/dom/src/base/nsDOMClassInfo.h b/dom/src/base/nsDOMClassInfo.h\\nindex 34bbc96..da0f838 100644\\n--- a/dom/src/base/nsDOMClassInfo.h\\n+++ b/dom/src/base/nsDOMClassInfo.h\\n@@ -563,8 +563,6 @@ protected:\\n public:\\n   NS_IMETHOD PostCreate(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\\n                         JSObject *obj);\\n-  NS_IMETHOD Enumerate(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\\n-                       JSObject *obj, PRBool *_retval);\\n \\n   static nsIClassInfo *doCreate(nsDOMClassInfoData* aData)\\n   {\\n\""}