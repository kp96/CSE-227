{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas9b2769f\""},"diff":"\"9b2769f fix for bug #389503:  handle repeated calls to ProcessResult() [allow for incremental autocomplete search results] r=gavin\\ndiff --git a/toolkit/components/autocomplete/public/nsIAutoCompleteController.idl b/toolkit/components/autocomplete/public/nsIAutoCompleteController.idl\\nindex ecf5bb1..dabf725 100644\\n--- a/toolkit/components/autocomplete/public/nsIAutoCompleteController.idl\\n+++ b/toolkit/components/autocomplete/public/nsIAutoCompleteController.idl\\n@@ -41,7 +41,7 @@\\n \\n interface nsIAutoCompleteInput;\\n \\n-[scriptable, uuid(b865d5cf-2ce1-4a5b-bb99-3d8a71df5ee9)]\\n+[scriptable, uuid(bb4d04f6-997b-437a-9216-7a3dbbd848d0)]\\n interface nsIAutoCompleteController : nsISupports\\n {\\n   /*\\n@@ -51,7 +51,7 @@ interface nsIAutoCompleteController : nsISupports\\n   const unsigned short STATUS_SEARCHING = 2;\\n   const unsigned short STATUS_COMPLETE_NO_MATCH = 3;\\n   const unsigned short STATUS_COMPLETE_MATCH = 4;\\n-  \\n+\\n   /*\\n    * The input widget that is currently being controlled.\\n    */\\n@@ -72,6 +72,11 @@ interface nsIAutoCompleteController : nsISupports\\n    */\\n   void startSearch(in AString searchString);\\n \\n+  /* \\n+   * Stop all asynchronous searches\\n+   */\\n+  void stopSearch();\\n+\\n   /*\\n    * Notify the controller that the user has changed text in the textbox.  This includes all\\n    * means of changing the text value, including typing a character, backspacing, deleting, or\\ndiff --git a/toolkit/components/autocomplete/public/nsIAutoCompleteResult.idl b/toolkit/components/autocomplete/public/nsIAutoCompleteResult.idl\\nindex c3ae8cd..0fbb173 100644\\n--- a/toolkit/components/autocomplete/public/nsIAutoCompleteResult.idl\\n+++ b/toolkit/components/autocomplete/public/nsIAutoCompleteResult.idl\\n@@ -37,7 +37,7 @@\\n \\n #include \\\"nsISupports.idl\\\"\\n \\n-[scriptable, uuid(78c49e44-4613-48c4-b502-29df82231222)]\\n+[scriptable, uuid(d2fcba9a-3f5c-40fc-a9fc-4adc87dc61ef)]\\n interface nsIAutoCompleteResult : nsISupports\\n {\\n   /**\\n@@ -45,9 +45,18 @@ interface nsIAutoCompleteResult : nsISupports\\n    */\\n   const unsigned short RESULT_IGNORED = 1; /* indicates invalid searchString */\\n   const unsigned short RESULT_FAILURE = 2; /* indicates failure */\\n-  const unsigned short RESULT_NOMATCH = 3; /* indicates success with no matches */\\n-  const unsigned short RESULT_SUCCESS = 4; /* indicates success with matches */\\n-\\n+  const unsigned short RESULT_NOMATCH = 3; /* indicates success with no matches\\n+                                              and that the search is complete */\\n+  const unsigned short RESULT_SUCCESS = 4; /* indicates success with matches\\n+                                              and that the search is complete */\\n+  const unsigned short RESULT_NOMATCH_ONGOING = 5; /* indicates success \\n+                                                      with no matches\\n+                                                      and that the search \\n+                                                      is still ongoing */\\n+  const unsigned short RESULT_SUCCESS_ONGOING = 6; /* indicates success \\n+                                                      with matches\\n+                                                      and that the search \\n+                                                      is still ongoing */\\n   /**\\n    * The original search string\\n    */\\ndiff --git a/toolkit/components/autocomplete/public/nsIAutoCompleteSearch.idl b/toolkit/components/autocomplete/public/nsIAutoCompleteSearch.idl\\nindex 32ff8d2..6e847a5 100644\\n--- a/toolkit/components/autocomplete/public/nsIAutoCompleteSearch.idl\\n+++ b/toolkit/components/autocomplete/public/nsIAutoCompleteSearch.idl\\n@@ -58,7 +58,7 @@ interface nsIAutoCompleteSearch : nsISupports\\n                    in nsIAutoCompleteObserver listener);\\n \\n   /*\\n-   * Stop an asynchronous search that is in progress\\n+   * Stop all searches that are in progress\\n    */\\n   void stopSearch();\\n };\\ndiff --git a/toolkit/components/autocomplete/src/nsAutoCompleteController.cpp b/toolkit/components/autocomplete/src/nsAutoCompleteController.cpp\\nindex fe81e67..5ab7824 100644\\n--- a/toolkit/components/autocomplete/src/nsAutoCompleteController.cpp\\n+++ b/toolkit/components/autocomplete/src/nsAutoCompleteController.cpp\\n@@ -81,7 +81,8 @@ nsAutoCompleteController::nsAutoCompleteController() :\\n   mIsOpen(PR_FALSE),\\n   mSearchStatus(0),\\n   mRowCount(0),\\n-  mSearchesOngoing(0)\\n+  mSearchesOngoing(0),\\n+  mFirstSearchResult(PR_FALSE)\\n {\\n   mSearches = do_CreateInstance(\\\"@mozilla.org/supports-array;1\\\");\\n   mResults = do_CreateInstance(\\\"@mozilla.org/supports-array;1\\\");\\n@@ -126,11 +127,11 @@ nsAutoCompleteController::SetInput(nsIAutoCompleteInput *aInput)\\n \\n   // Clear out the current search context\\n   if (mInput) {\\n-    ClearSearchTimer();\\n+    // Stop all searches in case they are async.\\n+    StopSearch();\\n     ClearResults();\\n-    if (mIsOpen) {\\n+    if (mIsOpen)\\n       ClosePopup();\\n-    }\\n     mSearches->Clear();\\n   }\\n     \\n@@ -157,7 +158,8 @@ nsAutoCompleteController::SetInput(nsIAutoCompleteInput *aInput)\\n   mInput->GetSearchCount(&searchCount);\\n   mResults->SizeTo(searchCount);\\n   mSearches->SizeTo(searchCount);\\n-  \\n+  mMatchCounts.SetLength(searchCount);\\n+\\n   const char *searchCID = kAutoCompleteSearchCID;\\n \\n   for (PRUint32 i = 0; i < searchCount; ++i) {\\n@@ -189,10 +191,8 @@ NS_IMETHODIMP\\n nsAutoCompleteController::HandleText(PRBool aIgnoreSelection)\\n {\\n   if (!mInput) {\\n-    // Stop current search in case it's async.\\n+    // Stop all searches in case they are async.\\n     StopSearch();\\n-    // Stop the queued up search on a timer\\n-    ClearSearchTimer();\\n     // Note: if now is after blur and IME end composition,\\n     // check mInput before calling.\\n     // See https://bugzilla.mozilla.org/show_bug.cgi?id=193544#c31\\n@@ -210,7 +210,7 @@ nsAutoCompleteController::HandleText(PRBool aIgnoreSelection)\\n   // Note that the input event occurs if IME composition is cancelled, as well.\\n   // In HandleEndComposition, we are processing the popup properly.\\n   // Therefore, the input event after composition end event should do nothing.\\n-  // (E.g., calling StopSearch(), ClearSearchTimer() and ClosePopup().)\\n+  // (E.g., calling StopSearch() and ClosePopup().)\\n   // If it is not, popup is always closed after composition end.\\n   if (mIgnoreHandleText) {\\n     mIgnoreHandleText = PR_FALSE;\\n@@ -219,10 +219,8 @@ nsAutoCompleteController::HandleText(PRBool aIgnoreSelection)\\n     NS_ERROR(\\\"Now is after composition end event. But the value was changed.\\\");\\n   }\\n \\n-  // Stop current search in case it's async.\\n+  // Stop all searches in case they are async.\\n   StopSearch();\\n-  // Stop the queued up search on a timer\\n-  ClearSearchTimer();\\n \\n   PRBool disabled;\\n   mInput->GetDisableAutoComplete(&disabled);\\n@@ -292,7 +290,12 @@ nsAutoCompleteController::HandleEnter(PRBool *_retval)\\n     }\\n   }\\n   \\n-  ClearSearchTimer();\\n+  // clear the search timer only if we are not searching.\\n+  // if we are searching, EnterMatch() will not handle the enter\\n+  // immediately.  instead, we will handle it on the next result we process\\n+  // but we need the search timer to fire to kick of that search \\n+  if (mSearchStatus != nsIAutoCompleteController::STATUS_SEARCHING)\\n+    ClearSearchTimer();\\n   EnterMatch();\\n   \\n   return NS_OK;\\n@@ -308,7 +311,8 @@ nsAutoCompleteController::HandleEscape(PRBool *_retval)\\n   // allow the event through if the popup is closed\\n   mInput->GetPopupOpen(_retval);\\n   \\n-  ClearSearchTimer();\\n+  // Stop all searches in case they are async.\\n+  StopSearch();\\n   ClearResults();\\n   RevertTextValue();\\n   ClosePopup();\\n@@ -332,8 +336,8 @@ nsAutoCompleteController::HandleStartComposition()\\n   if (disabled)\\n     return NS_OK;\\n \\n+  // Stop all searches in case they are async.\\n   StopSearch();\\n-  ClearSearchTimer();\\n \\n   PRBool isOpen;\\n   mInput->GetPopupOpen(&isOpen);\\n@@ -972,6 +976,7 @@ nsAutoCompleteController::StartSearch()\\n   PRUint32 count;\\n   mSearches->Count(&count);\\n   mSearchesOngoing = count;\\n+  mFirstSearchResult = PR_TRUE;\\n \\n   PRUint32 searchesFailed = 0;\\n   for (PRUint32 i = 0; i < count; ++i) {\\n@@ -983,7 +988,8 @@ nsAutoCompleteController::StartSearch()\\n     if (result) {\\n       PRUint16 searchResult;\\n       result->GetSearchResult(&searchResult);\\n-      if (searchResult != nsIAutoCompleteResult::RESULT_SUCCESS)\\n+      if (searchResult != nsIAutoCompleteResult::RESULT_SUCCESS &&\\n+          searchResult != nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING)\\n         result = nsnull;\\n     }\\n     \\n@@ -1001,13 +1007,13 @@ nsAutoCompleteController::StartSearch()\\n     }\\n   }\\n   \\n-  if (searchesFailed == count) {\\n+  if (searchesFailed == count)\\n     PostSearchCleanup();\\n-  }\\n+\\n   return NS_OK;\\n }\\n \\n-nsresult\\n+NS_IMETHODIMP\\n nsAutoCompleteController::StopSearch()\\n {\\n   // Stop the timer if there is one\\n@@ -1084,7 +1090,7 @@ nsAutoCompleteController::EnterMatch()\\n     \\n     if (forceComplete && value.IsEmpty()) {\\n       // Since nothing was selected, and forceComplete is specified, that means\\n-      // we have to find find the first default match and enter it instead\\n+      // we have to find the first default match and enter it instead\\n       PRUint32 count;\\n       mResults->Count(&count);\\n       for (PRUint32 i = 0; i < count; ++i) {\\n@@ -1149,23 +1155,45 @@ nsresult\\n nsAutoCompleteController::ProcessResult(PRInt32 aSearchIndex, nsIAutoCompleteResult *aResult)\\n {\\n   NS_ENSURE_STATE(mInput);\\n-  // If this is the first search to return, we should clear out the previous cached results\\n-  PRUint32 searchCount;\\n-  mSearches->Count(&searchCount);\\n-  if (mSearchesOngoing == searchCount)\\n-    ClearResults();\\n \\n-  --mSearchesOngoing;\\n-  \\n-  // Cache the result\\n-  mResults->AppendElement(aResult);\\n+  // If this is the first search result we are processing\\n+  // we should clear out the previously cached results\\n+  if (mFirstSearchResult) {\\n+    ClearResults();\\n+    mFirstSearchResult = PR_FALSE;\\n+  }\\n \\n-  // If the search failed, increase the match count to include the error description\\n   PRUint16 result = 0;\\n-  PRUint32 oldRowCount = mRowCount;\\n-\\n   if (aResult)\\n     aResult->GetSearchResult(&result);\\n+\\n+  // if our results are incremental, the search is still ongoing\\n+  if (result != nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING &&\\n+      result != nsIAutoCompleteResult::RESULT_NOMATCH_ONGOING) {\\n+    --mSearchesOngoing;\\n+  }\\n+\\n+  \\n+  PRUint32 oldMatchCount = 0;\\n+  PRUint32 matchCount = 0;\\n+  aResult->GetMatchCount(&matchCount);\\n+\\n+  PRInt32 oldIndex = mResults->IndexOf(aResult);\\n+  if (oldIndex == -1) {\\n+    // cache the result\\n+    mResults->AppendElement(aResult);\\n+    mMatchCounts.AppendElement(matchCount);\\n+  }\\n+  else {\\n+    // replace the cached result\\n+    mResults->ReplaceElementAt(aResult, oldIndex);\\n+    oldMatchCount = mMatchCounts[aSearchIndex];\\n+    mMatchCounts[oldIndex] = matchCount;\\n+  }\\n+\\n+  PRUint32 oldRowCount = mRowCount;\\n+  // If the search failed, increase the match count \\n+  // to include the error description\\n   if (result == nsIAutoCompleteResult::RESULT_FAILURE) {\\n     nsAutoString error;\\n     aResult->GetErrorDescription(error);\\n@@ -1174,13 +1202,13 @@ nsAutoCompleteController::ProcessResult(PRInt32 aSearchIndex, nsIAutoCompleteRes\\n       if (mTree)\\n         mTree->RowCountChanged(oldRowCount, 1);\\n     }\\n-  } else if (result == nsIAutoCompleteResult::RESULT_SUCCESS) {\\n+  } else if (result == nsIAutoCompleteResult::RESULT_SUCCESS ||\\n+             result == nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING) {\\n     // Increase the match count for all matches in this result\\n-    PRUint32 matchCount = 0;\\n-    aResult->GetMatchCount(&matchCount);\\n-    mRowCount += matchCount;\\n+    mRowCount += matchCount - oldMatchCount;\\n+\\n     if (mTree)\\n-      mTree->RowCountChanged(oldRowCount, matchCount);\\n+      mTree->RowCountChanged(oldRowCount, matchCount - oldMatchCount);\\n \\n     // Try to autocomplete the default index for this search\\n     CompleteDefaultIndex(aSearchIndex);\\n@@ -1199,6 +1227,14 @@ nsAutoCompleteController::ProcessResult(PRInt32 aSearchIndex, nsIAutoCompleteRes\\n   else\\n     ClosePopup();\\n \\n+  // if the user hit enter but we still have searches ongoing,\\n+  // stop the searches, otherwise enter won't be handled\\n+  // by PostSearchCleanup() until the ongoing searches finish.\\n+  if (mEnterAfterSearch && mSearchesOngoing) {\\n+    StopSearch();\\n+    mSearchesOngoing = 0;  \\n+  }\\n+\\n   // If this is the last search to return, cleanup\\n   if (mSearchesOngoing == 0)\\n     PostSearchCleanup();\\n@@ -1208,7 +1244,7 @@ nsAutoCompleteController::ProcessResult(PRInt32 aSearchIndex, nsIAutoCompleteRes\\n \\n nsresult\\n nsAutoCompleteController::PostSearchCleanup()\\n-{\\n+{  \\n   NS_ENSURE_STATE(mInput);\\n   if (mRowCount) {\\n     OpenPopup();\\n@@ -1221,8 +1257,8 @@ nsAutoCompleteController::PostSearchCleanup()\\n   // notify the input that the search is complete\\n   mInput->OnSearchComplete();\\n   \\n-  // if mEnterAfterSearch was set, then the user hit enter while the search was ongoing,\\n-  // so we need to enter a match now that the search is done\\n+  // if mEnterAfterSearch was set, then the user hit enter while the \\n+  // search was ongoing, so we need to enter a match now that the search is done\\n   if (mEnterAfterSearch)\\n     EnterMatch();\\n \\n@@ -1235,6 +1271,7 @@ nsAutoCompleteController::ClearResults()\\n   PRInt32 oldRowCount = mRowCount;\\n   mRowCount = 0;\\n   mResults->Clear();\\n+  mMatchCounts.Clear();\\n   if (oldRowCount != 0 && mTree)\\n     mTree->RowCountChanged(0, -oldRowCount);\\n   return NS_OK;\\n@@ -1359,7 +1396,8 @@ nsAutoCompleteController::GetResultValueAt(PRInt32 aIndex, PRBool aValueOnly, ns\\n     if (aValueOnly)\\n       return NS_ERROR_FAILURE;\\n     result->GetErrorDescription(_retval);\\n-  } else if (searchResult == nsIAutoCompleteResult::RESULT_SUCCESS) {\\n+  } else if (searchResult == nsIAutoCompleteResult::RESULT_SUCCESS ||\\n+             searchResult == nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING) {\\n     result->GetValueAt(rowIndex, _retval);\\n   }\\n   \\n@@ -1395,7 +1433,8 @@ nsAutoCompleteController::RowIndexToSearch(PRInt32 aRowIndex, PRInt32 *aSearchIn\\n     // Find out how many results were provided by the \\n     // current nsIAutoCompleteSearch\\n     PRUint32 rowCount = 0;\\n-    if (searchResult == nsIAutoCompleteResult::RESULT_SUCCESS) {\\n+    if (searchResult == nsIAutoCompleteResult::RESULT_SUCCESS ||\\n+        searchResult == nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING) {\\n       result->GetMatchCount(&rowCount);\\n     }\\n     \\ndiff --git a/toolkit/components/autocomplete/src/nsAutoCompleteController.h b/toolkit/components/autocomplete/src/nsAutoCompleteController.h\\nindex 045341e..dd71de8 100644\\n--- a/toolkit/components/autocomplete/src/nsAutoCompleteController.h\\n+++ b/toolkit/components/autocomplete/src/nsAutoCompleteController.h\\n@@ -52,6 +52,7 @@\\n #include \\\"nsITimer.h\\\"\\n #include \\\"nsIRollupListener.h\\\"\\n #include \\\"nsIWidget.h\\\"\\n+#include \\\"nsTArray.h\\\"\\n \\n class nsAutoCompleteController : public nsIAutoCompleteController,\\n                                  public nsIAutoCompleteObserver,\\n@@ -75,7 +76,6 @@ protected:\\n   nsresult ClosePopup();\\n \\n   nsresult StartSearch();\\n-  nsresult StopSearch();\\n   \\n   nsresult StartSearchTimer();\\n   nsresult ClearSearchTimer();\\n@@ -102,6 +102,7 @@ protected:\\n   \\n   nsCOMPtr<nsISupportsArray> mSearches;\\n   nsCOMPtr<nsISupportsArray> mResults;\\n+  nsTArray<PRUint32> mMatchCounts;\\n   \\n   nsCOMPtr<nsITimer> mTimer;\\n   nsCOMPtr<nsITreeSelection> mSelection;\\n@@ -118,6 +119,7 @@ protected:\\n   PRUint16 mSearchStatus;\\n   PRUint32 mRowCount;\\n   PRUint32 mSearchesOngoing;\\n+  PRBool mFirstSearchResult;\\n };\\n \\n #endif /* __nsAutoCompleteController__ */\\ndiff --git a/toolkit/content/widgets/autocomplete.xml b/toolkit/content/widgets/autocomplete.xml\\nindex 848a8c9..aa80891 100644\\n--- a/toolkit/content/widgets/autocomplete.xml\\n+++ b/toolkit/content/widgets/autocomplete.xml\\n@@ -511,9 +511,8 @@\\n \\n       <handler event=\\\"contextmenu\\\" phase=\\\"capturing\\\"\\n                action=\\\"this.closePopup();\\\"/>\\n-\\n     </handlers>\\n-  </binding> \\n+  </binding>\\n \\n   <binding id=\\\"autocomplete-result-popup\\\" extends=\\\"chrome://global/content/bindings/popup.xml#popup\\\">\\n     <resources>\\n@@ -776,7 +775,10 @@\\n         this.mPopupOpen = true;\\n       ]]></handler>\\n \\n-      <handler event=\\\"popuphiding\\\">\\n+      <handler event=\\\"popuphiding\\\"><![CDATA[\\n+        var controller = this.view.QueryInterface(Components.interfaces.nsIAutoCompleteController);\\n+        controller.stopSearch();\\n+\\n         this.mPopupOpen = false;\\n \\n         // Reset the maxRows property to the cached \\\"normal\\\" value, and reset\\n@@ -784,7 +786,7 @@\\n         // when the popupshowing handler runs.\\n         this.mInput.maxRows = this._normalMaxRows;\\n         this._normalMaxRows = -1;\\n-      </handler>\\n+      ]]></handler>\\n     </handlers>\\n   </binding>\\n \\n\""}