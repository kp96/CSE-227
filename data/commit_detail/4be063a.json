{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas4be063a\""},"diff":"\"4be063a Bug 394673: avoid recursion with long chains of \\\"||\\\" or \\\"&&\\\" in JS code. r=brendan\\ndiff --git a/js/src/jsemit.c b/js/src/jsemit.c\\nindex fdaabfa..098cd91 100644\\n--- a/js/src/jsemit.c\\n+++ b/js/src/jsemit.c\\n@@ -5590,42 +5590,57 @@ js_EmitTree(JSContext *cx, JSCodeGenerator *cg, JSParseNode *pn)\\n          * JSOP_AND converts the operand on the stack to boolean, and if false,\\n          * leaves the original operand value on the stack and jumps; otherwise\\n          * it pops and falls into the right operand's bytecode.\\n-         *\\n-         * Avoid tail recursion for long ||...|| expressions and long &&...&&\\n-         * expressions or long mixtures of ||'s and &&'s that can easily blow\\n-         * the stack, by forward-linking and then backpatching all the JSOP_OR\\n-         * and JSOP_AND bytecodes' immediate jump-offset operands.\\n          */\\n-        pn3 = pn;\\n-        if (!js_EmitTree(cx, cg, pn->pn_left))\\n-            return JS_FALSE;\\n-        top = EmitJump(cx, cg, JSOP_BACKPATCH_POP, 0);\\n-        if (top < 0)\\n-            return JS_FALSE;\\n-        jmp = top;\\n-        pn2 = pn->pn_right;\\n-        while (pn2->pn_type == TOK_OR || pn2->pn_type == TOK_AND) {\\n-            pn = pn2;\\n+        if (pn->pn_arity == PN_BINARY) {\\n             if (!js_EmitTree(cx, cg, pn->pn_left))\\n                 return JS_FALSE;\\n-            off = EmitJump(cx, cg, JSOP_BACKPATCH_POP, 0);\\n-            if (off < 0)\\n+            top = EmitJump(cx, cg, JSOP_BACKPATCH_POP, 0);\\n+            if (top < 0)\\n                 return JS_FALSE;\\n-            if (!SetBackPatchDelta(cx, cg, CG_CODE(cg, jmp), off - jmp))\\n+            if (!js_EmitTree(cx, cg, pn->pn_right))\\n                 return JS_FALSE;\\n-            jmp = off;\\n-            pn2 = pn->pn_right;\\n-        }\\n-        if (!js_EmitTree(cx, cg, pn2))\\n-            return JS_FALSE;\\n-        off = CG_OFFSET(cg);\\n-        do {\\n+            off = CG_OFFSET(cg);\\n             pc = CG_CODE(cg, top);\\n-            tmp = GetJumpOffset(cg, pc);\\n             CHECK_AND_SET_JUMP_OFFSET(cx, cg, pc, off - top);\\n-            *pc = pn3->pn_op;\\n-            top += tmp;\\n-        } while ((pn3 = pn3->pn_right) != pn2);\\n+            *pc = pn->pn_op;\\n+        } else {\\n+            JS_ASSERT(pn->pn_arity == PN_LIST);\\n+            JS_ASSERT(pn->pn_head->pn_next->pn_next);\\n+\\n+            /* Left-associative operator chain: avoid too much recursion. */\\n+            pn2 = pn->pn_head;\\n+            if (!js_EmitTree(cx, cg, pn2))\\n+                return JS_FALSE;\\n+            top = EmitJump(cx, cg, JSOP_BACKPATCH_POP, 0);\\n+            if (top < 0)\\n+                return JS_FALSE;\\n+\\n+            /* Emit nodes between the head and the tail. */\\n+            jmp = top;\\n+            while ((pn2 = pn2->pn_next)->pn_next) {\\n+                if (!js_EmitTree(cx, cg, pn2))\\n+                    return JS_FALSE;\\n+                off = EmitJump(cx, cg, JSOP_BACKPATCH_POP, 0);\\n+                if (off < 0)\\n+                    return JS_FALSE;\\n+                if (!SetBackPatchDelta(cx, cg, CG_CODE(cg, jmp), off - jmp))\\n+                    return JS_FALSE;\\n+                jmp = off;\\n+\\n+            }\\n+            if (!js_EmitTree(cx, cg, pn2))\\n+                return JS_FALSE;\\n+\\n+            pn2 = pn->pn_head;\\n+            off = CG_OFFSET(cg);\\n+            do {\\n+                pc = CG_CODE(cg, top);\\n+                tmp = GetJumpOffset(cg, pc);\\n+                CHECK_AND_SET_JUMP_OFFSET(cx, cg, pc, off - top);\\n+                *pc = pn->pn_op;\\n+                top += tmp;\\n+            } while ((pn2 = pn2->pn_next)->pn_next);\\n+        }\\n         break;\\n \\n       case TOK_BITOR:\\ndiff --git a/js/src/jsopcode.tbl b/js/src/jsopcode.tbl\\nindex cae7e37..a64142c 100644\\n--- a/js/src/jsopcode.tbl\\n+++ b/js/src/jsopcode.tbl\\n@@ -171,8 +171,8 @@ OPDEF(JSOP_NULL,      64, js_null_str,  js_null_str,  1,  0,  1, 19,  JOF_BYTE)\\n OPDEF(JSOP_THIS,      65, js_this_str,  js_this_str,  1,  0,  1, 19,  JOF_BYTE)\\n OPDEF(JSOP_FALSE,     66, js_false_str, js_false_str, 1,  0,  1, 19,  JOF_BYTE)\\n OPDEF(JSOP_TRUE,      67, js_true_str,  js_true_str,  1,  0,  1, 19,  JOF_BYTE)\\n-OPDEF(JSOP_OR,        68, \\\"or\\\",         NULL,         3,  1,  0,  5,  JOF_JUMP|JOF_DETECTING)\\n-OPDEF(JSOP_AND,       69, \\\"and\\\",        NULL,         3,  1,  0,  6,  JOF_JUMP|JOF_DETECTING)\\n+OPDEF(JSOP_OR,        68, \\\"or\\\",         NULL,         3,  1,  0,  5,  JOF_JUMP|JOF_DETECTING|JOF_LEFTASSOC)\\n+OPDEF(JSOP_AND,       69, \\\"and\\\",        NULL,         3,  1,  0,  6,  JOF_JUMP|JOF_DETECTING|JOF_LEFTASSOC)\\n \\n /* The switch bytecodes have variable length. */\\n OPDEF(JSOP_TABLESWITCH,  70, \\\"tableswitch\\\",  NULL,   -1,  1,  0,  0,  JOF_TABLESWITCH|JOF_DETECTING|JOF_PARENHEAD)\\ndiff --git a/js/src/jsparse.c b/js/src/jsparse.c\\nindex 31d3954..5dafc0c 100644\\n--- a/js/src/jsparse.c\\n+++ b/js/src/jsparse.c\\n@@ -3993,8 +3993,8 @@ OrExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)\\n     JSParseNode *pn;\\n \\n     pn = AndExpr(cx, ts, tc);\\n-    if (pn && js_MatchToken(cx, ts, TOK_OR))\\n-        pn = NewBinary(cx, TOK_OR, JSOP_OR, pn, OrExpr(cx, ts, tc), tc);\\n+    while (pn && js_MatchToken(cx, ts, TOK_OR))\\n+        pn = NewBinary(cx, TOK_OR, JSOP_OR, pn, AndExpr(cx, ts, tc), tc);\\n     return pn;\\n }\\n \\n@@ -4004,8 +4004,8 @@ AndExpr(JSContext *cx, JSTokenStream *ts, JSTreeContext *tc)\\n     JSParseNode *pn;\\n \\n     pn = BitOrExpr(cx, ts, tc);\\n-    if (pn && js_MatchToken(cx, ts, TOK_AND))\\n-        pn = NewBinary(cx, TOK_AND, JSOP_AND, pn, AndExpr(cx, ts, tc), tc);\\n+    while (pn && js_MatchToken(cx, ts, TOK_AND))\\n+        pn = NewBinary(cx, TOK_AND, JSOP_AND, pn, BitOrExpr(cx, ts, tc), tc);\\n     return pn;\\n }\\n \\n\""}