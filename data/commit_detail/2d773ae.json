{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas2d773ae\""},"diff":"\"2d773ae New appshell (process Gecko events on demand in Cocoa widgets). b=395397 r=joshmoz+mark sr=roc a=joshmoz\\ndiff --git a/widget/src/cocoa/nsAppShell.h b/widget/src/cocoa/nsAppShell.h\\nindex f7abf30..45dc5ff 100644\\n--- a/widget/src/cocoa/nsAppShell.h\\n+++ b/widget/src/cocoa/nsAppShell.h\\n@@ -50,20 +50,20 @@\\n class nsAppShell : public nsBaseAppShell\\n {\\n public:\\n-  NS_IMETHODIMP ResumeNative(void);\\n+  NS_IMETHOD ResumeNative(void);\\n \\t\\n   nsAppShell();\\n \\n   nsresult Init();\\n \\n   NS_IMETHOD Run(void);\\n+  NS_IMETHOD Exit(void);\\n   NS_IMETHOD OnProcessNextEvent(nsIThreadInternal *aThread, PRBool aMayWait,\\n                                 PRUint32 aRecursionDepth);\\n   NS_IMETHOD AfterProcessNextEvent(nsIThreadInternal *aThread,\\n                                    PRUint32 aRecursionDepth);\\n \\n   // public only to be visible to Objective-C code that must call it\\n-  void ProcessGeckoEvents();\\n   void WillTerminate();\\n \\n protected:\\n@@ -72,16 +72,25 @@ protected:\\n   virtual void ScheduleNativeEventCallback();\\n   virtual PRBool ProcessNextNativeEvent(PRBool aMayWait);\\n \\n+  static void ProcessGeckoEvents(void* aInfo);\\n+\\n protected:\\n   NSAutoreleasePool* mMainPool;\\n   CFMutableArrayRef  mAutoreleasePools;\\n \\n-  NSPort*            mPort;\\n   AppShellDelegate*  mDelegate;\\n+  CFRunLoopRef       mCFRunLoop;\\n+  CFRunLoopSourceRef mCFRunLoopSource;\\n \\n   PRPackedBool       mRunningEventLoop;\\n+  PRPackedBool       mStarted;\\n   PRPackedBool       mTerminated;\\n   PRPackedBool       mSkippedNativeCallback;\\n+\\n+  // mHadMoreEventsCount and kHadMoreEventsCountMax are used in\\n+  // ProcessNextNativeEvent().\\n+  PRUint32               mHadMoreEventsCount;\\n+  static const PRUint32  kHadMoreEventsCountMax = 10;\\n };\\n \\n #endif // nsAppShell_h_\\ndiff --git a/widget/src/cocoa/nsAppShell.mm b/widget/src/cocoa/nsAppShell.mm\\nindex a693594..fed73b4 100644\\n--- a/widget/src/cocoa/nsAppShell.mm\\n+++ b/widget/src/cocoa/nsAppShell.mm\\n@@ -49,28 +49,38 @@\\n #include \\\"nsString.h\\\"\\n #include \\\"nsIRollupListener.h\\\"\\n #include \\\"nsIWidget.h\\\"\\n+#include \\\"nsThreadUtils.h\\\"\\n+#include \\\"nsIWindowMediator.h\\\"\\n+#include \\\"nsServiceManagerUtils.h\\\"\\n+#include \\\"nsIInterfaceRequestor.h\\\"\\n+#include \\\"nsIWebBrowserChrome.h\\\"\\n \\n // defined in nsChildView.mm\\n extern nsIRollupListener * gRollupListener;\\n extern nsIWidget         * gRollupWidget;\\n \\n+// defined in nsCocoaWindow.mm\\n+extern PRInt32             gXULModalLevel;\\n+\\n+@interface NSApplication (Undocumented)\\n+\\n+// Present in all versions of OS X from (at least) 10.2.8 through 10.5.\\n+- (BOOL)_isRunningModal;\\n+\\n+@end\\n+\\n // AppShellDelegate\\n //\\n-// Cocoa bridge class.  An object of this class is used as an NSPort\\n-// delegate called on the main thread when Gecko wants to interrupt\\n-// the native run loop.\\n+// Cocoa bridge class.  An object of this class is registered to receive\\n+// notifications.\\n //\\n @interface AppShellDelegate : NSObject\\n {\\n   @private\\n     nsAppShell* mAppShell;\\n-    nsresult    mRunRV;\\n }\\n \\n - (id)initWithAppShell:(nsAppShell*)aAppShell;\\n-- (void)handlePortMessage:(NSPortMessage*)aPortMessage;\\n-- (void)runAppShell;\\n-- (nsresult)rvFromRun;\\n - (void)applicationWillTerminate:(NSNotification*)aNotification;\\n - (void)beginMenuTracking:(NSNotification*)aNotification;\\n @end\\n@@ -92,11 +102,14 @@ nsAppShell::ResumeNative(void)\\n \\n nsAppShell::nsAppShell()\\n : mAutoreleasePools(nsnull)\\n-, mPort(nil)\\n-, mDelegate(nil)\\n+, mDelegate(nsnull)\\n+, mCFRunLoop(NULL)\\n+, mCFRunLoopSource(NULL)\\n , mRunningEventLoop(PR_FALSE)\\n+, mStarted(PR_FALSE)\\n , mTerminated(PR_FALSE)\\n , mSkippedNativeCallback(PR_FALSE)\\n+, mHadMoreEventsCount(0)\\n {\\n   // mMainPool sits low on the autorelease pool stack to serve as a catch-all\\n   // for autoreleased objects on this thread.  Because it won't be popped\\n@@ -109,33 +122,38 @@ nsAppShell::nsAppShell()\\n \\n nsAppShell::~nsAppShell()\\n {\\n+  if (mCFRunLoop) {\\n+    if (mCFRunLoopSource) {\\n+      ::CFRunLoopRemoveSource(mCFRunLoop, mCFRunLoopSource,\\n+                              kCFRunLoopCommonModes);\\n+      ::CFRelease(mCFRunLoopSource);\\n+    }\\n+    ::CFRelease(mCFRunLoop);\\n+  }\\n+\\n   if (mAutoreleasePools) {\\n     NS_ASSERTION(::CFArrayGetCount(mAutoreleasePools) == 0,\\n                  \\\"nsAppShell destroyed without popping all autorelease pools\\\");\\n     ::CFRelease(mAutoreleasePools);\\n   }\\n \\n-  if (mPort) {\\n-    [[NSRunLoop currentRunLoop] removePort:mPort forMode:NSDefaultRunLoopMode];\\n-    [mPort release];\\n-  }\\n-\\n   [mDelegate release];\\n   [mMainPool release];\\n }\\n \\n // Init\\n //\\n-// Loads the nib (see bug 316076c21) and sets up the NSPort used to\\n-// interrupt the main Cocoa event loop.\\n+// Loads the nib (see bug 316076c21) and sets up the CFRunLoopSource used to\\n+// interrupt the main native run loop.\\n //\\n // public\\n nsresult\\n nsAppShell::Init()\\n {\\n-  // No event loop is running yet.  Avoid autoreleasing objects to\\n-  // mMainPool.  The appshell retains objects it needs to be long-lived\\n-  // and will release them as appropriate.\\n+  // No event loop is running yet (unless Camino is running, or another\\n+  // embedding app that uses NSApplicationMain()).  Avoid autoreleasing\\n+  // objects to mMainPool.  The appshell retains objects it needs to be\\n+  // long-lived and will release them as appropriate.\\n   NSAutoreleasePool* localPool = [[NSAutoreleasePool alloc] init];\\n \\n   // mAutoreleasePools is used as a stack of NSAutoreleasePool objects created\\n@@ -157,7 +175,12 @@ nsAppShell::Init()\\n   rv = nibFile->GetNativePath(nibPath);\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n-  // This call initializes NSApplication.\\n+  // This call initializes NSApplication unless:\\n+  // 1) we're using xre -- NSApp's already been initialized by\\n+  //    MacApplicationDelegate.mm's EnsureUseCocoaDockAPI().\\n+  // 2) Camino is running (or another embedding app that uses\\n+  //    NSApplicationMain()) -- NSApp's already been initialized and\\n+  //    its main run loop is already running.\\n   [NSBundle loadNibFile:\\n                      [NSString stringWithUTF8String:(const char*)nibPath.get()]\\n       externalNameTable:\\n@@ -165,16 +188,26 @@ nsAppShell::Init()\\n                                        forKey:@\\\"NSOwner\\\"]\\n                withZone:NSDefaultMallocZone()];\\n \\n-  // A message will be sent through mPort to mDelegate on the main thread\\n-  // to interrupt the run loop while it is running.\\n   mDelegate = [[AppShellDelegate alloc] initWithAppShell:this];\\n   NS_ENSURE_STATE(mDelegate);\\n \\n-  mPort = [[NSPort port] retain];\\n-  NS_ENSURE_STATE(mPort);\\n+  // Add a CFRunLoopSource to the main native run loop.  The source is\\n+  // responsible for interrupting the run loop when Gecko events are ready.\\n+\\n+  mCFRunLoop = [[NSRunLoop currentRunLoop] getCFRunLoop];\\n+  NS_ENSURE_STATE(mCFRunLoop);\\n+  ::CFRetain(mCFRunLoop);\\n+\\n+  CFRunLoopSourceContext context;\\n+  bzero(&context, sizeof(context));\\n+  // context.version = 0;\\n+  context.info = this;\\n+  context.perform = ProcessGeckoEvents;\\n+  \\n+  mCFRunLoopSource = ::CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &context);\\n+  NS_ENSURE_STATE(mCFRunLoopSource);\\n \\n-  [mPort setDelegate:mDelegate];\\n-  [[NSRunLoop currentRunLoop] addPort:mPort forMode:NSDefaultRunLoopMode];\\n+  ::CFRunLoopAddSource(mCFRunLoop, mCFRunLoopSource, kCFRunLoopCommonModes);\\n \\n   rv = nsBaseAppShell::Init();\\n \\n@@ -185,25 +218,33 @@ nsAppShell::Init()\\n \\n // ProcessGeckoEvents\\n //\\n-// Arrange for Gecko events to be processed.  They will either be processed\\n-// after the main run loop returns (if we own the run loop) or on\\n-// NativeEventCallback (if an embedder owns the loop).\\n+// The \\\"perform\\\" target of mCFRunLoop, called when mCFRunLoopSource is\\n+// signalled from ScheduleNativeEventCallback.\\n //\\n-// Called by -[AppShellDelegate handlePortMessage:] after mPort signals as a\\n-// result of a ScheduleNativeEventCallback call.  This method is public only\\n-// because it needs to be called by that Objective-C fragment, and C++ can't\\n-// make |friend|s with Objective-C.\\n+// Arrange for Gecko events to be processed on demand (in response to a call\\n+// to ScheduleNativeEventCallback(), if processing of Gecko events via \\\"native\\n+// methods\\\" hasn't been suspended).  This happens in NativeEventCallback() ...\\n+// or rather it's supposed to:  nsBaseAppShell::NativeEventCallback() doesn't\\n+// actually process any Gecko events if elsewhere we're also processing Gecko\\n+// events in a tight loop (as happens in nsBaseAppShell::Run()) -- in that\\n+// case ProcessGeckoEvents() is always called while ProcessNextNativeEvent()\\n+// is running (called from nsBaseAppShell::OnProcessNextEvent()) and\\n+// mProcessingNextNativeEvent is always true (which makes NativeEventCallback()\\n+// take an early out).\\n //\\n-// public\\n+// protected static\\n void\\n-nsAppShell::ProcessGeckoEvents()\\n+nsAppShell::ProcessGeckoEvents(void* aInfo)\\n {\\n-  if (mRunningEventLoop) {\\n-    mRunningEventLoop = PR_FALSE;\\n+  nsAppShell* self = static_cast<nsAppShell*> (aInfo);\\n+\\n+  if (self->mRunningEventLoop) {\\n+    self->mRunningEventLoop = PR_FALSE;\\n \\n-    // The run loop is sleeping.  [NSApp nextEventMatchingMask:...] won't\\n-    // return until it's given a reason to wake up.  Awaken it by posting\\n-    // a bogus event.  There's no need to make the event presentable.\\n+    // The run loop may be sleeping -- [NSRunLoop acceptInputForMode:...]\\n+    // won't return until it's given a reason to wake up.  Awaken it by\\n+    // posting a bogus event.  There's no need to make the event\\n+    // presentable.\\n     [NSApp postEvent:[NSEvent otherEventWithType:NSApplicationDefined\\n                                         location:NSMakePoint(0,0)\\n                                    modifierFlags:0\\n@@ -216,12 +257,14 @@ nsAppShell::ProcessGeckoEvents()\\n              atStart:NO];\\n   }\\n \\n-  if (mSuspendNativeCount <= 0) {\\n-    NativeEventCallback();\\n+  if (self->mSuspendNativeCount <= 0) {\\n+    self->NativeEventCallback();\\n   } else {\\n-    mSkippedNativeCallback = PR_TRUE;\\n+    self->mSkippedNativeCallback = PR_TRUE;\\n   }\\n \\n+  // Still needed to fix bug 343033 (\\\"5-10 second delay or hang or crash\\n+  // when quitting Cocoa Firefox\\\").\\n   [NSApp postEvent:[NSEvent otherEventWithType:NSApplicationDefined\\n                                       location:NSMakePoint(0,0)\\n                                  modifierFlags:0\\n@@ -232,19 +275,41 @@ nsAppShell::ProcessGeckoEvents()\\n                                          data1:0\\n                                          data2:0]\\n            atStart:NO];\\n+\\n+  // Each Release() here is balanced by exactly one AddRef() in\\n+  // ScheduleNativeEventCallback().\\n+  NS_RELEASE(self);\\n }\\n \\n // WillTerminate\\n //\\n // Called by the AppShellDelegate when an NSApplicationWillTerminate\\n // notification is posted.  After this method is called, native events should\\n-// no longer be processed.\\n+// no longer be processed.  The NSApplicationWillTerminate notification is\\n+// only posted when [NSApp terminate:] is called, which doesn't happen on a\\n+// \\\"normal\\\" application quit.\\n //\\n // public\\n void\\n nsAppShell::WillTerminate()\\n {\\n+  if (mTerminated)\\n+    return;\\n   mTerminated = PR_TRUE;\\n+\\n+  // Ugly hack to stop _NSAutoreleaseNoPool errors on shutdown from Camino --\\n+  // these seem to be triggered by our call here to NS_ProcessPendingEvents().\\n+  [[NSAutoreleasePool alloc] init];\\n+\\n+  // Calling [NSApp terminate:] causes (among other things) an\\n+  // NSApplicationWillTerminate notification to be posted and the main run\\n+  // loop to die before returning (in the call to [NSApp run]).  So this is\\n+  // our last crack at processing any remaining Gecko events.\\n+  NS_ProcessPendingEvents(NS_GetCurrentThread());\\n+\\n+  // Unless we call nsBaseAppShell::Exit() here, it might not get called\\n+  // at all.\\n+  nsBaseAppShell::Exit();\\n }\\n \\n // ScheduleNativeEventCallback\\n@@ -253,26 +318,33 @@ nsAppShell::WillTerminate()\\n // needs to be processed.  The Gecko event needs to be processed on the\\n // main thread, so the native run loop must be interrupted.\\n //\\n+// In nsBaseAppShell.cpp, the mNativeEventPending variable is used to\\n+// ensure that ScheduleNativeEventCallback() is called no more than once\\n+// per call to NativeEventCallback().  ProcessGeckoEvents() can skip its\\n+// call to NativeEventCallback() if processing of Gecko events by native\\n+// means is suspended (using nsIAppShell::SuspendNative()), which will\\n+// suspend calls from nsBaseAppShell::OnDispatchedEvent() to\\n+// ScheduleNativeEventCallback().  But when Gecko event processing by\\n+// native means is resumed (in ResumeNative()), an extra call is made to\\n+// ScheduleNativeEventCallback() (from ResumeNative()).  This triggers\\n+// another call to ProcessGeckoEvents(), which calls NativeEventCallback(),\\n+// and nsBaseAppShell::OnDispatchedEvent() resumes calling\\n+// ScheduleNativeEventCallback().\\n+//\\n // protected virtual\\n void\\n nsAppShell::ScheduleNativeEventCallback()\\n {\\n-  NS_ADDREF(this);\\n-\\n-  void* self = static_cast<void*>(this);\\n-  NSData* data = [[NSData alloc] initWithBytes:&self length:sizeof(this)];\\n-  NSArray* components = [[NSArray alloc] initWithObjects:&data count:1];\\n-\\n-  // This will invoke [mDelegate handlePortMessage:message] on the main thread.\\n+  if (mTerminated)\\n+    return;\\n \\n-  NSPortMessage* message = [[NSPortMessage alloc] initWithSendPort:mPort\\n-                                                       receivePort:nil\\n-                                                        components:components];\\n-  [message sendBeforeDate:[NSDate distantFuture]];\\n+  // Each AddRef() here is balanced by exactly one Release() in\\n+  // ProcessGeckoEvents().\\n+  NS_ADDREF_THIS();\\n \\n-  [message release];\\n-  [components release];\\n-  [data release];\\n+  // This will invoke ProcessGeckoEvents on the main thread.\\n+  ::CFRunLoopSourceSignal(mCFRunLoopSource);\\n+  ::CFRunLoopWakeUp(mCFRunLoop);\\n }\\n \\n // ProcessNextNativeEvent\\n@@ -282,14 +354,21 @@ nsAppShell::ScheduleNativeEventCallback()\\n //\\n // Returns true if more events are waiting in the native event queue.\\n //\\n+// But (now that we're using [NSRunLoop acceptInputForMode:beforeDate:]) it's\\n+// too expensive to call ProcessNextNativeEvent() many times in a row (in a\\n+// tight loop), so we never return true more than kHadMoreEventsCountMax\\n+// times in a row.  This doesn't seem to cause native event starvation.\\n+//\\n // protected virtual\\n PRBool\\n nsAppShell::ProcessNextNativeEvent(PRBool aMayWait)\\n {\\n+  PRBool moreEvents = PR_FALSE;\\n   PRBool eventProcessed = PR_FALSE;\\n+  NSString* currentMode = nil;\\n \\n   if (mTerminated)\\n-    return eventProcessed;\\n+    return moreEvents;\\n \\n   PRBool wasRunningEventLoop = mRunningEventLoop;\\n   mRunningEventLoop = aMayWait;\\n@@ -303,56 +382,135 @@ nsAppShell::ProcessNextNativeEvent(PRBool aMayWait)\\n     NS_ASSERTION(mAutoreleasePools && ::CFArrayGetCount(mAutoreleasePools),\\n                  \\\"No autorelease pool for native event\\\");\\n \\n-    if (NSEvent* event = [NSApp nextEventMatchingMask:NSAnyEventMask\\n-                                            untilDate:waitUntil\\n-                                               inMode:NSDefaultRunLoopMode\\n-                                              dequeue:YES]) {\\n-      [NSApp sendEvent:event];\\n-\\n-      // Additional processing that [NSApp run] does after each event.\\n-      NSEventType type = [event type];\\n-      if (type != NSPeriodic && type != NSMouseMoved) {\\n-        [[NSApp servicesMenu] update];\\n-        [[NSApp windowsMenu] update];\\n-        [[NSApp mainMenu] update];\\n+    // If an event is waiting to be processed, run the main event loop\\n+    // just long enough to process it.  For some reason, using [NSApp\\n+    // nextEventMatchingMask:...] to dequeue the event and [NSApp sendEvent:]\\n+    // to \\\"send\\\" it causes trouble, so we no longer do that.  (The trouble\\n+    // was very strange, and only happened while processing Gecko events on\\n+    // demand (via ProcessGeckoEvents()), as opposed to processing Gecko\\n+    // events in a tight loop (via nsBaseAppShell::Run()):  Particularly in\\n+    // Camino, mouse-down events sometimes got dropped (or mis-handled), so\\n+    // that (for example) you sometimes needed to click more than once on a\\n+    // button to make it work (the zoom button was particularly susceptible).\\n+    // You also sometimes had to ctrl-click or right-click multiple times to\\n+    // bring up a context menu.)\\n+\\n+    // Now that we're using [NSRunLoop acceptInputForMode:beforeDate:], it's\\n+    // too expensive to call ProcessNextNativeEvent() many times in a row, so\\n+    // we never return true more than kHadMoreEventsCountMax in a row.  I'm\\n+    // not entirely sure why [NSRunLoop acceptInputForMode:beforeDate:] is too\\n+    // expensive, since it and its cousin [NSRunLoop runMode:beforeDate:] are\\n+    // designed to be called in a tight loop.  Possibly the problem is due to\\n+    // combining [NSRunLoop acceptInputForMode:beforeDate] with [NSApp\\n+    // nextEventMatchingMask:...].\\n+\\n+    // If the current mode is something else than NSDefaultRunLoopMode, look\\n+    // for events in that mode.\\n+    currentMode = [[NSRunLoop currentRunLoop] currentMode];\\n+    if (!currentMode)\\n+      currentMode = NSDefaultRunLoopMode;\\n+\\n+    // If we're running modal (either Cocoa modal or XUL modal) we still need\\n+    // to use nextEventMatchingMask and sendEvent -- otherwise (in Minefield)\\n+    // the modal window won't receive key events or most mouse events.\\n+    if ([NSApp _isRunningModal] || (gXULModalLevel > 0)) {\\n+      if (NSEvent* event = [NSApp nextEventMatchingMask:NSAnyEventMask\\n+                                              untilDate:waitUntil\\n+                                                 inMode:currentMode\\n+                                                dequeue:YES]) {\\n+        [NSApp sendEvent:event];\\n+        eventProcessed = PR_TRUE;\\n+      }\\n+    } else {\\n+      if (aMayWait ||\\n+          [NSApp nextEventMatchingMask:NSAnyEventMask\\n+                             untilDate:nil\\n+                                inMode:currentMode\\n+                               dequeue:NO]) {\\n+        [[NSRunLoop currentRunLoop] acceptInputForMode:currentMode\\n+                                            beforeDate:waitUntil];\\n+        eventProcessed = PR_TRUE;\\n       }\\n-\\n-      [NSApp updateWindows];\\n-\\n-      eventProcessed = PR_TRUE;\\n     }\\n   } while (mRunningEventLoop);\\n \\n+  if (eventProcessed && (mHadMoreEventsCount < kHadMoreEventsCountMax)) {\\n+    moreEvents = ([NSApp nextEventMatchingMask:NSAnyEventMask\\n+                                     untilDate:nil\\n+                                        inMode:currentMode\\n+                                       dequeue:NO] != nil);\\n+  }\\n+\\n+  if (moreEvents) {\\n+    // Once this reaches kHadMoreEventsCountMax, it will be reset to 0 the\\n+    // next time through (whether or not we process any events then).\\n+    ++mHadMoreEventsCount;\\n+  } else {\\n+    mHadMoreEventsCount = 0;\\n+  }\\n+\\n   mRunningEventLoop = wasRunningEventLoop;\\n \\n-  return eventProcessed;\\n+  return moreEvents;\\n }\\n \\n // Run\\n //\\n-// Overrides the base class' Run method to ensure that [NSApp run] has been\\n-// called.  When [NSApp run] has not yet been called, this method calls it\\n-// after arranging for a selector to be called from the run loop.  That\\n-// selector is responsible for calling Run again.  At that point, because\\n-// [NSApp run] has been called, the base class' method is called.\\n+// Overrides the base class's Run() method to call [NSApp run] (which spins\\n+// the native run loop until the application quits).  Since (unlike the base\\n+// class's Run() method) we don't process any Gecko events here, they need\\n+// to be processed elsewhere (in NativeEventCallback(), called from\\n+// ProcessGeckoEvents()).\\n //\\n-// The runAppShell selector will call [NSApp stop:] as soon as the real\\n-// Run method finishes.  The real Run method's return value is saved so\\n-// that it may properly be returned.\\n+// Camino calls [NSApp run] on its own (via NSApplicationMain()), and so\\n+// doesn't call nsAppShell::Run().\\n //\\n // public\\n NS_IMETHODIMP\\n nsAppShell::Run(void)\\n {\\n-  if (![NSApp isRunning]) {\\n-    [mDelegate performSelector:@selector(runAppShell)\\n-                    withObject:nil\\n-                    afterDelay:0];\\n-    [NSApp run];\\n-    return [mDelegate rvFromRun];\\n-  }\\n+  NS_ASSERTION(!mStarted, \\\"nsAppShell::Run() called multiple times\\\");\\n+  if (mStarted)\\n+    return NS_OK;\\n+\\n+  mStarted = PR_TRUE;\\n+  [NSApp run];\\n+\\n+  return NS_OK;\\n+}\\n \\n-  return nsBaseAppShell::Run();\\n+NS_IMETHODIMP\\n+nsAppShell::Exit(void)\\n+{\\n+  // This method is currently called more than once -- from (according to\\n+  // mento) an nsAppExitEvent dispatched by nsAppStartup::Quit() and from an\\n+  // XPCOM shutdown notification that nsBaseAppShell has registered to\\n+  // receive.  So we need to ensure that multiple calls won't break anything.\\n+  // But we should also complain about it (since it isn't quite kosher).\\n+  NS_ASSERTION(!mTerminated, \\\"nsAppShell::Exit() called redundantly\\\");\\n+  if (mTerminated)\\n+    return NS_OK;\\n+\\n+  mTerminated = PR_TRUE;\\n+\\n+  // Quoting from Apple's doc on the [NSApplication stop:] method (from their\\n+  // doc on the NSApplication class):  \\\"If this method is invoked during a\\n+  // modal event loop, it will break that loop but not the main event loop.\\\"\\n+  // nsAppShell::Exit() shouldn't be called from a modal event loop.  So if\\n+  // it is we complain about it (to users of debug builds) and call [NSApp\\n+  // stop:] one extra time.  (I'm not sure if modal event loops can be nested\\n+  // -- Apple's docs don't say one way or the other.  But the return value\\n+  // of [NSApp _isRunningModal] doesn't change immediately after a call to\\n+  // [NSApp stop:], so we have to assume that one extra call to [NSApp stop:]\\n+  // will do the job.)\\n+  BOOL cocoaModal = [NSApp _isRunningModal];\\n+  NS_ASSERTION(!cocoaModal,\\n+               \\\"Don't call nsAppShell::Exit() from a modal event loop!\\\");\\n+  if (cocoaModal)\\n+    [NSApp stop:nsnull];\\n+  [NSApp stop:nsnull];\\n+\\n+  return nsBaseAppShell::Exit();\\n }\\n \\n // OnProcessNextEvent\\n@@ -413,7 +571,6 @@ nsAppShell::AfterProcessNextEvent(nsIThreadInternal *aThread,\\n {\\n   if ((self = [self init])) {\\n     mAppShell = aAppShell;\\n-    mRunRV = NS_ERROR_NOT_INITIALIZED;\\n \\n     [[NSNotificationCenter defaultCenter] addObserver:self\\n                                              selector:@selector(applicationWillTerminate:)\\n@@ -435,40 +592,6 @@ nsAppShell::AfterProcessNextEvent(nsIThreadInternal *aThread,\\n   [super dealloc];\\n }\\n \\n-// handlePortMessage:\\n-//\\n-// The selector called on the delegate object when nsAppShell::mPort is sent an\\n-// NSPortMessage by ScheduleNativeEventCallback.  Call into the nsAppShell\\n-// object for access to mRunningEventLoop and NativeEventCallback.\\n-//\\n-- (void)handlePortMessage:(NSPortMessage*)aPortMessage\\n-{\\n-  NSData* data = [[aPortMessage components] objectAtIndex:0];\\n-  nsAppShell* appShell = *static_cast<nsAppShell* const*>([data bytes]);\\n-  appShell->ProcessGeckoEvents();\\n-\\n-  NS_RELEASE(appShell);\\n-}\\n-\\n-// runAppShell\\n-//\\n-// Runs the nsAppShell, and immediately stops the Cocoa run loop when\\n-// nsAppShell::Run is done, saving its return value.\\n-- (void)runAppShell\\n-{\\n-  mRunRV = mAppShell->Run();\\n-  [NSApp stop:self];\\n-  return;\\n-}\\n-\\n-// rvFromRun\\n-//\\n-// Returns the nsresult return value saved by runAppShell.\\n-- (nsresult)rvFromRun\\n-{\\n-  return mRunRV;\\n-}\\n-\\n // applicationWillTerminate:\\n //\\n // Notify the nsAppShell that native event processing should be discontinued.\\n@@ -492,3 +615,4 @@ nsAppShell::AfterProcessNextEvent(nsIThreadInternal *aThread,\\n }\\n \\n @end\\n+\\ndiff --git a/widget/src/cocoa/nsCocoaWindow.h b/widget/src/cocoa/nsCocoaWindow.h\\nindex 64c6843..8135011 100644\\n--- a/widget/src/cocoa/nsCocoaWindow.h\\n+++ b/widget/src/cocoa/nsCocoaWindow.h\\n@@ -152,7 +152,7 @@ public:\\n     NS_IMETHOD              AddMenuListener(nsIMenuListener * aListener);\\n     NS_IMETHOD              Enable(PRBool aState);\\n     NS_IMETHOD              IsEnabled(PRBool *aState);\\n-    NS_IMETHOD              SetModal(PRBool aState) { return NS_OK; }\\n+    NS_IMETHOD              SetModal(PRBool aState);\\n     NS_IMETHOD              IsVisible(PRBool & aState);\\n     NS_IMETHOD              SetFocus(PRBool aState=PR_FALSE);\\n     NS_IMETHOD              SetMenuBar(nsIMenuBar * aMenuBar);\\n@@ -217,6 +217,7 @@ protected:\\n   PRPackedBool         mWindowMadeHere; // true if we created the window, false for embedding\\n   PRPackedBool         mVisible;        // Whether or not we're visible.\\n   PRPackedBool         mSheetNeedsShow; // if this is a sheet, are we waiting to be shown?\\n+  PRPackedBool         mModal;\\n };\\n \\n \\ndiff --git a/widget/src/cocoa/nsCocoaWindow.mm b/widget/src/cocoa/nsCocoaWindow.mm\\nindex 131b817..b0f2fb7 100644\\n--- a/widget/src/cocoa/nsCocoaWindow.mm\\n+++ b/widget/src/cocoa/nsCocoaWindow.mm\\n@@ -52,6 +52,8 @@\\n #include \\\"nsIPrefService.h\\\"\\n #include \\\"nsIPrefBranch.h\\\"\\n \\n+PRInt32 gXULModalLevel = 0;\\n+\\n // defined in nsMenuBarX.mm\\n extern NSMenu* sApplicationMenu; // Application menu shared by all menubars\\n \\n@@ -89,6 +91,7 @@ nsCocoaWindow::nsCocoaWindow()\\n , mWindowMadeHere(PR_FALSE)\\n , mVisible(PR_FALSE)\\n , mSheetNeedsShow(PR_FALSE)\\n+, mModal(PR_FALSE)\\n {\\n \\n }\\n@@ -111,6 +114,13 @@ nsCocoaWindow::~nsCocoaWindow()\\n   }\\n \\n   NS_IF_RELEASE(mPopupContentView);\\n+\\n+  // Deal with the possiblity that we're being destroyed while running modal.\\n+  NS_ASSERTION(!mModal, \\\"Widget destroyed while running modal!\\\");\\n+  if (mModal) {\\n+    --gXULModalLevel;\\n+    NS_ASSERTION(gXULModalLevel >= 0, \\\"Wierdness setting modality!\\\");\\n+  }\\n }\\n \\n \\n@@ -425,6 +435,19 @@ NS_IMETHODIMP nsCocoaWindow::IsVisible(PRBool & aState)\\n }\\n \\n \\n+NS_IMETHODIMP nsCocoaWindow::SetModal(PRBool aState)\\n+{\\n+  mModal = aState;\\n+  if (aState) {\\n+    ++gXULModalLevel;\\n+  } else {\\n+    --gXULModalLevel;\\n+    NS_ASSERTION(gXULModalLevel >= 0, \\\"Mismatched call to nsCocoaWindow::SetModal(PR_FALSE)!\\\");\\n+  }\\n+  return NS_OK;\\n+}\\n+\\n+\\n // Hide or show this window\\n NS_IMETHODIMP nsCocoaWindow::Show(PRBool bState)\\n {\\ndiff --git a/widget/src/cocoa/nsWindowMap.mm b/widget/src/cocoa/nsWindowMap.mm\\nindex e5e55eb..4337eb1 100644\\n--- a/widget/src/cocoa/nsWindowMap.mm\\n+++ b/widget/src/cocoa/nsWindowMap.mm\\n@@ -217,11 +217,18 @@\\n \\n - (void)windowWillClose:(NSNotification*)inNotification\\n {\\n+  // We can get _NSAutoreleaseNoPool errors on shutdown here (from Camino)\\n+  // unless we use a local pool -- possibly triggered by a call we're now\\n+  // making to NS_ProcessPendingEvents() from nsAppShell::WillTerminate().\\n+  NSAutoreleasePool* localPool = [[NSAutoreleasePool alloc] init];\\n+\\n   // postpone our destruction\\n   [[self retain] autorelease];\\n \\n   // remove ourselves from the window map (which owns us)\\n   [[WindowDataMap sharedWindowDataMap] removeDataForWindow:[inNotification object]];\\n+\\n+  [localPool release];\\n }\\n \\n @end\\n\""}