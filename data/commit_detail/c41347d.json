{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basc41347d\""},"diff":"\"c41347d Bug 394709: fixing memory leak with watch handlers. r+a=brendan\\ndiff --git a/js/src/jsdbgapi.c b/js/src/jsdbgapi.c\\nindex d473030..d29c3b7 100644\\n--- a/js/src/jsdbgapi.c\\n+++ b/js/src/jsdbgapi.c\\n@@ -386,7 +386,6 @@ DropWatchPointAndUnlock(JSContext *cx, JSWatchPoint *wp, uintN flag)\\n         }\\n     }\\n \\n-    js_RemoveRoot(cx->runtime, &wp->closure);\\n     JS_free(cx, wp);\\n     return ok;\\n }\\n@@ -397,7 +396,7 @@ DropWatchPointAndUnlock(JSContext *cx, JSWatchPoint *wp, uintN flag)\\n  * respect the request model).\\n  */\\n void\\n-js_TraceWatchPoints(JSTracer *trc)\\n+js_TraceWatchPoints(JSTracer *trc, JSObject *obj)\\n {\\n     JSRuntime *rt;\\n     JSWatchPoint *wp;\\n@@ -407,12 +406,46 @@ js_TraceWatchPoints(JSTracer *trc)\\n     for (wp = (JSWatchPoint *)rt->watchPointList.next;\\n          wp != (JSWatchPoint *)&rt->watchPointList;\\n          wp = (JSWatchPoint *)wp->links.next) {\\n-        TRACE_SCOPE_PROPERTY(trc, wp->sprop);\\n-        if ((wp->sprop->attrs & JSPROP_SETTER) && wp->setter)\\n-            JS_CALL_OBJECT_TRACER(trc, (JSObject *)wp->setter, \\\"wp->setter\\\");\\n+        if (wp->object == obj) {\\n+            TRACE_SCOPE_PROPERTY(trc, wp->sprop);\\n+            if ((wp->sprop->attrs & JSPROP_SETTER) && wp->setter) {\\n+                JS_CALL_OBJECT_TRACER(trc, (JSObject *)wp->setter,\\n+                                      \\\"wp->setter\\\");\\n+            }\\n+            JS_SET_TRACING_NAME(trc, \\\"wp->closure\\\");\\n+            js_CallValueTracerIfGCThing(trc, (jsval) wp->closure);\\n+        }\\n+    }\\n+}\\n+\\n+void\\n+js_SweepWatchPoints(JSContext *cx)\\n+{\\n+    JSRuntime *rt;\\n+    JSWatchPoint *wp, *next;\\n+    uint32 sample;\\n+\\n+    rt = cx->runtime;\\n+    DBG_LOCK(rt);\\n+    for (wp = (JSWatchPoint *)rt->watchPointList.next;\\n+         wp != (JSWatchPoint *)&rt->watchPointList;\\n+         wp = next) {\\n+        next = (JSWatchPoint *)wp->links.next;\\n+        if (js_IsAboutToBeFinalized(cx, wp->object)) {\\n+            sample = rt->debuggerMutations;\\n+\\n+            /* Ignore failures. */\\n+            DropWatchPointAndUnlock(cx, wp, JSWP_LIVE);\\n+            DBG_LOCK(rt);\\n+            if (rt->debuggerMutations != sample + 1)\\n+                next = (JSWatchPoint *)rt->watchPointList.next;\\n+        }\\n     }\\n+    DBG_UNLOCK(rt);\\n }\\n \\n+\\n+\\n /*\\n  * NB: FindWatchPoint must be called with rt->debuggerLock acquired.\\n  */\\n@@ -734,11 +767,6 @@ JS_SetWatchPoint(JSContext *cx, JSObject *obj, jsval id,\\n         }\\n         wp->handler = NULL;\\n         wp->closure = NULL;\\n-        ok = js_AddRoot(cx, &wp->closure, \\\"wp->closure\\\");\\n-        if (!ok) {\\n-            JS_free(cx, wp);\\n-            goto out;\\n-        }\\n         wp->object = obj;\\n         JS_ASSERT(sprop->setter != js_watch_set || pobj != obj);\\n         wp->setter = sprop->setter;\\ndiff --git a/js/src/jsdbgapi.h b/js/src/jsdbgapi.h\\nindex 1fbd6a1..4b904f2 100644\\n--- a/js/src/jsdbgapi.h\\n+++ b/js/src/jsdbgapi.h\\n@@ -99,7 +99,10 @@ JS_ClearAllWatchPoints(JSContext *cx);\\n  * header file \\\"jsconfig.h\\\" has been included.\\n  */\\n extern void\\n-js_TraceWatchPoints(JSTracer *trc);\\n+js_TraceWatchPoints(JSTracer *trc, JSObject *obj);\\n+\\n+extern void\\n+js_SweepWatchPoints(JSContext *cx);\\n \\n extern JSScopeProperty *\\n js_FindWatchPoint(JSRuntime *rt, JSScope *scope, jsid id);\\ndiff --git a/js/src/jsgc.c b/js/src/jsgc.c\\nindex de2c9c4..67a5bea 100644\\n--- a/js/src/jsgc.c\\n+++ b/js/src/jsgc.c\\n@@ -2088,7 +2088,6 @@ js_TraceRuntime(JSTracer *trc, JSBool allAtoms)\\n     if (rt->gcLocksHash)\\n         JS_DHashTableEnumerate(rt->gcLocksHash, gc_lock_traversal, trc);\\n     js_TraceAtomState(trc, allAtoms);\\n-    js_TraceWatchPoints(trc);\\n     js_TraceNativeIteratorStates(trc);\\n \\n     iter = NULL;\\n@@ -2339,17 +2338,6 @@ restart:\\n \\n     rt->gcMarkingTracer = NULL;\\n \\n-    /* Finalize iterator states before the objects they iterate over. */\\n-    CloseNativeIterators(cx);\\n-\\n-#ifdef DUMP_CALL_TABLE\\n-    /*\\n-     * Call js_DumpCallTable here so it can meter and then clear weak refs to\\n-     * GC-things that are about to be finalized.\\n-     */\\n-    js_DumpCallTable(cx);\\n-#endif\\n-\\n     /*\\n      * Sweep phase.\\n      *\\n@@ -2366,6 +2354,20 @@ restart:\\n      */\\n     js_SweepAtomState(cx);\\n \\n+    /* Finalize iterator states before the objects they iterate over. */\\n+    CloseNativeIterators(cx);\\n+\\n+    /* Finalize watch points associated with unreachable objects. */\\n+    js_SweepWatchPoints(cx);\\n+\\n+#ifdef DUMP_CALL_TABLE\\n+    /*\\n+     * Call js_DumpCallTable here so it can meter and then clear weak refs to\\n+     * GC-things that are about to be finalized.\\n+     */\\n+    js_DumpCallTable(cx);\\n+#endif\\n+\\n     /*\\n      * Here we need to ensure that JSObject instances are finalized before GC-\\n      * allocated JSString and jsdouble instances so object's finalizer can\\ndiff --git a/js/src/jsobj.c b/js/src/jsobj.c\\nindex d6f2d4c..6053337 100644\\n--- a/js/src/jsobj.c\\n+++ b/js/src/jsobj.c\\n@@ -2791,9 +2791,6 @@ js_FinalizeObject(JSContext *cx, JSObject *obj)\\n                                    cx->debugHooks->objectHookData);\\n     }\\n \\n-    /* Remove all watchpoints with weak links to obj. */\\n-    JS_ClearWatchPointsForObject(cx, obj);\\n-\\n     /* Finalize obj first, in case it needs map and slots. */\\n     GC_AWARE_GET_CLASS(cx, obj)->finalize(cx, obj);\\n \\n@@ -4848,6 +4845,9 @@ js_TraceObject(JSTracer *trc, JSObject *obj)\\n         TRACE_SCOPE_PROPERTY(trc, sprop);\\n     }\\n \\n+    if (!JS_CLIST_IS_EMPTY(&cx->runtime->watchPointList))\\n+        js_TraceWatchPoints(trc, obj);\\n+\\n     /* No one runs while the GC is running, so we can use LOCKED_... here. */\\n     clasp = LOCKED_OBJ_GET_CLASS(obj);\\n     if (clasp->mark) {\\n\""}