{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas7980966\""},"diff":"\"7980966 Bug 339501, r=bz, sr=sicking, a=1.9+\\ndiff --git a/content/html/content/src/nsHTMLOptGroupElement.cpp b/content/html/content/src/nsHTMLOptGroupElement.cpp\\nindex 2fc65ec..dd4ec6c 100644\\n--- a/content/html/content/src/nsHTMLOptGroupElement.cpp\\n+++ b/content/html/content/src/nsHTMLOptGroupElement.cpp\\n@@ -48,6 +48,7 @@\\n #include \\\"nsISelectElement.h\\\"\\n #include \\\"nsIDOMHTMLSelectElement.h\\\"\\n #include \\\"nsEventDispatcher.h\\\"\\n+#include \\\"nsHTMLSelectElement.h\\\"\\n \\n /**\\n  * The implementation of &lt;optgroup&gt;\\n@@ -174,23 +175,23 @@ nsHTMLOptGroupElement::InsertChildAt(nsIContent* aKid,\\n                                      PRUint32 aIndex,\\n                                      PRBool aNotify)\\n {\\n-  nsCOMPtr<nsISelectElement> sel = do_QueryInterface(GetSelect());\\n-  if (sel) {\\n-    sel->WillAddOptions(aKid, this, aIndex);\\n+  nsSafeOptionListMutation safeMutation(GetSelect(), this, aKid, aIndex);\\n+  nsresult rv = nsGenericHTMLElement::InsertChildAt(aKid, aIndex, aNotify);\\n+  if (NS_FAILED(rv)) {\\n+    safeMutation.MutationFailed();\\n   }\\n-\\n-  return nsGenericHTMLElement::InsertChildAt(aKid, aIndex, aNotify);\\n+  return rv;\\n }\\n \\n nsresult\\n nsHTMLOptGroupElement::RemoveChildAt(PRUint32 aIndex, PRBool aNotify)\\n {\\n-  nsCOMPtr<nsISelectElement> sel = do_QueryInterface(GetSelect());\\n-  if (sel) {\\n-    sel->WillRemoveOptions(this, aIndex);\\n+  nsSafeOptionListMutation safeMutation(GetSelect(), this, nsnull, aIndex);\\n+  nsresult rv = nsGenericHTMLElement::RemoveChildAt(aIndex, aNotify);\\n+  if (NS_FAILED(rv)) {\\n+    safeMutation.MutationFailed();\\n   }\\n-\\n-  return nsGenericHTMLElement::RemoveChildAt(aIndex, aNotify);\\n+  return rv;\\n }\\n \\n PRInt32\\ndiff --git a/content/html/content/src/nsHTMLSelectElement.cpp b/content/html/content/src/nsHTMLSelectElement.cpp\\nindex 5c56f1f..1645757 100644\\n--- a/content/html/content/src/nsHTMLSelectElement.cpp\\n+++ b/content/html/content/src/nsHTMLSelectElement.cpp\\n@@ -36,15 +36,10 @@\\n  * the terms of any one of the MPL, the GPL or the LGPL.\\n  *\\n  * ***** END LICENSE BLOCK ***** */\\n-#include \\\"nsCOMPtr.h\\\"\\n-#include \\\"nsCOMArray.h\\\"\\n-#include \\\"nsIDOMHTMLSelectElement.h\\\"\\n-#include \\\"nsIDOMNSHTMLSelectElement.h\\\"\\n-#include \\\"nsIDOMNSXBLFormControl.h\\\"\\n-#include \\\"nsIDOMHTMLFormElement.h\\\"\\n+\\n+#include \\\"nsHTMLSelectElement.h\\\"\\n #include \\\"nsIDOMEventTarget.h\\\"\\n #include \\\"nsContentCreatorFunctions.h\\\"\\n-#include \\\"nsGenericHTMLElement.h\\\"\\n #include \\\"nsGkAtoms.h\\\"\\n #include \\\"nsStyleConsts.h\\\"\\n #include \\\"nsPresContext.h\\\"\\n@@ -52,28 +47,16 @@\\n #include \\\"nsMappedAttributes.h\\\"\\n #include \\\"nsIForm.h\\\"\\n #include \\\"nsIFormSubmission.h\\\"\\n-#include \\\"nsIDOMHTMLCollection.h\\\"\\n-#include \\\"nsIDOMHTMLOptionElement.h\\\"\\n+\\n #include \\\"nsIDOMHTMLOptGroupElement.h\\\"\\n #include \\\"nsIOptionElement.h\\\"\\n #include \\\"nsIEventStateManager.h\\\"\\n-#include \\\"nsISelectElement.h\\\"\\n-#include \\\"nsISelectControlFrame.h\\\"\\n-#include \\\"nsIDOMHTMLOptionsCollection.h\\\"\\n-#include \\\"nsIDOMNSHTMLOptionCollectn.h\\\"\\n #include \\\"nsGUIEvent.h\\\"\\n #include \\\"nsIPrivateDOMEvent.h\\\"\\n #include \\\"nsIBoxObject.h\\\"\\n #include \\\"nsIDOMNSDocument.h\\\"\\n #include \\\"nsIDOMDocumentEvent.h\\\"\\n \\n-// PresState\\n-#include \\\"nsXPCOM.h\\\"\\n-#include \\\"nsPresState.h\\\"\\n-#include \\\"nsIComponentManager.h\\\"\\n-#include \\\"nsCheapSets.h\\\"\\n-#include \\\"nsLayoutErrors.h\\\"\\n-\\n // Notify/query select frame for selectedIndex\\n #include \\\"nsIDocument.h\\\"\\n #include \\\"nsIPresShell.h\\\"\\n@@ -86,405 +69,58 @@\\n #include \\\"nsRuleData.h\\\"\\n #include \\\"nsEventDispatcher.h\\\"\\n \\n-class nsHTMLSelectElement;\\n-\\n-/**\\n- * The collection of options in the select (what you get back when you do\\n- * select.options in DOM)\\n- */\\n-class nsHTMLOptionCollection: public nsIDOMHTMLOptionsCollection,\\n-                              public nsIDOMNSHTMLOptionCollection,\\n-                              public nsIDOMHTMLCollection\\n-{\\n-public:\\n-  nsHTMLOptionCollection(nsHTMLSelectElement* aSelect);\\n-  virtual ~nsHTMLOptionCollection();\\n-\\n-  NS_DECL_CYCLE_COLLECTING_ISUPPORTS\\n-\\n-  // nsIDOMHTMLOptionsCollection interface\\n-  NS_DECL_NSIDOMHTMLOPTIONSCOLLECTION\\n-\\n-  // nsIDOMNSHTMLOptionCollection interface\\n-  NS_DECL_NSIDOMNSHTMLOPTIONCOLLECTION\\n-\\n-  // nsIDOMHTMLCollection interface, all its methods are defined in\\n-  // nsIDOMHTMLOptionsCollection\\n-\\n-  NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsHTMLOptionCollection,\\n-                                           nsIDOMNSHTMLOptionCollection)\\n-\\n-  // Helpers for nsHTMLSelectElement\\n-  /**\\n-   * Insert an option\\n-   * @param aOption the option to insert\\n-   * @param aIndex the index to insert at\\n-   */\\n-  PRBool InsertOptionAt(nsIDOMHTMLOptionElement* aOption, PRInt32 aIndex)\\n-  {\\n-    return mElements.InsertObjectAt(aOption, aIndex);\\n-  }\\n-\\n-  /**\\n-   * Remove an option\\n-   * @param aIndex the index of the option to remove\\n-   */\\n-  void RemoveOptionAt(PRInt32 aIndex)\\n-  {\\n-    mElements.RemoveObjectAt(aIndex);\\n-  }\\n-\\n-  /**\\n-   * Get the option at the index\\n-   * @param aIndex the index\\n-   * @param aReturn the option returned [OUT]\\n-   */\\n-  nsIDOMHTMLOptionElement *ItemAsOption(PRInt32 aIndex)\\n-  {\\n-    return mElements.SafeObjectAt(aIndex);\\n-  }\\n-\\n-  /**\\n-   * Clears out all options\\n-   */\\n-  void Clear()\\n-  {\\n-    mElements.Clear();\\n-  }\\n-\\n-  /**\\n-   * Append an option to end of array\\n-   */\\n-  PRBool AppendOption(nsIDOMHTMLOptionElement* aOption)\\n-  {\\n-    return mElements.AppendObject(aOption);\\n-  }\\n-\\n-  /**\\n-   * Drop the reference to the select.  Called during select destruction.\\n-   */\\n-  void DropReference();\\n-\\n-  /**\\n-   * See nsISelectElement.idl for documentation on this method\\n-   */\\n-  nsresult GetOptionIndex(nsIDOMHTMLOptionElement* aOption,\\n-                          PRInt32 aStartIndex, PRBool aForward,\\n-                          PRInt32* aIndex);\\n-\\n-private:\\n-  /** The list of options (holds strong references) */\\n-  nsCOMArray<nsIDOMHTMLOptionElement> mElements;\\n-  /** The select element that contains this array */\\n-  nsHTMLSelectElement* mSelect;\\n-};\\n-\\n-\\n-/**\\n- * The restore state used by select\\n- */\\n-class nsSelectState : public nsISupports {\\n-public:\\n-  nsSelectState()\\n-  {\\n-  }\\n-  virtual ~nsSelectState()\\n-  {\\n-  }\\n+NS_IMPL_ISUPPORTS0(nsSelectState)\\n \\n-  NS_DECL_ISUPPORTS\\n+//----------------------------------------------------------------------\\n+//\\n+// nsSafeOptionListMutation\\n+//\\n \\n-  void PutOption(PRInt32 aIndex, const nsAString& aValue)\\n-  {\\n-    // If the option is empty, store the index.  If not, store the value.\\n-    if (aValue.IsEmpty()) {\\n-      mIndices.Put(aIndex);\\n+nsSafeOptionListMutation::nsSafeOptionListMutation(nsIContent* aSelect,\\n+                                                   nsIContent* aParent,\\n+                                                   nsIContent* aKid,\\n+                                                   PRUint32 aIndex)\\n+  : mSelect(do_QueryInterface(aSelect)), mTopLevelMutation(PR_FALSE),\\n+    mNeedsRebuild(PR_FALSE)\\n+{\\n+  nsHTMLSelectElement* select = static_cast<nsHTMLSelectElement*>(mSelect.get());\\n+  if (select) {\\n+    mTopLevelMutation = !select->mMutating;\\n+    if (mTopLevelMutation) {\\n+      select->mMutating = PR_TRUE;\\n     } else {\\n-      mValues.Put(aValue);\\n+      // This is very unfortunate, but to handle mutation events properly,\\n+      // option list must be up-to-date before inserting or removing options.\\n+      // Fortunately this is called only if mutation event listener\\n+      // adds or removes options.\\n+      select->RebuildOptionsArray();\\n     }\\n+    nsresult rv;\\n+    if (aKid) {\\n+      rv = mSelect->WillAddOptions(aKid, aParent, aIndex);\\n+    } else {\\n+      rv = mSelect->WillRemoveOptions(aParent, aIndex);\\n+    }\\n+    mNeedsRebuild = NS_FAILED(rv);\\n   }\\n+}\\n \\n-  PRBool ContainsOption(PRInt32 aIndex, const nsAString& aValue)\\n-  {\\n-    return mValues.Contains(aValue) || mIndices.Contains(aIndex);\\n-  }\\n-\\n-private:\\n-  nsCheapStringSet mValues;\\n-  nsCheapInt32Set mIndices;\\n-};\\n-\\n-NS_IMPL_ISUPPORTS0(nsSelectState)\\n-\\n-\\n-/**\\n- * Implementation of &lt;select&gt;\\n- */\\n-class nsHTMLSelectElement : public nsGenericHTMLFormElement,\\n-                            public nsIDOMHTMLSelectElement,\\n-                            public nsIDOMNSHTMLSelectElement,\\n-                            public nsIDOMNSXBLFormControl,\\n-                            public nsISelectElement\\n+nsSafeOptionListMutation::~nsSafeOptionListMutation()\\n {\\n-public:\\n-  nsHTMLSelectElement(nsINodeInfo *aNodeInfo, PRBool aFromParser = PR_FALSE);\\n-  virtual ~nsHTMLSelectElement();\\n-\\n-  // nsISupports\\n-  NS_DECL_ISUPPORTS_INHERITED\\n-\\n-  // nsIDOMNode\\n-  NS_FORWARD_NSIDOMNODE(nsGenericHTMLFormElement::)\\n-\\n-  // nsIDOMElement\\n-  NS_FORWARD_NSIDOMELEMENT(nsGenericHTMLFormElement::)\\n-\\n-  // nsIDOMHTMLElement\\n-  NS_FORWARD_NSIDOMHTMLELEMENT(nsGenericHTMLFormElement::)\\n-\\n-  // nsIDOMHTMLSelectElement\\n-  NS_DECL_NSIDOMHTMLSELECTELEMENT\\n-\\n-  // nsIDOMNSHTMLSelectElement\\n-  NS_DECL_NSIDOMNSHTMLSELECTELEMENT\\n-\\n-  // nsIDOMNSXBLFormControl\\n-  NS_DECL_NSIDOMNSXBLFORMCONTROL\\n-\\n-  // nsIContent\\n-  virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);\\n-\\n-  virtual void SetFocus(nsPresContext* aPresContext);\\n-  virtual PRBool IsFocusable(PRInt32 *aTabIndex = nsnull);\\n-  virtual nsresult InsertChildAt(nsIContent* aKid, PRUint32 aIndex,\\n-                                 PRBool aNotify);\\n-  virtual nsresult RemoveChildAt(PRUint32 aIndex, PRBool aNotify);\\n-\\n-  // Overriden nsIFormControl methods\\n-  NS_IMETHOD_(PRInt32) GetType() const { return NS_FORM_SELECT; }\\n-  NS_IMETHOD Reset();\\n-  NS_IMETHOD SubmitNamesValues(nsIFormSubmission* aFormSubmission,\\n-                               nsIContent* aSubmitElement);\\n-  NS_IMETHOD SaveState();\\n-  virtual PRBool RestoreState(nsPresState* aState);\\n-\\n-  // nsISelectElement\\n-  NS_DECL_NSISELECTELEMENT\\n-\\n-  /**\\n-   * Called when an attribute is about to be changed\\n-   */\\n-  virtual nsresult BeforeSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,\\n-                                 const nsAString* aValue, PRBool aNotify);\\n-  virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,\\n-                             PRBool aNotify);\\n-  \\n-  virtual nsresult DoneAddingChildren(PRBool aHaveNotified);\\n-  virtual PRBool IsDoneAddingChildren();\\n-\\n-  virtual PRBool ParseAttribute(PRInt32 aNamespaceID,\\n-                                nsIAtom* aAttribute,\\n-                                const nsAString& aValue,\\n-                                nsAttrValue& aResult);\\n-  virtual nsMapRuleToAttributesFunc GetAttributeMappingFunction() const;\\n-  virtual nsChangeHint GetAttributeChangeHint(const nsIAtom* aAttribute,\\n-                                              PRInt32 aModType) const;\\n-  NS_IMETHOD_(PRBool) IsAttributeMapped(const nsIAtom* aAttribute) const;\\n-\\n-  virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;\\n-\\n-  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_NO_UNLINK(nsHTMLSelectElement,\\n-                                                     nsGenericHTMLFormElement)\\n-\\n-protected:\\n-  // Helper Methods\\n-  /**\\n-   * Check whether the option specified by the index is selected\\n-   * @param aIndex the index\\n-   * @return whether the option at the index is selected\\n-   */\\n-  PRBool IsOptionSelectedByIndex(PRInt32 aIndex);\\n-  /**\\n-   * Starting with (and including) aStartIndex, find the first selected index\\n-   * and set mSelectedIndex to it.\\n-   * @param aStartIndex the index to start with\\n-   */\\n-  void FindSelectedIndex(PRInt32 aStartIndex);\\n-  /**\\n-   * Select some option if possible (generally the first non-disabled option).\\n-   * @return true if something was selected, false otherwise\\n-   */\\n-  PRBool SelectSomething();\\n-  /**\\n-   * Call SelectSomething(), but only if nothing is selected\\n-   * @see SelectSomething()\\n-   * @return true if something was selected, false otherwise\\n-   */\\n-  PRBool CheckSelectSomething();\\n-  /**\\n-   * Called to trigger notifications of frames and fixing selected index\\n-   *\\n-   * @param aSelectFrame the frame for this content (could be null)\\n-   * @param aPresContext the current pres context\\n-   * @param aIndex the index that was selected or deselected\\n-   * @param aSelected whether the index was selected or deselected\\n-   * @param aNotify whether to notify the style system and such\\n-   */\\n-  void OnOptionSelected(nsISelectControlFrame* aSelectFrame,\\n-                        nsPresContext* aPresContext,\\n-                        PRInt32 aIndex,\\n-                        PRBool aSelected,\\n-                        PRBool aNotify);\\n-  /**\\n-   * Restore state to a particular state string (representing the options)\\n-   * @param aNewSelected the state string to restore to\\n-   */\\n-  void RestoreStateTo(nsSelectState* aNewSelected);\\n-\\n-#ifdef DEBUG_john\\n-  // Don't remove these, por favor.  They're very useful in debugging\\n-  nsresult PrintOptions(nsIContent* aOptions, PRInt32 tabs);\\n-#endif\\n-\\n-  // Adding options\\n-  /**\\n-   * Insert option(s) into the options[] array and perform notifications\\n-   * @param aOptions the option or optgroup being added\\n-   * @param aListIndex the index to start adding options into the list at\\n-   * @param aDepth the depth of aOptions (1=direct child of select ...)\\n-   */\\n-  nsresult InsertOptionsIntoList(nsIContent* aOptions,\\n-                                 PRInt32 aListIndex,\\n-                                 PRInt32 aDepth);\\n-  /**\\n-   * Remove option(s) from the options[] array\\n-   * @param aOptions the option or optgroup being added\\n-   * @param aListIndex the index to start removing options from the list at\\n-   * @param aDepth the depth of aOptions (1=direct child of select ...)\\n-   */\\n-  nsresult RemoveOptionsFromList(nsIContent* aOptions,\\n-                                 PRInt32 aListIndex,\\n-                                 PRInt32 aDepth);\\n-  /**\\n-   * Insert option(s) into the options[] array (called by InsertOptionsIntoList)\\n-   * @param aOptions the option or optgroup being added\\n-   * @param aInsertIndex the index to start adding options into the list at\\n-   * @param aDepth the depth of aOptions (1=direct child of select ...)\\n-   */\\n-  nsresult InsertOptionsIntoListRecurse(nsIContent* aOptions,\\n-                                        PRInt32* aInsertIndex,\\n-                                        PRInt32 aDepth);\\n-  /**\\n-   * Remove option(s) from the options[] array (called by RemoveOptionsFromList)\\n-   * @param aOptions the option or optgroup being added\\n-   * @param aListIndex the index to start removing options from the list at\\n-   * @param aNumRemoved the number removed so far [OUT]\\n-   * @param aDepth the depth of aOptions (1=direct child of select ...)\\n-   */\\n-  nsresult RemoveOptionsFromListRecurse(nsIContent* aOptions,\\n-                                        PRInt32 aRemoveIndex,\\n-                                        PRInt32* aNumRemoved,\\n-                                        PRInt32 aDepth);\\n-  /**\\n-   * Find out how deep this content is from the select (1=direct child)\\n-   * @param aContent the content to check\\n-   * @return the depth\\n-   */\\n-  PRInt32 GetContentDepth(nsIContent* aContent);\\n-  /**\\n-   * Get the index of the first option at, under or following the content in\\n-   * the select, or length of options[] if none are found\\n-   * @param aOptions the content\\n-   * @return the index of the first option\\n-   */\\n-  PRInt32 GetOptionIndexAt(nsIContent* aOptions);\\n-  /**\\n-   * Get the next option following the content in question (not at or under)\\n-   * (this could include siblings of the current content or siblings of the\\n-   * parent or children of siblings of the parent).\\n-   * @param aOptions the content\\n-   * @return the index of the next option after the content\\n-   */\\n-  PRInt32 GetOptionIndexAfter(nsIContent* aOptions);\\n-  /**\\n-   * Get the first option index at or under the content in question.\\n-   * @param aOptions the content\\n-   * @return the index of the first option at or under the content\\n-   */\\n-  PRInt32 GetFirstOptionIndex(nsIContent* aOptions);\\n-  /**\\n-   * Get the first option index under the content in question, within the\\n-   * range specified.\\n-   * @param aOptions the content\\n-   * @param aStartIndex the first child to look at\\n-   * @param aEndIndex the child *after* the last child to look at\\n-   * @return the index of the first option at or under the content\\n-   */\\n-  PRInt32 GetFirstChildOptionIndex(nsIContent* aOptions,\\n-                                   PRInt32 aStartIndex,\\n-                                   PRInt32 aEndIndex);\\n-\\n-  /**\\n-   * Get the frame as an nsISelectControlFrame (MAY RETURN NULL)\\n-   * @return the select frame, or null\\n-   */\\n-  nsISelectControlFrame *GetSelectFrame();\\n-\\n-  /**\\n-   * Helper method for dispatching custom DOM events to our anonymous subcontent\\n-   * (for XBL form controls)\\n-   * @param aName the name of the event to dispatch\\n-   */\\n-  void DispatchDOMEvent(const nsAString& aName);\\n-\\n-  /**\\n-   * Is this a combobox?\\n-   */\\n-  PRBool IsCombobox() {\\n-    PRBool isMultiple = PR_TRUE;\\n-    PRInt32 size = 1;\\n-    GetSize(&size);\\n-    GetMultiple(&isMultiple);\\n-    return !isMultiple && size <= 1;\\n-  }\\n-\\n-  /**\\n-   * Helper method for dispatching ContentReset notifications to list\\n-   * and combo box frames.\\n-   */\\n-  void DispatchContentReset();\\n-\\n-  /**\\n-   * Rebuilds the options array from scratch as a fallback in error cases.\\n-   */\\n-  void RebuildOptionsArray();\\n-\\n+  if (mSelect) {\\n+    nsHTMLSelectElement* select =\\n+      static_cast<nsHTMLSelectElement*>(mSelect.get());\\n+    if (mNeedsRebuild || (mTopLevelMutation && mGuard.Mutated(1))) {\\n+      select->RebuildOptionsArray();\\n+    }\\n+    if (mTopLevelMutation) {\\n+      select->mMutating = PR_FALSE;\\n+    }\\n #ifdef DEBUG\\n-  void VerifyOptionsArray();\\n+    select->VerifyOptionsArray();\\n #endif\\n-\\n-  /** The options[] array */\\n-  nsRefPtr<nsHTMLOptionCollection> mOptions;\\n-  /** false if the parser is in the middle of adding children. */\\n-  PRPackedBool    mIsDoneAddingChildren;\\n-  /** true if our disabled state has changed from the default **/\\n-  PRPackedBool    mDisabledChanged;\\n-  /** The number of non-options as children of the select */\\n-  PRUint32  mNonOptionChildren;\\n-  /** The number of optgroups anywhere under the select */\\n-  PRUint32  mOptGroupCount;\\n-  /**\\n-   * The current selected index for selectedIndex (will be the first selected\\n-   * index if multiple are selected)\\n-   */\\n-  PRInt32   mSelectedIndex;\\n-  /**\\n-   * The temporary restore state in case we try to restore before parser is\\n-   * done adding options\\n-   */\\n-  nsRefPtr<nsSelectState> mRestoreState;\\n-};\\n-\\n+  }\\n+}\\n \\n //----------------------------------------------------------------------\\n //\\n@@ -502,6 +138,7 @@ nsHTMLSelectElement::nsHTMLSelectElement(nsINodeInfo *aNodeInfo,\\n     mOptions(new nsHTMLOptionCollection(this)),\\n     mIsDoneAddingChildren(!aFromParser),\\n     mDisabledChanged(PR_FALSE),\\n+    mMutating(PR_FALSE),\\n     mNonOptionChildren(0),\\n     mOptGroupCount(0),\\n     mSelectedIndex(-1)\\n@@ -561,39 +198,23 @@ nsHTMLSelectElement::InsertChildAt(nsIContent* aKid,\\n                                    PRUint32 aIndex,\\n                                    PRBool aNotify)\\n {\\n-  nsresult rv = WillAddOptions(aKid, this, aIndex);\\n-  PRBool rebuild = NS_FAILED(rv);\\n-\\n-  rv = nsGenericHTMLFormElement::InsertChildAt(aKid, aIndex, aNotify);\\n-  if (rebuild || NS_FAILED(rv)) {\\n-    RebuildOptionsArray();\\n-    return rv;\\n+  nsSafeOptionListMutation safeMutation(this, this, aKid, aIndex);\\n+  nsresult rv = nsGenericHTMLFormElement::InsertChildAt(aKid, aIndex, aNotify);\\n+  if (NS_FAILED(rv)) {\\n+    safeMutation.MutationFailed();\\n   }\\n-\\n-#ifdef DEBUG\\n-  VerifyOptionsArray();\\n-#endif\\n-\\n-  return NS_OK;\\n+  return rv;\\n }\\n \\n nsresult\\n nsHTMLSelectElement::RemoveChildAt(PRUint32 aIndex, PRBool aNotify)\\n {\\n-  nsresult rv = WillRemoveOptions(this, aIndex);\\n-  PRBool rebuild = NS_FAILED(rv);\\n-\\n-  rv = nsGenericHTMLFormElement::RemoveChildAt(aIndex, aNotify);\\n-  if (rebuild || NS_FAILED(rv)) {\\n-    RebuildOptionsArray();\\n-    return rv;\\n+  nsSafeOptionListMutation safeMutation(this, this, nsnull, aIndex);\\n+  nsresult rv = nsGenericHTMLFormElement::RemoveChildAt(aIndex, aNotify);\\n+  if (NS_FAILED(rv)) {\\n+    safeMutation.MutationFailed();\\n   }\\n-\\n-#ifdef DEBUG\\n-  VerifyOptionsArray();\\n-#endif\\n-\\n-  return NS_OK;\\n+  return rv;\\n }\\n \\n \\ndiff --git a/content/html/content/src/nsHTMLSelectElement.h b/content/html/content/src/nsHTMLSelectElement.h\\nnew file mode 100644\\nindex 0000000..b7b4310\\n--- /dev/null\\n+++ b/content/html/content/src/nsHTMLSelectElement.h\\n@@ -0,0 +1,496 @@\\n+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Mozilla Communicator client code.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Netscape Communications Corporation.\\n+ * Portions created by the Initial Developer are Copyright (C) 1998\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *   Pierre Phaneuf <pp@ludusdesign.com>\\n+ *   Mats Palmgren <mats.palmgren@bredband.net>\\n+ *   Olli Pettay <Olli.Pettay@helsinki.fi>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either of the GNU General Public License Version 2 or later (the \\\"GPL\\\"),\\n+ * or the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK ***** */\\n+#ifndef nsHTMLSelectElement_h___\\n+#define nsHTMLSelectElement_h___\\n+\\n+#include \\\"nsCOMPtr.h\\\"\\n+#include \\\"nsCOMArray.h\\\"\\n+#include \\\"nsGenericHTMLElement.h\\\"\\n+#include \\\"nsISelectElement.h\\\"\\n+#include \\\"nsIDOMHTMLSelectElement.h\\\"\\n+#include \\\"nsIDOMNSHTMLSelectElement.h\\\"\\n+#include \\\"nsIDOMNSXBLFormControl.h\\\"\\n+#include \\\"nsIDOMHTMLFormElement.h\\\"\\n+#include \\\"nsIDOMHTMLOptionElement.h\\\"\\n+#include \\\"nsIDOMHTMLCollection.h\\\"\\n+#include \\\"nsIDOMHTMLOptionsCollection.h\\\"\\n+#include \\\"nsIDOMNSHTMLOptionCollectn.h\\\"\\n+#include \\\"nsISelectControlFrame.h\\\"\\n+\\n+// PresState\\n+#include \\\"nsXPCOM.h\\\"\\n+#include \\\"nsPresState.h\\\"\\n+#include \\\"nsIComponentManager.h\\\"\\n+#include \\\"nsCheapSets.h\\\"\\n+#include \\\"nsLayoutErrors.h\\\"\\n+\\n+\\n+class nsHTMLSelectElement;\\n+\\n+/**\\n+ * The collection of options in the select (what you get back when you do\\n+ * select.options in DOM)\\n+ */\\n+class nsHTMLOptionCollection: public nsIDOMHTMLOptionsCollection,\\n+                              public nsIDOMNSHTMLOptionCollection,\\n+                              public nsIDOMHTMLCollection\\n+{\\n+public:\\n+  nsHTMLOptionCollection(nsHTMLSelectElement* aSelect);\\n+  virtual ~nsHTMLOptionCollection();\\n+\\n+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS\\n+\\n+  // nsIDOMHTMLOptionsCollection interface\\n+  NS_DECL_NSIDOMHTMLOPTIONSCOLLECTION\\n+\\n+  // nsIDOMNSHTMLOptionCollection interface\\n+  NS_DECL_NSIDOMNSHTMLOPTIONCOLLECTION\\n+\\n+  // nsIDOMHTMLCollection interface, all its methods are defined in\\n+  // nsIDOMHTMLOptionsCollection\\n+\\n+  NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsHTMLOptionCollection,\\n+                                           nsIDOMNSHTMLOptionCollection)\\n+\\n+  // Helpers for nsHTMLSelectElement\\n+  /**\\n+   * Insert an option\\n+   * @param aOption the option to insert\\n+   * @param aIndex the index to insert at\\n+   */\\n+  PRBool InsertOptionAt(nsIDOMHTMLOptionElement* aOption, PRInt32 aIndex)\\n+  {\\n+    return mElements.InsertObjectAt(aOption, aIndex);\\n+  }\\n+\\n+  /**\\n+   * Remove an option\\n+   * @param aIndex the index of the option to remove\\n+   */\\n+  void RemoveOptionAt(PRInt32 aIndex)\\n+  {\\n+    mElements.RemoveObjectAt(aIndex);\\n+  }\\n+\\n+  /**\\n+   * Get the option at the index\\n+   * @param aIndex the index\\n+   * @param aReturn the option returned [OUT]\\n+   */\\n+  nsIDOMHTMLOptionElement *ItemAsOption(PRInt32 aIndex)\\n+  {\\n+    return mElements.SafeObjectAt(aIndex);\\n+  }\\n+\\n+  /**\\n+   * Clears out all options\\n+   */\\n+  void Clear()\\n+  {\\n+    mElements.Clear();\\n+  }\\n+\\n+  /**\\n+   * Append an option to end of array\\n+   */\\n+  PRBool AppendOption(nsIDOMHTMLOptionElement* aOption)\\n+  {\\n+    return mElements.AppendObject(aOption);\\n+  }\\n+\\n+  /**\\n+   * Drop the reference to the select.  Called during select destruction.\\n+   */\\n+  void DropReference();\\n+\\n+  /**\\n+   * See nsISelectElement.idl for documentation on this method\\n+   */\\n+  nsresult GetOptionIndex(nsIDOMHTMLOptionElement* aOption,\\n+                          PRInt32 aStartIndex, PRBool aForward,\\n+                          PRInt32* aIndex);\\n+\\n+private:\\n+  /** The list of options (holds strong references) */\\n+  nsCOMArray<nsIDOMHTMLOptionElement> mElements;\\n+  /** The select element that contains this array */\\n+  nsHTMLSelectElement* mSelect;\\n+};\\n+\\n+\\n+/**\\n+ * The restore state used by select\\n+ */\\n+class nsSelectState : public nsISupports {\\n+public:\\n+  nsSelectState()\\n+  {\\n+  }\\n+  virtual ~nsSelectState()\\n+  {\\n+  }\\n+\\n+  NS_DECL_ISUPPORTS\\n+\\n+  void PutOption(PRInt32 aIndex, const nsAString& aValue)\\n+  {\\n+    // If the option is empty, store the index.  If not, store the value.\\n+    if (aValue.IsEmpty()) {\\n+      mIndices.Put(aIndex);\\n+    } else {\\n+      mValues.Put(aValue);\\n+    }\\n+  }\\n+\\n+  PRBool ContainsOption(PRInt32 aIndex, const nsAString& aValue)\\n+  {\\n+    return mValues.Contains(aValue) || mIndices.Contains(aIndex);\\n+  }\\n+\\n+private:\\n+  nsCheapStringSet mValues;\\n+  nsCheapInt32Set mIndices;\\n+};\\n+\\n+class nsSafeOptionListMutation\\n+{\\n+public:\\n+  /**\\n+   * @param aSelect The select element which option list is being mutated.\\n+   *                Can be null.\\n+   * @param aParent The content object which is being mutated.\\n+   * @param aKid    If not null, a new child element is being inserted to\\n+   *                aParent. Otherwise a child element will be removed.\\n+   * @param aIndex  The index of the content object in the parent.\\n+   */\\n+  nsSafeOptionListMutation(nsIContent* aSelect, nsIContent* aParent,\\n+                           nsIContent* aKid, PRUint32 aIndex);\\n+  ~nsSafeOptionListMutation();\\n+  void MutationFailed() { mNeedsRebuild = PR_TRUE; }\\n+private:\\n+  static void* operator new(size_t) CPP_THROW_NEW { return 0; }\\n+  static void operator delete(void*, size_t) {}\\n+  /** The select element which option list is being mutated. */\\n+  nsCOMPtr<nsISelectElement> mSelect;\\n+  /** PR_TRUE if the current mutation is the first one in the stack. */\\n+  PRBool                     mTopLevelMutation;\\n+  /** PR_TRUE if it is known that the option list must be recreated. */\\n+  PRBool                     mNeedsRebuild;\\n+  /** Option list must be recreated if more than one mutation is detected. */\\n+  nsMutationGuard            mGuard;\\n+};\\n+\\n+\\n+/**\\n+ * Implementation of &lt;select&gt;\\n+ */\\n+class nsHTMLSelectElement : public nsGenericHTMLFormElement,\\n+                            public nsIDOMHTMLSelectElement,\\n+                            public nsIDOMNSHTMLSelectElement,\\n+                            public nsIDOMNSXBLFormControl,\\n+                            public nsISelectElement\\n+{\\n+public:\\n+  nsHTMLSelectElement(nsINodeInfo *aNodeInfo, PRBool aFromParser = PR_FALSE);\\n+  virtual ~nsHTMLSelectElement();\\n+\\n+  // nsISupports\\n+  NS_DECL_ISUPPORTS_INHERITED\\n+\\n+  // nsIDOMNode\\n+  NS_FORWARD_NSIDOMNODE(nsGenericHTMLFormElement::)\\n+\\n+  // nsIDOMElement\\n+  NS_FORWARD_NSIDOMELEMENT(nsGenericHTMLFormElement::)\\n+\\n+  // nsIDOMHTMLElement\\n+  NS_FORWARD_NSIDOMHTMLELEMENT(nsGenericHTMLFormElement::)\\n+\\n+  // nsIDOMHTMLSelectElement\\n+  NS_DECL_NSIDOMHTMLSELECTELEMENT\\n+\\n+  // nsIDOMNSHTMLSelectElement\\n+  NS_DECL_NSIDOMNSHTMLSELECTELEMENT\\n+\\n+  // nsIDOMNSXBLFormControl\\n+  NS_DECL_NSIDOMNSXBLFORMCONTROL\\n+\\n+  // nsIContent\\n+  virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);\\n+\\n+  virtual void SetFocus(nsPresContext* aPresContext);\\n+  virtual PRBool IsFocusable(PRInt32 *aTabIndex = nsnull);\\n+  virtual nsresult InsertChildAt(nsIContent* aKid, PRUint32 aIndex,\\n+                                 PRBool aNotify);\\n+  virtual nsresult RemoveChildAt(PRUint32 aIndex, PRBool aNotify);\\n+\\n+  // Overriden nsIFormControl methods\\n+  NS_IMETHOD_(PRInt32) GetType() const { return NS_FORM_SELECT; }\\n+  NS_IMETHOD Reset();\\n+  NS_IMETHOD SubmitNamesValues(nsIFormSubmission* aFormSubmission,\\n+                               nsIContent* aSubmitElement);\\n+  NS_IMETHOD SaveState();\\n+  virtual PRBool RestoreState(nsPresState* aState);\\n+\\n+  // nsISelectElement\\n+  NS_DECL_NSISELECTELEMENT\\n+\\n+  /**\\n+   * Called when an attribute is about to be changed\\n+   */\\n+  virtual nsresult BeforeSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,\\n+                                 const nsAString* aValue, PRBool aNotify);\\n+  virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,\\n+                             PRBool aNotify);\\n+  \\n+  virtual nsresult DoneAddingChildren(PRBool aHaveNotified);\\n+  virtual PRBool IsDoneAddingChildren();\\n+\\n+  virtual PRBool ParseAttribute(PRInt32 aNamespaceID,\\n+                                nsIAtom* aAttribute,\\n+                                const nsAString& aValue,\\n+                                nsAttrValue& aResult);\\n+  virtual nsMapRuleToAttributesFunc GetAttributeMappingFunction() const;\\n+  virtual nsChangeHint GetAttributeChangeHint(const nsIAtom* aAttribute,\\n+                                              PRInt32 aModType) const;\\n+  NS_IMETHOD_(PRBool) IsAttributeMapped(const nsIAtom* aAttribute) const;\\n+\\n+  virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;\\n+\\n+  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_NO_UNLINK(nsHTMLSelectElement,\\n+                                                     nsGenericHTMLFormElement)\\n+\\n+protected:\\n+  friend class nsSafeOptionListMutation;\\n+\\n+  // Helper Methods\\n+  /**\\n+   * Check whether the option specified by the index is selected\\n+   * @param aIndex the index\\n+   * @return whether the option at the index is selected\\n+   */\\n+  PRBool IsOptionSelectedByIndex(PRInt32 aIndex);\\n+  /**\\n+   * Starting with (and including) aStartIndex, find the first selected index\\n+   * and set mSelectedIndex to it.\\n+   * @param aStartIndex the index to start with\\n+   */\\n+  void FindSelectedIndex(PRInt32 aStartIndex);\\n+  /**\\n+   * Select some option if possible (generally the first non-disabled option).\\n+   * @return true if something was selected, false otherwise\\n+   */\\n+  PRBool SelectSomething();\\n+  /**\\n+   * Call SelectSomething(), but only if nothing is selected\\n+   * @see SelectSomething()\\n+   * @return true if something was selected, false otherwise\\n+   */\\n+  PRBool CheckSelectSomething();\\n+  /**\\n+   * Called to trigger notifications of frames and fixing selected index\\n+   *\\n+   * @param aSelectFrame the frame for this content (could be null)\\n+   * @param aPresContext the current pres context\\n+   * @param aIndex the index that was selected or deselected\\n+   * @param aSelected whether the index was selected or deselected\\n+   * @param aNotify whether to notify the style system and such\\n+   */\\n+  void OnOptionSelected(nsISelectControlFrame* aSelectFrame,\\n+                        nsPresContext* aPresContext,\\n+                        PRInt32 aIndex,\\n+                        PRBool aSelected,\\n+                        PRBool aNotify);\\n+  /**\\n+   * Restore state to a particular state string (representing the options)\\n+   * @param aNewSelected the state string to restore to\\n+   */\\n+  void RestoreStateTo(nsSelectState* aNewSelected);\\n+\\n+#ifdef DEBUG_john\\n+  // Don't remove these, por favor.  They're very useful in debugging\\n+  nsresult PrintOptions(nsIContent* aOptions, PRInt32 tabs);\\n+#endif\\n+\\n+  // Adding options\\n+  /**\\n+   * Insert option(s) into the options[] array and perform notifications\\n+   * @param aOptions the option or optgroup being added\\n+   * @param aListIndex the index to start adding options into the list at\\n+   * @param aDepth the depth of aOptions (1=direct child of select ...)\\n+   */\\n+  nsresult InsertOptionsIntoList(nsIContent* aOptions,\\n+                                 PRInt32 aListIndex,\\n+                                 PRInt32 aDepth);\\n+  /**\\n+   * Remove option(s) from the options[] array\\n+   * @param aOptions the option or optgroup being added\\n+   * @param aListIndex the index to start removing options from the list at\\n+   * @param aDepth the depth of aOptions (1=direct child of select ...)\\n+   */\\n+  nsresult RemoveOptionsFromList(nsIContent* aOptions,\\n+                                 PRInt32 aListIndex,\\n+                                 PRInt32 aDepth);\\n+  /**\\n+   * Insert option(s) into the options[] array (called by InsertOptionsIntoList)\\n+   * @param aOptions the option or optgroup being added\\n+   * @param aInsertIndex the index to start adding options into the list at\\n+   * @param aDepth the depth of aOptions (1=direct child of select ...)\\n+   */\\n+  nsresult InsertOptionsIntoListRecurse(nsIContent* aOptions,\\n+                                        PRInt32* aInsertIndex,\\n+                                        PRInt32 aDepth);\\n+  /**\\n+   * Remove option(s) from the options[] array (called by RemoveOptionsFromList)\\n+   * @param aOptions the option or optgroup being added\\n+   * @param aListIndex the index to start removing options from the list at\\n+   * @param aNumRemoved the number removed so far [OUT]\\n+   * @param aDepth the depth of aOptions (1=direct child of select ...)\\n+   */\\n+  nsresult RemoveOptionsFromListRecurse(nsIContent* aOptions,\\n+                                        PRInt32 aRemoveIndex,\\n+                                        PRInt32* aNumRemoved,\\n+                                        PRInt32 aDepth);\\n+  /**\\n+   * Find out how deep this content is from the select (1=direct child)\\n+   * @param aContent the content to check\\n+   * @return the depth\\n+   */\\n+  PRInt32 GetContentDepth(nsIContent* aContent);\\n+  /**\\n+   * Get the index of the first option at, under or following the content in\\n+   * the select, or length of options[] if none are found\\n+   * @param aOptions the content\\n+   * @return the index of the first option\\n+   */\\n+  PRInt32 GetOptionIndexAt(nsIContent* aOptions);\\n+  /**\\n+   * Get the next option following the content in question (not at or under)\\n+   * (this could include siblings of the current content or siblings of the\\n+   * parent or children of siblings of the parent).\\n+   * @param aOptions the content\\n+   * @return the index of the next option after the content\\n+   */\\n+  PRInt32 GetOptionIndexAfter(nsIContent* aOptions);\\n+  /**\\n+   * Get the first option index at or under the content in question.\\n+   * @param aOptions the content\\n+   * @return the index of the first option at or under the content\\n+   */\\n+  PRInt32 GetFirstOptionIndex(nsIContent* aOptions);\\n+  /**\\n+   * Get the first option index under the content in question, within the\\n+   * range specified.\\n+   * @param aOptions the content\\n+   * @param aStartIndex the first child to look at\\n+   * @param aEndIndex the child *after* the last child to look at\\n+   * @return the index of the first option at or under the content\\n+   */\\n+  PRInt32 GetFirstChildOptionIndex(nsIContent* aOptions,\\n+                                   PRInt32 aStartIndex,\\n+                                   PRInt32 aEndIndex);\\n+\\n+  /**\\n+   * Get the frame as an nsISelectControlFrame (MAY RETURN NULL)\\n+   * @return the select frame, or null\\n+   */\\n+  nsISelectControlFrame *GetSelectFrame();\\n+\\n+  /**\\n+   * Helper method for dispatching custom DOM events to our anonymous subcontent\\n+   * (for XBL form controls)\\n+   * @param aName the name of the event to dispatch\\n+   */\\n+  void DispatchDOMEvent(const nsAString& aName);\\n+\\n+  /**\\n+   * Is this a combobox?\\n+   */\\n+  PRBool IsCombobox() {\\n+    PRBool isMultiple = PR_TRUE;\\n+    PRInt32 size = 1;\\n+    GetSize(&size);\\n+    GetMultiple(&isMultiple);\\n+    return !isMultiple && size <= 1;\\n+  }\\n+\\n+  /**\\n+   * Helper method for dispatching ContentReset notifications to list\\n+   * and combo box frames.\\n+   */\\n+  void DispatchContentReset();\\n+\\n+  /**\\n+   * Rebuilds the options array from scratch as a fallback in error cases.\\n+   */\\n+  void RebuildOptionsArray();\\n+\\n+#ifdef DEBUG\\n+  void VerifyOptionsArray();\\n+#endif\\n+\\n+  /** The options[] array */\\n+  nsRefPtr<nsHTMLOptionCollection> mOptions;\\n+  /** false if the parser is in the middle of adding children. */\\n+  PRPackedBool    mIsDoneAddingChildren;\\n+  /** true if our disabled state has changed from the default **/\\n+  PRPackedBool    mDisabledChanged;\\n+  /** true if child nodes are being added or removed.\\n+   *  Used by nsSafeOptionListMutation.\\n+   */\\n+  PRPackedBool    mMutating;\\n+  /** The number of non-options as children of the select */\\n+  PRUint32  mNonOptionChildren;\\n+  /** The number of optgroups anywhere under the select */\\n+  PRUint32  mOptGroupCount;\\n+  /**\\n+   * The current selected index for selectedIndex (will be the first selected\\n+   * index if multiple are selected)\\n+   */\\n+  PRInt32   mSelectedIndex;\\n+  /**\\n+   * The temporary restore state in case we try to restore before parser is\\n+   * done adding options\\n+   */\\n+  nsRefPtr<nsSelectState> mRestoreState;\\n+};\\n+\\n+#endif\\n\""}