{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basa78c95d\""},"diff":"\"a78c95d fix bug 369214 (ASSERTION: The observer list changed while being iterated over!: 'count == mObservers.Count()' in libpr0n) by switching the observers list to use nsTObserverArray. r=stuart a=1.9 blocker\\ndiff --git a/modules/libpr0n/src/imgRequest.cpp b/modules/libpr0n/src/imgRequest.cpp\\nindex c492dee..3e26715 100644\\n--- a/modules/libpr0n/src/imgRequest.cpp\\n+++ b/modules/libpr0n/src/imgRequest.cpp\\n@@ -124,23 +124,19 @@ nsresult imgRequest::Init(nsIURI *aURI,\\n   return NS_OK;\\n }\\n \\n-nsresult imgRequest::AddProxy(imgRequestProxy *proxy, PRBool aNotify)\\n+nsresult imgRequest::AddProxy(imgRequestProxy *proxy)\\n {\\n+  NS_PRECONDITION(proxy, \\\"null imgRequestProxy passed in\\\");\\n   LOG_SCOPE_WITH_PARAM(gImgLog, \\\"imgRequest::AddProxy\\\", \\\"proxy\\\", proxy);\\n \\n-  mObservers.AppendElement(static_cast<void*>(proxy));\\n-\\n-  if (aNotify)\\n-    NotifyProxyListener(proxy);\\n-\\n-  return NS_OK;\\n+  return mObservers.AppendObserver(proxy) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;\\n }\\n \\n nsresult imgRequest::RemoveProxy(imgRequestProxy *proxy, nsresult aStatus, PRBool aNotify)\\n {\\n   LOG_SCOPE_WITH_PARAM(gImgLog, \\\"imgRequest::RemoveProxy\\\", \\\"proxy\\\", proxy);\\n \\n-  mObservers.RemoveElement(static_cast<void*>(proxy));\\n+  mObservers.RemoveObserver(proxy);\\n \\n   /* Check mState below before we potentially call Cancel() below. Since\\n      Cancel() may result in OnStopRequest being called back before Cancel()\\n@@ -167,7 +163,7 @@ nsresult imgRequest::RemoveProxy(imgRequestProxy *proxy, nsresult aStatus, PRBoo\\n     mImage->StopAnimation();\\n   }\\n \\n-  if (mObservers.Count() == 0) {\\n+  if (mObservers.IsEmpty()) {\\n     /* If |aStatus| is a failure code, then cancel the load if it is still in progress.\\n        Otherwise, let the load continue, keeping 'this' in the cache with no observers.\\n        This way, if a proxy is destroyed without calling cancel on it, it won't leak\\n@@ -323,8 +319,9 @@ void imgRequest::RemoveFromCache()\\n \\n PRBool imgRequest::HaveProxyWithObserver(imgRequestProxy* aProxyToIgnore) const\\n {\\n-  for (PRInt32 i = 0; i < mObservers.Count(); ++i) {\\n-    imgRequestProxy *proxy = static_cast<imgRequestProxy*>(mObservers[i]);\\n+  nsTObserverArray<imgRequestProxy>::ForwardIterator iter(mObservers);\\n+  imgRequestProxy* proxy;\\n+  while ((proxy = iter.GetNext())) {\\n     if (proxy == aProxyToIgnore) {\\n       continue;\\n     }\\n@@ -355,7 +352,7 @@ void imgRequest::AdjustPriority(imgRequestProxy *proxy, PRInt32 delta)\\n   // concern though is that image loads remain lower priority than other pieces\\n   // of content such as link clicks, CSS, and JS.\\n   //\\n-  if (mObservers[0] != proxy)\\n+  if (mObservers.SafeObserverAt(0) != proxy)\\n     return;\\n \\n   nsCOMPtr<nsISupportsPriority> p = do_QueryInterface(mRequest);\\n@@ -401,15 +398,10 @@ NS_IMETHODIMP imgRequest::FrameChanged(imgIContainer *container,\\n {\\n   LOG_SCOPE(gImgLog, \\\"imgRequest::FrameChanged\\\");\\n \\n-  PRInt32 count = mObservers.Count();\\n-  for (PRInt32 i = 0; i < count; i++) {\\n-    imgRequestProxy *proxy = static_cast<imgRequestProxy*>(mObservers[i]);\\n-    if (proxy) proxy->FrameChanged(container, newframe, dirtyRect);\\n-\\n-    // If this assertion fires, it means that imgRequest notifications could\\n-    // be dropped!\\n-    NS_ASSERTION(count == mObservers.Count(),\\n-                 \\\"The observer list changed while being iterated over!\\\");\\n+  nsTObserverArray<imgRequestProxy>::ForwardIterator iter(mObservers);\\n+  imgRequestProxy* proxy;\\n+  while ((proxy = iter.GetNext())) {\\n+    proxy->FrameChanged(container, newframe, dirtyRect);\\n   }\\n \\n   return NS_OK;\\n@@ -424,15 +416,10 @@ NS_IMETHODIMP imgRequest::OnStartDecode(imgIRequest *request)\\n \\n   mState |= onStartDecode;\\n \\n-  PRInt32 count = mObservers.Count();\\n-  for (PRInt32 i = 0; i < count; i++) {\\n-    imgRequestProxy *proxy = static_cast<imgRequestProxy*>(mObservers[i]);\\n-    if (proxy) proxy->OnStartDecode();\\n-\\n-    // If this assertion fires, it means that imgRequest notifications could\\n-    // be dropped!\\n-    NS_ASSERTION(count == mObservers.Count(), \\n-                 \\\"The observer list changed while being iterated over!\\\");\\n+  nsTObserverArray<imgRequestProxy>::ForwardIterator iter(mObservers);\\n+  imgRequestProxy* proxy;\\n+  while ((proxy = iter.GetNext())) {\\n+    proxy->OnStartDecode();\\n   }\\n \\n   /* In the case of streaming jpegs, it is possible to get multiple OnStartDecodes which\\n@@ -464,16 +451,10 @@ NS_IMETHODIMP imgRequest::OnStartContainer(imgIRequest *request, imgIContainer *\\n \\n   mImageStatus |= imgIRequest::STATUS_SIZE_AVAILABLE;\\n \\n-  PRInt32 count = mObservers.Count();\\n-  for (PRInt32 i = 0; i < count; i++) {\\n-    imgRequestProxy *proxy = static_cast<imgRequestProxy*>(mObservers[i]);\\n-    if (proxy) proxy->OnStartContainer(image);\\n-\\n-    // If this assertion fires, it means that imgRequest notifications could\\n-    // be dropped!\\n-    NS_ASSERTION(count == mObservers.Count(), \\n-                 \\\"The observer list changed while being iterated over!\\\");\\n-\\n+  nsTObserverArray<imgRequestProxy>::ForwardIterator iter(mObservers);\\n+  imgRequestProxy* proxy;\\n+  while ((proxy = iter.GetNext())) {\\n+    proxy->OnStartContainer(image);\\n   }\\n \\n   return NS_OK;\\n@@ -485,15 +466,10 @@ NS_IMETHODIMP imgRequest::OnStartFrame(imgIRequest *request,\\n {\\n   LOG_SCOPE(gImgLog, \\\"imgRequest::OnStartFrame\\\");\\n \\n-  PRInt32 count = mObservers.Count();\\n-  for (PRInt32 i = 0; i < count; i++) {\\n-    imgRequestProxy *proxy = static_cast<imgRequestProxy*>(mObservers[i]);\\n-    if (proxy) proxy->OnStartFrame(frame);\\n-\\n-    // If this assertion fires, it means that imgRequest notifications could\\n-    // be dropped!\\n-    NS_ASSERTION(count == mObservers.Count(), \\n-                 \\\"The observer list changed while being iterated over!\\\");\\n+  nsTObserverArray<imgRequestProxy>::ForwardIterator iter(mObservers);\\n+  imgRequestProxy* proxy;\\n+  while ((proxy = iter.GetNext())) {\\n+    proxy->OnStartFrame(frame);\\n   }\\n \\n   return NS_OK;\\n@@ -506,15 +482,10 @@ NS_IMETHODIMP imgRequest::OnDataAvailable(imgIRequest *request,\\n {\\n   LOG_SCOPE(gImgLog, \\\"imgRequest::OnDataAvailable\\\");\\n \\n-  PRInt32 count = mObservers.Count();\\n-  for (PRInt32 i = 0; i < count; i++) {\\n-    imgRequestProxy *proxy = static_cast<imgRequestProxy*>(mObservers[i]);\\n-    if (proxy) proxy->OnDataAvailable(frame, rect);\\n-\\n-    // If this assertion fires, it means that imgRequest notifications could\\n-    // be dropped!\\n-    NS_ASSERTION(count == mObservers.Count(), \\n-                 \\\"The observer list changed while being iterated over!\\\");\\n+  nsTObserverArray<imgRequestProxy>::ForwardIterator iter(mObservers);\\n+  imgRequestProxy* proxy;\\n+  while ((proxy = iter.GetNext())) {\\n+    proxy->OnDataAvailable(frame, rect);\\n   }\\n \\n   return NS_OK;\\n@@ -541,15 +512,10 @@ NS_IMETHODIMP imgRequest::OnStopFrame(imgIRequest *request,\\n     mCacheEntry->SetDataSize(cacheSize + imageSize);\\n   }\\n \\n-  PRInt32 count = mObservers.Count();\\n-  for (PRInt32 i = 0; i < count; i++) {\\n-    imgRequestProxy *proxy = static_cast<imgRequestProxy*>(mObservers[i]);\\n-    if (proxy) proxy->OnStopFrame(frame);\\n-\\n-    // If this assertion fires, it means that imgRequest notifications could\\n-    // be dropped!\\n-    NS_ASSERTION(count == mObservers.Count(), \\n-                 \\\"The observer list changed while being iterated over!\\\");\\n+  nsTObserverArray<imgRequestProxy>::ForwardIterator iter(mObservers);\\n+  imgRequestProxy* proxy;\\n+  while ((proxy = iter.GetNext())) {\\n+    proxy->OnStopFrame(frame);\\n   }\\n \\n   return NS_OK;\\n@@ -563,15 +529,10 @@ NS_IMETHODIMP imgRequest::OnStopContainer(imgIRequest *request,\\n \\n   mState |= onStopContainer;\\n \\n-  PRInt32 count = mObservers.Count();\\n-  for (PRInt32 i = 0; i < count; i++) {\\n-    imgRequestProxy *proxy = static_cast<imgRequestProxy*>(mObservers[i]);\\n-    if (proxy) proxy->OnStopContainer(image);\\n-\\n-    // If this assertion fires, it means that imgRequest notifications could\\n-    // be dropped!\\n-    NS_ASSERTION(count == mObservers.Count(), \\n-                 \\\"The observer list changed while being iterated over!\\\");\\n+  nsTObserverArray<imgRequestProxy>::ForwardIterator iter(mObservers);\\n+  imgRequestProxy* proxy;\\n+  while ((proxy = iter.GetNext())) {\\n+    proxy->OnStopContainer(image);\\n   }\\n \\n   return NS_OK;\\n@@ -592,15 +553,10 @@ NS_IMETHODIMP imgRequest::OnStopDecode(imgIRequest *aRequest,\\n     mImageStatus |= imgIRequest::STATUS_ERROR;\\n   }\\n \\n-  PRInt32 count = mObservers.Count();\\n-  for (PRInt32 i = 0; i < count; i++) {\\n-    imgRequestProxy *proxy = static_cast<imgRequestProxy*>(mObservers[i]);\\n-    if (proxy) proxy->OnStopDecode(GetResultFromImageStatus(mImageStatus), aStatusArg);\\n-\\n-    // If this assertion fires, it means that imgRequest notifications could\\n-    // be dropped!\\n-    NS_ASSERTION(count == mObservers.Count(), \\n-                 \\\"The observer list changed while being iterated over!\\\");\\n+  nsTObserverArray<imgRequestProxy>::ForwardIterator iter(mObservers);\\n+  imgRequestProxy* proxy;\\n+  while ((proxy = iter.GetNext())) {\\n+    proxy->OnStopDecode(GetResultFromImageStatus(mImageStatus), aStatusArg);\\n   }\\n \\n   return NS_OK;\\n@@ -637,15 +593,10 @@ NS_IMETHODIMP imgRequest::OnStartRequest(nsIRequest *aRequest, nsISupports *ctxt\\n   mLoading = PR_TRUE;\\n \\n   /* notify our kids */\\n-  PRInt32 count = mObservers.Count();\\n-  for (PRInt32 i = 0; i < count; i++) {\\n-    imgRequestProxy *proxy = static_cast<imgRequestProxy*>(mObservers[i]);\\n-    if (proxy) proxy->OnStartRequest(aRequest, ctxt);\\n-\\n-    // If this assertion fires, it means that imgRequest notifications could\\n-    // be dropped!\\n-    NS_ASSERTION(count == mObservers.Count(), \\n-                 \\\"The observer list changed while being iterated over!\\\");\\n+  nsTObserverArray<imgRequestProxy>::ForwardIterator iter(mObservers);\\n+  imgRequestProxy* proxy;\\n+  while ((proxy = iter.GetNext())) {\\n+    proxy->OnStartRequest(aRequest, ctxt);\\n   }\\n \\n   nsCOMPtr<nsIChannel> chan(do_QueryInterface(aRequest));\\n@@ -703,7 +654,7 @@ NS_IMETHODIMP imgRequest::OnStartRequest(nsIRequest *aRequest, nsISupports *ctxt\\n \\n \\n   // Shouldn't we be dead already if this gets hit?  Probably multipart/x-mixed-replace...\\n-  if (mObservers.Count() == 0) {\\n+  if (mObservers.IsEmpty()) {\\n     this->Cancel(NS_IMAGELIB_ERROR_FAILURE);\\n   }\\n \\n@@ -762,13 +713,13 @@ NS_IMETHODIMP imgRequest::OnStopRequest(nsIRequest *aRequest, nsISupports *ctxt,\\n   }\\n \\n   /* notify the kids */\\n-  PRInt32 count = mObservers.Count();\\n-  for (PRInt32 i = count-1; i>=0; i--) {\\n-    imgRequestProxy *proxy = static_cast<imgRequestProxy*>(mObservers[i]);\\n+  nsTObserverArray<imgRequestProxy>::ForwardIterator iter(mObservers);\\n+  imgRequestProxy* proxy;\\n+  while ((proxy = iter.GetNext())) {\\n     /* calling OnStopRequest may result in the death of |proxy| so don't use the\\n        pointer after this call.\\n      */\\n-    if (proxy) proxy->OnStopRequest(aRequest, ctxt, status, mHadLastPart);\\n+    proxy->OnStopRequest(aRequest, ctxt, status, mHadLastPart);\\n   }\\n \\n   return NS_OK;\\ndiff --git a/modules/libpr0n/src/imgRequest.h b/modules/libpr0n/src/imgRequest.h\\nindex fd1e7fb..3de9607 100644\\n--- a/modules/libpr0n/src/imgRequest.h\\n+++ b/modules/libpr0n/src/imgRequest.h\\n@@ -56,7 +56,7 @@\\n #include \\\"nsCategoryCache.h\\\"\\n #include \\\"nsCOMPtr.h\\\"\\n #include \\\"nsString.h\\\"\\n-#include \\\"nsVoidArray.h\\\"\\n+#include \\\"nsTObserverArray.h\\\"\\n #include \\\"nsWeakReference.h\\\"\\n \\n class imgCacheValidator;\\n@@ -89,9 +89,8 @@ public:\\n                 void *aCacheId,\\n                 void *aLoadId);\\n \\n-  // Callers that pass aNotify==PR_FALSE must call NotifyProxyListener\\n-  // later.\\n-  nsresult AddProxy   (imgRequestProxy *proxy, PRBool aNotify);\\n+  // Callers must call NotifyProxyListener later.\\n+  nsresult AddProxy(imgRequestProxy *proxy);\\n \\n   // aNotify==PR_FALSE still sends OnStopRequest.\\n   nsresult RemoveProxy(imgRequestProxy *proxy, nsresult aStatus, PRBool aNotify);\\n@@ -156,7 +155,7 @@ private:\\n   nsCOMPtr<imgIDecoder> mDecoder;\\n   nsCOMPtr<nsIProperties> mProperties;\\n \\n-  nsAutoVoidArray mObservers;\\n+  nsTObserverArray<imgRequestProxy> mObservers;\\n \\n   PRPackedBool mLoading;\\n   PRPackedBool mProcessing;\\ndiff --git a/modules/libpr0n/src/imgRequestProxy.cpp b/modules/libpr0n/src/imgRequestProxy.cpp\\nindex 8548cb1..f960a28 100644\\n--- a/modules/libpr0n/src/imgRequestProxy.cpp\\n+++ b/modules/libpr0n/src/imgRequestProxy.cpp\\n@@ -92,8 +92,6 @@ imgRequestProxy::~imgRequestProxy()\\n        */\\n       mOwner->RemoveProxy(this, NS_OK, PR_FALSE);\\n     }\\n-\\n-    NS_RELEASE(mOwner);\\n   }\\n }\\n \\n@@ -101,6 +99,7 @@ imgRequestProxy::~imgRequestProxy()\\n \\n nsresult imgRequestProxy::Init(imgRequest *request, nsILoadGroup *aLoadGroup, imgIDecoderObserver *aObserver)\\n {\\n+  NS_PRECONDITION(!mOwner && !mListener, \\\"imgRequestProxy is already initialized\\\");\\n   NS_PRECONDITION(request, \\\"no request\\\");\\n   if (!request)\\n     return NS_ERROR_NULL_POINTER;\\n@@ -108,13 +107,11 @@ nsresult imgRequestProxy::Init(imgRequest *request, nsILoadGroup *aLoadGroup, im\\n   LOG_SCOPE_WITH_PARAM(gImgLog, \\\"imgRequestProxy::Init\\\", \\\"request\\\", request);\\n \\n   mOwner = request;\\n-  NS_ADDREF(mOwner);\\n-\\n   mListener = aObserver;\\n-\\n   mLoadGroup = aLoadGroup;\\n \\n-  request->AddProxy(this, PR_FALSE); // Pass PR_FALSE here so that AddProxy doesn't send all the On* notifications immediatly\\n+  // Note: AddProxy won't send all the On* notifications immediatly\\n+  request->AddProxy(this);\\n \\n   return NS_OK;\\n }\\n@@ -127,12 +124,10 @@ nsresult imgRequestProxy::ChangeOwner(imgRequest *aNewOwner)\\n   // Passing false to aNotify means that mListener will still get\\n   // OnStopRequest, if needed.\\n   mOwner->RemoveProxy(this, NS_IMAGELIB_CHANGING_OWNER, PR_FALSE);\\n-  NS_RELEASE(mOwner);\\n \\n   mOwner = aNewOwner;\\n-  NS_ADDREF(mOwner);\\n \\n-  mOwner->AddProxy(this, PR_FALSE);\\n+  mOwner->AddProxy(this);\\n \\n   return NS_OK;\\n }\\ndiff --git a/modules/libpr0n/src/imgRequestProxy.h b/modules/libpr0n/src/imgRequestProxy.h\\nindex 5bca7de..3c5f3fb 100644\\n--- a/modules/libpr0n/src/imgRequestProxy.h\\n+++ b/modules/libpr0n/src/imgRequestProxy.h\\n@@ -47,6 +47,7 @@\\n #include \\\"nsILoadGroup.h\\\"\\n #include \\\"nsISupportsPriority.h\\\"\\n #include \\\"nsCOMPtr.h\\\"\\n+#include \\\"nsAutoPtr.h\\\"\\n \\n #include \\\"imgRequest.h\\\"\\n \\n@@ -105,7 +106,13 @@ protected:\\n private:\\n   friend class imgCacheValidator;\\n \\n-  imgRequest *mOwner;\\n+  // We maintain the following invariant:\\n+  // The proxy is registered at most with a single imgRequest as an observer,\\n+  // and whenever it is, mOwner points to that object. This helps ensure that\\n+  // imgRequestProxy::~imgRequestProxy unregisters the proxy as an observer\\n+  // from whatever request it was registered with (if any). This, in turn,\\n+  // means that imgRequest::mObservers will not have any stale pointers in it.\\n+  nsRefPtr<imgRequest> mOwner;\\n \\n   imgIDecoderObserver* mListener;  // Weak ref; see imgILoader.idl\\n   nsCOMPtr<nsILoadGroup> mLoadGroup;\\ndiff --git a/xpcom/glue/nsTObserverArray.h b/xpcom/glue/nsTObserverArray.h\\nindex e40de4e..c1dc472 100644\\n--- a/xpcom/glue/nsTObserverArray.h\\n+++ b/xpcom/glue/nsTObserverArray.h\\n@@ -49,7 +49,7 @@ class NS_COM_GLUE nsTObserverArray_base {\\n       protected:\\n         friend class nsTObserverArray_base;\\n \\n-        Iterator_base(PRInt32 aPosition, nsTObserverArray_base& aArray)\\n+        Iterator_base(PRInt32 aPosition, const nsTObserverArray_base& aArray)\\n           : mPosition(aPosition),\\n             mNext(aArray.mIterators),\\n             mArray(aArray) {\\n@@ -80,7 +80,7 @@ class NS_COM_GLUE nsTObserverArray_base {\\n         Iterator_base* mNext;\\n \\n         // The array we're iterating\\n-        nsTObserverArray_base& mArray;\\n+        const nsTObserverArray_base& mArray;\\n     };\\n \\n     /**\\n@@ -104,7 +104,7 @@ class NS_COM_GLUE nsTObserverArray_base {\\n      */\\n     void AdjustIterators(PRInt32 aModPos, PRInt32 aAdjustment);\\n \\n-    Iterator_base* mIterators;\\n+    mutable Iterator_base* mIterators;\\n     nsVoidArray mObservers;\\n };\\n \\n@@ -182,7 +182,7 @@ class nsTObserverArray : public nsTObserverArray_base {\\n     // to GetNext\\n     class ForwardIterator : public nsTObserverArray_base::Iterator_base {\\n       public:\\n-        ForwardIterator(nsTObserverArray<T>& aArray)\\n+        ForwardIterator(const nsTObserverArray<T>& aArray)\\n           : Iterator_base(0, aArray) {\\n         }\\n \\n\""}