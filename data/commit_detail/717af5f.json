{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas717af5f\""},"diff":"\"717af5f Bug 393696 - Crash [@ PresShell::ResizeReflow] with onbeforecut removing element, iframe and position: fixed, patch by Mathieu Fenniak, r=Olli.Pettay, sr+a=jst\\ndiff --git a/layout/base/nsDocumentViewer.cpp b/layout/base/nsDocumentViewer.cpp\\nindex 4ca42f4..90e46c9 100644\\n--- a/layout/base/nsDocumentViewer.cpp\\n+++ b/layout/base/nsDocumentViewer.cpp\\n@@ -374,6 +374,7 @@ private:\\n   nsresult GetDocumentSelection(nsISelection **aSelection);\\n \\n   nsresult GetClipboardEventTarget(nsIDOMNode **aEventTarget);\\n+  nsresult FireClipboardEvent(PRUint32 msg, PRBool* aPreventDefault);\\n \\n #ifdef NS_PRINTING\\n   // Called when the DocViewer is notified that the state\\n@@ -2317,26 +2318,10 @@ NS_IMETHODIMP DocumentViewerImpl::SelectAll()\\n \\n NS_IMETHODIMP DocumentViewerImpl::CopySelection()\\n {\\n-  NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_INITIALIZED);\\n-\\n-  // Fire the copy event.\\n-  nsresult rv;\\n-  nsCOMPtr<nsIDOMNode> eventTarget;\\n-  rv = GetClipboardEventTarget(getter_AddRefs(eventTarget));\\n-  // On failure to get event target, just forget about it and don't fire.\\n-  if (NS_SUCCEEDED(rv)) {\\n-    nsEventStatus status = nsEventStatus_eIgnore;\\n-    nsEvent evt(PR_TRUE, NS_COPY);\\n-    nsEventDispatcher::Dispatch(eventTarget, mPresContext, &evt, nsnull,\\n-                                &status);\\n-    // if event handler return'd false (PreventDefault)\\n-    if (status == nsEventStatus_eConsumeNoDefault)\\n-      // Skip default behavior, return OK.\\n-      return NS_OK;\\n-    // It's possible the oncopy handler closed the window.\\n-    if (!mPresShell)\\n-      return NS_OK;\\n-  }\\n+  PRBool preventDefault;\\n+  nsresult rv = FireClipboardEvent(NS_COPY, &preventDefault);\\n+  if (NS_FAILED(rv) || preventDefault)\\n+    return rv;\\n \\n   return mPresShell->DoCopy();\\n }\\n@@ -2389,36 +2374,54 @@ nsresult DocumentViewerImpl::GetClipboardEventTarget(nsIDOMNode** aEventTarget)\\n   return nsCopySupport::GetClipboardEventTarget(sel, aEventTarget);\\n }\\n \\n-NS_IMETHODIMP DocumentViewerImpl::GetCopyable(PRBool *aCopyable)\\n+nsresult DocumentViewerImpl::FireClipboardEvent(PRUint32 msg,\\n+                                                PRBool* aPreventDefault)\\n {\\n-  NS_ENSURE_ARG_POINTER(aCopyable);\\n-  *aCopyable = PR_FALSE;\\n+  *aPreventDefault = PR_FALSE;\\n \\n+  NS_ENSURE_TRUE(mPresContext, NS_ERROR_NOT_INITIALIZED);\\n   NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_INITIALIZED);\\n \\n-  // Fire the beforecopy event.  If the event handler requests to prevent\\n-  // default behavior, set *aCopyable = true.  (IE-style behavior)\\n+  // It seems to be unsafe to fire an event handler during reflow (bug 393696)\\n+  PRBool isReflowing = PR_TRUE;\\n+  nsresult rv = mPresShell->IsReflowLocked(&isReflowing);\\n+  if (NS_FAILED(rv) || isReflowing)\\n+    return NS_OK;\\n+\\n   nsCOMPtr<nsIDOMNode> eventTarget;\\n-  nsresult rv = GetClipboardEventTarget(getter_AddRefs(eventTarget));\\n-  // On failure to get event target, just forget about it and don't fire.\\n-  if (NS_SUCCEEDED(rv)) {\\n-    nsEventStatus status = nsEventStatus_eIgnore;\\n-    nsEvent evt(PR_TRUE, NS_BEFORECOPY);\\n-    nsEventDispatcher::Dispatch(eventTarget, mPresContext, &evt, nsnull,\\n-                                &status);\\n-    // if event handler return'd false (PreventDefault)\\n-    if (status == nsEventStatus_eConsumeNoDefault) {\\n-      *aCopyable = PR_TRUE;\\n-      return NS_OK;\\n-    }\\n-    // It's possible the onbeforecopy handler closed the window.\\n-    if (!mPresShell)\\n-      return NS_OK;\\n-  }\\n+  rv = GetClipboardEventTarget(getter_AddRefs(eventTarget));\\n+  if (NS_FAILED(rv))\\n+    // On failure to get event target, just forget about it and don't fire.\\n+    return NS_OK;\\n+\\n+  nsEventStatus status = nsEventStatus_eIgnore;\\n+  nsEvent evt(PR_TRUE, msg);\\n+  nsEventDispatcher::Dispatch(eventTarget, mPresContext, &evt, nsnull,\\n+                              &status);\\n+  // if event handler return'd false (PreventDefault)\\n+  if (status == nsEventStatus_eConsumeNoDefault)\\n+    *aPreventDefault = PR_TRUE;\\n+\\n+  // Ensure that the calling function can use mPresShell -- if the event\\n+  // handler closed this window, mPresShell will be gone.\\n+  NS_ENSURE_STATE(mPresShell);\\n+\\n+  return NS_OK;\\n+}\\n+\\n+NS_IMETHODIMP DocumentViewerImpl::GetCopyable(PRBool *aCopyable)\\n+{\\n+  NS_ENSURE_ARG_POINTER(aCopyable);\\n+  *aCopyable = PR_FALSE;\\n+\\n+  nsresult rv = FireClipboardEvent(NS_BEFORECOPY, aCopyable);\\n+  if (NS_FAILED(rv) || *aCopyable)\\n+    return rv;\\n \\n   nsCOMPtr<nsISelection> selection;\\n   rv = mPresShell->GetSelectionForCopy(getter_AddRefs(selection));\\n-  if (NS_FAILED(rv)) return rv;\\n+  if (NS_FAILED(rv))\\n+    return rv;\\n \\n   PRBool isCollapsed;\\n   selection->GetIsCollapsed(&isCollapsed);\\n@@ -2429,21 +2432,10 @@ NS_IMETHODIMP DocumentViewerImpl::GetCopyable(PRBool *aCopyable)\\n \\n NS_IMETHODIMP DocumentViewerImpl::CutSelection()\\n {\\n-  NS_ENSURE_TRUE(mPresContext, NS_ERROR_NOT_INITIALIZED);\\n-\\n-  // Fire the cut event.\\n-  nsresult rv;\\n-  nsCOMPtr<nsIDOMNode> eventTarget;\\n-  rv = GetClipboardEventTarget(getter_AddRefs(eventTarget));\\n-  // On failure to get event target, just forget about it and don't fire.\\n-  if (NS_SUCCEEDED(rv)) {\\n-    nsEvent evt(PR_TRUE, NS_CUT);\\n-    nsEventDispatcher::Dispatch(eventTarget, mPresContext, &evt);\\n-    // should skip default behavior here if event handler returns false, but\\n-    // there is no default behavior to worry about.\\n-  }\\n-\\n-  return NS_OK;\\n+  // preventDefault's value is ignored because cut from the document has no\\n+  // default behaviour.\\n+  PRBool preventDefault;\\n+  return FireClipboardEvent(NS_CUT, &preventDefault);\\n }\\n \\n NS_IMETHODIMP DocumentViewerImpl::GetCutable(PRBool *aCutable)\\n@@ -2451,46 +2443,17 @@ NS_IMETHODIMP DocumentViewerImpl::GetCutable(PRBool *aCutable)\\n   NS_ENSURE_ARG_POINTER(aCutable);\\n   *aCutable = PR_FALSE;\\n \\n-  NS_ENSURE_TRUE(mPresContext, NS_ERROR_NOT_INITIALIZED);\\n-\\n-  // Fire the beforecut event.  If the event handler requests to prevent\\n-  // default behavior, set *aCutable = true.  (IE-style behavior)\\n-  nsCOMPtr<nsIDOMNode> eventTarget;\\n-  nsresult rv = GetClipboardEventTarget(getter_AddRefs(eventTarget));\\n-  // On failure to get event target, just forget about it and don't fire.\\n-  if (NS_SUCCEEDED(rv)) {\\n-    nsEventStatus status = nsEventStatus_eIgnore;\\n-    nsEvent evt(PR_TRUE, NS_BEFORECUT);\\n-    nsEventDispatcher::Dispatch(eventTarget, mPresContext, &evt, nsnull,\\n-                                &status);\\n-    // if event handler return'd false (PreventDefault)\\n-    if (status == nsEventStatus_eConsumeNoDefault) {\\n-      *aCutable = PR_TRUE;\\n-      return NS_OK;\\n-    }\\n-  }\\n-\\n-  *aCutable = PR_FALSE;  // mm, will this ever be called for an editable document?\\n-  return NS_OK;\\n+  // If event handler requests to prevent default behavior, enable\\n+  // the cut command -- pass aCutable in as aPreventDefault.\\n+  return FireClipboardEvent(NS_BEFORECUT, aCutable);\\n }\\n \\n NS_IMETHODIMP DocumentViewerImpl::Paste()\\n {\\n-  NS_ENSURE_TRUE(mPresContext, NS_ERROR_NOT_INITIALIZED);\\n-\\n-  // Fire the paste event.\\n-  nsresult rv;\\n-  nsCOMPtr<nsIDOMNode> eventTarget;\\n-  rv = GetClipboardEventTarget(getter_AddRefs(eventTarget));\\n-  // On failure to get event target, just forget about it and don't fire.\\n-  if (NS_SUCCEEDED(rv)) {\\n-    nsEvent evt(PR_TRUE, NS_PASTE);\\n-    nsEventDispatcher::Dispatch(eventTarget, mPresContext, &evt);\\n-    // should skip default behavior here if event handler returns false, but\\n-    // there is no default behavior to worry about.\\n-  }\\n-\\n-  return NS_OK;\\n+  // preventDefault's value is ignored because paste into the document has no\\n+  // default behaviour.\\n+  PRBool preventDefault;\\n+  return FireClipboardEvent(NS_PASTE, &preventDefault);\\n }\\n \\n NS_IMETHODIMP DocumentViewerImpl::GetPasteable(PRBool *aPasteable)\\n@@ -2498,27 +2461,9 @@ NS_IMETHODIMP DocumentViewerImpl::GetPasteable(PRBool *aPasteable)\\n   NS_ENSURE_ARG_POINTER(aPasteable);\\n   *aPasteable = PR_FALSE;\\n \\n-  NS_ENSURE_TRUE(mPresContext, NS_ERROR_NOT_INITIALIZED);\\n-\\n-  // Fire the beforepaste event.  If the event handler requests to prevent\\n-  // default behavior, set *aPasteable = true.  (IE-style behavior)\\n-  nsCOMPtr<nsIDOMNode> eventTarget;\\n-  nsresult rv = GetClipboardEventTarget(getter_AddRefs(eventTarget));\\n-  // On failure to get event target, just forget about it and don't fire.\\n-  if (NS_SUCCEEDED(rv)) {\\n-    nsEventStatus status = nsEventStatus_eIgnore;\\n-    nsEvent evt(PR_TRUE, NS_BEFOREPASTE);\\n-    nsEventDispatcher::Dispatch(eventTarget, mPresContext, &evt, nsnull,\\n-                                &status);\\n-    // if event handler return'd false (PreventDefault)\\n-    if (status == nsEventStatus_eConsumeNoDefault) {\\n-      *aPasteable = PR_TRUE;\\n-      return NS_OK;\\n-    }\\n-  }\\n-\\n-  *aPasteable = PR_FALSE;\\n-  return NS_OK;\\n+  // If event handler requests to prevent default behavior, enable\\n+  // the paste command -- pass aPasteable in as aPreventDefault.\\n+  return FireClipboardEvent(NS_BEFOREPASTE, aPasteable);\\n }\\n \\n /* AString getContents (in string mimeType, in boolean selectionOnly); */\\n\""}