{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas590a6c4\""},"diff":"\"590a6c4 Bug 376471 - \\\"Make XBM decoding also write directly to Cairo image buffer\\\" [p=alfredkayser@nl.ibm.com (Alfred Kayser) r+a1.9=stuart]\\ndiff --git a/modules/libpr0n/decoders/xbm/Makefile.in b/modules/libpr0n/decoders/xbm/Makefile.in\\nindex 3334742..cf1f802 100644\\n--- a/modules/libpr0n/decoders/xbm/Makefile.in\\n+++ b/modules/libpr0n/decoders/xbm/Makefile.in\\n@@ -50,10 +50,11 @@ MODULE_NAME     = nsXBMModule\\n LIBXUL_LIBRARY  = 1\\n \\n REQUIRES\\t= xpcom \\\\\\n-\\t\\t  gfx \\\\\\n-\\t\\t  imglib2 \\\\\\n-\\t\\t  thebes \\\\\\n-\\t\\t  $(NULL)\\n+\\t\\t\\t  string \\\\\\n+\\t\\t\\t  gfx \\\\\\n+\\t\\t\\t  thebes \\\\\\n+\\t\\t\\t  imglib2 \\\\\\n+\\t\\t\\t  $(NULL)\\n \\n CPPSRCS        = nsXBMDecoder.cpp\\n \\ndiff --git a/modules/libpr0n/decoders/xbm/nsXBMDecoder.cpp b/modules/libpr0n/decoders/xbm/nsXBMDecoder.cpp\\nindex d2bf215..74ea2b6 100644\\n--- a/modules/libpr0n/decoders/xbm/nsXBMDecoder.cpp\\n+++ b/modules/libpr0n/decoders/xbm/nsXBMDecoder.cpp\\n@@ -55,9 +55,19 @@\\n #include \\\"nsIProperties.h\\\"\\n #include \\\"nsISupportsPrimitives.h\\\"\\n \\n+#include \\\"gfxColor.h\\\"\\n+#include \\\"nsIImage.h\\\"\\n+#include \\\"nsIInterfaceRequestorUtils.h\\\"\\n+\\n+// Static colormap\\n+static const PRUint32 kColors[2] = {\\n+    GFX_PACKED_PIXEL(0, 0, 0, 0),     // Transparent \\n+    GFX_PACKED_PIXEL(255, 0, 0, 0)    // Black\\n+};\\n+\\n NS_IMPL_ISUPPORTS1(nsXBMDecoder, imgIDecoder)\\n \\n-nsXBMDecoder::nsXBMDecoder() : mBuf(nsnull), mPos(nsnull), mAlphaRow(nsnull)\\n+nsXBMDecoder::nsXBMDecoder() : mBuf(nsnull), mPos(nsnull), mImageData(nsnull)\\n {\\n }\\n \\n@@ -65,9 +75,6 @@ nsXBMDecoder::~nsXBMDecoder()\\n {\\n     if (mBuf)\\n         free(mBuf);\\n-\\n-    if (mAlphaRow)\\n-        free(mAlphaRow);\\n }\\n \\n NS_IMETHODIMP nsXBMDecoder::Init(imgILoad *aLoad)\\n@@ -87,28 +94,18 @@ NS_IMETHODIMP nsXBMDecoder::Init(imgILoad *aLoad)\\n \\n     mCurRow = mBufSize = mWidth = mHeight = 0;\\n     mState = RECV_HEADER;\\n-    mHasNoAlpha = PR_TRUE;\\n \\n     return NS_OK;\\n }\\n \\n NS_IMETHODIMP nsXBMDecoder::Close()\\n {\\n-    if (mHasNoAlpha) {\\n-        nsCOMPtr<nsIImage> img(do_GetInterface(mFrame));\\n-        img->SetHasNoAlpha();\\n-    }\\n-\\n     mObserver->OnStopContainer(nsnull, mImage);\\n     mObserver->OnStopDecode(nsnull, NS_OK, nsnull);\\n     mObserver = nsnull;\\n     mImage = nsnull;\\n     mFrame = nsnull;\\n-\\n-    if (mAlphaRow) {\\n-        free(mAlphaRow);\\n-        mAlphaRow = nsnull;\\n-    }\\n+    mImageData = nsnull;\\n \\n     return NS_OK;\\n }\\n@@ -206,19 +203,8 @@ nsresult nsXBMDecoder::ProcessData(const char* aData, PRUint32 aCount) {\\n             }\\n         }\\n \\n-        mImage->AppendFrame(mFrame);\\n-        mObserver->OnStartFrame(nsnull, mFrame);\\n-\\n-        PRUint32 bpr;\\n-        mFrame->GetImageBytesPerRow(&bpr);\\n-        PRUint32 abpr;\\n-        mFrame->GetAlphaBytesPerRow(&abpr);\\n-\\n-        mAlphaRow = (PRUint8*)malloc(abpr);\\n-        if (!mAlphaRow) {\\n-          mState = RECV_DONE;\\n-          return NS_ERROR_OUT_OF_MEMORY;\\n-        }\\n+        PRUint32 imageLen;\\n+        mFrame->GetImageData((PRUint8**)&mImageData, &imageLen);\\n \\n         mState = RECV_SEEK;\\n \\n@@ -236,12 +222,8 @@ nsresult nsXBMDecoder::ProcessData(const char* aData, PRUint32 aCount) {\\n         }\\n     }\\n     if (mState == RECV_DATA) {\\n-        PRUint32 bpr;\\n-        mFrame->GetImageBytesPerRow(&bpr);\\n-        PRUint32 abpr;\\n-        mFrame->GetAlphaBytesPerRow(&abpr);\\n-        PRBool hiByte = PR_TRUE;\\n-        PRBool chunkHasNoAlpha = PR_TRUE;\\n+        nsCOMPtr<nsIImage> img = do_GetInterface(mFrame);\\n+        PRUint32 *ar = mImageData + mCurRow * mWidth + mCurCol;\\n \\n         do {\\n             PRUint32 pixel = strtoul(mPos, &endPtr, 0);\\n@@ -257,53 +239,39 @@ nsresult nsXBMDecoder::ProcessData(const char* aData, PRUint32 aCount) {\\n             if (!*endPtr) {\\n                 // Need more data\\n                 return NS_OK;\\n-            } else if (*endPtr != ',') {\\n+            }\\n+            if (*endPtr != ',') {\\n                 *endPtr = '\\\\0';\\n                 mState = RECV_DONE;  // strange character (or ending '}')\\n+            } else {\\n+                // Skip the comma\\n+                endPtr++;\\n             }\\n-            if (!mIsX10 || !hiByte)\\n-                mPos = endPtr; // go to next value only when done with this one\\n-            if (mIsX10) {\\n-                // handle X10 flavor short values\\n-                if (hiByte)\\n-                    pixel >>= 8;\\n-                hiByte = !hiByte;\\n+            mPos = endPtr;\\n+            PRUint32 numPixels = 8;\\n+            if (mIsX10) { // X10 use 16bits values, but bytes are swapped\\n+                pixel = (pixel >> 8) | ((pixel&0xFF) << 8);\\n+                numPixels = 16;\\n             }\\n-\\n-            PRUint32 *ar = ((PRUint32*)mAlphaRow) + mCurCol;\\n-            const int alphas = PR_MIN(8, mWidth - mCurCol);\\n-            for (int i = 0; i < alphas; i++) {\\n-                const PRUint8 val = ((pixel & (1 << i)) >> i) ? 255 : 0;\\n-                *ar++ = (val << 24) | 0;\\n-                if (val == 0)\\n-                    chunkHasNoAlpha = PR_FALSE;\\n+            numPixels = PR_MIN(numPixels, mWidth - mCurCol);\\n+            for (PRUint32 i = numPixels; i > 0; --i) {\\n+                *ar++ = kColors[pixel & 1];\\n+                pixel >>= 1;\\n             }\\n-\\n-            mCurCol = PR_MIN(mCurCol + 8, mWidth);\\n+            mCurCol += numPixels;\\n             if (mCurCol == mWidth || mState == RECV_DONE) {\\n-                mFrame->SetImageData(mAlphaRow, abpr, mCurRow * abpr);\\n-\\n                 nsIntRect r(0, mCurRow, mWidth, 1);\\n+                img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);\\n                 mObserver->OnDataAvailable(nsnull, mFrame, &r);\\n \\n-                if ((mCurRow + 1) == mHeight) {\\n+                mCurRow++;\\n+                if (mCurRow == mHeight) {\\n                     mState = RECV_DONE;\\n                     return mObserver->OnStopFrame(nsnull, mFrame);\\n                 }\\n-                mCurRow++;\\n                 mCurCol = 0;\\n             }\\n-\\n-            // Skip the comma\\n-            NS_ASSERTION(mState != RECV_DATA || *mPos == ',' ||\\n-                         (mIsX10 && hiByte),\\n-                         \\\"Must be a comma\\\");\\n-            if (*mPos == ',')\\n-                mPos++;\\n         } while ((mState == RECV_DATA) && *mPos);\\n-\\n-        if (!chunkHasNoAlpha)\\n-            mHasNoAlpha = PR_FALSE;\\n     }\\n \\n     return NS_OK;\\ndiff --git a/modules/libpr0n/decoders/xbm/nsXBMDecoder.h b/modules/libpr0n/decoders/xbm/nsXBMDecoder.h\\nindex 34cde06..77065bc 100644\\n--- a/modules/libpr0n/decoders/xbm/nsXBMDecoder.h\\n+++ b/modules/libpr0n/decoders/xbm/nsXBMDecoder.h\\n@@ -86,11 +86,10 @@ private:\\n     PRUint32 mXHotspot;\\n     PRUint32 mYHotspot;\\n \\n-    PRUint8* mAlphaRow; // alpha data for the row\\n+    PRUint32* mImageData;    // Pointer into the Cairo image data\\n \\n     PRPackedBool mIsCursor;\\n     PRPackedBool mIsX10; // X10 flavor XBM?\\n-    PRPackedBool mHasNoAlpha;\\n \\n     enum {\\n         RECV_HEADER,\\n\""}