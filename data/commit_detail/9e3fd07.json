{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas9e3fd07\""},"diff":"\"9e3fd07 retain drag source view during drag in case gecko kills off the view during the drag. b=396829 r=smichaud sr=roc a=roc\\ndiff --git a/widget/src/cocoa/nsChildView.mm b/widget/src/cocoa/nsChildView.mm\\nindex 5728fbc..5c1176b 100644\\n--- a/widget/src/cocoa/nsChildView.mm\\n+++ b/widget/src/cocoa/nsChildView.mm\\n@@ -1784,13 +1784,13 @@ nsChildView::GetDocumentAccessible(nsIAccessible** aAccessible)\\n NSPasteboard* globalDragPboard = nil;\\n \\n \\n-// globalDragView and globalDragEvent are only non-null during calls to |mouseDragged:|\\n+// gLastDragView and gLastDragEvent are only non-null during calls to |mouseDragged:|\\n // in our native NSView. They are used to communicate information to the drag service\\n // during drag invocation (starting a drag in from the view). All drag service drag\\n // invocations happen only while these two global variables are non-null, while |mouseDragged:|\\n // is on the stack.\\n-NSView* globalDragView = nil;\\n-NSEvent* globalDragEvent = nil;\\n+NSView* gLastDragView = nil;\\n+NSEvent* gLastDragEvent = nil;\\n \\n \\n // initWithFrame:geckoChild:eventSink:\\n@@ -2782,8 +2782,8 @@ static nsEventStatus SendGeckoMouseEnterOrExitEvent(PRBool isTrusted,\\n     return;\\n   }\\n \\n-  globalDragView = self;\\n-  globalDragEvent = theEvent;\\n+  gLastDragView = self;\\n+  gLastDragEvent = theEvent;\\n \\n   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_MOVE, nsnull, nsMouseEvent::eReal);\\n   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];\\n@@ -2799,8 +2799,8 @@ static nsEventStatus SendGeckoMouseEnterOrExitEvent(PRBool isTrusted,\\n \\n   mGeckoChild->DispatchMouseEvent(geckoEvent);    \\n \\n-  globalDragView = nil;\\n-  globalDragEvent = nil;\\n+  gLastDragView = nil;\\n+  gLastDragEvent = nil;\\n   // XXX maybe call markedTextSelectionChanged:client: here?\\n }\\n \\ndiff --git a/widget/src/cocoa/nsDragService.h b/widget/src/cocoa/nsDragService.h\\nindex 67f5df4..d840b88 100644\\n--- a/widget/src/cocoa/nsDragService.h\\n+++ b/widget/src/cocoa/nsDragService.h\\n@@ -68,6 +68,8 @@ private:\\n                               nsIScriptableRegion* aRegion);\\n \\n   nsCOMPtr<nsISupportsArray> mDataItems; // only valid for a drag started within gecko\\n+  NSView* mNativeDragView;\\n+  NSEvent* mNativeDragEvent;\\n };\\n \\n #endif // nsDragService_h_\\ndiff --git a/widget/src/cocoa/nsDragService.mm b/widget/src/cocoa/nsDragService.mm\\nindex f91d9d5..c87fea4 100644\\n--- a/widget/src/cocoa/nsDragService.mm\\n+++ b/widget/src/cocoa/nsDragService.mm\\n@@ -75,8 +75,8 @@ extern PRLogModuleInfo* sCocoaLog;\\n #endif\\n \\n extern NSPasteboard* globalDragPboard;\\n-extern NSView* globalDragView;\\n-extern NSEvent* globalDragEvent;\\n+extern NSView* gLastDragView;\\n+extern NSEvent* gLastDragEvent;\\n \\n // This global makes the transferable array available to Cocoa's promised\\n // file destination callback.\\n@@ -86,6 +86,8 @@ NSString* const kWildcardPboardType = @\\\"MozillaWildcard\\\";\\n \\n nsDragService::nsDragService()\\n {\\n+  mNativeDragView = nil;\\n+  mNativeDragEvent = nil;\\n }\\n \\n \\n@@ -150,7 +152,7 @@ nsDragService::ConstructDragImage(nsIDOMNode* aDOMNode,\\n                                   nsRect* aDragRect,\\n                                   nsIScriptableRegion* aRegion)\\n {\\n-  NSPoint screenPoint = [[globalDragView window] convertBaseToScreen:[globalDragEvent locationInWindow]];\\n+  NSPoint screenPoint = [[gLastDragView window] convertBaseToScreen:[gLastDragEvent locationInWindow]];\\n   // Y coordinates are bottom to top, so reverse this\\n   if ([[NSScreen screens] count] > 0)\\n     screenPoint.y = NSMaxY([[[NSScreen screens] objectAtIndex:0] frame]) - screenPoint.y;\\n@@ -269,21 +271,25 @@ nsDragService::InvokeDragSession(nsIDOMNode* aDOMNode, nsISupportsArray* aTransf\\n   else\\n     point.y = dragRect.y;\\n \\n-  point = [[globalDragView window] convertScreenToBase: point];\\n-  NSPoint localPoint = [globalDragView convertPoint:point fromView:nil];\\n+  point = [[gLastDragView window] convertScreenToBase: point];\\n+  NSPoint localPoint = [gLastDragView convertPoint:point fromView:nil];\\n  \\n   // Save the transferables away in case a promised file callback is invoked.\\n   gDraggedTransferables = aTransferableArray;\\n \\n   nsBaseDragService::StartDragSession();\\n \\n-  [globalDragView dragImage:image\\n-                         at:localPoint\\n-                     offset:NSMakeSize(0,0)\\n-                      event:globalDragEvent\\n-                 pasteboard:[NSPasteboard pasteboardWithName:NSDragPboard]\\n-                     source:globalDragView\\n-                  slideBack:YES];\\n+  // We need to retain the view and the event during the drag in case either gets destroyed.\\n+  mNativeDragView = [gLastDragView retain];\\n+  mNativeDragEvent = [gLastDragEvent retain];\\n+\\n+  [mNativeDragView dragImage:image\\n+                          at:localPoint\\n+                      offset:NSMakeSize(0,0)\\n+                       event:mNativeDragEvent\\n+                  pasteboard:[NSPasteboard pasteboardWithName:NSDragPboard]\\n+                      source:mNativeDragView\\n+                   slideBack:YES];\\n \\n   return NS_OK;\\n }\\n@@ -516,6 +522,15 @@ nsDragService::GetNumDropItems(PRUint32* aNumItems)\\n NS_IMETHODIMP\\n nsDragService::EndDragSession(PRBool aDoneDrag)\\n {\\n+  if (mNativeDragView) {\\n+    [mNativeDragView release];\\n+    mNativeDragView = nil;\\n+  }\\n+  if (mNativeDragEvent) {\\n+    [mNativeDragEvent release];\\n+    mNativeDragEvent = nil;\\n+  }\\n+\\n   mDataItems = nsnull;\\n   return nsBaseDragService::EndDragSession(aDoneDrag);\\n }\\n\""}