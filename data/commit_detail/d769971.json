{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basd769971\""},"diff":"\"d769971 Bug 174889 - unable to get keyboard shortcut for treeitem node, r=smaug, ginn.chen, mats, sr=mats, a=sicking\\ndiff --git a/accessible/src/base/nsAccessibilityUtils.cpp b/accessible/src/base/nsAccessibilityUtils.cpp\\nindex 98aae9d..91d46b3 100755\\n--- a/accessible/src/base/nsAccessibilityUtils.cpp\\n+++ b/accessible/src/base/nsAccessibilityUtils.cpp\\n@@ -46,6 +46,9 @@\\n #include \\\"nsIDOMXULSelectCntrlEl.h\\\"\\n #include \\\"nsIDOMXULSelectCntrlItemEl.h\\\"\\n #include \\\"nsIEventListenerManager.h\\\"\\n+#include \\\"nsIPresShell.h\\\"\\n+#include \\\"nsPresContext.h\\\"\\n+#include \\\"nsIEventStateManager.h\\\"\\n #include \\\"nsISelection2.h\\\"\\n #include \\\"nsISelectionController.h\\\"\\n \\n@@ -176,6 +179,39 @@ nsAccUtils::HasListener(nsIContent *aContent, const nsAString& aEventType)\\n   return listenerManager && listenerManager->HasListenersFor(aEventType);  \\n }\\n \\n+PRUint32\\n+nsAccUtils::GetAccessKeyFor(nsIContent *aContent)\\n+{\\n+  if (!aContent)\\n+    return 0;\\n+\\n+  // Accesskeys are registered by @accesskey attribute only. At first check\\n+  // whether it is presented on the given element to avoid the slow\\n+  // nsIEventStateManager::GetRegisteredAccessKey() method.\\n+  if (!aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::accesskey))\\n+    return 0;\\n+\\n+  nsCOMPtr<nsIDocument> doc = aContent->GetOwnerDoc();\\n+  if (!doc)\\n+    return 0;\\n+\\n+  nsCOMPtr<nsIPresShell> presShell = doc->GetPrimaryShell();\\n+  if (!presShell)\\n+    return 0;\\n+\\n+  nsPresContext *presContext = presShell->GetPresContext();\\n+  if (!presContext)\\n+    return 0;\\n+\\n+  nsIEventStateManager *esm = presContext->EventStateManager();\\n+  if (!esm)\\n+    return 0;\\n+\\n+  PRUint32 key = 0;\\n+  esm->GetRegisteredAccessKey(aContent, &key);\\n+  return key;\\n+}\\n+\\n nsresult\\n nsAccUtils::FireAccEvent(PRUint32 aEventType, nsIAccessible *aAccessible,\\n                          PRBool aIsAsynch)\\ndiff --git a/accessible/src/base/nsAccessibilityUtils.h b/accessible/src/base/nsAccessibilityUtils.h\\nindex 0bc1662..13eef1d 100755\\n--- a/accessible/src/base/nsAccessibilityUtils.h\\n+++ b/accessible/src/base/nsAccessibilityUtils.h\\n@@ -110,6 +110,14 @@ public:\\n   static PRBool HasListener(nsIContent *aContent, const nsAString& aEventType);\\n \\n   /**\\n+   * Return an accesskey registered on the given element by\\n+   * nsIEventStateManager or 0 if there is no registered accesskey.\\n+   *\\n+   * @param aContent - the given element.\\n+   */\\n+  static PRUint32 GetAccessKeyFor(nsIContent *aContent);\\n+\\n+  /**\\n    * Fire accessible event of the given type for the given accessible.\\n    */\\n   static nsresult FireAccEvent(PRUint32 aEventType, nsIAccessible *aAccessible,\\ndiff --git a/accessible/src/base/nsAccessible.cpp b/accessible/src/base/nsAccessible.cpp\\nindex 767f58e..a645737 100644\\n--- a/accessible/src/base/nsAccessible.cpp\\n+++ b/accessible/src/base/nsAccessible.cpp\\n@@ -349,7 +349,7 @@ NS_IMETHODIMP nsAccessible::GetDescription(nsAString& aDescription)\\n // returns the accesskey modifier mask used in the given node's context\\n // (i.e. chrome or content), or 0 if an error occurs\\n static PRInt32\\n-GetAccessModifierMask(nsIDOMElement* aDOMNode)\\n+GetAccessModifierMask(nsIContent* aContent)\\n {\\n   nsCOMPtr<nsIPrefBranch> prefBranch =\\n     do_GetService(NS_PREFSERVICE_CONTRACTID);\\n@@ -370,8 +370,7 @@ GetAccessModifierMask(nsIDOMElement* aDOMNode)\\n   }\\n \\n   // get the docShell to this DOMNode, return 0 on failure\\n-  nsCOMPtr<nsIContent> content(do_QueryInterface(aDOMNode));\\n-  nsCOMPtr<nsIDocument> document = content->GetCurrentDoc();\\n+  nsCOMPtr<nsIDocument> document = aContent->GetCurrentDoc();\\n   if (!document)\\n     return 0;\\n   nsCOMPtr<nsISupports> container = document->GetContainer();\\n@@ -398,47 +397,49 @@ GetAccessModifierMask(nsIDOMElement* aDOMNode)\\n   return NS_SUCCEEDED(rv) ? accessModifierMask : 0;\\n }\\n \\n-NS_IMETHODIMP nsAccessible::GetKeyboardShortcut(nsAString& _retval)\\n+NS_IMETHODIMP\\n+nsAccessible::GetKeyboardShortcut(nsAString& aAccessKey)\\n {\\n-  nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(mDOMNode));\\n-  if (elt) {\\n-    nsAutoString accesskey;\\n-    elt->GetAttribute(NS_LITERAL_STRING(\\\"accesskey\\\"), accesskey);\\n-    if (accesskey.IsEmpty()) {\\n-      nsCOMPtr<nsIContent> content = do_QueryInterface(elt);\\n-      nsIContent *labelContent = GetLabelContent(content);\\n-      if (labelContent) {\\n-        labelContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::accesskey, accesskey);\\n-      }\\n-      if (accesskey.IsEmpty()) {\\n-        return NS_ERROR_FAILURE;\\n-      }\\n-    }\\n+  aAccessKey.Truncate();\\n \\n-    // append the modifiers in reverse order\\n-    // (result: Control+Alt+Shift+Meta+<key>)\\n-    nsAutoString propertyKey;\\n-    PRInt32 modifierMask = GetAccessModifierMask(elt);\\n-    if (modifierMask & NS_MODIFIER_META) {\\n-      propertyKey.AssignLiteral(\\\"VK_META\\\");\\n-      nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);\\n-    }\\n-    if (modifierMask & NS_MODIFIER_SHIFT) {\\n-      propertyKey.AssignLiteral(\\\"VK_SHIFT\\\");\\n-      nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);\\n-    }\\n-    if (modifierMask & NS_MODIFIER_ALT) {\\n-      propertyKey.AssignLiteral(\\\"VK_ALT\\\");\\n-      nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);\\n-    }\\n-    if (modifierMask & NS_MODIFIER_CONTROL) {\\n-      propertyKey.AssignLiteral(\\\"VK_CONTROL\\\");\\n-      nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);\\n-    }\\n-    _retval= accesskey;\\n+  nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));\\n+  if (!content)\\n+    return NS_ERROR_FAILURE;\\n+\\n+  PRUint32 key = nsAccUtils::GetAccessKeyFor(content);\\n+  if (!key) {\\n+    nsCOMPtr<nsIContent> labelContent(GetLabelContent(content));\\n+    if (labelContent)\\n+      key = nsAccUtils::GetAccessKeyFor(labelContent);\\n+  }\\n+\\n+  if (!key)\\n     return NS_OK;\\n+\\n+  nsAutoString accesskey(key);\\n+\\n+  // Append the modifiers in reverse order, result: Control+Alt+Shift+Meta+<key>\\n+  nsAutoString propertyKey;\\n+  PRInt32 modifierMask = GetAccessModifierMask(content);\\n+  if (modifierMask & NS_MODIFIER_META) {\\n+    propertyKey.AssignLiteral(\\\"VK_META\\\");\\n+    nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);\\n   }\\n-  return NS_ERROR_FAILURE;\\n+  if (modifierMask & NS_MODIFIER_SHIFT) {\\n+    propertyKey.AssignLiteral(\\\"VK_SHIFT\\\");\\n+    nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);\\n+  }\\n+  if (modifierMask & NS_MODIFIER_ALT) {\\n+    propertyKey.AssignLiteral(\\\"VK_ALT\\\");\\n+    nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);\\n+  }\\n+  if (modifierMask & NS_MODIFIER_CONTROL) {\\n+    propertyKey.AssignLiteral(\\\"VK_CONTROL\\\");\\n+    nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);\\n+  }\\n+\\n+  aAccessKey = accesskey;\\n+  return NS_OK;\\n }\\n \\n NS_IMETHODIMP nsAccessible::SetParent(nsIAccessible *aParent)\\ndiff --git a/accessible/src/xul/nsXULMenuAccessible.cpp b/accessible/src/xul/nsXULMenuAccessible.cpp\\nindex 5e0d533..ce89a06 100644\\n--- a/accessible/src/xul/nsXULMenuAccessible.cpp\\n+++ b/accessible/src/xul/nsXULMenuAccessible.cpp\\n@@ -391,13 +391,18 @@ NS_IMETHODIMP nsXULMenuitemAccessible::GetDescription(nsAString& aDescription)\\n }\\n \\n //return menu accesskey: N or Alt+F\\n-NS_IMETHODIMP nsXULMenuitemAccessible::GetKeyboardShortcut(nsAString& _retval)\\n+NS_IMETHODIMP\\n+nsXULMenuitemAccessible::GetKeyboardShortcut(nsAString& aAccessKey)\\n {\\n+  aAccessKey.Truncate();\\n+\\n   static PRInt32 gMenuAccesskeyModifier = -1;  // magic value of -1 indicates unitialized state\\n \\n   nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(mDOMNode));\\n   if (elt) {\\n     nsAutoString accesskey;\\n+    // We do not use nsAccUtils::GetAccesskeyFor() because accesskeys for\\n+    // menu are't registered by nsIEventStateManager.\\n     elt->GetAttribute(NS_LITERAL_STRING(\\\"accesskey\\\"), accesskey);\\n     if (accesskey.IsEmpty())\\n       return NS_OK;\\n@@ -423,11 +428,11 @@ NS_IMETHODIMP nsXULMenuitemAccessible::GetKeyboardShortcut(nsAString& _retval)\\n           case nsIDOMKeyEvent::DOM_VK_META: propertyKey.AssignLiteral(\\\"VK_META\\\"); break;\\n         }\\n         if (!propertyKey.IsEmpty())\\n-          nsAccessible::GetFullKeyName(propertyKey, accesskey, _retval);\\n+          nsAccessible::GetFullKeyName(propertyKey, accesskey, aAccessKey);\\n       }\\n     }\\n-    if (_retval.IsEmpty())\\n-      _retval = accesskey;\\n+    if (aAccessKey.IsEmpty())\\n+      aAccessKey = accesskey;\\n     return NS_OK;\\n   }\\n   return NS_ERROR_FAILURE;\\ndiff --git a/content/events/public/nsIEventStateManager.h b/content/events/public/nsIEventStateManager.h\\nindex 7f30f1f..24afac8 100644\\n--- a/content/events/public/nsIEventStateManager.h\\n+++ b/content/events/public/nsIEventStateManager.h\\n@@ -54,8 +54,8 @@ class imgIContainer;\\n  */\\n // {fb7516ff-2f01-4893-84e8-e4b282813023}\\n #define NS_IEVENTSTATEMANAGER_IID \\\\\\n-{ 0xfb7516ff, 0x2f01, 0x4893, \\\\\\n-  { 0x84, 0xe8, 0xe4, 0xb2, 0x82, 0x81, 0x30, 0x23 } }\\n+{ 0x522d12ec, 0xde51, 0x4635, \\\\\\n+  { 0xb0, 0x10, 0x4, 0x2a, 0x6d, 0x5, 0xa0, 0x3e } }\\n \\n #define NS_EVENT_NEEDS_FRAME(event) (!NS_IS_FOCUS_EVENT(event))\\n \\n@@ -132,9 +132,33 @@ public:\\n   NS_IMETHOD ChangeFocusWith(nsIContent *aFocusContent, EFocusedWithType aFocusedWith) = 0;\\n \\n   // Access Key Registration\\n+\\n+  /**\\n+   * Register accesskey on the given element. When accesskey is activated then\\n+   * the element will be notified via nsIContent::PerformAccesskey() method.\\n+   *\\n+   * @param  aContent  the given element\\n+   * @param  aKey      accesskey\\n+   */\\n   NS_IMETHOD RegisterAccessKey(nsIContent* aContent, PRUint32 aKey) = 0;\\n+\\n+  /**\\n+   * Unregister accesskey for the given element.\\n+   *\\n+   * @param  aContent  the given element\\n+   * @param  aKey      accesskey\\n+   */\\n   NS_IMETHOD UnregisterAccessKey(nsIContent* aContent, PRUint32 aKey) = 0;\\n \\n+  /**\\n+   * Get accesskey registered on the given element or 0 if there is none.\\n+   *\\n+   * @param  aContent  the given element\\n+   * @param  aKey      registered accesskey\\n+   * @return           NS_OK\\n+   */\\n+  NS_IMETHOD GetRegisteredAccessKey(nsIContent* aContent, PRUint32* aKey) = 0;\\n+\\n   NS_IMETHOD SetCursor(PRInt32 aCursor, imgIContainer* aContainer,\\n                        PRBool aHaveHotspot, float aHotspotX, float aHotspotY,\\n                        nsIWidget* aWidget, PRBool aLockCursor) = 0;\\ndiff --git a/content/events/src/nsEventStateManager.cpp b/content/events/src/nsEventStateManager.cpp\\nindex 9b1482b..5d04ceb 100644\\n--- a/content/events/src/nsEventStateManager.cpp\\n+++ b/content/events/src/nsEventStateManager.cpp\\n@@ -179,6 +179,27 @@ enum {\\n  MOUSE_SCROLL_PIXELS\\n };\\n \\n+struct AccessKeyInfo {\\n+  PRUint32 mAccessKey;\\n+  nsIContent* mTarget;\\n+\\n+  AccessKeyInfo(nsIContent* aTarget) : mAccessKey(0), mTarget(aTarget) {}\\n+};\\n+\\n+static PRIntn PR_CALLBACK\\n+FindTargetForAccessKey(nsHashKey *aKey, void *aData, void* aClosure)\\n+{\\n+  AccessKeyInfo* info = static_cast<AccessKeyInfo*>(aClosure);\\n+  nsIContent* aTarget = static_cast<nsIContent*>(aData);\\n+\\n+  if (aTarget == info->mTarget) {\\n+    info->mAccessKey = aKey->HashCode();\\n+    return kHashEnumerateStop;\\n+  }\\n+\\n+  return kHashEnumerateNext;\\n+}\\n+\\n // mask values for ui.key.chromeAccess and ui.key.contentAccess\\n #define NS_MODIFIER_SHIFT    1\\n #define NS_MODIFIER_CONTROL  2\\n@@ -4659,6 +4680,8 @@ nsEventStateManager::RegisterAccessKey(nsIContent* aContent, PRUint32 aKey)\\n     PRUint32 accKey = (IS_IN_BMP(aKey)) ? ToLowerCase((PRUnichar)aKey) : aKey;\\n \\n     nsVoidKey key(NS_INT32_TO_PTR(accKey));\\n+    NS_ASSERTION(key.HashCode() == accKey,\\n+                 \\\"nsHashKey::HashCode() doesn't return an accesskey\\\");\\n \\n #ifdef DEBUG_jag\\n     nsCOMPtr<nsIContent> oldContent = dont_AddRef(static_cast<nsIContent*>(mAccessKeys->Get(&key)));\\n@@ -4694,6 +4717,24 @@ nsEventStateManager::UnregisterAccessKey(nsIContent* aContent, PRUint32 aKey)\\n   return NS_OK;\\n }\\n \\n+NS_IMETHODIMP\\n+nsEventStateManager::GetRegisteredAccessKey(nsIContent* aContent,\\n+                                            PRUint32* aKey)\\n+{\\n+  NS_ENSURE_ARG(aContent);\\n+  NS_ENSURE_ARG_POINTER(aKey);\\n+  *aKey = 0;\\n+\\n+  if (!mAccessKeys)\\n+    return NS_OK;\\n+\\n+  AccessKeyInfo info(aContent);\\n+  mAccessKeys->Enumerate(FindTargetForAccessKey, &info);\\n+\\n+  *aKey = info.mAccessKey;\\n+  return NS_OK;\\n+}\\n+\\n void\\n nsEventStateManager::ForceViewUpdate(nsIView* aView)\\n {\\ndiff --git a/content/events/src/nsEventStateManager.h b/content/events/src/nsEventStateManager.h\\nindex b87e723..d66c7d2 100644\\n--- a/content/events/src/nsEventStateManager.h\\n+++ b/content/events/src/nsEventStateManager.h\\n@@ -127,6 +127,7 @@ public:\\n   // Access Key Registration\\n   NS_IMETHOD RegisterAccessKey(nsIContent* aContent, PRUint32 aKey);\\n   NS_IMETHOD UnregisterAccessKey(nsIContent* aContent, PRUint32 aKey);\\n+  NS_IMETHOD GetRegisteredAccessKey(nsIContent* aContent, PRUint32* aKey);\\n \\n   NS_IMETHOD SetCursor(PRInt32 aCursor, imgIContainer* aContainer,\\n                        PRBool aHaveHotspot, float aHotspotX, float aHotspotY,\\n\""}