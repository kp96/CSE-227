{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basa957173\""},"diff":"\"a957173 Bug 397112. Crash [@ nsAccessible::GetFirstChild] moving text out of an option. Patch by Alexander Surkov and Mats Palmgren. r=aaronlev\\ndiff --git a/accessible/public/nsPIAccessible.idl b/accessible/public/nsPIAccessible.idl\\nindex 893be0a..53c3288 100644\\n--- a/accessible/public/nsPIAccessible.idl\\n+++ b/accessible/public/nsPIAccessible.idl\\n@@ -41,7 +41,7 @@\\n interface nsIAccessible;\\n interface nsIAccessibleEvent;\\n \\n-[uuid(03932812-53d1-4dc7-965d-6b6ad8a872b1)]\\n+[uuid(af05f83c-6fd2-48c1-b1c3-811857472421)]\\n interface nsPIAccessible : nsISupports\\n {\\n   /**\\n@@ -65,6 +65,11 @@ interface nsPIAccessible : nsISupports\\n   void getCachedParent(out nsIAccessible aAccParent);\\n \\n   /**\\n+   * Return first child accessible only if cached.\\n+   */\\n+  void getCachedFirstChild(out nsIAccessible aAccFirstChild);\\n+\\n+  /**\\n    * Set the child count to -1 (unknown) and null out cached child pointers\\n    */\\n   void invalidateChildren();\\ndiff --git a/accessible/src/base/nsAccessible.cpp b/accessible/src/base/nsAccessible.cpp\\nindex ed9b9d0..a00e854 100644\\n--- a/accessible/src/base/nsAccessible.cpp\\n+++ b/accessible/src/base/nsAccessible.cpp\\n@@ -444,6 +444,16 @@ nsAccessible::GetKeyboardShortcut(nsAString& aAccessKey)\\n \\n NS_IMETHODIMP nsAccessible::SetParent(nsIAccessible *aParent)\\n {\\n+#ifdef DEBUG\\n+  if (aParent && aParent != mParent) {\\n+    nsCOMPtr<nsPIAccessible> privParent = do_QueryInterface(mParent);\\n+    if (privParent) {\\n+      nsCOMPtr<nsIAccessible> firstChild;\\n+      privParent->GetCachedFirstChild(getter_AddRefs(firstChild));\\n+      NS_ASSERTION(firstChild != this, \\\"Reparenting other node's first child!\\\");\\n+    }\\n+  }\\n+#endif\\n   mParent = aParent;\\n   return NS_OK;\\n }\\n@@ -588,6 +598,17 @@ NS_IMETHODIMP nsAccessible::GetCachedParent(nsIAccessible **  aParent)\\n   return NS_OK;\\n }\\n \\n+NS_IMETHODIMP nsAccessible::GetCachedFirstChild(nsIAccessible **  aFirstChild)\\n+{\\n+  *aFirstChild = nsnull;\\n+  if (!mWeakShell) {\\n+    // This node has been shut down\\n+    return NS_ERROR_FAILURE;\\n+  }\\n+  NS_IF_ADDREF(*aFirstChild = mFirstChild);\\n+  return NS_OK;\\n+}\\n+\\n   /* readonly attribute nsIAccessible nextSibling; */\\n NS_IMETHODIMP nsAccessible::GetNextSibling(nsIAccessible * *aNextSibling) \\n { \\n@@ -655,6 +676,16 @@ NS_IMETHODIMP nsAccessible::GetFirstChild(nsIAccessible * *aFirstChild)\\n   PRInt32 numChildren;\\n   GetChildCount(&numChildren);  // Make sure we cache all of the children\\n \\n+#ifdef DEBUG\\n+  nsCOMPtr<nsPIAccessible> firstChild(do_QueryInterface(mFirstChild));\\n+  if (firstChild) {\\n+    nsCOMPtr<nsIAccessible> realParent;\\n+    firstChild->GetCachedParent(getter_AddRefs(realParent));\\n+    NS_ASSERTION(!realParent || realParent == this,\\n+                 \\\"Two accessibles have the same first child accessible.\\\");\\n+  }\\n+#endif\\n+\\n   NS_IF_ADDREF(*aFirstChild = mFirstChild);\\n \\n   return NS_OK;  \\ndiff --git a/accessible/src/base/nsDocAccessible.cpp b/accessible/src/base/nsDocAccessible.cpp\\nindex be72aba..56a4971 100644\\n--- a/accessible/src/base/nsDocAccessible.cpp\\n+++ b/accessible/src/base/nsDocAccessible.cpp\\n@@ -1549,6 +1549,15 @@ NS_IMETHODIMP nsDocAccessible::FlushPendingEvents()\\n     accessibleEvent->GetEventType(&eventType);\\n     if (eventType == nsIAccessibleEvent::EVENT_DOM_CREATE || \\n         eventType == nsIAccessibleEvent::EVENT_ASYNCH_SHOW) {\\n+      nsCOMPtr<nsIAccessible> containerAccessible;\\n+      if (accessible) {\\n+        accessible->GetParent(getter_AddRefs(containerAccessible));\\n+        nsCOMPtr<nsPIAccessible> privateContainerAccessible =\\n+          do_QueryInterface(containerAccessible);\\n+        if (privateContainerAccessible)\\n+          privateContainerAccessible->InvalidateChildren();\\n+      }\\n+\\n       // Also fire text changes if the node being created could affect the text in an nsIAccessibleText parent.\\n       // When a node is being made visible or is inserted, the text in an ancestor hyper text will gain characters\\n       // At this point we now have the frame and accessible for this node if there is one. That is why we\\n@@ -1557,8 +1566,10 @@ NS_IMETHODIMP nsDocAccessible::FlushPendingEvents()\\n       nsCOMPtr<nsIDOMNode> domNode;\\n       accessibleEvent->GetDOMNode(getter_AddRefs(domNode));\\n       if (domNode && domNode != mDOMNode) {\\n-        nsCOMPtr<nsIAccessible> containerAccessible;\\n-        GetAccessibleInParentChain(domNode, getter_AddRefs(containerAccessible));\\n+        if (!containerAccessible)\\n+          GetAccessibleInParentChain(domNode,\\n+                                     getter_AddRefs(containerAccessible));\\n+\\n         nsCOMPtr<nsIAccessibleTextChangeEvent> textChangeEvent =\\n           CreateTextChangeEventForNode(containerAccessible, domNode, accessible, PR_TRUE, PR_TRUE);\\n         if (textChangeEvent) {\\n@@ -1831,11 +1842,6 @@ NS_IMETHODIMP nsDocAccessible::InvalidateCacheSubtree(nsIContent *aChild,\\n   // and there is always one of those.\\n \\n   if (aChild && !isHiding) {\\n-    nsCOMPtr<nsPIAccessible> privateContainerAccessible =\\n-      do_QueryInterface(containerAccessible);\\n-    if (privateContainerAccessible) {\\n-      privateContainerAccessible->InvalidateChildren();\\n-    }\\n     // Fire EVENT_SHOW, EVENT_MENUPOPUP_START for newly visible content.\\n     // Fire after a short timer, because we want to make sure the view has been\\n     // updated to make this accessible content visible. If we don't wait,\\n\""}