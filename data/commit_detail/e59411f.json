{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Base59411f\""},"diff":"\"e59411f Bug 382194 - Remove an assertion in nsMenuX, clean up native menu code. r=joshmoz sr=pavlov\\ndiff --git a/widget/public/nsIMenu.h b/widget/public/nsIMenu.h\\nindex 664312d..bc6af85 100644\\n--- a/widget/public/nsIMenu.h\\n+++ b/widget/public/nsIMenu.h\\n@@ -51,11 +51,10 @@ class nsIContent;\\n class nsIMenuCommandDispatcher;\\n \\n \\n-// {FC5BCA9C-4494-4C0F-BEFD-CB31BEBA1531}\\n+// a0aa02c5-5549-4228-8514-1083c6e8aa5d\\n #define NS_IMENU_IID \\\\\\n-{ 0xFC5BCA9C, 0x4494, 0x4C0F, \\\\\\n-  { 0xBE, 0xFD, 0xCB, 0x31, 0xBE, 0xBA, 0x15, 0x31 } }\\n-\\n+{ 0xa0aa02c5, 0x5549, 0x4228, \\\\\\n+  { 0x85, 0x14, 0x10, 0x83, 0xc6, 0xe8, 0xaa, 0x5d } }\\n \\n /**\\n  * Menu widget\\n@@ -129,17 +128,31 @@ class nsIMenu : public nsISupports {\\n     NS_IMETHOD AddSeparator() = 0;\\n \\n    /**\\n-    * Returns the number of menu items\\n+    * Returns the number of visible menu items\\n     * This includes separators. It does not include hidden items.\\n     *\\n     */\\n-    NS_IMETHOD GetItemCount(PRUint32 &aCount) = 0;\\n+    NS_IMETHOD GetVisibleItemCount(PRUint32 &aCount) = 0;\\n \\n    /**\\n     * Returns a Menu or Menu Item at a specified Index.\\n     * This includes separators. It does not include hidden items.\\n     *\\n     */\\n+    NS_IMETHOD GetVisibleItemAt(const PRUint32 aPos, nsISupports *& aMenuItem) = 0;\\n+\\n+   /**\\n+    * Returns the number of menu items\\n+    * This includes separators. It -does- include hidden items.\\n+    *\\n+    */\\n+    NS_IMETHOD GetItemCount(PRUint32 &aCount) = 0;\\n+\\n+   /**\\n+    * Returns a Menu or Menu Item at a specified Index.\\n+    * This includes separators. It -does- include hidden items.\\n+    *\\n+    */\\n     NS_IMETHOD GetItemAt(const PRUint32 aPos, nsISupports *& aMenuItem) = 0;\\n \\n    /**\\ndiff --git a/widget/src/cocoa/nsMenuX.h b/widget/src/cocoa/nsMenuX.h\\nindex 6b32db7..7407ec0 100644\\n--- a/widget/src/cocoa/nsMenuX.h\\n+++ b/widget/src/cocoa/nsMenuX.h\\n@@ -106,6 +106,8 @@ public:\\n     NS_IMETHOD AddSeparator();\\n     NS_IMETHOD GetItemCount(PRUint32 &aCount);\\n     NS_IMETHOD GetItemAt(const PRUint32 aPos, nsISupports *& aMenuItem);\\n+    NS_IMETHOD GetVisibleItemCount(PRUint32 &aCount);\\n+    NS_IMETHOD GetVisibleItemAt(const PRUint32 aPos, nsISupports *& aMenuItem);\\n     NS_IMETHOD InsertItemAt(const PRUint32 aPos, nsISupports * aMenuItem);\\n     NS_IMETHOD RemoveItem(const PRUint32 aPos);\\n     NS_IMETHOD RemoveAll();\\n@@ -149,7 +151,7 @@ protected:\\n protected:\\n     nsString                    mLabel;\\n     nsCOMArray<nsISupports>     mMenuItemsArray;\\n-    nsCOMArray<nsISupports>     mHiddenMenuItemsArray;\\n+    PRUint32                    mVisibleItemsCount;     // caching number of visible items in mMenuItemsArray\\n \\n     nsISupports*                mParent;                // weak, my parent owns me\\n     nsIChangeManager*           mManager;               // weak ref, it will outlive us [menubar]\\ndiff --git a/widget/src/cocoa/nsMenuX.mm b/widget/src/cocoa/nsMenuX.mm\\nindex e2e5938..de61df8 100644\\n--- a/widget/src/cocoa/nsMenuX.mm\\n+++ b/widget/src/cocoa/nsMenuX.mm\\n@@ -106,10 +106,10 @@ NS_IMPL_ISUPPORTS4(nsMenuX, nsIMenu, nsIMenuListener, nsIChangeObserver, nsISupp\\n \\n \\n nsMenuX::nsMenuX()\\n-: mParent(nsnull), mManager(nsnull), mMacMenuID(0), mMacMenu(nil), mNativeMenuItem(nil),\\n-  mIsEnabled(PR_TRUE), mDestroyHandlerCalled(PR_FALSE),\\n-  mNeedsRebuild(PR_TRUE), mConstructed(PR_FALSE), mVisible(PR_TRUE),\\n-  mXBLAttached(PR_FALSE)\\n+: mVisibleItemsCount(0), mParent(nsnull), mManager(nsnull), mMacMenuID(0), \\n+  mMacMenu(nil), mNativeMenuItem(nil), mIsEnabled(PR_TRUE),\\n+  mDestroyHandlerCalled(PR_FALSE), mNeedsRebuild(PR_TRUE),\\n+  mConstructed(PR_FALSE), mVisible(PR_TRUE), mXBLAttached(PR_FALSE)\\n {\\n   mMenuDelegate = [[MenuDelegate alloc] initWithGeckoMenu:this];\\n     \\n@@ -253,14 +253,11 @@ nsresult nsMenuX::AddMenuItem(nsIMenuItem * aMenuItem)\\n \\n   nsCOMPtr<nsIContent> menuItemContent;\\n   aMenuItem->GetMenuItemContent(getter_AddRefs(menuItemContent));\\n-  if (menuItemContent && NodeIsHiddenOrCollapsed(menuItemContent)) {\\n-    mHiddenMenuItemsArray.AppendObject(aMenuItem); // owning ref\\n+  mMenuItemsArray.AppendObject(aMenuItem); // owning ref\\n+  if (menuItemContent && NodeIsHiddenOrCollapsed(menuItemContent))\\n     return NS_OK;\\n-  }\\n-  else {\\n-    mMenuItemsArray.AppendObject(aMenuItem); // owning ref\\n-  }\\n-\\n+  ++mVisibleItemsCount;\\n+ \\n   // add the menu item to this menu\\n   NSMenuItem* newNativeMenuItem;\\n   aMenuItem->GetNativeData((void*&)newNativeMenuItem);\\n@@ -293,13 +290,10 @@ nsresult nsMenuX::AddMenu(nsIMenu * aMenu)\\n \\n   nsCOMPtr<nsIContent> menuContent;\\n   aMenu->GetMenuContent(getter_AddRefs(menuContent));\\n-  if (menuContent && NodeIsHiddenOrCollapsed(menuContent)) {\\n-    mHiddenMenuItemsArray.AppendObject(aMenu); // owning ref\\n+  mMenuItemsArray.AppendObject(aMenu); // owning ref\\n+  if (menuContent && NodeIsHiddenOrCollapsed(menuContent))\\n     return NS_OK;\\n-  }\\n-  else {\\n-    mMenuItemsArray.AppendObject(aMenu); // owning ref\\n-  }\\n+  ++mVisibleItemsCount;\\n \\n   // We have to add a menu item and then associate the menu with it\\n   NSMenuItem* newNativeMenuItem = (static_cast<nsMenuX*>(aMenu))->GetNativeMenuItem();\\n@@ -320,11 +314,13 @@ NS_IMETHODIMP nsMenuX::AddSeparator()\\n   // We're not really appending an nsMenuItem but a placeholder needs to be\\n   // here to make sure that event dispatching isn't off by one.\\n   mMenuItemsArray.AppendObject(&gDummyMenuItemX);  // owning ref\\n+  ++mVisibleItemsCount;\\n   [mMacMenu addItem:[NSMenuItem separatorItem]];\\n   return NS_OK;\\n }\\n \\n \\n+// Includes all items, including hidden/collapsed ones\\n NS_IMETHODIMP nsMenuX::GetItemCount(PRUint32 &aCount)\\n {\\n   aCount = mMenuItemsArray.Count();\\n@@ -332,14 +328,82 @@ NS_IMETHODIMP nsMenuX::GetItemCount(PRUint32 &aCount)\\n }\\n \\n \\n+// Includes all items, including hidden/collapsed ones\\n NS_IMETHODIMP nsMenuX::GetItemAt(const PRUint32 aPos, nsISupports *& aMenuItem)\\n {\\n+  if (aPos >= (PRUint32)mMenuItemsArray.Count())\\n+    return NS_ERROR_INVALID_ARG;\\n+\\n   aMenuItem = mMenuItemsArray.ObjectAt(aPos);\\n   NS_IF_ADDREF(aMenuItem);\\n   return NS_OK;\\n }\\n \\n \\n+// Checks both nsIMenus and nsIMenuItems. Not suitable for menus that are children\\n+// of nsIMenuBar, which has slightly different rules for visiblity.\\n+static PRBool MenuNodeIsVisible(nsISupports *item)\\n+{\\n+  // Find the content for this item in the menu, be it a MenuItem or a Menu\\n+  nsCOMPtr<nsIContent> itemContent;\\n+  nsCOMPtr<nsIMenuItem> menuItem = do_QueryInterface(item);\\n+  if (menuItem)\\n+    menuItem->GetMenuItemContent(getter_AddRefs(itemContent));\\n+  else {\\n+    nsCOMPtr<nsIMenu> menu = do_QueryInterface(item);\\n+    if (menu)\\n+      menu->GetMenuContent(getter_AddRefs(itemContent));\\n+  }\\n+  \\n+  // Check the visibility of the item's content\\n+  return (itemContent && !NodeIsHiddenOrCollapsed(itemContent));\\n+}\\n+\\n+\\n+// Only includes visible items\\n+NS_IMETHODIMP nsMenuX::GetVisibleItemCount(PRUint32 &aCount)\\n+{\\n+  aCount = mVisibleItemsCount;\\n+  return NS_OK;\\n+}\\n+\\n+\\n+// Only includes visible items. Note that this is provides O(N) access\\n+// If you need to iterate or search, consider using GetItemAt and doing your own filtering\\n+NS_IMETHODIMP nsMenuX::GetVisibleItemAt(const PRUint32 aPos, nsISupports *& aMenuItem)\\n+{\\n+  PRUint32 count = mMenuItemsArray.Count();\\n+  if (aPos >= mVisibleItemsCount || aPos >= count)\\n+    return NS_ERROR_INVALID_ARG;\\n+\\n+  // If there are no invisible items, can provide direct access\\n+  if (mVisibleItemsCount == count) {\\n+    nsCOMPtr<nsISupports> item = mMenuItemsArray.ObjectAt(aPos);\\n+    aMenuItem = item;\\n+    NS_IF_ADDREF(aMenuItem);\\n+    return NS_OK;\\n+  }\\n+\\n+  // Otherwise, traverse the array until we find the the item we're looking for.\\n+  nsCOMPtr<nsISupports> item;\\n+  PRUint32 visibleNodeIndex = 0;\\n+  for (PRUint32 i = 0; i < count; i++) {\\n+    item = mMenuItemsArray.ObjectAt(i);\\n+    if (MenuNodeIsVisible(item)) {\\n+      if (aPos == visibleNodeIndex) {\\n+        // we found the visible node we're looking for, return it\\n+        aMenuItem = item;\\n+        NS_IF_ADDREF(aMenuItem);\\n+        return NS_OK;\\n+      }\\n+      visibleNodeIndex++;\\n+    }\\n+  }\\n+\\n+  return NS_ERROR_FAILURE;\\n+}\\n+\\n+\\n NS_IMETHODIMP nsMenuX::InsertItemAt(const PRUint32 aPos, nsISupports * aMenuItem)\\n {\\n   return NS_ERROR_NOT_IMPLEMENTED;\\n@@ -367,7 +431,7 @@ NS_IMETHODIMP nsMenuX::RemoveAll()\\n   }\\n   // get rid of Gecko menu items\\n   mMenuItemsArray.Clear();\\n-  mHiddenMenuItemsArray.Clear();\\n+  mVisibleItemsCount = 0;\\n   \\n   return NS_OK;\\n }\\n@@ -707,12 +771,8 @@ void nsMenuX::LoadSeparator(nsIContent* inSeparatorContent)\\n }\\n \\n \\n-//\\n-// OnCreate\\n-//\\n // Fire our oncreate handler. Returns TRUE if we should keep processing the event,\\n // FALSE if the handler wants to stop the creation of the menu\\n-//\\n PRBool nsMenuX::OnCreate()\\n {\\n   nsEventStatus status = nsEventStatus_eIgnore;\\n@@ -818,12 +878,8 @@ PRBool nsMenuX::OnCreated()\\n }\\n \\n \\n-//\\n-// OnDestroy\\n-//\\n // Fire our ondestroy handler. Returns TRUE if we should keep processing the event,\\n // FALSE if the handler wants to stop the destruction of the menu\\n-//\\n PRBool nsMenuX::OnDestroy()\\n {\\n   if (mDestroyHandlerCalled)\\n@@ -883,13 +939,9 @@ PRBool nsMenuX::OnDestroyed()\\n }\\n \\n \\n-//\\n-// GetMenuPopupContent\\n-//\\n // Find the |menupopup| child in the |popup| representing this menu. It should be one\\n // of a very few children so we won't be iterating over a bazillion menu items to find\\n // it (so the strcmp won't kill us).\\n-//\\n void nsMenuX::GetMenuPopupContent(nsIContent** aResult)\\n {\\n   if (!aResult)\\n@@ -915,52 +967,69 @@ void nsMenuX::GetMenuPopupContent(nsIContent** aResult)\\n     }\\n   }\\n \\n-} // GetMenuPopupContent\\n+}\\n \\n \\n-//\\n-// CountVisibleBefore\\n-//\\n // Determines how many menus are visible among the siblings that are before me.\\n // It doesn't matter if I am visible. Note that this will always count the\\n // Application menu, since we always put it in there.\\n-//\\n nsresult nsMenuX::CountVisibleBefore(PRUint32* outVisibleBefore)\\n {\\n   NS_ASSERTION(outVisibleBefore, \\\"bad index param in nsMenuX::CountVisibleBefore\\\");\\n   \\n   nsCOMPtr<nsIMenuBar> menubarParent = do_QueryInterface(mParent);\\n-  if (!menubarParent)\\n-    return NS_ERROR_FAILURE;\\n-\\n-  PRUint32 numMenus = 0;\\n-  menubarParent->GetMenuCount(numMenus);\\n+  if (menubarParent) {\\n+    PRUint32 numMenus = 0;\\n+    menubarParent->GetMenuCount(numMenus);\\n+    \\n+    // Find this menu among the children of my parent menubar\\n+    *outVisibleBefore = 1; // start at 1, the Application menu will always be there\\n+    for (PRUint32 i = 0; i < numMenus; i++) {\\n+      nsCOMPtr<nsIMenu> currMenu;\\n+      menubarParent->GetMenuAt(i, *getter_AddRefs(currMenu));\\n+      if (currMenu == static_cast<nsIMenu*>(this)) {\\n+        // we found ourselves, break out\\n+        return NS_OK;\\n+      }\\n   \\n-  // Find this menu among the children of my parent menubar\\n-  PRBool gotThisMenu = PR_FALSE;\\n-  *outVisibleBefore = 1; // start at 1, the Application menu will always be there\\n-  for (PRUint32 i = 0; i < numMenus; i++) {\\n-    nsCOMPtr<nsIMenu> currMenu;\\n-    menubarParent->GetMenuAt(i, *getter_AddRefs(currMenu));\\n-    if (currMenu == static_cast<nsIMenu*>(this)) {\\n-      // we found ourselves, break out\\n-      gotThisMenu = PR_TRUE;\\n-      break;\\n+      if (currMenu) {\\n+        nsCOMPtr<nsIContent> menuContent;\\n+        currMenu->GetMenuContent(getter_AddRefs(menuContent));\\n+        if (menuContent &&\\n+            menuContent->GetChildCount() > 0 &&\\n+            !NodeIsHiddenOrCollapsed(menuContent)) {\\n+          ++(*outVisibleBefore);\\n+        }\\n+      }\\n     }\\n+  } // if menubarParent\\n+  else {\\n+    nsCOMPtr<nsIMenu> menuParent = do_QueryInterface(mParent);\\n+    if (!menuParent)\\n+      return NS_ERROR_FAILURE;\\n+\\n+    PRUint32 numItems;\\n+    menuParent->GetItemCount(numItems);\\n+\\n+    // Find this menu among the children of my parent menu\\n+    for (PRUint32 i = 0; i < numItems; i++) {\\n+      // Using GetItemAt instead of GetVisibleItemAt to avoid O(N^2)\\n+      nsCOMPtr<nsISupports> currItem;\\n+      menuParent->GetItemAt(i, *getter_AddRefs(currItem));\\n+      nsCOMPtr<nsIMenu> currMenu = do_QueryInterface(currItem);\\n+      if (currMenu == static_cast<nsIMenu*>(this)) {\\n+        // we found ourselves, break out\\n+        return NS_OK;\\n+      }\\n \\n-    if (currMenu) {\\n-      nsCOMPtr<nsIContent> menuContent;\\n-      currMenu->GetMenuContent(getter_AddRefs(menuContent));\\n-      if (menuContent &&\\n-          menuContent->GetChildCount() > 0 &&\\n-          !NodeIsHiddenOrCollapsed(menuContent)) {\\n+      // If the node is visible increment the outparam.\\n+      if (MenuNodeIsVisible(currItem))\\n         ++(*outVisibleBefore);\\n-      }\\n+      \\n     }\\n   }\\n-\\n-  return gotThisMenu ? NS_OK : NS_ERROR_FAILURE;\\n-} // CountVisibleBefore\\n+  return NS_ERROR_FAILURE;\\n+}\\n \\n \\n NS_IMETHODIMP\\n@@ -979,14 +1048,22 @@ nsMenuX::GetMenuRefAndItemIndexForMenuItem(nsISupports* aMenuItem,\\n   if (!mMacMenu)\\n     return NS_ERROR_FAILURE;\\n   \\n-  // look for the menu item given\\n-  PRUint32 menuItemCount = mMenuItemsArray.Count();\\n+  // look for the menu item given, and skip invisible elements\\n+  PRUint32 menuItemCount;\\n+  GetItemCount(menuItemCount);\\n+  PRUint32 visibleNodeIndex = 0;\\n   for (PRUint32 i = 0; i < menuItemCount; i++) {\\n-    nsCOMPtr<nsISupports> currItem = mMenuItemsArray.ObjectAt(i);\\n-    if (currItem == aMenuItem) {   \\n-      *aMenuRef = _NSGetCarbonMenu(mMacMenu);\\n-      *aMenuItemIndex = i + 1;\\n-      return NS_OK;\\n+    nsCOMPtr<nsISupports> currItem;\\n+    GetItemAt(i, *getter_AddRefs(currItem));\\n+    // Only check visible nodes\\n+    if (MenuNodeIsVisible(currItem)) {\\n+      if (currItem == aMenuItem) {\\n+        *aMenuRef = _NSGetCarbonMenu(mMacMenu);\\n+        // add 1 because carbon menu items are 1-indexed.\\n+        *aMenuItemIndex = visibleNodeIndex + 1;\\n+        return NS_OK;\\n+      }\\n+      visibleNodeIndex++;\\n     }\\n   }\\n   \\n@@ -1012,17 +1089,13 @@ NS_IMETHODIMP nsMenuX::AttributeChanged(nsIDocument *aDocument, PRInt32 aNameSpa\\n   // ignore the |open| attribute, which is by far the most common\\n   if (gConstructingMenu || (aAttribute == nsWidgetAtoms::open))\\n     return NS_OK;\\n-    \\n+\\n   nsCOMPtr<nsIMenuBar> menubarParent = do_QueryInterface(mParent);\\n \\n   if (aAttribute == nsWidgetAtoms::disabled) {\\n     SetRebuild(PR_TRUE);\\n-   \\n-    if (mMenuContent->AttrValueIs(kNameSpaceID_None, nsWidgetAtoms::disabled,\\n-                                  nsWidgetAtoms::_true, eCaseMatters))\\n-      SetEnabled(PR_FALSE);\\n-    else\\n-      SetEnabled(PR_TRUE);\\n+    SetEnabled(!mMenuContent->AttrValueIs(kNameSpaceID_None, nsWidgetAtoms::disabled,\\n+                                          nsWidgetAtoms::_true, eCaseMatters));\\n   }\\n   else if (aAttribute == nsWidgetAtoms::label) {\\n     SetRebuild(PR_TRUE);\\n@@ -1048,59 +1121,48 @@ NS_IMETHODIMP nsMenuX::AttributeChanged(nsIDocument *aDocument, PRInt32 aNameSpa\\n   else if (aAttribute == nsWidgetAtoms::hidden || aAttribute == nsWidgetAtoms::collapsed) {\\n     SetRebuild(PR_TRUE);\\n \\n-    if (NodeIsHiddenOrCollapsed(mMenuContent)) {\\n-      if (mVisible) {\\n-        if (menubarParent) {\\n-          PRUint32 indexToRemove = 0;\\n-          if (NS_SUCCEEDED(CountVisibleBefore(&indexToRemove))) {\\n-            void *clientData = nsnull;\\n-            menubarParent->GetNativeData(clientData);\\n-            if (clientData) {\\n-              NSMenu* menubar = reinterpret_cast<NSMenu*>(clientData);\\n-              [menubar removeItemAtIndex:indexToRemove];\\n-              mVisible = PR_FALSE;\\n-            }\\n-          }\\n-        } // if on the menubar\\n-        else {\\n-          // hide this submenu\\n-          NS_ASSERTION(PR_FALSE, \\\"nsMenuX::AttributeChanged: WRITE HIDE CODE FOR SUBMENU.\\\");\\n-        }\\n-      } // if visible\\n-      else\\n-        NS_WARNING(\\\"You're hiding the menu twice, please stop\\\");\\n-    } // if told to hide menu\\n+    PRBool contentIsHiddenOrCollapsed = NodeIsHiddenOrCollapsed(mMenuContent);\\n+\\n+    // don't do anything if the state is correct already\\n+    if (contentIsHiddenOrCollapsed != mVisible)\\n+      return NS_OK;\\n+\\n+    nsCOMPtr<nsIMenu> menuParent = do_QueryInterface(mParent);\\n+    if (contentIsHiddenOrCollapsed) {\\n+      void *clientData = nsnull;\\n+      if (menubarParent)\\n+        menubarParent->GetNativeData(clientData);\\n+      else if (menuParent)\\n+        menuParent->GetNativeData(&clientData);\\n+      if (clientData) {\\n+        NSMenu* parentMenu = reinterpret_cast<NSMenu*>(clientData);\\n+        [parentMenu removeItem:mNativeMenuItem];\\n+        mVisible = PR_FALSE;\\n+      }\\n+    }\\n     else {\\n-      if (!mVisible) {\\n-        if (menubarParent) {\\n-          PRUint32 insertAfter = 0;\\n-          if (NS_SUCCEEDED(CountVisibleBefore(&insertAfter))) {\\n-            void *clientData = nsnull;\\n-            menubarParent->GetNativeData(clientData);\\n-            if (clientData) {\\n-              NSMenu* menubar = reinterpret_cast<NSMenu*>(clientData);\\n-              // Shove this menu into its rightful place in the menubar. It doesn't matter\\n-              // what title we pass to InsertMenuItem() because when we stuff the actual menu\\n-              // handle in, the correct title goes with it.\\n-              [menubar insertItemWithTitle:@\\\"placeholder\\\" action:nil keyEquivalent:@\\\"\\\" atIndex:insertAfter];\\n-              [[menubar itemAtIndex:insertAfter] setSubmenu:mMacMenu];\\n-              mVisible = PR_TRUE;\\n-            }\\n-          }\\n-        } // if on menubar\\n-        else {\\n-          // show this submenu\\n-          NS_ASSERTION(PR_FALSE, \\\"nsMenuX::AttributeChanged: WRITE SHOW CODE FOR SUBMENU.\\\");\\n+      PRUint32 insertAfter = 0;\\n+      if (NS_SUCCEEDED(CountVisibleBefore(&insertAfter))) {\\n+        void *clientData = nsnull;\\n+        if (menubarParent)\\n+          menubarParent->GetNativeData(clientData);\\n+        else if (menuParent)\\n+          menuParent->GetNativeData(&clientData);\\n+        if (clientData) {\\n+          NSMenu* parentMenu = reinterpret_cast<NSMenu*>(clientData);\\n+          [parentMenu insertItem:mNativeMenuItem atIndex:insertAfter];\\n+          [mNativeMenuItem setSubmenu:mMacMenu];\\n+          mVisible = PR_TRUE;\\n         }\\n-      } // if not visible\\n-    } // if told to show menu\\n+      }\\n+    }\\n   }\\n   else if (aAttribute == nsWidgetAtoms::image) {\\n     SetupIcon();\\n   }  \\n \\n   return NS_OK;\\n-} // AttributeChanged\\n+}\\n \\n \\n NS_IMETHODIMP nsMenuX::ContentRemoved(nsIDocument *aDocument, nsIContent *aChild,\\n@@ -1115,7 +1177,7 @@ NS_IMETHODIMP nsMenuX::ContentRemoved(nsIDocument *aDocument, nsIContent *aChild\\n   mManager->Unregister(aChild);\\n \\n   return NS_OK;\\n-} // ContentRemoved\\n+}\\n \\n \\n NS_IMETHODIMP nsMenuX::ContentInserted(nsIDocument *aDocument, nsIContent *aChild,\\n@@ -1127,7 +1189,7 @@ NS_IMETHODIMP nsMenuX::ContentInserted(nsIDocument *aDocument, nsIContent *aChil\\n   SetRebuild(PR_TRUE);\\n   \\n   return NS_OK;\\n-} // ContentInserted\\n+}\\n \\n \\n NS_IMETHODIMP\\n@@ -1158,12 +1220,12 @@ static pascal OSStatus MyMenuEventHandler(EventHandlerCallRef myHandler, EventRe\\n     // this might happen just due to some random quirks in the event system\\n     PRUint32 itemCount;\\n     nsIMenu* targetMenu = reinterpret_cast<nsIMenu*>(userData);\\n-    targetMenu->GetItemCount(itemCount);\\n+    targetMenu->GetVisibleItemCount(itemCount);\\n     if (aPos >= itemCount)\\n       return eventNotHandledErr;\\n     \\n-    nsISupports* aTargetMenuItem;\\n-    targetMenu->GetItemAt((PRUint32)aPos, aTargetMenuItem);\\n+    nsCOMPtr<nsISupports> aTargetMenuItem;\\n+    targetMenu->GetVisibleItemAt((PRUint32)aPos, *getter_AddRefs(aTargetMenuItem));\\n     \\n     // Send DOM event\\n     // If the QI fails, we're over a submenu and we shouldn't send the event\\n@@ -1216,11 +1278,14 @@ static OSStatus InstallMyMenuEventHandler(MenuRef menuRef, void* userData, Event\\n }\\n \\n \\n+//\\n // MenuDelegate Objective-C class, used to set up Carbon events\\n+//\\n \\n \\n @implementation MenuDelegate\\n \\n+\\n - (id)initWithGeckoMenu:(nsMenuX*)geckoMenu\\n {\\n   if ((self = [super init])) {\\n@@ -1230,12 +1295,14 @@ static OSStatus InstallMyMenuEventHandler(MenuRef menuRef, void* userData, Event\\n   return self;\\n }\\n \\n+\\n - (void)dealloc\\n {\\n   RemoveEventHandler(mEventHandler);\\n   [super dealloc];\\n }\\n \\n+\\n // You can get a MenuRef from an NSMenu*, but not until it has been made visible\\n // or added to the main menu bar. Basically, Cocoa is attempting lazy loading,\\n // and that doesn't work for us. We don't need any carbon events until after the\\n\""}