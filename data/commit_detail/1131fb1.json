{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas1131fb1\""},"diff":"\"1131fb1 Bug 390050. Scan all blocks in a flow-chain, and their overflow lines, when iterating through lines to build text runs. r=smontagu,mats,sr=mats,a=bz\\ndiff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp\\nindex b96e5ff..cb2dfdc 100644\\n--- a/layout/generic/nsBlockFrame.cpp\\n+++ b/layout/generic/nsBlockFrame.cpp\\n@@ -5061,6 +5061,77 @@ nsBlockFrame::TryAllLines(nsLineList::iterator* aIterator,\\n   }\\n }\\n \\n+nsBlockInFlowLineIterator::nsBlockInFlowLineIterator(nsBlockFrame* aFrame,\\n+    line_iterator& aLine, PRBool aInOverflow)\\n+  : mFrame(aFrame), mLine(aLine), mInOverflowLines(nsnull)\\n+{\\n+  if (aInOverflow) {\\n+    mInOverflowLines = aFrame->GetOverflowLines();\\n+    NS_ASSERTION(mInOverflowLines, \\\"How can we be in overflow if there isn't any?\\\");\\n+  }\\n+}\\n+\\n+PRBool\\n+nsBlockInFlowLineIterator::Next()\\n+{\\n+  ++mLine;\\n+  line_iterator end = mInOverflowLines ? mInOverflowLines->end() : mFrame->end_lines();\\n+  if (mLine != end)\\n+    return PR_TRUE;\\n+  PRBool currentlyInOverflowLines = mInOverflowLines != nsnull;\\n+  while (PR_TRUE) {\\n+    if (currentlyInOverflowLines) {\\n+      mFrame = static_cast<nsBlockFrame*>(mFrame->GetNextInFlow());\\n+      if (!mFrame)\\n+        return PR_FALSE;\\n+      mInOverflowLines = nsnull;\\n+      mLine = mFrame->begin_lines();\\n+      if (mLine != mFrame->end_lines())\\n+        return PR_TRUE;\\n+    } else {\\n+      mInOverflowLines = mFrame->GetOverflowLines();\\n+      if (mInOverflowLines) {\\n+        mLine = mInOverflowLines->begin();\\n+        NS_ASSERTION(mLine != mInOverflowLines->end(), \\\"empty overflow line list?\\\");\\n+        return PR_TRUE;\\n+      }\\n+    }\\n+    currentlyInOverflowLines = !currentlyInOverflowLines;\\n+  }\\n+}\\n+\\n+PRBool\\n+nsBlockInFlowLineIterator::Prev()\\n+{\\n+  line_iterator begin = mInOverflowLines ? mInOverflowLines->begin() : mFrame->begin_lines();\\n+  if (mLine != begin) {\\n+    --mLine;\\n+    return PR_TRUE;\\n+  }\\n+  PRBool currentlyInOverflowLines = mInOverflowLines != nsnull;\\n+  while (PR_TRUE) {\\n+    if (currentlyInOverflowLines) {\\n+      mLine = mFrame->end_lines();\\n+      if (mLine != mFrame->begin_lines()) {\\n+        --mLine;\\n+        return PR_TRUE;\\n+      }\\n+    } else {\\n+      mFrame = static_cast<nsBlockFrame*>(mFrame->GetPrevInFlow());\\n+      if (!mFrame)\\n+        return PR_FALSE;\\n+      mInOverflowLines = mFrame->GetOverflowLines();\\n+      if (mInOverflowLines) {\\n+        mLine = mInOverflowLines->end();\\n+        NS_ASSERTION(mLine != mInOverflowLines->begin(), \\\"empty overflow line list?\\\");\\n+        --mLine;\\n+        return PR_TRUE;\\n+      }\\n+    }\\n+    currentlyInOverflowLines = !currentlyInOverflowLines;\\n+  }\\n+}\\n+\\n static nsresult RemoveBlockChild(nsIFrame* aFrame, PRBool aDestroyFrames)\\n {\\n   if (!aFrame)\\ndiff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h\\nindex b50eefd..5f063cc 100644\\n--- a/layout/generic/nsBlockFrame.h\\n+++ b/layout/generic/nsBlockFrame.h\\n@@ -70,6 +70,7 @@ enum LineReflowStatus {\\n };\\n \\n class nsBlockReflowState;\\n+class nsBlockInFlowLineIterator;\\n class nsBulletFrame;\\n class nsLineBox;\\n class nsFirstLineFrame;\\n@@ -608,6 +609,7 @@ protected:\\n   nsBulletFrame* mBullet;\\n \\n   friend class nsBlockReflowState;\\n+  friend class nsBlockInFlowLineIterator;\\n \\n private:\\n   nsAbsoluteContainingBlock mAbsoluteContainer;\\n@@ -653,5 +655,32 @@ private:\\n };\\n #endif\\n \\n-#endif /* nsBlockFrame_h___ */\\n+/**\\n+ * Iterates over all lines in the prev-in-flows/next-in-flows of this block.\\n+ */\\n+class nsBlockInFlowLineIterator {\\n+public:\\n+  typedef nsBlockFrame::line_iterator line_iterator;\\n+  nsBlockInFlowLineIterator(nsBlockFrame* aFrame, line_iterator& aLine, PRBool aInOverflow);\\n \\n+  line_iterator GetLine() { return mLine; }\\n+  nsBlockFrame* GetContainer() { return mFrame; }\\n+  PRBool GetInOverflow() { return mInOverflowLines != nsnull; }\\n+  /**\\n+   * Returns false if there are no more lines. After this has returned false,\\n+   * don't call any methods on this object again.\\n+   */\\n+  PRBool Next();\\n+  /**\\n+   * Returns false if there are no more lines. After this has returned false,\\n+   * don't call any methods on this object again.\\n+   */\\n+  PRBool Prev();\\n+\\n+private:\\n+  nsBlockFrame* mFrame;\\n+  line_iterator mLine;\\n+  nsLineList*   mInOverflowLines;\\n+};\\n+\\n+#endif /* nsBlockFrame_h___ */\\ndiff --git a/layout/generic/nsTextFrameThebes.cpp b/layout/generic/nsTextFrameThebes.cpp\\nindex 5a0ec84..729153a 100644\\n--- a/layout/generic/nsTextFrameThebes.cpp\\n+++ b/layout/generic/nsTextFrameThebes.cpp\\n@@ -1104,6 +1104,8 @@ BuildTextRuns(nsIRenderingContext* aRC, nsTextFrame* aForFrame,\\n   aLineContainer->QueryInterface(kBlockFrameCID, (void**)&block);\\n \\n   if (!block) {\\n+    NS_ASSERTION(!aLineContainer->GetPrevInFlow() && !aLineContainer->GetNextInFlow(),\\n+                 \\\"Breakable non-block line containers not supported\\\");\\n     // Just loop through all the children of the linecontainer ... it's really\\n     // just one line\\n     scanner.SetAtStartOfLine();\\n@@ -1151,20 +1153,17 @@ BuildTextRuns(nsIRenderingContext* aRC, nsTextFrame* aForFrame,\\n   // but we discard them instead of assigning them to frames.\\n   // This is a little awkward because we traverse lines in the reverse direction\\n   // but we traverse the frames in each line in the forward direction.\\n-  nsBlockFrame::line_iterator firstLine = block->begin_lines();\\n+  nsBlockInFlowLineIterator backIterator(block, line, PR_FALSE);\\n   nsTextFrame* stopAtFrame = aForFrame;\\n   nsTextFrame* nextLineFirstTextFrame = nsnull;\\n   PRBool seenTextRunBoundaryOnLaterLine = PR_FALSE;\\n   PRBool mayBeginInTextRun = PR_TRUE;\\n+  PRBool inOverflow = PR_FALSE;\\n   while (PR_TRUE) {\\n-    if (line == firstLine) {\\n-      mayBeginInTextRun = PR_FALSE;\\n-      break;\\n-    }\\n-    --line;\\n-    PRBool prevLineIsBlock = line->IsBlock();\\n-    ++line;\\n-    if (prevLineIsBlock) {\\n+    line = backIterator.GetLine();\\n+    block = backIterator.GetContainer();\\n+    inOverflow = backIterator.GetInOverflow();\\n+    if (!backIterator.Prev() || backIterator.GetLine()->IsBlock()) {\\n       mayBeginInTextRun = PR_FALSE;\\n       break;\\n     }\\n@@ -1200,7 +1199,6 @@ BuildTextRuns(nsIRenderingContext* aRC, nsTextFrame* aForFrame,\\n     if (state.mFirstTextFrame) {\\n       nextLineFirstTextFrame = state.mFirstTextFrame;\\n     }\\n-    --line;\\n   }\\n   scanner.SetSkipIncompleteTextRuns(mayBeginInTextRun);\\n \\n@@ -1208,19 +1206,20 @@ BuildTextRuns(nsIRenderingContext* aRC, nsTextFrame* aForFrame,\\n   // text frames will be accumulated into textRunFrames as we go. When a\\n   // text run boundary is required we flush textRunFrames ((re)building their\\n   // gfxTextRuns as necessary).\\n-  nsBlockFrame::line_iterator endLines = block->end_lines();\\n-  NS_ASSERTION(line != endLines && !line->IsBlock(), \\\"Where is this frame anyway??\\\");\\n-  nsIFrame* child = line->mFirstChild;\\n+  nsBlockInFlowLineIterator forwardIterator(block, line, inOverflow);\\n   do {\\n+    line = forwardIterator.GetLine();\\n+    if (line->IsBlock())\\n+      break;\\n     scanner.SetAtStartOfLine();\\n     scanner.SetCommonAncestorWithLastFrame(nsnull);\\n+    nsIFrame* child = line->mFirstChild;\\n     PRInt32 i;\\n     for (i = line->GetChildCount() - 1; i >= 0; --i) {\\n       scanner.ScanFrame(child);\\n       child = child->GetNextSibling();\\n     }\\n-    ++line;\\n-  } while (line != endLines && !line->IsBlock());\\n+  } while (forwardIterator.Next());\\n \\n   // Set mStartOfLine so FlushFrames knows its textrun ends a line\\n   scanner.SetAtStartOfLine();\\n\""}