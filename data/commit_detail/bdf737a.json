{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basbdf737a\""},"diff":"\"bdf737a fix for bug #395267:  show tag results (first) in the url bar autocomplete results. r=dietrich, a=mconnor for m8\\ndiff --git a/browser/themes/pinstripe/browser/browser.css b/browser/themes/pinstripe/browser/browser.css\\nindex efe1dd7..fb7b51c 100755\\n--- a/browser/themes/pinstripe/browser/browser.css\\n+++ b/browser/themes/pinstripe/browser/browser.css\\n@@ -947,6 +947,12 @@ statusbarpanel#statusbar-display {\\n   height: 16px;\\n }\\n \\n+.autocomplete-treebody::-moz-tree-image(tag, treecolAutoCompleteImage) {\\n+  list-style-image: url(\\\"chrome://browser/skin/places/tag.png\\\");\\n+  width: 16px;\\n+  height: 16px;\\n+}\\n+\\n .autocomplete-treebody::-moz-tree-cell-text(treecolAutoCompleteComment) {\\n   color: #555566;\\n }\\ndiff --git a/browser/themes/pinstripe/browser/jar.mn b/browser/themes/pinstripe/browser/jar.mn\\nindex fd5ae79..61ba90c 100644\\n--- a/browser/themes/pinstripe/browser/jar.mn\\n+++ b/browser/themes/pinstripe/browser/jar.mn\\n@@ -49,6 +49,7 @@ classic.jar:\\n   skin/classic/browser/places/editBookmarkOverlay.css       (places/editBookmarkOverlay.css)\\n   skin/classic/browser/places/starPage.png                  (places/starPage.png)\\n   skin/classic/browser/places/pageStarred.png               (places/pageStarred.png)\\n+  skin/classic/browser/places/tag.png                       (places/tag.png)\\n   skin/classic/browser/places/organizer-toolbar.png         (bookmarks/Bookmarks-toolbar.png)\\n   skin/classic/browser/places/expander-closed-active.png    (bookmarks/expander-closed-active.png)\\n   skin/classic/browser/places/expander-closed.png           (bookmarks/expander-closed.png)\\ndiff --git a/browser/themes/pinstripe/browser/places/tag.png b/browser/themes/pinstripe/browser/places/tag.png\\nnew file mode 100755\\nindex 0000000..9757fc6\\nBinary files /dev/null and b/browser/themes/pinstripe/browser/places/tag.png differ\\ndiff --git a/browser/themes/winstripe/browser/browser.css b/browser/themes/winstripe/browser/browser.css\\nindex 25e462f..c6c1030 100644\\n--- a/browser/themes/winstripe/browser/browser.css\\n+++ b/browser/themes/winstripe/browser/browser.css\\n@@ -980,6 +980,12 @@ statusbarpanel#statusbar-display {\\n   height: 16px;\\n }\\n \\n+.autocomplete-treebody::-moz-tree-image(tag, treecolAutoCompleteImage) {\\n+  list-style-image: url(\\\"chrome://browser/skin/places/tag.png\\\");\\n+  width: 16px;\\n+  height: 16px;\\n+}\\n+\\n .autocomplete-treebody::-moz-tree-cell-text(treecolAutoCompleteComment) {\\n   color: #555566;\\n }\\ndiff --git a/browser/themes/winstripe/browser/jar.mn b/browser/themes/winstripe/browser/jar.mn\\nindex 3b0d5030..5e55362 100644\\n--- a/browser/themes/winstripe/browser/jar.mn\\n+++ b/browser/themes/winstripe/browser/jar.mn\\n@@ -55,6 +55,7 @@ classic.jar:\\n         skin/classic/browser/places/editBookmarkOverlay.css     (places/editBookmarkOverlay.css)\\n         skin/classic/browser/places/starPage.png                (places/starPage.png)\\n         skin/classic/browser/places/pageStarred.png             (places/pageStarred.png)\\n+        skin/classic/browser/places/tag.png                     (places/tag.png)\\n         skin/classic/browser/places/bookmarkProperties.css      (places/bookmarkProperties.css)\\n         skin/classic/browser/places/organizer-toolbar.png       (bookmarks/Bookmarks-toolbar.png)\\n #ifdef MOZ_SAFE_BROWSING\\ndiff --git a/browser/themes/winstripe/browser/places/tag.png b/browser/themes/winstripe/browser/places/tag.png\\nnew file mode 100755\\nindex 0000000..9757fc6\\nBinary files /dev/null and b/browser/themes/winstripe/browser/places/tag.png differ\\ndiff --git a/toolkit/components/places/src/nsNavHistory.cpp b/toolkit/components/places/src/nsNavHistory.cpp\\nindex 3e2756a..db548a6 100644\\n--- a/toolkit/components/places/src/nsNavHistory.cpp\\n+++ b/toolkit/components/places/src/nsNavHistory.cpp\\n@@ -1345,8 +1345,8 @@ nsNavHistory::LoadPrefs()\\n   mPrefBranch->GetBoolPref(PREF_AUTOCOMPLETE_ONLY_TYPED,\\n                            &mAutoCompleteOnlyTyped);\\n   if (oldCompleteOnlyTyped != mAutoCompleteOnlyTyped) {\\n-    // update the autocomplete statement if the option has changed.\\n-    nsresult rv = CreateAutoCompleteQuery();\\n+    // update the autocomplete statements if the option has changed.\\n+    nsresult rv = CreateAutoCompleteQueries();\\n     NS_ENSURE_SUCCESS(rv, rv);\\n   }\\n   return NS_OK;\\ndiff --git a/toolkit/components/places/src/nsNavHistory.h b/toolkit/components/places/src/nsNavHistory.h\\nindex b128b4e..0fb5d7f 100644\\n--- a/toolkit/components/places/src/nsNavHistory.h\\n+++ b/toolkit/components/places/src/nsNavHistory.h\\n@@ -565,8 +565,10 @@ protected:\\n   static const PRInt32 kAutoCompleteIndex_ItemId;\\n   static const PRInt32 kAutoCompleteIndex_ParentId;\\n   nsCOMPtr<mozIStorageStatement> mDBAutoCompleteQuery; //  kAutoCompleteIndex_* results\\n+  nsCOMPtr<mozIStorageStatement> mDBTagAutoCompleteQuery; //  kAutoCompleteIndex_* results\\n+\\n   nsresult InitAutoComplete();\\n-  nsresult CreateAutoCompleteQuery();\\n+  nsresult CreateAutoCompleteQueries();\\n   PRBool mAutoCompleteOnlyTyped;\\n   nsCOMPtr<nsITimer> mAutoCompleteTimer;\\n \\n@@ -576,12 +578,14 @@ protected:\\n   nsDataHashtable<nsStringHashKey, PRBool> mCurrentResultURLs;\\n   PRTime mCurrentChunkEndTime;\\n   PRTime mCurrentOldestVisit;\\n+  PRBool mFirstChunk;\\n \\n   nsDataHashtable<nsTrimInt64HashKey, PRBool> mLivemarkFeedItemIds;  \\n   nsCOMPtr<mozIStorageStatement> mLivemarkFeedsQuery;\\n \\n   nsresult AutoCompleteTypedSearch();\\n   nsresult AutoCompleteFullHistorySearch();\\n+  nsresult AutoCompleteTagsSearch();\\n \\n   nsresult PerformAutoComplete();\\n   nsresult StartAutoCompleteTimer(PRUint32 aMilliseconds);\\ndiff --git a/toolkit/components/places/src/nsNavHistoryAutoComplete.cpp b/toolkit/components/places/src/nsNavHistoryAutoComplete.cpp\\nindex 447fff5..a261f59 100644\\n--- a/toolkit/components/places/src/nsNavHistoryAutoComplete.cpp\\n+++ b/toolkit/components/places/src/nsNavHistoryAutoComplete.cpp\\n@@ -61,6 +61,7 @@\\n #include \\\"mozStorageHelper.h\\\"\\n #include \\\"nsFaviconService.h\\\"\\n #include \\\"nsUnicharUtils.h\\\"\\n+#include \\\"nsNavBookmarks.h\\\"\\n \\n #define NS_AUTOCOMPLETESIMPLERESULT_CONTRACTID \\\\\\n   \\\"@mozilla.org/autocomplete/simple-result;1\\\"\\n@@ -74,14 +75,7 @@\\n nsresult\\n nsNavHistory::InitAutoComplete()\\n {\\n-  nsresult rv = CreateAutoCompleteQuery();\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  nsCString sql = NS_LITERAL_CSTRING(\\n-    \\\"SELECT annos.item_id FROM moz_anno_attributes attrs \\\"\\n-    \\\"JOIN moz_items_annos annos WHERE attrs.name = \\\\\\\"\\\" LMANNO_FEEDURI \\\"\\\\\\\" \\\"\\n-    \\\"AND attrs.id = annos.anno_attribute_id\\\");\\n-  rv = mDBConn->CreateStatement(sql, getter_AddRefs(mLivemarkFeedsQuery));\\n+  nsresult rv = CreateAutoCompleteQueries();\\n   NS_ENSURE_SUCCESS(rv, rv);\\n \\n   if (!mCurrentResultURLs.Init(128))\\n@@ -94,15 +88,22 @@ nsNavHistory::InitAutoComplete()\\n }\\n \\n \\n-// nsNavHistory::CreateAutoCompleteQuery\\n+// nsNavHistory::CreateAutoCompleteQueries\\n //\\n-//    The auto complete query we use depends on options, so we have it in\\n+//    The auto complete queries we use depend on options, so we have them in\\n //    a separate function so it can be re-created when the option changes.\\n \\n nsresult\\n-nsNavHistory::CreateAutoCompleteQuery()\\n+nsNavHistory::CreateAutoCompleteQueries()\\n {\\n   nsCString sql = NS_LITERAL_CSTRING(\\n+    \\\"SELECT annos.item_id FROM moz_anno_attributes attrs \\\"\\n+    \\\"JOIN moz_items_annos annos WHERE attrs.name = \\\\\\\"\\\" LMANNO_FEEDURI \\\"\\\\\\\" \\\"\\n+    \\\"AND attrs.id = annos.anno_attribute_id;\\\");\\n+  nsresult rv = mDBConn->CreateStatement(sql, getter_AddRefs(mLivemarkFeedsQuery));\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  sql = NS_LITERAL_CSTRING(\\n     \\\"SELECT h.url, h.title, f.url, b.id, b.parent \\\"\\n     \\\"FROM moz_places h \\\"\\n     \\\"JOIN moz_historyvisits v ON h.id = v.place_id \\\"\\n@@ -116,9 +117,24 @@ nsNavHistory::CreateAutoCompleteQuery()\\n \\n   sql += NS_LITERAL_CSTRING(\\n     \\\"(h.title LIKE ?3 ESCAPE '/' OR h.url LIKE ?3 ESCAPE '/') \\\"\\n-    \\\"GROUP BY h.id ORDER BY h.visit_count DESC, MAX(v.visit_date) DESC \\\");\\n+    \\\"GROUP BY h.id ORDER BY h.visit_count DESC, MAX(v.visit_date) DESC;\\\");\\n+\\n+  rv = mDBConn->CreateStatement(sql, getter_AddRefs(mDBAutoCompleteQuery));\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  sql = NS_LITERAL_CSTRING(\\n+    \\\"SELECT h.url, h.title, f.url, b.id, b.parent \\\"\\n+    \\\"FROM moz_places h \\\"\\n+    \\\"JOIN moz_bookmarks b ON b.fk = h.id \\\"\\n+    \\\"LEFT OUTER JOIN moz_historyvisits v ON h.id = v.place_id \\\"\\n+    \\\"LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id \\\"\\n+    \\\"WHERE \\\"\\n+    \\\"(b.parent = (SELECT t.id FROM moz_bookmarks t WHERE t.parent = ?1 and t.title LIKE ?2 ESCAPE '/')) \\\"\\n+    \\\"GROUP BY h.id ORDER BY h.visit_count DESC, MAX(v.visit_date) DESC;\\\");\\n+  rv = mDBConn->CreateStatement(sql, getter_AddRefs(mDBTagAutoCompleteQuery));\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n \\n-  return mDBConn->CreateStatement(sql, getter_AddRefs(mDBAutoCompleteQuery));\\n+  return NS_OK;\\n }\\n \\n // nsNavHistory::StartAutoCompleteTimer\\n@@ -181,6 +197,14 @@ nsNavHistory::PerformAutoComplete()\\n   if (mCurrentSearchString.IsEmpty())\\n     rv = AutoCompleteTypedSearch();\\n   else {\\n+    // only search tags on the first chunk,\\n+    // but before we search history, as we want tagged\\n+    // items to show up first.\\n+    if (mFirstChunk) {\\n+      rv = AutoCompleteTagsSearch();\\n+      NS_ENSURE_SUCCESS(rv, rv);\\n+    }\\n+\\n     rv = AutoCompleteFullHistorySearch();\\n     moreChunksToSearch = (mCurrentChunkEndTime >= mCurrentOldestVisit);\\n   }\\n@@ -210,6 +234,7 @@ nsNavHistory::PerformAutoComplete()\\n   // if we're not done searching, adjust our end time and \\n   // search the next earlier chunk of time\\n   if (moreChunksToSearch) {\\n+    mFirstChunk = PR_FALSE;\\n     mCurrentChunkEndTime -= AUTOCOMPLETE_SEARCH_CHUNK;\\n     rv = StartAutoCompleteTimer(AUTOCOMPLETE_SEARCH_TIMEOUT);\\n     NS_ENSURE_SUCCESS(rv, rv);\\n@@ -239,37 +264,15 @@ nsNavHistory::StartSearch(const nsAString & aSearchString,\\n   // searching using the previous mCurrentChunkEndTime and mCurrentOldestVisit values.\\n   PRBool searchPrevious = PR_FALSE;\\n   if (aPreviousResult) {\\n-    PRUint32 matchCount = 0;\\n-    aPreviousResult->GetMatchCount(&matchCount);\\n     nsAutoString prevSearchString;\\n     aPreviousResult->GetSearchString(prevSearchString);\\n \\n-    // if search string begins with the previous search string, it's a go\\n-    searchPrevious = Substring(mCurrentSearchString, 0,\\n-                       prevSearchString.Length()).Equals(prevSearchString);\\n-  }\\n-  else {\\n-    // reset to mCurrentChunkEndTime \\n-    mCurrentChunkEndTime = PR_Now();\\n-\\n-    // determine our earliest visit\\n-    nsCOMPtr<mozIStorageStatement> dbSelectStatement;\\n-    rv = mDBConn->CreateStatement(\\n-      NS_LITERAL_CSTRING(\\\"SELECT MIN(visit_date) id FROM moz_historyvisits WHERE visit_type <> 4 AND visit_type <> 0\\\"),\\n-      getter_AddRefs(dbSelectStatement));\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n-    PRBool hasMinVisit;\\n-    rv = dbSelectStatement->ExecuteStep(&hasMinVisit);\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n-  \\n-    if (hasMinVisit) {\\n-      rv = dbSelectStatement->GetInt64(0, &mCurrentOldestVisit);\\n-      NS_ENSURE_SUCCESS(rv, rv);\\n-    }\\n-    else {\\n-      // if we have no visits, use a reasonable value\\n-      mCurrentOldestVisit = PR_Now() - USECS_PER_DAY;\\n-    }\\n+    // if search string begins with the previous search string, it's a go.\\n+    // but don't search previous results if the previous search string was empty\\n+    // or if the current search string is empty.  (an empty search string is a \\\"typed only\\\"\\n+    // search from when clicking on the drop down to the right of the url bar.)\\n+    searchPrevious = !prevSearchString.IsEmpty() && Substring(mCurrentSearchString, 0,\\n+                      prevSearchString.Length()).Equals(prevSearchString);\\n   }\\n \\n   mCurrentResult = do_CreateInstance(NS_AUTOCOMPLETESIMPLERESULT_CONTRACTID, &rv);\\n@@ -292,29 +295,71 @@ nsNavHistory::StartSearch(const nsAString & aSearchString,\\n \\n   // Search through the previous result\\n   if (searchPrevious) {\\n+    // when searching our previous results\\n+    // we need to first re-search tags.\\n+    // if our previous search was for \\\"foo\\\", we would have shown\\n+    // items tagged with \\\"foo\\\".  if our current search is \\\"food\\\"\\n+    // we need to re-search for tags matching \\\"food\\\" first.\\n+    // then, when processing results we have to remove any previous tag matches\\n+    rv = AutoCompleteTagsSearch();\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n     PRUint32 matchCount;\\n     aPreviousResult->GetMatchCount(&matchCount);\\n-    for (PRInt32 i = 0; i < matchCount; i++) {\\n-      nsAutoString url, title;\\n-      aPreviousResult->GetValueAt(i, url);\\n-      aPreviousResult->GetCommentAt(i, title);\\n-\\n-      PRBool isMatch = CaseInsensitiveFindInReadable(mCurrentSearchString, url);\\n-      if (!isMatch)\\n-        isMatch = CaseInsensitiveFindInReadable(mCurrentSearchString, title);\\n-\\n-      if (isMatch) {\\n-        nsAutoString image, style;\\n-        aPreviousResult->GetImageAt(i, image);\\n-        aPreviousResult->GetStyleAt(i, style);\\n- \\n-        mCurrentResultURLs.Put(url, PR_TRUE);\\n-\\n-        rv = mCurrentResult->AppendMatch(url, title, image, style);\\n-        NS_ENSURE_SUCCESS(rv, rv);\\n+    for (PRUint32 i = 0; i < matchCount; i++) {\\n+      // if the previous result item was a tagged item, and it matches\\n+      // the current search term (due to url or title) don't include it.\\n+      // find it \\\"naturally\\\" with a history or bookmark search.\\n+      // \\n+      // note, if the previous result item is tagged with the current search term,\\n+      // our call to AutoCompleteTagsSearch() above will find it.\\n+      nsAutoString style;\\n+      aPreviousResult->GetStyleAt(i, style);\\n+      if (!style.Equals(NS_LITERAL_STRING(\\\"tag\\\"))) {\\n+        nsAutoString url, title;\\n+        aPreviousResult->GetValueAt(i, url);\\n+        aPreviousResult->GetCommentAt(i, title);\\n+\\n+        PRBool isMatch = CaseInsensitiveFindInReadable(mCurrentSearchString, url);\\n+        if (!isMatch)\\n+          isMatch = CaseInsensitiveFindInReadable(mCurrentSearchString, title);\\n+\\n+        if (isMatch) {\\n+          nsAutoString image;\\n+          aPreviousResult->GetImageAt(i, image);\\n+\\n+          mCurrentResultURLs.Put(url, PR_TRUE);\\n+  \\n+          rv = mCurrentResult->AppendMatch(url, title, image, style);\\n+          NS_ENSURE_SUCCESS(rv, rv);\\n+        }\\n       }\\n     }\\n   }\\n+  else if (!mCurrentSearchString.IsEmpty()) {\\n+    // reset to mCurrentChunkEndTime \\n+    mCurrentChunkEndTime = PR_Now();\\n+    mFirstChunk = PR_TRUE;\\n+\\n+    // determine our earliest visit\\n+    nsCOMPtr<mozIStorageStatement> dbSelectStatement;\\n+    rv = mDBConn->CreateStatement(\\n+      NS_LITERAL_CSTRING(\\\"SELECT MIN(visit_date) id FROM moz_historyvisits WHERE visit_type <> 4 AND visit_type <> 0\\\"),\\n+      getter_AddRefs(dbSelectStatement));\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    PRBool hasMinVisit;\\n+    rv = dbSelectStatement->ExecuteStep(&hasMinVisit);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+  \\n+    if (hasMinVisit) {\\n+      rv = dbSelectStatement->GetInt64(0, &mCurrentOldestVisit);\\n+      NS_ENSURE_SUCCESS(rv, rv);\\n+    }\\n+    else {\\n+      // if we have no visits, use a reasonable value\\n+      mCurrentOldestVisit = PR_Now() - USECS_PER_DAY;\\n+    }\\n+  }\\n \\n   // fire right away, we already waited to start searching\\n   rv = StartAutoCompleteTimer(0);\\n@@ -393,6 +438,67 @@ nsresult nsNavHistory::AutoCompleteTypedSearch()\\n   return NS_OK;\\n }\\n \\n+nsresult\\n+nsNavHistory::AutoCompleteTagsSearch()\\n+{\\n+  mozStorageStatementScoper scope(mDBTagAutoCompleteQuery);\\n+\\n+  nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();\\n+  NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);\\n+\\n+  PRInt64 tagRoot;\\n+  nsresult rv = bookmarks->GetTagRoot(&tagRoot);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  rv = mDBTagAutoCompleteQuery->BindInt64Parameter(0, tagRoot);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  nsString escapedSearchString;\\n+  rv = mDBTagAutoCompleteQuery->EscapeStringForLIKE(mCurrentSearchString, PRUnichar('/'), escapedSearchString);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  rv = mDBTagAutoCompleteQuery->BindStringParameter(1, escapedSearchString);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  nsFaviconService* faviconService = nsFaviconService::GetFaviconService();\\n+  NS_ENSURE_TRUE(faviconService, NS_ERROR_OUT_OF_MEMORY);\\n+\\n+  PRBool hasMore = PR_FALSE;\\n+\\n+  // Determine the result of the search\\n+  while (NS_SUCCEEDED(mDBTagAutoCompleteQuery->ExecuteStep(&hasMore)) && hasMore) {\\n+    nsAutoString entryURL, entryTitle, entryFavicon;\\n+    rv = mDBTagAutoCompleteQuery->GetString(kAutoCompleteIndex_URL, entryURL);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    rv = mDBTagAutoCompleteQuery->GetString(kAutoCompleteIndex_Title, entryTitle);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    rv = mDBTagAutoCompleteQuery->GetString(kAutoCompleteIndex_FaviconURL, entryFavicon);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    PRInt64 itemId = 0;\\n+    rv = mDBTagAutoCompleteQuery->GetInt64(kAutoCompleteIndex_ItemId, &itemId);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    PRInt64 parentId = 0;\\n+    rv = mDBTagAutoCompleteQuery->GetInt64(kAutoCompleteIndex_ParentId, &parentId);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    PRBool dummy;\\n+    // prevent duplicates.  this can happen when chunking as we\\n+    // may have already seen this URL from an earlier chunk of time\\n+    if (!mCurrentResultURLs.Get(entryURL, &dummy)) {\\n+      // new item, append to our results and put it in our hash table.\\n+      nsCAutoString faviconSpec;\\n+      faviconService->GetFaviconSpecForIconString(\\n+        NS_ConvertUTF16toUTF8(entryFavicon), faviconSpec);\\n+      rv = mCurrentResult->AppendMatch(entryURL, entryTitle, \\n+        NS_ConvertUTF8toUTF16(faviconSpec), NS_LITERAL_STRING(\\\"tag\\\"));\\n+      NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+      mCurrentResultURLs.Put(entryURL, PR_TRUE);\\n+    }\\n+  }\\n+\\n+  return NS_OK;\\n+}\\n \\n // nsNavHistory::AutoCompleteFullHistorySearch\\n //\\n@@ -428,13 +534,18 @@ nsNavHistory::AutoCompleteFullHistorySearch()\\n   // Determine the result of the search\\n   while (NS_SUCCEEDED(mDBAutoCompleteQuery->ExecuteStep(&hasMore)) && hasMore) {\\n     nsAutoString entryURL, entryTitle, entryFavicon;\\n-    mDBAutoCompleteQuery->GetString(kAutoCompleteIndex_URL, entryURL);\\n-    mDBAutoCompleteQuery->GetString(kAutoCompleteIndex_Title, entryTitle);\\n-    mDBAutoCompleteQuery->GetString(kAutoCompleteIndex_FaviconURL, entryFavicon);\\n+    rv = mDBAutoCompleteQuery->GetString(kAutoCompleteIndex_URL, entryURL);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    rv = mDBAutoCompleteQuery->GetString(kAutoCompleteIndex_Title, entryTitle);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    rv = mDBAutoCompleteQuery->GetString(kAutoCompleteIndex_FaviconURL, entryFavicon);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n     PRInt64 itemId = 0;\\n-    mDBAutoCompleteQuery->GetInt64(kAutoCompleteIndex_ItemId, &itemId);\\n+    rv = mDBAutoCompleteQuery->GetInt64(kAutoCompleteIndex_ItemId, &itemId);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n     PRInt64 parentId = 0;\\n-    mDBAutoCompleteQuery->GetInt64(kAutoCompleteIndex_ParentId, &parentId);\\n+    rv = mDBAutoCompleteQuery->GetInt64(kAutoCompleteIndex_ParentId, &parentId);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n \\n     PRBool dummy;\\n     // don't show rss feed items as bookmarked\\n\""}