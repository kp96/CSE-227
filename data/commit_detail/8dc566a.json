{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas8dc566a\""},"diff":"\"8dc566a Backing out fix for bug 92543 due to build bustage\\ndiff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp\\nindex 60eaf1a..0bda370 100644\\n--- a/layout/base/nsPresShell.cpp\\n+++ b/layout/base/nsPresShell.cpp\\n@@ -6605,7 +6605,7 @@ CompareTrees(nsPresContext* aFirstPresContext, nsIFrame* aFirstFrame,\\n                 for ( ;trapIndex<band1.mCount; trapIndex++)\\n                 {\\n                   PRBool match = (trap1[trapIndex].EqualGeometry(trap2[trapIndex])) && \\n-                    ((trap1[trapIndex].mFrame!=nsull) == (trap2[trapIndex].mFrame!=nsnull));\\n+                    trap1[trapIndex].mState == trap2[trapIndex].mState;\\n                   if (!match)\\n                   {\\n                     LogVerifyMessage(k1, k2, \\\"band.mTrapezoids of space managers differs\\\\n\\\");\\n@@ -6630,7 +6630,7 @@ CompareTrees(nsPresContext* aFirstPresContext, nsIFrame* aFirstFrame,\\n                 for ( ; trapIndex<band1.mCount; trapIndex++)\\n                 {\\n                   PRBool match = (trap1[trapIndex].EqualGeometry(trap2[trapIndex])) && \\n-                    ((trap1[trapIndex].mFrame!=nsull) == (trap2[trapIndex].mFrame!=nsnull));\\n+                    trap1[trapIndex].mState == trap2[trapIndex].mState;\\n                   if (!match)\\n                   {\\n                     LogVerifyMessage(k1, k2, \\\"band.mTrapezoids of space managers differs\\\\n\\\");\\ndiff --git a/layout/generic/nsBlockBandData.cpp b/layout/generic/nsBlockBandData.cpp\\nindex 92fa689..339fc59 100644\\n--- a/layout/generic/nsBlockBandData.cpp\\n+++ b/layout/generic/nsBlockBandData.cpp\\n@@ -183,16 +183,28 @@ nsBlockBandData::ComputeAvailSpaceRect()\\n     NS_PRECONDITION(mCount<=mSize, \\\"bad state, count > size\\\");\\n     for (i = 0; i < mCount; i++) {\\n       trapezoid = &mTrapezoids[i];\\n-      if (trapezoid->mFrames) {\\n+      if (trapezoid->mState != nsBandTrapezoid::Available) {\\n #ifdef REALLY_NOISY_COMPUTEAVAILSPACERECT\\n-        printf(\\\"band %p checking !Avail trap %p with frame %p\\\\n\\\", this, trapezoid, trapezoid->mFrames);\\n+        printf(\\\"band %p checking !Avail trap %p with frame %p\\\\n\\\", this, trapezoid, trapezoid->mFrame);\\n #endif\\n-        const nsSmallVoidArray* frames = trapezoid->mFrames;\\n-        const PRInt32 numFrames = frames->Count();\\n-        NS_ASSERTION(numFrames > 0, \\\"bad trapezoid frame list\\\");\\n-        for (PRInt32 j = 0; j < numFrames; j++) {\\n-          nsIFrame* f = (nsIFrame*) frames->ElementAt(j);\\n-          const nsStyleDisplay* display = f->GetStyleDisplay();\\n+        if (nsBandTrapezoid::OccupiedMultiple == trapezoid->mState) {\\n+          PRInt32 j, numFrames = trapezoid->mFrames->Count();\\n+          NS_ASSERTION(numFrames > 0, \\\"bad trapezoid frame list\\\");\\n+          for (j = 0; j < numFrames; j++) {\\n+            nsIFrame* f = (nsIFrame*) trapezoid->mFrames->ElementAt(j);\\n+            const nsStyleDisplay* display = f->GetStyleDisplay();\\n+            if (NS_STYLE_FLOAT_LEFT == display->mFloats) {\\n+              leftFloats++;\\n+            }\\n+            else if (NS_STYLE_FLOAT_RIGHT == display->mFloats) {\\n+              rightFloats++;\\n+              if ((nsnull == rightTrapezoid) && (i > 0)) {\\n+                rightTrapezoid = &mTrapezoids[i - 1];\\n+              }\\n+            }\\n+          }\\n+        } else {\\n+          const nsStyleDisplay* display = trapezoid->mFrame->GetStyleDisplay();\\n           if (NS_STYLE_FLOAT_LEFT == display->mFloats) {\\n             leftFloats++;\\n           }\\n@@ -206,7 +218,7 @@ nsBlockBandData::ComputeAvailSpaceRect()\\n       }\\n     }\\n   }\\n-  else if (mTrapezoids[0].mFrames) {\\n+  else if (mTrapezoids[0].mState != nsBandTrapezoid::Available) {\\n     // We have a float using up all the available space\\n     leftFloats = 1;\\n   }\\n@@ -226,21 +238,28 @@ nsBlockBandData::ComputeAvailSpaceRect()\\n \\n   // When there is no available space, we still need a proper X\\n   // coordinate to place objects that end up here anyway.\\n-  const nsSmallVoidArray* frames = trapezoid->mFrames;\\n-  if (frames) {\\n-    // It's not clear what coordinate to use when there is no\\n-    // available space and the space is multiply occupied...So: If\\n-    // any of the floats that are a part of the trapezoid are left\\n-    // floats then we move over to the right edge of the\\n-    // unavaliable space.\\n-    const PRInt32 numFrames = frames->Count();\\n-    NS_ASSERTION(numFrames > 0, \\\"bad trapezoid frame list\\\");\\n-    for (PRInt32 j = 0; j < numFrames; j++) {\\n-      nsIFrame* f = (nsIFrame*) frames->ElementAt(j);\\n-      const nsStyleDisplay* display = f->GetStyleDisplay();\\n+  if (nsBandTrapezoid::Available != trapezoid->mState) {\\n+    if (nsBandTrapezoid::OccupiedMultiple == trapezoid->mState) {\\n+      // It's not clear what coordinate to use when there is no\\n+      // available space and the space is multiply occupied...So: If\\n+      // any of the floats that are a part of the trapezoid are left\\n+      // floats then we move over to the right edge of the\\n+      // unavaliable space.\\n+      PRInt32 j, numFrames = trapezoid->mFrames->Count();\\n+      NS_ASSERTION(numFrames > 0, \\\"bad trapezoid frame list\\\");\\n+      for (j = 0; j < numFrames; j++) {\\n+        nsIFrame* f = (nsIFrame*) trapezoid->mFrames->ElementAt(j);\\n+        const nsStyleDisplay* display = f->GetStyleDisplay();\\n+        if (NS_STYLE_FLOAT_LEFT == display->mFloats) {\\n+          mAvailSpace.x = mAvailSpace.XMost();\\n+          break;\\n+        }\\n+      }\\n+    }\\n+    else {\\n+      const nsStyleDisplay* display = trapezoid->mFrame->GetStyleDisplay();\\n       if (NS_STYLE_FLOAT_LEFT == display->mFloats) {\\n         mAvailSpace.x = mAvailSpace.XMost();\\n-        break;\\n       }\\n     }\\n     mAvailSpace.width = 0;\\ndiff --git a/layout/generic/nsSpaceManager.cpp b/layout/generic/nsSpaceManager.cpp\\nindex 773788e..70f83d5 100644\\n--- a/layout/generic/nsSpaceManager.cpp\\n+++ b/layout/generic/nsSpaceManager.cpp\\n@@ -69,6 +69,7 @@ nsSpaceManager::BandList::BandList()\\n   : nsSpaceManager::BandRect(NSCOORD_MIN, NSCOORD_MIN, NSCOORD_MIN, NSCOORD_MIN, (nsIFrame*)nsnull)\\n {\\n   PR_INIT_CLIST(this);\\n+  mNumFrames = 0;\\n }\\n \\n void\\n@@ -275,7 +276,8 @@ nsSpaceManager::GetBandAvailableSpace(const BandRect* aBand,\\n         aBandData.mCount += 2 * aBand->Length() + 2;  // estimate the number needed\\n         return NS_ERROR_FAILURE;\\n       }\\n-      trapezoid->mFrames = nsnull;\\n+      trapezoid->mState = nsBandTrapezoid::Available;\\n+      trapezoid->mFrame = nsnull;\\n \\n       // Assign the trapezoid a rectangular shape. The trapezoid must be in the\\n       // local coordinate space, so convert the current left coordinate\\n@@ -292,8 +294,14 @@ nsSpaceManager::GetBandAvailableSpace(const BandRect* aBand,\\n       aBandData.mCount += 2 * aBand->Length() + 1;  // estimate the number needed\\n       return NS_ERROR_FAILURE;\\n     }\\n-    NS_ASSERTION(aBand->mFrames.Count() > 0, \\\"unexpected frame count\\\");\\n-    trapezoid->mFrames = &aBand->mFrames;\\n+    if (1 == aBand->mNumFrames) {\\n+      trapezoid->mState = nsBandTrapezoid::Occupied;\\n+      trapezoid->mFrame = aBand->mFrame;\\n+    } else {\\n+      NS_ASSERTION(aBand->mNumFrames > 1, \\\"unexpected frame count\\\");\\n+      trapezoid->mState = nsBandTrapezoid::OccupiedMultiple;\\n+      trapezoid->mFrames = aBand->mFrames;\\n+    }\\n \\n     nscoord x = aBand->mLeft;\\n     // The first band can straddle the clip rect\\n@@ -325,7 +333,8 @@ nsSpaceManager::GetBandAvailableSpace(const BandRect* aBand,\\n       aBandData.mCount++;\\n       return NS_ERROR_FAILURE;\\n     }\\n-    trapezoid->mFrames = nsnull;\\n+    trapezoid->mState = nsBandTrapezoid::Available;\\n+    trapezoid->mFrame = nsnull;\\n \\n     // Assign the trapezoid a rectangular shape. The trapezoid must be in the\\n     // local coordinate space, so convert the current left coordinate\\n@@ -357,7 +366,8 @@ nsSpaceManager::GetBandData(nscoord       aYOffset,\\n     // All the requested space is available\\n     aBandData.mCount = 1;\\n     aBandData.mTrapezoids[0] = nsRect(0, aYOffset, aMaxSize.width, maxHeight);\\n-    aBandData.mTrapezoids[0].mFrames = nsnull;\\n+    aBandData.mTrapezoids[0].mState = nsBandTrapezoid::Available;\\n+    aBandData.mTrapezoids[0].mFrame = nsnull;\\n   } else {\\n     // Find the first band that contains the y-offset or is below the y-offset\\n     BandRect* band = GuessBandWithTopAbove(y);\\n@@ -370,7 +380,8 @@ nsSpaceManager::GetBandData(nscoord       aYOffset,\\n         aBandData.mCount = 1;\\n         aBandData.mTrapezoids[0] =\\n           nsRect(0, aYOffset, aMaxSize.width, PR_MIN(band->mTop - y, maxHeight));\\n-        aBandData.mTrapezoids[0].mFrames = nsnull;\\n+        aBandData.mTrapezoids[0].mState = nsBandTrapezoid::Available;\\n+        aBandData.mTrapezoids[0].mFrame = nsnull;\\n         break;\\n       } else if (y < band->mBottom) {\\n         // The band contains the y-offset. Return a list of available and\\n@@ -573,7 +584,7 @@ nsSpaceManager::AddRectToBand(BandRect* aBand, BandRect* aBandRect)\\n {\\n   NS_PRECONDITION((aBand->mTop == aBandRect->mTop) &&\\n                   (aBand->mBottom == aBandRect->mBottom), \\\"bad band\\\");\\n-  NS_PRECONDITION(1 == aBandRect.mFrames.Count(), \\\"shared band rect\\\");\\n+  NS_PRECONDITION(1 == aBandRect->mNumFrames, \\\"shared band rect\\\");\\n   nscoord topOfBand = aBand->mTop;\\n \\n   // Figure out where in the band horizontally to insert the rect\\n@@ -640,7 +651,7 @@ nsSpaceManager::AddRectToBand(BandRect* aBand, BandRect* aBandRect)\\n         }\\n \\n         // Mark the existing rect as shared\\n-        aBand->AddFrame(aBandRect->FrameAt(0));\\n+        aBand->AddFrame(aBandRect->mFrame);\\n         return;\\n       }\\n     }\\n@@ -690,12 +701,12 @@ nsSpaceManager::AddRectToBand(BandRect* aBand, BandRect* aBandRect)\\n       aBand->InsertAfter(r1);\\n \\n       // Mark the overlap as being shared\\n-      aBand->AddFrame(aBandRect->FrameAt(0));\\n+      aBand->AddFrame(aBandRect->mFrame);\\n       return;\\n \\n     } else {\\n       // Indicate the frames share the existing rect\\n-      aBand->AddFrame(aBandRect->FrameAt(0));\\n+      aBand->AddFrame(aBandRect->mFrame);\\n \\n       if (aBand->mRight == aBandRect->mRight) {\\n         // The new and existing rect have the same right edge. We're all done,\\n@@ -778,7 +789,7 @@ nsSpaceManager::InsertBandRect(BandRect* aBandRect)\\n       // the part that's above the band\\n       BandRect* bandRect1 = new BandRect(aBandRect->mLeft, aBandRect->mTop,\\n                                          aBandRect->mRight, band->mTop,\\n-                                         aBandRect->mFrames);\\n+                                         aBandRect->mFrame);\\n \\n       // Insert bandRect1 as a new band\\n       band->InsertBefore(bandRect1);\\n@@ -824,7 +835,7 @@ nsSpaceManager::InsertBandRect(BandRect* aBandRect)\\n       // the rect, creating a new rect for the part that overlaps the band\\n       BandRect* bandRect1 = new BandRect(aBandRect->mLeft, aBandRect->mTop,\\n                                          aBandRect->mRight, band->mBottom,\\n-                                         aBandRect->mFrames);\\n+                                         aBandRect->mFrame);\\n \\n       // Add bandRect1 to the band\\n       AddRectToBand(band, bandRect1);\\n@@ -941,9 +952,9 @@ nsSpaceManager::RemoveRegion(nsIFrame* aFrame)\\n           // Remember that we found a matching rect in this band\\n           foundMatchingRect = PR_TRUE;\\n \\n-          if (rect->mFrames.Count() > 1) {\\n+          if (rect->mNumFrames > 1) {\\n             // The band rect is occupied by more than one frame\\n-            rect->mFrames.RemoveElement(aFrame);\\n+            rect->RemoveFrame(aFrame);\\n \\n             // Remember that this rect was being shared by more than one frame\\n             // including aFrame\\n@@ -1145,19 +1156,33 @@ nsSpaceManager::List(FILE* out)\\n   else {\\n     BandRect* band = mBandList.Head();\\n     do {\\n-      PRInt32 const n = band->mFrames.Count();\\n-      fprintf(out, \\\"  left=%d top=%d right=%d bottom=%d count=%d frames=\\\",\\n-              band->mLeft, band->mTop, band->mRight, band->mBottom, n);\\n-\\n-      for (PRInt32 i = 0; i < n; i++) {\\n-        nsIFrame* frame = (nsIFrame*)band->mFrames.FastElementAt(i);\\n-        if (frame) {\\n-          nsIFrameDebug*  frameDebug;\\n-\\n-\\t\\t  if (NS_SUCCEEDED(frame->QueryInterface(NS_GET_IID(nsIFrameDebug), (void**)&frameDebug))) {\\n-            frameDebug->GetFrameName(tmp);\\n-            fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);\\n-            fprintf(out, \\\"@%p \\\", frame);\\n+      fprintf(out, \\\"  left=%d top=%d right=%d bottom=%d numFrames=%d\\\",\\n+              band->mLeft, band->mTop, band->mRight, band->mBottom,\\n+              band->mNumFrames);\\n+      if (1 == band->mNumFrames) {\\n+        nsIFrameDebug*  frameDebug;\\n+\\n+        if (NS_SUCCEEDED(band->mFrame->QueryInterface(NS_GET_IID(nsIFrameDebug), (void**)&frameDebug))) {\\n+          frameDebug->GetFrameName(tmp);\\n+          fprintf(out, \\\" frame=\\\");\\n+          fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);\\n+          fprintf(out, \\\"@%p\\\", band->mFrame);\\n+        }\\n+      }\\n+      else if (1 < band->mNumFrames) {\\n+        fprintf(out, \\\"\\\\n    \\\");\\n+        nsVoidArray* a = band->mFrames;\\n+        PRInt32 i, n = a->Count();\\n+        for (i = 0; i < n; i++) {\\n+          nsIFrame* frame = (nsIFrame*) a->ElementAt(i);\\n+          if (frame) {\\n+            nsIFrameDebug*  frameDebug;\\n+\\n+            if (NS_SUCCEEDED(frame->QueryInterface(NS_GET_IID(nsIFrameDebug), (void**)&frameDebug))) {\\n+              frameDebug->GetFrameName(tmp);\\n+              fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);\\n+              fprintf(out, \\\"@%p \\\", frame);\\n+            }\\n           }\\n         }\\n       }\\n@@ -1362,26 +1387,32 @@ nsSpaceManager::BandRect::BandRect(nscoord    aLeft,\\n   mTop = aTop;\\n   mRight = aRight;\\n   mBottom = aBottom;\\n-  AddFrame(aFrame);\\n+  mFrame = aFrame;\\n+  mNumFrames = 1;\\n }\\n \\n nsSpaceManager::BandRect::BandRect(nscoord      aLeft,\\n                                    nscoord      aTop,\\n                                    nscoord      aRight,\\n                                    nscoord      aBottom,\\n-                                   nsSmallVoidArray& aFrames)\\n+                                   nsVoidArray* aFrames)\\n {\\n   MOZ_COUNT_CTOR(BandRect);\\n   mLeft = aLeft;\\n   mTop = aTop;\\n   mRight = aRight;\\n   mBottom = aBottom;\\n-  mFrames = aFrames;\\n+  mFrames = new nsVoidArray;\\n+  mFrames->operator=(*aFrames);\\n+  mNumFrames = mFrames->Count();\\n }\\n \\n nsSpaceManager::BandRect::~BandRect()\\n {\\n   MOZ_COUNT_DTOR(BandRect);\\n+  if (mNumFrames > 1) {\\n+    delete mFrames;\\n+  }\\n }\\n \\n nsSpaceManager::BandRect*\\n@@ -1390,7 +1421,13 @@ nsSpaceManager::BandRect::SplitVertically(nscoord aBottom)\\n   NS_PRECONDITION((aBottom > mTop) && (aBottom < mBottom), \\\"bad argument\\\");\\n \\n   // Create a new band rect for the bottom part\\n-  BandRect* bottomBandRect = new BandRect(mLeft, aBottom, mRight, mBottom, mFrames);\\n+  BandRect* bottomBandRect;\\n+                                            \\n+  if (mNumFrames > 1) {\\n+    bottomBandRect = new BandRect(mLeft, aBottom, mRight, mBottom, mFrames);\\n+  } else {\\n+    bottomBandRect = new BandRect(mLeft, aBottom, mRight, mBottom, mFrame);\\n+  }\\n                                            \\n   // This band rect becomes the top part, so adjust the bottom edge\\n   mBottom = aBottom;\\n@@ -1403,7 +1440,13 @@ nsSpaceManager::BandRect::SplitHorizontally(nscoord aRight)\\n   NS_PRECONDITION((aRight > mLeft) && (aRight < mRight), \\\"bad argument\\\");\\n   \\n   // Create a new band rect for the right part\\n-  BandRect* rightBandRect = new BandRect(aRight, mTop, mRight, mBottom, mFrames);\\n+  BandRect* rightBandRect;\\n+                                            \\n+  if (mNumFrames > 1) {\\n+    rightBandRect = new BandRect(aRight, mTop, mRight, mBottom, mFrames);\\n+  } else {\\n+    rightBandRect = new BandRect(aRight, mTop, mRight, mBottom, mFrame);\\n+  }\\n                                            \\n   // This band rect becomes the left part, so adjust the right edge\\n   mRight = aRight;\\n@@ -1413,32 +1456,76 @@ nsSpaceManager::BandRect::SplitHorizontally(nscoord aRight)\\n PRBool\\n nsSpaceManager::BandRect::IsOccupiedBy(const nsIFrame* aFrame) const\\n {\\n-  const PRInt32 count = mFrames.Count();\\n+  PRBool  result;\\n \\n-  for (PRInt32 i = 0; i < count; i++) {\\n-    if ((nsIFrame*)mFrames.FastElementAt(i) == aFrame)\\n-      return PR_TRUE;\\n+  if (1 == mNumFrames) {\\n+    result = (mFrame == aFrame);\\n+  } else {\\n+    PRInt32 count = mFrames->Count();\\n+\\n+    result = PR_FALSE;\\n+    for (PRInt32 i = 0; i < count; i++) {\\n+      nsIFrame* f = (nsIFrame*)mFrames->ElementAt(i);\\n+\\n+      if (f == aFrame) {\\n+        result = PR_TRUE;\\n+        break;\\n+      }\\n+    }\\n   }\\n \\n-  return PR_FALSE;\\n+  return result;\\n+}\\n+\\n+void\\n+nsSpaceManager::BandRect::AddFrame(const nsIFrame* aFrame)\\n+{\\n+  if (1 == mNumFrames) {\\n+    nsIFrame* f = mFrame;\\n+    mFrames = new nsVoidArray;\\n+    mFrames->AppendElement(f);\\n+  }\\n+\\n+  mNumFrames++;\\n+  mFrames->AppendElement((void*)aFrame);\\n+  NS_POSTCONDITION(mFrames->Count() == mNumFrames, \\\"bad frame count\\\");\\n+}\\n+\\n+void\\n+nsSpaceManager::BandRect::RemoveFrame(const nsIFrame* aFrame)\\n+{\\n+  NS_PRECONDITION(mNumFrames > 1, \\\"only one frame\\\");\\n+  mFrames->RemoveElement((void*)aFrame);\\n+  mNumFrames--;\\n+\\n+  if (1 == mNumFrames) {\\n+    nsIFrame* f = (nsIFrame*)mFrames->ElementAt(0);\\n+\\n+    delete mFrames;\\n+    mFrame = f;\\n+  }\\n }\\n \\n PRBool\\n nsSpaceManager::BandRect::HasSameFrameList(const BandRect* aBandRect) const\\n {\\n-  const PRInt32 count = mFrames.Count();\\n   PRBool  result;\\n \\n   // Check whether they're occupied by the same number of frames\\n-  if (count != aBandRect->mFrames.Count()) {\\n+  if (mNumFrames != aBandRect->mNumFrames) {\\n     result = PR_FALSE;\\n+  } else if (1 == mNumFrames) {\\n+    result = (mFrame == aBandRect->mFrame);\\n   } else {\\n     result = PR_TRUE;\\n \\n     // For each frame occupying this band rect check whether it also occupies\\n     // aBandRect\\n+    PRInt32 count = mFrames->Count();\\n     for (PRInt32 i = 0; i < count; i++) {\\n-      if (-1 == aBandRect->mFrames.IndexOf(mFrames.FastElementAt(i))) {\\n+      nsIFrame* f = (nsIFrame*)mFrames->ElementAt(i);\\n+\\n+      if (-1 == aBandRect->mFrames->IndexOf(f)) {\\n         result = PR_FALSE;\\n         break;\\n       }\\ndiff --git a/layout/generic/nsSpaceManager.h b/layout/generic/nsSpaceManager.h\\nindex faa48f5..b312ea2 100644\\n--- a/layout/generic/nsSpaceManager.h\\n+++ b/layout/generic/nsSpaceManager.h\\n@@ -49,10 +49,10 @@\\n #include \\\"nsISupports.h\\\"\\n #include \\\"nsCoord.h\\\"\\n #include \\\"nsRect.h\\\"\\n-#include \\\"nsVoidArray.h\\\"\\n \\n class nsIPresShell;\\n class nsIFrame;\\n+class nsVoidArray;\\n struct nsSize;\\n struct nsHTMLReflowState;\\n class nsPresContext;\\n@@ -69,10 +69,16 @@ class nsPresContext;\\n  * </ul>\\n  */\\n struct nsBandTrapezoid {\\n+  enum State {Available, Occupied, OccupiedMultiple};\\n+\\n   nscoord   mTopY, mBottomY;            // top and bottom y-coordinates\\n   nscoord   mTopLeftX, mBottomLeftX;    // left edge x-coordinates\\n   nscoord   mTopRightX, mBottomRightX;  // right edge x-coordinates\\n-  const nsSmallVoidArray* mFrames; // list of frames occupying the space\\n+  State     mState;                     // state of the space\\n+  union {\\n+    nsIFrame*          mFrame;  // single frame occupying the space\\n+    const nsVoidArray* mFrames; // list of frames occupying the space\\n+  };\\n \\n   // Get the height of the trapezoid\\n   nscoord GetHeight() const {return mBottomY - mTopY;}\\n@@ -83,6 +89,9 @@ struct nsBandTrapezoid {\\n   // Set the trapezoid from a rectangle\\n   inline void operator=(const nsRect& aRect);\\n \\n+  // Do these trapezoids have the same geometry, frame, and state?\\n+  inline PRBool Equals(const nsBandTrapezoid& aTrap) const;\\n+\\n   // Do these trapezoids have the same geometry?\\n   inline PRBool EqualGeometry(const nsBandTrapezoid& aTrap) const;\\n \\n@@ -93,7 +102,7 @@ struct nsBandTrapezoid {\\n       mBottomLeftX(0),\\n       mTopRightX(0),\\n       mBottomRightX(0),\\n-      mFrames(nsnull)\\n+      mFrame(nsnull)\\n   {\\n   }\\n };\\n@@ -117,6 +126,20 @@ inline void nsBandTrapezoid::operator=(const nsRect& aRect)\\n   mBottomY = aRect.YMost();\\n }\\n \\n+inline PRBool nsBandTrapezoid::Equals(const nsBandTrapezoid& aTrap) const\\n+{\\n+  return (\\n+    mTopLeftX == aTrap.mTopLeftX &&\\n+    mBottomLeftX == aTrap.mBottomLeftX &&\\n+    mTopRightX == aTrap.mTopRightX &&\\n+    mBottomRightX == aTrap.mBottomRightX &&\\n+    mTopY == aTrap.mTopY &&\\n+    mBottomY == aTrap.mBottomY &&\\n+    mState == aTrap.mState &&\\n+    mFrame == aTrap.mFrame    \\n+  );\\n+}\\n+\\n inline PRBool nsBandTrapezoid::EqualGeometry(const nsBandTrapezoid& aTrap) const\\n {\\n   return (\\n@@ -354,14 +377,18 @@ public:\\n   struct BandRect : PRCListStr {\\n     nscoord   mLeft, mTop;\\n     nscoord   mRight, mBottom;\\n-    nsSmallVoidArray mFrames;  // list of frames occupying the space\\n+    PRInt32   mNumFrames;    // number of frames occupying this rect\\n+    union {\\n+      nsIFrame*    mFrame;   // single frame occupying the space\\n+      nsVoidArray* mFrames;  // list of frames occupying the space\\n+    };\\n \\n     BandRect(nscoord aLeft, nscoord aTop,\\n              nscoord aRight, nscoord aBottom,\\n-             nsIFrame* aFrame);\\n+             nsIFrame*);\\n     BandRect(nscoord aLeft, nscoord aTop,\\n              nscoord aRight, nscoord aBottom,\\n-             nsSmallVoidArray& frames);\\n+             nsVoidArray*);\\n     ~BandRect();\\n \\n     // List operations\\n@@ -387,15 +414,8 @@ public:\\n \\n     // Accessor functions\\n     PRBool  IsOccupiedBy(const nsIFrame*) const;\\n-    void    AddFrame(const nsIFrame* aFrame) {\\n-      mFrames.AppendElement((void*)aFrame);\\n-    }\\n-    void    RemoveFrame(const nsIFrame* aFrame) {\\n-      mFrames.RemoveElement((void*)aFrame);\\n-    }\\n-    nsIFrame * FrameAt(PRInt32 index) {\\n-      return static_cast<nsIFrame*>(mFrames.FastElementAt(index));\\n-    }\\n+    void    AddFrame(const nsIFrame*);\\n+    void    RemoveFrame(const nsIFrame*);\\n     PRBool  HasSameFrameList(const BandRect* aBandRect) const;\\n     PRInt32 Length() const;\\n   };\\n\""}