{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basdc0f534\""},"diff":"\"dc0f534 Fixing bug 392505. Make nsNPObjWrapper::GetNewOrUsed() remove entries from the right hash table when out of memory. r+sr=peterv@propagandism.org, a=jst@mozilla.org\\ndiff --git a/modules/plugin/base/src/nsJSNPRuntime.cpp b/modules/plugin/base/src/nsJSNPRuntime.cpp\\nindex 66ced01..f9e665b 100644\\n--- a/modules/plugin/base/src/nsJSNPRuntime.cpp\\n+++ b/modules/plugin/base/src/nsJSNPRuntime.cpp\\n@@ -951,9 +951,9 @@ nsJSObjWrapper::GetNewOrUsed(NPP npp, JSContext *cx, JSObject *obj)\\n \\n   nsJSObjWrapperKey key(obj, npp);\\n \\n-  JSObjWrapperHashEntry *entry =\\n-    static_cast<JSObjWrapperHashEntry *>\\n-               (PL_DHashTableOperate(&sJSObjWrappers, &key, PL_DHASH_ADD));\\n+  JSObjWrapperHashEntry *entry = static_cast<JSObjWrapperHashEntry *>\\n+    (PL_DHashTableOperate(&sJSObjWrappers, &key, PL_DHASH_ADD));\\n+\\n   if (!entry) {\\n     // Out of memory.\\n     return nsnull;\\n@@ -1473,10 +1473,8 @@ nsNPObjWrapper::OnDestroy(NPObject *npobj)\\n     return;\\n   }\\n \\n-  NPObjWrapperHashEntry *entry =\\n-    NS_STATIC_CAST(NPObjWrapperHashEntry *,\\n-                   PL_DHashTableOperate(&sNPObjWrappers, npobj,\\n-                                        PL_DHASH_LOOKUP));\\n+  NPObjWrapperHashEntry *entry = static_cast<NPObjWrapperHashEntry *>\\n+    (PL_DHashTableOperate(&sNPObjWrappers, npobj, PL_DHASH_LOOKUP));\\n \\n   if (PL_DHASH_ENTRY_IS_BUSY(entry) && entry->mJSObj) {\\n     // Found a live NPObject wrapper, null out its JSObjects' private\\n@@ -1530,10 +1528,9 @@ nsNPObjWrapper::GetNewOrUsed(NPP npp, JSContext *cx, NPObject *npobj)\\n     }\\n   }\\n \\n-  NPObjWrapperHashEntry *entry =\\n-    static_cast<NPObjWrapperHashEntry *>\\n-               (PL_DHashTableOperate(&sNPObjWrappers, npobj,\\n-                                        PL_DHASH_ADD));\\n+  NPObjWrapperHashEntry *entry = static_cast<NPObjWrapperHashEntry *>\\n+    (PL_DHashTableOperate(&sNPObjWrappers, npobj, PL_DHASH_ADD));\\n+\\n   if (!entry) {\\n     // Out of memory\\n     JS_ReportOutOfMemory(cx);\\n@@ -1558,7 +1555,7 @@ nsNPObjWrapper::GetNewOrUsed(NPP npp, JSContext *cx, NPObject *npobj)\\n   if (!obj) {\\n     // OOM? Remove the stale entry from the hash.\\n \\n-    PL_DHashTableRawRemove(&sJSObjWrappers, entry);\\n+    PL_DHashTableRawRemove(&sNPObjWrappers, entry);\\n \\n     return nsnull;\\n   }\\n@@ -1567,13 +1564,8 @@ nsNPObjWrapper::GetNewOrUsed(NPP npp, JSContext *cx, NPObject *npobj)\\n \\n   entry->mJSObj = obj;\\n \\n-  if (!::JS_SetPrivate(cx, obj, npobj)) {\\n-    NS_ERROR(\\\"Error setting private NPObject data in JS wrapper!\\\");\\n-\\n-    PL_DHashTableRawRemove(&sJSObjWrappers, entry);\\n-\\n-    return nsnull;\\n-  }\\n+  // JS_SetPrivate() never fails.\\n+  ::JS_SetPrivate(cx, obj, npobj);\\n \\n   // The new JSObject now holds on to npobj\\n   _retainobject(npobj);\\n@@ -1780,12 +1772,8 @@ LookupNPP(NPObject *npobj)\\n     return nsnull;\\n   }\\n \\n-\\n-\\n-  NPObjWrapperHashEntry *entry =\\n-    static_cast<NPObjWrapperHashEntry *>\\n-               (PL_DHashTableOperate(&sNPObjWrappers, npobj,\\n-                                        PL_DHASH_ADD));\\n+  NPObjWrapperHashEntry *entry = static_cast<NPObjWrapperHashEntry *>\\n+    (PL_DHashTableOperate(&sNPObjWrappers, npobj, PL_DHASH_ADD));\\n \\n   if (PL_DHASH_ENTRY_IS_FREE(entry)) {\\n     return nsnull;\\n\""}