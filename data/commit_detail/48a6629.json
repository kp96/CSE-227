{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas48a6629\""},"diff":"\"48a6629 [OS/2] Bug 393013: update SetCursor to work correctly with Cairo, p=alfredkayser/me, r=mkaply\\ndiff --git a/widget/src/os2/nsWindow.cpp b/widget/src/os2/nsWindow.cpp\\nindex 476e30e..efa75d6 100644\\n--- a/widget/src/os2/nsWindow.cpp\\n+++ b/widget/src/os2/nsWindow.cpp\\n@@ -1889,9 +1889,11 @@ NS_IMETHODIMP nsWindow::SetCursor(imgIContainer* aCursor,\\n   if (NS_FAILED(rv))\\n     return rv;\\n \\n-  // only 24-bit images with 0, 1, or 8-bit alpha data are supported\\n-  if (format != gfxIFormats::BGR_A1 && format != gfxIFormats::BGR_A8 &&\\n-      format != gfxIFormats::BGR)\\n+  // only 24-bit images with 0, 1, or 8-bit alpha data are supported.\\n+  // These are all the formats used in Cairo, and all map to the RGB24 resp. ARGB32 Cairo formats.\\n+  if (format != gfxIFormats::BGR_A1 && format != gfxIFormats::RGB_A1 &&\\n+      format != gfxIFormats::BGR_A8 && format != gfxIFormats::RGB_A8 &&\\n+      format != gfxIFormats::BGR && format != gfxIFormats::RGB)\\n     return NS_ERROR_UNEXPECTED;\\n \\n   frame->LockImageData();\\n@@ -1904,42 +1906,19 @@ NS_IMETHODIMP nsWindow::SetCursor(imgIContainer* aCursor,\\n   }\\n \\n   // create the color bitmap\\n-  HBITMAP hBmp = 0;\\n-  hBmp = DataToBitmap(data, width, height, 24);\\n-  frame->UnlockImageData();\\n+  HBITMAP hBmp = CreateBitmapRGB(data, width, height);\\n   if (!hBmp)\\n     return NS_ERROR_FAILURE;\\n \\n-  // create a transparency mask from the alpha data;\\n-  HBITMAP hAlpha = 0;\\n-\\n-  // image has no alpha data - make the pointer opaque\\n-  if (format == gfxIFormats::BGR) {\\n-    hAlpha = CreateTransparencyMask(format, 0, width, height);\\n-    if (!hAlpha) {\\n-      GpiDeleteBitmap(hBmp);\\n-      return NS_ERROR_FAILURE;\\n-    }\\n+  // create a transparency mask from the alpha bytes\\n+  HBITMAP hAlpha = CreateTransparencyMask(format, data, width, height);\\n+  if (!hAlpha) {\\n+    GpiDeleteBitmap(hBmp);\\n+    return NS_ERROR_FAILURE;\\n   }\\n-  // image has either 1 or 8 bits of alpha data\\n-  else {\\n-    PRUint8* adata;\\n-    frame->LockAlphaData();\\n-    rv = frame->GetAlphaData(&adata, &dataLen);\\n-    if (NS_FAILED(rv)) {\\n-      GpiDeleteBitmap(hBmp);\\n-      frame->UnlockAlphaData();\\n-      return rv;\\n-    }\\n \\n-    // create the bitmap\\n-    hAlpha = CreateTransparencyMask(format, adata, width, height);\\n-    frame->UnlockAlphaData();\\n-    if (!hAlpha) {\\n-      GpiDeleteBitmap(hBmp);\\n-      return NS_ERROR_FAILURE;\\n-    }\\n-  }\\n+  // Unlock image data after both processing colors and alpha data\\n+  frame->UnlockImageData();\\n \\n   POINTERINFO info = {0};\\n   info.fPointer = TRUE;\\n@@ -2020,6 +1999,40 @@ HBITMAP nsWindow::DataToBitmap(PRUint8* aImageData, PRUint32 aWidth,\\n \\n //-------------------------------------------------------------------------\\n \\n+// create a RGB24 bitmap from Cairo image data\\n+\\n+HBITMAP nsWindow::CreateBitmapRGB(PRUint8* aImageData,\\n+                                  PRUint32 aWidth,\\n+                                  PRUint32 aHeight)\\n+{\\n+  // calc width in bytes, rounding up to a dword boundary\\n+  const PRUint32 bpr = ALIGNEDBPR(aWidth, 24);\\n+  PRUint8* bmp = (PRUint8*)malloc(bpr * aHeight);\\n+  if (!bmp)\\n+    return NULL;\\n+\\n+  PRUint32* pSrc = (PRUint32*)aImageData;\\n+  for (PRUint32 row = aHeight; row > 0; --row) {\\n+    PRUint8* pDst = bmp + bpr * (row - 1);\\n+\\n+    for (PRUint32 col = aWidth; col > 0; --col) {\\n+      // In Cairo a color is encoded as ARGB in a DWORD\\n+      // stored in machine endianess.\\n+      PRUint32 color = *pSrc++;\\n+      *pDst++ = color;       // Blue\\n+      *pDst++ = color >> 8;  // Green\\n+      *pDst++ = color >> 16; // Red\\n+    }\\n+  }\\n+\\n+  // create the bitmap\\n+  HBITMAP hAlpha = DataToBitmap(bmp, aWidth, aHeight, 24);\\n+\\n+  // free the buffer, then return the bitmap\\n+  free(bmp);\\n+  return hAlpha;\\n+}\\n+\\n // create a monochrome AND/XOR bitmap from 0, 1, or 8-bit alpha data\\n \\n HBITMAP nsWindow::CreateTransparencyMask(gfx_format format,\\n@@ -2031,64 +2044,38 @@ HBITMAP nsWindow::CreateTransparencyMask(gfx_format format,\\n   PRUint32 abpr = ALIGNEDBPR(aWidth, 1);\\n   PRUint32 cbData = abpr * aHeight;\\n \\n-  // alloc space to hold both the AND & XOR bitmaps\\n-  PRUint8* mono = (PRUint8*)malloc(cbData * 2);\\n+  // alloc and clear space to hold both the AND & XOR bitmaps\\n+  PRUint8* mono = (PRUint8*)calloc(cbData, 2);\\n   if (!mono)\\n     return NULL;\\n \\n-  // init the XOR bitmap to produce either black or transparent pixels\\n-  memset(mono, 0x00, cbData);\\n-\\n   switch (format) {\\n-\\n-    // make the AND mask opaque\\n-    case gfxIFormats::BGR:\\n-      memset(&mono[cbData], 0x00, cbData);\\n-      break;\\n-\\n-    // make the AND mask the inverse of the 1-bit alpha data\\n-    case gfxIFormats::BGR_A1: {\\n-      PRUint32* pSrc = (PRUint32*)aImageData;\\n-      PRUint32* pAnd = (PRUint32*)&mono[cbData];\\n-\\n-      for (PRUint32 dataNdx = 0; dataNdx < cbData; dataNdx += 4)\\n-        *pAnd++ = ~(*pSrc++);\\n-\\n-      break;\\n-    }\\n+    // gfxIFormats::BGR and case gfxIFormats::RGB are already\\n+    // taken care of by initializing XOR and AND masks to zero\\n \\n     // make the AND mask the inverse of the 8-bit alpha data\\n+    case gfxIFormats::BGR_A1:\\n+    case gfxIFormats::RGB_A1:\\n+    case gfxIFormats::RGB_A8:\\n     case gfxIFormats::BGR_A8: {\\n-      PRUint8*  pSrc = aImageData;\\n-      PRUint32* pAnd = (PRUint32*)&mono[cbData];\\n-\\n-      // if aWidth isn't a multiple of 4, the input contains byte padding;\\n-      // if aWidth isn't a multiple of 32, the output contains bit padding\\n-      for (PRUint32 dataNdx = 0; dataNdx < cbData; dataNdx += 4) {\\n-        PRUint32 dst = 0;\\n-        PRUint32 colNdx = 0;\\n-\\n-        // construct an output dword, then save\\n-        for (PRUint32 byteNdx = 0; byteNdx < 4; byteNdx++) {\\n-          PRUint32 mask = 0x80 << (byteNdx * 8);\\n-\\n-          // construct an output byte from 8 input bytes\\n-          for (PRUint32 bitNdx = 0; bitNdx < 8; bitNdx++) {\\n-            if (*pSrc++ < 128)\\n-              dst |= mask;\\n-            mask >>= 1;\\n-\\n-            // at the end of a row, skip over any padding in the\\n-            // input, then break out of the byte & dword loops\\n-            if (++colNdx >= aWidth) {\\n-              pSrc += (4 - (aWidth & 3)) & 3;\\n-              break;\\n-            }\\n+      PRInt32* pSrc = (PRInt32*)aImageData;\\n+      for (PRUint32 row = aHeight; row > 0; --row) {\\n+        // Point to the right row in the AND mask\\n+        PRUint8* pDst = mono + cbData + abpr * (row - 1);\\n+        PRUint8 mask = 0x80;\\n+        for (PRUint32 col = aWidth; col > 0; --col) {\\n+          // Use sign bit to test for transparency, as alpha byte is highest byte\\n+          // Positive means, alpha < 128, so consider as transparent and set the AND mask\\n+          if (*pSrc++ >= 0) {\\n+            *pDst |= mask;\\n+          }\\n+\\n+          mask >>= 1;\\n+          if (!mask) {\\n+            pDst++;\\n+            mask = 0x80;\\n           }\\n-          if (colNdx >= aWidth)\\n-            break;\\n         }\\n-        *pAnd++ = dst;\\n       }\\n \\n       break;\\ndiff --git a/widget/src/os2/nsWindow.h b/widget/src/os2/nsWindow.h\\nindex 0b3726c..5299ec1 100644\\n--- a/widget/src/os2/nsWindow.h\\n+++ b/widget/src/os2/nsWindow.h\\n@@ -336,6 +336,7 @@ protected:\\n \\n    HBITMAP DataToBitmap(PRUint8* aImageData, PRUint32 aWidth,\\n                         PRUint32 aHeight, PRUint32 aDepth);\\n+   HBITMAP CreateBitmapRGB(PRUint8* aImageData, PRUint32 aWidth, PRUint32 aHeight);\\n    // 'format' should be 'gfx_format' which is a PRInt32\\n    HBITMAP CreateTransparencyMask(PRInt32  format, PRUint8* aImageData,\\n                                   PRUint32 aWidth, PRUint32 aHeight);\\n\""}