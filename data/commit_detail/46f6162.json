{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas46f6162\""},"diff":"\"46f6162 move Listener and read_stream to its own head file so that it can be reused by other tests\\ndiff --git a/netwerk/test/unit/head_channels.js b/netwerk/test/unit/head_channels.js\\nnew file mode 100644\\nindex 0000000..b78fba0\\n--- /dev/null\\n+++ b/netwerk/test/unit/head_channels.js\\n@@ -0,0 +1,96 @@\\n+/**\\n+ * Read count bytes from stream and return as a String object\\n+ */\\n+function read_stream(stream, count) {\\n+  /* assume stream has non-ASCII data */\\n+  var wrapper =\\n+      Components.classes[\\\"@mozilla.org/binaryinputstream;1\\\"]\\n+                .createInstance(Components.interfaces.nsIBinaryInputStream);\\n+  wrapper.setInputStream(stream);\\n+  /* JS methods can be called with a maximum of 65535 arguments, and input\\n+     streams don't have to return all the data they make .available() when\\n+     asked to .read() that number of bytes. */\\n+  var data = [];\\n+  while (count > 0) {\\n+    var bytes = wrapper.readByteArray(Math.min(65535, count));\\n+    data.push(String.fromCharCode.apply(null, bytes));\\n+    count -= bytes.length;\\n+    if (bytes.length == 0)\\n+      do_throw(\\\"Nothing read from input stream!\\\");\\n+  }\\n+  return data.join('');\\n+}\\n+\\n+/**\\n+ * A stream listener that calls a callback function with a specified\\n+ * context and the received data when the channel is loaded.\\n+ *\\n+ * Signature of the closure:\\n+ *   void closure(in nsIRequest request, in ACString data, in JSObject context);\\n+ *\\n+ * This listener makes sure that various parts of the channel API are\\n+ * implemented correctly and that the channel's status is a success code.\\n+ *\\n+ * Note that it also requires a valid content length on the channel and\\n+ * is thus not fully generic.\\n+ */\\n+function ChannelListener(closure, ctx) {\\n+  this._closure = closure;\\n+  this._closurectx = ctx;\\n+}\\n+ChannelListener.prototype = {\\n+  _closure: null,\\n+  _closurectx: null,\\n+  _buffer: \\\"\\\",\\n+  _got_onstartrequest: false,\\n+  _got_onstoprequest: false,\\n+  _contentLen: -1,\\n+\\n+  QueryInterface: function(iid) {\\n+    if (iid.Equals(Components.interfaces.nsIStreamChannelListener) ||\\n+        iid.Equals(Components.interfaces.nsIRequestObserver) ||\\n+        iid.Equals(Components.interfaces.nsISupports))\\n+      return this;\\n+    throw Components.results.NS_ERROR_NO_INTERFACE;\\n+  },\\n+\\n+  onStartRequest: function(request, context) {\\n+    if (this._got_onstartrequest)\\n+      do_throw(\\\"Got second onStartRequest event!\\\");\\n+    this._got_onstartrequest = true;\\n+\\n+    request.QueryInterface(Components.interfaces.nsIChannel);\\n+    this._contentLen = request.contentLength;\\n+    if (this._contentLen == -1)\\n+      do_throw(\\\"Content length is unknown in onStartRequest!\\\");\\n+  },\\n+\\n+  onDataAvailable: function(request, context, stream, offset, count) {\\n+    if (!this._got_onstartrequest)\\n+      do_throw(\\\"onDataAvailable without onStartRequest event!\\\");\\n+    if (this._got_onstoprequest)\\n+      do_throw(\\\"onDataAvailable after onStopRequest event!\\\");\\n+    if (!request.isPending())\\n+      do_throw(\\\"request reports itself as not pending from onStartRequest!\\\");\\n+\\n+    this._buffer = this._buffer.concat(read_stream(stream, count));\\n+  },\\n+\\n+  onStopRequest: function(request, context, status) {\\n+    if (!this._got_onstartrequest)\\n+      do_throw(\\\"onStopRequest without onStartRequest event!\\\");\\n+    if (this._got_onstoprequest)\\n+      do_throw(\\\"Got second onStopRequest event!\\\");\\n+    this._got_onstoprequest = true;\\n+    if (!Components.isSuccessCode(status))\\n+      do_throw(\\\"Failed to load URL: \\\" + status.toString(16));\\n+    if (status != request.status)\\n+      do_throw(\\\"request.status does not match status arg to onStopRequest!\\\");\\n+    if (request.isPending())\\n+      do_throw(\\\"request reports itself as pending from onStopRequest!\\\");\\n+    if (this._contentLen != -1 && this._buffer.length != this._contentLen)\\n+      do_throw(\\\"did not read nsIChannel.contentLength number of bytes!\\\");\\n+\\n+    this._closure(request, this._buffer, this._closurectx);\\n+  }\\n+};\\ndiff --git a/netwerk/test/unit/test_data_protocol.js b/netwerk/test/unit/test_data_protocol.js\\nindex cc19b43..06f6b0e 100644\\n--- a/netwerk/test/unit/test_data_protocol.js\\n+++ b/netwerk/test/unit/test_data_protocol.js\\n@@ -22,89 +22,6 @@ function run_next_test() {\\n   test_array[test_index++]();\\n }\\n \\n-/* read count bytes from stream and return as a String object */\\n-function read_stream(stream, count) {\\n-  /* assume stream has non-ASCII data */\\n-  var wrapper =\\n-      Cc[\\\"@mozilla.org/binaryinputstream;1\\\"].\\n-      createInstance(Ci.nsIBinaryInputStream);\\n-  wrapper.setInputStream(stream);\\n-  /* JS methods can be called with a maximum of 65535 arguments, and input\\n-     streams don't have to return all the data they make .available() when\\n-     asked to .read() that number of bytes. */\\n-  var data = [];\\n-  while (count > 0) {\\n-    var bytes = wrapper.readByteArray(Math.min(65535, count));\\n-    data.push(String.fromCharCode.apply(null, bytes));\\n-    count -= bytes.length;\\n-    if (bytes.length == 0)\\n-      do_throw(\\\"Nothing read from input stream!\\\");\\n-  }\\n-  return data.join('');\\n-}\\n-\\n-/* stream listener */\\n-function Listener(closure, ctx) {\\n-  this._closure = closure;\\n-  this._closurectx = ctx;\\n-}\\n-Listener.prototype = {\\n-  _closure: null,\\n-  _closurectx: null,\\n-  _buffer: \\\"\\\",\\n-  _got_onstartrequest: false,\\n-  _got_onstoprequest: false,\\n-  _contentLen: -1,\\n-\\n-  QueryInterface: function(iid) {\\n-    if (iid.Equals(Ci.nsIStreamListener) ||\\n-        iid.Equals(Ci.nsIRequestObserver) ||\\n-        iid.Equals(Ci.nsISupports))\\n-      return this;\\n-    throw Cr.NS_ERROR_NO_INTERFACE;\\n-  },\\n-\\n-  onStartRequest: function(request, context) {\\n-    if (this._got_onstartrequest)\\n-      do_throw(\\\"Got second onStartRequest event!\\\");\\n-    this._got_onstartrequest = true;\\n-\\n-    request.QueryInterface(Ci.nsIChannel);\\n-    this._contentLen = request.contentLength;\\n-    if (this._contentLen == -1)\\n-      do_throw(\\\"Content length is unknown in onStartRequest!\\\");\\n-  },\\n-\\n-  onDataAvailable: function(request, context, stream, offset, count) {\\n-    if (!this._got_onstartrequest)\\n-      do_throw(\\\"onDataAvailable without onStartRequest event!\\\");\\n-    if (this._got_onstoprequest)\\n-      do_throw(\\\"onDataAvailable after onStopRequest event!\\\");\\n-    if (!request.isPending())\\n-      do_throw(\\\"request reports itself as not pending from onStartRequest!\\\");\\n-\\n-    this._buffer = this._buffer.concat(read_stream(stream, count));\\n-  },\\n-\\n-  onStopRequest: function(request, context, status) {\\n-    if (!this._got_onstartrequest)\\n-      do_throw(\\\"onStopRequest without onStartRequest event!\\\");\\n-    if (this._got_onstoprequest)\\n-      do_throw(\\\"Got second onStopRequest event!\\\");\\n-    this._got_onstoprequest = true;\\n-    if (!Components.isSuccessCode(status))\\n-      do_throw(\\\"Failed to load URL: \\\" + status.toString(16));\\n-    if (status != request.status)\\n-      do_throw(\\\"request.status does not match status arg to onStopRequest!\\\");\\n-    if (request.isPending())\\n-      do_throw(\\\"request reports itself as pending from onStopRequest!\\\");\\n-    if (this._contentLen != -1 && this._buffer.length != this._contentLen)\\n-      do_throw(\\\"did not read nsIChannel.contentLength number of bytes!\\\");\\n-\\n-    this._closure(request, this._buffer, this._closurectx);\\n-  }\\n-};\\n-\\n function run_test() {\\n   dump(\\\"*** run_test\\\\n\\\");\\n \\n@@ -127,7 +44,7 @@ function run_test() {\\n     do_test_pending();\\n     var chan = ios.newChannel(urls[i][0], \\\"\\\", null);\\n     chan.contentType = \\\"foo/bar\\\"; // should be ignored\\n-    chan.asyncOpen(new Listener(on_read_complete, i), null);\\n+    chan.asyncOpen(new ChannelListener(on_read_complete, i), null);\\n   }\\n }\\n \\ndiff --git a/netwerk/test/unit/test_file_protocol.js b/netwerk/test/unit/test_file_protocol.js\\nindex ebe7fad..577bbfd 100644\\n--- a/netwerk/test/unit/test_file_protocol.js\\n+++ b/netwerk/test/unit/test_file_protocol.js\\n@@ -26,27 +26,6 @@ function getFile(key) {\\n   return dirSvc.get(key, Components.interfaces.nsILocalFile);\\n }\\n \\n-/* read count bytes from stream and return as a String object */\\n-function read_stream(stream, count) {\\n-  /* assume stream has non-ASCII data */\\n-  var wrapper =\\n-      Cc[\\\"@mozilla.org/binaryinputstream;1\\\"].\\n-      createInstance(Ci.nsIBinaryInputStream);\\n-  wrapper.setInputStream(stream);\\n-  /* JS methods can be called with a maximum of 65535 arguments, and input\\n-     streams don't have to return all the data they make .available() when\\n-     asked to .read() that number of bytes. */\\n-  var data = [];\\n-  while (count > 0) {\\n-    var bytes = wrapper.readByteArray(Math.min(65535, count));\\n-    data.push(String.fromCharCode.apply(null, bytes));\\n-    count -= bytes.length;\\n-    if (bytes.length == 0)\\n-      do_throw(\\\"Nothing read from input stream!\\\");\\n-  }\\n-  return data.join('');\\n-}\\n-\\n function new_file_input_stream(file, buffered) {\\n   var stream =\\n       Cc[\\\"@mozilla.org/network/file-input-stream;1\\\"].\\n@@ -69,11 +48,15 @@ function new_file_channel(file) {\\n   return ios.newChannelFromURI(ios.newFileURI(file));\\n }\\n \\n-/* stream listener */\\n-function Listener(closure) {\\n+/*\\n+ * stream listener\\n+ * this listener has some additional file-specific tests, so we can't just use\\n+ * ChannelListener here.\\n+ */\\n+function FileStreamListener(closure) {\\n   this._closure = closure;\\n }\\n-Listener.prototype = {\\n+FileStreamListener.prototype = {\\n   _closure: null,\\n   _buffer: \\\"\\\",\\n   _got_onstartrequest: false,\\n@@ -160,7 +143,7 @@ function test_read_file() {\\n   }\\n \\n   chan.contentType = special_type;\\n-  chan.asyncOpen(new Listener(on_read_complete), null);\\n+  chan.asyncOpen(new FileStreamListener(on_read_complete), null);\\n }\\n \\n function do_test_read_dir(set_type, expected_type) {\\n@@ -182,7 +165,7 @@ function do_test_read_dir(set_type, expected_type) {\\n \\n   if (set_type)\\n     chan.contentType = expected_type;\\n-  chan.asyncOpen(new Listener(on_read_complete), null);\\n+  chan.asyncOpen(new FileStreamListener(on_read_complete), null);\\n }\\n \\n function test_read_dir_1() {\\n@@ -241,7 +224,7 @@ function test_upload_file() {\\n   }\\n \\n   chan.contentType = special_type;\\n-  chan.asyncOpen(new Listener(on_upload_complete), null);\\n+  chan.asyncOpen(new FileStreamListener(on_upload_complete), null);\\n }\\n \\n function run_test() {\\n\""}