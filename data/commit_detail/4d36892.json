{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas4d36892\""},"diff":"\"4d36892 Bug 387990 [a11y] mouse pointer position can prevent keyboard access to submenus r+sr=roc a=roc\\ndiff --git a/widget/src/gtk2/nsWindow.cpp b/widget/src/gtk2/nsWindow.cpp\\nindex 65c2cef..42f360b 100644\\n--- a/widget/src/gtk2/nsWindow.cpp\\n+++ b/widget/src/gtk2/nsWindow.cpp\\n@@ -227,6 +227,9 @@ static nsresult    initialize_prefs        (void);\\n nsWindow *nsWindow::mLastDragMotionWindow = NULL;\\n PRBool nsWindow::sIsDraggingOutOf = PR_FALSE;\\n \\n+// the last window that had a MOUSE_ENTER event\\n+nsWindow *nsWindow::sLastMouseEnterWindow = nsnull;\\n+\\n // This is the time of the last button press event.  The drag service\\n // uses it as the time to start drags.\\n guint32   nsWindow::mLastButtonPressTime = 0;\\n@@ -419,6 +422,10 @@ nsWindow::Destroy(void)\\n     if (mIsDestroyed || !mCreated)\\n         return NS_OK;\\n \\n+    if (this == sLastMouseEnterWindow) {\\n+        sLastMouseEnterWindow = nsnull;\\n+    }\\n+\\n     LOG((\\\"nsWindow::Destroy [%p]\\\\n\\\", (void *)this));\\n     mIsDestroyed = PR_TRUE;\\n     mCreated = PR_FALSE;\\n@@ -1889,6 +1896,14 @@ nsWindow::OnEnterNotifyEvent(GtkWidget *aWidget, GdkEventCrossing *aEvent)\\n     if (aEvent->subwindow != NULL)\\n         return;\\n \\n+    // Do not fire MOUSE_ENTER event if the mouse pointer is not on it.\\n+    // In this case, enter_notify_event is not triggered by mouse.\\n+    if (aEvent->x < 0 || aEvent->y < 0 ||\\n+        aEvent->x >= mBounds.width || aEvent->y >= mBounds.height) {\\n+        return;\\n+    }\\n+    sLastMouseEnterWindow = this;\\n+\\n     nsMouseEvent event(PR_TRUE, NS_MOUSE_ENTER, this, nsMouseEvent::eReal);\\n \\n     event.refPoint.x = nscoord(aEvent->x);\\n@@ -1909,6 +1924,16 @@ nsWindow::OnLeaveNotifyEvent(GtkWidget *aWidget, GdkEventCrossing *aEvent)\\n     if (aEvent->subwindow != NULL)\\n         return;\\n \\n+    // Do not fire MOUSE_EXIT event if the last MOUSE_ENTER event was not for\\n+    // the leaving window, or the mouse pointer is still on the leaving window.\\n+    // In this case, leave_notify_event is not triggered by mouse.\\n+    if (this != sLastMouseEnterWindow ||\\n+        (aEvent->x >= 0 && aEvent->y >= 0 &&\\n+         aEvent->x < mBounds.width && aEvent->y < mBounds.height)) {\\n+        return;\\n+    }\\n+    sLastMouseEnterWindow = nsnull;\\n+\\n     nsMouseEvent event(PR_TRUE, NS_MOUSE_EXIT, this, nsMouseEvent::eReal);\\n \\n     event.refPoint.x = nscoord(aEvent->x);\\ndiff --git a/widget/src/gtk2/nsWindow.h b/widget/src/gtk2/nsWindow.h\\nindex a4842ba..6e6ea43 100644\\n--- a/widget/src/gtk2/nsWindow.h\\n+++ b/widget/src/gtk2/nsWindow.h\\n@@ -426,6 +426,9 @@ private:\\n     // drag in progress\\n     static PRBool DragInProgress(void);\\n \\n+    // the last window that had a MOUSE_ENTER event\\n+    static nsWindow  *sLastMouseEnterWindow;\\n+\\n     void         ResetDragMotionTimer     (GtkWidget      *aWidget,\\n                                            GdkDragContext *aDragContext,\\n                                            gint           aX,\\n\""}