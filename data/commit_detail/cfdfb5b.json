{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bascfdfb5b\""},"diff":"\"cfdfb5b [OS/2] Bug 393776: Little nsWindow cleanup (remove obsolete commented code), r=mkaply\\ndiff --git a/widget/src/os2/nsWindow.cpp b/widget/src/os2/nsWindow.cpp\\nindex 015af1a..476e30e 100644\\n--- a/widget/src/os2/nsWindow.cpp\\n+++ b/widget/src/os2/nsWindow.cpp\\n@@ -60,12 +60,9 @@\\n #include \\\"nsTransform2D.h\\\"\\n #include \\\"nsGfxCIID.h\\\"\\n #include \\\"prtime.h\\\"\\n-// #include \\\"nsTooltipManager.h\\\"\\n #include \\\"nsISupportsArray.h\\\"\\n #include \\\"nsIMenuBar.h\\\"\\n-//#include \\\"nsIMenuItem.h\\\"\\n #include \\\"nsHashtable.h\\\"\\n-//#include \\\"nsMenu.h\\\"\\n #include \\\"nsDragService.h\\\"\\n #include \\\"nsILocalFile.h\\\"\\n #include \\\"nsNetUtil.h\\\"\\n@@ -77,7 +74,7 @@\\n #include \\\"nsIPrefBranch.h\\\"\\n #include \\\"nsIPrefService.h\\\"\\n \\n-//~~~ windowless plugin support\\n+// windowless plugin support\\n #include \\\"nsplugindefs.h\\\"\\n \\n #include \\\"nsITimer.h\\\"\\n@@ -163,7 +160,7 @@ static PRBool gIsDBCS = PR_FALSE;\\n static PRUint32 gLastInputEventTime = 0;\\n \\n #ifdef DEBUG_FOCUS\\n-  int currentWindowIdentifier = 0;\\n+int currentWindowIdentifier = 0;\\n #endif\\n \\n //-------------------------------------------------------------------------\\n@@ -308,8 +305,7 @@ nsWindow::~nsWindow()\\n     mWindowState |= nsWindowState_eDoingDelete;\\n     mWindowState &= ~(nsWindowState_eLive|nsWindowState_ePrecreate|\\n                       nsWindowState_eInCreate);\\n-//    if( mWnd)\\n-      Destroy();\\n+    Destroy();\\n   }\\n \\n }\\n@@ -329,7 +325,6 @@ NS_METHOD nsWindow::CaptureMouse(PRBool aCapture)\\n   } else {\\n     WinSetCapture( HWND_DESKTOP, NULLHANDLE);\\n   }\\n-//  mIsInMouseCapture = aCapture;\\n   return NS_OK;\\n }\\n \\n@@ -910,11 +905,6 @@ void nsWindow::RealDoCreate( HWND              hwndP,\\n                              nsWidgetInitData *aInitData,\\n                              HWND              hwndOwner)\\n {\\n-\\n-  // XXXX TEST HACK to get rid of window bunnies\\n-  //  if (!(aRect.height > 1) && !(aRect.width > 1))\\n-  //    return;\\n-\\n    // Set up parent data - don't addref to avoid circularity\\n    mParent = aParent;\\n \\n@@ -2282,7 +2272,6 @@ void* nsWindow::GetNativeData(PRUint32 aDataType)\\n     return NULL;\\n }\\n \\n-//~~~\\n void nsWindow::FreeNativeData(void * data, PRUint32 aDataType)\\n {\\n   switch(aDataType)\\n@@ -2652,15 +2641,6 @@ PRBool nsWindow::ProcessMessage( ULONG msg, MPARAM mp1, MPARAM mp2, MRESULT &rc)\\n            result = DispatchWindowEvent(&event);\\n            NS_RELEASE(event.widget);\\n         }\\n-#if 0\\n-        case WM_INITMENU:\\n-          result = OnActivateMenu( HWNDFROMMP(mp2), TRUE);\\n-          break;\\n-\\n-        case WM_MENUEND:\\n-          result = OnActivateMenu( HWNDFROMMP(mp2), FALSE);\\n-          break;\\n-#endif\\n \\n         case WM_CONTROL: // remember this is resent to the orginator...\\n           result = OnControl( mp1, mp2);\\n@@ -3399,7 +3379,7 @@ PRBool nsWindow::DispatchMouseEvent(PRUint32 aEventType, MPARAM mp1, MPARAM mp2,\\n \\n   nsPluginEvent pluginEvent;\\n \\n-  switch (aEventType)//~~~\\n+  switch (aEventType)\\n   {\\n     case NS_MOUSE_BUTTON_DOWN:\\n       switch (aButton) {\\n@@ -3464,85 +3444,8 @@ PRBool nsWindow::DispatchMouseEvent(PRUint32 aEventType, MPARAM mp1, MPARAM mp2,\\n \\n   // call the event callback \\n   if (nsnull != mEventCallback) {\\n-\\n     result = DispatchWindowEvent(&event);\\n \\n-#if 0  // OS2TODO\\n-    if (aEventType == NS_MOUSE_MOVE) {\\n-\\n-      // if we are not in mouse capture mode (mouse down and hold)\\n-      // then use \\\"this\\\" window\\n-      // if we are in mouse capture, then all events are being directed\\n-      // back to the nsWindow doing the capture. So therefore, the detection\\n-      // of whether we are in a new nsWindow is wrong. Meaning this MOUSE_MOVE\\n-      // event hold the captured windows pointer not the one the mouse is over.\\n-      //\\n-      // So we use \\\"WindowFromPoint\\\" to find what window we are over and \\n-      // set that window into the mouse trailer timer.\\n-      if (!mIsInMouseCapture) {\\n-        MouseTrailer * mouseTrailer = MouseTrailer::GetMouseTrailer(0);\\n-        MouseTrailer::SetMouseTrailerWindow(this);\\n-        mouseTrailer->CreateTimer();\\n-      } else {\\n-        POINT mp;\\n-        DWORD pos = ::GetMessagePos();\\n-        mp.x      = LOWORD(pos);\\n-        mp.y      = HIWORD(pos);\\n-\\n-        // OK, now find out if we are still inside\\n-        // the captured native window\\n-        POINT cpos;\\n-        cpos.x = LOWORD(pos);\\n-        cpos.y = HIWORD(pos);\\n-\\n-        nsWindow * someWindow = NULL;\\n-        HWND hWnd = ::WindowFromPoint(mp);\\n-        if (hWnd != NULL) {\\n-          ::ScreenToClient(hWnd, &cpos);\\n-          RECT r;\\n-          VERIFY(::GetWindowRect(hWnd, &r));\\n-          if (cpos.x >= r.left && cpos.x <= r.right &&\\n-              cpos.y >= r.top && cpos.y <= r.bottom) {\\n-            // yes we are so we should be able to get a valid window\\n-            // although, strangley enough when we are on the frame part of the\\n-            // window we get right here when in capture mode\\n-            // but this window won't match the capture mode window so\\n-            // we are ok\\n-            someWindow = (nsWindow*)::GetWindowLong(hWnd, GWL_USERDATA);\\n-          } \\n-        }\\n-        // only set the window into the mouse trailer if we have a good window\\n-        if (nsnull != someWindow)  {\\n-          MouseTrailer * mouseTrailer = MouseTrailer::GetMouseTrailer(0);\\n-          MouseTrailer::SetMouseTrailerWindow(someWindow);\\n-          mouseTrailer->CreateTimer();\\n-        }\\n-      }\\n-\\n-      nsRect rect;\\n-      GetBounds(rect);\\n-      rect.x = 0;\\n-      rect.y = 0;\\n-\\n-      if (rect.Contains(event.refPoint.x, event.refPoint.y)) {\\n-        if (gCurrentWindow == NULL || gCurrentWindow != this) {\\n-          if ((nsnull != gCurrentWindow) && (!gCurrentWindow->mIsDestroying)) {\\n-            MouseTrailer::IgnoreNextCycle();\\n-            gCurrentWindow->DispatchMouseEvent(NS_MOUSE_EXIT, gCurrentWindow->GetLastPoint());\\n-          }\\n-          gCurrentWindow = this;\\n-          if (!mIsDestroying) {\\n-            gCurrentWindow->DispatchMouseEvent(NS_MOUSE_ENTER);\\n-          }\\n-        }\\n-      } \\n-    } else if (aEventType == NS_MOUSE_EXIT) {\\n-      if (gCurrentWindow == this) {\\n-        gCurrentWindow = nsnull;\\n-      }\\n-    }\\n-#endif //OS2TODO\\n-\\n     // Release the widget with NS_IF_RELEASE() just in case\\n     // the context menu key code in nsEventListenerManager::HandleEvent()\\n     // released it already.\\n@@ -3560,10 +3463,7 @@ PRBool nsWindow::DispatchMouseEvent(PRUint32 aEventType, MPARAM mp1, MPARAM mp2,\\n           if (gCurrentWindow == NULL || gCurrentWindow != this) {\\n             gCurrentWindow = this;\\n           }\\n-        } else {\\n-          //printf(\\\"Mouse exit\\\");\\n         }\\n-\\n       } break;\\n \\n       case NS_MOUSE_BUTTON_DOWN:\\n@@ -3572,7 +3472,6 @@ PRBool nsWindow::DispatchMouseEvent(PRUint32 aEventType, MPARAM mp1, MPARAM mp2,\\n \\n       case NS_MOUSE_BUTTON_UP:\\n         result = ConvertStatus(mMouseListener->MouseReleased(event));\\n-//        result = ConvertStatus(mMouseListener->MouseClicked(event));\\n         break;\\n \\n       case NS_MOUSE_CLICK:\\n@@ -3606,7 +3505,7 @@ PRBool nsWindow::DispatchFocus(PRUint32 aEventType, PRBool isMozWindowTakingFocu\\n \\n     nsPluginEvent pluginEvent;\\n \\n-    switch (aEventType)//~~~\\n+    switch (aEventType)\\n     {\\n       case NS_GOTFOCUS:\\n         pluginEvent.event = WM_SETFOCUS;\\ndiff --git a/widget/src/os2/nsWindow.h b/widget/src/os2/nsWindow.h\\nindex db65164..0b3726c 100644\\n--- a/widget/src/os2/nsWindow.h\\n+++ b/widget/src/os2/nsWindow.h\\n@@ -195,13 +195,6 @@ class nsWindow : public nsBaseWidget,\\n    NS_IMETHOD              ScrollWidgets(PRInt32 aDx, PRInt32 aDy);\\n    NS_IMETHOD              ScrollRect(nsRect &aRect, PRInt32 aDx, PRInt32 aDy);\\n \\n-#if 0 // Handled by XP code now\\n-   // Tooltips\\n-   NS_IMETHOD SetTooltips( PRUint32 aNumberOfTips, nsRect *aTooltipAreas[]);   \\n-   NS_IMETHOD RemoveTooltips();\\n-   NS_IMETHOD UpdateTooltips( nsRect* aNewTips[]);\\n-#endif\\n-\\n    // Get a HWND or a HPS.\\n    virtual void  *GetNativeData( PRUint32 aDataType);\\n    virtual void   FreeNativeData( void *aDatum, PRUint32 aDataType);\\n@@ -260,8 +253,6 @@ protected:\\n    virtual PRBool OnVScroll( MPARAM mp1, MPARAM mp2);\\n    virtual PRBool OnHScroll( MPARAM mp1, MPARAM mp2);\\n    virtual PRBool OnControl( MPARAM mp1, MPARAM mp2);\\n-//   virtual PRBool OnMenuClick( USHORT aCmd);\\n-//   virtual PRBool OnActivateMenu( HWND aMenu, BOOL aActivate);\\n    // called after param has been set...\\n    virtual PRBool OnPresParamChanged( MPARAM mp1, MPARAM mp2);\\n    virtual PRBool OnDragDropMsg(ULONG msg, MPARAM mp1, MPARAM mp2, MRESULT &mr);\\n\""}