{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas70b254f\""},"diff":"\"70b254f Back out the patch for bug 393845 because it appears the regressions it caused are worse than the bug it fixed (a=biesi)\\ndiff --git a/content/base/src/nsObjectLoadingContent.cpp b/content/base/src/nsObjectLoadingContent.cpp\\nindex d2f7029..7634e79 100644\\n--- a/content/base/src/nsObjectLoadingContent.cpp\\n+++ b/content/base/src/nsObjectLoadingContent.cpp\\n@@ -142,8 +142,6 @@ nsAsyncInstantiateEvent::Run()\\n            mContent, mContentType.get(), mURI.get(), spec.get()));\\n     }\\n \\n-    // We don't have to stop the plugin because we only use the event\\n-    // for newly created frames that don't have a plugin loaded yet.\\n     nsresult rv = mContent->Instantiate(frame, mContentType, mURI);\\n     if (NS_FAILED(rv)) {\\n       mContent->Fallback(PR_TRUE);\\n@@ -525,8 +523,6 @@ nsObjectLoadingContent::OnStartRequest(nsIRequest *aRequest, nsISupports *aConte\\n         mInstantiating = PR_FALSE;\\n         return NS_BINDING_ABORTED;\\n       }\\n-      // We came here via eState_Loading. Therefore, our frame is newly\\n-      // created, thus we don't have to stop the plugin.\\n       rv = frame->Instantiate(chan, getter_AddRefs(mFinalListener));\\n       mInstantiating = PR_FALSE;\\n       break;\\n@@ -1518,21 +1514,6 @@ nsObjectLoadingContent::TryInstantiate(const nsACString& aMIMEType,\\n     LOG((\\\"OBJLC [%p]: Frame hasn't been reflown yet\\\\n\\\", this));\\n     return NS_OK; // Not a failure to have no frame\\n   }\\n-  // Stop the plugin first. Since that might destroy the frame,\\n-  // we have to get it again.\\n-  frame->StopPlugin();\\n-\\n-  frame = GetFrame(PR_FALSE);\\n-  if (!frame) {\\n-    LOG((\\\"OBJLC [%p]: No frame anymore\\\\n\\\", this));\\n-    return NS_OK; // Not a failure to have no frame\\n-  }\\n-  CallQueryInterface(frame, &iframe);\\n-  if (iframe->GetStateBits() & NS_FRAME_FIRST_REFLOW) {\\n-    LOG((\\\"OBJLC [%p]: New frame hasn't been reflown yet\\\\n\\\", this));\\n-    return NS_OK; // Not a failure to have no frame\\n-  }\\n-\\n   return Instantiate(frame, aMIMEType, aURI);\\n }\\n \\ndiff --git a/layout/generic/nsObjectFrame.cpp b/layout/generic/nsObjectFrame.cpp\\nindex c3a6628..44062e3 100644\\n--- a/layout/generic/nsObjectFrame.cpp\\n+++ b/layout/generic/nsObjectFrame.cpp\\n@@ -1374,8 +1374,9 @@ nsresult nsObjectFrame::GetPluginInstance(nsIPluginInstance*& aPluginInstance)\\n nsresult\\n nsObjectFrame::PrepareInstanceOwner()\\n {\\n-  // Our content node should have taken care of stopping the\\n-  // previously loaded plugin (if any)\\n+  // First, have to stop any possibly running plugins.\\n+  StopPluginInternal(PR_FALSE);\\n+\\n   NS_ASSERTION(!mInstanceOwner, \\\"Must not have an instance owner here\\\");\\n \\n   mInstanceOwner = new nsPluginInstanceOwner();\\n@@ -1544,10 +1545,7 @@ nsObjectFrame::StopPluginInternal(PRBool aDelayedStop)\\n     return;\\n   }\\n \\n-  nsRefPtr<nsPluginInstanceOwner> owner;\\n-  owner.swap(mInstanceOwner);\\n-\\n-  owner->PrepareToStop(aDelayedStop);\\n+  mInstanceOwner->PrepareToStop(aDelayedStop);\\n \\n #ifdef XP_WIN\\n   // We only deal with delayed stopping of plugins on Win32 for now,\\n@@ -1555,8 +1553,8 @@ nsObjectFrame::StopPluginInternal(PRBool aDelayedStop)\\n   // unclear how safe widget parenting is on other platforms.\\n   if (aDelayedStop) {\\n     // nsStopPluginRunnable will hold a strong reference to\\n-    // owner, and thus keep it alive as long as it needs it.\\n-    nsCOMPtr<nsIRunnable> evt = new nsStopPluginRunnable(owner);\\n+    // mInstanceOwner, and thus keep it alive as long as it needs it.\\n+    nsCOMPtr<nsIRunnable> evt = new nsStopPluginRunnable(mInstanceOwner);\\n     NS_DispatchToCurrentThread(evt);\\n \\n     // If we're asked to do a delayed stop it means we're stopping the\\n@@ -1570,13 +1568,13 @@ nsObjectFrame::StopPluginInternal(PRBool aDelayedStop)\\n   } else\\n #endif\\n   {\\n-    DoStopPlugin(owner);\\n-    // Stopping the plugin may have destroyed the frame.\\n-    // Do not touch any member variables after this line.\\n+    DoStopPlugin(mInstanceOwner);\\n   }\\n \\n   // Break relationship between frame and plugin instance owner\\n-  owner->SetOwner(nsnull);\\n+  mInstanceOwner->SetOwner(nsnull);\\n+\\n+  NS_RELEASE(mInstanceOwner);\\n }\\n \\n void\\n\""}