{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basb312070\""},"diff":"\"b312070 Bug 393464 - Re-landing tag-search so search-in-folders (bug 384228) and related work could get the same sort of love. patch by dietrich, r=sspitzer, a=mconnor.\\ndiff --git a/toolkit/components/places/public/nsITaggingService.idl b/toolkit/components/places/public/nsITaggingService.idl\\nindex cbf048f..de99adc 100644\\n--- a/toolkit/components/places/public/nsITaggingService.idl\\n+++ b/toolkit/components/places/public/nsITaggingService.idl\\n@@ -91,3 +91,9 @@ interface nsITaggingService : nsISupports\\n    */\\n   readonly attribute nsIVariant allTags;\\n };\\n+\\n+%{C++\\n+\\n+#define TAGGING_SERVICE_CID \\\"@mozilla.org/browser/tagging-service;1\\\"\\n+\\n+%}\\ndiff --git a/toolkit/components/places/src/nsNavHistory.cpp b/toolkit/components/places/src/nsNavHistory.cpp\\nindex 1af84fa..db548a6 100644\\n--- a/toolkit/components/places/src/nsNavHistory.cpp\\n+++ b/toolkit/components/places/src/nsNavHistory.cpp\\n@@ -69,6 +69,9 @@\\n #include \\\"prtime.h\\\"\\n #include \\\"prprf.h\\\"\\n #include \\\"nsEscape.h\\\"\\n+#include \\\"nsITaggingService.h\\\"\\n+#include \\\"nsIVariant.h\\\"\\n+#include \\\"nsVariant.h\\\"\\n \\n #include \\\"mozIStorageService.h\\\"\\n #include \\\"mozIStorageConnection.h\\\"\\n@@ -4096,6 +4099,45 @@ nsNavHistory::GroupByHost(nsNavHistoryQueryResultNode *aResultNode,\\n   return NS_OK;\\n }\\n \\n+PRBool\\n+nsNavHistory::URIHasTag(nsIURI* aURI, const nsAString& aTag)\\n+{\\n+  nsresult rv;\\n+  nsCOMPtr<nsITaggingService> tagService =\\n+    do_GetService(TAGGING_SERVICE_CID, &rv);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  nsCOMPtr<nsIVariant> tagsV;\\n+  rv = tagService->GetTagsForURI(aURI, getter_AddRefs(tagsV));\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  // confirm that type is array, and has elements\\n+  // (data type is different for empty array)\\n+  PRUint16 dataType;\\n+  tagsV->GetDataType(&dataType);\\n+  if (dataType != nsIDataType::VTYPE_ARRAY)\\n+    return PR_FALSE;\\n+\\n+  // get tags as array\\n+  PRUint16 type;\\n+  nsIID iid;\\n+  PRUint32 count;\\n+  PRUnichar** tags;\\n+  rv = tagsV->GetAsArray(&type, &iid, &count, (void**)&tags);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  for (PRUint32 i = 0; i < count; i++) {\\n+    nsAutoString tag(tags[i]);\\n+    PRInt32 position = Compare(tag, aTag, nsCaseInsensitiveStringComparator());\\n+    if (position == 0) {\\n+      nsMemory::Free(tags);\\n+      return PR_TRUE;\\n+    }\\n+  }\\n+  nsMemory::Free(tags);\\n+  return PR_FALSE;\\n+}\\n+\\n \\n // nsNavHistory::FilterResultSet\\n //\\n@@ -4161,6 +4203,7 @@ nsNavHistory::FilterResultSet(nsNavHistoryQueryResultNode* aParentNode,\\n     if (terms.Count() == 0) {\\n         allTermsFound = PR_TRUE;\\n     } else {\\n+\\n       for (PRInt32 termIndex = 0; termIndex < terms.Count(); termIndex ++) {\\n         PRBool termFound = PR_FALSE;\\n         // title and URL\\n@@ -4170,6 +4213,7 @@ nsNavHistory::FilterResultSet(nsNavHistoryQueryResultNode* aParentNode,\\n              CaseInsensitiveFindInReadable(*terms[termIndex],\\n                                     NS_ConvertUTF8toUTF16(aSet[nodeIndex]->mURI))))\\n           termFound = PR_TRUE;\\n+\\n         // searchable annotations\\n         /*if (! termFound) {\\n           for (PRInt32 annotIndex = 0; annotIndex < curAnnotations.Count(); annotIndex ++) {\\n@@ -4178,7 +4222,16 @@ nsNavHistory::FilterResultSet(nsNavHistoryQueryResultNode* aParentNode,\\n               termFound = PR_TRUE;\\n           }\\n         }*/\\n-        if (! termFound) {\\n+\\n+        // search tags\\n+        if (!termFound) {\\n+          nsCOMPtr<nsIURI> itemURI;\\n+          rv = NS_NewURI(getter_AddRefs(itemURI), aSet[nodeIndex]->mURI);\\n+          NS_ENSURE_SUCCESS(rv, rv);\\n+          termFound = URIHasTag(itemURI, *terms[termIndex]);\\n+        }\\n+\\n+        if (!termFound) {\\n           allTermsFound = PR_FALSE;\\n           break;\\n         }\\ndiff --git a/toolkit/components/places/src/nsNavHistory.h b/toolkit/components/places/src/nsNavHistory.h\\nindex 8ee2446..d287b57 100644\\n--- a/toolkit/components/places/src/nsNavHistory.h\\n+++ b/toolkit/components/places/src/nsNavHistory.h\\n@@ -511,6 +511,8 @@ protected:\\n                        nsCOMArray<nsNavHistoryResultNode>* aDest,\\n                        PRBool aIsDomain);\\n \\n+  PRBool URIHasTag(nsIURI* aURI, const nsAString& aTag);\\n+\\n   nsresult FilterResultSet(nsNavHistoryQueryResultNode *aParentNode,\\n                            const nsCOMArray<nsNavHistoryResultNode>& aSet,\\n                            nsCOMArray<nsNavHistoryResultNode>* aFiltered,\\ndiff --git a/toolkit/components/places/tests/bookmarks/test_395101.js b/toolkit/components/places/tests/bookmarks/test_395101.js\\nindex 6f8f9e7..50d04f6 100644\\n--- a/toolkit/components/places/tests/bookmarks/test_395101.js\\n+++ b/toolkit/components/places/tests/bookmarks/test_395101.js\\n@@ -63,7 +63,6 @@ var root = bmsvc.bookmarksRoot;\\n \\n // main\\n function run_test() {\\n-  return true;\\n   // test searching for tagged bookmarks\\n \\n   // test folder\\n\""}