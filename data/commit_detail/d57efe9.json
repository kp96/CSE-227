{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basd57efe9\""},"diff":"\"d57efe9 394242 improve the comments on some necko APIs r+sr+a=bz\\ndiff --git a/netwerk/base/public/nsIChannel.idl b/netwerk/base/public/nsIChannel.idl\\nindex 3a4e593..c8001e5 100644\\n--- a/netwerk/base/public/nsIChannel.idl\\n+++ b/netwerk/base/public/nsIChannel.idl\\n@@ -95,7 +95,7 @@ interface nsIChannel : nsIRequest\\n      * callbacks do not supply the requested interface.\\n      * \\n      * Interfaces commonly requested include: nsIProgressEventSink, nsIPrompt,\\n-     * and nsIAuthPrompt.\\n+     * and nsIAuthPrompt/nsIAuthPrompt2.\\n      *\\n      * When the channel is done, it must not continue holding references to\\n      * this object.\\n@@ -192,6 +192,9 @@ interface nsIChannel : nsIRequest\\n      * keeping itself alive until it has called onStopRequest on aListener or\\n      * called onChannelRedirect.\\n      *\\n+     * Implementations are allowed to synchronously add themselves to the\\n+     * associated load group (if any).\\n+     *\\n      * NOTE: Implementations should throw NS_ERROR_ALREADY_OPENED if the\\n      * channel is reopened.\\n      *\\ndiff --git a/netwerk/base/public/nsIRequest.idl b/netwerk/base/public/nsIRequest.idl\\nindex 66ad9bb..12e00bd 100644\\n--- a/netwerk/base/public/nsIRequest.idl\\n+++ b/netwerk/base/public/nsIRequest.idl\\n@@ -83,6 +83,13 @@ interface nsIRequest : nsISupports\\n      * be passed.  The error passed in will become the value of the \\n      * status attribute.\\n      *\\n+     * Implementations must not send any notifications (e.g. via\\n+     * nsIRequestObserver) synchronously from this function. Similarly,\\n+     * removal from the load group (if any) must also happen asynchronously.\\n+     *\\n+     * Requests that use nsIStreamListener must not call onDataAvailable\\n+     * anymore after cancel has been called.\\n+     *\\n      * @param aStatus the reason for canceling this request.\\n      *\\n      * NOTE: most nsIRequest implementations expect aStatus to be a\\n@@ -96,7 +103,10 @@ interface nsIRequest : nsISupports\\n      * Suspends the current request.  This may have the effect of closing\\n      * any underlying transport (in order to free up resources), although\\n      * any open streams remain logically opened and will continue delivering\\n-     * data when the transport is resumed. \\n+     * data when the transport is resumed.\\n+     *\\n+     * Calling cancel() on a suspended request must not send any\\n+     * notifications (such as onstopRequest) until the request is resumed.\\n      *\\n      * NOTE: some implementations are unable to immediately suspend, and\\n      * may continue to deliver events already posted to an event queue. In\\n\""}