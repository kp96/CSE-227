{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas3317427\""},"diff":"\"3317427 Bug 394261 - Update Hunspell to version 1.1.12, patch by Ryan VanderMeulen, r+sr=mscott, a=dsicore\\ndiff --git a/extensions/spellcheck/hunspell/src/Makefile.in b/extensions/spellcheck/hunspell/src/Makefile.in\\nindex fe216b2..bf8d292 100644\\n--- a/extensions/spellcheck/hunspell/src/Makefile.in\\n+++ b/extensions/spellcheck/hunspell/src/Makefile.in\\n@@ -33,44 +33,45 @@\\n #\\n # ****** END LICENSE BLOCK ******\\n \\n-DEPTH\\t\\t= ../../../..\\n-topsrcdir\\t= @top_srcdir@\\n-srcdir\\t\\t= @srcdir@\\n-VPATH\\t\\t= @srcdir@\\n+DEPTH           = ../../../..\\n+topsrcdir       = @top_srcdir@\\n+srcdir          = @srcdir@\\n+VPATH           = @srcdir@\\n \\n include $(DEPTH)/config/autoconf.mk\\n \\n-MODULE\\t\\t = hunspell\\n-LIBRARY_NAME\\t = hunspell_s\\n+MODULE           = hunspell\\n+LIBRARY_NAME     = hunspell_s\\n FORCE_STATIC_LIB = 1\\n LIBXUL_LIBRARY   = 1\\n \\n-REQUIRES\\t= xpcom \\\\\\n-\\t\\t  string \\\\\\n-\\t\\t  uconv \\\\\\n-\\t\\t  unicharutil \\\\\\n-\\t\\t  spellchecker \\\\\\n-\\t\\t  xulapp \\\\\\n-\\t\\t  $(NULL)\\n+REQUIRES         = xpcom \\\\\\n+                   string \\\\\\n+                   uconv \\\\\\n+                   unicharutil \\\\\\n+                   spellchecker \\\\\\n+                   xulapp \\\\\\n+                   $(NULL)\\n \\n-CPPSRCS =         affentry.cpp \\\\\\n-\\t\\t  affixmgr.cpp \\\\\\n-\\t\\t  hashmgr.cpp \\\\\\n-\\t\\t  suggestmgr.cpp \\\\\\n-\\t\\t  csutil.cpp \\\\\\n-\\t\\t  hunspell.cpp \\\\\\n-\\t\\t  mozHunspell.cpp \\\\\\n-                  $(NULL)\\n+CPPSRCS          = affentry.cpp \\\\\\n+                   affixmgr.cpp \\\\\\n+                   csutil.cpp \\\\\\n+                   hashmgr.cpp \\\\\\n+                   hunspell.cpp \\\\\\n+                   mozHunspell.cpp \\\\\\n+                   phonet.cpp \\\\\\n+                   suggestmgr.cpp \\\\\\n+                   $(NULL)\\n \\n ifdef MOZ_XUL_APP\\n CPPSRCS += mozHunspellDirProvider.cpp\\n endif\\n \\n EXTRA_DSO_LDOPTS = \\\\\\n-\\t\\t$(LIBS_DIR) \\\\\\n-\\t\\t$(XPCOM_LIBS) \\\\\\n-\\t\\t$(NSPR_LIBS) \\\\\\n-\\t\\t$(MOZ_UNICHARUTIL_LIBS) \\\\\\n-\\t\\t$(NULL)\\n+                   $(LIBS_DIR) \\\\\\n+                   $(XPCOM_LIBS) \\\\\\n+                   $(NSPR_LIBS) \\\\\\n+                   $(MOZ_UNICHARUTIL_LIBS) \\\\\\n+                   $(NULL)\\n \\n include $(topsrcdir)/config/rules.mk\\ndiff --git a/extensions/spellcheck/hunspell/src/README.hunspell b/extensions/spellcheck/hunspell/src/README.hunspell\\nindex 08c3f6a..fbfe149 100644\\n--- a/extensions/spellcheck/hunspell/src/README.hunspell\\n+++ b/extensions/spellcheck/hunspell/src/README.hunspell\\n@@ -34,7 +34,7 @@\\n *\\n ******* END LICENSE BLOCK *******\\n \\n-Hunspell Version: 1.1.8\\n+Hunspell Version: 1.1.12\\n \\n Hunspell Author: L�szl� N�meth\\n MySpell Author: Kevin Hendricks & David Einstein\\n@@ -45,7 +45,7 @@ are available at http://hunspell.sourceforge.net.\\n \\n A special thanks and credit goes to Geoff Kuenning, the creator of Ispell.\\n MySpell's affix algorithms were based on those of Ispell, which should be\\n-noted is copyright Geoff Kuenning et.al. and now available under a BSD-style\\n+noted is copyright Geoff Kuenning et al and now available under a BSD-style\\n license. For more information on Ispell and affix compression in general,\\n please see: http://lasr.cs.ucla.edu/geoff/ispell.html (Ispell homepage)\\n \\ndiff --git a/extensions/spellcheck/hunspell/src/affentry.cpp b/extensions/spellcheck/hunspell/src/affentry.cpp\\nindex 6e3d64e..b43f013 100644\\n--- a/extensions/spellcheck/hunspell/src/affentry.cpp\\n+++ b/extensions/spellcheck/hunspell/src/affentry.cpp\\n@@ -112,7 +112,7 @@ PfxEntry::~PfxEntry()\\n     appnd = NULL;\\n     strip = NULL;\\n     if (opts & aeUTF8) {\\n-        for (int i = 0; i < 8; i++) {\\n+        for (int i = 0; i < numconds; i++) {\\n             if (conds.utf8.wchars[i]) free(conds.utf8.wchars[i]);\\n         }\\n     }\\n@@ -449,7 +449,7 @@ SfxEntry::~SfxEntry()\\n     appnd = NULL;\\n     strip = NULL;    \\n     if (opts & aeUTF8) {\\n-        for (int i = 0; i < 8; i++) {\\n+        for (int i = 0; i < numconds; i++) {\\n             if (conds.utf8.wchars[i]) free(conds.utf8.wchars[i]);  \\n         }\\n     }\\ndiff --git a/extensions/spellcheck/hunspell/src/affixmgr.cpp b/extensions/spellcheck/hunspell/src/affixmgr.cpp\\nindex e453883..550e74e 100644\\n--- a/extensions/spellcheck/hunspell/src/affixmgr.cpp\\n+++ b/extensions/spellcheck/hunspell/src/affixmgr.cpp\\n@@ -82,6 +82,7 @@ AffixMgr::AffixMgr(const char * affpath, HashMgr* ptr)\\n {\\n   // register hash manager and load affix data from aff file\\n   pHMgr = ptr;\\n+  keystring = NULL;\\n   trystring = NULL;\\n   encoding=NULL;\\n   utf8 = 0;\\n@@ -96,6 +97,7 @@ AffixMgr::AffixMgr(const char * affpath, HashMgr* ptr)\\n   numcheckcpd = 0;\\n   defcpdtable = NULL;\\n   numdefcpd = 0;\\n+  phone = NULL;\\n   compoundflag = FLAG_NULL; // permits word in compound forms\\n   compoundbegin = FLAG_NULL; // may be first word in compound forms\\n   compoundmiddle = FLAG_NULL; // may be middle word in compound forms\\n@@ -196,6 +198,8 @@ AffixMgr::~AffixMgr()\\n        sStart[j] = NULL;\\n   }\\n \\n+  if (keystring) free(keystring);\\n+  keystring=NULL;\\n   if (trystring) free(trystring);\\n   trystring=NULL;\\n   if (encoding) free(encoding);\\n@@ -220,16 +224,24 @@ AffixMgr::~AffixMgr()\\n      breaktable = NULL;\\n   }\\n   numbreak = 0;\\n-  if (reptable) {  \\n+  if (reptable) {\\n      for (int j=0; j < numrep; j++) {\\n         free(reptable[j].pattern);\\n         free(reptable[j].pattern2);\\n-        reptable[j].pattern = NULL;\\n-        reptable[j].pattern2 = NULL;\\n      }\\n      free(reptable);  \\n      reptable = NULL;\\n   }\\n+  if (phone && phone->rules) {\\n+     for (int j=0; j < phone->num + 1; j++) {\\n+        free(phone->rules[j * 2]);\\n+        free(phone->rules[j * 2 + 1]);\\n+     }\\n+     free(phone->rules);\\n+     free(phone);  \\n+     phone = NULL;\\n+  }\\n+\\n   if (defcpdtable) {  \\n      for (int j=0; j < numdefcpd; j++) {\\n         free(defcpdtable[j].def);\\n@@ -326,6 +338,14 @@ int  AffixMgr::parse_file(const char * affpath)\\n          }\\n        }\\n \\n+       /* parse in the keyboard string */\\n+       if (strncmp(line,\\\"KEY\\\",3) == 0) {\\n+          if (parse_string(line, &keystring, \\\"KEY\\\")) {\\n+             fclose(afflst);\\n+             return 1;\\n+          }\\n+       }\\n+\\n        /* parse in the try string */\\n        if (strncmp(line,\\\"TRY\\\",3) == 0) {\\n           if (parse_string(line, &trystring, \\\"TRY\\\")) {\\n@@ -556,6 +576,14 @@ int  AffixMgr::parse_file(const char * affpath)\\n           }\\n        }\\n \\n+       /* parse in the phonetic translation table */\\n+       if (strncmp(line,\\\"PHONE\\\",5) == 0) {\\n+          if (parse_phonetable(line, afflst)) {\\n+             fclose(afflst);\\n+             return 1;\\n+          }\\n+       }\\n+\\n        /* parse in the checkcompoundpattern table */\\n        if (strncmp(line,\\\"CHECKCOMPOUNDPATTERN\\\",20) == 0) {\\n           if (parse_checkcpdtable(line, afflst)) {\\n@@ -970,7 +998,7 @@ int AffixMgr::process_sfx_order()\\n \\n // takes aff file condition string and creates the\\n // conds array - please see the appendix at the end of the\\n-// file affentry.cxx which describes what is going on here\\n+// file affentry.cpp which describes what is going on here\\n // in much more detail\\n \\n int AffixMgr::encodeit(struct affentry * ptr, char * cs)\\n@@ -1527,7 +1555,7 @@ short AffixMgr::get_syllable(const char * word, int wlen)\\n     } else if (cpdvowels_utf16) {\\n         w_char w[MAXWORDUTF8LEN];\\n         int i = u8_u16(w, MAXWORDUTF8LEN, word);\\n-        for (; i; i--) {\\n+        for (; i > 0; i--) {\\n             if (flag_bsearch((unsigned short *) cpdvowels_utf16,\\n                 ((unsigned short *) w)[i - 1], cpdvowels_utf16_len)) num++;\\n         }\\n@@ -1793,7 +1821,7 @@ struct hentry * AffixMgr::compound_check(const char * word, int len,\\n                 && (\\n                       ((cpdwordmax==-1) || (wordnum+1<cpdwordmax)) || \\n                       ((cpdmaxsyllable==0) || \\n-                          (numsyllable + get_syllable(rv->word,rv->wlen)<=cpdmaxsyllable))\\n+                          (numsyllable + get_syllable(&(rv->word), rv->clen)<=cpdmaxsyllable))\\n                     )\\n                 && (\\n                      (!checkcompounddup || (rv != rv_first))\\n@@ -1821,6 +1849,7 @@ struct hentry * AffixMgr::compound_check(const char * word, int len,\\n             if (!rv && numdefcpd && words) {\\n                 rv = affix_check((word+i),strlen(word+i), 0, IN_CPD_END);\\n                 if (rv && defcpd_check(&words, wnum + 1, rv, NULL, 1)) return rv;\\n+                rv = NULL;\\n             }\\n \\n             // check non_compound flag in suffix and prefix\\n@@ -2173,7 +2202,7 @@ int AffixMgr::compound_check_morph(const char * word, int len,\\n                   if (complexprefixes && rv->description) strcat(*result, rv->description);\\n                   if (rv->description && ((!rv->astr) || \\n                      !TESTAFF(rv->astr, lemma_present, rv->alen)))\\n-                        strcat(*result, rv->word);\\n+                        strcat(*result, &(rv->word));\\n                   if (!complexprefixes && rv->description) strcat(*result, rv->description);\\n                   strcat(*result, \\\"\\\\n\\\");\\n                   ok = 1;\\n@@ -2211,7 +2240,7 @@ int AffixMgr::compound_check_morph(const char * word, int len,\\n                 && (\\n                       ((cpdwordmax==-1) || (wordnum+1<cpdwordmax)) || \\n                       ((cpdmaxsyllable==0) || \\n-                          (numsyllable+get_syllable(rv->word,rv->wlen)<=cpdmaxsyllable))\\n+                          (numsyllable+get_syllable(&(rv->word),rv->wlen)<=cpdmaxsyllable))\\n                     )\\n                 && (\\n                      (!checkcompounddup || (rv != rv_first))\\n@@ -2224,7 +2253,7 @@ int AffixMgr::compound_check_morph(const char * word, int len,\\n                       if (rv->description) {\\n                         if (complexprefixes) strcat(*result, rv->description);\\n                         if ((!rv->astr) || !TESTAFF(rv->astr, lemma_present, rv->alen))\\n-                                               strcat(*result, rv->word);\\n+                                               strcat(*result, &(rv->word));\\n                         if (!complexprefixes) strcat(*result, rv->description);\\n                       }\\n                       strcat(*result, \\\"\\\\n\\\");\\n@@ -2667,7 +2696,7 @@ char * AffixMgr::suffix_check_morph(const char * word, int len,\\n             if (complexprefixes && rv->description) strcat(result, rv->description);\\n             if (rv->description && ((!rv->astr) || \\n                                         !TESTAFF(rv->astr, lemma_present, rv->alen)))\\n-                                               strcat(result, rv->word);\\n+                                               strcat(result, &(rv->word));\\n             if (!complexprefixes && rv->description) strcat(result, rv->description);\\n             if (se->getMorph()) strcat(result, se->getMorph());\\n             strcat(result, \\\"\\\\n\\\");\\n@@ -2710,7 +2739,7 @@ char * AffixMgr::suffix_check_morph(const char * word, int len,\\n                     }    \\n                     if (complexprefixes && rv->description) strcat(result, rv->description);\\n                     if (rv->description && ((!rv->astr) || \\n-                        !TESTAFF(rv->astr, lemma_present, rv->alen))) strcat(result, rv->word);\\n+                        !TESTAFF(rv->astr, lemma_present, rv->alen))) strcat(result, &(rv->word));\\n                     if (!complexprefixes && rv->description) strcat(result, rv->description);\\n #ifdef DEBUG\\n                 unsigned short flag = sptr->getFlag();\\n@@ -2812,26 +2841,34 @@ char * AffixMgr::affix_check_morph(const char * word, int len, const FLAG needfl\\n \\n \\n int AffixMgr::expand_rootword(struct guessword * wlst, int maxn, const char * ts,\\n-    int wl, const unsigned short * ap, unsigned short al, char * bad, int badl)\\n+    int wl, const unsigned short * ap, unsigned short al, char * bad, int badl,\\n+    char * phone)\\n {\\n \\n     int nh=0;\\n-\\n     // first add root word to list\\n     if ((nh < maxn) && !(al && ((pseudoroot && TESTAFF(ap, pseudoroot, al)) ||\\n          (onlyincompound && TESTAFF(ap, onlyincompound, al))))) {\\n        wlst[nh].word = mystrdup(ts);\\n        wlst[nh].allow = (1 == 0);\\n+       wlst[nh].orig = NULL;\\n        nh++;\\n+       // add special phonetic version\\n+       if (phone && (nh < maxn)) {\\n+    \\t    wlst[nh].word = mystrdup(phone);\\n+    \\t    wlst[nh].allow = (1 == 0);\\n+    \\t    wlst[nh].orig = mystrdup(ts);\\n+    \\t    nh++;\\n+       }\\n     }\\n \\n     // handle suffixes\\n     for (int i = 0; i < al; i++) {\\n-       unsigned short c = (unsigned short) ap[i];\\n+       const unsigned char c = (unsigned char) (ap[i] & 0x00FF);\\n        SfxEntry * sptr = (SfxEntry *)sFlag[c];\\n        while (sptr) {\\n-         if (!sptr->getKeyLen() || ((badl > sptr->getKeyLen()) &&\\n-                (strcmp(sptr->getAffix(), bad + badl - sptr->getKeyLen()) == 0)) &&\\n+         if ((sptr->getFlag() == ap[i]) && (!sptr->getKeyLen() || ((badl > sptr->getKeyLen()) &&\\n+                (strcmp(sptr->getAffix(), bad + badl - sptr->getKeyLen()) == 0))) &&\\n                 // check pseudoroot flag\\n                 !(sptr->getCont() && ((pseudoroot && \\n                       TESTAFF(sptr->getCont(), pseudoroot, sptr->getContLen())) ||\\n@@ -2844,8 +2881,20 @@ int AffixMgr::expand_rootword(struct guessword * wlst, int maxn, const char * ts\\n             if (newword) {\\n                 if (nh < maxn) {\\n                     wlst[nh].word = newword;\\n-                    wlst[nh].allow = sptr->allowCross();              \\n-                nh++;\\n+                    wlst[nh].allow = sptr->allowCross();\\n+                    wlst[nh].orig = NULL;\\n+                    nh++;\\n+                    // add special phonetic version\\n+    \\t\\t    if (phone && (nh < maxn)) {\\n+    \\t\\t\\tchar st[MAXWORDUTF8LEN];\\n+    \\t\\t\\tstrcpy(st, phone);\\n+    \\t\\t\\tstrcat(st, sptr->getKey());\\n+    \\t\\t\\treverseword(st + strlen(phone));\\n+    \\t\\t\\twlst[nh].word = mystrdup(st);\\n+    \\t\\t\\twlst[nh].allow = (1 == 0);\\n+    \\t\\t\\twlst[nh].orig = mystrdup(newword);\\n+    \\t\\t\\tnh++;\\n+    \\t\\t    }\\n                 } else {\\n                     free(newword);\\n                 }\\n@@ -2861,10 +2910,10 @@ int AffixMgr::expand_rootword(struct guessword * wlst, int maxn, const char * ts\\n     for (int j=1;j<n ;j++)\\n        if (wlst[j].allow) {\\n           for (int k = 0; k < al; k++) {\\n-             unsigned short c = (unsigned short) ap[k];\\n+    \\t     const unsigned char c = (unsigned char) (ap[k] & 0x00FF);\\n              PfxEntry * cptr = (PfxEntry *) pFlag[c];\\n              while (cptr) {\\n-                if (cptr->allowCross() && (!cptr->getKeyLen() || ((badl > cptr->getKeyLen()) &&\\n+                if ((cptr->getFlag() == ap[k]) && cptr->allowCross() && (!cptr->getKeyLen() || ((badl > cptr->getKeyLen()) &&\\n                         (strncmp(cptr->getKey(), bad, cptr->getKeyLen()) == 0)))) {\\n                     int l1 = strlen(wlst[j].word);\\n                     char * newword = cptr->add(wlst[j].word, l1);\\n@@ -2872,6 +2921,7 @@ int AffixMgr::expand_rootword(struct guessword * wlst, int maxn, const char * ts\\n                        if (nh < maxn) {\\n                           wlst[nh].word = newword;\\n                           wlst[nh].allow = cptr->allowCross();\\n+                \\t  wlst[nh].orig = NULL;\\n                           nh++;\\n                        } else {\\n                           free(newword);\\n@@ -2886,11 +2936,11 @@ int AffixMgr::expand_rootword(struct guessword * wlst, int maxn, const char * ts\\n \\n     // now handle pure prefixes\\n     for (int m = 0; m < al; m ++) {\\n-       unsigned short c = (unsigned short) ap[m];\\n+       const unsigned char c = (unsigned char) (ap[m] & 0x00FF);\\n        PfxEntry * ptr = (PfxEntry *) pFlag[c];\\n        while (ptr) {\\n-         if (!ptr->getKeyLen() || ((badl > ptr->getKeyLen()) &&\\n-                (strncmp(ptr->getKey(), bad, ptr->getKeyLen()) == 0)) &&\\n+         if ((ptr->getFlag() == ap[m]) && (!ptr->getKeyLen() || ((badl > ptr->getKeyLen()) &&\\n+                (strncmp(ptr->getKey(), bad, ptr->getKeyLen()) == 0))) &&\\n                 // check pseudoroot flag\\n                 !(ptr->getCont() && ((pseudoroot && \\n                       TESTAFF(ptr->getCont(), pseudoroot, ptr->getContLen())) ||\\n@@ -2904,6 +2954,7 @@ int AffixMgr::expand_rootword(struct guessword * wlst, int maxn, const char * ts\\n                 if (nh < maxn) {\\n                     wlst[nh].word = newword;\\n                     wlst[nh].allow = ptr->allowCross();\\n+                    wlst[nh].orig = NULL;\\n                     nh++;\\n                 } else {\\n                     free(newword);\\n@@ -2932,6 +2983,13 @@ struct replentry * AffixMgr::get_reptable()\\n   return reptable;\\n }\\n \\n+// return replacing table\\n+struct phonetable * AffixMgr::get_phonetable()\\n+{\\n+  if (! phone ) return NULL;\\n+  return phone;\\n+}\\n+\\n // return length of character map table\\n int AffixMgr::get_nummap()\\n {\\n@@ -3003,6 +3061,13 @@ unsigned short * AffixMgr::get_ignore_utf16(int * len)\\n   return ignorechars_utf16;\\n }\\n \\n+// return the keyboard string for suggestions\\n+char * AffixMgr::get_key_string()\\n+{\\n+  if (! keystring ) return NULL;\\n+  return mystrdup(keystring);\\n+}\\n+\\n // return the preferred try string for suggestions\\n char * AffixMgr::get_try_string()\\n {\\n@@ -3295,6 +3360,93 @@ int  AffixMgr::parse_reptable(char * line, FILE * af)\\n    return 0;\\n }\\n \\n+/* parse in the typical fault correcting table */\\n+int  AffixMgr::parse_phonetable(char * line, FILE * af)\\n+{\\n+   if (phone) {\\n+      HUNSPELL_WARNING(stderr, \\\"error: duplicate PHONE tables used\\\\n\\\");\\n+      return 1;\\n+   }\\n+   char * tp = line;\\n+   char * piece;\\n+   int i = 0;\\n+   int np = 0;\\n+   piece = mystrsep(&tp, 0);\\n+   while (piece) {\\n+       if (*piece != '\\\\0') {\\n+          switch(i) {\\n+             case 0: { np++; break; }\\n+             case 1: { \\n+            \\t       phone = (phonetable *) malloc(sizeof(struct phonetable));\\n+            \\t       phone->num = atoi(piece);\\n+            \\t       phone->rules = NULL;\\n+            \\t       phone->utf8 = utf8;\\n+                       if (!phone) return 1;\\n+                       if (phone->num < 1) {\\n+                          HUNSPELL_WARNING(stderr, \\\"incorrect number of entries in phonelacement table\\\\n\\\");\\n+                          free(piece);\\n+                          return 1;\\n+                       }\\n+                       phone->rules = (char * *) malloc(2 * (phone->num + 1) * sizeof(char *));\\n+                       if (!phone->rules) return 1;\\n+                       np++;\\n+                       break;\\n+                     }\\n+             default: break;\\n+          }\\n+          i++;\\n+       }\\n+       free(piece);\\n+       piece = mystrsep(&tp, 0);\\n+   }\\n+   if (np != 2) {\\n+      HUNSPELL_WARNING(stderr, \\\"error: missing PHONE table information\\\\n\\\");\\n+      return 1;\\n+   } \\n+ \\n+   /* now parse the phone->num lines to read in the remainder of the table */\\n+   char * nl = line;\\n+   for (int j=0; j < phone->num; j++) {\\n+        if (!fgets(nl,MAXLNLEN,af)) return 1;\\n+        mychomp(nl);\\n+        tp = nl;\\n+        i = 0;\\n+        phone->rules[j * 2] = NULL;\\n+        phone->rules[j * 2 + 1] = NULL;\\n+        piece = mystrsep(&tp, 0);\\n+        while (piece) {\\n+           if (*piece != '\\\\0') {\\n+               switch(i) {\\n+                  case 0: {\\n+                             if (strncmp(piece,\\\"PHONE\\\",5) != 0) {\\n+                                 HUNSPELL_WARNING(stderr, \\\"error: PHONE table is corrupt\\\\n\\\");\\n+                                 phone->num = 0;\\n+                                 free(piece);\\n+                                 return 1;\\n+                             }\\n+                             break;\\n+                          }\\n+                  case 1: { phone->rules[j * 2] = mystrrep(mystrdup(piece),\\\"_\\\",\\\"\\\"); break; }\\n+                  case 2: { phone->rules[j * 2 + 1] = mystrrep(mystrdup(piece),\\\"_\\\",\\\"\\\"); break; }\\n+                  default: break;\\n+               }\\n+               i++;\\n+           }\\n+           free(piece);\\n+           piece = mystrsep(&tp, 0);\\n+        }\\n+        if ((!(phone->rules[j * 2])) || (!(phone->rules[j * 2 + 1]))) {\\n+             HUNSPELL_WARNING(stderr, \\\"error: PHONE table is corrupt\\\\n\\\");\\n+             phone->num = 0;\\n+             return 1;\\n+        }\\n+   }\\n+   phone->rules[phone->num * 2] = mystrdup(\\\"\\\");\\n+   phone->rules[phone->num * 2 + 1] = mystrdup(\\\"\\\");\\n+   init_phonet_hash(*phone);\\n+   return 0;\\n+}\\n+\\n /* parse in the checkcompoundpattern table */\\n int  AffixMgr::parse_checkcpdtable(char * line, FILE * af)\\n {\\n@@ -3936,7 +4088,7 @@ int  AffixMgr::parse_affix(char * line, const char at, FILE * af, char * dupflag\\n    return 0;\\n }\\n \\n-int AffixMgr::redundant_condition(char ft, char * strip, int stripl, const char * cond, char * WARNVAR) {\\n+int AffixMgr::redundant_condition(char ft, char * strip, int stripl, const char * cond, char * warnvar) {\\n   int condl = strlen(cond);\\n   int i;\\n   int j;\\ndiff --git a/extensions/spellcheck/hunspell/src/affixmgr.hxx b/extensions/spellcheck/hunspell/src/affixmgr.hxx\\nindex 2d8cb39..6d77589 100644\\n--- a/extensions/spellcheck/hunspell/src/affixmgr.hxx\\n+++ b/extensions/spellcheck/hunspell/src/affixmgr.hxx\\n@@ -69,6 +69,7 @@ using namespace std;\\n #include \\\"atypes.hxx\\\"\\n #include \\\"baseaffix.hxx\\\"\\n #include \\\"hashmgr.hxx\\\"\\n+#include \\\"phonet.hxx\\\"\\n \\n // check flag duplication\\n #define dupSFX        (1 << 0)\\n@@ -82,12 +83,13 @@ class AffixMgr\\n   AffEntry *          pFlag[CONTSIZE];\\n   AffEntry *          sFlag[CONTSIZE];\\n   HashMgr *           pHMgr;\\n+  char *              keystring;\\n   char *              trystring;\\n   char *              encoding;\\n   struct cs_info *    csconv;\\n   int                 utf8;\\n   int                 complexprefixes;\\n-  FLAG                compoundflag;  \\n+  FLAG                compoundflag;\\n   FLAG                compoundbegin;\\n   FLAG                compoundmiddle;\\n   FLAG                compoundend;\\n@@ -112,6 +114,7 @@ class AffixMgr\\n   replentry *         checkcpdtable;\\n   int                 numdefcpd;\\n   flagentry *         defcpdtable;\\n+  phonetable *        phone;\\n   int                 maxngramsugs;\\n   int                 nosplitsugs;\\n   int                 sugswithdots;\\n@@ -178,7 +181,8 @@ public:\\n             int sfxopts, AffEntry * ppfx, const FLAG needflag = FLAG_NULL);\\n \\n   int                 expand_rootword(struct guessword * wlst, int maxn, const char * ts,\\n-                        int wl, const unsigned short * ap, unsigned short al, char * bad, int);\\n+                        int wl, const unsigned short * ap, unsigned short al, char * bad, int,\\n+                        char *);\\n \\n   short               get_syllable (const char * word, int wlen);\\n   int                 cpdrep_check(const char * word, int len);\\n@@ -197,12 +201,14 @@ public:\\n   struct hentry *     lookup(const char * word);\\n   int                 get_numrep();\\n   struct replentry *  get_reptable();\\n+  struct phonetable * get_phonetable();\\n   int                 get_nummap();\\n   struct mapentry *   get_maptable();\\n   int                 get_numbreak();\\n   char **             get_breaktable();\\n   char *              get_encoding();\\n   int                 get_langnum();\\n+  char *              get_key_string();\\n   char *              get_try_string();\\n   const char *        get_wordchars();\\n   unsigned short *    get_wordchars_utf16(int * len);\\n@@ -243,6 +249,7 @@ private:\\n //            int * out_utf16_len, const char * name);\\n   int  parse_cpdsyllable(char * line);\\n   int  parse_reptable(char * line, FILE * af);\\n+  int  parse_phonetable(char * line, FILE * af);\\n   int  parse_maptable(char * line, FILE * af);\\n   int  parse_breaktable(char * line, FILE * af);\\n   int  parse_checkcpdtable(char * line, FILE * af);\\ndiff --git a/extensions/spellcheck/hunspell/src/atypes.hxx b/extensions/spellcheck/hunspell/src/atypes.hxx\\nindex 3bcd3a7..fca7dce 100644\\n--- a/extensions/spellcheck/hunspell/src/atypes.hxx\\n+++ b/extensions/spellcheck/hunspell/src/atypes.hxx\\n@@ -61,9 +61,9 @@\\n #ifdef HUNSPELL_WARNING_ON\\n #define HUNSPELL_WARNING fprintf\\n #else\\n+// empty inline function to switch off warnings (instead of the C99 standard variadic macros)\\n static inline void HUNSPELL_WARNING(FILE *, const char *, ...) {}\\n #endif\\n-#define WARNVAR warnvar\\n #endif\\n \\n // HUNSTEM def.\\n@@ -75,7 +75,7 @@ static inline void HUNSPELL_WARNING(FILE *, const char *, ...) {}\\n #define SETSIZE         256\\n #define CONTSIZE        65536\\n #define MAXWORDLEN      100\\n-#define MAXWORDUTF8LEN  (MAXWORDLEN * 4)\\n+#define MAXWORDUTF8LEN  256\\n \\n // affentry options\\n #define aeXPRODUCT      (1 << 0)\\n@@ -90,7 +90,7 @@ static inline void HUNSPELL_WARNING(FILE *, const char *, ...) {}\\n #define IN_CPD_END   2\\n #define IN_CPD_OTHER 3\\n \\n-#define MAXLNLEN        8192 * 4\\n+#define MAXLNLEN        8192\\n \\n #define MINCPDLEN       3\\n #define MAXCOMPOUND     10\\n@@ -129,11 +129,6 @@ struct affentry\\n    short        contclasslen;\\n };\\n \\n-struct replentry {\\n-  char * pattern;\\n-  char * pattern2;\\n-};\\n-\\n struct mapentry {\\n   char * set;\\n   w_char * set_utf16;\\n@@ -148,6 +143,7 @@ struct flagentry {\\n struct guessword {\\n   char * word;\\n   bool allow;\\n+  char * orig;\\n };\\n \\n #endif\\ndiff --git a/extensions/spellcheck/hunspell/src/csutil.cpp b/extensions/spellcheck/hunspell/src/csutil.cpp\\nindex 3f39f14..14612c6 100644\\n--- a/extensions/spellcheck/hunspell/src/csutil.cpp\\n+++ b/extensions/spellcheck/hunspell/src/csutil.cpp\\n@@ -58,10 +58,12 @@\\n #include <cstdlib>\\n #include <cstring>\\n #include <cstdio>\\n+#include <cctype>\\n #else\\n #include <stdlib.h> \\n #include <string.h>\\n #include <stdio.h> \\n+#include <ctype.h>\\n #endif\\n \\n #include \\\"csutil.hxx\\\"\\n@@ -5217,9 +5219,9 @@ unsigned short unicodetoupper(unsigned short c, int langnum)\\n   return u_toupper(c);\\n #else\\n #ifdef MOZILLA_CLIENT\\n-  unsigned short ret(c);\\n-  getcaseConv()->ToUpper(c, &ret);\\n-  return ret;\\n+  PRUnichar ch2;\\n+  getcaseConv()->ToUpper((PRUnichar) c, &ch2);\\n+  return ch2;\\n #else\\n   return (utf_tbl) ? utf_tbl[c].cupper : c;\\n #endif\\n@@ -5237,9 +5239,9 @@ unsigned short unicodetolower(unsigned short c, int langnum)\\n   return u_tolower(c);\\n #else\\n #ifdef MOZILLA_CLIENT\\n-  unsigned short ret(c);\\n-  getcaseConv()->ToLower(c, &ret);\\n-  return ret;\\n+  PRUnichar ch2;\\n+  getcaseConv()->ToLower((PRUnichar) c, &ch2);\\n+  return ch2;\\n #else\\n   return (utf_tbl) ? utf_tbl[c].clower : c;\\n #endif\\n@@ -5283,27 +5285,25 @@ int get_captype(char * word, int nl, cs_info * csconv) {\\n    return HUHCAP;\\n }\\n \\n-int get_captype_utf8(char * q, int nl, int langnum) {\\n+int get_captype_utf8(w_char * word, int nl, int langnum) {\\n    // now determine the capitalization type of the first nl letters\\n    int ncap = 0;\\n    int nneutral = 0;\\n    int firstcap = 0;\\n-   w_char dest_utf[MAXWORDLEN];\\n-      unsigned short idx;\\n-      nl = u8_u16(dest_utf, MAXWORDLEN, (const char *) q);\\n-      // don't check too long words\\n-      if (nl >= MAXWORDLEN) return 0;\\n-      // big Unicode character (non BMP area)\\n-      if (nl == -1) return NOCAP;\\n-      for (int i = 0; i < nl; i++) {\\n-         idx = (dest_utf[i].h << 8) + dest_utf[i].l;\\n-         if (idx != unicodetolower(idx, langnum)) ncap++;\\n-         if (unicodetoupper(idx, langnum) == unicodetolower(idx, langnum)) nneutral++;\\n-      }\\n-      if (ncap) {\\n-         idx = (dest_utf[0].h << 8) + dest_utf[0].l;\\n-         firstcap = (idx != unicodetolower(idx, langnum));\\n-      }\\n+   unsigned short idx;\\n+   // don't check too long words\\n+   if (nl >= MAXWORDLEN) return 0;\\n+   // big Unicode character (non BMP area)\\n+   if (nl == -1) return NOCAP;\\n+   for (int i = 0; i < nl; i++) {\\n+     idx = (word[i].h << 8) + word[i].l;\\n+     if (idx != unicodetolower(idx, langnum)) ncap++;\\n+     if (unicodetoupper(idx, langnum) == unicodetolower(idx, langnum)) nneutral++;\\n+   }\\n+   if (ncap) {\\n+      idx = (word[0].h << 8) + word[0].l;\\n+      firstcap = (idx != unicodetolower(idx, langnum));\\n+  }\\n \\n    // now finally set the captype\\n    if (ncap == 0) {\\n@@ -5348,7 +5348,7 @@ void remove_ignored_chars(char * word, char * ignored_chars)\\n    *word = '\\\\0';\\n }\\n \\n-int parse_string(char * line, char ** out, const char * WARNVAR)\\n+int parse_string(char * line, char ** out, const char * warnvar)\\n {\\n    char * tp = line;\\n    char * piece;\\ndiff --git a/extensions/spellcheck/hunspell/src/csutil.hxx b/extensions/spellcheck/hunspell/src/csutil.hxx\\nindex d1e308b..005c53a 100644\\n--- a/extensions/spellcheck/hunspell/src/csutil.hxx\\n+++ b/extensions/spellcheck/hunspell/src/csutil.hxx\\n@@ -65,6 +65,16 @@\\n #define HUHCAP  3\\n #define HUHINITCAP  4\\n \\n+#define FIELD_STEM  \\\"st:\\\"\\n+#define FIELD_POS   \\\"po:\\\"\\n+#define FIELD_SUFF  \\\"su:\\\"\\n+#define FIELD_PREF  \\\"pr:\\\"\\n+#define FIELD_FREQ  \\\"fr:\\\"\\n+#define FIELD_PHON  \\\"ph:\\\"\\n+#define FIELD_HYPH  \\\"hy:\\\"\\n+#define FIELD_COMP  \\\"co:\\\"\\n+\\n+// default flags\\n #define ONLYUPCASEFLAG 65535\\n \\n typedef struct {\\n@@ -72,6 +82,8 @@ typedef struct {\\n     unsigned char h;\\n } w_char;\\n \\n+#define w_char_eq(a,b) (((a).l == (b).l) && ((a).h == (b).h))\\n+\\n // convert UTF-16 characters to UTF-8\\n char * u16_u8(char * dest, int size, const w_char * src, int srclen);\\n \\n@@ -129,6 +141,12 @@ struct cs_info {\\n   unsigned char cupper;\\n };\\n \\n+// two character arrays\\n+struct replentry {\\n+  char * pattern;\\n+  char * pattern2;\\n+};\\n+\\n // Unicode character encoding information\\n struct unicode_info {\\n   unsigned short c;\\n@@ -199,7 +217,7 @@ void mkallcap_utf(w_char * u, int nc, int langnum);\\n int get_captype(char * q, int nl, cs_info *);\\n \\n // get type of capitalization (UTF-8)\\n-int get_captype_utf8(char * q, int nl, int langnum);\\n+int get_captype_utf8(w_char * q, int nl, int langnum);\\n \\n // strip all ignored characters in the string\\n void remove_ignored_chars_utf(char * word, unsigned short ignored_chars[], int ignored_len);\\ndiff --git a/extensions/spellcheck/hunspell/src/hashmgr.cpp b/extensions/spellcheck/hunspell/src/hashmgr.cpp\\nindex 4a6c11c..23929c1 100644\\n--- a/extensions/spellcheck/hunspell/src/hashmgr.cpp\\n+++ b/extensions/spellcheck/hunspell/src/hashmgr.cpp\\n@@ -108,6 +108,7 @@ HashMgr::HashMgr(const char * tpath, const char * apath)\\n     HUNSPELL_WARNING(stderr, \\\"Hash Manager Error : %d\\\\n\\\",ec);\\n     if (tableptr) {\\n       free(tableptr);\\n+      tableptr = NULL;\\n     }\\n     tablesize = 0;\\n   }\\n@@ -120,20 +121,19 @@ HashMgr::~HashMgr()\\n     // now pass through hash table freeing up everything\\n     // go through column by column of the table\\n     for (int i=0; i < tablesize; i++) {\\n-      struct hentry * pt = &tableptr[i];\\n+      struct hentry * pt = tableptr[i];\\n       struct hentry * nt = NULL;\\n-      if (pt) {\\n-        if (pt->astr && !aliasf) free(pt->astr);\\n-        if (pt->word) free(pt->word);\\n+/*      if (pt) {\\n+        if (pt->astr && (!aliasf || TESTAFF(pt->astr, ONLYUPCASEFLAG, pt->alen))) free(pt->astr);\\n #ifdef HUNSPELL_EXPERIMENTAL\\n         if (pt->description && !aliasm) free(pt->description);\\n #endif\\n         pt = pt->next;\\n       }\\n+*/\\n       while(pt) {\\n         nt = pt->next;\\n-        if (pt->astr && !aliasf) free(pt->astr);\\n-        if (pt->word) free(pt->word);\\n+        if (pt->astr && (!aliasf || TESTAFF(pt->astr, ONLYUPCASEFLAG, pt->alen))) free(pt->astr);\\n #ifdef HUNSPELL_EXPERIMENTAL\\n         if (pt->description && !aliasm) free(pt->description);\\n #endif\\n@@ -179,67 +179,50 @@ struct hentry * HashMgr::lookup(const char *word) const\\n {\\n     struct hentry * dp;\\n     if (tableptr) {\\n-       dp = &tableptr[hash(word)];\\n-       if (dp->word == NULL) return NULL;\\n+       dp = tableptr[hash(word)];\\n+       if (!dp) return NULL;\\n        for (  ;  dp != NULL;  dp = dp->next) {\\n-          if (strcmp(word,dp->word) == 0) return dp;\\n+          if (strcmp(word,&(dp->word)) == 0) return dp;\\n        }\\n     }\\n     return NULL;\\n }\\n \\n // add a word to the hash table (private)\\n-\\n-int HashMgr::add_word(const char * word, int wl, unsigned short * aff,\\n-    int al, const char *\\n-#ifdef HUNSPELL_EXPERIMENTAL\\n-desc\\n-#endif\\n-, bool onlyupcase)\\n+int HashMgr::add_word(const char * word, int wbl, int wcl, unsigned short * aff,\\n+    int al, const char * desc, bool onlyupcase)\\n {\\n-    char * st = mystrdup(word);\\n     bool upcasehomonym = false;\\n-    if (wl && !st) return 1;\\n+    int descl = (desc) ? strlen(desc) : 0;\\n+    // variable-length hash record with word and optional fields\\n+    // instead of mmap implementation temporarily\\n+    struct hentry* hp = \\n+\\t(struct hentry *) malloc (sizeof(struct hentry) + wbl + descl + 1);\\n+    if (!hp) return 1;\\n+    char * hpw = &(hp->word);\\n+    strcpy(hpw, word);\\n+    if (desc && strncmp(desc, FIELD_PHON, strlen(FIELD_PHON)) == 0) {\\n+\\tstrcpy(hpw + wbl + 1, desc + strlen(FIELD_PHON));\\n+\\thp->var = 1;\\n+    } else {\\n+\\thp->var = 0;\\n+    }\\n     if (ignorechars != NULL) {\\n       if (utf8) {\\n-        remove_ignored_chars_utf(st, ignorechars_utf16, ignorechars_utf16_len);\\n+        remove_ignored_chars_utf(hpw, ignorechars_utf16, ignorechars_utf16_len);\\n       } else {\\n-        remove_ignored_chars(st, ignorechars);\\n+        remove_ignored_chars(hpw, ignorechars);\\n       }\\n     }\\n     if (complexprefixes) {\\n-        if (utf8) reverseword_utf(st); else reverseword(st);\\n+        if (utf8) reverseword_utf(hpw); else reverseword(hpw);\\n     }\\n-    int i = hash(st);\\n-    struct hentry * dp = &tableptr[i];\\n-    if (dp->word == NULL) {\\n-       dp->wlen = (short) wl;\\n-       dp->alen = (short) al;\\n-       dp->word = st;\\n-       dp->astr = aff;\\n-       dp->next = NULL;\\n-       dp->next_homonym = NULL;\\n-#ifdef HUNSPELL_EXPERIMENTAL\\n-       if (aliasm) {\\n-            dp->description = (desc) ? get_aliasm(atoi(desc)) : mystrdup(desc);\\n-       } else {\\n-            dp->description = mystrdup(desc);\\n-            if (desc && !dp->description) return 1;\\n-            if (dp->description && complexprefixes) {\\n-                if (utf8) reverseword_utf(dp->description); else reverseword(dp->description);\\n-            }\\n-       }\\n-#endif\\n-    } else {\\n-       struct hentry* hp = (struct hentry *) malloc (sizeof(struct hentry));\\n-       if (!hp)\\n-       {\\n-           if (st) free(st);\\n-           return 1;\\n-       }\\n-       hp->wlen = (short) wl;\\n+\\n+    int i = hash(hpw);\\n+\\n+       hp->blen = (unsigned char) wbl;\\n+       hp->clen = (unsigned char) wcl;\\n        hp->alen = (short) al;\\n-       hp->word = st;\\n        hp->astr = aff;\\n        hp->next = NULL;      \\n        hp->next_homonym = NULL;\\n@@ -250,26 +233,29 @@ desc\\n             hp->description = mystrdup(desc);\\n             if (desc && !hp->description)\\n             {\\n-                free(hp->word);\\n                 free(hp->astr);\\n                 free(hp);\\n                 return 1;\\n             }\\n-            if (dp->description && complexprefixes) {\\n+            if (hp->description && complexprefixes) {\\n                 if (utf8) reverseword_utf(hp->description); else reverseword(hp->description);\\n             }\\n        }\\n #endif\\n+       \\n+       struct hentry * dp = tableptr[i];\\n+       if (!dp) {\\n+         tableptr[i] = hp;\\n+         return 0;\\n+       }\\n        while (dp->next != NULL) {\\n-         if ((!dp->next_homonym) && (strcmp(hp->word, dp->word) == 0)) {\\n+         if ((!dp->next_homonym) && (strcmp(&(hp->word), &(dp->word)) == 0)) {\\n     \\t    // remove hidden onlyupcase homonym\\n             if (!onlyupcase) {\\n \\t\\tif ((dp->astr) && TESTAFF(dp->astr, ONLYUPCASEFLAG, dp->alen)) {\\n \\t\\t    free(dp->astr);\\n \\t\\t    dp->astr = hp->astr;\\n \\t\\t    dp->alen = hp->alen;\\n-\\t\\t    dp->alen = hp->alen;\\n-\\t\\t    free(hp->word);\\n \\t\\t    free(hp);\\n \\t\\t    return 0;\\n \\t\\t} else {\\n@@ -281,13 +267,13 @@ desc\\n          }\\n          dp=dp->next;\\n        }\\n-       if (strcmp(hp->word, dp->word) == 0) {\\n+       if (strcmp(&(hp->word), &(dp->word)) == 0) {\\n     \\t    // remove hidden onlyupcase homonym\\n             if (!onlyupcase) {\\n \\t\\tif ((dp->astr) && TESTAFF(dp->astr, ONLYUPCASEFLAG, dp->alen)) {\\n \\t\\t    free(dp->astr);\\n \\t\\t    dp->astr = hp->astr;\\n-\\t\\t    free(hp->word);\\n+\\t\\t    dp->alen = hp->alen;\\n \\t\\t    free(hp);\\n \\t\\t    return 0;\\n \\t\\t} else {\\n@@ -301,16 +287,58 @@ desc\\n     \\t    dp->next = hp;\\n        } else {\\n     \\t    // remove hidden onlyupcase homonym\\n-    \\t    free(hp->word);\\n     \\t    if (hp->astr) free(hp->astr);\\n     \\t    free(hp);\\n        }\\n-    }\\n     return 0;\\n }     \\n \\n+int HashMgr::add_hidden_capitalized_word(char * word, int wbl, int wcl,\\n+    unsigned short * flags, int al, char * dp, int captype)\\n+{\\n+    // add inner capitalized forms to handle the following allcap forms:\\n+    // Mixed caps: OpenOffice.org -> OPENOFFICE.ORG\\n+    // Allcaps with suffixes: CIA's -> CIA'S    \\n+    if (((captype == HUHCAP) || (captype == HUHINITCAP) ||\\n+      ((captype == ALLCAP) && (flags != NULL))) &&\\n+      !((flags != NULL) && TESTAFF(flags, forbiddenword, al))) {\\n+          unsigned short * flags2 = (unsigned short *) malloc (sizeof(unsigned short) * (al+1));\\n+\\t  if (!flags2) return 1;\\n+          if (al) memcpy(flags2, flags, al * sizeof(unsigned short));\\n+          flags2[al] = ONLYUPCASEFLAG;\\n+          if (utf8) {\\n+              char st[MAXDELEN];\\n+              w_char w[MAXDELEN];\\n+              int wlen = u8_u16(w, MAXDELEN, word);\\n+              mkallsmall_utf(w, wlen, langnum);\\n+              mkallcap_utf(w, 1, langnum);\\n+              u16_u8(st, MAXDELEN, w, wlen);\\n+              return add_word(st,wbl,wcl,flags2,al+1,dp, true);\\n+           } else {\\n+               mkallsmall(word, csconv);\\n+               mkinitcap(word, csconv);\\n+               return add_word(word,wbl,wcl,flags2,al+1,dp, true);\\n+           }\\n+    }\\n+    return 0;\\n+}\\n+\\n+// detect captype and modify word length for UTF-8 encoding\\n+int HashMgr::get_clen_and_captype(const char * word, int wbl, int * captype) {\\n+    int len;\\n+    if (utf8) {\\n+      w_char dest_utf[MAXDELEN];\\n+      len = u8_u16(dest_utf, MAXDELEN, word);\\n+      *captype = get_captype_utf8(dest_utf, len, langnum);\\n+    } else {\\n+      len = wbl;\\n+      *captype = get_captype((char *) word, len, csconv);\\n+    }\\n+    return len;\\n+}\\n+\\n // add a custom dic. word to the hash table (public)\\n-int HashMgr::put_word(const char * word, int wl, char * aff)\\n+int HashMgr::put_word(const char * word, char * aff)\\n {\\n     unsigned short * flags;\\n     int al = 0;\\n@@ -320,58 +348,56 @@ int HashMgr::put_word(const char * word, int wl, char * aff)\\n     } else {\\n         flags = NULL;\\n     }\\n-    add_word(word, wl, flags, al, NULL, false);\\n-    return 0;\\n+\\n+    int captype;\\n+    int wbl = strlen(word);\\n+    int wcl = get_clen_and_captype(word, wbl, &captype);\\n+    add_word(word, wbl, wcl, flags, al, NULL, false);\\n+    return add_hidden_capitalized_word((char *) word, wbl, wcl, flags, al, NULL, captype);\\n }\\n \\n-int HashMgr::put_word_pattern(const char * word, int wl, const char * pattern)\\n+int HashMgr::put_word_pattern(const char * word, const char * pattern)\\n {\\n-    unsigned short * flags;\\n+    // detect captype and modify word length for UTF-8 encoding\\n     struct hentry * dp = lookup(pattern);\\n-    if (!dp || !dp->astr) return 1;\\n-    flags = (unsigned short *) malloc (dp->alen * sizeof(short));\\n-    if (flags) {\\n-\\tmemcpy((void *) flags, (void *) dp->astr, dp->alen * sizeof(short));\\n-\\tadd_word(word, wl, flags, dp->alen, NULL, false);\\n-        return 0;\\n+    if (dp && dp->astr) {\\n+        int captype;\\n+        int wbl = strlen(word);\\n+        int wcl = get_clen_and_captype(word, wbl, &captype);\\n+\\tif (aliasf) {\\n+\\t    add_word(word, wbl, wcl, dp->astr, dp->alen, NULL, false);\\t\\n+\\t} else {\\n+    \\t    unsigned short * flags = (unsigned short *) malloc (dp->alen * sizeof(short));\\n+\\t    if (flags) {\\n+\\t\\tmemcpy((void *) flags, (void *) dp->astr, dp->alen * sizeof(short));\\n+\\t\\tadd_word(word, wbl, wcl, flags, dp->alen, NULL, false);\\n+\\t    } else return 1;\\n+\\t}\\n+    \\treturn add_hidden_capitalized_word((char *) word, wbl, wcl, dp->astr, dp->alen, NULL, captype);\\n     }\\n     return 1;\\n }\\n \\n // walk the hash table entry by entry - null at end\\n+// initialize: col=-1; hp = NULL; hp = walk_hashtable(&col, hp);\\n struct hentry * HashMgr::walk_hashtable(int &col, struct hentry * hp) const\\n-{\\n-  //reset to start\\n-  if ((col < 0) || (hp == NULL)) {\\n-    col = -1;\\n-    hp = NULL;\\n-  }\\n-\\n-  if (hp && hp->next != NULL) {\\n-    hp = hp->next;\\n-  } else {\\n-    col++;\\n-    hp = (col < tablesize) ? &tableptr[col] : NULL;\\n-    // search for next non-blank column entry\\n-    while (hp && (hp->word == NULL)) {\\n-        col ++;\\n-        hp = (col < tablesize) ? &tableptr[col] : NULL;\\n-    }\\n-    if (col < tablesize) return hp;\\n-    hp = NULL;\\n-    col = -1;\\n+{  \\n+  if (hp && hp->next != NULL) return hp->next;\\n+  for (col++; col < tablesize; col++) {\\n+    if (tableptr[col]) return tableptr[col];\\n   }\\n-  return hp;\\n+  // null at end and reset to start\\n+  col = -1;\\n+  return NULL;\\n }\\n \\n // load a munched word list and build a hash table on the fly\\n int HashMgr::load_tables(const char * tpath)\\n {\\n-  int wl, al;\\n+  int al;\\n   char * ap;\\n   char * dp;\\n   unsigned short * flags;\\n-  int captype;\\n \\n   // raw dictionary - munched file\\n   FILE * rawdict = fopen(tpath, \\\"r\\\");\\n@@ -402,12 +428,12 @@ int HashMgr::load_tables(const char * tpath)\\n   if ((tablesize %2) == 0) tablesize++;\\n \\n   // allocate the hash table\\n-  tableptr = (struct hentry *) calloc(tablesize, sizeof(struct hentry));\\n+  tableptr = (struct hentry **) malloc(tablesize * sizeof(struct hentry *));\\n   if (! tableptr) {\\n     fclose(rawdict);\\n     return 3;\\n   }\\n-  for (int i=0; i<tablesize; i++) tableptr[i].word = NULL;\\n+  for (int i=0; i<tablesize; i++) tableptr[i] = NULL;\\n \\n   // loop through all words on much list and add to hash\\n   // table and create word and affix strings\\n@@ -457,47 +483,17 @@ int HashMgr::load_tables(const char * tpath)\\n       flags = NULL;\\n     }\\n \\n-    wl = strlen(ts);\\n-\\n-    // add the word and its index\\n-    if (add_word(ts,wl,flags,al,dp, false)) {\\n+    int captype;\\n+    int wbl = strlen(ts);\\n+    int wcl = get_clen_and_captype(ts, wbl, &captype);\\n+    // add the word and its index plus its capitalized form optionally\\n+    if (add_word(ts,wbl,wcl,flags,al,dp, false) ||\\n+\\tadd_hidden_capitalized_word(ts, wbl, wcl, flags, al, dp, captype)) {\\n \\tfclose(rawdict);\\n \\treturn 5;\\n     }\\n-\\n-    // add inner capitalized forms to handle the following allcap forms:\\n-    // Mixed caps: OpenOffice.org -> OPENOFFICE.ORG\\n-    // Allcaps with suffixes: CIA's -> CIA'S\\n-    captype = utf8 ? get_captype_utf8(ts, wl, langnum) : get_captype(ts, wl, csconv);\\n-    if (((captype == HUHCAP) || (captype == HUHINITCAP) ||\\n-      ((captype == ALLCAP) && (flags != NULL))) &&\\n-      !((flags != NULL) && TESTAFF(flags, forbiddenword, al))) {\\n-          unsigned short * flags2 = (unsigned short *) malloc (sizeof(unsigned short) * (al+1));\\n-\\t  if (!flags2) return 6;\\n-          if (al) memcpy(flags2, flags, al * sizeof(unsigned short));\\n-          flags2[al] = ONLYUPCASEFLAG;\\n-          if (utf8) {\\n-              char st[MAXDELEN];\\n-              w_char w[MAXDELEN];\\n-              int wlen = u8_u16(w, MAXDELEN, ts);\\n-              mkallsmall_utf(w, wlen, langnum);\\n-              mkallcap_utf(w, 1, langnum);\\n-              u16_u8(st, MAXDELEN, w, wlen);\\n-              if (add_word(st,wl,flags2,al+1,dp, true)) {\\n-\\t        fclose(rawdict);\\n-                return 5;\\n-              }\\n-           } else {\\n-               mkallsmall(ts, csconv);\\n-               mkinitcap(ts, csconv);\\n-               if (add_word(ts,wl,flags2,al+1,dp, true)) {\\n-\\t         fclose(rawdict);\\n-        \\t return 5;\\n-               }\\n-           }\\n-    }\\n   }\\n- \\n+\\n   fclose(rawdict);\\n   return 0;\\n }\\ndiff --git a/extensions/spellcheck/hunspell/src/hashmgr.hxx b/extensions/spellcheck/hunspell/src/hashmgr.hxx\\nindex 8dff2c1..9d92f87 100644\\n--- a/extensions/spellcheck/hunspell/src/hashmgr.hxx\\n+++ b/extensions/spellcheck/hunspell/src/hashmgr.hxx\\n@@ -70,7 +70,7 @@ enum flag { FLAG_CHAR, FLAG_LONG, FLAG_NUM, FLAG_UNI };\\n class HashMgr\\n {\\n   int             tablesize;\\n-  struct hentry * tableptr;\\n+  struct hentry ** tableptr;\\n   int             userword;\\n   flag            flag_mode;\\n   int             complexprefixes;\\n@@ -98,8 +98,8 @@ public:\\n   int hash(const char *) const;\\n   struct hentry * walk_hashtable(int & col, struct hentry * hp) const;\\n \\n-  int put_word(const char * word, int wl, char * ap);\\n-  int put_word_pattern(const char * word, int wl, const char * pattern);\\n+  int put_word(const char * word, char * ap);\\n+  int put_word_pattern(const char * word, const char * pattern);\\n   int decode_flags(unsigned short ** result, char * flags);\\n   unsigned short        decode_flag(const char * flag);\\n   char *                encode_flag(unsigned short flag);\\n@@ -112,11 +112,14 @@ public:\\n \\n   \\n private:\\n+  int get_clen_and_captype(const char * word, int wbl, int * captype);\\n   int load_tables(const char * tpath);\\n-  int add_word(const char * word, int wl, unsigned short * ap, int al,\\n-    const char * desc, bool onlyupcase);\\n+  int add_word(const char * word, int wbl, int wcl, unsigned short * ap,\\n+    int al, const char * desc, bool onlyupcase);\\n   int load_config(const char * affpath);\\n   int parse_aliasf(char * line, FILE * af);\\n+  int add_hidden_capitalized_word(char * word, int wbl, int wcl,\\n+    unsigned short * flags, int al, char * dp, int captype);\\n #ifdef HUNSPELL_EXPERIMENTAL\\n   int parse_aliasm(char * line, FILE * af);\\n #endif\\ndiff --git a/extensions/spellcheck/hunspell/src/htypes.hxx b/extensions/spellcheck/hunspell/src/htypes.hxx\\nindex 8c107e7..acc3350 100644\\n--- a/extensions/spellcheck/hunspell/src/htypes.hxx\\n+++ b/extensions/spellcheck/hunspell/src/htypes.hxx\\n@@ -69,16 +69,17 @@\\n \\n struct hentry\\n {\\n-  short    wlen;\\n-  short    alen;\\n-  char     wbeg[2];\\n-  char *   word;\\n-  unsigned short * astr;\\n-  struct   hentry * next;\\n-  struct   hentry * next_homonym;\\n+  unsigned char blen; // word length in bytes\\n+  unsigned char clen; // word length in characters (different for UTF-8 enc.)\\n+  short    alen;      // length of affix flag vector\\n+  unsigned short * astr;  // affix flag vector\\n+  struct   hentry * next; // next word with same hash code\\n+  struct   hentry * next_homonym; // next homonym word (with same hash code)\\n #ifdef HUNSPELL_EXPERIMENTAL\\n-  char *   description;\\n+  char *   description; // morphological data (optional)\\n #endif\\n+  char     var;       // variable fields (only for special pronounciation yet)\\n+  char     word;      // variable-length word (8-bit or UTF-8 encoding)\\n };\\n \\n #endif\\ndiff --git a/extensions/spellcheck/hunspell/src/hunspell.cpp b/extensions/spellcheck/hunspell/src/hunspell.cpp\\nindex 6d1c5f9..252b9fc 100644\\n--- a/extensions/spellcheck/hunspell/src/hunspell.cpp\\n+++ b/extensions/spellcheck/hunspell/src/hunspell.cpp\\n@@ -162,7 +162,7 @@ int Hunspell::cleanword2(char * dest, const char * src,\\n          *pcaptype = NOCAP;\\n          return nl;\\n       }\\n-     *pcaptype = get_captype_utf8(dest, nl, langnum);\\n+     *pcaptype = get_captype_utf8(dest_utf, *nc, langnum);\\n    } else {\\n      *pcaptype = get_captype(dest, nl, csconv);\\n      *nc = nl;\\n@@ -218,8 +218,9 @@ int Hunspell::cleanword(char * dest, const char * src,\\n       nc = u8_u16(t, MAXWORDLEN, src);\\n       for (int i = 0; i < nc; i++) {\\n          idx = (t[i].h << 8) + t[i].l;\\n-         if (idx != unicodetolower(idx, langnum)) ncap++;\\n-         if (unicodetoupper(idx, langnum) == unicodetolower(idx, langnum)) nneutral++;\\n+         unsigned short low = unicodetolower(idx, langnum);\\n+         if (idx != low) ncap++;\\n+         if (unicodetoupper(idx, langnum) == low) nneutral++;\\n       }\\n       u16_u8(dest, MAXWORDUTF8LEN, t, nc);\\n       if (ncap) {\\n@@ -272,9 +273,10 @@ int Hunspell::mkallcap2(char * p, w_char * u, int nc)\\n       unsigned short idx;\\n       for (int i = 0; i < nc; i++) {\\n          idx = (u[i].h << 8) + u[i].l;\\n-         if (idx != unicodetoupper(idx, langnum)) {\\n-            u[i].h = (unsigned char) (unicodetoupper(idx, langnum) >> 8);\\n-            u[i].l = (unsigned char) (unicodetoupper(idx, langnum) & 0x00FF);\\n+         unsigned short up = unicodetoupper(idx, langnum);\\n+         if (idx != up) {\\n+            u[i].h = (unsigned char) (up >> 8);\\n+            u[i].l = (unsigned char) (up & 0x00FF);\\n          }\\n       }\\n       u16_u8(p, MAXWORDUTF8LEN, u, nc);\\n@@ -303,9 +305,10 @@ int Hunspell::mkallsmall2(char * p, w_char * u, int nc)\\n       unsigned short idx;\\n       for (int i = 0; i < nc; i++) {\\n          idx = (u[i].h << 8) + u[i].l;\\n-         if (idx != unicodetolower(idx, langnum)) {\\n-            u[i].h = (unsigned char) (unicodetolower(idx, langnum) >> 8);\\n-            u[i].l = (unsigned char) (unicodetolower(idx, langnum) & 0x00FF);\\n+         unsigned short low = unicodetolower(idx, langnum);\\n+         if (idx != low) {\\n+            u[i].h = (unsigned char) (low >> 8);\\n+            u[i].l = (unsigned char) (low & 0x00FF);\\n          }\\n       }\\n       u16_u8(p, MAXWORDUTF8LEN, u, nc);\\n@@ -371,9 +374,9 @@ int Hunspell::spell(const char * word, int * info, char ** root)\\n   struct hentry * rv=NULL;\\n   // need larger vector. For example, Turkish capital letter I converted a\\n   // 2-byte UTF-8 character (dotless i) by mkallsmall.\\n-  char cw[MAXWORDUTF8LEN + 4];\\n-  char wspace[MAXWORDUTF8LEN + 4];\\n-  w_char unicw[MAXWORDLEN + 1];\\n+  char cw[MAXWORDUTF8LEN];\\n+  char wspace[MAXWORDUTF8LEN];\\n+  w_char unicw[MAXWORDLEN];\\n   int nc = strlen(word);\\n   int wl2 = 0;\\n   if (utf8) {\\n@@ -407,8 +410,8 @@ int Hunspell::spell(const char * word, int * info, char ** root)\\n   // LANG_hu section: number(s) + (percent or degree) with suffixes\\n   if (langnum == LANG_hu) {\\n     if ((nstate == NNUM) && ((cw[i] == '%') || ((!utf8 && (cw[i] == '\\\\xB0')) ||\\n-\\t(utf8 && (strncmp(cw + i, \\\"\\\\xC2\\\\xB0\\\", 2)==0))))\\n-        \\t&& checkword(cw + i, info, root)) return 1;\\n+        (utf8 && (strncmp(cw + i, \\\"\\\\xC2\\\\xB0\\\", 2)==0))))\\n+               && checkword(cw + i, info, root)) return 1;\\n   }\\n   // END of LANG_hu section\\n \\n@@ -680,7 +683,7 @@ struct hentry * Hunspell::checkword(const char * w, int * info, char ** root)\\n             return NULL;\\n         }\\n         if (root) {\\n-            *root = mystrdup(he->word);\\n+            *root = mystrdup(&(he->word));\\n             if (complexprefixes) {\\n                 if (utf8) reverseword_utf(*root); else reverseword(*root);\\n             }\\n@@ -700,7 +703,7 @@ struct hentry * Hunspell::checkword(const char * w, int * info, char ** root)\\n           // end of LANG speficic region          \\n           if (he) {\\n                 if (root) {\\n-                    *root = mystrdup(he->word);\\n+                    *root = mystrdup(&(he->word));\\n                     if (complexprefixes) {\\n                         if (utf8) reverseword_utf(*root); else reverseword(*root);\\n                     }\\n@@ -716,10 +719,11 @@ struct hentry * Hunspell::checkword(const char * w, int * info, char ** root)\\n \\n int Hunspell::suggest(char*** slst, const char * word)\\n {\\n-  char cw[MAXWORDUTF8LEN + 4];\\n-  char wspace[MAXWORDUTF8LEN + 4];\\n+  int onlycmpdsug = 0;\\n+  char cw[MAXWORDUTF8LEN];\\n+  char wspace[MAXWORDUTF8LEN];\\n   if (! pSMgr) return 0;\\n-  w_char unicw[MAXWORDLEN + 1];\\n+  w_char unicw[MAXWORDLEN];\\n   int nc = strlen(word);\\n   if (utf8) {\\n     if (nc >= MAXWORDUTF8LEN) return 0;\\n@@ -733,34 +737,37 @@ int Hunspell::suggest(char*** slst, const char * word)\\n   int ns = 0;\\n   *slst = NULL;\\n   int capwords = 0;\\n-  int ngramsugs = 0;\\n \\n   switch(captype) {\\n      case NOCAP:   { \\n-                     ns = pSMgr->suggest(slst, cw, ns);\\n+                     ns = pSMgr->suggest(slst, cw, ns, &onlycmpdsug);\\n                      break;\\n                    }\\n \\n      case INITCAP: { \\n                      capwords = 1;\\n-                     ns = pSMgr->suggest(slst, cw, ns);\\n+                     ns = pSMgr->suggest(slst, cw, ns, &onlycmpdsug);\\n                      if (ns == -1) break;\\n                      memcpy(wspace,cw,(wl+1));\\n                      mkallsmall2(wspace, unicw, nc);\\n-                     ns = pSMgr->suggest(slst, wspace, ns);\\n+                     ns = pSMgr->suggest(slst, wspace, ns, &onlycmpdsug);\\n                      break;\\n                    }\\n      case HUHINITCAP:\\n                     capwords = 1;\\n      case HUHCAP: { \\n-                     ns = pSMgr->suggest(slst, cw, ns);\\n+                     ns = pSMgr->suggest(slst, cw, ns, &onlycmpdsug);\\n                      if (ns != -1) {\\n                         int prevns;\\n     \\t\\t        // something.The -> something. The\\n                         char * dot = strchr(cw, '.');\\n \\t\\t        if (dot && (dot > cw)) {\\n-\\t\\t    \\t    int captype_ = utf8 ? get_captype_utf8(dot+1, strlen(dot+1), langnum) :\\n-\\t\\t        \\tget_captype(dot+1, strlen(dot+1), csconv);\\n+\\t\\t            int captype_;\\n+\\t\\t            if (utf8) {\\n+\\t\\t               w_char w_[MAXWORDLEN];\\n+\\t\\t\\t       int wl_ = u8_u16(w_, MAXWORDLEN, dot + 1);\\n+\\t\\t               captype_ = get_captype_utf8(w_, wl_, langnum);\\n+\\t\\t            } else captype_ = get_captype(dot+1, strlen(dot+1), csconv);\\n \\t\\t    \\t    if (captype_ == INITCAP) {\\n                         \\tchar * st = mystrdup(cw);\\n                         \\tst = (char *) realloc(st, wl + 2);\\n@@ -776,17 +783,17 @@ int Hunspell::suggest(char*** slst, const char * word)\\n                             // TheOpenOffice.org -> The OpenOffice.org\\n                             memcpy(wspace,cw,(wl+1));\\n                             mkinitsmall2(wspace, unicw, nc);\\n-                            ns = pSMgr->suggest(slst, wspace, ns);\\n+                            ns = pSMgr->suggest(slst, wspace, ns, &onlycmpdsug);\\n                         }\\n                         memcpy(wspace,cw,(wl+1));\\n                         mkallsmall2(wspace, unicw, nc);\\n                         if (spell(wspace)) ns = insert_sug(slst, wspace, ns);\\n                         prevns = ns;\\n-                        ns = pSMgr->suggest(slst, wspace, ns);\\n+                        ns = pSMgr->suggest(slst, wspace, ns, &onlycmpdsug);\\n                         if (captype == HUHINITCAP) {\\n                             mkinitcap2(wspace, unicw, nc);\\n                             if (spell(wspace)) ns = insert_sug(slst, wspace, ns);\\n-                            ns = pSMgr->suggest(slst, wspace, ns);\\n+                            ns = pSMgr->suggest(slst, wspace, ns, &onlycmpdsug);\\n                         }\\n                         // aNew -> \\\"a New\\\" (instead of \\\"a new\\\")\\n                         for (int j = prevns; j < ns; j++) {\\n@@ -795,7 +802,7 @@ int Hunspell::suggest(char*** slst, const char * word)\\n                                 int slen = strlen(space + 1);\\n                                 // different case after space (need capitalisation)\\n                                 if ((slen < wl) && strcmp(cw + wl - slen, space + 1)) {\\n-                                    w_char w[MAXWORDLEN + 1];\\n+                                    w_char w[MAXWORDLEN];\\n                                     int wc = 0;\\n                                     char * r = (*slst)[j];\\n                                     if (utf8) wc = u8_u16(w, MAXWORDLEN, space + 1);\\n@@ -813,12 +820,12 @@ int Hunspell::suggest(char*** slst, const char * word)\\n      case ALLCAP: { \\n                      memcpy(wspace, cw, (wl+1));\\n                      mkallsmall2(wspace, unicw, nc);\\n-                     ns = pSMgr->suggest(slst, wspace, ns);\\n+                     ns = pSMgr->suggest(slst, wspace, ns, &onlycmpdsug);\\n                      if (ns == -1) break;\\n                      if (pAMgr && pAMgr->get_keepcase() && spell(wspace))\\n                         ns = insert_sug(slst, wspace, ns);\\n                      mkinitcap2(wspace, unicw, nc);\\n-                     ns = pSMgr->suggest(slst, wspace, ns);\\n+                     ns = pSMgr->suggest(slst, wspace, ns, &onlycmpdsug);\\n                      for (int j=0; j < ns; j++) {\\n                         mkallcap((*slst)[j]);\\n                         if (pAMgr && pAMgr->get_checksharps()) {\\n@@ -862,33 +869,33 @@ int Hunspell::suggest(char*** slst, const char * word)\\n       }\\n   }\\n   // END OF LANG_hu section\\n-\\n+  \\n   // try ngram approach since found nothing\\n-  if ((ns == 0) && pAMgr && (pAMgr->get_maxngramsugs() != 0)) {\\n-      ngramsugs = 1;\\n+  if ((ns == 0 || onlycmpdsug) && pAMgr && (pAMgr->get_maxngramsugs() != 0)) {\\n       switch(captype) {\\n           case NOCAP: {\\n-              ns = pSMgr->ngsuggest(*slst, cw, pHMgr);\\n+              ns = pSMgr->ngsuggest(*slst, cw, ns, pHMgr);\\n               break;\\n           }\\n           case HUHCAP: {\\n               memcpy(wspace,cw,(wl+1));\\n               mkallsmall2(wspace, unicw, nc);\\n-              ns = pSMgr->ngsuggest(*slst, wspace, pHMgr);\\n+              ns = pSMgr->ngsuggest(*slst, wspace, ns, pHMgr);\\n               break;\\n           }\\n           case INITCAP: { \\n               capwords = 1;\\n               memcpy(wspace,cw,(wl+1));\\n               mkallsmall2(wspace, unicw, nc);\\n-              ns = pSMgr->ngsuggest(*slst, wspace, pHMgr);\\n+              ns = pSMgr->ngsuggest(*slst, wspace, ns, pHMgr);\\n               break;\\n           }\\n           case ALLCAP: {\\n               memcpy(wspace,cw,(wl+1));\\n               mkallsmall2(wspace, unicw, nc);\\n-              ns = pSMgr->ngsuggest(*slst, wspace, pHMgr);\\n-              for (int j=0; j < ns; j++) \\n+\\t      int oldns = ns;\\n+              ns = pSMgr->ngsuggest(*slst, wspace, ns, pHMgr);\\n+              for (int j = oldns; j < ns; j++) \\n                   mkallcap((*slst)[j]);\\n               break;\\n          }\\n@@ -978,8 +985,8 @@ char * Hunspell::get_dic_encoding()\\n // XXX need UTF-8 support\\n int Hunspell::suggest_auto(char*** slst, const char * word)\\n {\\n-  char cw[MAXWORDUTF8LEN + 4];\\n-  char wspace[MAXWORDUTF8LEN + 4];\\n+  char cw[MAXWORDUTF8LEN];\\n+  char wspace[MAXWORDUTF8LEN];\\n   if (! pSMgr) return 0;\\n   int wl = strlen(word);\\n   if (utf8) {\\n@@ -1075,8 +1082,8 @@ int Hunspell::suggest_auto(char*** slst, const char * word)\\n // XXX need UTF-8 support\\n int Hunspell::stem(char*** slst, const char * word)\\n {\\n-  char cw[MAXWORDUTF8LEN + 4];\\n-  char wspace[MAXWORDUTF8LEN + 4];\\n+  char cw[MAXWORDUTF8LEN];\\n+  char wspace[MAXWORDUTF8LEN];\\n   if (! pSMgr) return 0;\\n   int wl = strlen(word);\\n   if (utf8) {\\n@@ -1162,8 +1169,8 @@ int Hunspell::stem(char*** slst, const char * word)\\n \\n int Hunspell::suggest_pos_stems(char*** slst, const char * word)\\n {\\n-  char cw[MAXWORDUTF8LEN + 4];\\n-  char wspace[MAXWORDUTF8LEN + 4];\\n+  char cw[MAXWORDUTF8LEN];\\n+  char wspace[MAXWORDUTF8LEN];\\n   if (! pSMgr) return 0;\\n   int wl = strlen(word);\\n   if (utf8) {\\n@@ -1284,17 +1291,13 @@ int Hunspell::mkinitsmall2(char * p, w_char * u, int nc)\\n \\n int Hunspell::put_word(const char * word)\\n {\\n-    if (pHMgr) {\\n-        return pHMgr->put_word(word, strlen(word), NULL);\\n-    }\\n+    if (pHMgr) return pHMgr->put_word(word, NULL);\\n     return 0;\\n }\\n \\n int Hunspell::put_word_pattern(const char * word, const char * pattern)\\n {\\n-    if (pHMgr) {\\n-        return pHMgr->put_word_pattern(word, strlen(word), pattern);\\n-    }\\n+    if (pHMgr) return pHMgr->put_word_pattern(word, pattern);\\n     return 0;\\n }\\n \\n@@ -1303,23 +1306,17 @@ const char * Hunspell::get_version()\\n   return pAMgr->get_version();\\n }\\n \\n-/*\\n-\\n struct cs_info * Hunspell::get_csconv()\\n {\\n   return csconv;\\n }\\n \\n-int utf16_isalpha(unsigned short c) {\\n-  return unicodeisalpha(c);\\n-}\\n-*/\\n #ifdef HUNSPELL_EXPERIMENTAL\\n // XXX need UTF-8 support\\n char * Hunspell::morph(const char * word)\\n {\\n-  char cw[MAXWORDUTF8LEN + 4];\\n-  char wspace[MAXWORDUTF8LEN + 4];\\n+  char cw[MAXWORDUTF8LEN];\\n+  char wspace[MAXWORDUTF8LEN];\\n   if (! pSMgr) return 0;\\n   int wl = strlen(word);\\n   if (utf8) {\\n@@ -1606,8 +1603,8 @@ char * Hunspell::morph(const char * word)\\n // XXX need UTF-8 support\\n char * Hunspell::morph_with_correction(const char * word)\\n {\\n-  char cw[MAXWORDUTF8LEN + 4];\\n-  char wspace[MAXWORDUTF8LEN + 4];\\n+  char cw[MAXWORDUTF8LEN];\\n+  char wspace[MAXWORDUTF8LEN];\\n   if (! pSMgr) return 0;\\n   int wl = strlen(word);\\n   if (utf8) {\\n@@ -1808,4 +1805,3 @@ int Hunspell_suggest(Hunhandle *pHunspell, char*** slst, const char * word)\\n {\\n         return ((Hunspell*)pHunspell)->suggest(slst, word);\\n }\\n-\\ndiff --git a/extensions/spellcheck/hunspell/src/hunspell.hxx b/extensions/spellcheck/hunspell/src/hunspell.hxx\\nindex 6574772..15632de 100644\\n--- a/extensions/spellcheck/hunspell/src/hunspell.hxx\\n+++ b/extensions/spellcheck/hunspell/src/hunspell.hxx\\n@@ -147,8 +147,7 @@ public:\\n   const char * get_wordchars();\\n   unsigned short * get_wordchars_utf16(int * len);\\n \\n-//  struct cs_info * get_csconv();\\n-//  int utf16_isalpha(unsigned short c);\\n+  struct cs_info * get_csconv();\\n   const char * get_version();\\n \\n   /* experimental functions */\\ndiff --git a/extensions/spellcheck/hunspell/src/phonet.cpp b/extensions/spellcheck/hunspell/src/phonet.cpp\\nnew file mode 100644\\nindex 0000000..8789b89\\n--- /dev/null\\n+++ b/extensions/spellcheck/hunspell/src/phonet.cpp\\n@@ -0,0 +1,310 @@\\n+/******* BEGIN LICENSE BLOCK *******\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ * \\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ * \\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ * \\n+ * The Initial Developer of the Original Code is Bj�rn Jacke. Portions created\\n+ * by the Initial Developers are Copyright (C) 2000-2007 the Initial\\n+ * Developers. All Rights Reserved.\\n+ * \\n+ * Contributor(s): Bj�rn Jacke (bjoern.jacke@gmx.de)\\n+ *                 L�szl� N�meth (nemethl@gyorsposta.hu)\\n+ * \\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * Changelog:\\n+ *  2000-01-05  Bj�rn Jacke <bjoern.jacke AT gmx.de>\\n+ *              Initial Release insprired by the article about phonetic\\n+ *              transformations out of c't 25/1999\\n+ *\\n+ *  2007-07-26  Bj�rn Jacke <bjoern.jacke AT gmx.de>\\n+ *              Released under MPL/GPL/LGPL tri-license for Hunspell\\n+ *\\n+ *  2007-08-23  L�szl� N�meth <nemeth at OOo>\\n+ *              Porting from Aspell to Hunspell using C-like structs\\n+ *\\n+ ******* END LICENSE BLOCK *******/\\n+\\n+#ifndef MOZILLA_CLIENT\\n+#include <cstdlib>\\n+#include <cstring>\\n+#include <cstdio>\\n+#include <cctype>\\n+#else\\n+#include <stdlib.h> \\n+#include <string.h>\\n+#include <stdio.h> \\n+#include <ctype.h>\\n+#endif\\n+\\n+#include \\\"csutil.hxx\\\"\\n+#include \\\"phonet.hxx\\\"\\n+\\n+void init_phonet_hash(phonetable & parms) \\n+  {\\n+    int i, k;\\n+\\n+    for (i = 0; i < parms.hash_size; i++) {\\n+      parms.hash[i] = -1;\\n+    }\\n+\\n+    for (i = 0; parms.rules[i][0] != '\\\\0'; i += 2) {\\n+      /**  set hash value  **/\\n+      k = (unsigned char) parms.rules[i][0];\\n+\\n+      if (parms.hash[k] < 0) {\\n+\\tparms.hash[k] = i;\\n+      }\\n+    }\\n+  }\\n+\\n+  // like strcpy but safe if the strings overlap\\n+  //   but only if dest < src\\n+  static inline void strmove(char * dest, char * src) {\\n+    while (*src) \\n+      *dest++ = *src++;\\n+    *dest = '\\\\0';\\n+  }\\n+\\n+/*  phonetic transcription algorithm                   */\\n+/*  see: http://aspell.net/man-html/Phonetic-Code.html */\\n+/*  convert string to uppercase before this call       */\\n+int phonet (const char * inword, char * target,\\n+              int len,\\n+\\t      phonetable & parms)\\n+  {\\n+    /**       Do phonetic transformation.       **/\\n+    /**  \\\"len\\\" = length of \\\"inword\\\" incl. '\\\\0'. **/\\n+\\n+    /**  result:  >= 0:  length of \\\"target\\\"    **/\\n+    /**            otherwise:  error            **/\\n+\\n+    int  i,j,k=0,n,p,z;\\n+    int  k0,n0,p0=-333,z0;\\n+    char c, c0;\\n+    const char * s;\\n+    typedef unsigned char uchar;    \\n+    char word[MAXPHONETUTF8LEN + 1];\\n+    if (len == -1) len = strlen(inword);\\n+    if (len > MAXPHONETUTF8LEN) return 0;\\n+    strcpy(word, inword);\\n+  \\n+    /**  check word  **/\\n+    i = j = z = 0;\\n+    while ((c = word[i]) != '\\\\0') {\\n+      n = parms.hash[(uchar) c];\\n+      z0 = 0;\\n+\\n+      if (n >= 0) {\\n+        /**  check all rules for the same letter  **/\\n+        while (parms.rules[n][0] == c) {\\n+\\n+          /**  check whole string  **/\\n+          k = 1;   /** number of found letters  **/\\n+          p = 5;   /** default priority  **/\\n+          s = parms.rules[n];\\n+          s++;     /**  important for (see below)  \\\"*(s-1)\\\"  **/\\n+          \\n+          while (*s != '\\\\0'  &&  word[i+k] == *s\\n+                 &&  !isdigit (*s)  &&  strchr (\\\"(-<^$\\\", *s) == NULL) {\\n+            k++;\\n+            s++;\\n+          }\\n+          if (*s == '(') {\\n+            /**  check letters in \\\"(..)\\\"  **/\\n+            if (isalpha(word[i+k])  // ...could be implied?\\n+                && strchr(s+1, word[i+k]) != NULL) {\\n+              k++;\\n+              while (*s != ')')\\n+                s++;\\n+              s++;\\n+            }\\n+          }\\n+          p0 = (int) *s;\\n+          k0 = k;\\n+          while (*s == '-'  &&  k > 1) {\\n+            k--;\\n+            s++;\\n+          }\\n+          if (*s == '<')\\n+            s++;\\n+          if (isdigit (*s)) {\\n+            /**  determine priority  **/\\n+            p = *s - '0';\\n+            s++;\\n+          }\\n+          if (*s == '^'  &&  *(s+1) == '^')\\n+            s++;\\n+\\n+          if (*s == '\\\\0'\\n+              || (*s == '^'  \\n+                  && (i == 0  ||  ! isalpha(word[i-1]))\\n+                  && (*(s+1) != '$'\\n+                      || (! isalpha(word[i+k0]) )))\\n+              || (*s == '$'  &&  i > 0  \\n+                  &&  isalpha(word[i-1])\\n+                  && (! isalpha(word[i+k0]) ))) \\n+          {\\n+            /**  search for followup rules, if:     **/\\n+            /**  parms.followup and k > 1  and  NO '-' in searchstring **/\\n+            c0 = word[i+k-1];\\n+            n0 = parms.hash[(uchar) c0];\\n+\\n+//            if (parms.followup  &&  k > 1  &&  n0 >= 0\\n+            if (k > 1  &&  n0 >= 0\\n+                &&  p0 != (int) '-'  &&  word[i+k] != '\\\\0') {\\n+              /**  test follow-up rule for \\\"word[i+k]\\\"  **/\\n+              while (parms.rules[n0][0] == c0) {\\n+\\n+                /**  check whole string  **/\\n+                k0 = k;\\n+                p0 = 5;\\n+                s = parms.rules[n0];\\n+                s++;\\n+                while (*s != '\\\\0'  &&  word[i+k0] == *s\\n+                       && ! isdigit(*s)  &&  strchr(\\\"(-<^$\\\",*s) == NULL) {\\n+                  k0++;\\n+                  s++;\\n+                }\\n+                if (*s == '(') {\\n+                  /**  check letters  **/\\n+                  if (isalpha(word[i+k0])\\n+                      &&  strchr (s+1, word[i+k0]) != NULL) {\\n+                    k0++;\\n+                    while (*s != ')'  &&  *s != '\\\\0')\\n+                      s++;\\n+                    if (*s == ')')\\n+                      s++;\\n+                  }\\n+                }\\n+                while (*s == '-') {\\n+                  /**  \\\"k0\\\" gets NOT reduced   **/\\n+                  /**  because \\\"if (k0 == k)\\\"  **/\\n+                  s++;\\n+                }\\n+                if (*s == '<')\\n+                  s++;\\n+                if (isdigit (*s)) {\\n+                  p0 = *s - '0';\\n+                  s++;\\n+                }\\n+\\n+                if (*s == '\\\\0'\\n+                    /**  *s == '^' cuts  **/\\n+                    || (*s == '$'  &&  ! isalpha(word[i+k0]))) \\n+                {\\n+                  if (k0 == k) {\\n+                    /**  this is just a piece of the string  **/\\n+                    n0 += 2;\\n+                    continue;\\n+                  }\\n+\\n+                  if (p0 < p) {\\n+                    /**  priority too low  **/\\n+                    n0 += 2;\\n+                    continue;\\n+                  }\\n+                  /**  rule fits; stop search  **/\\n+                  break;\\n+                }\\n+                n0 += 2;\\n+              } /**  End of \\\"while (parms.rules[n0][0] == c0)\\\"  **/\\n+\\n+              if (p0 >= p  && parms.rules[n0][0] == c0) {\\n+                n += 2;\\n+                continue;\\n+              }\\n+            } /** end of follow-up stuff **/\\n+\\n+            /**  replace string  **/\\n+            s = parms.rules[n+1];\\n+            p0 = (parms.rules[n][0] != '\\\\0'\\n+                 &&  strchr (parms.rules[n]+1,'<') != NULL) ? 1:0;\\n+            if (p0 == 1 &&  z == 0) {\\n+              /**  rule with '<' is used  **/\\n+              if (j > 0  &&  *s != '\\\\0'\\n+                 && (target[j-1] == c  ||  target[j-1] == *s)) {\\n+                j--;\\n+              }\\n+              z0 = 1;\\n+              z = 1;\\n+              k0 = 0;\\n+              while (*s != '\\\\0'  &&  word[i+k0] != '\\\\0') {\\n+                word[i+k0] = *s;\\n+                k0++;\\n+                s++;\\n+              }\\n+              if (k > k0)\\n+                strmove (&word[0]+i+k0, &word[0]+i+k);\\n+\\n+              /**  new \\\"actual letter\\\"  **/\\n+              c = word[i];\\n+            }\\n+            else { /** no '<' rule used **/\\n+              i += k - 1;\\n+              z = 0;\\n+              while (*s != '\\\\0'\\n+                     &&  *(s+1) != '\\\\0'  &&  j < len) {\\n+                if (j == 0  ||  target[j-1] != *s) {\\n+                  target[j] = *s;\\n+                  j++;\\n+                }\\n+                s++;\\n+              }\\n+              /**  new \\\"actual letter\\\"  **/\\n+              c = *s;\\n+              if (parms.rules[n][0] != '\\\\0'\\n+                 &&  strstr (parms.rules[n]+1, \\\"^^\\\") != NULL) {\\n+                if (c != '\\\\0') {\\n+                  target[j] = c;\\n+                  j++;\\n+                }\\n+                strmove (&word[0], &word[0]+i+1);\\n+                i = 0;\\n+                z0 = 1;\\n+              }\\n+            }\\n+            break;\\n+          }  /** end of follow-up stuff **/\\n+          n += 2;\\n+        } /**  end of while (parms.rules[n][0] == c)  **/\\n+      } /**  end of if (n >= 0)  **/\\n+      if (z0 == 0) {\\n+//        if (k && (assert(p0!=-333),!p0) &&  j < len &&  c != '\\\\0'\\n+//           && (!parms.collapse_result  ||  j == 0  ||  target[j-1] != c)){\\n+        if (k && !p0 && j < len &&  c != '\\\\0'\\n+           && (1 || j == 0  ||  target[j-1] != c)){\\n+           /**  condense only double letters  **/\\n+          target[j] = c;\\n+\\t  ///printf(\\\"\\\\n setting \\\\n\\\");\\n+          j++;\\n+        }\\n+\\n+        i++;\\n+        z = 0;\\n+\\tk=0;\\n+      }\\n+    }  /**  end of   while ((c = word[i]) != '\\\\0')  **/\\n+\\n+    target[j] = '\\\\0';\\n+    return (j);\\n+\\n+  }  /**  end of function \\\"phonet\\\"  **/\\ndiff --git a/extensions/spellcheck/hunspell/src/phonet.hxx b/extensions/spellcheck/hunspell/src/phonet.hxx\\nnew file mode 100644\\nindex 0000000..48a8f5f\\n--- /dev/null\\n+++ b/extensions/spellcheck/hunspell/src/phonet.hxx\\n@@ -0,0 +1,66 @@\\n+/******* BEGIN LICENSE BLOCK *******\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ * \\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ * \\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ * \\n+ * The Initial Developer of the Original Code is Bj�rn Jacke. Portions created\\n+ * by the Initial Developers are Copyright (C) 2000-2007 the Initial\\n+ * Developers. All Rights Reserved.\\n+ * \\n+ * Contributor(s): Bj�rn Jacke (bjoern.jacke@gmx.de)\\n+ *                 L�szl� N�meth (nemethl@gyorsposta.hu)\\n+ * \\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * Changelog:\\n+ *  2000-01-05  Bj�rn Jacke <bjoern.jacke AT gmx.de>\\n+ *              Initial Release insprired by the article about phonetic\\n+ *              transformations out of c't 25/1999\\n+ *\\n+ *  2007-07-20  Bj�rn Jacke <bjoern.jacke AT gmx.de>\\n+ *              Released under MPL/GPL/LGPL tri-license for Hunspell\\n+ *\\n+ *  2007-08-22  L�szl� N�meth <nemeth at OOo>\\n+ *              Porting from Aspell to Hunspell by little modifications\\n+ *\\n+ ******* END LICENSE BLOCK *******/\\n+\\n+#ifndef __PHONETHXX__\\n+#define __PHONETHXX__\\n+\\n+#define MAXPHONETLEN      256\\n+#define MAXPHONETUTF8LEN  (MAXPHONETLEN * 4)\\n+\\n+struct phonetable {\\n+  char utf8;\\n+  cs_info * lang;\\n+  int num;\\n+  char * * rules;\\n+  static const int hash_size = 256;\\n+  int hash[hash_size];\\n+};\\n+\\n+void init_phonet_hash(phonetable & parms);\\n+\\n+int phonet (const char * inword, char * target,\\n+              int len, phonetable & phone);\\n+\\n+#endif\\ndiff --git a/extensions/spellcheck/hunspell/src/suggestmgr.cpp b/extensions/spellcheck/hunspell/src/suggestmgr.cpp\\nindex 6404a22..4d141b5 100644\\n--- a/extensions/spellcheck/hunspell/src/suggestmgr.cpp\\n+++ b/extensions/spellcheck/hunspell/src/suggestmgr.cpp\\n@@ -74,6 +74,7 @@ using namespace std;\\n #endif\\n #endif\\n \\n+const w_char W_VLINE = { '\\\\0', '|' };\\n \\n SuggestMgr::SuggestMgr(const char * tryme, int maxn, \\n                        AffixMgr * aptr)\\n@@ -83,27 +84,45 @@ SuggestMgr::SuggestMgr(const char * tryme, int maxn,\\n   // try when building candidate suggestions\\n   pAMgr = aptr;\\n \\n+  ckeyl = 0;\\n+  ckey = NULL;\\n+  ckey_utf = NULL;\\n+\\n   ctryl = 0;\\n   ctry = NULL;\\n   ctry_utf = NULL;\\n \\n+  utf8 = 0;\\n+  langnum = 0;\\n+  complexprefixes = 0;  \\n+  \\n   maxSug = maxn;\\n   nosplitsugs = 0;\\n   maxngramsugs = MAXNGRAMSUGS;\\n \\n-  utf8 = 0;\\n-  complexprefixes = 0;\\n-\\n   if (pAMgr) {\\n         char * enc = pAMgr->get_encoding();\\n         csconv = get_current_cs(enc);\\n         free(enc);\\n+        langnum = pAMgr->get_langnum();\\n+        ckey = pAMgr->get_key_string();\\n         nosplitsugs = pAMgr->get_nosplitsugs();\\n         if (pAMgr->get_maxngramsugs() >= 0) maxngramsugs = pAMgr->get_maxngramsugs();\\n         utf8 = pAMgr->get_utf8();\\n         complexprefixes = pAMgr->get_complexprefixes();\\n   }\\n \\n+  if (ckey) {  \\n+    if (utf8) {\\n+        w_char t[MAXSWL];    \\n+        ckeyl = u8_u16(t, MAXSWL, ckey);\\n+        ckey_utf = (w_char *) malloc(ckeyl * sizeof(w_char));\\n+        if (ckey_utf) memcpy(ckey_utf, t, ckeyl * sizeof(w_char));\\n+    } else {\\n+        ckeyl = strlen(ckey);\\n+    }\\n+  }\\n+  \\n   if (tryme) {  \\n     if (utf8) {\\n         w_char t[MAXSWL];    \\n@@ -121,6 +140,11 @@ SuggestMgr::SuggestMgr(const char * tryme, int maxn,\\n SuggestMgr::~SuggestMgr()\\n {\\n   pAMgr = NULL;\\n+  if (ckey) free(ckey);\\n+  ckey = NULL;\\n+  if (ckey_utf) free(ckey_utf);\\n+  ckey_utf = NULL;\\n+  ckeyl = 0;\\n   if (ctry) free(ctry);\\n   ctry = NULL;\\n   if (ctry_utf) free(ctry_utf);\\n@@ -130,7 +154,7 @@ SuggestMgr::~SuggestMgr()\\n }\\n \\n int SuggestMgr::testsug(char** wlst, const char * candidate, int wl, int ns, int cpdsuggest,\\n-   int * timer, time_t * timelimit) {\\n+   int * timer, clock_t * timelimit) {\\n       int cwrd = 1;\\n       if (ns == maxSug) return maxSug;\\n       for (int k=0; k < ns; k++) {\\n@@ -149,13 +173,15 @@ int SuggestMgr::testsug(char** wlst, const char * candidate, int wl, int ns, int\\n \\n // generate suggestions for a mispelled word\\n //    pass in address of array of char * pointers\\n+// onlycompoundsug: probably bad suggestions (need for ngram sugs, too)\\n \\n-int SuggestMgr::suggest(char*** slst, const char * w, int nsug)\\n+int SuggestMgr::suggest(char*** slst, const char * w, int nsug,\\n+    int * onlycompoundsug)\\n {\\n-    int nocompoundtwowords = 0;\\n-    char ** wlst;    \\n-    w_char word_utf[MAXSWL];\\n-    int wl = 0;\\n+  int nocompoundtwowords = 0;\\n+  char ** wlst;    \\n+  w_char word_utf[MAXSWL];\\n+  int wl = 0;\\n \\n   char w2[MAXWORDUTF8LEN];\\n   const char * word = w;\\n@@ -194,8 +220,8 @@ int SuggestMgr::suggest(char*** slst, const char * w, int nsug)\\n     nsug = replchars(wlst, word, nsug, cpdsuggest);\\n \\n     // perhaps we made chose the wrong char from a related set\\n-    if ((nsug < maxSug) && (nsug > -1) && (cpdsuggest == 0)) {\\n-      nsug = mapchars(wlst, word, nsug);\\n+    if ((nsug < maxSug) && (nsug > -1)) {\\n+      nsug = mapchars(wlst, word, nsug, cpdsuggest);\\n     }\\n \\n     // did we swap the order of chars by mistake\\n@@ -210,6 +236,21 @@ int SuggestMgr::suggest(char*** slst, const char * w, int nsug)\\n                     longswapchar(wlst, word, nsug, cpdsuggest);\\n     }\\n \\n+    // did we just hit the wrong key in place of a good char (case and keyboard)\\n+    if ((nsug < maxSug) && (nsug > -1)) {\\n+        nsug = (utf8) ? badcharkey_utf(wlst, word_utf, wl, nsug, cpdsuggest) :\\n+                    badcharkey(wlst, word, nsug, cpdsuggest);\\n+    }\\n+\\n+    // did we add a char that should not be there\\n+    if ((nsug < maxSug) && (nsug > -1)) {\\n+        nsug = (utf8) ? extrachar_utf(wlst, word_utf, wl, nsug, cpdsuggest) :\\n+                    extrachar(wlst, word, nsug, cpdsuggest);\\n+    }\\n+\\n+    // only suggest compound words when no other suggestion\\n+    if ((cpdsuggest == 0) && (nsug > 0)) nocompoundtwowords=1;\\n+\\n     // did we forgot a char\\n     if ((nsug < maxSug) && (nsug > -1)) {\\n         nsug = (utf8) ? forgotchar_utf(wlst, word_utf, wl, nsug, cpdsuggest) :\\n@@ -222,12 +263,6 @@ int SuggestMgr::suggest(char*** slst, const char * w, int nsug)\\n                     movechar(wlst, word, nsug, cpdsuggest);\\n     }\\n \\n-    // did we add a char that should not be there\\n-    if ((nsug < maxSug) && (nsug > -1)) {\\n-        nsug = (utf8) ? extrachar_utf(wlst, word_utf, wl, nsug, cpdsuggest) :\\n-                    extrachar(wlst, word, nsug, cpdsuggest);\\n-    }\\n-\\n     // did we just hit the wrong key in place of a good char\\n     if ((nsug < maxSug) && (nsug > -1)) {\\n         nsug = (utf8) ? badchar_utf(wlst, word_utf, wl, nsug, cpdsuggest) :\\n@@ -240,10 +275,6 @@ int SuggestMgr::suggest(char*** slst, const char * w, int nsug)\\n                     doubletwochars(wlst, word, nsug, cpdsuggest);\\n     }\\n \\n-\\n-    // only suggest compound words when no other suggestion\\n-    if ((cpdsuggest==0) && (nsug>0)) nocompoundtwowords=1;\\n-\\n     // perhaps we forgot to hit space and two words ran together\\n     if ((!nosplitsugs) && (nsug < maxSug) && (nsug > -1)) {\\n                 nsug = twowords(wlst, word, nsug, cpdsuggest);\\n@@ -258,6 +289,8 @@ int SuggestMgr::suggest(char*** slst, const char * w, int nsug)\\n        free(wlst);\\n        wlst = NULL;\\n     }\\n+    \\n+    if (!nocompoundtwowords && (nsug > 0) && onlycompoundsug) *onlycompoundsug = 1;\\n \\n     *slst = wlst;\\n     return nsug;\\n@@ -295,10 +328,10 @@ int SuggestMgr::suggest_auto(char*** slst, const char * w, int nsug)\\n     nsug = replchars(wlst, word, nsug, cpdsuggest);\\n \\n     // perhaps we made chose the wrong char from a related set\\n-    if ((nsug < maxSug) && (nsug > -1) && (cpdsuggest == 0))\\n-      nsug = mapchars(wlst, word, nsug);\\n+    if ((nsug < maxSug) && (nsug > -1))\\n+      nsug = mapchars(wlst, word, nsug, cpdsuggest);\\n \\n-    if ((cpdsuggest==0) && (nsug>0)) nocompoundtwowords=1;\\n+    if ((cpdsuggest==0) && (nsug>0)) nocompoundtwowords=1; else *\\n \\n     // perhaps we forgot to hit space and two words ran together\\n \\n@@ -326,7 +359,7 @@ int SuggestMgr::capchars_utf(char ** wlst, const w_char * word, int wl, int ns,\\n   char candidate[MAXSWUTF8L];\\n   w_char candidate_utf[MAXSWL];\\n   memcpy(candidate_utf, word, wl * sizeof(w_char));\\n-  mkallcap_utf(candidate_utf, wl, pAMgr->get_langnum());\\n+  mkallcap_utf(candidate_utf, wl, langnum);\\n   u16_u8(candidate, MAXSWUTF8L, candidate_utf, wl);\\n   return testsug(wlst, candidate, strlen(candidate), ns, cpdsuggest, NULL, NULL);\\n }\\n@@ -341,9 +374,9 @@ int SuggestMgr::capchars(char** wlst, const char * word, int ns, int cpdsuggest)\\n }\\n \\n // suggestions for when chose the wrong char out of a related set\\n-int SuggestMgr::mapchars(char** wlst, const char * word, int ns)\\n+int SuggestMgr::mapchars(char** wlst, const char * word, int ns, int cpdsuggest)\\n {\\n-  time_t timelimit;\\n+  clock_t timelimit;\\n   int timer;\\n   \\n   int wl = strlen(word);\\n@@ -353,18 +386,19 @@ int SuggestMgr::mapchars(char** wlst, const char * word, int ns)\\n   struct mapentry* maptable = pAMgr->get_maptable();\\n   if (maptable==NULL) return ns;\\n \\n-  timelimit = time(NULL);\\n+  timelimit = clock();\\n   timer = MINTIMER;\\n   if (utf8) {\\n     w_char w[MAXSWL];\\n     int len = u8_u16(w, MAXSWL, word);\\n-    ns = map_related_utf(w, len, 0, wlst, ns, maptable, nummap, &timer, &timelimit);\\n-  } else ns = map_related(word, 0, wlst, ns, maptable, nummap, &timer, &timelimit);\\n+    ns = map_related_utf(w, len, 0, cpdsuggest, wlst, ns, maptable, nummap, &timer, &timelimit);\\n+  } else ns = map_related(word, 0, wlst, cpdsuggest, ns, maptable, nummap, &timer, &timelimit);\\n   return ns;\\n }\\n \\n-int SuggestMgr::map_related(const char * word, int i, char** wlst, int ns,\\n-    const mapentry* maptable, int nummap, int * timer, time_t * timelimit)\\n+int SuggestMgr::map_related(const char * word, int i, char** wlst, \\n+    int cpdsuggest,  int ns,\\n+    const mapentry* maptable, int nummap, int * timer, clock_t * timelimit)\\n {\\n   char c = *(word + i);  \\n   if (c == 0) {\\n@@ -372,8 +406,7 @@ int SuggestMgr::map_related(const char * word, int i, char** wlst, int ns,\\n       int wl = strlen(word);\\n       for (int m=0; m < ns; m++)\\n           if (strcmp(word,wlst[m]) == 0) cwrd = 0;\\n-      if ((cwrd) && (checkword(word, wl, 0, timer, timelimit) || \\n-        checkword(word, wl, 1, timer, timelimit))) {\\n+      if ((cwrd) && checkword(word, wl, cpdsuggest, timer, timelimit)) {\\n           if (ns < maxSug) {\\n               wlst[ns] = mystrdup(word);\\n               if (wlst[ns] == NULL) return -1;\\n@@ -389,21 +422,24 @@ int SuggestMgr::map_related(const char * word, int i, char** wlst, int ns,\\n       char * newword = mystrdup(word);\\n       for (int k = 0; k < maptable[j].len; k++) {\\n         *(newword + i) = *(maptable[j].set + k);\\n-        ns = map_related(newword, (i+1), wlst, ns, maptable, nummap, timer, timelimit);\\n-        if (!(*timelimit)) return ns;\\n+        ns = map_related(newword, (i+1), wlst, cpdsuggest,\\n+           ns, maptable, nummap, timer, timelimit);\\n+        if (!(*timer)) return ns;\\n       }\\n       free(newword);\\n     }\\n   }\\n   if (!in_map) {\\n      i++;\\n-     ns = map_related(word, i, wlst, ns, maptable, nummap, timer, timelimit);\\n+     ns = map_related(word, i, wlst, cpdsuggest,\\n+        ns, maptable, nummap, timer, timelimit);\\n   }\\n   return ns;\\n }\\n \\n-int SuggestMgr::map_related_utf(w_char * word, int len, int i, char** wlst, int ns,\\n-    const mapentry* maptable, int nummap, int * timer, time_t * timelimit) \\n+int SuggestMgr::map_related_utf(w_char * word, int len, int i, int cpdsuggest,\\n+    char** wlst, int ns, const mapentry* maptable, int nummap,\\n+    int * timer, clock_t * timelimit) \\n {\\n   if (i == len) {\\n       int cwrd = 1;\\n@@ -413,8 +449,7 @@ int SuggestMgr::map_related_utf(w_char * word, int len, int i, char** wlst, int\\n       wl = strlen(s);\\n       for (int m=0; m < ns; m++)\\n           if (strcmp(s,wlst[m]) == 0) cwrd = 0;\\n-      if ((cwrd) && (checkword(s, wl, 0, timer, timelimit) || \\n-            checkword(s, wl, 1, timer, timelimit))) {\\n+      if ((cwrd) && checkword(s, wl, cpdsuggest, timer, timelimit)) {\\n           if (ns < maxSug) {\\n               wlst[ns] = mystrdup(s);\\n               if (wlst[ns] == NULL) return -1;\\n@@ -430,15 +465,17 @@ int SuggestMgr::map_related_utf(w_char * word, int len, int i, char** wlst, int\\n       in_map = 1;\\n       for (int k = 0; k < maptable[j].len; k++) {\\n         *(word + i) = *(maptable[j].set_utf16 + k);\\n-        ns = map_related_utf(word, len, i + 1, wlst, ns, maptable, nummap, timer, timelimit);\\n-        if (!(*timelimit)) return ns;\\n+        ns = map_related_utf(word, len, i + 1, cpdsuggest,\\n+           wlst, ns, maptable, nummap, timer, timelimit);\\n+        if (!(*timer)) return ns;\\n       }\\n       *((unsigned short *) word + i) = c;\\n     }\\n   }\\n   if (!in_map) {\\n      i++;\\n-     ns = map_related_utf(word, len, i, wlst, ns, maptable, nummap, timer, timelimit);\\n+     ns = map_related_utf(word, len, i, cpdsuggest,\\n+          wlst, ns, maptable, nummap, timer, timelimit);\\n   }\\n   return ns;\\n }\\n@@ -469,6 +506,22 @@ int SuggestMgr::replchars(char** wlst, const char * word, int ns, int cpdsuggest\\n           strcpy(candidate+(r-word)+lenr, r+lenp);\\n           ns = testsug(wlst, candidate, wl-lenp+lenr, ns, cpdsuggest, NULL, NULL);\\n           if (ns == -1) return -1;\\n+          // check REP suggestions with space\\n+          char * sp = strchr(candidate, ' ');\\n+          if (sp) {\\n+            *sp = '\\\\0';\\n+            if (checkword(candidate, strlen(candidate), 0, NULL, NULL)) {\\n+              int oldns = ns;\\n+              *sp = ' ';\\n+              ns = testsug(wlst, sp + 1, strlen(sp + 1), ns, cpdsuggest, NULL, NULL);\\n+              if (ns == -1) return -1;\\n+              if (oldns < ns) {\\n+                free(wlst[ns - 1]);\\n+                wlst[ns - 1] = mystrdup(candidate);\\n+              }\\n+            }            \\n+            *sp = ' ';\\n+          }\\n           r++; // search for the next letter\\n       }\\n    }\\n@@ -507,7 +560,7 @@ int SuggestMgr::doubletwochars_utf(char ** wlst, const w_char * word, int wl, in\\n   int state=0;\\n   if (wl < 5 || ! pAMgr) return ns;\\n   for (int i=2; i < wl; i++) {\\n-      if ((word[i].l==word[i-2].l) && (word[i].h==word[i-2].h))  {\\n+      if (w_char_eq(word[i], word[i-2]))  {\\n           state++;\\n           if (state==3) {\\n             memcpy(candidate_utf, word, (i - 1) * sizeof(w_char));\\n@@ -524,12 +577,95 @@ int SuggestMgr::doubletwochars_utf(char ** wlst, const w_char * word, int wl, in\\n   return ns;\\n }\\n \\n+// error is wrong char in place of correct one (case and keyboard related version)\\n+int SuggestMgr::badcharkey(char ** wlst, const char * word, int ns, int cpdsuggest)\\n+{\\n+  char  tmpc;\\n+  char  candidate[MAXSWUTF8L];\\n+  int wl = strlen(word);\\n+  strcpy(candidate, word);\\n+  // swap out each char one by one and try uppercase and neighbor\\n+  // keyboard chars in its place to see if that makes a good word\\n+\\n+  for (int i=0; i < wl; i++) {\\n+    tmpc = candidate[i];\\n+    // check with uppercase letters\\n+    candidate[i] = csconv[((unsigned char)tmpc)].cupper;\\n+    if (tmpc != candidate[i]) {\\n+       ns = testsug(wlst, candidate, wl, ns, cpdsuggest, NULL, NULL);\\n+       if (ns == -1) return -1;\\n+       candidate[i] = tmpc;\\n+    }\\n+    // check neighbor characters in keyboard string\\n+    if (!ckey) continue;\\n+    char * loc = strchr(ckey, tmpc);\\n+    while (loc) {\\n+       if ((loc > ckey) && (*(loc - 1) != '|')) {\\n+          candidate[i] = *(loc - 1);\\n+          ns = testsug(wlst, candidate, wl, ns, cpdsuggest, NULL, NULL);\\n+          if (ns == -1) return -1;\\n+       }\\n+       if ((*(loc + 1) != '|') && (*(loc + 1) != '\\\\0')) {\\n+          candidate[i] = *(loc + 1);\\n+          ns = testsug(wlst, candidate, wl, ns, cpdsuggest, NULL, NULL);\\n+          if (ns == -1) return -1;\\n+       }\\n+       loc = strchr(loc + 1, tmpc);\\n+    }\\n+    candidate[i] = tmpc;    \\n+  }\\n+  return ns;\\n+}\\n+\\n+// error is wrong char in place of correct one (case and keyboard related version)\\n+int SuggestMgr::badcharkey_utf(char ** wlst, const w_char * word, int wl, int ns, int cpdsuggest)\\n+{\\n+  w_char        tmpc;\\n+  w_char        candidate_utf[MAXSWL];\\n+  char          candidate[MAXSWUTF8L];\\n+  memcpy(candidate_utf, word, wl * sizeof(w_char));\\n+  // swap out each char one by one and try all the tryme\\n+  // chars in its place to see if that makes a good word\\n+  for (int i=0; i < wl; i++) {\\n+    tmpc = candidate_utf[i];\\n+    // check with uppercase letters\\n+    mkallcap_utf(candidate_utf + i, 1, langnum);\\n+    if (!w_char_eq(tmpc, candidate_utf[i])) {\\n+       u16_u8(candidate, MAXSWUTF8L, candidate_utf, wl);\\n+       ns = testsug(wlst, candidate, strlen(candidate), ns, cpdsuggest, NULL, NULL);\\n+       if (ns == -1) return -1;\\n+       candidate_utf[i] = tmpc;\\n+    }\\n+    // check neighbor characters in keyboard string\\n+    if (!ckey) continue;\\n+    w_char * loc = ckey_utf;\\n+    while ((loc < (ckey_utf + ckeyl)) && !w_char_eq(*loc, tmpc)) loc++;\\n+    while (loc < (ckey_utf + ckeyl)) {\\n+       if ((loc > ckey_utf) && !w_char_eq(*(loc - 1), W_VLINE)) {\\n+          candidate_utf[i] = *(loc - 1);\\n+          u16_u8(candidate, MAXSWUTF8L, candidate_utf, wl);\\n+          ns = testsug(wlst, candidate, strlen(candidate), ns, cpdsuggest, NULL, NULL);\\n+          if (ns == -1) return -1;\\n+       }\\n+       if (((loc + 1) < (ckey_utf + ckeyl)) && !w_char_eq(*(loc + 1), W_VLINE)) {\\n+          candidate_utf[i] = *(loc + 1);\\n+          u16_u8(candidate, MAXSWUTF8L, candidate_utf, wl);\\n+          ns = testsug(wlst, candidate, strlen(candidate), ns, cpdsuggest, NULL, NULL);\\n+          if (ns == -1) return -1;\\n+       }\\n+       do { loc++; } while ((loc < (ckey_utf + ckeyl)) && !w_char_eq(*loc, tmpc));\\n+    }\\n+    candidate_utf[i] = tmpc;    \\n+  }\\n+  return ns;\\n+}\\n+\\n // error is wrong char in place of correct one\\n int SuggestMgr::badchar(char ** wlst, const char * word, int ns, int cpdsuggest)\\n {\\n   char  tmpc;\\n   char  candidate[MAXSWUTF8L];\\n-  time_t timelimit = time(NULL);\\n+  clock_t timelimit = clock();\\n   int timer = MINTIMER;\\n   int wl = strlen(word);\\n   strcpy(candidate, word);\\n@@ -542,7 +678,7 @@ int SuggestMgr::badchar(char ** wlst, const char * word, int ns, int cpdsuggest)\\n        candidate[i] = ctry[j];\\n        ns = testsug(wlst, candidate, wl, ns, cpdsuggest, &timer, &timelimit);\\n        if (ns == -1) return -1;\\n-       if (!timelimit) return ns;\\n+       if (!timer) return ns;\\n        candidate[i] = tmpc;\\n     }\\n   }\\n@@ -555,7 +691,7 @@ int SuggestMgr::badchar_utf(char ** wlst, const w_char * word, int wl, int ns, i\\n   w_char        tmpc;\\n   w_char        candidate_utf[MAXSWL];\\n   char          candidate[MAXSWUTF8L];\\n-  time_t timelimit = time(NULL);\\n+  clock_t timelimit = clock();\\n   int timer = MINTIMER;  \\n   memcpy(candidate_utf, word, wl * sizeof(w_char));\\n   // swap out each char one by one and try all the tryme\\n@@ -563,12 +699,12 @@ int SuggestMgr::badchar_utf(char ** wlst, const w_char * word, int wl, int ns, i\\n   for (int i=0; i < wl; i++) {\\n     tmpc = candidate_utf[i];\\n     for (int j=0; j < ctryl; j++) {\\n-       if ((ctry_utf[j].l == tmpc.l) && (ctry_utf[j].h == tmpc.h)) continue;\\n+       if (w_char_eq(tmpc, ctry_utf[j])) continue;\\n        candidate_utf[i] = ctry_utf[j];\\n        u16_u8(candidate, MAXSWUTF8L, candidate_utf, wl);\\n        ns = testsug(wlst, candidate, strlen(candidate), ns, cpdsuggest, &timer, &timelimit);\\n        if (ns == -1) return -1;\\n-       if (!timelimit) return ns;\\n+       if (!timer) return ns;\\n        candidate_utf[i] = tmpc;\\n     }\\n   }\\n@@ -619,7 +755,7 @@ int SuggestMgr::forgotchar(char ** wlst, const char * word, int ns, int cpdsugge\\n    char candidate[MAXSWUTF8L];\\n    const char * p;\\n    char *       q;\\n-   time_t timelimit = time(NULL);\\n+   clock_t timelimit = clock();\\n    int timer = MINTIMER;\\n    int wl = strlen(word);\\n    // try inserting a tryme character before every letter\\n@@ -629,7 +765,7 @@ int SuggestMgr::forgotchar(char ** wlst, const char * word, int ns, int cpdsugge\\n          *q = ctry[i];\\n          ns = testsug(wlst, candidate, wl+1, ns, cpdsuggest, &timer, &timelimit);\\n          if (ns == -1) return -1;\\n-         if (!timelimit) return ns;\\n+         if (!timer) return ns;\\n       }\\n       *q++ = *p++;\\n    }\\n@@ -650,7 +786,7 @@ int SuggestMgr::forgotchar_utf(char ** wlst, const w_char * word, int wl, int ns\\n    const w_char * p;\\n    w_char * q;\\n    int cwrd;\\n-   time_t timelimit = time(NULL);\\n+   clock_t timelimit = clock();\\n    int timer = MINTIMER;\\n    // try inserting a tryme character before every letter\\n    memcpy (candidate_utf + 1, word, wl * sizeof(w_char));\\n@@ -661,7 +797,7 @@ int SuggestMgr::forgotchar_utf(char ** wlst, const w_char * word, int wl, int ns\\n          u16_u8(candidate, MAXSWUTF8L, candidate_utf, wl + 1);\\n          ns = testsug(wlst, candidate, strlen(candidate), ns, cpdsuggest, &timer, &timelimit);\\n          if (ns == -1) return -1;\\n-         if (!timelimit) return ns;\\n+         if (!timer) return ns;\\n        }\\n       *q++ = *p++;\\n    }\\n@@ -689,19 +825,19 @@ int SuggestMgr::twowords(char ** wlst, const char * word, int ns, int cpdsuggest\\n     int wl=strlen(word);\\n     if (wl < 3) return ns;\\n     \\n-    if (pAMgr->get_langnum() == LANG_hu) forbidden = check_forbidden(word, wl);\\n+    if (langnum == LANG_hu) forbidden = check_forbidden(word, wl);\\n \\n     strcpy(candidate + 1, word);\\n-\\n     // split the string into two pieces after every char\\n     // if both pieces are good words make them a suggestion\\n     for (p = candidate + 1;  p[1] != '\\\\0';  p++) {\\n        p[-1] = *p;\\n        // go to end of the UTF-8 character\\n        while (utf8 && ((p[1] & 0xc0) == 0x80)) {\\n+         *p = p[1];\\n          p++;\\n-         p[-1] = *p;\\n        }\\n+       if (utf8 && p[1] == '\\\\0') break; // last UTF-8 character\\n        *p = '\\\\0';\\n        c1 = checkword(candidate,strlen(candidate), cpdsuggest, NULL, NULL);\\n        if (c1) {\\n@@ -710,7 +846,7 @@ int SuggestMgr::twowords(char ** wlst, const char * word, int ns, int cpdsuggest\\n             *p = ' ';\\n \\n             // spec. Hungarian code (need a better compound word support)\\n-            if ((pAMgr->get_langnum() == LANG_hu) && !forbidden &&\\n+            if ((langnum == LANG_hu) && !forbidden &&\\n                 // if 3 repeating letter, use - instead of space\\n                 (((p[-1] == p[1]) && (((p>candidate+1) && (p[-1] == p[-2])) || (p[-1] == p[2]))) ||\\n                 // or multiple compounding, with more, than 6 syllables\\n@@ -751,6 +887,24 @@ int SuggestMgr::swapchar(char ** wlst, const char * word, int ns, int cpdsuggest\\n       p[1] = *p;\\n       *p = tmpc;\\n    }\\n+   // try double swaps for short words\\n+   // ahev -> have, owudl -> would\\n+   if (wl == 4 || wl == 5) {\\n+     candidate[0] = word[1];\\n+     candidate[1] = word[0];\\n+     candidate[2] = word[2];\\n+     candidate[wl - 2] = word[wl - 1];\\n+     candidate[wl - 1] = word[wl - 2];\\n+     ns = testsug(wlst, candidate, wl, ns, cpdsuggest, NULL, NULL);\\n+     if (ns == -1) return -1;\\n+     if (wl == 5) {\\n+        candidate[0] = word[0];\\n+        candidate[1] = word[2];\\n+        candidate[2] = word[1];\\n+        ns = testsug(wlst, candidate, wl, ns, cpdsuggest, NULL, NULL);\\n+        if (ns == -1) return -1;\\n+     }\\n+   }\\n    return ns;\\n }\\n \\n@@ -761,6 +915,7 @@ int SuggestMgr::swapchar_utf(char ** wlst, const w_char * word, int wl, int ns,\\n    char   candidate[MAXSWUTF8L];\\n    w_char * p;\\n    w_char tmpc;\\n+   int len = 0;\\n    // try swapping adjacent chars one by one\\n    memcpy (candidate_utf, word, wl * sizeof(w_char));\\n    for (p = candidate_utf;  p < (candidate_utf + wl - 1);  p++) {\\n@@ -768,11 +923,32 @@ int SuggestMgr::swapchar_utf(char ** wlst, const w_char * word, int wl, int ns,\\n       *p = p[1];\\n       p[1] = tmpc;\\n       u16_u8(candidate, MAXSWUTF8L, candidate_utf, wl);\\n-      ns = testsug(wlst, candidate, strlen(candidate), ns, cpdsuggest, NULL, NULL);\\n+      if (len == 0) len = strlen(candidate);\\n+      ns = testsug(wlst, candidate, len, ns, cpdsuggest, NULL, NULL);\\n       if (ns == -1) return -1;\\n       p[1] = *p;\\n       *p = tmpc;\\n    }\\n+   // try double swaps for short words\\n+   // ahev -> have, owudl -> would, suodn -> sound\\n+   if (wl == 4 || wl == 5) {\\n+     candidate_utf[0] = word[1];\\n+     candidate_utf[1] = word[0];\\n+     candidate_utf[2] = word[2];\\n+     candidate_utf[wl - 2] = word[wl - 1];\\n+     candidate_utf[wl - 1] = word[wl - 2];\\n+     u16_u8(candidate, MAXSWUTF8L, candidate_utf, wl);\\n+     ns = testsug(wlst, candidate, len, ns, cpdsuggest, NULL, NULL);\\n+     if (ns == -1) return -1;\\n+     if (wl == 5) {\\n+        candidate_utf[0] = word[0];\\n+        candidate_utf[1] = word[2];\\n+        candidate_utf[2] = word[1];\\n+        u16_u8(candidate, MAXSWUTF8L, candidate_utf, wl);\\n+\\tns = testsug(wlst, candidate, len, ns, cpdsuggest, NULL, NULL);\\n+        if (ns == -1) return -1;\\n+     }\\n+   }\\n    return ns;\\n }\\n \\n@@ -904,27 +1080,33 @@ int SuggestMgr::movechar_utf(char ** wlst, const w_char * word, int wl, int ns,\\n }\\n \\n // generate a set of suggestions for very poorly spelled words\\n-int SuggestMgr::ngsuggest(char** wlst, char * w, HashMgr* pHMgr)\\n+int SuggestMgr::ngsuggest(char** wlst, char * w, int ns, HashMgr* pHMgr)\\n {\\n \\n   int i, j;\\n   int lval;\\n-  int sc;\\n-  int lp;\\n+  int sc, scphon;\\n+  int lp, lpphon;\\n   int nonbmp = 0;\\n \\n-  if (!pHMgr) return 0;\\n+  if (!pHMgr) return ns;\\n \\n   // exhaustively search through all root words\\n   // keeping track of the MAX_ROOTS most similar root words\\n   struct hentry * roots[MAX_ROOTS];\\n+  char * rootsphon[MAX_ROOTS];\\n   int scores[MAX_ROOTS];\\n+  int scoresphon[MAX_ROOTS];\\n   for (i = 0; i < MAX_ROOTS; i++) {\\n     roots[i] = NULL;\\n     scores[i] = -100 * i;\\n+    rootsphon[i] = NULL;\\n+    scoresphon[i] = -100 * i;\\n   }\\n   lp = MAX_ROOTS - 1;\\n-\\n+  lpphon = MAX_ROOTS - 1;\\n+  scphon = scoresphon[MAX_ROOTS-1];\\n+  \\n   char w2[MAXWORDUTF8LEN];\\n   char * word = w;\\n \\n@@ -949,13 +1131,41 @@ int SuggestMgr::ngsuggest(char** wlst, char * w, HashMgr* pHMgr)\\n \\n   struct hentry* hp = NULL;\\n   int col = -1;\\n+  phonetable * ph = (pAMgr) ? pAMgr->get_phonetable() : NULL;\\n+  char target[MAXSWUTF8L];\\n+  char candidate[MAXSWUTF8L];\\n+  if (ph) {\\n+    strcpy(candidate, word);\\n+    mkallcap(candidate, csconv);\\n+    phonet(candidate, target, n, *ph);\\n+//    fprintf(stderr, \\\"Tip: %s->%s\\\\n\\\", candidate, target);\\n+  }\\n+  \\n   while ((hp = pHMgr->walk_hashtable(col, hp))) {\\n     if ((hp->astr) && (pAMgr) && \\n        (TESTAFF(hp->astr, pAMgr->get_forbiddenword(), hp->alen) ||\\n           TESTAFF(hp->astr, ONLYUPCASEFLAG, hp->alen) ||\\n           TESTAFF(hp->astr, pAMgr->get_nosuggest(), hp->alen) ||\\n           TESTAFF(hp->astr, pAMgr->get_onlyincompound(), hp->alen))) continue;\\n-    sc = ngram(3, word, hp->word, NGRAM_LONGER_WORSE);\\n+\\n+    sc = ngram(3, word, &(hp->word), NGRAM_LONGER_WORSE + NGRAM_LOWERING) +\\n+\\tleftcommonsubstring(word, &(hp->word));\\n+\\n+    // check special pronounciation\\n+    if (hp->var) {\\n+\\tint sc2 = ngram(3, word, &(hp->word) + hp->blen + 1, NGRAM_LONGER_WORSE + NGRAM_LOWERING) +\\n+\\tleftcommonsubstring(word, &(hp->word) + hp->blen + 1);\\n+\\tif (sc2 > sc) sc = sc2;\\n+    }\\n+    \\n+    if (ph && (sc > 2) && (abs(n - (int) hp->clen) <= 3)) {\\n+\\tchar target2[MAXSWUTF8L];\\n+        strcpy(candidate, &(hp->word));\\n+        mkallcap(candidate, csconv);\\n+        phonet(candidate, target2, -1, *ph);\\n+        scphon = 2 * ngram(3, target, target2, NGRAM_LONGER_WORSE);\\n+    }\\n+\\n     if (sc > scores[lp]) {\\n       scores[lp] = sc;  \\n       roots[lp] = hp;\\n@@ -965,7 +1175,18 @@ int SuggestMgr::ngsuggest(char** wlst, char * w, HashMgr* pHMgr)\\n           lp = j;\\n           lval = scores[j];\\n         }\\n-    }  \\n+    }\\n+\\n+    if (scphon > scoresphon[lpphon]) {\\n+      scoresphon[lpphon] = scphon;\\n+      rootsphon[lpphon] = &(hp->word);\\n+      lval = scphon;\\n+      for (j=0; j < MAX_ROOTS; j++)\\n+        if (scoresphon[j] < lval) {\\n+          lpphon = j;\\n+          lval = scoresphon[j];\\n+        }\\n+    }\\n   }\\n \\n   // find minimum threshhold for a passable suggestion\\n@@ -976,11 +1197,11 @@ int SuggestMgr::ngsuggest(char** wlst, char * w, HashMgr* pHMgr)\\n      if (utf8) {\\n        for (int k=sp; k < n; k+=4) *((unsigned short *) u8 + k) = '*';\\n        u16_u8(mw, MAXSWUTF8L, u8, n);\\n-       thresh = thresh + ngram(n, word, mw, NGRAM_ANY_MISMATCH);\\n+       thresh = thresh + ngram(n, word, mw, NGRAM_ANY_MISMATCH + NGRAM_LOWERING);\\n      } else {\\n        strcpy(mw, word);\\n        for (int k=sp; k < n; k+=4) *(mw + k) = '*';\\n-       thresh = thresh + ngram(n, word, mw, NGRAM_ANY_MISMATCH);\\n+       thresh = thresh + ngram(n, word, mw, NGRAM_ANY_MISMATCH + NGRAM_LOWERING);\\n      }\\n   }\\n   thresh = thresh / 3;\\n@@ -990,9 +1211,11 @@ int SuggestMgr::ngsuggest(char** wlst, char * w, HashMgr* pHMgr)\\n   // and use length adjusted ngram scores to select\\n   // possible suggestions\\n   char * guess[MAX_GUESS];\\n+  char * guessorig[MAX_GUESS];\\n   int gscore[MAX_GUESS];\\n   for(i=0;i<MAX_GUESS;i++) {\\n      guess[i] = NULL;\\n+     guessorig[i] = NULL;\\n      gscore[i] = -100 * i;\\n   }\\n \\n@@ -1002,31 +1225,46 @@ int SuggestMgr::ngsuggest(char** wlst, char * w, HashMgr* pHMgr)\\n   glst = (struct guessword *) calloc(MAX_WORDS,sizeof(struct guessword));\\n   if (! glst) {\\n     if (nonbmp) utf8 = 1;\\n-    return 0;\\n+    return ns;\\n   }\\n \\n   for (i = 0; i < MAX_ROOTS; i++) {\\n-\\n       if (roots[i]) {\\n         struct hentry * rp = roots[i];\\n-        int nw = pAMgr->expand_rootword(glst, MAX_WORDS, rp->word, rp->wlen,\\n-                                        rp->astr, rp->alen, word, nc);\\n+        int nw = pAMgr->expand_rootword(glst, MAX_WORDS, &(rp->word), rp->blen,\\n+            \\t    rp->astr, rp->alen, word, nc, \\n+                    ((rp->var) ? &(rp->word) + rp->blen + 1 : NULL));\\n \\n         for (int k = 0; k < nw ; k++) {\\n-           sc = ngram(n, word, glst[k].word, NGRAM_ANY_MISMATCH);\\n+           sc = ngram(n, word, glst[k].word, NGRAM_ANY_MISMATCH + NGRAM_LOWERING) +\\n+               leftcommonsubstring(word, glst[k].word);\\n+\\n            if ((sc > thresh)) {\\n               if (sc > gscore[lp]) {\\n-                 if (guess[lp]) free (guess[lp]);\\n+                 if (guess[lp]) {\\n+                    free (guess[lp]);\\n+                    if (guessorig[lp]) {\\n+                \\tfree(guessorig[lp]);\\n+                \\tguessorig[lp] = NULL;\\n+            \\t    }\\n+                 }\\n                  gscore[lp] = sc;\\n                  guess[lp] = glst[k].word;\\n+                 guessorig[lp] = glst[k].orig;\\n                  lval = sc;\\n                  for (j=0; j < MAX_GUESS; j++)\\n                     if (gscore[j] < lval) {\\n                        lp = j;\\n                        lval = gscore[j];\\n                     }\\n-              } else free (glst[k].word);  \\n-           } else free(glst[k].word);\\n+              } else { \\n+                free(glst[k].word);\\n+                if (glst[k].orig) free(glst[k].orig);\\n+              }\\n+           } else {\\n+        \\tfree(glst[k].word);\\n+                if (glst[k].orig) free(glst[k].orig);\\n+           }\\n         }\\n       }\\n   }\\n@@ -1035,7 +1273,9 @@ int SuggestMgr::ngsuggest(char** wlst, char * w, HashMgr* pHMgr)\\n   // now we are done generating guesses\\n   // sort in order of decreasing score\\n   \\n-  bubblesort(&guess[0], &gscore[0], MAX_GUESS);\\n+  \\n+  bubblesort(&guess[0], &guessorig[0], &gscore[0], MAX_GUESS);\\n+  if (ph) bubblesort(&rootsphon[0], NULL, &scoresphon[0], MAX_ROOTS);\\n \\n   // weight suggestions with a similarity index, based on\\n   // the longest common subsequent algorithm and resort\\n@@ -1049,7 +1289,7 @@ int SuggestMgr::ngsuggest(char** wlst, char * w, HashMgr* pHMgr)\\n         if (utf8) {\\n           w_char _w[MAXSWL];\\n           len = u8_u16(_w, MAXSWL, guess[i]);\\n-          mkallsmall_utf(_w, len, pAMgr->get_langnum());\\n+          mkallsmall_utf(_w, len, langnum);\\n           u16_u8(gl, MAXSWUTF8L, _w, len);\\n         } else {\\n           strcpy(gl, guess[i]);\\n@@ -1067,10 +1307,10 @@ int SuggestMgr::ngsuggest(char** wlst, char * w, HashMgr* pHMgr)\\n         \\n         // heuristic weigthing of ngram scores\\n         gscore[i] +=\\n-          // length of longest common subsequent minus lenght difference\\n+          // length of longest common subsequent minus length difference\\n           2 * _lcs - abs((int) (n - len)) +\\n-          // weight equal first letter\\n-          equalfirstletter(word, gl) +\\n+          // weight length of the left common substring\\n+          leftcommonsubstring(word, gl) +\\n           // weight equal character positions\\n           ((_lcs == commoncharacterpositions(word, gl, &is_swap)) ? 1: 0) +\\n           // swap character (not neighboring)\\n@@ -1078,25 +1318,81 @@ int SuggestMgr::ngsuggest(char** wlst, char * w, HashMgr* pHMgr)\\n       }\\n   }\\n \\n-  bubblesort(&guess[0], &gscore[0], MAX_GUESS);\\n+  bubblesort(&guess[0], &guessorig[0], &gscore[0], MAX_GUESS);\\n+\\n+// phonetic version\\n+  if (ph) for (i=0; i < MAX_ROOTS; i++) {\\n+      if (rootsphon[i]) {\\n+        // lowering rootphon[i]\\n+        char gl[MAXSWUTF8L];\\n+        int len;\\n+        if (utf8) {\\n+          w_char _w[MAXSWL];\\n+          len = u8_u16(_w, MAXSWL, rootsphon[i]);\\n+          mkallsmall_utf(_w, len, langnum);\\n+          u16_u8(gl, MAXSWUTF8L, _w, len);\\n+        } else {\\n+          strcpy(gl, rootsphon[i]);\\n+          mkallsmall(gl, csconv);\\n+          len = strlen(rootsphon[i]);\\n+        }\\n+\\n+        // heuristic weigthing of ngram scores\\n+        scoresphon[i] += 2 * lcslen(word, gl) - abs((int) (n - len)) +\\n+          // weight length of the left common substring\\n+          leftcommonsubstring(word, gl);\\n+      }\\n+  }\\n+\\n+  if (ph) bubblesort(&rootsphon[0], NULL, &scoresphon[0], MAX_ROOTS);\\n \\n   // copy over\\n+  int oldns = ns;\\n \\n-  int ns = 0;\\n   int same = 0;\\n   for (i=0; i < MAX_GUESS; i++) {\\n     if (guess[i]) {\\n-      if ((ns < maxngramsugs) && (ns < maxSug) && (!same || (gscore[i] > 1000))) {\\n+      if ((ns < oldns + maxngramsugs) && (ns < maxSug) && (!same || (gscore[i] > 1000))) {\\n         int unique = 1;\\n-        // we have excellent suggestion(s)\\n+        // leave only excellent suggestions, if exists\\n         if (gscore[i] > 1000) same = 1;\\n-        for (j=0; j < ns; j++)\\n+        for (j = 0; j < ns; j++) {\\n           // don't suggest previous suggestions or a previous suggestion with prefixes or affixes\\n-          if (strstr(guess[i], wlst[j]) || \\n+          if ((!guessorig[i] && strstr(guess[i], wlst[j])) ||\\n+\\t     (guessorig[i] && strstr(guessorig[i], wlst[j])) ||\\n             // check forbidden words\\n             !checkword(guess[i], strlen(guess[i]), 0, NULL, NULL)) unique = 0;\\n-        if (unique) wlst[ns++] = guess[i]; else free(guess[i]);\\n-      } else free(guess[i]);\\n+        }\\n+        if (unique) {\\n+    \\t    wlst[ns++] = guess[i];\\n+    \\t    if (guessorig[i]) {\\n+    \\t\\tfree(guess[i]);\\n+    \\t\\twlst[ns-1] = guessorig[i];\\n+    \\t    }\\n+    \\t} else {\\n+    \\t    free(guess[i]);\\n+    \\t    if (guessorig[i]) free(guessorig[i]);\\n+    \\t}\\n+      } else {\\n+        free(guess[i]);\\n+    \\tif (guessorig[i]) free(guessorig[i]);\\n+      }\\n+    }\\n+  }\\n+\\n+  oldns = ns;\\n+  if (ph) for (i=0; i < MAX_ROOTS; i++) {\\n+    if (rootsphon[i]) {\\n+      if ((ns < oldns + MAXPHONSUGS) && (ns < maxSug)) {\\n+        int unique = 1;\\n+        for (j = 0; j < ns; j++) {\\n+          // don't suggest previous suggestions or a previous suggestion with prefixes or affixes\\n+          if (strstr(rootsphon[i], wlst[j]) || \\n+            // check forbidden words\\n+            !checkword(rootsphon[i], strlen(rootsphon[i]), 0, NULL, NULL)) unique = 0;\\n+        }\\n+        if (unique) wlst[ns++] = mystrdup(rootsphon[i]);\\n+      }\\n     }\\n   }\\n \\n@@ -1111,19 +1407,16 @@ int SuggestMgr::ngsuggest(char** wlst, char * w, HashMgr* pHMgr)\\n // obsolote MySpell-HU modifications:\\n // return value 2 and 3 marks compounding with hyphen (-)\\n // `3' marks roots without suffix\\n-int SuggestMgr::checkword(const char * word, int len, int cpdsuggest, int * timer, time_t * timelimit)\\n+int SuggestMgr::checkword(const char * word, int len, int cpdsuggest, int * timer, clock_t * timelimit)\\n {\\n   struct hentry * rv=NULL;\\n   int nosuffix = 0;\\n-  \\n+\\n   // check time limit\\n   if (timer) {\\n     (*timer)--;\\n     if (!(*timer) && timelimit) {\\n-      if (time(NULL) > *timelimit) {\\n-        *timelimit = 0;\\n-        return 0;\\n-      }\\n+      if ((clock() - *timelimit) > TIMELIMIT) return 0;\\n       *timer = MAXPLUSTIMER;\\n     }\\n   }\\n@@ -1482,7 +1775,7 @@ char * SuggestMgr::suggest_morph_for_spelling_error(const char * word)\\n \\n \\n // generate an n-gram score comparing s1 and s2\\n-int SuggestMgr::ngram(int n, char * s1, const char * s2, int uselen)\\n+int SuggestMgr::ngram(int n, char * s1, const char * s2, int opt)\\n {\\n   int nscore = 0;\\n   int ns;\\n@@ -1494,9 +1787,9 @@ int SuggestMgr::ngram(int n, char * s1, const char * s2, int uselen)\\n     w_char su2[MAXSWL];\\n     l1 = u8_u16(su1, MAXSWL, s1);\\n     l2 = u8_u16(su2, MAXSWL, s2);\\n-    if (!l2 || (l1==-1) || (l2==-1)) return 0;\\n+    if ((l2 <= 0) || (l1 == -1)) return 0;\\n     // lowering dictionary word\\n-    mkallsmall_utf(su2, l2, pAMgr->get_langnum());\\n+    if (opt & NGRAM_LOWERING) mkallsmall_utf(su2, l2, langnum);\\n     for (int j = 1; j <= n; j++) {\\n       ns = 0;\\n       for (int i = 0; i <= (l1-j); i++) {\\n@@ -1520,9 +1813,9 @@ int SuggestMgr::ngram(int n, char * s1, const char * s2, int uselen)\\n     char t[MAXSWUTF8L];\\n     l1 = strlen(s1);\\n     l2 = strlen(s2);\\n-    if (!l2) return 0;\\n+    if (l2 == 0) return 0;\\n     strcpy(t, s2);\\n-    mkallsmall(t, csconv);\\n+    if (opt & NGRAM_LOWERING) mkallsmall(t, csconv);\\n     for (int j = 1; j <= n; j++) {\\n       ns = 0;\\n       for (int i = 0; i <= (l1-j); i++) {\\n@@ -1537,13 +1830,14 @@ int SuggestMgr::ngram(int n, char * s1, const char * s2, int uselen)\\n   }\\n   \\n   ns = 0;\\n-  if (uselen == NGRAM_LONGER_WORSE) ns = (l2-l1)-2;\\n-  if (uselen == NGRAM_ANY_MISMATCH) ns = abs(l2-l1)-2;\\n+  if (opt & NGRAM_LONGER_WORSE) ns = (l2-l1)-2;\\n+  if (opt & NGRAM_ANY_MISMATCH) ns = abs(l2-l1)-2;\\n   ns = (nscore - ((ns > 0) ? ns : 0));\\n   return ns;\\n }\\n \\n-int SuggestMgr::equalfirstletter(char * s1, const char * s2) {\\n+// length of the left common substring of s1 and (decapitalised) s2\\n+int SuggestMgr::leftcommonsubstring(char * s1, const char * s2) {\\n   if (utf8) {\\n     w_char su1[MAXSWL];\\n     w_char su2[MAXSWL];\\n@@ -1553,9 +1847,17 @@ int SuggestMgr::equalfirstletter(char * s1, const char * s2) {\\n       int l2 = u8_u16(su2, MAXSWL, s2);\\n       if (*((short *)su1+l1-1) == *((short *)su2+l2-1)) return 1;\\n     } else {\\n+      int i;\\n       u8_u16(su1, 1, s1);\\n       u8_u16(su2, 1, s2);\\n-      if (*((short *)su1) == *((short *)su2)) return 1;\\n+      unsigned short idx = (su2->h << 8) + su2->l;\\n+      if (*((short *)su1) != *((short *)su2) &&\\n+         (*((unsigned short *)su1) != unicodetolower(idx, langnum))) return 0;\\n+      int l1 = u8_u16(su1, MAXSWL, s1);\\n+      int l2 = u8_u16(su2, MAXSWL, s2);\\n+      for(i = 1; (i < l1) && (i < l2) &&\\n+         (*((short *)(su1 + i)) == *((short *)(su2 + i))); i++);\\n+      return i;\\n     }\\n   } else {\\n     if (complexprefixes) {\\n@@ -1563,7 +1865,13 @@ int SuggestMgr::equalfirstletter(char * s1, const char * s2) {\\n       int l2 = strlen(s2);\\n       if (*(s2+l1-1) == *(s2+l2-1)) return 1;\\n     } else {\\n-      if (*s1 == *s2) return 1;\\n+      char * olds = s1;\\n+      // decapitalise dictionary word\\n+      if ((*s1 != *s2) && (*s1 != csconv[((unsigned char)*s2)].clower)) return 0;\\n+      do {\\n+        s1++; s2++;\\n+      } while ((*s1 == *s2) && (*s1 != '\\\\0'));\\n+      return s1 - olds;\\n     }\\n   }\\n   return 0;\\n@@ -1581,9 +1889,9 @@ int SuggestMgr::commoncharacterpositions(char * s1, const char * s2, int * is_sw\\n     int l2 = u8_u16(su2, MAXSWL, s2);\\n     // decapitalize dictionary word\\n     if (complexprefixes) {\\n-      mkallsmall_utf(su2+l2-1, 1, pAMgr->get_langnum());\\n+      mkallsmall_utf(su2+l2-1, 1, langnum);\\n     } else {\\n-      mkallsmall_utf(su2, 1, pAMgr->get_langnum());\\n+      mkallsmall_utf(su2, 1, langnum);\\n     }\\n     for (int i = 0; (i < l1) && (i < l2); i++) {\\n       if (((short *) su1)[i] == ((short *) su2)[i]) {\\n@@ -1630,7 +1938,7 @@ int SuggestMgr::mystrlen(const char * word) {\\n }\\n \\n // sort in decreasing order of score\\n-void SuggestMgr::bubblesort(char** rword, int* rsc, int n )\\n+void SuggestMgr::bubblesort(char** rword, char** rword2, int* rsc, int n )\\n {\\n       int m = 1;\\n       while (m < n) {\\n@@ -1643,6 +1951,11 @@ void SuggestMgr::bubblesort(char** rword, int* rsc, int n )\\n                 rword[j-1] = rword[j];\\n                 rsc[j] = sctmp;\\n                 rword[j] = wdtmp;\\n+                if (rword2) {\\n+            \\t    wdtmp = rword2[j-1];\\n+            \\t    rword2[j-1] = rword2[j];\\n+            \\t    rword2[j] = wdtmp;\\n+                }\\n                 j--;\\n             } else break;\\n           }\\ndiff --git a/extensions/spellcheck/hunspell/src/suggestmgr.hxx b/extensions/spellcheck/hunspell/src/suggestmgr.hxx\\nindex e7561dc..2265f94 100644\\n--- a/extensions/spellcheck/hunspell/src/suggestmgr.hxx\\n+++ b/extensions/spellcheck/hunspell/src/suggestmgr.hxx\\n@@ -61,15 +61,18 @@\\n #define MAXSWUTF8L (MAXSWL * 4)\\n #define MAX_ROOTS 100\\n #define MAX_WORDS 100\\n-#define MAX_GUESS 100\\n-#define MAXNGRAMSUGS 5\\n+#define MAX_GUESS 200\\n+#define MAXNGRAMSUGS 4\\n+#define MAXPHONSUGS 2\\n \\n-#define MINTIMER 500\\n-#define MAXPLUSTIMER 500\\n+// timelimit: max ~1/4 sec (process time on Linux) for a time consuming function\\n+#define TIMELIMIT (CLOCKS_PER_SEC >> 2)\\n+#define MINTIMER 100\\n+#define MAXPLUSTIMER 100\\n \\n-#define NGRAM_IGNORE_LENGTH 0\\n-#define NGRAM_LONGER_WORSE  1\\n-#define NGRAM_ANY_MISMATCH  2\\n+#define NGRAM_LONGER_WORSE  (1 << 0)\\n+#define NGRAM_ANY_MISMATCH  (1 << 1)\\n+#define NGRAM_LOWERING      (1 << 2)\\n \\n #include \\\"atypes.hxx\\\"\\n #include \\\"affixmgr.hxx\\\"\\n@@ -81,6 +84,10 @@ enum { LCS_UP, LCS_LEFT, LCS_UPLEFT };\\n \\n class SuggestMgr\\n {\\n+  char *          ckey;\\n+  int             ckeyl;\\n+  w_char *        ckey_utf;\\n+\\n   char *          ctry;\\n   int             ctryl;\\n   w_char *        ctry_utf;\\n@@ -89,6 +96,7 @@ class SuggestMgr\\n   int             maxSug;\\n   struct cs_info * csconv;\\n   int             utf8;\\n+  int             langnum;\\n   int             nosplitsugs;\\n   int             maxngramsugs;\\n   int             complexprefixes;\\n@@ -98,8 +106,8 @@ public:\\n   SuggestMgr(const char * tryme, int maxn, AffixMgr *aptr);\\n   ~SuggestMgr();\\n \\n-  int suggest(char*** slst, const char * word, int nsug);\\n-  int ngsuggest(char ** wlst, char * word, HashMgr* pHMgr);\\n+  int suggest(char*** slst, const char * word, int nsug, int * onlycmpdsug);\\n+  int ngsuggest(char ** wlst, char * word, int ns, HashMgr* pHMgr);\\n   int suggest_auto(char*** slst, const char * word, int nsug);\\n   int suggest_stems(char*** slst, const char * word, int nsug);\\n   int suggest_pos_stems(char*** slst, const char * word, int nsug);\\n@@ -109,8 +117,8 @@ public:\\n \\n private:\\n    int testsug(char** wlst, const char * candidate, int wl, int ns, int cpdsuggest,\\n-     int * timer, time_t * timelimit);\\n-   int checkword(const char *, int, int, int *, time_t *);\\n+     int * timer, clock_t * timelimit);\\n+   int checkword(const char *, int, int, int *, clock_t *);\\n    int check_forbidden(const char *, int);\\n \\n    int capchars(char **, const char *, int, int);\\n@@ -121,6 +129,7 @@ private:\\n    int longswapchar(char **, const char *, int, int);\\n    int movechar(char **, const char *, int, int);\\n    int extrachar(char **, const char *, int, int);\\n+   int badcharkey(char **, const char *, int, int);\\n    int badchar(char **, const char *, int, int);\\n    int twowords(char **, const char *, int, int);\\n    int fixstems(char **, const char *, int);\\n@@ -129,23 +138,23 @@ private:\\n    int doubletwochars_utf(char**, const w_char *, int wl, int, int);\\n    int forgotchar_utf(char**, const w_char *, int wl, int, int);\\n    int extrachar_utf(char**, const w_char *, int wl, int, int);\\n+   int badcharkey_utf(char **, const w_char *, int wl, int, int);\\n    int badchar_utf(char **, const w_char *, int wl, int, int);\\n    int swapchar_utf(char **, const w_char *, int wl, int, int);\\n    int longswapchar_utf(char **, const w_char *, int, int, int);\\n    int movechar_utf(char **, const w_char *, int, int, int);\\n \\n-   int mapchars(char**, const char *, int);\\n-   int map_related(const char *, int, char ** wlst, int, const mapentry*, int, int *, time_t *);\\n-   int map_related_utf(w_char *, int, int, char ** wlst, int, const mapentry*, int, int *, time_t *);\\n-   int ngram(int n, char * s1, const char * s2, int uselen);\\n+   int mapchars(char**, const char *, int, int);\\n+   int map_related(const char *, int, char ** wlst, int, int, const mapentry*, int, int *, clock_t *);\\n+   int map_related_utf(w_char *, int, int, int, char ** wlst, int, const mapentry*, int, int *, clock_t *);\\n+   int ngram(int n, char * s1, const char * s2, int opt);\\n    int mystrlen(const char * word);\\n-   int equalfirstletter(char * s1, const char * s2);\\n+   int leftcommonsubstring(char * s1, const char * s2);\\n    int commoncharacterpositions(char * s1, const char * s2, int * is_swap);\\n-   void bubblesort( char ** rwd, int * rsc, int n);\\n+   void bubblesort( char ** rwd, char ** rwd2, int * rsc, int n);\\n    void lcs(const char * s, const char * s2, int * l1, int * l2, char ** result);\\n    int lcslen(const char * s, const char* s2);\\n \\n };\\n \\n #endif\\n-\\n\""}