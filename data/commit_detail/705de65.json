{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas705de65\""},"diff":"\"705de65 Bug 392089 - JPEG decoding: Prevent allocation of scanline and remove memcpy p=Alfred Kayser <alfredkayser@nl.ibm.com> r=stuart, sr=tor, a=stuart\\ndiff --git a/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.cpp b/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.cpp\\nindex 16b9fd8..0a16c4b 100644\\n--- a/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.cpp\\n+++ b/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.cpp\\n@@ -83,8 +83,6 @@ nsJPEGDecoder::nsJPEGDecoder()\\n   mState = JPEG_HEADER;\\n   mReading = PR_TRUE;\\n \\n-  mSamples = nsnull;\\n-\\n   mBytesToSkip = 0;\\n   memset(&mInfo, 0, sizeof(jpeg_decompress_struct));\\n   memset(&mSourceMgr, 0, sizeof(mSourceMgr));\\n@@ -419,22 +417,6 @@ NS_IMETHODIMP nsJPEGDecoder::WriteFrom(nsIInputStream *inStr, PRUint32 count, PR\\n     }      \\n \\n     mObserver->OnStartFrame(nsnull, mFrame);\\n-\\n-    /*\\n-     * Make a one-row-high sample array that will go away\\n-     * when done with image. Always make it big enough to\\n-     * hold an RGB row.  Since this uses the IJG memory\\n-     * manager, it must be allocated before the call to\\n-     * jpeg_start_compress().\\n-     */\\n-    /* \\n-     * From: http://apodeline.free.fr/DOC/libjpeg/libjpeg-2.html#ss2.3 :\\n-     * PLEASE NOTE THAT RGB DATA IS THREE SAMPLES PER PIXEL, GRAYSCALE ONLY ONE\\n-     */\\n-    mSamples = (*mInfo.mem->alloc_sarray)((j_common_ptr) &mInfo,\\n-                                          JPOOL_IMAGE,\\n-                                          mInfo.output_width * 3, 1);\\n-\\n     mState = JPEG_START_DECOMPRESS;\\n   }\\n \\n@@ -580,42 +562,40 @@ nsJPEGDecoder::OutputScanlines()\\n \\n   while ((mInfo.output_scanline < mInfo.output_height)) {\\n       /* Request one scanline.  Returns 0 or 1 scanlines. */    \\n-      if (jpeg_read_scanlines(&mInfo, mSamples, 1) != 1) {\\n+      PRUint32 *imageRow = ((PRUint32*)imageData) +\\n+                           (mInfo.output_scanline * mInfo.output_width);\\n+\\n+      /* Use the Cairo image buffer as scanline buffer */\\n+      JSAMPROW sampleRow = (JSAMPROW)imageRow;\\n+      if (!mTransform || mInfo.out_color_space != JCS_GRAYSCALE) {\\n+        /* Put the pixels at end of row to enable in-place expansion */\\n+        sampleRow += mInfo.output_width;\\n+      }\\n+\\n+      if (jpeg_read_scanlines(&mInfo, &sampleRow, 1) != 1) {\\n         rv = PR_FALSE; /* suspend */\\n         break;\\n       }\\n \\n       if (mTransform) {\\n+        JSAMPROW source = sampleRow;\\n         if (mInfo.out_color_space == JCS_GRAYSCALE) {\\n-          /* move gray data to end of mSample array so\\n-             cmsDoTransform can do in-place transform */\\n-          memcpy(mSamples[0] + 2 * mInfo.output_width,\\n-                 mSamples[0],\\n-                 mInfo.output_width);\\n-          cmsDoTransform(mTransform,\\n-                         mSamples[0] + 2 * mInfo.output_width, mSamples[0],\\n-                         mInfo.output_width);\\n-        } else\\n-          cmsDoTransform(mTransform,\\n-                         mSamples[0], mSamples[0],\\n-                         mInfo.output_width);\\n+          /* Convert from the 1byte grey pixels at begin of row \\n+             to the 3byte RGB byte pixels at 'end' of row */\\n+          sampleRow += mInfo.output_width;\\n+        }\\n+        cmsDoTransform(mTransform, source, sampleRow, mInfo.output_width);\\n       } else if (gfxPlatform::IsCMSEnabled()) {\\n         /* No embedded ICC profile - treat as sRGB */\\n         cmsHTRANSFORM transform = gfxPlatform::GetCMSRGBTransform();\\n         if (transform) {\\n-          cmsDoTransform(transform,\\n-                         mSamples[0], mSamples[0],\\n-                         mInfo.output_width);\\n+          cmsDoTransform(transform, sampleRow, sampleRow, mInfo.output_width);\\n         }\\n       }\\n \\n-      // offset is in Cairo pixels (PRUint32)\\n-      PRUint32 offset = (mInfo.output_scanline - 1) * mInfo.output_width;\\n-      PRUint32 *ptrOutputBuf = ((PRUint32*)imageData) + offset;\\n-      JSAMPLE *j1 = mSamples[0];\\n       for (PRUint32 i=mInfo.output_width; i>0; --i) {\\n-        *ptrOutputBuf++ = GFX_PACKED_PIXEL(0xFF, j1[0], j1[1], j1[2]);\\n-        j1+=3;\\n+        *imageRow++ = GFX_PACKED_PIXEL(0xFF, sampleRow[0], sampleRow[1], sampleRow[2]);\\n+        sampleRow += 3;\\n       }\\n   }\\n \\ndiff --git a/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.h b/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.h\\nindex 83bb818..d4f960d 100644\\n--- a/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.h\\n+++ b/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.h\\n@@ -106,8 +106,6 @@ public:\\n   decoder_error_mgr mErr;\\n   jstate mState;\\n \\n-  JSAMPARRAY mSamples;\\n-\\n   PRUint32 mBytesToSkip;\\n \\n   JOCTET *mBuffer;\\n\""}