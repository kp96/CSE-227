{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas6655e6e\""},"diff":"\"6655e6e Bug 384524: Passwords still filled in on web sites after logged out of Software Security Device. r=gavin\\ndiff --git a/toolkit/components/passwordmgr/src/storage-Legacy.js b/toolkit/components/passwordmgr/src/storage-Legacy.js\\nindex 425414e..3421861 100644\\n--- a/toolkit/components/passwordmgr/src/storage-Legacy.js\\n+++ b/toolkit/components/passwordmgr/src/storage-Legacy.js\\n@@ -206,11 +206,21 @@ LoginManagerStorage_legacy.prototype = {\\n             throw \\\"No logins found for hostname (\\\" + key + \\\")\\\";\\n \\n         // The specified login isn't encrypted, so we need to ensure\\n-        // the logins we're comparing with are decrypted.\\n-        this._decryptLogins(logins);\\n-\\n+        // the logins we're comparing with are decrypted. We decrypt one entry\\n+        // at a time, lest _decryptLogins return fewer entries and screw up\\n+        // indicies between the two.\\n         for (var i = 0; i < logins.length; i++) {\\n-            if (logins[i].equals(login)) {\\n+\\n+            var [[decryptedLogin], userCanceled] =\\n+                        this._decryptLogins([logins[i]]);\\n+\\n+            if (userCanceled)\\n+                return;\\n+\\n+            if (!decryptedLogin)\\n+                continue;\\n+\\n+            if (decryptedLogin.equals(login)) {\\n                 logins.splice(i, 1); // delete that login from array.\\n                 break;\\n                 // Note that if there are duplicate entries, they'll\\n@@ -703,16 +713,16 @@ LoginManagerStorage_legacy.prototype = {\\n         var result = [], userCanceled = false;\\n \\n         for each (var login in logins) {\\n-            if (!login.username)\\n-                [login.username, userCanceled] =\\n-                    this._decrypt(login.wrappedJSObject.encryptedUsername);\\n+            var username, password;\\n+\\n+            [username, userCanceled] =\\n+                this._decrypt(login.wrappedJSObject.encryptedUsername);\\n \\n             if (userCanceled)\\n                 break;\\n \\n-            if (!login.password)\\n-                [login.password, userCanceled] =\\n-                    this._decrypt(login.wrappedJSObject.encryptedPassword);\\n+            [password, userCanceled] =\\n+                this._decrypt(login.wrappedJSObject.encryptedPassword);\\n \\n             // Probably can't hit this case, but for completeness...\\n             if (userCanceled)\\n@@ -720,9 +730,16 @@ LoginManagerStorage_legacy.prototype = {\\n \\n             // If decryption failed (corrupt entry?) skip it.\\n             // XXX remove it from the original list entirely?\\n-            if (!login.username || !login.password)\\n+            if (!username || !password)\\n                 continue;\\n \\n+            // We could set the decrypted values on a copy of the object, to\\n+            // try to prevent the decrypted values from sitting around in\\n+            // memory if they're not needed. But thanks to GC that's happening\\n+            // anyway, so meh.\\n+            login.username = username;\\n+            login.password = password;\\n+\\n             // Force any old mime64-obscured entries to be reencrypted.\\n             if (login.wrappedJSObject.encryptedUsername &&\\n                 login.wrappedJSObject.encryptedUsername.charAt(0) == '~')\\n\""}