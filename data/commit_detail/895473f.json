{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas895473f\""},"diff":"\"895473f Bug 394442, Optimize ID, class and style getters, r=bz+sicking, sr=sicking, a=jst\\ndiff --git a/content/base/public/nsINode.h b/content/base/public/nsINode.h\\nindex 87f7a36..30f74fc 100644\\n--- a/content/base/public/nsINode.h\\n+++ b/content/base/public/nsINode.h\\n@@ -92,8 +92,14 @@ enum {\\n \\n   NODE_IS_EDITABLE =             0x00000100U,\\n \\n+  // Optimizations to quickly check whether element may have ID, class or style\\n+  // attributes. Not all element implementations may use these!\\n+  NODE_MAY_HAVE_ID =             0x00000200U,\\n+  NODE_MAY_HAVE_CLASS =          0x00000400U,\\n+  NODE_MAY_HAVE_STYLE =          0x00000800U,\\n+\\n   // Four bits for the script-type ID\\n-  NODE_SCRIPT_TYPE_OFFSET =                9,\\n+  NODE_SCRIPT_TYPE_OFFSET =               12,\\n \\n   NODE_SCRIPT_TYPE_SIZE =                  4,\\n \\ndiff --git a/content/base/src/nsGenericElement.cpp b/content/base/src/nsGenericElement.cpp\\nindex bba8b49..fcc0296 100644\\n--- a/content/base/src/nsGenericElement.cpp\\n+++ b/content/base/src/nsGenericElement.cpp\\n@@ -2268,6 +2268,10 @@ nsGenericElement::DispatchDOMEvent(nsEvent* aEvent,\\n nsIAtom*\\n nsGenericElement::GetID() const\\n {\\n+  if (!HasFlag(NODE_MAY_HAVE_ID)) {\\n+    return nsnull;\\n+  }\\n+\\n   nsIAtom* IDName = GetIDAttributeName();\\n   if (IDName) {\\n     const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(IDName);\\n@@ -3683,6 +3687,7 @@ nsGenericElement::ParseAttribute(PRInt32 aNamespaceID,\\n {\\n   if (aNamespaceID == kNameSpaceID_None &&\\n       aAttribute == GetIDAttributeName() && !aValue.IsEmpty()) {\\n+    SetFlags(NODE_MAY_HAVE_ID);\\n     // Store id as an atom.  id=\\\"\\\" means that the element has no id,\\n     // not that it has an emptystring as the id.\\n     aResult.ParseAtom(aValue);\\ndiff --git a/content/base/src/nsStyledElement.cpp b/content/base/src/nsStyledElement.cpp\\nindex 454fdbf..e519860 100644\\n--- a/content/base/src/nsStyledElement.cpp\\n+++ b/content/base/src/nsStyledElement.cpp\\n@@ -73,6 +73,9 @@ nsStyledElement::GetIDAttributeName() const\\n const nsAttrValue*\\n nsStyledElement::GetClasses() const\\n {\\n+  if (!HasFlag(NODE_MAY_HAVE_CLASS)) {\\n+    return nsnull;\\n+  }\\n   return mAttrsAndChildren.GetAttr(nsGkAtoms::_class);\\n }\\n \\n@@ -82,10 +85,12 @@ nsStyledElement::ParseAttribute(PRInt32 aNamespaceID, nsIAtom* aAttribute,\\n {\\n   if (aNamespaceID == kNameSpaceID_None) {\\n     if (aAttribute == nsGkAtoms::style) {\\n+      SetFlags(NODE_MAY_HAVE_STYLE);\\n       ParseStyleAttribute(this, aValue, aResult);\\n       return PR_TRUE;\\n     }\\n     if (aAttribute == nsGkAtoms::_class) {\\n+      SetFlags(NODE_MAY_HAVE_CLASS);\\n #ifdef MOZ_SVG\\n       NS_ASSERTION(!nsCOMPtr<nsIDOMSVGStylable>(do_QueryInterface(this)),\\n                    \\\"SVG code should have handled this 'class' attribute!\\\");\\n@@ -102,6 +107,7 @@ nsStyledElement::ParseAttribute(PRInt32 aNamespaceID, nsIAtom* aAttribute,\\n NS_IMETHODIMP\\n nsStyledElement::SetInlineStyleRule(nsICSSStyleRule* aStyleRule, PRBool aNotify)\\n {\\n+  SetFlags(NODE_MAY_HAVE_STYLE);\\n   PRBool modification = PR_FALSE;\\n   nsAutoString oldValueStr;\\n \\n@@ -135,6 +141,9 @@ nsStyledElement::SetInlineStyleRule(nsICSSStyleRule* aStyleRule, PRBool aNotify)\\n nsICSSStyleRule*\\n nsStyledElement::GetInlineStyleRule()\\n {\\n+  if (!HasFlag(NODE_MAY_HAVE_STYLE)) {\\n+    return nsnull;\\n+  }\\n   const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(nsGkAtoms::style);\\n \\n   if (attrVal && attrVal->Type() == nsAttrValue::eCSSStyleRule) {\\n@@ -186,6 +195,7 @@ nsStyledElement::GetStyle(nsIDOMCSSStyleDeclaration** aStyle)\\n     rv = gCSSOMFactory->CreateDOMCSSAttributeDeclaration(this,\\n                                                  getter_AddRefs(slots->mStyle));\\n     NS_ENSURE_SUCCESS(rv, rv);\\n+    SetFlags(NODE_MAY_HAVE_STYLE);\\n   }\\n \\n   // Why bother with QI?\\n@@ -196,6 +206,9 @@ nsStyledElement::GetStyle(nsIDOMCSSStyleDeclaration** aStyle)\\n nsresult\\n nsStyledElement::ReparseStyleAttribute()\\n {\\n+  if (!HasFlag(NODE_MAY_HAVE_STYLE)) {\\n+    return NS_OK;\\n+  }\\n   const nsAttrValue* oldVal = mAttrsAndChildren.GetAttr(nsGkAtoms::style);\\n   \\n   if (oldVal && oldVal->Type() != nsAttrValue::eCSSStyleRule) {\\ndiff --git a/content/xul/content/src/nsXULElement.cpp b/content/xul/content/src/nsXULElement.cpp\\nindex 7ff8297..cfab65c 100644\\n--- a/content/xul/content/src/nsXULElement.cpp\\n+++ b/content/xul/content/src/nsXULElement.cpp\\n@@ -275,6 +275,15 @@ nsXULElement::Create(nsXULPrototypeElement* aPrototype, nsINodeInfo *aNodeInfo,\\n         NS_ADDREF(element);\\n \\n         element->mPrototype = aPrototype;\\n+        if (aPrototype->mHasIdAttribute) {\\n+            element->SetFlags(NODE_MAY_HAVE_ID);\\n+        }\\n+        if (aPrototype->mHasClassAttribute) {\\n+            element->SetFlags(NODE_MAY_HAVE_CLASS);\\n+        }\\n+        if (aPrototype->mHasStyleAttribute) {\\n+            element->SetFlags(NODE_MAY_HAVE_STYLE);\\n+        }\\n \\n         NS_ASSERTION(aPrototype->mScriptTypeID != nsIProgrammingLanguage::UNKNOWN,\\n                     \\\"Need to know the language!\\\");\\n@@ -1069,11 +1078,13 @@ nsXULElement::ParseAttribute(PRInt32 aNamespaceID,\\n     // Any changes should be made to both functions.\\n     if (aNamespaceID == kNameSpaceID_None) {\\n         if (aAttribute == nsGkAtoms::style) {\\n+            SetFlags(NODE_MAY_HAVE_STYLE);\\n             nsStyledElement::ParseStyleAttribute(this, aValue, aResult);\\n             return PR_TRUE;\\n         }\\n \\n         if (aAttribute == nsGkAtoms::_class) {\\n+            SetFlags(NODE_MAY_HAVE_CLASS);\\n             aResult.ParseAtomArray(aValue);\\n             return PR_TRUE;\\n         }\\n@@ -1632,6 +1643,10 @@ nsXULElement::InsertChildAt(nsIContent* aKid, PRUint32 aIndex, PRBool aNotify)\\n nsIAtom*\\n nsXULElement::GetID() const\\n {\\n+    if (!HasFlag(NODE_MAY_HAVE_ID)) {\\n+        return nsnull;\\n+    }\\n+\\n     const nsAttrValue* attrVal = FindLocalOrProtoAttr(kNameSpaceID_None, nsGkAtoms::id);\\n \\n     NS_ASSERTION(!attrVal ||\\n@@ -1649,6 +1664,9 @@ nsXULElement::GetID() const\\n const nsAttrValue*\\n nsXULElement::GetClasses() const\\n {\\n+    if (!HasFlag(NODE_MAY_HAVE_CLASS)) {\\n+        return nsnull;\\n+    }\\n     return FindLocalOrProtoAttr(kNameSpaceID_None, nsGkAtoms::_class);\\n }\\n \\n@@ -1661,6 +1679,9 @@ nsXULElement::WalkContentStyleRules(nsRuleWalker* aRuleWalker)\\n nsICSSStyleRule*\\n nsXULElement::GetInlineStyleRule()\\n {\\n+    if (!HasFlag(NODE_MAY_HAVE_STYLE)) {\\n+        return nsnull;\\n+    }\\n     // Fetch the cached style rule from the attributes.\\n     const nsAttrValue* attrVal = FindLocalOrProtoAttr(kNameSpaceID_None, nsGkAtoms::style);\\n \\n@@ -1674,6 +1695,7 @@ nsXULElement::GetInlineStyleRule()\\n NS_IMETHODIMP\\n nsXULElement::SetInlineStyleRule(nsICSSStyleRule* aStyleRule, PRBool aNotify)\\n {\\n+  SetFlags(NODE_MAY_HAVE_STYLE);\\n   PRBool modification = PR_FALSE;\\n   nsAutoString oldValueStr;\\n \\n@@ -1887,6 +1909,7 @@ nsXULElement::GetStyle(nsIDOMCSSStyleDeclaration** aStyle)\\n         rv = gCSSOMFactory->CreateDOMCSSAttributeDeclaration(this,\\n                 getter_AddRefs(slots->mStyle));\\n         NS_ENSURE_SUCCESS(rv, rv);\\n+        SetFlags(NODE_MAY_HAVE_STYLE);\\n     }\\n \\n     NS_IF_ADDREF(*aStyle = slots->mStyle);\\n@@ -2470,7 +2493,10 @@ nsXULPrototypeElement::Deserialize(nsIObjectInputStream* aStream,\\n     nsresult rv;\\n \\n     // Read script language\\n-    rv = aStream->Read32(&mScriptTypeID);\\n+    PRUint32 scriptId = 0;\\n+    rv = aStream->Read32(&scriptId);\\n+    mScriptTypeID = scriptId;\\n+\\n     // Read Node Info\\n     PRUint32 number;\\n     rv |= aStream->Read32(&number);\\n@@ -2610,6 +2636,7 @@ nsXULPrototypeElement::SetAttrAt(PRUint32 aPos, const nsAString& aValue,\\n \\n     if (mAttributes[aPos].mName.Equals(nsGkAtoms::id) &&\\n         !aValue.IsEmpty()) {\\n+        mHasIdAttribute = PR_TRUE;\\n         // Store id as atom.\\n         // id=\\\"\\\" means that the element has no id. Not that it has\\n         // emptystring as id.\\n@@ -2618,12 +2645,14 @@ nsXULPrototypeElement::SetAttrAt(PRUint32 aPos, const nsAString& aValue,\\n         return NS_OK;\\n     }\\n     else if (mAttributes[aPos].mName.Equals(nsGkAtoms::_class)) {\\n+        mHasClassAttribute = PR_TRUE;\\n         // Compute the element's class list\\n         mAttributes[aPos].mValue.ParseAtomArray(aValue);\\n         \\n         return NS_OK;\\n     }\\n     else if (mAttributes[aPos].mName.Equals(nsGkAtoms::style)) {\\n+        mHasStyleAttribute = PR_TRUE;\\n         // Parse the element's 'style' attribute\\n         nsCOMPtr<nsICSSStyleRule> rule;\\n         nsICSSParser* parser = GetCSSParser();\\ndiff --git a/content/xul/content/src/nsXULElement.h b/content/xul/content/src/nsXULElement.h\\nindex 3da3a6d..aed4c07 100644\\n--- a/content/xul/content/src/nsXULElement.h\\n+++ b/content/xul/content/src/nsXULElement.h\\n@@ -246,6 +246,9 @@ public:\\n           mChildren(nsnull),\\n           mNumAttributes(0),\\n           mAttributes(nsnull),\\n+          mHasIdAttribute(PR_FALSE),\\n+          mHasClassAttribute(PR_FALSE),\\n+          mHasStyleAttribute(PR_FALSE),\\n           mScriptTypeID(nsIProgrammingLanguage::UNKNOWN)\\n     {\\n         NS_LOG_ADDREF(this, 1, ClassName(), ClassSize());\\n@@ -298,12 +301,16 @@ public:\\n \\n     PRUint32                 mNumAttributes;\\n     nsXULPrototypeAttribute* mAttributes;         // [OWNER]\\n+    \\n+    PRPackedBool             mHasIdAttribute:1;\\n+    PRPackedBool             mHasClassAttribute:1;\\n+    PRPackedBool             mHasStyleAttribute:1;\\n \\n     // The language ID can not be set on a per-node basis, but is tracked\\n     // so that the language ID from the originating root can be used\\n     // (eg, when a node from an overlay ends up in our document, that node\\n     // must use its original script language, not our document's default.\\n-    PRUint32                 mScriptTypeID;\\n+    PRUint16                 mScriptTypeID;\\n     static void ReleaseGlobals()\\n     {\\n         NS_IF_RELEASE(sCSSParser);\\ndiff --git a/content/xul/document/src/nsXULContentSink.cpp b/content/xul/document/src/nsXULContentSink.cpp\\nindex 2c6b0e1..dcf79c8 100644\\n--- a/content/xul/document/src/nsXULContentSink.cpp\\n+++ b/content/xul/document/src/nsXULContentSink.cpp\\n@@ -855,7 +855,9 @@ XULContentSinkImpl::SetElementScriptType(nsXULPrototypeElement* element,\\n             // Ask the top-node for its script type (which has already\\n             // had this function called for it - so no need to recurse\\n             // until we find it)\\n-            rv = mContextStack.GetTopNodeScriptType(&element->mScriptTypeID);\\n+            PRUint32 scriptId = 0;\\n+            rv = mContextStack.GetTopNodeScriptType(&scriptId);\\n+            element->mScriptTypeID = scriptId;\\n         }\\n     }\\n     return rv;\\n\""}