{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas7d8ed5f\""},"diff":"\"7d8ed5f Bug 383668 Custom cursors display as black with some video drivers r+a=pavlov\\ndiff --git a/widget/src/windows/nsWindow.cpp b/widget/src/windows/nsWindow.cpp\\nindex 6579ad1..2d48b6a 100644\\n--- a/widget/src/windows/nsWindow.cpp\\n+++ b/widget/src/windows/nsWindow.cpp\\n@@ -2554,6 +2554,51 @@ NS_METHOD nsWindow::SetCursor(nsCursor aCursor)\\n   return NS_OK;\\n }\\n \\n+static PRUint8* Data32BitTo1Bit(PRUint8* aImageData,\\n+                                PRUint32 aImageBytesPerRow,\\n+                                PRUint32 aWidth, PRUint32 aHeight)\\n+{\\n+  // We need (aWidth + 7) / 8 bytes plus zero-padding up to a multiple of\\n+  // 4 bytes for each row (HBITMAP requirement). Bug 353553.\\n+  PRUint32 outBpr = ((aWidth + 31) / 8) & ~3;\\n+  \\n+  PRUint8* outData = new PRUint8[outBpr * aHeight];\\n+  if (!outData)\\n+    return NULL;\\n+\\n+  PRUint8 *outRow = outData,\\n+          *imageRow = aImageData;\\n+\\n+  for (PRUint32 curRow = 0; curRow < aHeight; curRow++) {\\n+    PRUint8 *irow = imageRow;\\n+    PRUint8 *nextOutRow = outRow + outBpr;\\n+    PRUint8 alphaPixels = 0;\\n+    PRUint8 offset = 7;\\n+\\n+    for (PRUint32 curCol = 0; curCol < aWidth; curCol++) {\\n+      if (imageRow[3] > 0)\\n+        alphaPixels |= (1 << offset);\\n+      imageRow += 4;\\n+        \\n+      if (offset == 0) {\\n+        *outRow++ = alphaPixels;\\n+        offset = 7;\\n+        alphaPixels = 0;\\n+      } else {\\n+        offset--;\\n+      }\\n+    }\\n+    if (offset != 7)\\n+      *outRow++ = alphaPixels;\\n+\\n+    imageRow = irow + aImageBytesPerRow;\\n+    while (outRow != nextOutRow)\\n+      *outRow++ = 0; // padding\\n+  }\\n+\\n+  return outData;\\n+}\\n+\\n // static\\n PRUint8* nsWindow::Data8BitTo1Bit(PRUint8* aAlphaData,\\n                                   PRUint32 aAlphaBytesPerRow,\\n@@ -2823,20 +2868,28 @@ NS_IMETHODIMP nsWindow::SetCursor(imgIContainer* aCursor,\\n       }\\n     }\\n   }\\n-  HBITMAP bmp = DataToBitmap(bottomUpData, width, height, 32);\\n+  frame->UnlockImageData();\\n \\n-  free(bottomUpData);\\n+  PRUint8* a1data = Data32BitTo1Bit(bottomUpData, bpr, width, height);\\n+  if (!a1data) {\\n+    free(bottomUpData);\\n+    return NS_ERROR_FAILURE;\\n+  }\\n \\n-  frame->UnlockImageData();\\n+  HBITMAP bmp = DataToBitmap(bottomUpData, width, height, 32);\\n+  HBITMAP mbmp = DataToBitmap(a1data, width, height, 1);\\n+  free(bottomUpData);\\n+  delete[] a1data;\\n \\n   ICONINFO info = {0};\\n   info.fIcon = FALSE;\\n   info.xHotspot = aHotspotX;\\n   info.yHotspot = aHotspotY;\\n-  info.hbmMask = bmp;\\n+  info.hbmMask = mbmp;\\n   info.hbmColor = bmp;\\n   \\n   HCURSOR cursor = ::CreateIconIndirect(&info);\\n+  ::DeleteObject(mbmp);\\n   ::DeleteObject(bmp);\\n   if (cursor == NULL) {\\n     return NS_ERROR_FAILURE;\\n\""}