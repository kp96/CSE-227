{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basf17ce63\""},"diff":"\"f17ce63 Backing out bug 396587 to hopefully fix orange.\\ndiff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp\\nindex aa51d96..8dd14bc8 100644\\n--- a/docshell/base/nsDocShell.cpp\\n+++ b/docshell/base/nsDocShell.cpp\\n@@ -3624,11 +3624,9 @@ nsDocShell::SetPositionAndSize(PRInt32 x, PRInt32 y, PRInt32 cx,\\n     mBounds.width = cx;\\n     mBounds.height = cy;\\n \\n-    // Hold strong ref, since SetBounds can make us null out mContentViewer\\n-    nsCOMPtr<nsIContentViewer> viewer = mContentViewer;\\n-    if (viewer) {\\n+    if (mContentViewer) {\\n         //XXX Border figured in here or is that handled elsewhere?\\n-        NS_ENSURE_SUCCESS(viewer->SetBounds(mBounds), NS_ERROR_FAILURE);\\n+        NS_ENSURE_SUCCESS(mContentViewer->SetBounds(mBounds), NS_ERROR_FAILURE);\\n     }\\n \\n     return NS_OK;\\ndiff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp\\nindex f27d06a..e8b3742 100644\\n--- a/layout/base/nsPresShell.cpp\\n+++ b/layout/base/nsPresShell.cpp\\n@@ -2480,40 +2480,29 @@ PresShell::ResizeReflow(nscoord aWidth, nscoord aHeight)\\n     return NS_OK;\\n \\n   NS_ASSERTION(mViewManager, \\\"Must have view manager\\\");\\n-  nsCOMPtr<nsIViewManager> viewManager = mViewManager;\\n-  viewManager->BeginUpdateViewBatch();\\n-\\n-  // Take this ref after viewManager so it'll make sure to go away first\\n-  nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);\\n-\\n-  // Make sure style is up to date\\n-  mFrameConstructor->ProcessPendingRestyles();\\n-  if (!mIsDestroying) {\\n-    // XXX Do a full invalidate at the beginning so that invalidates along\\n-    // the way don't have region accumulation issues?\\n+  mViewManager->BeginUpdateViewBatch();\\n \\n-    WillCauseReflow();\\n-    WillDoReflow();\\n+  // XXX Do a full invalidate at the beginning so that invalidates along\\n+  // the way don't have region accumulation issues?\\n \\n-    {\\n-      // Kick off a top-down reflow\\n-      AUTO_LAYOUT_PHASE_ENTRY_POINT(GetPresContext(), Reflow);\\n-      mIsReflowing = PR_TRUE;\\n+  WillCauseReflow();\\n+  WillDoReflow();\\n \\n-      mDirtyRoots.RemoveElement(rootFrame);\\n-      DoReflow(rootFrame);\\n-      mIsReflowing = PR_FALSE;\\n-    }\\n+  {\\n+    // Kick off a top-down reflow\\n+    AUTO_LAYOUT_PHASE_ENTRY_POINT(GetPresContext(), Reflow);\\n+    mIsReflowing = PR_TRUE;\\n \\n-    DidCauseReflow();\\n-    DidDoReflow();\\n+    mDirtyRoots.RemoveElement(rootFrame);\\n+    DoReflow(rootFrame);\\n+    mIsReflowing = PR_FALSE;\\n   }\\n \\n-  viewManager->EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);\\n+  DidCauseReflow();\\n+  DidDoReflow();\\n+  mViewManager->EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);\\n \\n-  if (!mIsDestroying) {\\n-    CreateResizeEventTimer();\\n-  }\\n+  CreateResizeEventTimer();\\n \\n   return NS_OK; //XXX this needs to be real. MMP\\n }\\n@@ -6234,31 +6223,26 @@ PresShell::ProcessReflowCommands(PRBool aInterruptible)\\n \\n     DidDoReflow();\\n \\n-    // DidDoReflow might have killed us\\n-    if (!mIsDestroying) {\\n #ifdef DEBUG\\n-      if (VERIFY_REFLOW_DUMP_COMMANDS & gVerifyReflowFlags) {\\n-        printf(\\\"\\\\nPresShell::ProcessReflowCommands() finished: this=%p\\\\n\\\",\\n-               (void*)this);\\n-      }\\n-      DoVerifyReflow();\\n+    if (VERIFY_REFLOW_DUMP_COMMANDS & gVerifyReflowFlags) {\\n+      printf(\\\"\\\\nPresShell::ProcessReflowCommands() finished: this=%p\\\\n\\\", (void*)this);\\n+    }\\n+    DoVerifyReflow();\\n #endif\\n \\n-      // If any new reflow commands were enqueued during the reflow, schedule\\n-      // another reflow event to process them.  Note that we want to do this\\n-      // after DidDoReflow(), since that method can change whether there are\\n-      // dirty roots around by flushing, and there's no point in posting a\\n-      // reflow event just to have the flush revoke it.\\n-      if (mDirtyRoots.Count())\\n-        PostReflowEvent();\\n-    }\\n+    // If any new reflow commands were enqueued during the reflow, schedule\\n+    // another reflow event to process them.  Note that we want to do this\\n+    // after DidDoReflow(), since that method can change whether there are\\n+    // dirty roots around by flushing, and there's no point in posting a reflow\\n+    // event just to have the flush revoke it.\\n+    if (mDirtyRoots.Count())\\n+      PostReflowEvent();\\n   }\\n   \\n   MOZ_TIMER_DEBUGLOG((\\\"Stop: Reflow: PresShell::ProcessReflowCommands(), this=%p\\\\n\\\", this));\\n   MOZ_TIMER_STOP(mReflowWatch);  \\n \\n-  if (!mIsDestroying && mShouldUnsuppressPainting &&\\n-      mDirtyRoots.Count() == 0) {\\n+  if (mShouldUnsuppressPainting && mDirtyRoots.Count() == 0) {\\n     // We only unlock if we're out of reflows.  It's pointless\\n     // to unlock if reflows are still pending, since reflows\\n     // are just going to thrash the frames around some more.  By\\ndiff --git a/layout/generic/nsFrameFrame.cpp b/layout/generic/nsFrameFrame.cpp\\nindex c6afff2..a654fb0 100644\\n--- a/layout/generic/nsFrameFrame.cpp\\n+++ b/layout/generic/nsFrameFrame.cpp\\n@@ -89,7 +89,6 @@\\n #include \\\"nsIDOMNSHTMLDocument.h\\\"\\n #include \\\"nsDisplayList.h\\\"\\n #include \\\"nsUnicharUtils.h\\\"\\n-#include \\\"nsIReflowCallback.h\\\"\\n \\n // For Accessibility\\n #ifdef ACCESSIBILITY\\n@@ -103,8 +102,7 @@ static NS_DEFINE_CID(kCChildCID, NS_CHILD_CID);\\n  * nsSubDocumentFrame\\n  *****************************************************************************/\\n class nsSubDocumentFrame : public nsLeafFrame,\\n-                           public nsIFrameFrame,\\n-                           public nsIReflowCallback\\n+                           public nsIFrameFrame\\n {\\n public:\\n   nsSubDocumentFrame(nsStyleContext* aContext);\\n@@ -161,9 +159,6 @@ public:\\n \\n   NS_IMETHOD  VerifyTree() const;\\n \\n-  // nsIReflowCallback\\n-  virtual PRBool ReflowFinished();\\n-\\n protected:\\n   nsSize GetMargin();\\n   PRBool IsInline() { return mIsInline; }\\n@@ -180,12 +175,11 @@ protected:\\n   PRPackedBool mDidCreateDoc;\\n   PRPackedBool mOwnsFrameLoader;\\n   PRPackedBool mIsInline;\\n-  PRPackedBool mPostedReflowCallback;\\n };\\n \\n nsSubDocumentFrame::nsSubDocumentFrame(nsStyleContext* aContext)\\n   : nsLeafFrame(aContext), mDidCreateDoc(PR_FALSE), mOwnsFrameLoader(PR_FALSE),\\n-    mIsInline(PR_FALSE), mPostedReflowCallback(PR_FALSE)\\n+    mIsInline(PR_FALSE)\\n {\\n }\\n \\n@@ -378,9 +372,6 @@ nsSubDocumentFrame::Reflow(nsPresContext*          aPresContext,\\n \\n   aStatus = NS_FRAME_COMPLETE;\\n \\n-  NS_ASSERTION(aPresContext->GetPresShell()->GetPrimaryFrameFor(mContent) == this,\\n-               \\\"Shouldn't happen\\\");\\n-\\n   // \\\"offset\\\" is the offset of our content area from our frame's\\n   // top-left corner.\\n   nsPoint offset(0, 0);\\n@@ -418,9 +409,22 @@ nsSubDocumentFrame::Reflow(nsPresContext*          aPresContext,\\n   nsRect rect(nsPoint(0, 0), GetSize());\\n   Invalidate(rect, PR_FALSE);\\n \\n-  if (!aPresContext->IsPaginated() && !mPostedReflowCallback) {\\n-    PresContext()->PresShell()->PostReflowCallback(this);\\n-    mPostedReflowCallback = PR_TRUE;\\n+  if (!aPresContext->IsPaginated()) {\\n+    nsCOMPtr<nsIDocShell> docShell;\\n+    GetDocShell(getter_AddRefs(docShell));\\n+\\n+    nsCOMPtr<nsIBaseWindow> baseWindow(do_QueryInterface(docShell));\\n+\\n+    // resize the sub document\\n+    if (baseWindow) {\\n+      PRInt32 x = 0;\\n+      PRInt32 y = 0;\\n+      \\n+      baseWindow->GetPositionAndSize(&x, &y, nsnull, nsnull);\\n+      PRInt32 cx = aPresContext->AppUnitsToDevPixels(innerSize.width);\\n+      PRInt32 cy = aPresContext->AppUnitsToDevPixels(innerSize.height);\\n+      baseWindow->SetPositionAndSize(x, y, cx, cy, PR_FALSE);\\n+    }\\n   }\\n \\n   // printf(\\\"OuterFrame::Reflow DONE %X (%d,%d)\\\\n\\\", this,\\n@@ -434,39 +438,6 @@ nsSubDocumentFrame::Reflow(nsPresContext*          aPresContext,\\n   return NS_OK;\\n }\\n \\n-PRBool\\n-nsSubDocumentFrame::ReflowFinished()\\n-{\\n-  mPostedReflowCallback = PR_FALSE;\\n-  \\n-  nsSize innerSize(GetSize());\\n-  if (IsInline()) {\\n-    nsMargin usedBorderPadding = GetUsedBorderAndPadding();\\n-    innerSize.width  -= usedBorderPadding.LeftRight();\\n-    innerSize.height -= usedBorderPadding.TopBottom();\\n-  }\\n-  \\n-  nsCOMPtr<nsIDocShell> docShell;\\n-  GetDocShell(getter_AddRefs(docShell));\\n-\\n-  nsCOMPtr<nsIBaseWindow> baseWindow(do_QueryInterface(docShell));\\n-\\n-  // resize the sub document\\n-  if (baseWindow) {\\n-    PRInt32 x = 0;\\n-    PRInt32 y = 0;\\n-\\n-    nsPresContext* presContext = PresContext();\\n-    baseWindow->GetPositionAndSize(&x, &y, nsnull, nsnull);\\n-    PRInt32 cx = presContext->AppUnitsToDevPixels(innerSize.width);\\n-    PRInt32 cy = presContext->AppUnitsToDevPixels(innerSize.height);\\n-    baseWindow->SetPositionAndSize(x, y, cx, cy, PR_FALSE);\\n-  }\\n-\\n-  return PR_FALSE;\\n-}\\n-\\n-\\n NS_IMETHODIMP\\n nsSubDocumentFrame::VerifyTree() const\\n {\\n@@ -585,11 +556,6 @@ NS_NewSubDocumentFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)\\n void\\n nsSubDocumentFrame::Destroy()\\n {\\n-  if (mPostedReflowCallback) {\\n-    PresContext()->PresShell()->CancelReflowCallback(this);\\n-    mPostedReflowCallback = PR_FALSE;\\n-  }\\n-  \\n   if (mFrameLoader && mDidCreateDoc) {\\n     // Get the content viewer through the docshell, but don't call\\n     // GetDocShell() since we don't want to create one if we don't\\n@@ -718,7 +684,7 @@ nsSubDocumentFrame::ShowDocShell()\\n \\n   if (presShell) {\\n     // The docshell is already showing, nothing left to do...\\n-    NS_ASSERTION(mInnerView, \\\"What's going on?\\\");\\n+\\n     return NS_OK;\\n   }\\n \\n\""}