{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basc284e81\""},"diff":"\"c284e81 Bug 391915: Don't use atoms from nsCacheMetaData because atoms aren't threadsafe. r+sr=biesi, a=blocking1.9\\ndiff --git a/netwerk/cache/src/nsCacheMetaData.cpp b/netwerk/cache/src/nsCacheMetaData.cpp\\nindex 70efb93..bdfebbc 100644\\n--- a/netwerk/cache/src/nsCacheMetaData.cpp\\n+++ b/netwerk/cache/src/nsCacheMetaData.cpp\\n@@ -67,11 +67,9 @@ nsCacheMetaData::GetElement(const char * key)\\n     // We assume the number of meta data elements will be very small, so\\n     // we keep it real simple.  Singly-linked list, linearly searched.\\n \\n-    nsCOMPtr<nsIAtom> keyAtom = do_GetAtom(key);\\n-\\n     MetaElement * elem = mData;\\n     while (elem) {\\n-        if (elem->mKey == keyAtom)\\n+        if (elem->mKey.EqualsASCII(key))\\n             return elem->mValue;\\n         elem = elem->mNext;\\n     }\\n@@ -83,17 +81,13 @@ nsresult\\n nsCacheMetaData::SetElement(const char * key,\\n                             const char * value)\\n {\\n-    nsCOMPtr<nsIAtom> keyAtom = do_GetAtom(key);\\n-    if (!keyAtom)\\n-        return NS_ERROR_OUT_OF_MEMORY;\\n-\\n     PRUint32 keySize = strlen(key);\\n     PRUint32 valueSize = value ? strlen(value) : 0;\\n \\n     // find and remove or update old meta data element\\n     MetaElement * elem = mData, * last = nsnull;\\n     while (elem) {\\n-        if (elem->mKey == keyAtom) {\\n+        if (elem->mKey.Equals(key)) {\\n             // Get length of old value\\n             PRUint32 oldValueLen = strlen(elem->mValue);\\n             if (valueSize == oldValueLen) {\\n@@ -120,7 +114,7 @@ nsCacheMetaData::SetElement(const char * key,\\n         elem = new (value, valueSize) MetaElement;\\n         if (!elem)\\n             return NS_ERROR_OUT_OF_MEMORY;\\n-        elem->mKey = keyAtom;\\n+        elem->mKey.Assign(key);\\n \\n         // insert after last or as first element...\\n         if (last) {\\n@@ -142,8 +136,6 @@ nsCacheMetaData::SetElement(const char * key,\\n nsresult\\n nsCacheMetaData::FlattenMetaData(char * buffer, PRUint32 bufSize)\\n {\\n-    const char *key;\\n-\\n     if (mMetaSize > bufSize) {\\n         NS_ERROR(\\\"buffer size too small for meta data.\\\");\\n         return NS_ERROR_OUT_OF_MEMORY;\\n@@ -151,10 +143,8 @@ nsCacheMetaData::FlattenMetaData(char * buffer, PRUint32 bufSize)\\n \\n     MetaElement * elem = mData;\\n     while (elem) {\\n-        elem->mKey->GetUTF8String(&key);\\n-\\n-        PRUint32 keySize = 1 + strlen(key);\\n-        memcpy(buffer, key, keySize);\\n+        PRUint32 keySize = 1 + elem->mKey.Length();\\n+        memcpy(buffer, elem->mKey.get(), keySize);\\n         buffer += keySize;\\n \\n         PRUint32 valSize = 1 + strlen(elem->mValue);\\n@@ -179,15 +169,11 @@ nsCacheMetaData::UnflattenMetaData(const char * data, PRUint32 size)\\n         PRUint32 keySize = strlen(key);\\n         data += 1 + keySize;\\n         if (data < limit) {\\n-            nsCOMPtr<nsIAtom> keyAtom = do_GetAtom(key);\\n-            if (!keyAtom)\\n-                return NS_ERROR_OUT_OF_MEMORY;\\n-\\n             PRUint32 valueSize = strlen(data);\\n             MetaElement *elem = new (data, valueSize) MetaElement;\\n             if (!elem)\\n                  return NS_ERROR_OUT_OF_MEMORY;\\n-            elem->mKey = keyAtom;\\n+            elem->mKey.Assign(key);\\n \\n             // insert after last or as first element...\\n             if (last) {\\n@@ -212,14 +198,10 @@ nsCacheMetaData::UnflattenMetaData(const char * data, PRUint32 size)\\n nsresult\\n nsCacheMetaData::VisitElements(nsICacheMetaDataVisitor * visitor)\\n {\\n-    const char *key;\\n-\\n     MetaElement * elem = mData;\\n     while (elem) {\\n-        elem->mKey->GetUTF8String(&key);\\n-\\n         PRBool keepGoing;\\n-        nsresult rv = visitor->VisitMetaDataElement(key, elem->mValue, &keepGoing);\\n+        nsresult rv = visitor->VisitMetaDataElement(elem->mKey.get(), elem->mValue, &keepGoing);\\n \\n         if (NS_FAILED(rv) || !keepGoing)\\n             break;\\ndiff --git a/netwerk/cache/src/nsCacheMetaData.h b/netwerk/cache/src/nsCacheMetaData.h\\nindex f76a1a3..22c4d0b 100644\\n--- a/netwerk/cache/src/nsCacheMetaData.h\\n+++ b/netwerk/cache/src/nsCacheMetaData.h\\n@@ -44,7 +44,7 @@\\n #include \\\"nspr.h\\\"\\n #include \\\"pldhash.h\\\"\\n #include \\\"nscore.h\\\"\\n-#include \\\"nsIAtom.h\\\"\\n+#include \\\"nsString.h\\\"\\n \\n class nsICacheMetaDataVisitor;\\n \\n@@ -74,7 +74,7 @@ private:\\n     struct MetaElement\\n     {\\n         struct MetaElement * mNext;\\n-        nsCOMPtr<nsIAtom>    mKey;\\n+        nsCString            mKey;\\n         char                 mValue[1]; // actually, bigger than 1\\n \\n         // MetaElement and mValue are allocated together via:\\n\""}