{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas9bf4c3c\""},"diff":"\"9bf4c3c Bug 373911, r=bz, sr=dbaron, a=1.9+\\ndiff --git a/content/xbl/src/nsBindingManager.cpp b/content/xbl/src/nsBindingManager.cpp\\nindex e0d8bcb..662c9a6 100644\\n--- a/content/xbl/src/nsBindingManager.cpp\\n+++ b/content/xbl/src/nsBindingManager.cpp\\n@@ -843,36 +843,38 @@ nsBindingManager::ProcessAttachedQueue()\\n   mAttachedStack.Compact();\\n }\\n \\n+// Keep bindings and bound elements alive while executing detached handlers.\\n+struct BindingTableReadClosure\\n+{\\n+  nsCOMArray<nsIContent> mBoundElements;\\n+  nsBindingList          mBindings;\\n+};\\n+\\n PR_STATIC_CALLBACK(PLDHashOperator)\\n AccumulateBindingsToDetach(nsISupports *aKey, nsXBLBinding *aBinding,\\n-                           void* aVoidArray)\\n-{\\n-  nsVoidArray* arr = static_cast<nsVoidArray*>(aVoidArray);\\n-  // Hold an owning reference to this binding, just in case\\n-  if (arr->AppendElement(aBinding))\\n-    NS_ADDREF(aBinding);\\n+                           void* aClosure)\\n+ {\\n+  BindingTableReadClosure* closure =\\n+    static_cast<BindingTableReadClosure*>(aClosure);\\n+  if (aBinding && closure->mBindings.AppendElement(aBinding)) {\\n+    if (!closure->mBoundElements.AppendObject(aBinding->GetBoundElement())) {\\n+      closure->mBindings.RemoveElementAt(closure->mBindings.Length() - 1);\\n+    }\\n+  }\\n   return PL_DHASH_NEXT;\\n }\\n \\n-PR_STATIC_CALLBACK(PRBool)\\n-ExecuteDetachedHandler(void* aBinding, void* aClosure)\\n-{\\n-  NS_PRECONDITION(aBinding, \\\"Null binding in list?\\\");\\n-  nsXBLBinding* binding = static_cast<nsXBLBinding*>(aBinding);\\n-  binding->ExecuteDetachedHandler();\\n-  // Drop our ref to the binding now\\n-  NS_RELEASE(binding);\\n-  return PR_TRUE;\\n-}\\n-\\n void\\n nsBindingManager::ExecuteDetachedHandlers()\\n {\\n   // Walk our hashtable of bindings.\\n   if (mBindingTable.IsInitialized()) {\\n-    nsVoidArray bindingsToDetach;\\n-    mBindingTable.EnumerateRead(AccumulateBindingsToDetach, &bindingsToDetach);\\n-    bindingsToDetach.EnumerateForwards(ExecuteDetachedHandler, nsnull);\\n+    BindingTableReadClosure closure;\\n+    mBindingTable.EnumerateRead(AccumulateBindingsToDetach, &closure);\\n+    PRUint32 i, count = closure.mBindings.Length();\\n+    for (i = 0; i < count; ++i) {\\n+      closure.mBindings[i]->ExecuteDetachedHandler();\\n+    }\\n   }\\n }\\n \\ndiff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp\\nindex 9c2b069..79e05a4 100644\\n--- a/layout/base/nsPresShell.cpp\\n+++ b/layout/base/nsPresShell.cpp\\n@@ -4377,7 +4377,11 @@ PresShell::FlushPendingNotifications(mozFlushType aType)\\n   IsSafeToFlush(isSafeToFlush);\\n \\n   NS_ASSERTION(!isSafeToFlush || mViewManager, \\\"Must have view manager\\\");\\n-  if (isSafeToFlush && mViewManager) {\\n+  // Make sure the view manager stays alive while batching view updates.\\n+  // XXX FIXME: If viewmanager hierarchy is modified while we're in update\\n+  //            batch... We need to address that somehow.  See bug 369165.\\n+  nsCOMPtr<nsIViewManager> viewManager = mViewManager;\\n+  if (isSafeToFlush && viewManager) {\\n     // Processing pending notifications can kill us, and some callers only\\n     // hold weak refs when calling FlushPendingNotifications().  :(\\n     nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);\\n@@ -4385,27 +4389,15 @@ PresShell::FlushPendingNotifications(mozFlushType aType)\\n     // Style reresolves not in conjunction with reflows can't cause\\n     // painting or geometry changes, so don't bother with view update\\n     // batching if we only have style reresolve\\n-    mViewManager->BeginUpdateViewBatch();\\n+    viewManager->BeginUpdateViewBatch();\\n \\n     if (aType & Flush_StyleReresolves) {\\n       mFrameConstructor->ProcessPendingRestyles();\\n-      if (mIsDestroying) {\\n-        // We no longer have a view manager and all that.\\n-        // XXX FIXME: Except we're in the middle of a view update batch...  We\\n-        // need to address that somehow.  See bug 369165.\\n-        return NS_OK;\\n-      }\\n     }\\n \\n-    if (aType & Flush_OnlyReflow) {\\n+    if (aType & Flush_OnlyReflow && !mIsDestroying) {\\n       mFrameConstructor->RecalcQuotesAndCounters();\\n       ProcessReflowCommands(PR_FALSE);\\n-      if (mIsDestroying) {\\n-        // We no longer have a view manager and all that.\\n-        // XXX FIXME: Except we're in the middle of a view update batch...  We\\n-        // need to address that somehow.  See bug 369165.\\n-        return NS_OK;\\n-      }\\n     }\\n \\n     PRUint32 updateFlags = NS_VMREFRESH_NO_SYNC;\\n@@ -4420,7 +4412,7 @@ PresShell::FlushPendingNotifications(mozFlushType aType)\\n       // at the end of this view batch.\\n       updateFlags = NS_VMREFRESH_DEFERRED;\\n     }\\n-    mViewManager->EndUpdateViewBatch(updateFlags);\\n+    viewManager->EndUpdateViewBatch(updateFlags);\\n   }\\n \\n   return NS_OK;\\n\""}