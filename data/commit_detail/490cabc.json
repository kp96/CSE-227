{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas490cabc\""},"diff":"\"490cabc Make Suspend() work on an HTTP channel if called right after AsyncOpen.  Bug 392837, r+sr=biesi, a=bzbarsky\\ndiff --git a/netwerk/protocol/http/src/nsHttpChannel.cpp b/netwerk/protocol/http/src/nsHttpChannel.cpp\\nindex a3d9bbd..5c0a77d 100644\\n--- a/netwerk/protocol/http/src/nsHttpChannel.cpp\\n+++ b/netwerk/protocol/http/src/nsHttpChannel.cpp\\n@@ -104,6 +104,8 @@ nsHttpChannel::nsHttpChannel()\\n     , mProxyAuthContinuationState(nsnull)\\n     , mAuthContinuationState(nsnull)\\n     , mStartPos(LL_MAXUINT)\\n+    , mPendingAsyncCallOnResume(nsnull)\\n+    , mSuspendCount(0)\\n     , mRedirectionLimit(gHttpHandler->RedirectionLimit())\\n     , mIsPending(PR_FALSE)\\n     , mWasOpened(PR_FALSE)\\n@@ -354,31 +356,53 @@ nsHttpChannel::AsyncAbort(nsresult status)\\n     mStatus = status;\\n     mIsPending = PR_FALSE;\\n \\n-    // create a proxy for the listener..\\n-    nsCOMPtr<nsIRequestObserver> observer;\\n-    NS_NewRequestObserverProxy(getter_AddRefs(observer), mListener,\\n-                               NS_GetCurrentThread());\\n-    if (observer) {\\n-        observer->OnStartRequest(this, mListenerContext);\\n-        observer->OnStopRequest(this, mListenerContext, mStatus);\\n-    }\\n-    else {\\n-        NS_ERROR(\\\"unable to create request observer proxy\\\");\\n-        // XXX else, no proxy object manager... what do we do?\\n-    }\\n-    mListener = 0;\\n-    mListenerContext = 0;\\n-\\n+    nsresult rv = AsyncCall(&nsHttpChannel::HandleAsyncNotifyListener);\\n+    // And if that fails?  Callers ignore our return value anyway....\\n+    \\n     // finally remove ourselves from the load group.\\n     if (mLoadGroup)\\n         mLoadGroup->RemoveRequest(this, nsnull, status);\\n \\n-    return NS_OK;\\n+    return rv;\\n+}\\n+\\n+void\\n+nsHttpChannel::HandleAsyncNotifyListener()\\n+{\\n+    NS_PRECONDITION(!mPendingAsyncCallOnResume, \\\"How did that happen?\\\");\\n+    \\n+    if (mSuspendCount) {\\n+        LOG((\\\"Waiting until resume to do async notification [this=%p]\\\\n\\\",\\n+             this));\\n+        mPendingAsyncCallOnResume = &nsHttpChannel::HandleAsyncNotifyListener;\\n+        return;\\n+    }\\n+\\n+    DoNotifyListener();\\n+}\\n+\\n+void\\n+nsHttpChannel::DoNotifyListener()\\n+{\\n+    if (mListener) {\\n+        mListener->OnStartRequest(this, mListenerContext);\\n+        mListener->OnStopRequest(this, mListenerContext, mStatus);\\n+        mListener = 0;\\n+        mListenerContext = 0;\\n+    }\\n }\\n \\n void\\n nsHttpChannel::HandleAsyncRedirect()\\n {\\n+    NS_PRECONDITION(!mPendingAsyncCallOnResume, \\\"How did that happen?\\\");\\n+    \\n+    if (mSuspendCount) {\\n+        LOG((\\\"Waiting until resume to do async redirect [this=%p]\\\\n\\\", this));\\n+        mPendingAsyncCallOnResume = &nsHttpChannel::HandleAsyncRedirect;\\n+        return;\\n+    }\\n+\\n     nsresult rv = NS_OK;\\n \\n     LOG((\\\"nsHttpChannel::HandleAsyncRedirect [this=%p]\\\\n\\\", this));\\n@@ -393,12 +417,7 @@ nsHttpChannel::HandleAsyncRedirect()\\n             // OnStart/OnStop notifications.\\n             LOG((\\\"ProcessRedirection failed [rv=%x]\\\\n\\\", rv));\\n             mStatus = rv;\\n-            if (mListener) {\\n-                mListener->OnStartRequest(this, mListenerContext);\\n-                mListener->OnStopRequest(this, mListenerContext, mStatus);\\n-                mListener = 0;\\n-                mListenerContext = 0;\\n-            }\\n+            DoNotifyListener();\\n         }\\n     }\\n \\n@@ -419,14 +438,18 @@ nsHttpChannel::HandleAsyncRedirect()\\n void\\n nsHttpChannel::HandleAsyncNotModified()\\n {\\n+    NS_PRECONDITION(!mPendingAsyncCallOnResume, \\\"How did that happen?\\\");\\n+    \\n+    if (mSuspendCount) {\\n+        LOG((\\\"Waiting until resume to do async not-modified [this=%p]\\\\n\\\",\\n+             this));\\n+        mPendingAsyncCallOnResume = &nsHttpChannel::HandleAsyncNotModified;\\n+        return;\\n+    }\\n+    \\n     LOG((\\\"nsHttpChannel::HandleAsyncNotModified [this=%p]\\\\n\\\", this));\\n \\n-    if (mListener) {\\n-        mListener->OnStartRequest(this, mListenerContext);\\n-        mListener->OnStopRequest(this, mListenerContext, mStatus);\\n-        mListener = 0;\\n-        mListenerContext = 0;\\n-    }\\n+    DoNotifyListener();\\n \\n     CloseCacheEntry();\\n \\n@@ -986,11 +1009,42 @@ nsHttpChannel::ProxyFailover()\\n     if (NS_FAILED(rv))\\n         return rv;\\n \\n-    return ReplaceWithProxy(pi);\\n+    // XXXbz so where does this codepath remove us from the loadgroup,\\n+    // exactly?\\n+    return DoReplaceWithProxy(pi);\\n+}\\n+\\n+void\\n+nsHttpChannel::HandleAsyncReplaceWithProxy()\\n+{\\n+    NS_PRECONDITION(!mPendingAsyncCallOnResume, \\\"How did that happen?\\\");\\n+\\n+    if (mSuspendCount) {\\n+        LOG((\\\"Waiting until resume to do async proxy replacement [this=%p]\\\\n\\\",\\n+             this));\\n+        mPendingAsyncCallOnResume =\\n+            &nsHttpChannel::HandleAsyncReplaceWithProxy;\\n+        return;\\n+    }\\n+\\n+    nsresult status = mStatus;\\n+    \\n+    nsCOMPtr<nsIProxyInfo> pi;\\n+    pi.swap(mTargetProxyInfo);\\n+    if (!mCanceled) {\\n+        status = DoReplaceWithProxy(pi);\\n+        if (mLoadGroup && NS_SUCCEEDED(status)) {\\n+            mLoadGroup->RemoveRequest(this, nsnull, mStatus);\\n+        }\\n+    }\\n+\\n+    if (NS_FAILED(status)) {\\n+        AsyncAbort(status);\\n+    }\\n }\\n \\n nsresult\\n-nsHttpChannel::ReplaceWithProxy(nsIProxyInfo *pi)\\n+nsHttpChannel::DoReplaceWithProxy(nsIProxyInfo* pi)\\n {\\n     nsresult rv;\\n \\n@@ -3335,25 +3389,39 @@ nsHttpChannel::Cancel(nsresult status)\\n NS_IMETHODIMP\\n nsHttpChannel::Suspend()\\n {\\n+    NS_ENSURE_TRUE(mIsPending, NS_ERROR_NOT_AVAILABLE);\\n+    \\n     LOG((\\\"nsHttpChannel::Suspend [this=%x]\\\\n\\\", this));\\n+\\n+    ++mSuspendCount;\\n+\\n     if (mTransactionPump)\\n         return mTransactionPump->Suspend();\\n     if (mCachePump)\\n         return mCachePump->Suspend();\\n \\n-    return NS_ERROR_UNEXPECTED;\\n+    return NS_OK;\\n }\\n \\n NS_IMETHODIMP\\n nsHttpChannel::Resume()\\n {\\n+    NS_ENSURE_TRUE(mSuspendCount > 0, NS_ERROR_UNEXPECTED);\\n+    \\n     LOG((\\\"nsHttpChannel::Resume [this=%x]\\\\n\\\", this));\\n+        \\n+    if (--mSuspendCount == 0 && mPendingAsyncCallOnResume) {\\n+        nsresult rv = AsyncCall(mPendingAsyncCallOnResume);\\n+        mPendingAsyncCallOnResume = nsnull;\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+    }\\n+\\n     if (mTransactionPump)\\n         return mTransactionPump->Resume();\\n     if (mCachePump)\\n         return mCachePump->Resume();\\n \\n-    return NS_ERROR_UNEXPECTED;\\n+    return NS_OK;\\n }\\n \\n NS_IMETHODIMP\\n@@ -4170,17 +4238,8 @@ nsHttpChannel::OnProxyAvailable(nsICancelable *request, nsIURI *uri,\\n     // Need to replace this channel with a new one.  It would be complex to try\\n     // to change the value of mConnectionInfo since so much of our state may\\n     // depend on its state.\\n-    if (!mCanceled) {\\n-        status = ReplaceWithProxy(pi);\\n-\\n-        // XXX(darin): It'd be nice if removing ourselves from the loadgroup\\n-        // could be factored into ReplaceWithProxy somehow.\\n-        if (mLoadGroup && NS_SUCCEEDED(status))\\n-            mLoadGroup->RemoveRequest(this, nsnull, mStatus);\\n-    }\\n-\\n-    if (NS_FAILED(status))\\n-        AsyncAbort(status);\\n+    mTargetProxyInfo = pi;\\n+    HandleAsyncReplaceWithProxy();\\n     return NS_OK;\\n }\\n \\ndiff --git a/netwerk/protocol/http/src/nsHttpChannel.h b/netwerk/protocol/http/src/nsHttpChannel.h\\nindex 676d855..ac836f9 100644\\n--- a/netwerk/protocol/http/src/nsHttpChannel.h\\n+++ b/netwerk/protocol/http/src/nsHttpChannel.h\\n@@ -149,6 +149,9 @@ private:\\n     PRBool   RequestIsConditional();\\n     nsresult Connect(PRBool firstTime = PR_TRUE);\\n     nsresult AsyncAbort(nsresult status);\\n+    // Send OnStartRequest/OnStopRequest to our listener, if any.\\n+    void     HandleAsyncNotifyListener();\\n+    void     DoNotifyListener();\\n     nsresult SetupTransaction();\\n     void     AddCookiesToRequest();\\n     nsresult ApplyContentConversions();\\n@@ -168,7 +171,8 @@ private:\\n \\n     // proxy specific methods\\n     nsresult ProxyFailover();\\n-    nsresult ReplaceWithProxy(nsIProxyInfo *);\\n+    nsresult DoReplaceWithProxy(nsIProxyInfo *);\\n+    void HandleAsyncReplaceWithProxy();\\n     nsresult ResolveProxy();\\n \\n     // cache specific methods\\n@@ -268,6 +272,18 @@ private:\\n     nsCString                         mEntityID;\\n     PRUint64                          mStartPos;\\n \\n+    // Function pointer that can be set to indicate that we got suspended while\\n+    // waiting on an AsyncCall.  When we get resumed we should AsyncCall this\\n+    // function.\\n+    nsAsyncCallback                   mPendingAsyncCallOnResume;\\n+\\n+    // Proxy info to replace with\\n+    nsCOMPtr<nsIProxyInfo>            mTargetProxyInfo;\\n+\\n+    // Suspend counter.  This is used if someone tries to suspend/resume us\\n+    // before we have either a cache pump or a transaction pump.\\n+    PRUint32                          mSuspendCount;\\n+\\n     // redirection specific data.\\n     PRUint8                           mRedirectionLimit;\\n \\n\""}