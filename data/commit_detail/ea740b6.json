{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basea740b6\""},"diff":"\"ea740b6 Bug 379633: Scriptable zipwriter component. r=bsmedberg, sr=cbiesinger, a=bzbarsky\\ndiff --git a/config/autoconf.mk.in b/config/autoconf.mk.in\\nindex 11ba314..db69e1e 100644\\n--- a/config/autoconf.mk.in\\n+++ b/config/autoconf.mk.in\\n@@ -148,6 +148,7 @@ MOZ_PLACES_BOOKMARKS = @MOZ_PLACES_BOOKMARKS@\\n MOZ_STORAGE = @MOZ_STORAGE@\\n MOZ_SAFE_BROWSING = @MOZ_SAFE_BROWSING@\\n MOZ_URL_CLASSIFIER = @MOZ_URL_CLASSIFIER@\\n+MOZ_ZIPWRITER = @MOZ_ZIPWRITER@\\n MOZ_MORK = @MOZ_MORK@\\n MOZ_MORKREADER = @MOZ_MORKREADER@\\n MOZ_NO_XPCOM_OBSOLETE = @MOZ_NO_XPCOM_OBSOLETE@\\ndiff --git a/configure.in b/configure.in\\nindex 6103aee..f11e35b 100644\\n--- a/configure.in\\n+++ b/configure.in\\n@@ -4164,6 +4164,7 @@ MOZ_XSLT_STANDALONE=\\n MOZ_XTF=1\\n MOZ_XUL=1\\n MOZ_XUL_APP=1\\n+MOZ_ZIPWRITER=1\\n NS_PRINTING=1\\n NECKO_COOKIES=1\\n NECKO_DISK_CACHE=1\\n@@ -4281,6 +4282,7 @@ basic)\\n   MOZ_XPFE_COMPONENTS=\\n   MOZ_XPINSTALL=\\n   MOZ_XTF=\\n+  MOZ_ZIPWRITER=\\n   NECKO_DISK_CACHE=\\n   NECKO_PROTOCOLS_DEFAULT=\\\"about data http file res\\\"\\n   NECKO_SMALL_BUFFERS=1\\n@@ -4331,6 +4333,7 @@ minimal)\\n   MOZ_XPINSTALL=\\n   MOZ_XTF=\\n   MOZ_XUL=\\n+  MOZ_ZIPWRITER=\\n   MOZ_RDF=\\n   NECKO_DISK_CACHE=\\n   NECKO_PROTOCOLS_DEFAULT=\\\"about data http file res\\\"\\n@@ -5904,6 +5907,15 @@ fi\\n AC_SUBST(MOZ_URL_CLASSIFIER)\\n \\n dnl ========================================================\\n+dnl = Disable zipwriter\\n+dnl ========================================================\\n+MOZ_ARG_DISABLE_BOOL(zipwriter,\\n+[  --disable-zipwriter             Disable zipwriter component],\\n+    MOZ_ZIPWRITER=,\\n+    MOZ_ZIPWRITER=1 )\\n+AC_SUBST(MOZ_ZIPWRITER)\\n+\\n+dnl ========================================================\\n dnl = Enable Ultrasparc specific optimizations for JS\\n dnl ========================================================\\n MOZ_ARG_ENABLE_BOOL(js-ultrasparc,\\ndiff --git a/modules/libjar/Makefile.in b/modules/libjar/Makefile.in\\nindex 69ee7dd..1245ea3 100644\\n--- a/modules/libjar/Makefile.in\\n+++ b/modules/libjar/Makefile.in\\n@@ -44,9 +44,15 @@ VPATH\\t\\t= @srcdir@\\n include $(DEPTH)/config/autoconf.mk\\n include $(srcdir)/objs.mk\\n \\n+DIRS   =\\n+\\n+ifdef MOZ_ZIPWRITER\\n+DIRS  += zipwriter\\n+endif\\n+\\n ifdef MOZ_INSTALLER\\n # Linux and Solaris installer needs standalone libjar\\n-DIRS\\t\\t= standalone\\n+DIRS  += standalone\\n \\n # Make this a true dynamic component even in static builds because\\n # this component is shared by installer\\ndiff --git a/modules/libjar/zipwriter/Makefile.in b/modules/libjar/zipwriter/Makefile.in\\nnew file mode 100644\\nindex 0000000..ec852fd\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/Makefile.in\\n@@ -0,0 +1,53 @@\\n+# ***** BEGIN LICENSE BLOCK *****\\n+# Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+#\\n+# The contents of this file are subject to the Mozilla Public License Version\\n+# 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+# the License. You may obtain a copy of the License at\\n+# http://www.mozilla.org/MPL/\\n+#\\n+# Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+# for the specific language governing rights and limitations under the\\n+# License.\\n+#\\n+# The Original Code is Zip Writer Component.\\n+#\\n+# The Initial Developer of the Original Code is\\n+# Dave Townsend <dtownsend@oxymoronical.com>.\\n+#\\n+# Portions created by the Initial Developer are Copyright (C) 2007\\n+# the Initial Developer. All Rights Reserved.\\n+#\\n+# Contributor(s):\\n+#\\n+# Alternatively, the contents of this file may be used under the terms of\\n+# either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+# the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+# in which case the provisions of the GPL or the LGPL are applicable instead\\n+# of those above. If you wish to allow use of your version of this file only\\n+# under the terms of either the GPL or the LGPL, and not to allow others to\\n+# use your version of this file under the terms of the MPL, indicate your\\n+# decision by deleting the provisions above and replace them with the notice\\n+# and other provisions required by the GPL or the LGPL. If you do not delete\\n+# the provisions above, a recipient may use your version of this file under\\n+# the terms of any one of the MPL, the GPL or the LGPL.\\n+#\\n+# ***** END LICENSE BLOCK *****\\n+\\n+DEPTH                 = ../../..\\n+topsrcdir             = @top_srcdir@\\n+srcdir                = @srcdir@\\n+VPATH                 = @srcdir@\\n+\\n+include $(DEPTH)/config/autoconf.mk\\n+\\n+MODULE                = zipwriter\\n+\\n+DIRS                  = public src\\n+\\n+ifdef ENABLE_TESTS\\n+DIRS                 += test\\n+endif\\n+\\n+include $(topsrcdir)/config/rules.mk\\ndiff --git a/modules/libjar/zipwriter/public/Makefile.in b/modules/libjar/zipwriter/public/Makefile.in\\nnew file mode 100644\\nindex 0000000..f3c87f3\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/public/Makefile.in\\n@@ -0,0 +1,51 @@\\n+# ***** BEGIN LICENSE BLOCK *****\\n+# Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+#\\n+# The contents of this file are subject to the Mozilla Public License Version\\n+# 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+# the License. You may obtain a copy of the License at\\n+# http://www.mozilla.org/MPL/\\n+#\\n+# Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+# for the specific language governing rights and limitations under the\\n+# License.\\n+#\\n+# The Original Code is Zip Writer Component.\\n+#\\n+# The Initial Developer of the Original Code is\\n+# Dave Townsend <dtownsend@oxymoronical.com>.\\n+#\\n+# Portions created by the Initial Developer are Copyright (C) 2007\\n+# the Initial Developer. All Rights Reserved.\\n+#\\n+# Contributor(s):\\n+#\\n+# Alternatively, the contents of this file may be used under the terms of\\n+# either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+# the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+# in which case the provisions of the GPL or the LGPL are applicable instead\\n+# of those above. If you wish to allow use of your version of this file only\\n+# under the terms of either the GPL or the LGPL, and not to allow others to\\n+# use your version of this file under the terms of the MPL, indicate your\\n+# decision by deleting the provisions above and replace them with the notice\\n+# and other provisions required by the GPL or the LGPL. If you do not delete\\n+# the provisions above, a recipient may use your version of this file under\\n+# the terms of any one of the MPL, the GPL or the LGPL.\\n+#\\n+# ***** END LICENSE BLOCK *****\\n+\\n+DEPTH                 = ../../../..\\n+topsrcdir             = @top_srcdir@\\n+srcdir                = @srcdir@\\n+VPATH                 = @srcdir@\\n+\\n+include $(DEPTH)/config/autoconf.mk\\n+\\n+MODULE                = zipwriter\\n+\\n+XPIDLSRCS = \\\\\\n+  nsIZipWriter.idl \\\\\\n+  $(NULL)\\n+\\n+include $(topsrcdir)/config/rules.mk\\ndiff --git a/modules/libjar/zipwriter/public/nsIZipWriter.idl b/modules/libjar/zipwriter/public/nsIZipWriter.idl\\nnew file mode 100644\\nindex 0000000..28c1cd9\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/public/nsIZipWriter.idl\\n@@ -0,0 +1,242 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+#include \\\"nsISupports.idl\\\"\\n+interface nsIChannel;\\n+interface nsIInputStream;\\n+interface nsIRequestObserver;\\n+interface nsIFile;\\n+interface nsIZipEntry;\\n+\\n+/**\\n+ * nsIZipWriter\\n+ *\\n+ * An interface for a zip archiver that can be used from script.\\n+ *\\n+ * The interface supports both a synchronous method of archiving data and a\\n+ * queueing system to allow operations to be prepared then run in sequence\\n+ * with notification after completion.\\n+ *\\n+ * Operations added to the queue do not get performed until performQueue is\\n+ * called at which point they will be performed in the order that they were\\n+ * added to the queue.\\n+ *\\n+ * Operations performed on the queue will throw any errors out to the\\n+ * observer.\\n+ *\\n+ * An attempt to perform a synchronous operation while the background queue\\n+ * is in progress will throw NS_ERROR_IN_PROGRESS.\\n+ *\\n+ * Entry names should use /'s as path separators and should not start with\\n+ * a /.\\n+ *\\n+ * It is not generally necessary to add directory entries in order to add file\\n+ * entries within them, however it is possible that some zip programs may\\n+ * experience problems what that.\\n+ */\\n+[scriptable, uuid(6d4ef074-206c-4649-9884-57bc355864d6)]\\n+interface nsIZipWriter : nsISupports\\n+{\\n+  /**\\n+   * Some predefined compression levels\\n+   */\\n+  const PRUint32 COMPRESSION_NONE    = 0;\\n+  const PRUint32 COMPRESSION_FASTEST = 1;\\n+  const PRUint32 COMPRESSION_DEFAULT = 6;\\n+  const PRUint32 COMPRESSION_BEST    = 9;\\n+\\n+  /**\\n+   * Gets or sets the comment associated with the open zip file.\\n+   *\\n+   * @throws NS_ERROR_NOT_INITIALIZED if no zip file has been opened\\n+   */\\n+  attribute ACString comment;\\n+\\n+  /**\\n+   * Indicates that operations on the background queue are being performed.\\n+   */\\n+  readonly attribute boolean inQueue;\\n+\\n+  /**\\n+   * The file that the zipwriter is writing to.\\n+   */\\n+  readonly attribute nsIFile file;\\n+\\n+  /**\\n+   * Opens a zip file.\\n+   *\\n+   * @param aFile the zip file to open\\n+   * @param aIoFlags the open flags for the zip file from prio.h\\n+   *\\n+   * @throws NS_ERROR_ALREADY_INITIALIZED if a zip file is already open\\n+   * @throws NS_ERROR_INVALID_ARG if aFile is null\\n+   * @throws NS_ERROR_FILE_NOT_FOUND if aFile does not exist and flags did\\n+   *  not allow for creation\\n+   * @throws NS_ERROR_FILE_CORRUPTED if the file does not contain zip markers\\n+   * @throws <other-error> on failure to open zip file (most likely corrupt\\n+   *  or unsupported form)\\n+   */\\n+  void open(in nsIFile aFile, in PRInt32 aIoFlags);\\n+\\n+  /**\\n+   * Returns a nsIZipEntry describing a specified zip entry or null if there\\n+   * is no such entry in the zip file\\n+   *\\n+   * @param aZipEntry the path of the entry\\n+   */\\n+  nsIZipEntry getEntry(in AUTF8String aZipEntry);\\n+\\n+  /**\\n+   * Checks whether the zipfile contains an entry specified by zipEntry.\\n+   *\\n+   * @param aZipEntry the path of the entry\\n+   */\\n+  boolean hasEntry(in AUTF8String aZipEntry);\\n+\\n+  /**\\n+   * Adds a new directory entry to the zip file. If aZipEntry does not end with\\n+   * \\\"/\\\" then it will be added.\\n+   *\\n+   * @param aZipEntry the path of the directory entry\\n+   * @param aModTime the modification time of the entry in microseconds\\n+   * @param aQueue adds the operation to the background queue. Will be\\n+   *        performed when processQueue is called.\\n+   *\\n+   * @throws NS_ERROR_NOT_INITIALIZED if no zip file has been opened\\n+   * @throws NS_ERROR_FILE_ALREADY_EXISTS if the path already exists in the\\n+   *  file\\n+   * @throws NS_ERROR_IN_PROGRESS if another operation is currently in progress\\n+   */\\n+  void addEntryDirectory(in AUTF8String aZipEntry, in PRTime aModTime,\\n+                         in boolean aQueue);\\n+\\n+  /**\\n+   * Adds a new file or directory to the zip file. If the specified file is\\n+   * a directory then this will be equivalent to a call to\\n+   * addEntryDirectory(aZipEntry, aFile.lastModifiedTime, aQueue)\\n+   *\\n+   * @param aZipEntry the path of the file entry\\n+   * @param aCompression the compression level, 0 is no compression, 9 is best\\n+   * @param aFile the file to get the data and modification time from\\n+   * @param aQueue adds the operation to the background queue. Will be\\n+   *        performed when processQueue is called.\\n+   *\\n+   * @throws NS_ERROR_NOT_INITIALIZED if no zip file has been opened\\n+   * @throws NS_ERROR_FILE_ALREADY_EXISTS if the path already exists in the zip\\n+   * @throws NS_ERROR_IN_PROGRESS if another operation is currently in progress\\n+   * @throws NS_ERROR_FILE_NOT_FOUND if file does not exist\\n+   */\\n+  void addEntryFile(in AUTF8String aZipEntry,\\n+                    in PRInt32 aCompression, in nsIFile aFile,\\n+                    in boolean aQueue);\\n+\\n+  /**\\n+   * Adds data from a channel to the zip file. If the operation is performed\\n+   * on the queue then the channel will be opened asynchronously, otherwise\\n+   * the channel must support being opened synchronously.\\n+   *\\n+   * @param aZipEntry the path of the file entry\\n+   * @param aModTime the modification time of the entry in microseconds\\n+   * @param aCompression the compression level, 0 is no compression, 9 is best\\n+   * @param aChannel the channel to get the data from\\n+   * @param aQueue adds the operation to the background queue. Will be\\n+   *        performed when processQueue is called.\\n+   *\\n+   * @throws NS_ERROR_NOT_INITIALIZED if no zip file has been opened\\n+   * @throws NS_ERROR_FILE_ALREADY_EXISTS if the path already exists in the zip\\n+   * @throws NS_ERROR_IN_PROGRESS if another operation is currently in progress\\n+   */\\n+  void addEntryChannel(in AUTF8String aZipEntry, in PRTime aModTime,\\n+                       in PRInt32 aCompression, in nsIChannel aChannel,\\n+                       in boolean aQueue);\\n+\\n+  /**\\n+   * Adds data from an input stream to the zip file.\\n+   *\\n+   * @param aZipEntry the path of the file entry\\n+   * @param aModTime the modification time of the entry in microseconds\\n+   * @param aCompression the compression level, 0 is no compression, 9 is best\\n+   * @param aStream the input stream to get the data from\\n+   * @param aQueue adds the operation to the background queue. Will be\\n+   *        performed when processQueue is called.\\n+   *\\n+   * @throws NS_ERROR_NOT_INITIALIZED if no zip file has been opened\\n+   * @throws NS_ERROR_FILE_ALREADY_EXISTS if the path already exists in the zip\\n+   * @throws NS_ERROR_IN_PROGRESS if another operation is currently in progress\\n+   */\\n+  void addEntryStream(in AUTF8String aZipEntry, in PRTime aModTime,\\n+                      in PRInt32 aCompression, in nsIInputStream aStream,\\n+                      in boolean aQueue);\\n+\\n+  /**\\n+   * Removes an existing entry from the zip file.\\n+   *\\n+   * @param aZipEntry the path of the entry to be removed\\n+   * @param aQueue adds the operation to the background queue. Will be\\n+   *        performed when processQueue is called.\\n+   *\\n+   * @throws NS_ERROR_NOT_INITIALIZED if no zip file has been opened\\n+   * @throws NS_ERROR_IN_PROGRESS if another operation is currently in progress\\n+   * @throws NS_ERROR_FILE_NOT_FOUND if no entry with the given path exists\\n+   * @throws <other-error> on failure to update the zip file\\n+   */\\n+  void removeEntry(in AUTF8String aZipEntry, in boolean aQueue);\\n+\\n+  /**\\n+   * Processes all queued items until complete or some error occurs. The\\n+   * observer will be notified when the first operation starts and when the\\n+   * last operation completes. Any failures will be passed to the observer.\\n+   * The zip writer will be busy until the queue is complete or some error\\n+   * halted processing of the queue early. In the event of an early failure,\\n+   * remaining items will stay in the queue and calling processQueue will\\n+   * continue.\\n+   *\\n+   * @throws NS_ERROR_NOT_INITIALIZED if no zip file has been opened\\n+   * @throws NS_ERROR_IN_PROGRESS if the queue is already in progress\\n+   */\\n+  void processQueue(in nsIRequestObserver aObserver, in nsISupports aContext);\\n+\\n+  /**\\n+   * Closes the zip file.\\n+   *\\n+   * @throws NS_ERROR_NOT_INITIALIZED if no zip file has been opened\\n+   * @throws NS_ERROR_IN_PROGRESS if another operation is currently in progress\\n+   * @throws <other-error> on failure to complete the zip file\\n+   */\\n+  void close();\\n+};\\ndiff --git a/modules/libjar/zipwriter/src/Makefile.in b/modules/libjar/zipwriter/src/Makefile.in\\nnew file mode 100644\\nindex 0000000..0ab79a6\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/src/Makefile.in\\n@@ -0,0 +1,74 @@\\n+# ***** BEGIN LICENSE BLOCK *****\\n+# Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+#\\n+# The contents of this file are subject to the Mozilla Public License Version\\n+# 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+# the License. You may obtain a copy of the License at\\n+# http://www.mozilla.org/MPL/\\n+#\\n+# Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+# for the specific language governing rights and limitations under the\\n+# License.\\n+#\\n+# The Original Code is Zip Writer Component.\\n+#\\n+# The Initial Developer of the Original Code is\\n+# Dave Townsend <dtownsend@oxymoronical.com>.\\n+#\\n+# Portions created by the Initial Developer are Copyright (C) 2007\\n+# the Initial Developer. All Rights Reserved.\\n+#\\n+# Contributor(s):\\n+#\\n+# Alternatively, the contents of this file may be used under the terms of\\n+# either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+# the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+# in which case the provisions of the GPL or the LGPL are applicable instead\\n+# of those above. If you wish to allow use of your version of this file only\\n+# under the terms of either the GPL or the LGPL, and not to allow others to\\n+# use your version of this file under the terms of the MPL, indicate your\\n+# decision by deleting the provisions above and replace them with the notice\\n+# and other provisions required by the GPL or the LGPL. If you do not delete\\n+# the provisions above, a recipient may use your version of this file under\\n+# the terms of any one of the MPL, the GPL or the LGPL.\\n+#\\n+# ***** END LICENSE BLOCK *****\\n+\\n+DEPTH                 = ../../../..\\n+topsrcdir             = @top_srcdir@\\n+srcdir                = @srcdir@\\n+VPATH                 = @srcdir@\\n+\\n+include $(DEPTH)/config/autoconf.mk\\n+\\n+MODULE                = zipwriter\\n+LIBRARY_NAME          = zipwriter\\n+MODULE_NAME           = ZipWriterModule\\n+EXPORT_LIBRARY        = 1\\n+LIBXUL_LIBRARY        = 1\\n+IS_COMPONENT          = 1\\n+\\n+REQUIRES = \\\\\\n+  xpcom \\\\\\n+  string \\\\\\n+  necko \\\\\\n+  jar \\\\\\n+  $(ZLIB_REQUIRES) \\\\\\n+  $(NULL)\\n+\\n+CPPSRCS = \\\\\\n+  StreamFunctions.cpp \\\\\\n+  nsDeflateConverter.cpp \\\\\\n+  nsZipHeader.cpp \\\\\\n+  nsZipDataStream.cpp \\\\\\n+  nsZipWriter.cpp \\\\\\n+  ZipWriterModule.cpp \\\\\\n+  $(NULL)\\n+\\n+include $(topsrcdir)/config/rules.mk\\n+\\n+EXTRA_DSO_LDOPTS += \\\\\\n+  $(MOZ_COMPONENT_LIBS) \\\\\\n+  $(ZLIB_LIBS) \\\\\\n+  $(NULL)\\ndiff --git a/modules/libjar/zipwriter/src/StreamFunctions.cpp b/modules/libjar/zipwriter/src/StreamFunctions.cpp\\nnew file mode 100644\\nindex 0000000..ad0456b\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/src/StreamFunctions.cpp\\n@@ -0,0 +1,82 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *      Mook <mook.moz+random.code@gmail.com>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+#include \\\"nscore.h\\\"\\n+#include \\\"nsIInputStream.h\\\"\\n+#include \\\"nsIOutputStream.h\\\"\\n+\\n+/*\\n+ * Fully reads the required amount of data. Keeps reading until all the\\n+ * data is retrieved or an error is hit.\\n+ */\\n+NS_HIDDEN_(nsresult) ZW_ReadData(nsIInputStream *aStream, char *aBuffer, PRUint32 aCount)\\n+{\\n+    while (aCount > 0) {\\n+        PRUint32 read;\\n+        nsresult rv = aStream->Read(aBuffer, aCount, &read);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+        aCount -= read;\\n+        aBuffer += read;\\n+        // If we hit EOF before reading the data we need then throw.\\n+        if (read == 0 && aCount > 0)\\n+            return NS_ERROR_FAILURE;\\n+    }\\n+\\n+    return NS_OK;\\n+}\\n+\\n+/*\\n+ * Fully writes the required amount of data. Keeps writing untill all the\\n+ * data is written or an error is hit.\\n+ */\\n+NS_HIDDEN_(nsresult) ZW_WriteData(nsIOutputStream *aStream, const char *aBuffer,\\n+                                  PRUint32 aCount)\\n+{\\n+    while (aCount > 0) {\\n+        PRUint32 written;\\n+        nsresult rv = aStream->Write(aBuffer, aCount, &written);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+        if (written <= 0)\\n+            return NS_ERROR_FAILURE;\\n+        aCount -= written;\\n+        aBuffer += written;\\n+    }\\n+\\n+    return NS_OK;\\n+}\\ndiff --git a/modules/libjar/zipwriter/src/StreamFunctions.h b/modules/libjar/zipwriter/src/StreamFunctions.h\\nnew file mode 100644\\nindex 0000000..b1f7d2b\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/src/StreamFunctions.h\\n@@ -0,0 +1,98 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *      Mook <mook.moz+random.code@gmail.com>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+#ifndef _nsStreamFunctions_h_\\n+#define _nsStreamFunctions_h_\\n+\\n+#include \\\"nscore.h\\\"\\n+#include \\\"nsIInputStream.h\\\"\\n+#include \\\"nsIOutputStream.h\\\"\\n+\\n+/*\\n+ * ZIP file data is stored little-endian. These are helper functions to read and\\n+ * write little endian data to/from a char buffer.\\n+ * The off argument is incremented according to the number of bytes consumed\\n+ * from the buffer.\\n+ */\\n+inline NS_HIDDEN_(void) WRITE8(char* buf, PRUint32* off, PRUint8 val)\\n+{\\n+  buf[(*off)++] = val & 0xff;\\n+}\\n+\\n+inline NS_HIDDEN_(void) WRITE16(char* buf, PRUint32* off, PRUint16 val)\\n+{\\n+  buf[(*off)++] = val & 0xff;\\n+  buf[(*off)++] = (val >> 8) & 0xff;\\n+}\\n+\\n+inline NS_HIDDEN_(void) WRITE32(char* buf, PRUint32* off, PRUint32 val)\\n+{\\n+  buf[(*off)++] = val & 0xff;\\n+  buf[(*off)++] = (val >> 8) & 0xff;\\n+  buf[(*off)++] = (val >> 16) & 0xff;\\n+  buf[(*off)++] = (val >> 24) & 0xff;\\n+}\\n+\\n+inline NS_HIDDEN_(PRUint8) READ8(char* buf, PRUint32* off)\\n+{\\n+  return (PRUint8)buf[(*off)++];\\n+}\\n+\\n+inline NS_HIDDEN_(PRUint16) READ16(char* buf, PRUint32* off)\\n+{\\n+  PRUint16 val = (PRUint16)buf[(*off)++] & 0xff;\\n+  val |= ((PRUint16)buf[(*off)++] & 0xff) << 8;\\n+  return val;\\n+}\\n+\\n+inline NS_HIDDEN_(PRUint32) READ32(char* buf, PRUint32* off)\\n+{\\n+  PRUint32 val = (PRUint32)buf[(*off)++] & 0xff;\\n+  val |= ((PRUint32)buf[(*off)++] & 0xff) << 8;\\n+  val |= ((PRUint32)buf[(*off)++] & 0xff) << 16;\\n+  val |= ((PRUint32)buf[(*off)++] & 0xff) << 24;\\n+  return val;\\n+}\\n+\\n+NS_HIDDEN_(nsresult) ZW_ReadData(nsIInputStream *aStream, char *aBuffer, PRUint32 aCount);\\n+\\n+NS_HIDDEN_(nsresult) ZW_WriteData(nsIOutputStream *aStream, const char *aBuffer,\\n+                      PRUint32 aCount);\\n+\\n+#endif\\ndiff --git a/modules/libjar/zipwriter/src/ZipWriterModule.cpp b/modules/libjar/zipwriter/src/ZipWriterModule.cpp\\nnew file mode 100644\\nindex 0000000..9d66658\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/src/ZipWriterModule.cpp\\n@@ -0,0 +1,62 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+#include \\\"nsIGenericFactory.h\\\"\\n+#include \\\"nsDeflateConverter.h\\\"\\n+#include \\\"nsZipWriter.h\\\"\\n+\\n+NS_GENERIC_FACTORY_CONSTRUCTOR(nsDeflateConverter)\\n+NS_GENERIC_FACTORY_CONSTRUCTOR(nsZipWriter)\\n+\\n+static nsModuleComponentInfo components[] =\\n+{\\n+  {\\n+    DEFLATECONVERTER_CLASSNAME,\\n+    DEFLATECONVERTER_CID,\\n+    DEFLATECONVERTER_CONTRACTID,\\n+    nsDeflateConverterConstructor,\\n+  },\\n+  {\\n+    ZIPWRITER_CLASSNAME,\\n+    ZIPWRITER_CID,\\n+    ZIPWRITER_CONTRACTID,\\n+    nsZipWriterConstructor,\\n+  }\\n+};\\n+\\n+NS_IMPL_NSGETMODULE(ZipWriterModule, components)\\ndiff --git a/modules/libjar/zipwriter/src/nsDeflateConverter.cpp b/modules/libjar/zipwriter/src/nsDeflateConverter.cpp\\nnew file mode 100644\\nindex 0000000..f57f56c\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/src/nsDeflateConverter.cpp\\n@@ -0,0 +1,198 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *      Lan Qiang <jameslan@gmail.com>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+#include \\\"StreamFunctions.h\\\"\\n+#include \\\"nsDeflateConverter.h\\\"\\n+#include \\\"nsIStringStream.h\\\"\\n+#include \\\"nsIInputStreamPump.h\\\"\\n+#include \\\"nsComponentManagerUtils.h\\\"\\n+#include \\\"nsMemory.h\\\"\\n+#include \\\"nsAutoPtr.h\\\"\\n+\\n+/**\\n+ * nsDeflateConverter is a stream converter applies the deflate compression\\n+ * method to the data.\\n+ */\\n+NS_IMPL_ISUPPORTS3(nsDeflateConverter, nsIStreamConverter,\\n+                                       nsIStreamListener,\\n+                                       nsIRequestObserver)\\n+\\n+nsresult nsDeflateConverter::Init()\\n+{\\n+    int zerr;\\n+\\n+    mOffset = 0;\\n+\\n+    mZstream.zalloc = Z_NULL;\\n+    mZstream.zfree = Z_NULL;\\n+    mZstream.opaque = Z_NULL;\\n+\\n+    zerr = deflateInit2(&mZstream, mLevel, Z_DEFLATED, -MAX_WBITS, 8,\\n+                        Z_DEFAULT_STRATEGY);\\n+    if (zerr != Z_OK) return NS_ERROR_OUT_OF_MEMORY;\\n+\\n+    mZstream.next_out = mWriteBuffer;\\n+    mZstream.avail_out = sizeof(mWriteBuffer);\\n+\\n+    return NS_OK;\\n+}\\n+\\n+/* nsIInputStream convert (in nsIInputStream aFromStream, in string aFromType\\n+ *                         in string aToType, in nsISupports aCtxt); */\\n+NS_IMETHODIMP nsDeflateConverter::Convert(nsIInputStream *aFromStream,\\n+                                          const char *aFromType,\\n+                                          const char *aToType,\\n+                                          nsISupports *aCtxt,\\n+                                          nsIInputStream **_retval)\\n+{\\n+    return NS_ERROR_NOT_IMPLEMENTED;\\n+}\\n+\\n+/* void asyncConvertData (in string aFromType, in string aToType,\\n+ *                        in nsIStreamListener aListener,\\n+ *                        in nsISupports aCtxt); */\\n+NS_IMETHODIMP nsDeflateConverter::AsyncConvertData(const char *aFromType,\\n+                                                   const char *aToType,\\n+                                                   nsIStreamListener *aListener,\\n+                                                   nsISupports *aCtxt)\\n+{\\n+    if (mListener)\\n+        return NS_ERROR_ALREADY_INITIALIZED;\\n+\\n+    NS_ENSURE_ARG_POINTER(aListener);\\n+\\n+    nsresult rv = Init();\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    mListener = aListener;\\n+    mContext = aCtxt;\\n+    return rv;\\n+}\\n+\\n+/* void onDataAvailable (in nsIRequest aRequest, in nsISupports aContext,\\n+ *                       in nsIInputStream aInputStream,\\n+ *                       in unsigned long aOffset, in unsigned long aCount); */\\n+NS_IMETHODIMP nsDeflateConverter::OnDataAvailable(nsIRequest *aRequest,\\n+                                                  nsISupports *aContext,\\n+                                                  nsIInputStream *aInputStream,\\n+                                                  PRUint32 aOffset,\\n+                                                  PRUint32 aCount)\\n+{\\n+    if (!mListener)\\n+        return NS_ERROR_NOT_INITIALIZED;\\n+\\n+    nsAutoArrayPtr<char> buffer(new char[aCount]);\\n+    NS_ENSURE_TRUE(buffer, NS_ERROR_OUT_OF_MEMORY);\\n+\\n+    nsresult rv = ZW_ReadData(aInputStream, buffer.get(), aCount);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    // make sure we aren't reading too much\\n+    mZstream.avail_in = aCount;\\n+    mZstream.next_in = (unsigned char*)buffer.get();\\n+\\n+    int zerr = Z_OK;\\n+    // deflate loop\\n+    while (mZstream.avail_in > 0 && zerr == Z_OK) {\\n+        zerr = deflate(&mZstream, Z_NO_FLUSH);\\n+\\n+        while (mZstream.avail_out == 0) {\\n+            // buffer is full, push the data out to the listener\\n+            rv = PushAvailableData(aRequest, aContext);\\n+            NS_ENSURE_SUCCESS(rv, rv);\\n+            zerr = deflate(&mZstream, Z_NO_FLUSH);\\n+        }\\n+    }\\n+\\n+    return NS_OK;\\n+}\\n+\\n+/* void onStartRequest (in nsIRequest aRequest, in nsISupports aContext); */\\n+NS_IMETHODIMP nsDeflateConverter::OnStartRequest(nsIRequest *aRequest,\\n+                                                 nsISupports *aContext)\\n+{\\n+    if (!mListener)\\n+        return NS_ERROR_NOT_INITIALIZED;\\n+\\n+    return mListener->OnStartRequest(aRequest, mContext);\\n+}\\n+\\n+/* void onStopRequest (in nsIRequest aRequest, in nsISupports aContext,\\n+ *                     in nsresult aStatusCode); */\\n+NS_IMETHODIMP nsDeflateConverter::OnStopRequest(nsIRequest *aRequest,\\n+                                                nsISupports *aContext,\\n+                                                nsresult aStatusCode)\\n+{\\n+    if (!mListener)\\n+        return NS_ERROR_NOT_INITIALIZED;\\n+\\n+    nsresult rv;\\n+\\n+    int zerr;\\n+    do {\\n+        zerr = deflate(&mZstream, Z_FINISH);\\n+        rv = PushAvailableData(aRequest, aContext);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+    } while (zerr == Z_OK);\\n+\\n+    deflateEnd(&mZstream);\\n+\\n+    return mListener->OnStopRequest(aRequest, mContext, aStatusCode);\\n+}\\n+\\n+nsresult nsDeflateConverter::PushAvailableData(nsIRequest *aRequest,\\n+                                               nsISupports *aContext)\\n+{\\n+    nsresult rv;\\n+    nsCOMPtr<nsIStringInputStream> stream =\\n+             do_CreateInstance(\\\"@mozilla.org/io/string-input-stream;1\\\", &rv);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    PRUint32 bytesToWrite = ZIP_BUFLEN - mZstream.avail_out;\\n+    stream->ShareData((char*)mWriteBuffer, bytesToWrite);\\n+    rv = mListener->OnDataAvailable(aRequest, mContext, stream, mOffset,\\n+                                    bytesToWrite);\\n+\\n+    // now set the state for 'deflate'\\n+    mZstream.next_out = mWriteBuffer;\\n+    mZstream.avail_out = sizeof(mWriteBuffer);\\n+\\n+    mOffset += bytesToWrite;\\n+    return rv;\\n+}\\ndiff --git a/modules/libjar/zipwriter/src/nsDeflateConverter.h b/modules/libjar/zipwriter/src/nsDeflateConverter.h\\nnew file mode 100644\\nindex 0000000..8079ac2\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/src/nsDeflateConverter.h\\n@@ -0,0 +1,91 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *      Lan Qiang <jameslan@gmail.com>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+#ifndef _nsDeflateConverter_h_\\n+#define _nsDeflateConverter_h_\\n+\\n+#include \\\"nsIStreamConverter.h\\\"\\n+#include \\\"nsCOMPtr.h\\\"\\n+#include \\\"nsIPipe.h\\\"\\n+#include \\\"zlib.h\\\"\\n+\\n+#define DEFLATECONVERTER_CONTRACTID \\\\\\n+           \\\"@mozilla.org/streamconv;1?from=uncompressed&to=deflate\\\"\\n+#define DEFLATECONVERTER_CLASSNAME \\\"Deflate converter\\\"\\n+#define DEFLATECONVERTER_CID { 0x461cd5dd, 0x73c6, 0x47a4, \\\\\\n+           { 0x8c, 0xc3, 0x60, 0x3b, 0x37, 0xd8, 0x4a, 0x61 } }\\n+\\n+#define ZIP_BUFLEN (4 * 1024 - 1)\\n+\\n+class nsDeflateConverter : public nsIStreamConverter\\n+{\\n+public:\\n+    NS_DECL_ISUPPORTS\\n+    NS_DECL_NSIREQUESTOBSERVER\\n+    NS_DECL_NSISTREAMLISTENER\\n+    NS_DECL_NSISTREAMCONVERTER\\n+\\n+    nsDeflateConverter()\\n+    {\\n+        mLevel = Z_DEFAULT_COMPRESSION;\\n+    }\\n+\\n+    nsDeflateConverter(PRInt32 level)\\n+    {\\n+        mLevel = level;\\n+    }\\n+\\n+private:\\n+\\n+    ~nsDeflateConverter()\\n+    {\\n+    }\\n+\\n+    PRUint32 mOffset;\\n+    PRInt32 mLevel;\\n+    nsCOMPtr<nsIStreamListener> mListener;\\n+    nsCOMPtr<nsISupports> mContext;\\n+    z_stream mZstream;\\n+    unsigned char mWriteBuffer[ZIP_BUFLEN];\\n+\\n+    nsresult Init();\\n+    nsresult PushAvailableData(nsIRequest *aRequest, nsISupports *aContext);\\n+};\\n+\\n+#endif\\ndiff --git a/modules/libjar/zipwriter/src/nsZipDataStream.cpp b/modules/libjar/zipwriter/src/nsZipDataStream.cpp\\nnew file mode 100644\\nindex 0000000..65097bb\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/src/nsZipDataStream.cpp\\n@@ -0,0 +1,230 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *      Mook <mook.moz+random.code@gmail.com>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+#include \\\"StreamFunctions.h\\\"\\n+#include \\\"nsZipDataStream.h\\\"\\n+#include \\\"nsIStringStream.h\\\"\\n+#include \\\"nsISeekableStream.h\\\"\\n+#include \\\"nsDeflateConverter.h\\\"\\n+#include \\\"nsNetUtil.h\\\"\\n+#include \\\"nsComponentManagerUtils.h\\\"\\n+#include \\\"nsMemory.h\\\"\\n+\\n+#define ZIP_METHOD_STORE 0\\n+#define ZIP_METHOD_DEFLATE 8\\n+\\n+/**\\n+ * nsZipDataStream handles the writing an entry's into the zip file.\\n+ * It is set up to wither write the data as is, or in the event that compression\\n+ * has been requested to pass it through a stream converter.\\n+ * Currently only the deflate compression method is supported.\\n+ * The CRC checksum for the entry's data is also generated here.\\n+ */\\n+NS_IMPL_THREADSAFE_ISUPPORTS2(nsZipDataStream, nsIStreamListener,\\n+                                               nsIRequestObserver)\\n+\\n+nsresult nsZipDataStream::Init(nsZipWriter *aWriter,\\n+                               nsIOutputStream *aStream,\\n+                               nsZipHeader *aHeader,\\n+                               PRInt32 aCompression)\\n+{\\n+    mWriter = aWriter;\\n+    mHeader = aHeader;\\n+    mStream = aStream;\\n+    mHeader->mCRC = crc32(0L, Z_NULL, 0);\\n+\\n+    nsresult rv = NS_NewSimpleStreamListener(getter_AddRefs(mOutput), aStream,\\n+                                             nsnull);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    if (aCompression > 0) {\\n+        mHeader->mMethod = ZIP_METHOD_DEFLATE;\\n+        nsCOMPtr<nsIStreamConverter> converter =\\n+                              new nsDeflateConverter(aCompression);\\n+        NS_ENSURE_TRUE(converter, NS_ERROR_OUT_OF_MEMORY);\\n+\\n+        rv = converter->AsyncConvertData(\\\"uncompressed\\\", \\\"deflate\\\", mOutput,\\n+                                         nsnull);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+        mOutput = do_QueryInterface(converter, &rv);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+    }\\n+    else {\\n+        mHeader->mMethod = ZIP_METHOD_STORE;\\n+    }\\n+\\n+    return NS_OK;\\n+}\\n+\\n+/* void onDataAvailable (in nsIRequest aRequest, in nsISupports aContext,\\n+ *                       in nsIInputStream aInputStream,\\n+ *                       in unsigned long aOffset, in unsigned long aCount); */\\n+NS_IMETHODIMP nsZipDataStream::OnDataAvailable(nsIRequest *aRequest,\\n+                                               nsISupports *aContext,\\n+                                               nsIInputStream *aInputStream,\\n+                                               PRUint32 aOffset,\\n+                                               PRUint32 aCount)\\n+{\\n+    if (!mOutput)\\n+        return NS_ERROR_NOT_INITIALIZED;\\n+\\n+    nsAutoArrayPtr<char> buffer(new char[aCount]);\\n+    NS_ENSURE_TRUE(buffer, NS_ERROR_OUT_OF_MEMORY);\\n+\\n+    nsresult rv = ZW_ReadData(aInputStream, buffer.get(), aCount);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    return ProcessData(aRequest, aContext, buffer.get(), aOffset, aCount);\\n+}\\n+\\n+/* void onStartRequest (in nsIRequest aRequest, in nsISupports aContext); */\\n+NS_IMETHODIMP nsZipDataStream::OnStartRequest(nsIRequest *aRequest,\\n+                                              nsISupports *aContext)\\n+{\\n+    if (!mOutput)\\n+        return NS_ERROR_NOT_INITIALIZED;\\n+\\n+    return mOutput->OnStartRequest(aRequest, aContext);\\n+}\\n+\\n+/* void onStopRequest (in nsIRequest aRequest, in nsISupports aContext,\\n+ *                     in nsresult aStatusCode); */\\n+NS_IMETHODIMP nsZipDataStream::OnStopRequest(nsIRequest *aRequest,\\n+                                             nsISupports *aContext,\\n+                                             nsresult aStatusCode)\\n+{\\n+    if (!mOutput)\\n+        return NS_ERROR_NOT_INITIALIZED;\\n+\\n+    nsresult rv = mOutput->OnStopRequest(aRequest, aContext, aStatusCode);\\n+    mOutput = nsnull;\\n+    if (NS_FAILED(rv)) {\\n+        mWriter->EntryCompleteCallback(mHeader, rv);\\n+    }\\n+    else {\\n+        rv = CompleteEntry();\\n+        rv = mWriter->EntryCompleteCallback(mHeader, rv);\\n+    }\\n+\\n+    mStream = nsnull;\\n+    mWriter = nsnull;\\n+    mHeader = nsnull;\\n+\\n+    return rv;\\n+}\\n+\\n+inline nsresult nsZipDataStream::CompleteEntry()\\n+{\\n+    nsresult rv = mStream->Flush();\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mStream, &rv);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    PRInt64 pos;\\n+    rv = seekable->Tell(&pos);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    mHeader->mCSize = pos - mHeader->mOffset - mHeader->GetFileHeaderLength();\\n+\\n+    // Go back and rewrite the file header\\n+    rv = seekable->Seek(nsISeekableStream::NS_SEEK_SET, mHeader->mOffset);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    rv = mHeader->WriteFileHeader(mStream);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    rv = mStream->Flush();\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    rv = seekable->Seek(nsISeekableStream::NS_SEEK_SET, pos);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    return NS_OK;\\n+}\\n+\\n+nsresult nsZipDataStream::ProcessData(nsIRequest *aRequest,\\n+                                      nsISupports *aContext, char *aBuffer,\\n+                                      PRUint32 aOffset, PRUint32 aCount)\\n+{\\n+    mHeader->mCRC = crc32(mHeader->mCRC,\\n+                          reinterpret_cast<const unsigned char*>(aBuffer),\\n+                          aCount);\\n+\\n+    nsresult rv;\\n+    nsCOMPtr<nsIStringInputStream> stream =\\n+             do_CreateInstance(\\\"@mozilla.org/io/string-input-stream;1\\\", &rv);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    stream->ShareData(aBuffer, aCount);\\n+    rv = mOutput->OnDataAvailable(aRequest, aContext, stream, aOffset, aCount);\\n+    mHeader->mUSize += aCount;\\n+\\n+    return rv;\\n+}\\n+\\n+nsresult nsZipDataStream::ReadStream(nsIInputStream *aStream)\\n+{\\n+    if (!mOutput)\\n+        return NS_ERROR_NOT_INITIALIZED;\\n+\\n+    nsresult rv = OnStartRequest(nsnull, nsnull);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    nsAutoArrayPtr<char> buffer(new char[4096]);\\n+    NS_ENSURE_TRUE(buffer, NS_ERROR_OUT_OF_MEMORY);\\n+\\n+    PRUint32 read = 0;\\n+    PRUint32 offset = 0;\\n+    do\\n+    {\\n+        rv = aStream->Read(buffer.get(), 4096, &read);\\n+        if (NS_FAILED(rv)) {\\n+            OnStopRequest(nsnull, nsnull, rv);\\n+            return rv;\\n+        }\\n+\\n+        if (read > 0) {\\n+            rv = ProcessData(nsnull, nsnull, buffer.get(), offset, read);\\n+            if (NS_FAILED(rv)) {\\n+                OnStopRequest(nsnull, nsnull, rv);\\n+                return rv;\\n+            }\\n+            offset += read;\\n+        }\\n+    } while (read > 0);\\n+\\n+    return OnStopRequest(nsnull, nsnull, NS_OK);\\n+}\\ndiff --git a/modules/libjar/zipwriter/src/nsZipDataStream.h b/modules/libjar/zipwriter/src/nsZipDataStream.h\\nnew file mode 100644\\nindex 0000000..7f3723a\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/src/nsZipDataStream.h\\n@@ -0,0 +1,76 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *      Mook <mook.moz+random.code@gmail.com>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+#ifndef _nsZipDataStream_h_\\n+#define _nsZipDataStream_h_\\n+\\n+#include \\\"nsZipWriter.h\\\"\\n+#include \\\"nsIOutputStream.h\\\"\\n+#include \\\"nsIStreamListener.h\\\"\\n+#include \\\"nsAutoPtr.h\\\"\\n+\\n+class nsZipDataStream : public nsIStreamListener\\n+{\\n+public:\\n+    NS_DECL_ISUPPORTS\\n+    NS_DECL_NSIREQUESTOBSERVER\\n+    NS_DECL_NSISTREAMLISTENER\\n+\\n+    nsZipDataStream()\\n+    {\\n+    }\\n+\\n+    nsresult Init(nsZipWriter *aWriter, nsIOutputStream *aStream,\\n+                  nsZipHeader *aHeader, PRInt32 aCompression);\\n+\\n+    nsresult ReadStream(nsIInputStream *aStream);\\n+\\n+private:\\n+\\n+    nsCOMPtr<nsIStreamListener> mOutput;\\n+    nsCOMPtr<nsIOutputStream> mStream;\\n+    nsRefPtr<nsZipWriter> mWriter;\\n+    nsRefPtr<nsZipHeader> mHeader;\\n+\\n+    nsresult CompleteEntry();\\n+    nsresult ProcessData(nsIRequest *aRequest, nsISupports *aContext,\\n+                         char *aBuffer, PRUint32 aOffset, PRUint32 aCount);\\n+};\\n+\\n+#endif\\ndiff --git a/modules/libjar/zipwriter/src/nsZipHeader.cpp b/modules/libjar/zipwriter/src/nsZipHeader.cpp\\nnew file mode 100644\\nindex 0000000..0a59089\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/src/nsZipHeader.cpp\\n@@ -0,0 +1,292 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+#include \\\"StreamFunctions.h\\\"\\n+#include \\\"nsZipHeader.h\\\"\\n+#include \\\"nsMemory.h\\\"\\n+\\n+#define ZIP_FILE_HEADER_SIGNATURE 0x04034b50\\n+#define ZIP_FILE_HEADER_SIZE 30\\n+#define ZIP_CDS_HEADER_SIGNATURE 0x02014b50\\n+#define ZIP_CDS_HEADER_SIZE 46\\n+\\n+#define FLAGS_IS_UTF8 0x800\\n+\\n+/**\\n+ * nsZipHeader represents an entry from a zip file.\\n+ */\\n+NS_IMPL_ISUPPORTS1(nsZipHeader, nsIZipEntry)\\n+\\n+/* readonly attribute unsigned short compression; */\\n+NS_IMETHODIMP nsZipHeader::GetCompression(PRUint16 *aCompression)\\n+{\\n+    NS_ASSERTION(mInited, \\\"Not initalised\\\");\\n+\\n+    *aCompression = mMethod;\\n+    return NS_OK;\\n+}\\n+\\n+/* readonly attribute unsigned long size; */\\n+NS_IMETHODIMP nsZipHeader::GetSize(PRUint32 *aSize)\\n+{\\n+    NS_ASSERTION(mInited, \\\"Not initalised\\\");\\n+\\n+    *aSize = mCSize;\\n+    return NS_OK;\\n+}\\n+\\n+/* readonly attribute unsigned long realSize; */\\n+NS_IMETHODIMP nsZipHeader::GetRealSize(PRUint32 *aRealSize)\\n+{\\n+    NS_ASSERTION(mInited, \\\"Not initalised\\\");\\n+\\n+    *aRealSize = mUSize;\\n+    return NS_OK;\\n+}\\n+\\n+/* readonly attribute unsigned long CRC32; */\\n+NS_IMETHODIMP nsZipHeader::GetCRC32(PRUint32 *aCRC32)\\n+{\\n+    NS_ASSERTION(mInited, \\\"Not initalised\\\");\\n+\\n+    *aCRC32 = mCRC;\\n+    return NS_OK;\\n+}\\n+\\n+/* readonly attribute boolean isDirectory; */\\n+NS_IMETHODIMP nsZipHeader::GetIsDirectory(PRBool *aIsDirectory)\\n+{\\n+    NS_ASSERTION(mInited, \\\"Not initalised\\\");\\n+\\n+    if (mName.Last() == '/')\\n+        *aIsDirectory = PR_TRUE;\\n+    else\\n+        *aIsDirectory = PR_FALSE;\\n+    return NS_OK;\\n+}\\n+\\n+/* readonly attribute PRTime lastModifiedTime; */\\n+NS_IMETHODIMP nsZipHeader::GetLastModifiedTime(PRTime *aLastModifiedTime)\\n+{\\n+    NS_ASSERTION(mInited, \\\"Not initalised\\\");\\n+\\n+    PRExplodedTime time;\\n+\\n+    time.tm_usec = 0;\\n+\\n+    time.tm_hour = mTime >> 11;\\n+    time.tm_min = (mTime >> 5) & 0x3F;\\n+    time.tm_sec = (mTime & 0x1F) * 2;\\n+\\n+    time.tm_year = (mDate >> 9) + 1980;\\n+    time.tm_month = ((mDate >> 5) & 0x0F) - 1;\\n+    time.tm_mday = mDate & 0x1F;\\n+\\n+    time.tm_params.tp_gmt_offset = 0;\\n+    time.tm_params.tp_dst_offset = 0;\\n+\\n+    PR_NormalizeTime(&time, PR_GMTParameters);\\n+    time.tm_params = PR_LocalTimeParameters(&time);\\n+\\n+    *aLastModifiedTime = PR_ImplodeTime(&time);\\n+\\n+    return NS_OK;\\n+}\\n+\\n+/* readonly attribute boolean isSynthetic; */\\n+NS_IMETHODIMP nsZipHeader::GetIsSynthetic(PRBool *aIsSynthetic)\\n+{\\n+    NS_ASSERTION(mInited, \\\"Not initalised\\\");\\n+\\n+    *aIsSynthetic = PR_FALSE;\\n+    return NS_OK;\\n+}\\n+\\n+void nsZipHeader::Init(const nsACString & aPath, PRTime aDate, PRUint32 aAttr,\\n+                       PRUint32 aOffset)\\n+{\\n+    NS_ASSERTION(!mInited, \\\"Already initalised\\\");\\n+\\n+    PRExplodedTime time;\\n+    PR_ExplodeTime(aDate, PR_LocalTimeParameters, &time);\\n+\\n+    mTime = time.tm_sec / 2 + (time.tm_min << 5) + (time.tm_hour << 11);\\n+    mDate = time.tm_mday + ((time.tm_month + 1) << 5) +\\n+            ((time.tm_year - 1980) << 9);\\n+\\n+    mEAttr = aAttr;\\n+    mOffset = aOffset;\\n+    mName = aPath;\\n+    mComment = NS_LITERAL_CSTRING(\\\"\\\");\\n+    // Claim a UTF-8 path in case it needs it.\\n+    mFlags |= FLAGS_IS_UTF8;\\n+    mInited = PR_TRUE;\\n+}\\n+\\n+PRUint32 nsZipHeader::GetFileHeaderLength()\\n+{\\n+    return ZIP_FILE_HEADER_SIZE + mName.Length();\\n+}\\n+\\n+nsresult nsZipHeader::WriteFileHeader(nsIOutputStream *aStream)\\n+{\\n+    NS_ASSERTION(mInited, \\\"Not initalised\\\");\\n+\\n+    char buf[ZIP_FILE_HEADER_SIZE];\\n+    PRUint32 pos = 0;\\n+    WRITE32(buf, &pos, ZIP_FILE_HEADER_SIGNATURE);\\n+    WRITE16(buf, &pos, mVersionNeeded);\\n+    WRITE16(buf, &pos, mFlags);\\n+    WRITE16(buf, &pos, mMethod);\\n+    WRITE16(buf, &pos, mTime);\\n+    WRITE16(buf, &pos, mDate);\\n+    WRITE32(buf, &pos, mCRC);\\n+    WRITE32(buf, &pos, mCSize);\\n+    WRITE32(buf, &pos, mUSize);\\n+    WRITE16(buf, &pos, mName.Length());\\n+    WRITE16(buf, &pos, 0);\\n+\\n+    nsresult rv = ZW_WriteData(aStream, buf, pos);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    return ZW_WriteData(aStream, mName.get(), mName.Length());\\n+}\\n+\\n+PRUint32 nsZipHeader::GetCDSHeaderLength()\\n+{\\n+    return ZIP_CDS_HEADER_SIZE + mName.Length() + mComment.Length() +\\n+           mFieldLength;\\n+}\\n+\\n+nsresult nsZipHeader::WriteCDSHeader(nsIOutputStream *aStream)\\n+{\\n+    NS_ASSERTION(mInited, \\\"Not initalised\\\");\\n+\\n+    char buf[ZIP_CDS_HEADER_SIZE];\\n+    PRUint32 pos = 0;\\n+    WRITE32(buf, &pos, ZIP_CDS_HEADER_SIGNATURE);\\n+    WRITE16(buf, &pos, mVersionMade);\\n+    WRITE16(buf, &pos, mVersionNeeded);\\n+    WRITE16(buf, &pos, mFlags);\\n+    WRITE16(buf, &pos, mMethod);\\n+    WRITE16(buf, &pos, mTime);\\n+    WRITE16(buf, &pos, mDate);\\n+    WRITE32(buf, &pos, mCRC);\\n+    WRITE32(buf, &pos, mCSize);\\n+    WRITE32(buf, &pos, mUSize);\\n+    WRITE16(buf, &pos, mName.Length());\\n+    WRITE16(buf, &pos, mFieldLength);\\n+    WRITE16(buf, &pos, mComment.Length());\\n+    WRITE16(buf, &pos, mDisk);\\n+    WRITE16(buf, &pos, mIAttr);\\n+    WRITE32(buf, &pos, mEAttr);\\n+    WRITE32(buf, &pos, mOffset);\\n+\\n+    nsresult rv = ZW_WriteData(aStream, buf, pos);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    rv = ZW_WriteData(aStream, mName.get(), mName.Length());\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    if (mExtraField) {\\n+        rv = ZW_WriteData(aStream, mExtraField, sizeof(mExtraField));\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+    }\\n+    return ZW_WriteData(aStream, mComment.get(), mComment.Length());\\n+}\\n+\\n+nsresult nsZipHeader::ReadCDSHeader(nsIInputStream *stream)\\n+{\\n+    NS_ASSERTION(!mInited, \\\"Already initalised\\\");\\n+\\n+    char buf[ZIP_CDS_HEADER_SIZE];\\n+\\n+    nsresult rv = ZW_ReadData(stream, buf, ZIP_CDS_HEADER_SIZE);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    PRUint32 pos = 0;\\n+    PRUint32 signature = READ32(buf, &pos);\\n+    if (signature != ZIP_CDS_HEADER_SIGNATURE)\\n+        return NS_ERROR_FILE_CORRUPTED;\\n+\\n+    mVersionMade = READ16(buf, &pos);\\n+    mVersionNeeded = READ16(buf, &pos);\\n+    mFlags = READ16(buf, &pos);\\n+    mMethod = READ16(buf, &pos);\\n+    mTime = READ16(buf, &pos);\\n+    mDate = READ16(buf, &pos);\\n+    mCRC = READ32(buf, &pos);\\n+    mCSize = READ32(buf, &pos);\\n+    mUSize = READ32(buf, &pos);\\n+    PRUint16 namelength = READ16(buf, &pos);\\n+    PRUint16 fieldlength = READ16(buf, &pos);\\n+    PRUint16 commentlength = READ16(buf, &pos);\\n+    mDisk = READ16(buf, &pos);\\n+    mIAttr = READ16(buf, &pos);\\n+    mEAttr = READ32(buf, &pos);\\n+    mOffset = READ32(buf, &pos);\\n+\\n+    if (namelength > 0) {\\n+        nsAutoArrayPtr<char> field(new char[namelength]);\\n+        NS_ENSURE_TRUE(field, NS_ERROR_OUT_OF_MEMORY);\\n+        rv = ZW_ReadData(stream, field.get(), namelength);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+        mName.Assign(field, namelength);\\n+    }\\n+    else\\n+        mName = NS_LITERAL_CSTRING(\\\"\\\");\\n+\\n+    if (fieldlength > 0) {\\n+        mExtraField = new char[fieldlength];\\n+        NS_ENSURE_TRUE(mExtraField, NS_ERROR_OUT_OF_MEMORY);\\n+        rv = ZW_ReadData(stream, mExtraField.get(), fieldlength);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+    }\\n+\\n+    if (commentlength > 0) {\\n+        nsAutoArrayPtr<char> field(new char[commentlength]);\\n+        NS_ENSURE_TRUE(field, NS_ERROR_OUT_OF_MEMORY);\\n+        rv = ZW_ReadData(stream, field.get(), commentlength);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+        mComment.Assign(field, commentlength);\\n+    }\\n+    else\\n+        mComment = NS_LITERAL_CSTRING(\\\"\\\");\\n+\\n+    mInited = PR_TRUE;\\n+    return NS_OK;\\n+}\\ndiff --git a/modules/libjar/zipwriter/src/nsZipHeader.h b/modules/libjar/zipwriter/src/nsZipHeader.h\\nnew file mode 100644\\nindex 0000000..78b5c34\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/src/nsZipHeader.h\\n@@ -0,0 +1,110 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+#ifndef _nsZipHeader_h_\\n+#define _nsZipHeader_h_\\n+\\n+#include \\\"nsString.h\\\"\\n+#include \\\"nsIOutputStream.h\\\"\\n+#include \\\"nsIInputStream.h\\\"\\n+#include \\\"nsIZipReader.h\\\"\\n+#include \\\"nsAutoPtr.h\\\"\\n+\\n+#define ZIP_ATTRS_FILE 0\\n+#define ZIP_ATTRS_DIRECTORY 16\\n+\\n+class nsZipHeader : public nsIZipEntry\\n+{\\n+public:\\n+    NS_DECL_ISUPPORTS\\n+    NS_DECL_NSIZIPENTRY\\n+\\n+    nsZipHeader() :\\n+        mCRC(0),\\n+        mCSize(0),\\n+        mUSize(0),\\n+        mEAttr(0),\\n+        mOffset(0),\\n+        mFieldLength(0),\\n+        mVersionMade(20),\\n+        mVersionNeeded(20),\\n+        mFlags(0),\\n+        mMethod(0),\\n+        mTime(0),\\n+        mDate(0),\\n+        mDisk(0),\\n+        mIAttr(0),\\n+        mInited(PR_FALSE),\\n+        mExtraField(NULL)\\n+    {\\n+    }\\n+\\n+    ~nsZipHeader()\\n+    {\\n+        mExtraField = NULL;\\n+    }\\n+\\n+    PRUint32 mCRC;\\n+    PRUint32 mCSize;\\n+    PRUint32 mUSize;\\n+    PRUint32 mEAttr;\\n+    PRUint32 mOffset;\\n+    PRUint32 mFieldLength;\\n+    PRUint16 mVersionMade;\\n+    PRUint16 mVersionNeeded;\\n+    PRUint16 mFlags;\\n+    PRUint16 mMethod;\\n+    PRUint16 mTime;\\n+    PRUint16 mDate;\\n+    PRUint16 mDisk;\\n+    PRUint16 mIAttr;\\n+    PRPackedBool mInited;\\n+    nsCString mName;\\n+    nsCString mComment;\\n+    nsAutoArrayPtr<char> mExtraField;\\n+\\n+    void Init(const nsACString & aPath, PRTime aDate, PRUint32 aAttr,\\n+              PRUint32 aOffset);\\n+    PRUint32 GetFileHeaderLength();\\n+    nsresult WriteFileHeader(nsIOutputStream *aStream);\\n+    PRUint32 GetCDSHeaderLength();\\n+    nsresult WriteCDSHeader(nsIOutputStream *aStream);\\n+    nsresult ReadCDSHeader(nsIInputStream *aStream);\\n+};\\n+\\n+#endif\\ndiff --git a/modules/libjar/zipwriter/src/nsZipWriter.cpp b/modules/libjar/zipwriter/src/nsZipWriter.cpp\\nnew file mode 100644\\nindex 0000000..1030044\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/src/nsZipWriter.cpp\\n@@ -0,0 +1,1033 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *      Mook <mook.moz+random.code@gmail.com>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+#include \\\"StreamFunctions.h\\\"\\n+#include \\\"nsZipWriter.h\\\"\\n+#include \\\"nsZipDataStream.h\\\"\\n+#include \\\"nsISeekableStream.h\\\"\\n+#include \\\"nsIAsyncStreamCopier.h\\\"\\n+#include \\\"nsIStreamListener.h\\\"\\n+#include \\\"nsIInputStreamPump.h\\\"\\n+#include \\\"nsComponentManagerUtils.h\\\"\\n+#include \\\"nsMemory.h\\\"\\n+#include \\\"nsNetError.h\\\"\\n+#include \\\"nsStreamUtils.h\\\"\\n+#include \\\"nsThreadUtils.h\\\"\\n+#include \\\"nsNetUtil.h\\\"\\n+#include \\\"prio.h\\\"\\n+\\n+#define ZIP_EOCDR_HEADER_SIZE 22\\n+#define ZIP_EOCDR_HEADER_SIGNATURE 0x06054b50\\n+\\n+/**\\n+ * nsZipWriter is used to create and add to zip files.\\n+ * It is based on the spec available at\\n+ * http://www.pkware.com/documents/casestudies/APPNOTE.TXT.\\n+ * \\n+ * The basic structure of a zip file created is slightly simpler than that\\n+ * illustrated in the spec because certain features of the zip format are\\n+ * unsupported:\\n+ * \\n+ * [local file header 1]\\n+ * [file data 1]\\n+ * . \\n+ * .\\n+ * .\\n+ * [local file header n]\\n+ * [file data n]\\n+ * [central directory]\\n+ * [end of central directory record]\\n+ */\\n+NS_IMPL_ISUPPORTS2(nsZipWriter, nsIZipWriter,\\n+                                nsIRequestObserver)\\n+\\n+nsZipWriter::nsZipWriter()\\n+{\\n+    mEntryHash.Init();\\n+    mInQueue = PR_FALSE;\\n+}\\n+\\n+nsZipWriter::~nsZipWriter()\\n+{\\n+    if (mStream && !mInQueue)\\n+        Close();\\n+}\\n+\\n+/* attribute AString comment; */\\n+NS_IMETHODIMP nsZipWriter::GetComment(nsACString & aComment)\\n+{\\n+    if (!mStream)\\n+        return NS_ERROR_NOT_INITIALIZED;\\n+\\n+    aComment = mComment;\\n+    return NS_OK;\\n+}\\n+\\n+NS_IMETHODIMP nsZipWriter::SetComment(const nsACString & aComment)\\n+{\\n+    if (!mStream)\\n+        return NS_ERROR_NOT_INITIALIZED;\\n+\\n+    mComment = aComment;\\n+    mCDSDirty = PR_TRUE;\\n+    return NS_OK;\\n+}\\n+\\n+/* readonly attribute boolean inQueue; */\\n+NS_IMETHODIMP nsZipWriter::GetInQueue(PRBool *aInQueue)\\n+{\\n+    *aInQueue = mInQueue;\\n+    return NS_OK;\\n+}\\n+\\n+/* readonly attribute nsIFile file; */\\n+NS_IMETHODIMP nsZipWriter::GetFile(nsIFile **aFile)\\n+{\\n+    nsCOMPtr<nsIFile> file;\\n+    nsresult rv = mFile->Clone(getter_AddRefs(file));\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    NS_ADDREF(*aFile = file);\\n+    return NS_OK;\\n+}\\n+\\n+/*\\n+ * Reads file entries out of an existing zip file.\\n+ */\\n+nsresult nsZipWriter::ReadFile(nsIFile *aFile)\\n+{\\n+    PRInt64 size;\\n+    nsresult rv = aFile->GetFileSize(&size);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    nsCOMPtr<nsIInputStream> inputStream;\\n+    rv = NS_NewLocalFileInputStream(getter_AddRefs(inputStream), aFile);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    char buf[1024];\\n+    PRInt64 seek = size - 1024;\\n+    PRUint32 length = 1024;\\n+\\n+    if (seek < 0) {\\n+        length += seek;\\n+        seek = 0;\\n+    }\\n+\\n+    PRUint32 pos;\\n+    PRUint32 sig = 0;\\n+    nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(inputStream);\\n+\\n+    while (true) {\\n+        rv = seekable->Seek(nsISeekableStream::NS_SEEK_SET, seek);\\n+        if (NS_FAILED(rv)) {\\n+            inputStream->Close();\\n+            return rv;\\n+        }\\n+        rv = ZW_ReadData(inputStream, buf, length);\\n+        if (NS_FAILED(rv)) {\\n+            inputStream->Close();\\n+            return rv;\\n+        }\\n+\\n+        /*\\n+         * We have to backtrack from the end of the file until we find the\\n+         * CDS signature\\n+         */\\n+        // We know it's at least this far from the end\\n+        pos = length - ZIP_EOCDR_HEADER_SIZE;\\n+        sig = READ32(buf, &pos);\\n+        pos -= 4;\\n+        while (pos >=0) {\\n+            if (sig == ZIP_EOCDR_HEADER_SIGNATURE) {\\n+                // Skip down to entry count\\n+                pos += 10;\\n+                PRUint32 entries = READ16(buf, &pos);\\n+                // Skip past CDS size\\n+                pos += 4;\\n+                mCDSOffset = READ32(buf, &pos);\\n+                PRUint32 commentlen = READ16(buf, &pos);\\n+\\n+                if (commentlen == 0)\\n+                    mComment.Truncate();\\n+                else if (pos + commentlen <= length)\\n+                    mComment.Assign(buf + pos, commentlen);\\n+                else {\\n+                    if ((seek + pos + commentlen) > size) {\\n+                        inputStream->Close();\\n+                        return NS_ERROR_FILE_CORRUPTED;\\n+                    }\\n+                    nsAutoArrayPtr<char> field(new char[commentlen]);\\n+                    NS_ENSURE_TRUE(field, NS_ERROR_OUT_OF_MEMORY);\\n+                    rv = seekable->Seek(nsISeekableStream::NS_SEEK_SET,\\n+                                        seek + pos);\\n+                    if (NS_FAILED(rv)) {\\n+                        inputStream->Close();\\n+                        return rv;\\n+                    }\\n+                    rv = ZW_ReadData(inputStream, field.get(), length);\\n+                    if (NS_FAILED(rv)) {\\n+                        inputStream->Close();\\n+                        return rv;\\n+                    }\\n+                    mComment.Assign(field.get(), commentlen);\\n+                }\\n+\\n+                rv = seekable->Seek(nsISeekableStream::NS_SEEK_SET,\\n+                                    mCDSOffset);\\n+                if (NS_FAILED(rv)) {\\n+                    inputStream->Close();\\n+                    return rv;\\n+                }\\n+\\n+                for (PRUint32 entry = 0; entry < entries; entry++) {\\n+                    nsZipHeader* header = new nsZipHeader();\\n+                    if (!header) {\\n+                        inputStream->Close();\\n+                        mEntryHash.Clear();\\n+                        mHeaders.Clear();\\n+                        return NS_ERROR_OUT_OF_MEMORY;\\n+                    }\\n+                    rv = header->ReadCDSHeader(inputStream);\\n+                    if (NS_FAILED(rv)) {\\n+                        inputStream->Close();\\n+                        mEntryHash.Clear();\\n+                        mHeaders.Clear();\\n+                        return rv;\\n+                    }\\n+                    if (!mEntryHash.Put(header->mName, mHeaders.Count()))\\n+                        return NS_ERROR_OUT_OF_MEMORY;\\n+                    if (!mHeaders.AppendObject(header))\\n+                        return NS_ERROR_OUT_OF_MEMORY;\\n+                }\\n+\\n+                return inputStream->Close();\\n+            }\\n+            sig = sig << 8;\\n+            sig += buf[--pos];\\n+        }\\n+\\n+        if (seek == 0) {\\n+            // We've reached the start with no signature found. Corrupt.\\n+            inputStream->Close();\\n+            return NS_ERROR_FILE_CORRUPTED;\\n+        }\\n+\\n+        // Overlap by the size of the end of cdr\\n+        seek -= (1024 - ZIP_EOCDR_HEADER_SIZE);\\n+        if (seek < 0) {\\n+            length += seek;\\n+            seek = 0;\\n+        }\\n+    }\\n+    // Will never reach here in reality\\n+    NS_NOTREACHED(\\\"Loop should never complete\\\");\\n+    return NS_ERROR_UNEXPECTED;\\n+}\\n+\\n+/* void open (in nsIFile aFile, in PRInt32 aIoFlags); */\\n+NS_IMETHODIMP nsZipWriter::Open(nsIFile *aFile, PRInt32 aIoFlags)\\n+{\\n+    if (mStream)\\n+        return NS_ERROR_ALREADY_INITIALIZED;\\n+\\n+    NS_ENSURE_ARG_POINTER(aFile);\\n+\\n+    // Need to be able to write to the file\\n+    if (aIoFlags & PR_RDONLY)\\n+        return NS_ERROR_FAILURE;\\n+\\n+    PRBool exists;\\n+    nsresult rv = aFile->Exists(&exists);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    if (!exists && !(aIoFlags & PR_CREATE_FILE))\\n+        return NS_ERROR_FILE_NOT_FOUND;\\n+\\n+    if (exists && !(aIoFlags & (PR_TRUNCATE | PR_WRONLY))) {\\n+        rv = ReadFile(aFile);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+        mCDSDirty = PR_FALSE;\\n+    }\\n+    else {\\n+        mCDSOffset = 0;\\n+        mCDSDirty = PR_TRUE;\\n+        mComment.Truncate();\\n+    }\\n+\\n+    // Silently drop PR_APPEND\\n+    aIoFlags &= 0xef;\\n+\\n+    nsCOMPtr<nsIOutputStream> stream;\\n+    rv = NS_NewLocalFileOutputStream(getter_AddRefs(stream), aFile, aIoFlags);\\n+    if (NS_FAILED(rv)) {\\n+        mHeaders.Clear();\\n+        mEntryHash.Clear();\\n+        return rv;\\n+    }\\n+\\n+    rv = NS_NewBufferedOutputStream(getter_AddRefs(mStream), stream, 0x800);\\n+    if (NS_FAILED(rv)) {\\n+        stream->Close();\\n+        mHeaders.Clear();\\n+        mEntryHash.Clear();\\n+        return rv;\\n+    }\\n+\\n+    if (mCDSOffset > 0) {\\n+        rv = SeekCDS();\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+    }\\n+\\n+    mFile = aFile;\\n+\\n+    return NS_OK;\\n+}\\n+\\n+/* nsIZipEntry getEntry (in AString aZipEntry); */\\n+NS_IMETHODIMP nsZipWriter::GetEntry(const nsACString & aZipEntry,\\n+                                    nsIZipEntry **_retval)\\n+{\\n+    PRInt32 pos;\\n+    if (mEntryHash.Get(aZipEntry, &pos))\\n+        NS_ADDREF(*_retval = mHeaders[pos]);\\n+    else\\n+        *_retval = nsnull;\\n+\\n+    return NS_OK;\\n+}\\n+\\n+/* boolean hasEntry (in AString aZipEntry); */\\n+NS_IMETHODIMP nsZipWriter::HasEntry(const nsACString & aZipEntry,\\n+                                    PRBool *_retval)\\n+{\\n+    *_retval = mEntryHash.Get(aZipEntry, nsnull);\\n+\\n+    return NS_OK;\\n+}\\n+\\n+/* void addEntryDirectory (in AUTF8String aZipEntry, in PRTime aModTime,\\n+ *                         in boolean aQueue); */\\n+NS_IMETHODIMP nsZipWriter::AddEntryDirectory(const nsACString & aZipEntry,\\n+                                             PRTime aModTime, PRBool aQueue)\\n+{\\n+    if (!mStream)\\n+        return NS_ERROR_NOT_INITIALIZED;\\n+\\n+    if (aQueue) {\\n+        nsZipQueueItem item;\\n+        item.mOperation = OPERATION_ADD;\\n+        item.mZipEntry = aZipEntry;\\n+        item.mModTime = aModTime;\\n+        if (!mQueue.AppendElement(item))\\n+            return NS_ERROR_OUT_OF_MEMORY;\\n+        return NS_OK;\\n+    }\\n+\\n+    if (mInQueue)\\n+        return NS_ERROR_IN_PROGRESS;\\n+    return InternalAddEntryDirectory(aZipEntry, aModTime);\\n+}\\n+\\n+/* void addEntryFile (in AUTF8String aZipEntry, in PRInt32 aCompression,\\n+ *                    in nsIFile aFile, in boolean aQueue); */\\n+NS_IMETHODIMP nsZipWriter::AddEntryFile(const nsACString & aZipEntry,\\n+                                        PRInt32 aCompression, nsIFile *aFile,\\n+                                        PRBool aQueue)\\n+{\\n+    NS_ENSURE_ARG_POINTER(aFile);\\n+    if (!mStream)\\n+        return NS_ERROR_NOT_INITIALIZED;\\n+\\n+    if (aQueue) {\\n+        nsZipQueueItem item;\\n+        item.mOperation = OPERATION_ADD;\\n+        item.mZipEntry = aZipEntry;\\n+        item.mCompression = aCompression;\\n+        item.mFile = aFile;\\n+        if (!mQueue.AppendElement(item))\\n+            return NS_ERROR_OUT_OF_MEMORY;\\n+        return NS_OK;\\n+    }\\n+\\n+    if (mInQueue)\\n+        return NS_ERROR_IN_PROGRESS;\\n+\\n+    PRBool exists;\\n+    nsresult rv = aFile->Exists(&exists);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    if (!exists)\\n+        return NS_ERROR_FILE_NOT_FOUND;\\n+\\n+    PRBool isdir;\\n+    rv = aFile->IsDirectory(&isdir);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    PRInt64 modtime;\\n+    rv = aFile->GetLastModifiedTime(&modtime);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    modtime *= PR_USEC_PER_MSEC;\\n+\\n+    if (isdir)\\n+        return InternalAddEntryDirectory(aZipEntry, modtime);\\n+\\n+    if (mEntryHash.Get(aZipEntry, nsnull))\\n+        return NS_ERROR_FILE_ALREADY_EXISTS;\\n+\\n+    nsCOMPtr<nsIInputStream> inputStream;\\n+    rv = NS_NewLocalFileInputStream(getter_AddRefs(inputStream),\\n+                                    aFile);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    rv = AddEntryStream(aZipEntry, modtime, aCompression, inputStream,\\n+                        PR_FALSE);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    return inputStream->Close();\\n+}\\n+\\n+/* void addEntryChannel (in AUTF8String aZipEntry, in PRTime aModTime,\\n+ *                       in PRInt32 aCompression, in nsIChannel aChannel,\\n+ *                       in boolean aQueue); */\\n+NS_IMETHODIMP nsZipWriter::AddEntryChannel(const nsACString & aZipEntry,\\n+                                           PRTime aModTime,\\n+                                           PRInt32 aCompression,\\n+                                           nsIChannel *aChannel,\\n+                                           PRBool aQueue)\\n+{\\n+    NS_ENSURE_ARG_POINTER(aChannel);\\n+    if (!mStream)\\n+        return NS_ERROR_NOT_INITIALIZED;\\n+\\n+    if (aQueue) {\\n+        nsZipQueueItem item;\\n+        item.mOperation = OPERATION_ADD;\\n+        item.mZipEntry = aZipEntry;\\n+        item.mModTime = aModTime;\\n+        item.mCompression = aCompression;\\n+        item.mChannel = aChannel;\\n+        if (!mQueue.AppendElement(item))\\n+            return NS_ERROR_OUT_OF_MEMORY;\\n+        return NS_OK;\\n+    }\\n+\\n+    if (mInQueue)\\n+        return NS_ERROR_IN_PROGRESS;\\n+    if (mEntryHash.Get(aZipEntry, nsnull))\\n+        return NS_ERROR_FILE_ALREADY_EXISTS;\\n+\\n+    nsCOMPtr<nsIInputStream> inputStream;\\n+    nsresult rv = aChannel->Open(getter_AddRefs(inputStream));\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    rv = AddEntryStream(aZipEntry, aModTime, aCompression, inputStream,\\n+                        PR_FALSE);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+    return inputStream->Close();\\n+}\\n+\\n+/* void addEntryStream (in AUTF8String aZipEntry, in PRTime aModTime,\\n+ *                      in PRInt32 aCompression, in nsIInputStream aStream,\\n+ *                      in boolean aQueue); */\\n+NS_IMETHODIMP nsZipWriter::AddEntryStream(const nsACString & aZipEntry,\\n+                                          PRTime aModTime,\\n+                                          PRInt32 aCompression,\\n+                                          nsIInputStream *aStream,\\n+                                          PRBool aQueue)\\n+{\\n+    NS_ENSURE_ARG_POINTER(aStream);\\n+    if (!mStream)\\n+        return NS_ERROR_NOT_INITIALIZED;\\n+\\n+    if (aQueue) {\\n+        nsZipQueueItem item;\\n+        item.mOperation = OPERATION_ADD;\\n+        item.mZipEntry = aZipEntry;\\n+        item.mModTime = aModTime;\\n+        item.mCompression = aCompression;\\n+        item.mStream = aStream;\\n+        if (!mQueue.AppendElement(item))\\n+            return NS_ERROR_OUT_OF_MEMORY;\\n+        return NS_OK;\\n+    }\\n+\\n+    if (mInQueue)\\n+        return NS_ERROR_IN_PROGRESS;\\n+    if (mEntryHash.Get(aZipEntry, nsnull))\\n+        return NS_ERROR_FILE_ALREADY_EXISTS;\\n+\\n+    nsRefPtr<nsZipHeader> header = new nsZipHeader();\\n+    NS_ENSURE_TRUE(header, NS_ERROR_OUT_OF_MEMORY);\\n+    header->Init(aZipEntry, aModTime, ZIP_ATTRS_FILE, mCDSOffset);\\n+    nsresult rv = header->WriteFileHeader(mStream);\\n+    if (NS_FAILED(rv)) {\\n+        SeekCDS();\\n+        return rv;\\n+    }\\n+\\n+    nsRefPtr<nsZipDataStream> stream = new nsZipDataStream();\\n+    if (!stream) {\\n+        SeekCDS();\\n+        return NS_ERROR_OUT_OF_MEMORY;\\n+    }\\n+    rv = stream->Init(this, mStream, header, aCompression);\\n+    if (NS_FAILED(rv)) {\\n+        SeekCDS();\\n+        return rv;\\n+    }\\n+\\n+    rv = stream->ReadStream(aStream);\\n+    if (NS_FAILED(rv))\\n+        SeekCDS();\\n+    return rv;\\n+}\\n+\\n+/* void removeEntry (in AUTF8String aZipEntry, in boolean aQueue); */\\n+NS_IMETHODIMP nsZipWriter::RemoveEntry(const nsACString & aZipEntry,\\n+                                       PRBool aQueue)\\n+{\\n+    if (!mStream)\\n+        return NS_ERROR_NOT_INITIALIZED;\\n+\\n+    if (aQueue) {\\n+        nsZipQueueItem item;\\n+        item.mOperation = OPERATION_REMOVE;\\n+        item.mZipEntry = aZipEntry;\\n+        if (!mQueue.AppendElement(item))\\n+            return NS_ERROR_OUT_OF_MEMORY;\\n+        return NS_OK;\\n+    }\\n+\\n+    if (mInQueue)\\n+        return NS_ERROR_IN_PROGRESS;\\n+\\n+    PRInt32 pos;\\n+    if (mEntryHash.Get(aZipEntry, &pos)) {\\n+        // Flush any remaining data before we seek.\\n+        nsresult rv = mStream->Flush();\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+        if (pos < mHeaders.Count() - 1) {\\n+            // This is not the last entry, pull back the data.\\n+            nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mStream);\\n+            rv = seekable->Seek(nsISeekableStream::NS_SEEK_SET,\\n+                                mHeaders[pos]->mOffset);\\n+            NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+            nsCOMPtr<nsIInputStream> inputStream;\\n+            rv = NS_NewLocalFileInputStream(getter_AddRefs(inputStream),\\n+                                            mFile);\\n+            NS_ENSURE_SUCCESS(rv, rv);\\n+            seekable = do_QueryInterface(inputStream);\\n+            rv = seekable->Seek(nsISeekableStream::NS_SEEK_SET,\\n+                                mHeaders[pos + 1]->mOffset);\\n+            if (NS_FAILED(rv)) {\\n+                inputStream->Close();\\n+                return rv;\\n+            }\\n+\\n+            PRUint32 count = mCDSOffset - mHeaders[pos + 1]->mOffset;\\n+            PRUint32 read = 0;\\n+            char buf[4096];\\n+            while (count > 0) {\\n+                if (count < sizeof(buf))\\n+                    read = count;\\n+                else\\n+                    read = sizeof(buf);\\n+\\n+                rv = inputStream->Read(buf, read, &read);\\n+                if (NS_FAILED(rv)) {\\n+                    inputStream->Close();\\n+                    Cleanup();\\n+                    return rv;\\n+                }\\n+\\n+                rv = ZW_WriteData(mStream, buf, read);\\n+                if (NS_FAILED(rv)) {\\n+                    inputStream->Close();\\n+                    Cleanup();\\n+                    return rv;\\n+                }\\n+\\n+                count -= read;\\n+            }\\n+            inputStream->Close();\\n+\\n+            // Rewrite header offsets and update hash\\n+            PRUint32 shift = (mHeaders[pos + 1]->mOffset -\\n+                              mHeaders[pos]->mOffset);\\n+            mCDSOffset -= shift;\\n+            PRInt32 pos2 = pos + 1;\\n+            while (pos2 < mHeaders.Count()) {\\n+                if (!mEntryHash.Put(mHeaders[pos2]->mName, pos2-1)) {\\n+                    Cleanup();\\n+                    return NS_ERROR_OUT_OF_MEMORY;\\n+                }\\n+                mHeaders[pos2]->mOffset -= shift;\\n+                pos2++;\\n+            }\\n+        }\\n+        else {\\n+            // Remove the last entry is just a case of moving the CDS\\n+            mCDSOffset = mHeaders[pos]->mOffset;\\n+            rv = SeekCDS();\\n+            NS_ENSURE_SUCCESS(rv, rv);\\n+        }\\n+\\n+        mEntryHash.Remove(mHeaders[pos]->mName);\\n+        mHeaders.RemoveObjectAt(pos);\\n+        mCDSDirty = PR_TRUE;\\n+\\n+        return NS_OK;\\n+    }\\n+\\n+    return NS_ERROR_FILE_NOT_FOUND;\\n+}\\n+\\n+/* void processQueue (in nsIRequestObserver aObserver,\\n+ *                    in nsISupports aContext); */\\n+NS_IMETHODIMP nsZipWriter::ProcessQueue(nsIRequestObserver *aObserver,\\n+                                        nsISupports *aContext)\\n+{\\n+    if (!mStream)\\n+        return NS_ERROR_NOT_INITIALIZED;\\n+    if (mInQueue)\\n+        return NS_ERROR_IN_PROGRESS;\\n+\\n+    mProcessObserver = aObserver;\\n+    mProcessContext = aContext;\\n+    mInQueue = PR_TRUE;\\n+\\n+    if (mProcessObserver)\\n+        mProcessObserver->OnStartRequest(nsnull, mProcessContext);\\n+\\n+    BeginProcessingNextItem();\\n+\\n+    return NS_OK;\\n+}\\n+\\n+/* void close (); */\\n+NS_IMETHODIMP nsZipWriter::Close()\\n+{\\n+    if (!mStream)\\n+        return NS_ERROR_NOT_INITIALIZED;\\n+    if (mInQueue)\\n+        return NS_ERROR_IN_PROGRESS;\\n+\\n+    if (mCDSDirty) {\\n+        PRUint32 size = 0;\\n+        for (PRInt32 i = 0; i < mHeaders.Count(); i++) {\\n+            nsresult rv = mHeaders[i]->WriteCDSHeader(mStream);\\n+            if (NS_FAILED(rv)) {\\n+                Cleanup();\\n+                return rv;\\n+            }\\n+            size += mHeaders[i]->GetCDSHeaderLength();\\n+        }\\n+\\n+        char buf[ZIP_EOCDR_HEADER_SIZE];\\n+        PRUint32 pos = 0;\\n+        WRITE32(buf, &pos, ZIP_EOCDR_HEADER_SIGNATURE);\\n+        WRITE16(buf, &pos, 0);\\n+        WRITE16(buf, &pos, 0);\\n+        WRITE16(buf, &pos, mHeaders.Count());\\n+        WRITE16(buf, &pos, mHeaders.Count());\\n+        WRITE32(buf, &pos, size);\\n+        WRITE32(buf, &pos, mCDSOffset);\\n+        WRITE16(buf, &pos, mComment.Length());\\n+\\n+        nsresult rv = ZW_WriteData(mStream, buf, pos);\\n+        if (NS_FAILED(rv)) {\\n+            Cleanup();\\n+            return rv;\\n+        }\\n+\\n+        rv = ZW_WriteData(mStream, mComment.get(), mComment.Length());\\n+        if (NS_FAILED(rv)) {\\n+            Cleanup();\\n+            return rv;\\n+        }\\n+\\n+        nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mStream);\\n+        rv = seekable->SetEOF();\\n+        if (NS_FAILED(rv)) {\\n+            Cleanup();\\n+            return rv;\\n+        }\\n+    }\\n+\\n+    nsresult rv = mStream->Close();\\n+    mStream = nsnull;\\n+    mHeaders.Clear();\\n+    mEntryHash.Clear();\\n+    mQueue.Clear();\\n+\\n+    return rv;\\n+}\\n+\\n+// Our nsIRequestObserver monitors removal operations performed on the queue\\n+/* void onStartRequest (in nsIRequest aRequest, in nsISupports aContext); */\\n+NS_IMETHODIMP nsZipWriter::OnStartRequest(nsIRequest *aRequest,\\n+                                          nsISupports *aContext)\\n+{\\n+    return NS_OK;\\n+}\\n+\\n+/* void onStopRequest (in nsIRequest aRequest, in nsISupports aContext,\\n+ *                                             in nsresult aStatusCode); */\\n+NS_IMETHODIMP nsZipWriter::OnStopRequest(nsIRequest *aRequest,\\n+                                         nsISupports *aContext,\\n+                                         nsresult aStatusCode)\\n+{\\n+    if (NS_FAILED(aStatusCode)) {\\n+        FinishQueue(aStatusCode);\\n+        Cleanup();\\n+    }\\n+\\n+    nsresult rv = mStream->Flush();\\n+    if (NS_FAILED(rv)) {\\n+        FinishQueue(rv);\\n+        Cleanup();\\n+        return rv;\\n+    }\\n+    rv = SeekCDS();\\n+    if (NS_FAILED(rv)) {\\n+        FinishQueue(rv);\\n+        return rv;\\n+    }\\n+\\n+    BeginProcessingNextItem();\\n+\\n+    return NS_OK;\\n+}\\n+\\n+nsresult nsZipWriter::InternalAddEntryDirectory(const nsACString & aZipEntry,\\n+                                                PRTime aModTime)\\n+{\\n+    nsRefPtr<nsZipHeader> header = new nsZipHeader();\\n+    NS_ENSURE_TRUE(header, NS_ERROR_OUT_OF_MEMORY);\\n+\\n+    if (aZipEntry.Last() != '/') {\\n+        nsCString dirPath;\\n+        dirPath.Assign(aZipEntry + NS_LITERAL_CSTRING(\\\"/\\\"));\\n+        header->Init(dirPath, aModTime, ZIP_ATTRS_DIRECTORY, mCDSOffset);\\n+    }\\n+    else\\n+        header->Init(aZipEntry, aModTime, ZIP_ATTRS_DIRECTORY, mCDSOffset);\\n+\\n+    if (mEntryHash.Get(header->mName, nsnull))\\n+        return NS_ERROR_FILE_ALREADY_EXISTS;\\n+\\n+    nsresult rv = header->WriteFileHeader(mStream);\\n+    if (NS_FAILED(rv)) {\\n+        Cleanup();\\n+        return rv;\\n+    }\\n+\\n+    mCDSDirty = PR_TRUE;\\n+    mCDSOffset += header->GetFileHeaderLength();\\n+    if (!mEntryHash.Put(header->mName, mHeaders.Count())) {\\n+        Cleanup();\\n+        return NS_ERROR_OUT_OF_MEMORY;\\n+    }\\n+    if (!mHeaders.AppendObject(header)) {\\n+        Cleanup();\\n+        return NS_ERROR_OUT_OF_MEMORY;\\n+    }\\n+\\n+    return NS_OK;\\n+}\\n+\\n+/*\\n+ * Recovering from an error while adding a new entry is simply a case of\\n+ * seeking back to the CDS. If we fail trying to do that though then cleanup\\n+ * and bail out.\\n+ */\\n+nsresult nsZipWriter::SeekCDS()\\n+{\\n+    nsresult rv;\\n+    nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mStream, &rv);\\n+    if (NS_FAILED(rv)) {\\n+        Cleanup();\\n+        return rv;\\n+    }\\n+    rv = seekable->Seek(nsISeekableStream::NS_SEEK_SET, mCDSOffset);\\n+    if (NS_FAILED(rv))\\n+        Cleanup();\\n+    return rv;\\n+}\\n+\\n+/*\\n+ * In a bad error condition this essentially closes down the component as best\\n+ * it can.\\n+ */\\n+void nsZipWriter::Cleanup()\\n+{\\n+    mHeaders.Clear();\\n+    mEntryHash.Clear();\\n+    if (mStream)\\n+        mStream->Close();\\n+    mStream = nsnull;\\n+    mFile = nsnull;\\n+}\\n+\\n+/*\\n+ * Called when writing a file to the zip is complete.\\n+ */\\n+nsresult nsZipWriter::EntryCompleteCallback(nsZipHeader* aHeader,\\n+                                            nsresult aStatus)\\n+{\\n+    if (NS_SUCCEEDED(aStatus)) {\\n+        if (!mEntryHash.Put(aHeader->mName, mHeaders.Count())) {\\n+            SeekCDS();\\n+            return NS_ERROR_OUT_OF_MEMORY;\\n+        }\\n+        if (!mHeaders.AppendObject(aHeader)) {\\n+            mEntryHash.Remove(aHeader->mName);\\n+            SeekCDS();\\n+            return NS_ERROR_OUT_OF_MEMORY;\\n+        }\\n+        mCDSDirty = PR_TRUE;\\n+        mCDSOffset += aHeader->mCSize + aHeader->GetFileHeaderLength();\\n+\\n+        if (mInQueue)\\n+            BeginProcessingNextItem();\\n+\\n+        return NS_OK;\\n+    }\\n+\\n+    nsresult rv = SeekCDS();\\n+    if (mInQueue)\\n+        FinishQueue(aStatus);\\n+    return rv;\\n+}\\n+\\n+inline nsresult nsZipWriter::BeginProcessingAddition(nsZipQueueItem* aItem,\\n+                                                     PRBool* complete)\\n+{\\n+    if (aItem->mFile) {\\n+        PRBool exists;\\n+        nsresult rv = aItem->mFile->Exists(&exists);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+        if (!exists) return NS_ERROR_FILE_NOT_FOUND;\\n+\\n+        PRBool isdir;\\n+        rv = aItem->mFile->IsDirectory(&isdir);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+        rv = aItem->mFile->GetLastModifiedTime(&aItem->mModTime);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+        aItem->mModTime *= PR_USEC_PER_MSEC;\\n+\\n+        if (!isdir) {\\n+            // Set up for fall through to stream reader\\n+            rv = NS_NewLocalFileInputStream(getter_AddRefs(aItem->mStream),\\n+                                            aItem->mFile);\\n+            NS_ENSURE_SUCCESS(rv, rv);\\n+        }\\n+        // If a dir then this will fall through to the plain dir addition\\n+    }\\n+\\n+    if (aItem->mStream) {\\n+        nsRefPtr<nsZipHeader> header = new nsZipHeader();\\n+        NS_ENSURE_TRUE(header, NS_ERROR_OUT_OF_MEMORY);\\n+\\n+        header->Init(aItem->mZipEntry, aItem->mModTime, ZIP_ATTRS_FILE,\\n+                     mCDSOffset);\\n+        nsresult rv = header->WriteFileHeader(mStream);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+        nsRefPtr<nsZipDataStream> stream = new nsZipDataStream();\\n+        rv = stream->Init(this, mStream, header, aItem->mCompression);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+        nsCOMPtr<nsIInputStreamPump> pump;\\n+        rv = NS_NewInputStreamPump(getter_AddRefs(pump), aItem->mStream, -1,\\n+                                   -1, 0, 0, PR_TRUE);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+        rv = pump->AsyncRead(stream, nsnull);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+        return NS_OK;\\n+    }\\n+\\n+    if (aItem->mChannel) {\\n+        nsRefPtr<nsZipHeader> header = new nsZipHeader();\\n+        NS_ENSURE_TRUE(header, NS_ERROR_OUT_OF_MEMORY);\\n+\\n+        header->Init(aItem->mZipEntry, aItem->mModTime, ZIP_ATTRS_FILE,\\n+                     mCDSOffset);\\n+\\n+        nsRefPtr<nsZipDataStream> stream = new nsZipDataStream();\\n+        NS_ENSURE_TRUE(stream, NS_ERROR_OUT_OF_MEMORY);\\n+        nsresult rv = stream->Init(this, mStream, header, aItem->mCompression);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+        rv = aItem->mChannel->AsyncOpen(stream, nsnull);\\n+        NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+        return NS_OK;\\n+    }\\n+\\n+    // Must be plain directory addition\\n+    *complete = PR_TRUE;\\n+    return InternalAddEntryDirectory(aItem->mZipEntry, aItem->mModTime);\\n+}\\n+\\n+inline nsresult nsZipWriter::BeginProcessingRemoval(PRInt32 aPos)\\n+{\\n+    // Open the zip file for reading\\n+    nsCOMPtr<nsIInputStream> inputStream;\\n+    nsresult rv = NS_NewLocalFileInputStream(getter_AddRefs(inputStream),\\n+                                             mFile);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+    nsCOMPtr<nsIInputStreamPump> pump;\\n+    rv = NS_NewInputStreamPump(getter_AddRefs(pump), inputStream, -1, -1, 0,\\n+                               0, PR_TRUE);\\n+    if (NS_FAILED(rv)) {\\n+        inputStream->Close();\\n+        return rv;\\n+    }\\n+    nsCOMPtr<nsIStreamListener> listener;\\n+    rv = NS_NewSimpleStreamListener(getter_AddRefs(listener), mStream, this);\\n+    if (NS_FAILED(rv)) {\\n+        inputStream->Close();\\n+        return rv;\\n+    }\\n+\\n+    nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mStream);\\n+    rv = seekable->Seek(nsISeekableStream::NS_SEEK_SET,\\n+                        mHeaders[aPos]->mOffset);\\n+    if (NS_FAILED(rv)) {\\n+        inputStream->Close();\\n+        return rv;\\n+    }\\n+\\n+    PRUint32 shift = (mHeaders[aPos + 1]->mOffset -\\n+                      mHeaders[aPos]->mOffset);\\n+    mCDSOffset -= shift;\\n+    PRInt32 pos2 = aPos + 1;\\n+    while (pos2 < mHeaders.Count()) {\\n+        mEntryHash.Put(mHeaders[pos2]->mName, pos2 - 1);\\n+        mHeaders[pos2]->mOffset -= shift;\\n+        pos2++;\\n+    }\\n+\\n+    mEntryHash.Remove(mHeaders[aPos]->mName);\\n+    mHeaders.RemoveObjectAt(aPos);\\n+    mCDSDirty = PR_TRUE;\\n+\\n+    rv = pump->AsyncRead(listener, nsnull);\\n+    if (NS_FAILED(rv)) {\\n+        inputStream->Close();\\n+        Cleanup();\\n+        return rv;\\n+    }\\n+    return NS_OK;\\n+}\\n+\\n+/*\\n+ * Starts processing on the next item in the queue.\\n+ */\\n+void nsZipWriter::BeginProcessingNextItem()\\n+{\\n+    while (!mQueue.IsEmpty()) {\\n+\\n+        nsZipQueueItem next = mQueue[0];\\n+        mQueue.RemoveElementAt(0);\\n+\\n+        if (next.mOperation == OPERATION_REMOVE) {\\n+            PRInt32 pos = -1;\\n+            if (mEntryHash.Get(next.mZipEntry, &pos)) {\\n+                if (pos < mHeaders.Count() - 1) {\\n+                    nsresult rv = BeginProcessingRemoval(pos);\\n+                    if (NS_FAILED(rv)) FinishQueue(rv);\\n+                    return;\\n+                }\\n+\\n+                mCDSOffset = mHeaders[pos]->mOffset;\\n+                nsresult rv = SeekCDS();\\n+                if (NS_FAILED(rv)) {\\n+                    FinishQueue(rv);\\n+                    return;\\n+                }\\n+                mEntryHash.Remove(mHeaders[pos]->mName);\\n+                mHeaders.RemoveObjectAt(pos);\\n+            }\\n+            else {\\n+                FinishQueue(NS_ERROR_FILE_NOT_FOUND);\\n+                return;\\n+            }\\n+        }\\n+        else if (next.mOperation == OPERATION_ADD) {\\n+            if (mEntryHash.Get(next.mZipEntry, nsnull)) {\\n+                FinishQueue(NS_ERROR_FILE_ALREADY_EXISTS);\\n+                return;\\n+            }\\n+\\n+            PRBool complete = PR_FALSE;\\n+            nsresult rv = BeginProcessingAddition(&next, &complete);\\n+            if (NS_FAILED(rv)) {\\n+                SeekCDS();\\n+                FinishQueue(rv);\\n+                return;\\n+            }\\n+            if (!complete)\\n+                return;\\n+        }\\n+    }\\n+\\n+    FinishQueue(NS_OK);\\n+}\\n+\\n+/*\\n+ * Ends processing with the given status.\\n+ */\\n+void nsZipWriter::FinishQueue(nsresult aStatus)\\n+{\\n+    nsCOMPtr<nsIRequestObserver> observer = mProcessObserver;\\n+    nsCOMPtr<nsISupports> context = mProcessContext;\\n+    // Clean up everything first in case the observer decides to queue more\\n+    // things\\n+    mProcessObserver = nsnull;\\n+    mProcessContext = nsnull;\\n+    mInQueue = PR_FALSE;\\n+\\n+    if (observer)\\n+        observer->OnStopRequest(nsnull, context, aStatus);\\n+}\\ndiff --git a/modules/libjar/zipwriter/src/nsZipWriter.h b/modules/libjar/zipwriter/src/nsZipWriter.h\\nnew file mode 100644\\nindex 0000000..dc60fad\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/src/nsZipWriter.h\\n@@ -0,0 +1,110 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *      Mook <mook.moz+random.code@gmail.com>\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+#ifndef _nsZipWriter_h_\\n+#define _nsZipWriter_h_\\n+\\n+#include \\\"nsIZipWriter.h\\\"\\n+#include \\\"nsIFileStreams.h\\\"\\n+#include \\\"nsIBufferedStreams.h\\\"\\n+#include \\\"nsIRequestObserver.h\\\"\\n+#include \\\"nsZipHeader.h\\\"\\n+#include \\\"nsCOMPtr.h\\\"\\n+#include \\\"nsCOMArray.h\\\"\\n+#include \\\"nsTArray.h\\\"\\n+#include \\\"nsDataHashtable.h\\\"\\n+\\n+#define ZIPWRITER_CONTRACTID \\\"@mozilla.org/zipwriter;1\\\"\\n+#define ZIPWRITER_CLASSNAME \\\"Zip Writer\\\"\\n+#define ZIPWRITER_CID { 0x430d416c, 0xa722, 0x4ad1, \\\\\\n+           { 0xbe, 0x98, 0xd9, 0xa4, 0x45, 0xf8, 0x5e, 0x3f } }\\n+\\n+#define OPERATION_ADD 0\\n+#define OPERATION_REMOVE 1\\n+struct nsZipQueueItem\\n+{\\n+public:\\n+    PRUint32 mOperation;\\n+    nsCString mZipEntry;\\n+    nsCOMPtr<nsIFile> mFile;\\n+    nsCOMPtr<nsIChannel> mChannel;\\n+    nsCOMPtr<nsIInputStream> mStream;\\n+    PRTime mModTime;\\n+    PRInt32 mCompression;\\n+};\\n+\\n+class nsZipWriter : public nsIZipWriter,\\n+                    public nsIRequestObserver\\n+{\\n+public:\\n+    NS_DECL_ISUPPORTS\\n+    NS_DECL_NSIZIPWRITER\\n+    NS_DECL_NSIREQUESTOBSERVER\\n+\\n+    nsZipWriter();\\n+    nsresult EntryCompleteCallback(nsZipHeader *aHeader, nsresult aStatus);\\n+\\n+private:\\n+    ~nsZipWriter();\\n+\\n+    PRUint32 mCDSOffset;\\n+    PRPackedBool mCDSDirty;\\n+    PRPackedBool mInQueue;\\n+\\n+    nsCOMPtr<nsIFile> mFile;\\n+    nsCOMPtr<nsIRequestObserver> mProcessObserver;\\n+    nsCOMPtr<nsISupports> mProcessContext;\\n+    nsCOMPtr<nsIOutputStream> mStream;\\n+    nsCOMArray<nsZipHeader> mHeaders;\\n+    nsTArray<nsZipQueueItem> mQueue;\\n+    nsDataHashtable<nsCStringHashKey, PRInt32> mEntryHash;\\n+    nsCString mComment;\\n+\\n+    nsresult SeekCDS();\\n+    void Cleanup();\\n+    nsresult ReadFile(nsIFile *aFile);\\n+    nsresult InternalAddEntryDirectory(const nsACString & aZipEntry,\\n+                                       PRTime aModTime);\\n+    nsresult BeginProcessingAddition(nsZipQueueItem* aItem, PRBool* complete);\\n+    nsresult BeginProcessingRemoval(PRInt32 aPos);\\n+    void BeginProcessingNextItem();\\n+    void FinishQueue(nsresult aStatus);\\n+};\\n+\\n+#endif\\ndiff --git a/modules/libjar/zipwriter/test/Makefile.in b/modules/libjar/zipwriter/test/Makefile.in\\nnew file mode 100644\\nindex 0000000..6afead1\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/test/Makefile.in\\n@@ -0,0 +1,51 @@\\n+# ***** BEGIN LICENSE BLOCK *****\\n+# Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+#\\n+# The contents of this file are subject to the Mozilla Public License Version\\n+# 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+# the License. You may obtain a copy of the License at\\n+# http://www.mozilla.org/MPL/\\n+#\\n+# Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+# for the specific language governing rights and limitations under the\\n+# License.\\n+#\\n+# The Original Code is Zip Writer Component.\\n+#\\n+# The Initial Developer of the Original Code is\\n+# Dave Townsend <dtownsend@oxymoronical.com>.\\n+#\\n+# Portions created by the Initial Developer are Copyright (C) 2007\\n+# the Initial Developer. All Rights Reserved.\\n+#\\n+# Contributor(s):\\n+#\\n+# Alternatively, the contents of this file may be used under the terms of\\n+# either of the GNU General Public License Version 2 or later (the \\\"GPL\\\"),\\n+# or the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+# in which case the provisions of the GPL or the LGPL are applicable instead\\n+# of those above. If you wish to allow use of your version of this file only\\n+# under the terms of either the GPL or the LGPL, and not to allow others to\\n+# use your version of this file under the terms of the MPL, indicate your\\n+# decision by deleting the provisions above and replace them with the notice\\n+# and other provisions required by the GPL or the LGPL. If you do not delete\\n+# the provisions above, a recipient may use your version of this file under\\n+# the terms of any one of the MPL, the GPL or the LGPL.\\n+#\\n+# ***** END LICENSE BLOCK *****\\n+\\n+DEPTH          = ../../../..\\n+topsrcdir      = @top_srcdir@\\n+srcdir         = @srcdir@\\n+VPATH          = @srcdir@\\n+\\n+include $(DEPTH)/config/autoconf.mk\\n+\\n+MODULE         = test_zipwriter\\n+\\n+XPCSHELL_TESTS = \\\\\\n+  unit \\\\\\n+  $(NULL)\\n+\\n+include $(topsrcdir)/config/rules.mk\\ndiff --git a/modules/libjar/zipwriter/test/unit/data/test.png b/modules/libjar/zipwriter/test/unit/data/test.png\\nnew file mode 100644\\nindex 0000000..c648f72\\nBinary files /dev/null and b/modules/libjar/zipwriter/test/unit/data/test.png differ\\ndiff --git a/modules/libjar/zipwriter/test/unit/data/test.txt b/modules/libjar/zipwriter/test/unit/data/test.txt\\nnew file mode 100644\\nindex 0000000..1040981\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/test/unit/data/test.txt\\n@@ -0,0 +1,5 @@\\n+This is a test text file for the zipwriter component.\\n+It will be made available in the unit test directory.\\n+It will also be compressed into a testcase zip file\\n+made by a 3rd party zip tool to test the opening of\\n+existing zip files.\\ndiff --git a/modules/libjar/zipwriter/test/unit/data/test.zip b/modules/libjar/zipwriter/test/unit/data/test.zip\\nnew file mode 100644\\nindex 0000000..96581fe\\nBinary files /dev/null and b/modules/libjar/zipwriter/test/unit/data/test.zip differ\\ndiff --git a/modules/libjar/zipwriter/test/unit/head_zipwriter.js b/modules/libjar/zipwriter/test/unit/head_zipwriter.js\\nnew file mode 100644\\nindex 0000000..ada0823\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/test/unit/head_zipwriter.js\\n@@ -0,0 +1,79 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+const NS_OS_TEMP_DIR = \\\"TmpD\\\";\\n+const Ci = Components.interfaces;\\n+const Cc = Components.classes;\\n+const NS_ERROR_IN_PROGRESS = 2152398863;\\n+\\n+const PR_RDONLY      = 0x01\\n+const PR_WRONLY      = 0x02\\n+const PR_RDWR        = 0x04\\n+const PR_CREATE_FILE = 0x08\\n+const PR_APPEND      = 0x10\\n+const PR_TRUNCATE    = 0x20\\n+const PR_SYNC        = 0x40\\n+const PR_EXCL        = 0x80\\n+\\n+const ZIP_EOCDR_HEADER_SIZE = 22;\\n+const ZIP_FILE_HEADER_SIZE = 30;\\n+const ZIP_CDS_HEADER_SIZE = 46;\\n+const ZIP_METHOD_STORE = 0\\n+const ZIP_METHOD_DEFLATE = 8\\n+\\n+const PR_USEC_PER_MSEC = 1000;\\n+\\n+// ZIP times are stored at a 2 second resolution.\\n+const TIME_RESOLUTION = 2000;\\n+\\n+const DATA_DIR = \\\"modules/libjar/zipwriter/test/unit/data/\\\";\\n+\\n+var ZipWriter = Components.Constructor(\\\"@mozilla.org/zipwriter;1\\\",\\n+                                       \\\"nsIZipWriter\\\");\\n+var ZipReader = Components.Constructor(\\\"@mozilla.org/libjar/zip-reader;1\\\",\\n+                                       \\\"nsIZipReader\\\", \\\"open\\\");\\n+\\n+var dirSvc = Cc[\\\"@mozilla.org/file/directory_service;1\\\"]\\n+              .getService(Ci.nsIProperties);\\n+var tmpDir = dirSvc.get(NS_OS_TEMP_DIR, Ci.nsIFile);\\n+var tmpFile = tmpDir.clone();\\n+tmpFile.append(\\\"zipwriter-test.zip\\\");\\n+if (tmpFile.exists())\\n+  tmpFile.remove(true);\\n+\\n+var zipW = new ZipWriter();\\ndiff --git a/modules/libjar/zipwriter/test/unit/tail_zipwriter.js b/modules/libjar/zipwriter/test/unit/tail_zipwriter.js\\nnew file mode 100644\\nindex 0000000..1d54268\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/test/unit/tail_zipwriter.js\\n@@ -0,0 +1,47 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+try {\\n+  zipW.close();\\n+}\\n+catch (e) {\\n+  // Just ignore a failure here and attempt to delete the file anyway.\\n+}\\n+\\n+if (tmpFile.exists())\\n+  tmpFile.remove(true);\\ndiff --git a/modules/libjar/zipwriter/test/unit/test_asyncadd.js b/modules/libjar/zipwriter/test/unit/test_asyncadd.js\\nnew file mode 100644\\nindex 0000000..c6792d4\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/test/unit/test_asyncadd.js\\n@@ -0,0 +1,108 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+// Values taken from using zipinfo to list the test.zip contents\\n+var TESTS = [\\n+  {\\n+    name: \\\"test.txt\\\",\\n+    size: 232,\\n+    crc: 0x0373ac26\\n+  },\\n+  {\\n+    name: \\\"test.png\\\",\\n+    size: 3402,\\n+    crc: 0x504a5c30\\n+  }\\n+];\\n+\\n+var size = 0;\\n+\\n+var observer = {\\n+  onStartRequest: function(request, context)\\n+  {\\n+  },\\n+\\n+  onStopRequest: function(request, context, status)\\n+  {\\n+    do_check_eq(status, Components.results.NS_OK);\\n+\\n+    zipW.close();\\n+    size += ZIP_EOCDR_HEADER_SIZE;\\n+\\n+    do_check_eq(size, tmpFile.fileSize);\\n+\\n+    // Test the stored data with the zipreader\\n+    var zipR = new ZipReader(tmpFile);\\n+\\n+    for (var i = 0; i < TESTS.length; i++) {\\n+      do_check_true(zipR.hasEntry(TESTS[i].name));\\n+\\n+      var source = do_get_file(DATA_DIR + TESTS[i].name);\\n+      var entry = zipR.getEntry(TESTS[i].name);\\n+      do_check_eq(entry.realSize, TESTS[i].size);\\n+      do_check_eq(entry.size, TESTS[i].size);\\n+      do_check_eq(entry.CRC32, TESTS[i].crc);\\n+\\n+      var diff = Math.abs((entry.lastModifiedTime/PR_USEC_PER_MSEC) -\\n+                          source.lastModifiedTime);\\n+      if (diff > TIME_RESOLUTION)\\n+        do_throw(diff);\\n+\\n+      zipR.test(TESTS[i].name);\\n+    }\\n+\\n+    zipR.close();\\n+    do_test_finished();\\n+  }\\n+};\\n+\\n+function run_test()\\n+{\\n+  zipW.open(tmpFile, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE);\\n+\\n+  for (var i = 0; i < TESTS.length; i++) {\\n+    var source = do_get_file(DATA_DIR+TESTS[i].name);\\n+    zipW.addEntryFile(TESTS[i].name, Ci.nsIZipWriter.COMPRESSION_NONE, source,\\n+                      true);\\n+    size += ZIP_FILE_HEADER_SIZE + ZIP_CDS_HEADER_SIZE +\\n+            (TESTS[i].name.length*2) + TESTS[i].size;\\n+  }\\n+  do_test_pending();\\n+  zipW.processQueue(observer, null);\\n+  do_check_true(zipW.inQueue);\\n+}\\ndiff --git a/modules/libjar/zipwriter/test/unit/test_asyncbadadd.js b/modules/libjar/zipwriter/test/unit/test_asyncbadadd.js\\nnew file mode 100644\\nindex 0000000..8634e32\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/test/unit/test_asyncbadadd.js\\n@@ -0,0 +1,68 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+const FILENAME = \\\"missing.txt\\\";\\n+\\n+var observer = {\\n+  onStartRequest: function(request, context)\\n+  {\\n+  },\\n+\\n+  onStopRequest: function(request, context, status)\\n+  {\\n+    do_check_eq(status, Components.results.NS_ERROR_FILE_NOT_FOUND);\\n+    zipW.close();\\n+    do_check_eq(ZIP_EOCDR_HEADER_SIZE, tmpFile.fileSize);\\n+    do_test_finished();\\n+  }\\n+};\\n+\\n+function run_test()\\n+{\\n+  zipW.open(tmpFile, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE);\\n+\\n+  var source = tmpDir.clone();\\n+  source.append(FILENAME);\\n+  zipW.addEntryFile(FILENAME, Ci.nsIZipWriter.COMPRESSION_NONE, source, true);\\n+\\n+  do_test_pending();\\n+  zipW.processQueue(observer, null);\\n+\\n+  // With nothing to actually do the queue would have completed immediately\\n+  do_check_false(zipW.inQueue);\\n+}\\ndiff --git a/modules/libjar/zipwriter/test/unit/test_asyncbadremove.js b/modules/libjar/zipwriter/test/unit/test_asyncbadremove.js\\nnew file mode 100644\\nindex 0000000..90f00af\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/test/unit/test_asyncbadremove.js\\n@@ -0,0 +1,64 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+const FILENAME = \\\"missing.txt\\\";\\n+\\n+var observer = {\\n+  onStartRequest: function(request, context)\\n+  {\\n+  },\\n+\\n+  onStopRequest: function(request, context, status)\\n+  {\\n+    do_check_eq(status, Components.results.NS_ERROR_FILE_NOT_FOUND);\\n+    zipW.close();\\n+    do_check_eq(ZIP_EOCDR_HEADER_SIZE, tmpFile.fileSize);\\n+    do_test_finished();\\n+  }\\n+};\\n+\\n+function run_test()\\n+{\\n+  zipW.open(tmpFile, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE);\\n+  zipW.removeEntry(FILENAME, true);\\n+  do_test_pending();\\n+  zipW.processQueue(observer, null);\\n+\\n+  // With nothing to actually do the queue would have completed immediately\\n+  do_check_false(zipW.inQueue);\\n+}\\ndiff --git a/modules/libjar/zipwriter/test/unit/test_asyncremove.js b/modules/libjar/zipwriter/test/unit/test_asyncremove.js\\nnew file mode 100644\\nindex 0000000..89bfc2e\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/test/unit/test_asyncremove.js\\n@@ -0,0 +1,79 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+var TESTS = [\\n+  \\\"test.txt\\\",\\n+  \\\"test.png\\\"\\n+];\\n+\\n+var observer = {\\n+  onStartRequest: function(request, context)\\n+  {\\n+  },\\n+\\n+  onStopRequest: function(request, context, status)\\n+  {\\n+    do_check_eq(status, Components.results.NS_OK);\\n+\\n+    zipW.close();\\n+\\n+    // Empty zip file should just be the end of central directory marker\\n+    do_check_eq(tmpFile.fileSize, ZIP_EOCDR_HEADER_SIZE);\\n+    do_test_finished();\\n+  }\\n+};\\n+\\n+function run_test()\\n+{\\n+  // Copy our test zip to the tmp dir so we can modify it\\n+  var testzip = do_get_file(DATA_DIR + \\\"test.zip\\\");\\n+  testzip.copyTo(tmpDir, tmpFile.leafName);\\n+\\n+  do_check_true(tmpFile.exists());\\n+\\n+  zipW.open(tmpFile, PR_RDWR);\\n+\\n+  for (var i = 0; i < TESTS.length; i++) {\\n+    do_check_true(zipW.hasEntry(TESTS[i]));\\n+    zipW.removeEntry(TESTS[i], true);\\n+  }\\n+\\n+  do_test_pending();\\n+  zipW.processQueue(observer, null);\\n+  do_check_true(zipW.inQueue);\\n+}\\ndiff --git a/modules/libjar/zipwriter/test/unit/test_createempty.js b/modules/libjar/zipwriter/test/unit/test_createempty.js\\nnew file mode 100644\\nindex 0000000..9c4f63d\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/test/unit/test_createempty.js\\n@@ -0,0 +1,49 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+function run_test()\\n+{\\n+  zipW.open(tmpFile, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE);\\n+  zipW.close();\\n+\\n+  // Should have created a zip file\\n+  do_check_true(tmpFile.exists());\\n+\\n+  // Empty zip file should just be the end of central directory marker\\n+  do_check_eq(tmpFile.fileSize, ZIP_EOCDR_HEADER_SIZE);\\n+}\\ndiff --git a/modules/libjar/zipwriter/test/unit/test_deflatedata.js b/modules/libjar/zipwriter/test/unit/test_deflatedata.js\\nnew file mode 100644\\nindex 0000000..8f87acb\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/test/unit/test_deflatedata.js\\n@@ -0,0 +1,87 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+const DATA = \\\"ZIP WRITER TEST DATA\\\";\\n+const FILENAME = \\\"test.txt\\\";\\n+const CRC = 0xe6164331;\\n+const time = Date.now();\\n+\\n+function run_test()\\n+{\\n+  zipW.open(tmpFile, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE);\\n+\\n+  // Shouldn't be there to start with.\\n+  do_check_false(zipW.hasEntry(FILENAME));\\n+\\n+  do_check_false(zipW.inQueue);\\n+\\n+  var stream = Cc[\\\"@mozilla.org/io/string-input-stream;1\\\"]\\n+                .createInstance(Ci.nsIStringInputStream);\\n+  stream.setData(DATA, DATA.length);\\n+  zipW.addEntryStream(FILENAME, time * PR_USEC_PER_MSEC,\\n+                      Ci.nsIZipWriter.COMPRESSION_BEST, stream, false);\\n+\\n+  var entry = zipW.getEntry(FILENAME);\\n+\\n+  do_check_true(entry != null);\\n+\\n+  // Check entry seems right.\\n+  do_check_eq(entry.compression, ZIP_METHOD_DEFLATE);\\n+  do_check_eq(entry.CRC32, CRC);\\n+  do_check_eq(entry.realSize, DATA.length);\\n+  var diff = Math.abs((entry.lastModifiedTime/PR_USEC_PER_MSEC) - time);\\n+  if (diff > TIME_RESOLUTION)\\n+    do_throw(diff);\\n+\\n+  zipW.close();\\n+\\n+  // Test the stored data with the zipreader\\n+  var zipR = new ZipReader(tmpFile);\\n+  do_check_true(zipR.hasEntry(FILENAME));\\n+\\n+  zipR.test(FILENAME);\\n+\\n+  var stream = Cc[\\\"@mozilla.org/scriptableinputstream;1\\\"]\\n+                .createInstance(Ci.nsIScriptableInputStream);\\n+  stream.init(zipR.getInputStream(FILENAME));\\n+  var result = stream.read(DATA.length);\\n+  stream.close();\\n+  zipR.close();\\n+\\n+  do_check_eq(result, DATA);\\n+}\\ndiff --git a/modules/libjar/zipwriter/test/unit/test_directory.js b/modules/libjar/zipwriter/test/unit/test_directory.js\\nnew file mode 100644\\nindex 0000000..78560ba\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/test/unit/test_directory.js\\n@@ -0,0 +1,60 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+const DIRNAME1 = \\\"test\\\";\\n+const DIRNAME1_CORRECT = \\\"test/\\\";\\n+const DIRNAME2 = \\\"test2/\\\";\\n+const time = Date.now();\\n+\\n+function run_test()\\n+{\\n+  zipW.open(tmpFile, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE);\\n+\\n+  zipW.addEntryDirectory(DIRNAME1, time * PR_USEC_PER_MSEC, false);\\n+  do_check_false(zipW.hasEntry(DIRNAME1));\\n+  do_check_true(zipW.hasEntry(DIRNAME1_CORRECT));\\n+  var entry = zipW.getEntry(DIRNAME1_CORRECT);\\n+  do_check_true(entry.isDirectory);\\n+\\n+  zipW.addEntryDirectory(DIRNAME2, time * PR_USEC_PER_MSEC, false);\\n+  do_check_true(zipW.hasEntry(DIRNAME2));\\n+  entry = zipW.getEntry(DIRNAME2);\\n+  do_check_true(entry.isDirectory);\\n+\\n+  zipW.close();\\n+}\\ndiff --git a/modules/libjar/zipwriter/test/unit/test_editexisting.js b/modules/libjar/zipwriter/test/unit/test_editexisting.js\\nnew file mode 100644\\nindex 0000000..23e1d1e\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/test/unit/test_editexisting.js\\n@@ -0,0 +1,98 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+// Values taken from using zipinfo to list the test.zip contents\\n+var TESTS = [\\n+  {\\n+    name: \\\"test.txt\\\",\\n+    size: 232,\\n+    crc: 0x0373ac26,\\n+    time: new Date(2007, 4, 1, 21, 44, 56)\\n+  },\\n+  {\\n+    name: \\\"test.png\\\",\\n+    size: 3402,\\n+    crc: 0x504a5c30,\\n+    time: new Date(2007, 4, 1, 21, 49, 40)\\n+  }\\n+];\\n+var BADENTRY = \\\"unknown.txt\\\";\\n+\\n+function run_test()\\n+{\\n+  // Copy our test zip to the tmp dir so we can modify it\\n+  var testzip = do_get_file(DATA_DIR + \\\"test.zip\\\");\\n+  testzip.copyTo(tmpDir, tmpFile.leafName);\\n+\\n+  do_check_true(tmpFile.exists());\\n+\\n+  zipW.open(tmpFile, PR_RDWR);\\n+\\n+  for (var i = 0; i < TESTS.length; i++) {\\n+    do_check_true(zipW.hasEntry(TESTS[i].name));\\n+    var entry = zipW.getEntry(TESTS[i].name);\\n+    do_check_true(entry != null);\\n+\\n+    do_check_eq(entry.realSize, TESTS[i].size);\\n+    do_check_eq(entry.CRC32, TESTS[i].crc);\\n+    var diff = Math.abs(TESTS[i].time -\\n+               (entry.lastModifiedTime / PR_USEC_PER_MSEC));\\n+    if (diff > TIME_RESOLUTION)\\n+      do_throw(diff);\\n+  }\\n+\\n+  try {\\n+    zipW.removeEntry(BADENTRY, false);\\n+    do_throw(\\\"shouldn't be able to remove an entry that doesn't exist\\\");\\n+  }\\n+  catch (e) {\\n+    do_check_eq(e.result, Components.results.NS_ERROR_FILE_NOT_FOUND);\\n+  }\\n+\\n+  for (var i = 0; i < TESTS.length; i++) {\\n+    zipW.removeEntry(TESTS[i].name, false);\\n+  }\\n+\\n+  zipW.close();\\n+\\n+  // Certain platforms cache the file size so get a fresh file to check.\\n+  tmpFile = tmpFile.clone();\\n+\\n+  // Empty zip file should just be the end of central directory marker\\n+  do_check_eq(tmpFile.fileSize, ZIP_EOCDR_HEADER_SIZE);\\n+}\\ndiff --git a/modules/libjar/zipwriter/test/unit/test_storedata.js b/modules/libjar/zipwriter/test/unit/test_storedata.js\\nnew file mode 100644\\nindex 0000000..1c84a9f\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/test/unit/test_storedata.js\\n@@ -0,0 +1,111 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+const DATA = \\\"ZIP WRITER TEST DATA\\\";\\n+const FILENAME = \\\"test.txt\\\";\\n+const FILENAME2 = \\\"test2.txt\\\";\\n+const CRC = 0xe6164331;\\n+const time = Date.now();\\n+\\n+function testpass(source)\\n+{\\n+  // Should exist.\\n+  do_check_true(source.hasEntry(FILENAME));\\n+\\n+  var entry = source.getEntry(FILENAME);\\n+  do_check_neq(entry, null);\\n+\\n+  do_check_false(entry.isDirectory);\\n+\\n+  // Should be stored\\n+  do_check_eq(entry.compression, ZIP_METHOD_STORE);\\n+\\n+  var diff = Math.abs((entry.lastModifiedTime / PR_USEC_PER_MSEC) - time);\\n+  if (diff > TIME_RESOLUTION)\\n+    do_throw(diff);\\n+\\n+  // File size should match our data size.\\n+  do_check_eq(entry.realSize, DATA.length);\\n+  // When stored sizes should match.\\n+  do_check_eq(entry.size, entry.realSize);\\n+\\n+  // Check that the CRC is accurate\\n+  do_check_eq(entry.CRC32, CRC);\\n+}\\n+\\n+function run_test()\\n+{\\n+  zipW.open(tmpFile, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE);\\n+\\n+  // Shouldn't be there to start with.\\n+  do_check_false(zipW.hasEntry(FILENAME));\\n+\\n+  do_check_false(zipW.inQueue);\\n+\\n+  var stream = Cc[\\\"@mozilla.org/io/string-input-stream;1\\\"]\\n+                .createInstance(Ci.nsIStringInputStream);\\n+  stream.setData(DATA, DATA.length);\\n+  zipW.addEntryStream(FILENAME, time * PR_USEC_PER_MSEC,\\n+                      Ci.nsIZipWriter.COMPRESSION_NONE, stream, false);\\n+\\n+  // Check that zip state is right at this stage.\\n+  testpass(zipW);\\n+  zipW.close();\\n+\\n+  do_check_eq(tmpFile.fileSize,\\n+              DATA.length + ZIP_FILE_HEADER_SIZE + ZIP_CDS_HEADER_SIZE +\\n+              (FILENAME.length * 2) + ZIP_EOCDR_HEADER_SIZE);\\n+\\n+  // Check to see if we get the same results loading afresh.\\n+  zipW.open(tmpFile, PR_RDWR);\\n+  testpass(zipW);\\n+  zipW.close();\\n+\\n+  // Test the stored data with the zipreader\\n+  var zipR = new ZipReader(tmpFile);\\n+  testpass(zipR);\\n+  zipR.test(FILENAME);\\n+  var stream = Cc[\\\"@mozilla.org/scriptableinputstream;1\\\"]\\n+                .createInstance(Ci.nsIScriptableInputStream);\\n+  stream.init(zipR.getInputStream(FILENAME));\\n+  var result = stream.read(DATA.length);\\n+  stream.close();\\n+  zipR.close();\\n+\\n+  do_check_eq(result, DATA);\\n+}\\ndiff --git a/modules/libjar/zipwriter/test/unit/test_sync.js b/modules/libjar/zipwriter/test/unit/test_sync.js\\nnew file mode 100644\\nindex 0000000..4a6862e\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/test/unit/test_sync.js\\n@@ -0,0 +1,92 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+// Values taken from using zipinfo to list the test.zip contents\\n+var TESTS = [\\n+  {\\n+    name: \\\"test.txt\\\",\\n+    size: 232,\\n+    crc: 0x0373ac26\\n+  },\\n+  {\\n+    name: \\\"test.png\\\",\\n+    size: 3402,\\n+    crc: 0x504a5c30\\n+  }\\n+];\\n+\\n+function run_test()\\n+{\\n+  zipW.open(tmpFile, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE);\\n+\\n+  var size = 0;\\n+  for (var i = 0; i < TESTS.length; i++) {\\n+    var source = do_get_file(DATA_DIR + TESTS[i].name);\\n+    zipW.addEntryFile(TESTS[i].name, Ci.nsIZipWriter.COMPRESSION_NONE, source,\\n+                      false);\\n+    size += ZIP_FILE_HEADER_SIZE + ZIP_CDS_HEADER_SIZE +\\n+            (TESTS[i].name.length*2) + TESTS[i].size;\\n+  }\\n+\\n+  zipW.close();\\n+  size += ZIP_EOCDR_HEADER_SIZE;\\n+\\n+  do_check_eq(size, tmpFile.fileSize);\\n+\\n+  // Test the stored data with the zipreader\\n+  var zipR = new ZipReader(tmpFile);\\n+\\n+  for (var i = 0; i < TESTS.length; i++) {\\n+    var source = do_get_file(DATA_DIR + TESTS[i].name);\\n+    do_check_true(zipR.hasEntry(TESTS[i].name));\\n+\\n+    var entry = zipR.getEntry(TESTS[i].name);\\n+    do_check_eq(entry.realSize, TESTS[i].size);\\n+    do_check_eq(entry.size, TESTS[i].size);\\n+    do_check_eq(entry.CRC32, TESTS[i].crc);\\n+\\n+    var diff = Math.abs((entry.lastModifiedTime/PR_USEC_PER_MSEC) -\\n+                        source.lastModifiedTime);\\n+    if (diff > TIME_RESOLUTION)\\n+      do_throw(diff);\\n+\\n+    zipR.test(TESTS[i].name);\\n+  }\\n+\\n+  zipR.close();\\n+}\\ndiff --git a/modules/libjar/zipwriter/test/unit/test_undochange.js b/modules/libjar/zipwriter/test/unit/test_undochange.js\\nnew file mode 100644\\nindex 0000000..9d18db0\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/test/unit/test_undochange.js\\n@@ -0,0 +1,74 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+// Values taken from using zipinfo to list the test.zip contents\\n+var TESTS = [\\n+  \\\"test.txt\\\",\\n+  \\\"test.png\\\"\\n+];\\n+\\n+function run_test()\\n+{\\n+  zipW.open(tmpFile, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE);\\n+\\n+  for (var i = 0; i < TESTS.length; i++) {\\n+    var source = do_get_file(DATA_DIR + TESTS[i]);\\n+    zipW.addEntryFile(TESTS[i], Ci.nsIZipWriter.COMPRESSION_NONE, source,\\n+                      false);\\n+  }\\n+\\n+  try {\\n+    var source = do_get_file(DATA_DIR + TESTS[0]);\\n+    zipW.addEntryFile(TESTS[0], Ci.nsIZipWriter.COMPRESSION_NONE, source,\\n+                      false);\\n+    do_throw(\\\"Should not be able to add the same file twice\\\");\\n+  }\\n+  catch (e) {\\n+    do_check_eq(e.result, Components.results.NS_ERROR_FILE_ALREADY_EXISTS);\\n+  }\\n+\\n+  // Remove all the tests and see if we are left with an empty zip\\n+  for (var i = 0; i < TESTS.length; i++) {\\n+    zipW.removeEntry(TESTS[i], false);\\n+  }\\n+\\n+  zipW.close();\\n+\\n+  // Empty zip file should just be the end of central directory marker\\n+  do_check_eq(tmpFile.fileSize, ZIP_EOCDR_HEADER_SIZE);\\n+}\\ndiff --git a/modules/libjar/zipwriter/test/unit/test_zipcomment.js b/modules/libjar/zipwriter/test/unit/test_zipcomment.js\\nnew file mode 100644\\nindex 0000000..3b05ea1\\n--- /dev/null\\n+++ b/modules/libjar/zipwriter/test/unit/test_zipcomment.js\\n@@ -0,0 +1,67 @@\\n+/* ***** BEGIN LICENSE BLOCK *****\\n+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n+ *\\n+ * The contents of this file are subject to the Mozilla Public License Version\\n+ * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n+ * the License. You may obtain a copy of the License at\\n+ * http://www.mozilla.org/MPL/\\n+ *\\n+ * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n+ * for the specific language governing rights and limitations under the\\n+ * License.\\n+ *\\n+ * The Original Code is Zip Writer Component.\\n+ *\\n+ * The Initial Developer of the Original Code is\\n+ * Dave Townsend <dtownsend@oxymoronical.com>.\\n+ *\\n+ * Portions created by the Initial Developer are Copyright (C) 2007\\n+ * the Initial Developer. All Rights Reserved.\\n+ *\\n+ * Contributor(s):\\n+ *\\n+ * Alternatively, the contents of this file may be used under the terms of\\n+ * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n+ * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n+ * in which case the provisions of the GPL or the LGPL are applicable instead\\n+ * of those above. If you wish to allow use of your version of this file only\\n+ * under the terms of either the GPL or the LGPL, and not to allow others to\\n+ * use your version of this file under the terms of the MPL, indicate your\\n+ * decision by deleting the provisions above and replace them with the notice\\n+ * and other provisions required by the GPL or the LGPL. If you do not delete\\n+ * the provisions above, a recipient may use your version of this file under\\n+ * the terms of any one of the MPL, the GPL or the LGPL.\\n+ *\\n+ * ***** END LICENSE BLOCK *****\\n+ */\\n+\\n+const DATA = \\\"ZIP WRITER TEST COMMENT\\\";\\n+const DATA2 = \\\"ANOTHER ONE\\\";\\n+\\n+function run_test()\\n+{\\n+  zipW.open(tmpFile, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE);\\n+  zipW.comment = DATA;\\n+  zipW.close();\\n+\\n+  // Should have created a zip file\\n+  do_check_true(tmpFile.exists());\\n+\\n+  // Empty zip file should just be the end of central directory marker\\n+  // and comment\\n+  do_check_eq(tmpFile.fileSize, ZIP_EOCDR_HEADER_SIZE + DATA.length);\\n+\\n+  zipW.open(tmpFile, PR_RDWR);\\n+  // Should have the set comment\\n+  do_check_eq(zipW.comment, DATA);\\n+  zipW.comment = DATA2;\\n+  zipW.close();\\n+\\n+  // Certain platforms cache the file size so get a fresh file to check.\\n+  tmpFile = tmpFile.clone();\\n+\\n+  // Empty zip file should just be the end of central directory marker\\n+  // and comment. This should now be shorter\\n+  do_check_eq(tmpFile.fileSize, ZIP_EOCDR_HEADER_SIZE + DATA2.length);\\n+}\\ndiff --git a/toolkit/library/libxul-config.mk b/toolkit/library/libxul-config.mk\\nindex e409e30..09d4411 100644\\n--- a/toolkit/library/libxul-config.mk\\n+++ b/toolkit/library/libxul-config.mk\\n@@ -339,6 +339,11 @@ DEFINES += -DMOZ_SPELLCHECK\\n COMPONENT_LIBS += spellchecker\\n endif\\n \\n+ifdef MOZ_ZIPWRITER\\n+DEFINES += -DMOZ_ZIPWRITER\\n+COMPONENT_LIBS += zipwriter\\n+endif\\n+\\n ifneq (,$(filter layout-debug,$(MOZ_EXTENSIONS)))\\n COMPONENT_LIBS += gkdebug\\n endif\\ndiff --git a/toolkit/library/nsStaticXULComponents.cpp b/toolkit/library/nsStaticXULComponents.cpp\\nindex bf5aa94..d525541 100644\\n--- a/toolkit/library/nsStaticXULComponents.cpp\\n+++ b/toolkit/library/nsStaticXULComponents.cpp\\n@@ -222,6 +222,12 @@\\n #define STORAGE_MODULE\\n #endif\\n \\n+#ifdef MOZ_ZIPWRITER\\n+#define ZIPWRITER_MODULE MODULE(ZipWriterModule)\\n+#else\\n+#define ZIPWRITER_MODULE\\n+#endif\\n+\\n #ifdef MOZ_PLACES\\n #define PLACES_MODULES \\\\\\n     MODULE(nsPlacesModule)\\n@@ -268,6 +274,7 @@\\n     AUTH_MODULE                              \\\\\\n     IPC_MODULE                               \\\\\\n     MODULE(nsJarModule)                      \\\\\\n+    ZIPWRITER_MODULE                         \\\\\\n     MODULE(nsPrefModule)                     \\\\\\n     MODULE(nsSecurityManagerModule)          \\\\\\n     RDF_MODULE                               \\\\\\ndiff --git a/toolkit/toolkit-makefiles.sh b/toolkit/toolkit-makefiles.sh\\nindex 1b6d720..e5215f5 100644\\n--- a/toolkit/toolkit-makefiles.sh\\n+++ b/toolkit/toolkit-makefiles.sh\\n@@ -840,6 +840,15 @@ if [ \\\"$MOZ_COMPOSER\\\" ]; then\\n   \\\"\\n fi\\n \\n+if [ \\\"$MOZ_ZIPWRITER\\\" ]; then\\n+  add_makefiles \\\"\\n+    modules/libjar/zipwriter/Makefile\\n+    modules/libjar/zipwriter/public/Makefile\\n+    modules/libjar/zipwriter/src/Makefile\\n+    modules/libjar/zipwriter/test/Makefile\\n+  \\\"\\n+fi\\n+\\n if [ \\\"$MOZ_STORAGE\\\" ]; then\\n   add_makefiles \\\"\\n     db/sqlite3/src/Makefile\\n\""}