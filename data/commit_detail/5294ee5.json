{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas5294ee5\""},"diff":"\"5294ee5 canvas3d fixes for bug 396972; npotb\\ndiff --git a/extensions/canvas3d/src/Makefile.in b/extensions/canvas3d/src/Makefile.in\\nindex ed4767e..0f6190e 100644\\n--- a/extensions/canvas3d/src/Makefile.in\\n+++ b/extensions/canvas3d/src/Makefile.in\\n@@ -52,39 +52,29 @@ EXPORT_LIBRARY\\t= 0\\n IS_COMPONENT\\t= 1\\n MODULE_NAME\\t= nsCanvas3DModule\\n GRE_MODULE\\t= 1\\n-MOZILLA_INTERNAL_API = 1\\n BUILD_STATIC_LIBS =\\n \\n REQUIRES\\t= \\\\\\n \\t\\txpcom \\\\\\n \\t\\tstring \\\\\\n-\\t\\tgfx \\\\\\n+\\t\\tunicharutil \\\\\\n+\\t\\txpconnect \\\\\\n+\\t\\tthebes \\\\\\n+\\t\\tcairo \\\\\\n \\t\\tcontent \\\\\\n-\\t\\tlayout \\\\\\n-\\t\\twidget \\\\\\n \\t\\tdom \\\\\\n+\\t\\tcaps \\\\\\n \\t\\tjs \\\\\\n-\\t\\tlocale \\\\\\n-\\t\\tunicharutil \\\\\\n+\\t\\timglib2 \\\\\\n \\t\\tnecko \\\\\\n-\\t\\tview \\\\\\n+\\t\\tgfx \\\\\\n+\\t\\tlayout \\\\\\n+\\t\\twidget \\\\\\n+\\t\\tlocale \\\\\\n \\t\\tpref \\\\\\n-\\t\\tdocshell \\\\\\n-\\t\\txpconnect \\\\\\n-\\t\\txuldoc \\\\\\n-\\t\\tcaps \\\\\\n-\\t\\timglib2 \\\\\\n-\\t\\tmimetype \\\\\\n-\\t\\texthandler \\\\\\n-\\t\\tuconv \\\\\\n-\\t\\tintl \\\\\\n-\\t\\tcairo \\\\\\n+\\t\\tview \\\\\\n \\t\\t$(NULL)\\n \\n-ifdef MOZ_ENABLE_CAIRO_GFX\\n-REQUIRES += thebes\\n-endif\\n-\\n ifdef MOZ_X11\\n EXTRA_DSO_LIBS += GL\\n endif\\n@@ -109,12 +99,7 @@ CPPSRCS\\t\\t= nsCanvas3DModule.cpp \\\\\\n \\n DEFINES += -DXPCOM_GLUE -DXPCOM_GLUE_USE_NSPR -DGLEW_MX -DGLEW_STATIC\\n \\n-EXTRA_DSO_LIBS += js3250 xpcom xpcom_core unicharutil_s\\n-# mozcairo mozlibpixman\\n-\\n-ifdef MOZ_ENABLE_CAIRO_GFX\\n-EXTRA_DSO_LDOPTS += $(DEPTH)/gfx/thebes/src/thebes.lib $(DEPTH)/gfx/src/gkgfx.lib\\n-endif\\n+EXTRA_DSO_LIBS += js3250 xpcom xul\\n \\n # Hack for getting an extension built against static vs. dynamic versions of firefox\\n ##ifeq (,$(BUILD_STATIC_LIBS))\\n@@ -138,4 +123,4 @@ endif\\n ifneq (,$(filter $(MOZ_WIDGET_TOOLKIT),mac cocoa))\\n endif\\n \\n-EXTRA_DSO_LDOPTS += $(LIBS_DIR) $(EXTRA_DSO_LIBS)\\n+EXTRA_DSO_LDOPTS += $(LIBS_DIR) $(EXTRA_DSO_LIBS) $(XPCOM_GLUE_LDOPTS)\\ndiff --git a/extensions/canvas3d/src/nsCanvasRenderingContextGL.cpp b/extensions/canvas3d/src/nsCanvasRenderingContextGL.cpp\\nindex 449aab4..fd56122 100644\\n--- a/extensions/canvas3d/src/nsCanvasRenderingContextGL.cpp\\n+++ b/extensions/canvas3d/src/nsCanvasRenderingContextGL.cpp\\n@@ -50,9 +50,7 @@\\n #include \\\"nsIView.h\\\"\\n #include \\\"nsIViewManager.h\\\"\\n \\n-#ifndef MOZILLA_1_8_BRANCH\\n #include \\\"nsIDocument.h\\\"\\n-#endif\\n \\n #include \\\"nsTransform2D.h\\\"\\n \\n@@ -68,20 +66,17 @@\\n #include \\\"nsIImageLoadingContent.h\\\"\\n #include \\\"nsIInterfaceRequestorUtils.h\\\"\\n #include \\\"nsIImage.h\\\"\\n-#include \\\"nsIFrame.h\\\"\\n #include \\\"nsDOMError.h\\\"\\n #include \\\"nsIJSRuntimeService.h\\\"\\n \\n-#ifndef MOZILLA_1_8_BRANCH\\n+#include \\\"nsIPrefService.h\\\"\\n+\\n #include \\\"nsIClassInfoImpl.h\\\"\\n-#endif\\n \\n #include \\\"nsServiceManagerUtils.h\\\"\\n \\n #include \\\"nsDOMError.h\\\"\\n \\n-#include \\\"nsContentUtils.h\\\"\\n-\\n #include \\\"nsIXPConnect.h\\\"\\n #include \\\"jsapi.h\\\"\\n \\n@@ -90,34 +85,8 @@\\n \\n // we're hoping that something is setting us up the remap\\n \\n-#include \\\"cairo.h\\\"\\n-\\n-#ifdef MOZ_CAIRO_GFX\\n #include \\\"gfxContext.h\\\"\\n #include \\\"gfxASurface.h\\\"\\n-#endif\\n-\\n-#ifdef XP_WIN\\n-#ifdef MOZILLA_1_8_BRANCH\\n-struct _cairo_surface_win32_hack {\\n-    void *ptr;\\n-    unsigned int refcnt;\\n-    cairo_status_t st;\\n-    cairo_bool_t finished;\\n-    /* array_t */\\n-    int sz;\\n-    int num_el;\\n-    int el_sz;\\n-    void *elements;\\n-    double dx, dy, dxs, dys;\\n-    unsigned int a;\\n-    unsigned int b;\\n-\\n-    /* win32 */\\n-    cairo_format_t format;\\n-};\\n-#endif\\n-#endif\\n \\n #ifdef MOZ_X11\\n #include <gdk/gdk.h>\\n@@ -544,13 +513,8 @@ nsCanvasRenderingContextGLPrivate::SetDimensions(PRInt32 width, PRInt32 height)\\n     return NS_OK;\\n }\\n \\n-/*\\n- * This is identical to nsCanvasRenderingContext2D::Render, we just don't\\n- * have a good place to put it; though maybe I want a CanvasContextImpl that\\n- * all this stuff can derive from?\\n- */\\n NS_IMETHODIMP\\n-nsCanvasRenderingContextGLPrivate::Render(nsIRenderingContext *rc)\\n+nsCanvasRenderingContextGLPrivate::Render(gfxContext *ctx)\\n {\\n     nsresult rv = NS_OK;\\n \\n@@ -560,8 +524,6 @@ nsCanvasRenderingContextGLPrivate::Render(nsIRenderingContext *rc)\\n     if (!mGLPbuffer->ThebesSurface())\\n         return NS_OK;\\n \\n-#ifdef MOZ_CAIRO_GFX\\n-    gfxContext* ctx = (gfxContext*) rc->GetNativeGraphicData(nsIRenderingContext::NATIVE_THEBES_CONTEXT);\\n     nsRefPtr<gfxASurface> surf = mGLPbuffer->ThebesSurface();\\n     nsRefPtr<gfxPattern> pat = new gfxPattern(surf);\\n \\n@@ -570,171 +532,13 @@ nsCanvasRenderingContextGLPrivate::Render(nsIRenderingContext *rc)\\n     ctx->NewPath();\\n     ctx->PixelSnappedRectangleAndSetPattern(gfxRect(0, 0, mWidth, mHeight), pat);\\n     ctx->Fill();\\n-#else\\n-\\n-    // non-Thebes; this becomes exciting\\n-    cairo_surface_t *dest = nsnull;\\n-    cairo_t *dest_cr = nsnull;\\n-\\n-#ifdef XP_WIN\\n-    void *ptr = nsnull;\\n-#ifdef MOZILLA_1_8_BRANCH\\n-    rv = rc->RetrieveCurrentNativeGraphicData(&ptr);\\n-    if (NS_FAILED(rv) || !ptr)\\n-        return NS_ERROR_FAILURE;\\n-#else\\n-    ptr = rc->GetNativeGraphicData(nsIRenderingContext::NATIVE_WINDOWS_DC);\\n-#endif\\n-    HDC dc = (HDC) ptr;\\n-\\n-    dest = cairo_win32_surface_create (dc);\\n-    dest_cr = cairo_create (dest);\\n-#endif\\n-\\n-#ifdef MOZ_WIDGET_GTK2\\n-    GdkDrawable *gdkdraw = nsnull;\\n-#ifdef MOZILLA_1_8_BRANCH\\n-    rv = rc->RetrieveCurrentNativeGraphicData((void**) &gdkdraw);\\n-    if (NS_FAILED(rv) || !gdkdraw)\\n-        return NS_ERROR_FAILURE;\\n-#else\\n-    gdkdraw = (GdkDrawable*) rc->GetNativeGraphicData(nsIRenderingContext::NATIVE_GDK_DRAWABLE);\\n-    if (!gdkdraw)\\n-        return NS_ERROR_FAILURE;\\n-#endif\\n-\\n-    gint w, h;\\n-    gdk_drawable_get_size (gdkdraw, &w, &h);\\n-    dest = cairo_xlib_surface_create (GDK_DRAWABLE_XDISPLAY(gdkdraw),\\n-                                      GDK_DRAWABLE_XID(gdkdraw),\\n-                                      GDK_VISUAL_XVISUAL(gdk_drawable_get_visual(gdkdraw)),\\n-                                      w, h);\\n-    dest_cr = cairo_create (dest);\\n-#endif\\n-\\n-    nsTransform2D *tx = nsnull;\\n-    rc->GetCurrentTransform(tx);\\n-\\n-    nsCOMPtr<nsIDeviceContext> dctx;\\n-    rc->GetDeviceContext(*getter_AddRefs(dctx));\\n-\\n-    // Until we can use the quartz2 surface, mac will be different,\\n-    // since we'll use CG to render.\\n-#ifndef XP_MACOSX\\n-\\n-    float x0 = 0.0, y0 = 0.0;\\n-    float sx = 1.0, sy = 1.0;\\n-    if (tx->GetType() & MG_2DTRANSLATION) {\\n-        tx->Transform(&x0, &y0);\\n-    }\\n-\\n-    if (tx->GetType() & MG_2DSCALE) {\\n-        sx = sy = dctx->DevUnitsToTwips();\\n-        tx->TransformNoXLate(&sx, &sy);\\n-    }\\n-\\n-    cairo_translate (dest_cr, NSToIntRound(x0), NSToIntRound(y0));\\n-    if (sx != 1.0 || sy != 1.0)\\n-        cairo_scale (dest_cr, sx, sy);\\n-\\n-    cairo_rectangle (dest_cr, 0, 0, mWidth, mHeight);\\n-    cairo_clip (dest_cr);\\n-\\n-    cairo_set_source_surface (dest_cr, mCairoImageSurface, 0, 0);\\n-    cairo_paint (dest_cr);\\n-\\n-    if (dest_cr)\\n-        cairo_destroy (dest_cr);\\n-    if (dest)\\n-        cairo_surface_destroy (dest);\\n-\\n-#else\\n-\\n-    // OSX path\\n-\\n-    CGrafPtr port = nsnull;\\n-#ifdef MOZILLA_1_8_BRANCH\\n-    rv = rc->RetrieveCurrentNativeGraphicData((void**) &port);\\n-    if (NS_FAILED(rv) || !port)\\n-        return NS_ERROR_FAILURE;\\n-#else\\n-    port = (CGrafPtr) rc->GetNativeGraphicData(nsIRenderingContext::NATIVE_MAC_THING);\\n-    if (!port)\\n-        return NS_ERROR_FAILURE;\\n-#endif\\n-\\n-    struct Rect portRect;\\n-    GetPortBounds(port, &portRect);\\n-\\n-    CGContextRef cgc;\\n-    OSStatus status;\\n-    status = QDBeginCGContext (port, &cgc);\\n-    if (status != noErr)\\n-        return NS_ERROR_FAILURE;\\n-\\n-    CGDataProviderRef dataProvider;\\n-    CGImageRef img;\\n-\\n-    dataProvider = CGDataProviderCreateWithData (NULL, mImageBuffer,\\n-                                                 mWidth * mHeight * 4,\\n-                                                 NULL);\\n-    CGColorSpaceRef rgb = CGColorSpaceCreateDeviceRGB();\\n-    img = CGImageCreate (mWidth, mHeight, 8, 32, mWidth * 4, rgb,\\n-                         kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host,\\n-                         dataProvider, NULL, false, kCGRenderingIntentDefault);\\n-    CGColorSpaceRelease (rgb);\\n-    CGDataProviderRelease (dataProvider);\\n-\\n-    float x0 = 0.0, y0 = 0.0;\\n-    float sx = 1.0, sy = 1.0;\\n-    if (tx->GetType() & MG_2DTRANSLATION) {\\n-        tx->Transform(&x0, &y0);\\n-    }\\n-\\n-    if (tx->GetType() & MG_2DSCALE) {\\n-        float p2t = dctx->DevUnitsToTwips();\\n-        sx = p2t, sy = p2t;\\n-        tx->TransformNoXLate(&sx, &sy);\\n-    }\\n-\\n-    /* Compensate for the bottom-left Y origin */\\n-    CGContextTranslateCTM (cgc, NSToIntRound(x0),\\n-                           portRect.bottom - portRect.top - NSToIntRound(y0) - NSToIntRound(mHeight * sy));\\n-    if (sx != 1.0 || sy != 1.0)\\n-        CGContextScaleCTM (cgc, sx, sy);\\n-\\n-    CGContextDrawImage (cgc, CGRectMake(0, 0, mWidth, mHeight), img);\\n-\\n-    CGImageRelease (img);\\n-\\n-    status = QDEndCGContext (port, &cgc);\\n-    /* if EndCGContext fails, what can we do? */\\n-#endif\\n-#endif\\n \\n     return rv;\\n }\\n \\n NS_IMETHODIMP\\n-nsCanvasRenderingContextGLPrivate::RenderToSurface(cairo_surface_t *surf)\\n-{\\n-    return NS_OK;\\n-}\\n-\\n-nsIFrame*\\n-nsCanvasRenderingContextGLPrivate::GetCanvasLayoutFrame()\\n-{\\n-    if (!mCanvasElement)\\n-        return nsnull;\\n-\\n-    nsIFrame *fr = nsnull;\\n-    mCanvasElement->GetPrimaryCanvasFrame(&fr);\\n-    return fr;\\n-}\\n-\\n-NS_IMETHODIMP\\n-nsCanvasRenderingContextGLPrivate::GetInputStream(const nsACString& aMimeType,\\n-                                                  const nsAString& aEncoderOptions,\\n+nsCanvasRenderingContextGLPrivate::GetInputStream(const char* aMimeType,\\n+                                                  const PRUnichar* aEncoderOptions,\\n                                                   nsIInputStream **aStream)\\n {\\n     return NS_ERROR_NOT_IMPLEMENTED;\\n@@ -746,7 +550,7 @@ nsCanvasRenderingContextGLPrivate::GetInputStream(const nsACString& aMimeType,\\n \\n nsresult\\n nsCanvasRenderingContextGLPrivate::CairoSurfaceFromElement(nsIDOMElement *imgElt,\\n-                                                           cairo_surface_t **aCairoSurface,\\n+                                                           gfxASurface **aThebesSurface,\\n                                                            PRUint8 **imgData,\\n                                                            PRInt32 *widthOut, PRInt32 *heightOut,\\n                                                            nsIURI **uriOut, PRBool *forceWriteOnlyOut)\\n@@ -781,23 +585,20 @@ nsCanvasRenderingContextGLPrivate::CairoSurfaceFromElement(nsIDOMElement *imgElt\\n             rv = canvas->GetSize(&w, &h);\\n             NS_ENSURE_SUCCESS(rv, rv);\\n \\n-            PRUint8 *data = (PRUint8*) PR_Malloc(w * h * 4);\\n-            cairo_surface_t *surf =\\n-                cairo_image_surface_create_for_data (data, CAIRO_FORMAT_ARGB32,\\n-                                                     w, h, w*4);\\n-            cairo_t *cr = cairo_create (surf);\\n-            cairo_set_operator (cr, CAIRO_OPERATOR_CLEAR);\\n-            cairo_paint (cr);\\n-            cairo_destroy (cr);\\n-\\n-            rv = canvas->RenderContextsToSurface(surf);\\n-            if (NS_FAILED(rv)) {\\n-                cairo_surface_destroy (surf);\\n+            nsRefPtr<gfxImageSurface> surf =\\n+                new gfxImageSurface (gfxIntSize(w, h), gfxASurface::ImageFormatARGB32);\\n+            nsRefPtr<gfxContext> ctx = new gfxContext(surf);\\n+            ctx->SetOperator(gfxContext::OPERATOR_CLEAR);\\n+            ctx->Paint();\\n+            ctx->SetOperator(gfxContext::OPERATOR_OVER);\\n+\\n+            rv = canvas->RenderContexts(ctx);\\n+            if (NS_FAILED(rv))\\n                 return rv;\\n-            }\\n \\n-            *aCairoSurface = surf;\\n-            *imgData = data;\\n+            NS_ADDREF(surf.get());\\n+            *aThebesSurface = surf;\\n+            *imgData = surf->Data();\\n             *widthOut = w;\\n             *heightOut = h;\\n \\n@@ -831,266 +632,10 @@ nsCanvasRenderingContextGLPrivate::CairoSurfaceFromElement(nsIDOMElement *imgElt\\n     if (heightOut)\\n         *heightOut = imgHeight;\\n \\n-#ifdef MOZ_CAIRO_GFX\\n-    gfxASurface* gfxsurf = nsnull;\\n-    rv = img->GetSurface(&gfxsurf);\\n+    rv = img->GetSurface(aThebesSurface);\\n     NS_ENSURE_SUCCESS(rv, rv);\\n \\n-    *aCairoSurface = gfxsurf->CairoSurface();\\n-    cairo_surface_reference (*aCairoSurface);\\n     *imgData = nsnull;\\n-#else\\n-    //\\n-    // We now need to create a cairo_surface with the same data as\\n-    // this image element.\\n-    //\\n-\\n-    PRUint8 *cairoImgData = (PRUint8 *)nsMemory::Alloc(imgHeight * imgWidth * 4);\\n-    PRUint8 *outData = cairoImgData;\\n-\\n-    gfx_format format;\\n-    rv = frame->GetFormat(&format);\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-    rv = frame->LockImageData();\\n-    if (img->GetHasAlphaMask())\\n-        rv |= frame->LockAlphaData();\\n-    if (NS_FAILED(rv)) {\\n-        nsMemory::Free(cairoImgData);\\n-        return NS_ERROR_FAILURE;\\n-    }\\n-\\n-    PRUint8 *inPixBits, *inAlphaBits = nsnull;\\n-    PRUint32 inPixStride, inAlphaStride = 0;\\n-    inPixBits = img->GetBits();\\n-    inPixStride = img->GetLineStride();\\n-    if (img->GetHasAlphaMask()) {\\n-        inAlphaBits = img->GetAlphaBits();\\n-        inAlphaStride = img->GetAlphaLineStride();\\n-    }\\n-\\n-    PRBool topToBottom = img->GetIsRowOrderTopToBottom();\\n-    PRBool useBGR;\\n-\\n-    // The gtk backend optimizes away the alpha mask of images\\n-    // with a fully opaque alpha, but doesn't update its format (bug?);\\n-    // you end up with a RGB_A8 image with GetHasAlphaMask() == false.\\n-    // We need to treat that case as RGB.\\n-\\n-    if ((format == gfxIFormats::RGB || format == gfxIFormats::BGR) ||\\n-        (!(img->GetHasAlphaMask()) && (format == gfxIFormats::RGB_A8 || format == gfxIFormats::BGR_A8)))\\n-    {\\n-        useBGR = (format & 1);\\n-\\n-#ifdef IS_BIG_ENDIAN\\n-        useBGR = !useBGR;\\n-#endif\\n-\\n-        for (PRUint32 j = 0; j < (PRUint32) imgHeight; j++) {\\n-            PRUint32 rowIndex;\\n-            if (topToBottom)\\n-                rowIndex = j;\\n-            else\\n-                rowIndex = imgHeight - j - 1;\\n-\\n-            PRUint8 *inrowrgb = inPixBits + (inPixStride * rowIndex);\\n-\\n-            for (PRUint32 i = 0; i < (PRUint32) imgWidth; i++) {\\n-                // handle rgb data; no alpha to premultiply\\n-#ifdef XP_MACOSX\\n-                // skip extra OSX byte\\n-                inrowrgb++;\\n-#endif\\n-                PRUint8 r, g, b;\\n-                if (useBGR) {\\n-                    b = *inrowrgb++;\\n-                    g = *inrowrgb++;\\n-                    r = *inrowrgb++;\\n-                } else {\\n-                    r = *inrowrgb++;\\n-                    g = *inrowrgb++;\\n-                    b = *inrowrgb++;\\n-                }\\n-\\n-#ifdef IS_BIG_ENDIAN\\n-                // alpha\\n-                *outData++ = 0xff;\\n-#endif\\n-\\n-                *outData++ = r;\\n-                *outData++ = g;\\n-                *outData++ = b;\\n-\\n-#ifdef IS_LITTLE_ENDIAN\\n-                // alpha\\n-                *outData++ = 0xff;\\n-#endif\\n-            }\\n-        }\\n-        rv = NS_OK;\\n-    } else if (format == gfxIFormats::RGB_A1 || format == gfxIFormats::BGR_A1) {\\n-        useBGR = (format & 1);\\n-\\n-#ifdef IS_BIG_ENDIAN\\n-        useBGR = !useBGR;\\n-#endif\\n-\\n-        for (PRUint32 j = 0; j < (PRUint32) imgHeight; j++) {\\n-            PRUint32 rowIndex;\\n-            if (topToBottom)\\n-                rowIndex = j;\\n-            else\\n-                rowIndex = imgHeight - j - 1;\\n-\\n-            PRUint8 *inrowrgb = inPixBits + (inPixStride * rowIndex);\\n-            PRUint8 *inrowalpha = inAlphaBits + (inAlphaStride * rowIndex);\\n-\\n-            for (PRUint32 i = 0; i < (PRUint32) imgWidth; i++) {\\n-                // pull out the bit value into alpha\\n-                PRInt32 bit = i % 8;\\n-                PRInt32 byte = i / 8;\\n-\\n-#ifdef IS_LITTLE_ENDIAN\\n-                PRUint8 a = (inrowalpha[byte] >> (7-bit)) & 1;\\n-#else\\n-                PRUint8 a = (inrowalpha[byte] >> bit) & 1;\\n-#endif\\n-\\n-#ifdef XP_MACOSX\\n-                // skip extra X8 byte on OSX\\n-                inrowrgb++;\\n-#endif\\n-\\n-                // handle rgb data; need to multiply the alpha out,\\n-                // but we short-circuit that here since we know that a\\n-                // can only be 0 or 1\\n-                if (a) {\\n-                    PRUint8 r, g, b;\\n-\\n-                    if (useBGR) {\\n-                        b = *inrowrgb++;\\n-                        g = *inrowrgb++;\\n-                        r = *inrowrgb++;\\n-                    } else {\\n-                        r = *inrowrgb++;\\n-                        g = *inrowrgb++;\\n-                        b = *inrowrgb++;\\n-                    }\\n-\\n-#ifdef IS_BIG_ENDIAN\\n-                    // alpha\\n-                    *outData++ = 0xff;\\n-#endif\\n-\\n-                    *outData++ = r;\\n-                    *outData++ = g;\\n-                    *outData++ = b;\\n-\\n-#ifdef IS_LITTLE_ENDIAN\\n-                    // alpha\\n-                    *outData++ = 0xff;\\n-#endif\\n-                } else {\\n-                    // alpha is 0, so we need to write all 0's,\\n-                    // ignoring input color\\n-                    inrowrgb += 3;\\n-                    *outData++ = 0;\\n-                    *outData++ = 0;\\n-                    *outData++ = 0;\\n-                    *outData++ = 0;\\n-                }\\n-            }\\n-        }\\n-        rv = NS_OK;\\n-    } else if (format == gfxIFormats::RGB_A8 || format == gfxIFormats::BGR_A8) {\\n-        useBGR = (format & 1);\\n-\\n-#ifdef IS_BIG_ENDIAN\\n-        useBGR = !useBGR;\\n-#endif\\n-\\n-        for (PRUint32 j = 0; j < (PRUint32) imgHeight; j++) {\\n-            PRUint32 rowIndex;\\n-            if (topToBottom)\\n-                rowIndex = j;\\n-            else\\n-                rowIndex = imgHeight - j - 1;\\n-\\n-            PRUint8 *inrowrgb = inPixBits + (inPixStride * rowIndex);\\n-            PRUint8 *inrowalpha = inAlphaBits + (inAlphaStride * rowIndex);\\n-\\n-            for (PRUint32 i = 0; i < (PRUint32) imgWidth; i++) {\\n-                // pull out alpha; we'll need it to premultiply\\n-                PRUint8 a = *inrowalpha++;\\n-\\n-                // handle rgb data; we need to fully premultiply\\n-                // with the alpha\\n-#ifdef XP_MACOSX\\n-                // skip extra X8 byte on OSX\\n-                inrowrgb++;\\n-#endif\\n-\\n-                // XXX gcc bug: gcc seems to push \\\"r\\\" into a register\\n-                // early, and pretends that it's in that register\\n-                // throughout the 3 macros below.  At the end\\n-                // of the 3rd macro, the correct r value is\\n-                // calculated but never stored anywhere -- the r variable\\n-                // has the value of the low byte of register that it\\n-                // was stuffed into, which has the result of some \\n-                // intermediate calculation.\\n-                // I've seen this on gcc 3.4.2 x86 (Fedora Core 3)\\n-                // and gcc 3.3 PPC (OS X 10.3)\\n-\\n-                //PRUint8 b, g, r;\\n-                //FAST_DIVIDE_BY_255(b, *inrowrgb++ * a - a / 2);\\n-                //FAST_DIVIDE_BY_255(g, *inrowrgb++ * a - a / 2);\\n-                //FAST_DIVIDE_BY_255(r, *inrowrgb++ * a - a / 2);\\n-\\n-                PRUint8 r, g, b;\\n-                if (useBGR) {\\n-                    b = (*inrowrgb++ * a - a / 2) / 255;\\n-                    g = (*inrowrgb++ * a - a / 2) / 255;\\n-                    r = (*inrowrgb++ * a - a / 2) / 255;\\n-                } else {\\n-                    r = (*inrowrgb++ * a - a / 2) / 255;\\n-                    g = (*inrowrgb++ * a - a / 2) / 255;\\n-                    b = (*inrowrgb++ * a - a / 2) / 255;\\n-                }\\n-\\n-#ifdef IS_BIG_ENDIAN\\n-                *outData++ = a;\\n-#endif\\n-\\n-                *outData++ = r;\\n-                *outData++ = g;\\n-                *outData++ = b;\\n-\\n-#ifdef IS_LITTLE_ENDIAN\\n-                *outData++ = a;\\n-#endif\\n-            }\\n-        }\\n-        rv = NS_OK;\\n-    } else {\\n-        rv = NS_ERROR_FAILURE;\\n-    }\\n-\\n-    if (img->GetHasAlphaMask())\\n-        frame->UnlockAlphaData();\\n-    frame->UnlockImageData();\\n-\\n-    if (NS_FAILED(rv)) {\\n-        nsMemory::Free(cairoImgData);\\n-        return rv;\\n-    }\\n-\\n-    cairo_surface_t *imgSurf =\\n-        cairo_image_surface_create_for_data(cairoImgData, CAIRO_FORMAT_ARGB32,\\n-                                            imgWidth, imgHeight, imgWidth*4);\\n-\\n-    *aCairoSurface = imgSurf;\\n-    *imgData = cairoImgData;\\n-#endif\\n \\n     return NS_OK;\\n }\\n@@ -1125,27 +670,6 @@ nsCanvasRenderingContextGLPrivate::DoDrawImageSecurityCheck(nsIURI* aURI, PRBool\\n     }\\n \\n     fprintf (stderr, \\\"DoDrawImageSecuritycheck this 5: %p\\\\n\\\", this);\\n-#ifdef MOZILLA_1_8_BRANCH\\n-#if 0\\n-    nsCOMPtr<nsIDOMNode> elem = do_QueryInterface(mCanvasElement);\\n-    if (elem && ssm) {\\n-        nsCOMPtr<nsIPrincipal> elemPrincipal;\\n-        nsCOMPtr<nsIPrincipal> uriPrincipal;\\n-        nsCOMPtr<nsIDocument> elemDocument;\\n-        nsContentUtils::GetDocumentAndPrincipal(elem, getter_AddRefs(elemDocument), getter_AddRefs(elemPrincipal));\\n-        ssm->GetCodebasePrincipal(aURI, getter_AddRefs(uriPrincipal));\\n-\\n-        if (uriPrincipal && elemPrincipal) {\\n-            nsresult rv =\\n-                ssm->CheckSameOriginPrincipal(elemPrincipal, uriPrincipal);\\n-            if (NS_SUCCEEDED(rv)) {\\n-                // Same origin\\n-                return;\\n-            }\\n-        }\\n-    }\\n-#endif\\n-#else\\n     nsCOMPtr<nsINode> elem = do_QueryInterface(mCanvasElement);\\n     if (elem && ssm) {\\n         nsCOMPtr<nsIPrincipal> uriPrincipal;\\n@@ -1160,7 +684,6 @@ nsCanvasRenderingContextGLPrivate::DoDrawImageSecurityCheck(nsIURI* aURI, PRBool\\n             }\\n         }\\n     }\\n-#endif\\n \\n     fprintf (stderr, \\\"DoDrawImageSecuritycheck this 6: %p\\\\n\\\", this); fflush(stderr);\\n     mCanvasElement->SetWriteOnly();\\n@@ -1221,43 +744,11 @@ nsCanvasRenderingContextGLPrivate::DoSwapBuffers()\\n {\\n     mGLPbuffer->SwapBuffers();\\n \\n-    // then invalidate the region and do a sync redraw\\n-    // (uh, why sync?)\\n-    nsIFrame *frame = GetCanvasLayoutFrame();\\n-    if (frame) {\\n-        nsRect r = frame->GetRect();\\n-        r.x = r.y = 0;\\n-\\n-        // sync redraw\\n-        //frame->Invalidate(r, PR_TRUE);\\n-\\n-        // nsIFrame::Invalidate is an internal non-virtual method,\\n-        // so we basically recreate it here.  I would suggest\\n-        // an InvalidateExternal for the trunk.\\n-        nsIPresShell *shell = frame->PresContext()->GetPresShell();\\n-        if (shell) {\\n-            PRBool suppressed = PR_FALSE;\\n-            shell->IsPaintingSuppressed(&suppressed);\\n-            if (suppressed)\\n-                return NS_OK;\\n-        }\\n-\\n-        // maybe VMREFRESH_IMMEDIATE in some cases,\\n-        // need to think\\n-        PRUint32 flags = NS_VMREFRESH_NO_SYNC;\\n-        if (frame->HasView()) {\\n-            nsIView* view = frame->GetViewExternal();\\n-            view->GetViewManager()->UpdateView(view, r, flags);\\n-        } else {\\n-            nsPoint offset;\\n-            nsIView *view;\\n-            frame->GetOffsetFromView(offset, &view);\\n-            NS_ASSERTION(view, \\\"no view\\\");\\n-            r += offset;\\n-            view->GetViewManager()->UpdateView(view, r, flags);\\n-        }\\n-    }\\n+    // then invalidate the region and do a redraw\\n+    if (!mCanvasElement)\\n+        return NS_OK;\\n \\n+    mCanvasElement->InvalidateFrame();\\n     return NS_OK;\\n }\\n \\n@@ -1298,3 +789,16 @@ nsCanvasRenderingContextGLPrivate::SafeToCreateCanvas3DContext()\\n \\n     return PR_FALSE;\\n }\\n+\\n+/*\\n+ * We need this here, because nsAString has a different type name based on whether it's\\n+ * used internally or externally.  BeginPrinting isn't ever called, but gfxImageSurface\\n+ * wants to inherit the default definition, and it can't find it.  So instead, we just\\n+ * stick a stub here to shut the compiler up, because we never call this method.\\n+ */\\n+\\n+nsresult\\n+gfxASurface::BeginPrinting(const nsAString& aTitle, const nsAString& aPrintToFileName)\\n+{\\n+    return NS_ERROR_NOT_IMPLEMENTED;\\n+}\\ndiff --git a/extensions/canvas3d/src/nsCanvasRenderingContextGL.h b/extensions/canvas3d/src/nsCanvasRenderingContextGL.h\\nindex 2c0d205..065689b 100644\\n--- a/extensions/canvas3d/src/nsCanvasRenderingContextGL.h\\n+++ b/extensions/canvas3d/src/nsCanvasRenderingContextGL.h\\n@@ -44,6 +44,8 @@\\n #include <stdlib.h>\\n #include \\\"prmem.h\\\"\\n \\n+#include \\\"nsStringGlue.h\\\"\\n+\\n #include \\\"nsICanvasRenderingContextGLBuffer.h\\\"\\n #include \\\"nsICanvasRenderingContextInternal.h\\\"\\n #include \\\"nsIDOMHTMLCanvasElement.h\\\"\\n@@ -64,7 +66,6 @@\\n #include \\\"nsIImageLoadingContent.h\\\"\\n #include \\\"nsIInterfaceRequestorUtils.h\\\"\\n #include \\\"nsIImage.h\\\"\\n-#include \\\"nsIFrame.h\\\"\\n #include \\\"nsDOMError.h\\\"\\n #include \\\"nsIJSRuntimeService.h\\\"\\n \\n@@ -73,12 +74,13 @@\\n \\n #include \\\"nsDOMError.h\\\"\\n \\n-#include \\\"nsContentUtils.h\\\"\\n+#include \\\"nsServiceManagerUtils.h\\\"\\n \\n #include \\\"nsIXPConnect.h\\\"\\n #include \\\"jsapi.h\\\"\\n \\n-#include \\\"cairo.h\\\"\\n+#include \\\"gfxContext.h\\\"\\n+\\n #include \\\"glew.h\\\"\\n \\n #include \\\"nsGLPbuffer.h\\\"\\n@@ -122,18 +124,16 @@ public:\\n     // nsICanvasRenderingContextInternal\\n     NS_IMETHOD SetCanvasElement(nsICanvasElement* aParentCanvas);\\n     NS_IMETHOD SetDimensions(PRInt32 width, PRInt32 height);\\n-    NS_IMETHOD Render(nsIRenderingContext *rc);\\n-    NS_IMETHOD RenderToSurface(cairo_surface_t *surf);\\n-    NS_IMETHOD GetInputStream(const nsACString& aMimeType,\\n-                              const nsAString& aEncoderOptions,\\n+    NS_IMETHOD Render(gfxContext *ctx);\\n+    NS_IMETHOD GetInputStream(const char* aMimeType,\\n+                              const PRUnichar* aEncoderOptions,\\n                               nsIInputStream **aStream);\\n \\n protected:\\n     PRBool SafeToCreateCanvas3DContext();\\n-    nsIFrame *GetCanvasLayoutFrame();\\n     nsresult DoSwapBuffers();\\n     nsresult CairoSurfaceFromElement(nsIDOMElement *imgElt,\\n-                                     cairo_surface_t **aCairoSurface,\\n+                                     gfxASurface **aThebesSurface,\\n                                      PRUint8 **imgData,\\n                                      PRInt32 *widthOut, PRInt32 *heightOut,\\n                                      nsIURI **uriOut, PRBool *forceWriteOnlyOut);\\n@@ -412,6 +412,8 @@ public:\\n         return PR_TRUE;\\n     }\\n \\n+    // We can't use ns*Substring, because we don't have internal linkage\\n+#if 0\\n     PRBool DefineProperty(const char *name, const nsCSubstring& val) {\\n         JSString *jsstr = JS_NewStringCopyN(mCtx->ctx, val.BeginReading(), val.Length());\\n         if (!jsstr ||\\n@@ -427,6 +429,7 @@ public:\\n             return PR_FALSE;\\n         return PR_TRUE;\\n     }\\n+#endif\\n \\n     PRBool DefineProperty(const char *name, const char *val, PRUint32 len) {\\n         JSString *jsstr = JS_NewStringCopyN(mCtx->ctx, val, len);\\ndiff --git a/extensions/canvas3d/src/nsCanvasRenderingContextGLES11.cpp b/extensions/canvas3d/src/nsCanvasRenderingContextGLES11.cpp\\nindex dd4ee4e..91e3ef2 100644\\n--- a/extensions/canvas3d/src/nsCanvasRenderingContextGLES11.cpp\\n+++ b/extensions/canvas3d/src/nsCanvasRenderingContextGLES11.cpp\\n@@ -53,9 +53,7 @@\\n \\n #include \\\"nsICanvasGLPrivate.h\\\"\\n \\n-#ifndef MOZILLA_1_8_BRANCH\\n #include \\\"nsIDocument.h\\\"\\n-#endif\\n \\n #include \\\"nsTransform2D.h\\\"\\n \\n@@ -73,28 +71,18 @@\\n #include \\\"nsIImageLoadingContent.h\\\"\\n #include \\\"nsIInterfaceRequestorUtils.h\\\"\\n #include \\\"nsIImage.h\\\"\\n-#include \\\"nsIFrame.h\\\"\\n #include \\\"nsDOMError.h\\\"\\n #include \\\"nsIJSRuntimeService.h\\\"\\n \\n-#ifndef MOZILLA_1_8_BRANCH\\n #include \\\"nsIClassInfoImpl.h\\\"\\n-#endif\\n \\n #include \\\"nsServiceManagerUtils.h\\\"\\n \\n #include \\\"nsDOMError.h\\\"\\n \\n-#include \\\"nsContentUtils.h\\\"\\n-\\n #include \\\"nsIXPConnect.h\\\"\\n #include \\\"jsapi.h\\\"\\n \\n-#ifdef MOZ_CAIRO_GFX\\n-#include \\\"gfxContext.h\\\"\\n-#include \\\"gfxASurface.h\\\"\\n-#endif\\n-\\n #ifdef XP_WIN\\n #include <windows.h>\\n #endif\\n@@ -102,7 +90,8 @@\\n // GLEW will pull in the GL bits that we want/need\\n #include \\\"glew.h\\\"\\n \\n-#include \\\"cairo.h\\\"\\n+#include \\\"gfxImageSurface.h\\\"\\n+#include \\\"gfxContext.h\\\"\\n \\n #ifdef PR_LOGGING\\n PRLogModuleInfo* gGLES11Log = nsnull;\\n@@ -1132,13 +1121,14 @@ NS_IMETHODIMP\\n nsCanvasRenderingContextGLES11::TexImage2DHTML(PRUint32 target, nsIDOMHTMLElement *imageOrCanvas)\\n {\\n     nsresult rv;\\n-    cairo_surface_t *cairo_surf = nsnull;\\n-    PRUint8 *image_data = nsnull, *local_image_data = nsnull;\\n+    nsRefPtr<gfxASurface> surf;\\n+    nsRefPtr<gfxImageSurface> tmpImageSurface;\\n+    PRUint8 *image_data = nsnull;\\n     PRInt32 width, height;\\n     nsCOMPtr<nsIURI> element_uri;\\n     PRBool force_write_only = PR_FALSE;\\n \\n-    rv = CairoSurfaceFromElement(imageOrCanvas, &cairo_surf, &image_data,\\n+    rv = CairoSurfaceFromElement(imageOrCanvas, getter_AddRefs(surf), &image_data,\\n                                  &width, &height, getter_AddRefs(element_uri), &force_write_only);\\n     if (NS_FAILED(rv))\\n         return rv;\\n@@ -1157,26 +1147,15 @@ nsCanvasRenderingContextGLES11::TexImage2DHTML(PRUint32 target, nsIDOMHTMLElemen\\n     }\\n \\n     if (!image_data) {\\n-        local_image_data = (PRUint8*) PR_Malloc(width * height * 4);\\n-        if (!local_image_data)\\n-            return NS_ERROR_FAILURE;\\n-\\n-        cairo_surface_t *tmp = cairo_image_surface_create_for_data (local_image_data,\\n-                                                                    CAIRO_FORMAT_ARGB32,\\n-                                                                    width, height, width * 4);\\n-        if (!tmp) {\\n-            PR_Free(local_image_data);\\n-            return NS_ERROR_FAILURE;\\n-        }\\n+        nsRefPtr<gfxImageSurface> tmpImageSurface = new gfxImageSurface(gfxIntSize(width, height),\\n+                                                                        gfxASurface::ImageFormatARGB32);\\n \\n-        cairo_t *tmp_cr = cairo_create (tmp);\\n-        cairo_set_source_surface (tmp_cr, cairo_surf, 0, 0);\\n-        cairo_set_operator (tmp_cr, CAIRO_OPERATOR_SOURCE);\\n-        cairo_paint (tmp_cr);\\n-        cairo_destroy (tmp_cr);\\n-        cairo_surface_destroy (tmp);\\n+        nsRefPtr<gfxContext> cx = new gfxContext(tmpImageSurface);\\n+        cx->SetSource(surf);\\n+        cx->SetOperator(gfxContext::OPERATOR_SOURCE);\\n+        cx->Paint();\\n \\n-        image_data = local_image_data;\\n+        image_data = tmpImageSurface->Data();\\n     }\\n \\n     // Er, I can do this with glPixelStore, no?\\n@@ -1209,9 +1188,6 @@ nsCanvasRenderingContextGLES11::TexImage2DHTML(PRUint32 target, nsIDOMHTMLElemen\\n \\n     glTexImage2D(target, 0, 4, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image_data);\\n \\n-    if (local_image_data)\\n-        PR_Free(local_image_data);\\n-\\n     return NS_OK;\\n }\\n \\ndiff --git a/extensions/canvas3d/src/nsCanvasRenderingContextGLWeb20.cpp b/extensions/canvas3d/src/nsCanvasRenderingContextGLWeb20.cpp\\nindex 4f7c6da..fd80dec 100644\\n--- a/extensions/canvas3d/src/nsCanvasRenderingContextGLWeb20.cpp\\n+++ b/extensions/canvas3d/src/nsCanvasRenderingContextGLWeb20.cpp\\n@@ -51,9 +51,7 @@\\n #include \\\"nsIView.h\\\"\\n #include \\\"nsIViewManager.h\\\"\\n \\n-#ifndef MOZILLA_1_8_BRANCH\\n #include \\\"nsIDocument.h\\\"\\n-#endif\\n \\n #include \\\"nsTransform2D.h\\\"\\n \\n@@ -71,28 +69,18 @@\\n #include \\\"nsIImageLoadingContent.h\\\"\\n #include \\\"nsIInterfaceRequestorUtils.h\\\"\\n #include \\\"nsIImage.h\\\"\\n-#include \\\"nsIFrame.h\\\"\\n #include \\\"nsDOMError.h\\\"\\n #include \\\"nsIJSRuntimeService.h\\\"\\n \\n-#ifndef MOZILLA_1_8_BRANCH\\n #include \\\"nsIClassInfoImpl.h\\\"\\n-#endif\\n \\n #include \\\"nsServiceManagerUtils.h\\\"\\n \\n #include \\\"nsDOMError.h\\\"\\n \\n-#include \\\"nsContentUtils.h\\\"\\n-\\n #include \\\"nsIXPConnect.h\\\"\\n #include \\\"jsapi.h\\\"\\n \\n-#ifdef MOZ_CAIRO_GFX\\n-#include \\\"gfxContext.h\\\"\\n-#include \\\"gfxASurface.h\\\"\\n-#endif\\n-\\n #ifdef XP_WIN\\n #include <windows.h>\\n #endif\\n@@ -102,7 +90,8 @@\\n \\n // we're hoping that something is setting us up the remap\\n \\n-#include \\\"cairo.h\\\"\\n+#include \\\"gfxImageSurface.h\\\"\\n+#include \\\"gfxContext.h\\\"\\n \\n #ifdef PR_LOGGING\\n PRLogModuleInfo* gGLES20Log = nsnull;\\n@@ -1012,13 +1001,14 @@ NS_IMETHODIMP\\n nsCanvasRenderingContextGLWeb20::TexImage2DHTML(PRUint32 target, nsIDOMHTMLElement *imageOrCanvas)\\n {\\n     nsresult rv;\\n-    cairo_surface_t *cairo_surf = nsnull;\\n-    PRUint8 *image_data = nsnull, *local_image_data = nsnull;\\n+    nsRefPtr<gfxASurface> surf;\\n+    nsRefPtr<gfxImageSurface> tmpImageSurface;\\n+    PRUint8 *image_data = nsnull;\\n     PRInt32 width, height;\\n     nsCOMPtr<nsIURI> element_uri;\\n     PRBool force_write_only = PR_FALSE;\\n \\n-    rv = CairoSurfaceFromElement(imageOrCanvas, &cairo_surf, &image_data,\\n+    rv = CairoSurfaceFromElement(imageOrCanvas, getter_AddRefs(surf), &image_data,\\n                                  &width, &height, getter_AddRefs(element_uri), &force_write_only);\\n     if (NS_FAILED(rv))\\n         return rv;\\n@@ -1037,26 +1027,15 @@ nsCanvasRenderingContextGLWeb20::TexImage2DHTML(PRUint32 target, nsIDOMHTMLEleme\\n     }\\n \\n     if (!image_data) {\\n-        local_image_data = (PRUint8*) PR_Malloc(width * height * 4);\\n-        if (!local_image_data)\\n-            return NS_ERROR_FAILURE;\\n-\\n-        cairo_surface_t *tmp = cairo_image_surface_create_for_data (local_image_data,\\n-                                                                    CAIRO_FORMAT_ARGB32,\\n-                                                                    width, height, width * 4);\\n-        if (!tmp) {\\n-            PR_Free(local_image_data);\\n-            return NS_ERROR_FAILURE;\\n-        }\\n+        nsRefPtr<gfxImageSurface> tmpImageSurface = new gfxImageSurface(gfxIntSize(width, height),\\n+                                                                        gfxASurface::ImageFormatARGB32);\\n \\n-        cairo_t *tmp_cr = cairo_create (tmp);\\n-        cairo_set_source_surface (tmp_cr, cairo_surf, 0, 0);\\n-        cairo_set_operator (tmp_cr, CAIRO_OPERATOR_SOURCE);\\n-        cairo_paint (tmp_cr);\\n-        cairo_destroy (tmp_cr);\\n-        cairo_surface_destroy (tmp);\\n+        nsRefPtr<gfxContext> cx = new gfxContext(tmpImageSurface);\\n+        cx->SetSource(surf);\\n+        cx->SetOperator(gfxContext::OPERATOR_SOURCE);\\n+        cx->Paint();\\n \\n-        image_data = local_image_data;\\n+        image_data = tmpImageSurface->Data();\\n     }\\n \\n     // Er, I can do this with glPixelStore, no?\\n@@ -1089,9 +1068,6 @@ nsCanvasRenderingContextGLWeb20::TexImage2DHTML(PRUint32 target, nsIDOMHTMLEleme\\n \\n     glTexImage2D(target, 0, 4, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image_data);\\n \\n-    if (local_image_data)\\n-        PR_Free(local_image_data);\\n-\\n     return NS_OK;\\n }\\n \\n\""}