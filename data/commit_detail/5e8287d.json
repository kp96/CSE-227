{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas5e8287d\""},"diff":"\"5e8287d Bug 397536 - \\\"performance improvements for JSON.jsm\\\" (optimize string serialization) [p=zeniko@gmail.com (Simon BÃ¼nzli) r=sspitzer sr=brendan a1.9=mconnor]\\ndiff --git a/js/src/xpconnect/loader/JSON.jsm b/js/src/xpconnect/loader/JSON.jsm\\nindex 13b47a2..3743ab2 100644\\n--- a/js/src/xpconnect/loader/JSON.jsm\\n+++ b/js/src/xpconnect/loader/JSON.jsm\\n@@ -73,32 +73,36 @@ var JSON = {\\n    * Note: aJSObject MUST not contain cyclic references.\\n    */\\n   toString: function JSON_toString(aJSObject, aKeysToDrop) {\\n-    // these characters have a special escape notation\\n-    const charMap = { \\\"\\\\b\\\": \\\"\\\\\\\\b\\\", \\\"\\\\t\\\": \\\"\\\\\\\\t\\\", \\\"\\\\n\\\": \\\"\\\\\\\\n\\\", \\\"\\\\f\\\": \\\"\\\\\\\\f\\\",\\n-                      \\\"\\\\r\\\": \\\"\\\\\\\\r\\\", '\\\"': '\\\\\\\\\\\"', \\\"\\\\\\\\\\\": \\\"\\\\\\\\\\\\\\\\\\\" };\\n-    \\n     // we use a single string builder for efficiency reasons\\n     var pieces = [];\\n     \\n     // this recursive function walks through all objects and appends their\\n     // JSON representation (in one or several pieces) to the string builder\\n     function append_piece(aObj) {\\n-      if (typeof aObj == \\\"boolean\\\") {\\n-        pieces.push(aObj ? \\\"true\\\" : \\\"false\\\");\\n-      }\\n-      else if (typeof aObj == \\\"number\\\" && isFinite(aObj)) {\\n-        // there is no representation for infinite numbers or for NaN!\\n-        pieces.push(aObj.toString());\\n-      }\\n-      else if (typeof aObj == \\\"string\\\") {\\n+      if (typeof aObj == \\\"string\\\") {\\n         aObj = aObj.replace(/[\\\\\\\\\\\"\\\\x00-\\\\x1F\\\\u0080-\\\\uFFFF]/g, function($0) {\\n           // use the special escape notation if one exists, otherwise\\n           // produce a general unicode escape sequence\\n-          return charMap[$0] ||\\n-            \\\"\\\\\\\\u\\\" + (\\\"0000\\\" + $0.charCodeAt(0).toString(16)).slice(-4);\\n+          switch ($0) {\\n+          case \\\"\\\\b\\\": return \\\"\\\\\\\\b\\\";\\n+          case \\\"\\\\t\\\": return \\\"\\\\\\\\t\\\";\\n+          case \\\"\\\\n\\\": return \\\"\\\\\\\\n\\\";\\n+          case \\\"\\\\f\\\": return \\\"\\\\\\\\f\\\";\\n+          case \\\"\\\\r\\\": return \\\"\\\\\\\\r\\\";\\n+          case '\\\"':  return '\\\\\\\\\\\"';\\n+          case \\\"\\\\\\\\\\\": return \\\"\\\\\\\\\\\\\\\\\\\";\\n+          }\\n+          return \\\"\\\\\\\\u\\\" + (\\\"0000\\\" + $0.charCodeAt(0).toString(16)).slice(-4);\\n         });\\n         pieces.push('\\\"' + aObj + '\\\"')\\n       }\\n+      else if (typeof aObj == \\\"boolean\\\") {\\n+        pieces.push(aObj ? \\\"true\\\" : \\\"false\\\");\\n+      }\\n+      else if (typeof aObj == \\\"number\\\" && isFinite(aObj)) {\\n+        // there is no representation for infinite numbers or for NaN!\\n+        pieces.push(aObj.toString());\\n+      }\\n       else if (aObj === null) {\\n         pieces.push(\\\"null\\\");\\n       }\\n@@ -109,10 +113,10 @@ var JSON = {\\n                (aObj.length === 0 || aObj[aObj.length - 1] !== undefined)) {\\n         pieces.push(\\\"[\\\");\\n         for (var i = 0; i < aObj.length; i++) {\\n-          append_piece(aObj[i]);\\n+          arguments.callee(aObj[i]);\\n           pieces.push(\\\",\\\");\\n         }\\n-        if (pieces[pieces.length - 1] == \\\",\\\")\\n+        if (aObj.length > 0)\\n           pieces.pop(); // drop the trailing colon\\n         pieces.push(\\\"]\\\");\\n       }\\n@@ -125,9 +129,9 @@ var JSON = {\\n           if (aKeysToDrop && aKeysToDrop.indexOf(key) != -1)\\n             continue;\\n           \\n-          append_piece(key.toString());\\n+          arguments.callee(key.toString());\\n           pieces.push(\\\":\\\");\\n-          append_piece(aObj[key]);\\n+          arguments.callee(aObj[key]);\\n           pieces.push(\\\",\\\");\\n         }\\n         if (pieces[pieces.length - 1] == \\\",\\\")\\n\""}