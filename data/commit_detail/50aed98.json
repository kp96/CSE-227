{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas50aed98\""},"diff":"\"50aed98 Back out sicking's patch from bug 348156 (remove unbinds from nsDocument::Destroy) due to crashing during talos test (probably tp test).\\ndiff --git a/content/base/src/nsDocument.cpp b/content/base/src/nsDocument.cpp\\nindex 482cb60..1e6b1dd 100644\\n--- a/content/base/src/nsDocument.cpp\\n+++ b/content/base/src/nsDocument.cpp\\n@@ -5536,15 +5536,26 @@ nsDocument::Destroy()\\n   if (mIsGoingAway)\\n     return;\\n \\n+  PRInt32 count = mChildren.ChildCount();\\n+\\n   mIsGoingAway = PR_TRUE;\\n-  PRUint32 i, count = mChildren.ChildCount();\\n-  for (i = 0; i < count; ++i) {\\n-    nsNodeUtils::DestroySubtree(mChildren.ChildAt(i));\\n+  DestroyLinkMap();\\n+  for (PRInt32 indx = 0; indx < count; ++indx) {\\n+    // XXXbz what we _should_ do here is to clear mChildren and null out\\n+    // mRootContent.  If we did this (or at least the latter), we could remove\\n+    // the silly null-checks in nsHTMLDocument::MatchLinks.  Unfortunately,\\n+    // doing that introduces several problems:\\n+    // 1) Focus issues (see bug 341730).  The fix for bug 303260 may fix these.\\n+    // 2) Crashes in OnPageHide if it fires after Destroy.  See bug 303260\\n+    //    comments 9 and 10.\\n+    // So we're just creating an inconsistent DOM for now and hoping.  :(\\n+    mChildren.ChildAt(indx)->UnbindFromTree();\\n   }\\n-\\n   mLayoutHistoryState = nsnull;\\n \\n   nsContentList::OnDocumentDestroy(this);\\n+  delete mContentWrapperHash;\\n+  mContentWrapperHash = nsnull;\\n }\\n \\n already_AddRefed<nsILayoutHistoryState>\\ndiff --git a/content/base/src/nsGenericElement.cpp b/content/base/src/nsGenericElement.cpp\\nindex 136fcd7..bc8d699 100644\\n--- a/content/base/src/nsGenericElement.cpp\\n+++ b/content/base/src/nsGenericElement.cpp\\n@@ -3348,11 +3348,8 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsGenericElement)\\n   // Unlink any DOM slots of interest.\\n   {\\n     nsDOMSlots *slots = tmp->GetExistingDOMSlots();\\n-    if (slots) {\\n+    if (slots)\\n       slots->mAttributeMap = nsnull;\\n-      if (tmp->IsNodeOfType(nsINode::eXUL))\\n-        NS_IF_RELEASE(slots->mControllers);\\n-    }\\n   }\\n NS_IMPL_CYCLE_COLLECTION_UNLINK_END\\n \\ndiff --git a/content/base/src/nsNodeUtils.cpp b/content/base/src/nsNodeUtils.cpp\\nindex 32993d6..ec11d40 100755\\n--- a/content/base/src/nsNodeUtils.cpp\\n+++ b/content/base/src/nsNodeUtils.cpp\\n@@ -687,27 +687,3 @@ nsNodeUtils::UnlinkUserData(nsINode *aNode)\\n                                                       DOM_USER_DATA_HANDLER);\\n   }\\n }\\n-\\n-/* static */\\n-void\\n-nsNodeUtils::DestroySubtree(nsIContent* aRoot)\\n-{\\n-  nsXULElement* xul = nsXULElement::FromContent(aRoot);\\n-  if (xul) {\\n-    nsGenericElement::nsDOMSlots* slots = xul->GetExistingDOMSlots();\\n-    if (slots) {\\n-      NS_IF_RELEASE(slots->mControllers);\\n-    }\\n-  }\\n-\\n-  nsIDocument *document = aRoot->GetOwnerDoc();\\n-  if (document) {\\n-    document->BindingManager()->ChangeDocumentFor(aRoot, document, nsnull);\\n-    document->ClearBoxObjectFor(aRoot);\\n-  }\\n-\\n-  PRUint32 i, count = aRoot->GetChildCount();\\n-  for (i = 0; i < count; ++i) {\\n-    DestroySubtree(aRoot->GetChildAt(i));\\n-  }\\n-}\\ndiff --git a/content/base/src/nsNodeUtils.h b/content/base/src/nsNodeUtils.h\\nindex 8193d53..4dac9f0 100755\\n--- a/content/base/src/nsNodeUtils.h\\n+++ b/content/base/src/nsNodeUtils.h\\n@@ -269,14 +269,6 @@ public:\\n    */\\n   static void UnlinkUserData(nsINode *aNode);\\n \\n-  /**\\n-   * Remove neccesary components of all nodes in a subtree to avoid leaking.\\n-   * So far this removes XBL bindings and XUL controllers.\\n-   *\\n-   * @param aRoot the node that is the root of the subtree to clear.\\n-   */\\n-  static void DestroySubtree(nsIContent* aRoot);\\n-\\n private:\\n   friend PLDHashOperator PR_CALLBACK\\n     AdoptFunc(nsAttrHashKey::KeyType aKey, nsIDOMNode *aData, void* aUserArg);\\ndiff --git a/content/html/content/src/nsHTMLFormElement.cpp b/content/html/content/src/nsHTMLFormElement.cpp\\nindex bf94cda..513ffad 100644\\n--- a/content/html/content/src/nsHTMLFormElement.cpp\\n+++ b/content/html/content/src/nsHTMLFormElement.cpp\\n@@ -323,7 +323,7 @@ protected:\\n   /** The request currently being submitted */\\n   nsCOMPtr<nsIRequest> mSubmittingRequest;\\n   /** The web progress object we are currently listening to */\\n-  nsWeakPtr mWebProgress;\\n+  nsCOMPtr<nsIWebProgress> mWebProgress;\\n \\n   /** The default submit element -- WEAK */\\n   nsIFormControl* mDefaultSubmitElement;\\n@@ -1025,12 +1025,10 @@ nsHTMLFormElement::SubmitSubmission(nsIFormSubmission* aFormSubmission)\\n     PRBool pending = PR_FALSE;\\n     mSubmittingRequest->IsPending(&pending);\\n     if (pending && !schemeIsJavaScript) {\\n-      nsCOMPtr<nsIWebProgress> webProgress = do_GetInterface(docShell);\\n-      NS_ASSERTION(webProgress, \\\"nsIDocShell not converted to nsIWebProgress!\\\");\\n-      rv = webProgress->AddProgressListener(this, nsIWebProgress::NOTIFY_STATE_ALL);\\n+      mWebProgress = do_GetInterface(docShell);\\n+      NS_ASSERTION(mWebProgress, \\\"nsIDocShell not converted to nsIWebProgress!\\\");\\n+      rv = mWebProgress->AddProgressListener(this, nsIWebProgress::NOTIFY_STATE_ALL);\\n       NS_ENSURE_SUBMIT_SUCCESS(rv);\\n-      mWebProgress = do_GetWeakReference(webProgress);\\n-      NS_ASSERTION(mWebProgress, \\\"can't hold weak ref to webprogress!\\\");\\n     } else {\\n       ForgetCurrentSubmission();\\n     }\\n@@ -1647,11 +1645,10 @@ nsHTMLFormElement::ForgetCurrentSubmission()\\n   mNotifiedObservers = PR_FALSE;\\n   mIsSubmitting = PR_FALSE;\\n   mSubmittingRequest = nsnull;\\n-  nsCOMPtr<nsIWebProgress> webProgress = do_QueryReferent(mWebProgress);\\n-  if (webProgress) {\\n-    webProgress->RemoveProgressListener(this);\\n+  if (mWebProgress) {\\n+    mWebProgress->RemoveProgressListener(this);\\n+    mWebProgress = nsnull;\\n   }\\n-  mWebProgress = nsnull;\\n }\\n \\n // nsIWebProgressListener\\ndiff --git a/content/xtf/src/nsXTFElementWrapper.cpp b/content/xtf/src/nsXTFElementWrapper.cpp\\nindex a73f124..2d0eb36 100644\\n--- a/content/xtf/src/nsXTFElementWrapper.cpp\\n+++ b/content/xtf/src/nsXTFElementWrapper.cpp\\n@@ -104,15 +104,8 @@ nsXTFElementWrapper::Init()\\n //----------------------------------------------------------------------\\n // nsISupports implementation\\n \\n-NS_IMPL_ADDREF_INHERITED(nsXTFElementWrapper, nsXTFElementWrapperBase)\\n-NS_IMPL_RELEASE_INHERITED(nsXTFElementWrapper, nsXTFElementWrapperBase)\\n-\\n-NS_IMPL_CYCLE_COLLECTION_CLASS(nsXTFElementWrapper)\\n-NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsXTFElementWrapper,\\n-                                                  nsXTFElementWrapperBase)\\n-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mXTFElement)\\n-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mAttributeHandler)\\n-NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END\\n+NS_IMPL_ADDREF_INHERITED(nsXTFElementWrapper,nsXTFElementWrapperBase)\\n+NS_IMPL_RELEASE_INHERITED(nsXTFElementWrapper,nsXTFElementWrapperBase)\\n \\n NS_IMETHODIMP\\n nsXTFElementWrapper::QueryInterface(REFNSIID aIID, void** aInstancePtr)\\ndiff --git a/content/xtf/src/nsXTFElementWrapper.h b/content/xtf/src/nsXTFElementWrapper.h\\nindex 556d633..b85fae77 100644\\n--- a/content/xtf/src/nsXTFElementWrapper.h\\n+++ b/content/xtf/src/nsXTFElementWrapper.h\\n@@ -65,8 +65,6 @@ public:\\n \\n   // nsISupports interface\\n   NS_DECL_ISUPPORTS_INHERITED\\n-  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_NO_UNLINK(nsXTFElementWrapper,\\n-                                                     nsXTFElementWrapperBase)\\n \\n   // nsIXTFElementWrapper\\n   NS_DECL_NSIXTFELEMENTWRAPPER\\n\""}