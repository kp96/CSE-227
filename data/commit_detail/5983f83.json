{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas5983f83\""},"diff":"\"5983f83 Make the nsISerializable implementation of nsPrincipal actually work.  This makes it possible to save principal objects to a stream and read them back. Bug 369566, r=dveditz+brendan, sr=jst, a=jst\\ndiff --git a/caps/include/nsPrincipal.h b/caps/include/nsPrincipal.h\\nindex 26f64c0..2f0c599 100755\\n--- a/caps/include/nsPrincipal.h\\n+++ b/caps/include/nsPrincipal.h\\n@@ -45,6 +45,8 @@\\n #include \\\"nsVoidArray.h\\\"\\n #include \\\"nsHashtable.h\\\"\\n #include \\\"nsJSPrincipals.h\\\"\\n+#include \\\"nsTArray.h\\\"\\n+#include \\\"nsAutoPtr.h\\\"\\n \\n class nsIObjectInputStream;\\n class nsIObjectOutputStream;\\n@@ -100,7 +102,7 @@ public:\\n \\n protected:\\n   nsJSPrincipals mJSPrincipals;\\n-  nsVoidArray mAnnotations;\\n+  nsTArray< nsAutoPtr<nsHashtable> > mAnnotations;\\n   nsHashtable mCapabilities;\\n   nsCString mPrefName;\\n   static PRInt32 sCapabilitiesOrdinal;\\ndiff --git a/caps/src/nsPrincipal.cpp b/caps/src/nsPrincipal.cpp\\nindex b6d5b8a..05b68c5 100755\\n--- a/caps/src/nsPrincipal.cpp\\n+++ b/caps/src/nsPrincipal.cpp\\n@@ -150,18 +150,8 @@ nsPrincipal::Init(const nsACString& aCertFingerprint,\\n   return rv;\\n }\\n \\n-\\n-PR_STATIC_CALLBACK(PRBool)\\n-deleteElement(void* aElement, void *aData)\\n-{\\n-  nsHashtable *ht = (nsHashtable *) aElement;\\n-  delete ht;\\n-  return PR_TRUE;\\n-}\\n-\\n nsPrincipal::~nsPrincipal(void)\\n {\\n-  mAnnotations.EnumerateForwards(deleteElement, nsnull);\\n   SetSecurityPolicy(nsnull); \\n }\\n \\n@@ -486,14 +476,20 @@ nsPrincipal::SetCapability(const char *capability, void **annotation,\\n                            AnnotationValue value)\\n {\\n   if (*annotation == nsnull) {\\n-    *annotation = new nsHashtable(5);\\n-    if (!*annotation) {\\n+    nsHashtable* ht = new nsHashtable(5);\\n+\\n+    if (!ht) {\\n        return NS_ERROR_OUT_OF_MEMORY;\\n      }\\n \\n     // This object owns its annotations. Save them so we can release\\n     // them when we destroy this object.\\n-    mAnnotations.AppendElement(*annotation);\\n+    if (!mAnnotations.AppendElement(ht)) {\\n+      delete ht;\\n+      return NS_ERROR_OUT_OF_MEMORY;\\n+    }\\n+\\n+    *annotation = ht;\\n   }\\n \\n   const char *start = capability;\\n@@ -502,7 +498,7 @@ nsPrincipal::SetCapability(const char *capability, void **annotation,\\n     int len = space ? space - start : strlen(start);\\n     nsCAutoString capString(start, len);\\n     nsCStringKey key(capString);\\n-    nsHashtable *ht = (nsHashtable *) *annotation;\\n+    nsHashtable *ht = static_cast<nsHashtable *>(*annotation);\\n     ht->Put(&key, (void *) value);\\n     if (!space) {\\n       break;\\n@@ -673,7 +669,7 @@ nsPrincipal::InitFromPersistent(const char* aPrefName,\\n {\\n   NS_PRECONDITION(mCapabilities.Count() == 0,\\n                   \\\"mCapabilities was already initialized?\\\");\\n-  NS_PRECONDITION(mAnnotations.Count() == 0,\\n+  NS_PRECONDITION(mAnnotations.Length() == 0,\\n                   \\\"mAnnotations was already initialized?\\\");\\n   NS_PRECONDITION(!mInitialized, \\\"We were already initialized?\\\");\\n \\n@@ -911,46 +907,84 @@ FreeAnnotationEntry(nsIObjectInputStream* aStream, nsHashKey* aKey,\\n NS_IMETHODIMP\\n nsPrincipal::Read(nsIObjectInputStream* aStream)\\n {\\n-  PRUint32 annotationCount;\\n-  nsresult rv = aStream->Read32(&annotationCount);\\n+  PRBool hasCapabilities;\\n+  nsresult rv = aStream->ReadBoolean(&hasCapabilities);\\n+  if (NS_SUCCEEDED(rv) && hasCapabilities) {\\n+    // We want to use one of the nsHashtable constructors, but don't want to\\n+    // generally have mCapabilities be a pointer... and nsHashtable has no\\n+    // reasonable copy-constructor.  Placement-new to the rescue!\\n+    mCapabilities.~nsHashtable();\\n+    new (&mCapabilities) nsHashtable(aStream, ReadAnnotationEntry,\\n+                                     FreeAnnotationEntry, &rv);\\n+  }\\n+\\n   if (NS_FAILED(rv)) {\\n     return rv;\\n   }\\n \\n-  for (PRInt32 i = 0, n = PRInt32(annotationCount); i < n; i++) {\\n-    nsHashtable *ht = new nsHashtable(aStream,\\n-                                      ReadAnnotationEntry,\\n-                                      FreeAnnotationEntry,\\n-                                      &rv);\\n-    if (!ht) {\\n-      return NS_ERROR_OUT_OF_MEMORY;\\n+  rv = NS_ReadOptionalCString(aStream, mPrefName);\\n+  if (NS_FAILED(rv)) {\\n+    return rv;\\n+  }\\n+\\n+  const char* ordinalBegin = PL_strpbrk(mPrefName.get(), \\\"1234567890\\\");\\n+  if (ordinalBegin) {\\n+    PRIntn n = atoi(ordinalBegin);\\n+    if (sCapabilitiesOrdinal <= n) {\\n+      sCapabilitiesOrdinal = n + 1;\\n     }\\n+  }\\n \\n+  PRBool haveCert;\\n+  rv = aStream->ReadBoolean(&haveCert);\\n+  if (NS_FAILED(rv)) {\\n+    return rv;\\n+  }\\n+\\n+  nsCString fingerprint;\\n+  nsCString subjectName;\\n+  nsCString prettyName;\\n+  nsCOMPtr<nsISupports> cert;\\n+  if (haveCert) {\\n+    rv = NS_ReadOptionalCString(aStream, fingerprint);\\n     if (NS_FAILED(rv)) {\\n-      delete ht;\\n       return rv;\\n     }\\n \\n-    if (!mAnnotations.InsertElementAt(reinterpret_cast<void*>(ht), i)) {\\n-      delete ht;\\n-      return NS_ERROR_OUT_OF_MEMORY;\\n+    rv = NS_ReadOptionalCString(aStream, subjectName);\\n+    if (NS_FAILED(rv)) {\\n+      return rv;\\n+    }\\n+\\n+    rv = NS_ReadOptionalCString(aStream, prettyName);\\n+    if (NS_FAILED(rv)) {\\n+      return rv;\\n+    }\\n+\\n+    rv = aStream->ReadObject(PR_TRUE, getter_AddRefs(cert));\\n+    if (NS_FAILED(rv)) {\\n+      return rv;\\n     }\\n   }\\n \\n-  PRBool hasCapabilities;\\n-  rv = aStream->ReadBoolean(&hasCapabilities);\\n-  if (NS_SUCCEEDED(rv) && hasCapabilities) {\\n-    mCapabilities = nsHashtable(aStream,\\n-                                ReadAnnotationEntry,\\n-                                FreeAnnotationEntry,\\n-                                &rv);\\n+  nsCOMPtr<nsIURI> codebase;\\n+  rv = NS_ReadOptionalObject(aStream, PR_TRUE, getter_AddRefs(codebase));\\n+  if (NS_FAILED(rv)) {\\n+    return rv;\\n   }\\n \\n+  rv = Init(fingerprint, subjectName, prettyName, cert, codebase);\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  nsCOMPtr<nsIURI> domain;\\n+  rv = NS_ReadOptionalObject(aStream, PR_TRUE, getter_AddRefs(domain));\\n   if (NS_FAILED(rv)) {\\n     return rv;\\n   }\\n \\n-  rv = NS_ReadOptionalCString(aStream, mPrefName);\\n+  SetDomain(domain);\\n+\\n+  rv = aStream->Read8(&mTrusted);\\n   if (NS_FAILED(rv)) {\\n     return rv;\\n   }\\n@@ -969,34 +1003,81 @@ WriteScalarValue(nsIObjectOutputStream* aStream, void* aData)\\n NS_IMETHODIMP\\n nsPrincipal::Write(nsIObjectOutputStream* aStream)\\n {\\n-  PRUint32 annotationCount = PRUint32(mAnnotations.Count());\\n-  nsresult rv = aStream->Write32(annotationCount);\\n+  NS_ENSURE_STATE(mCert || mCodebase);\\n+  \\n+  // mAnnotations is transient data associated to specific JS stack frames.  We\\n+  // don't want to serialize that.\\n+  \\n+  PRBool hasCapabilities = (mCapabilities.Count() > 0);\\n+  nsresult rv = aStream->WriteBoolean(hasCapabilities);\\n+  if (NS_SUCCEEDED(rv) && hasCapabilities) {\\n+    rv = mCapabilities.Write(aStream, WriteScalarValue);\\n+  }\\n+\\n+  if (NS_FAILED(rv)) {\\n+    return rv;\\n+  }\\n+\\n+  rv = NS_WriteOptionalStringZ(aStream, mPrefName.get());\\n+  if (NS_FAILED(rv)) {\\n+    return rv;\\n+  }\\n+\\n+  rv = aStream->WriteBoolean(mCert != nsnull);\\n   if (NS_FAILED(rv)) {\\n     return rv;\\n   }\\n \\n-  for (PRInt32 i = 0, n = PRInt32(annotationCount); i < n; i++) {\\n-    nsHashtable *ht = reinterpret_cast<nsHashtable *>(mAnnotations[i]);\\n-    rv = ht->Write(aStream, WriteScalarValue);\\n+  if (mCert) {\\n+    NS_ENSURE_STATE(mCert->cert);\\n+    \\n+    rv = NS_WriteOptionalStringZ(aStream, mCert->fingerprint.get());\\n+    if (NS_FAILED(rv)) {\\n+      return rv;\\n+    }\\n+    \\n+    rv = NS_WriteOptionalStringZ(aStream, mCert->subjectName.get());\\n+    if (NS_FAILED(rv)) {\\n+      return rv;\\n+    }\\n+    \\n+    rv = NS_WriteOptionalStringZ(aStream, mCert->prettyName.get());\\n     if (NS_FAILED(rv)) {\\n       return rv;\\n     }\\n+\\n+    rv = aStream->WriteCompoundObject(mCert->cert, NS_GET_IID(nsISupports),\\n+                                      PR_TRUE);\\n+    if (NS_FAILED(rv)) {\\n+      return rv;\\n+    }    \\n   }\\n+  \\n+  // mSecurityPolicy is an optimization; it'll get looked up again as needed.\\n+  // Don't bother saving and restoring it, esp. since it might change if\\n+  // preferences change.\\n \\n-  PRBool hasCapabilities = (mCapabilities.Count() > 0);\\n-  rv = aStream->WriteBoolean(hasCapabilities);\\n-  if (NS_SUCCEEDED(rv) && hasCapabilities) {\\n-    rv = mCapabilities.Write(aStream, WriteScalarValue);\\n+  rv = NS_WriteOptionalCompoundObject(aStream, mCodebase, NS_GET_IID(nsIURI),\\n+                                      PR_TRUE);\\n+  if (NS_FAILED(rv)) {\\n+    return rv;\\n   }\\n \\n+  rv = NS_WriteOptionalCompoundObject(aStream, mDomain, NS_GET_IID(nsIURI),\\n+                                      PR_TRUE);\\n   if (NS_FAILED(rv)) {\\n     return rv;\\n   }\\n \\n-  rv = NS_WriteOptionalStringZ(aStream, mPrefName.get());\\n+  // mOrigin is an optimization; don't bother serializing it.\\n+\\n+  rv = aStream->Write8(mTrusted);\\n   if (NS_FAILED(rv)) {\\n     return rv;\\n   }\\n \\n+  // mCodebaseImmutable and mDomainImmutable will be recomputed based\\n+  // on the deserialized URIs in Read().\\n+\\n   return NS_OK;\\n }\\ndiff --git a/content/xul/document/public/nsIXULPrototypeCache.h b/content/xul/document/public/nsIXULPrototypeCache.h\\nindex 14cd854..fd9d41d 100644\\n--- a/content/xul/document/public/nsIXULPrototypeCache.h\\n+++ b/content/xul/document/public/nsIXULPrototypeCache.h\\n@@ -82,7 +82,7 @@ const char XUL_FASTLOAD_FILE_BASENAME[] = \\\"XUL\\\";\\n // (opaque to XPCOM FastLoad code) format of XUL-specific XDR serializations.\\n // See also JSXDR_BYTECODE_VERSION in jsxdrapi.h, which tracks incompatible JS\\n // bytecode version changes.\\n-#define XUL_FASTLOAD_FILE_VERSION       (0xfeedbeef - 22)\\n+#define XUL_FASTLOAD_FILE_VERSION       (0xfeedbeef - 23)\\n \\n #define XUL_SERIALIZATION_BUFFER_SIZE   (64 * 1024)\\n #define XUL_DESERIALIZATION_BUFFER_SIZE (8 * 1024)\\n\""}