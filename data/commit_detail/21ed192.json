{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas21ed192\""},"diff":"\"21ed192 Bug 389996, menubar menus flicker when switching between them, r+sr=bz, a=dbaron\\ndiff --git a/layout/xul/base/src/nsMenuBarFrame.cpp b/layout/xul/base/src/nsMenuBarFrame.cpp\\nindex e57d316..37aec01 100644\\n--- a/layout/xul/base/src/nsMenuBarFrame.cpp\\n+++ b/layout/xul/base/src/nsMenuBarFrame.cpp\\n@@ -341,6 +341,36 @@ nsMenuBarFrame::CurrentMenuIsBeingDestroyed()\\n   mCurrentMenu = nsnull;\\n }\\n \\n+class nsMenuBarSwitchMenu : public nsRunnable\\n+{\\n+public:\\n+  nsMenuBarSwitchMenu(nsIContent *aOldMenu,\\n+                      nsIContent *aNewMenu,\\n+                      PRBool aSelectFirstItem)\\n+    : mOldMenu(aOldMenu), mNewMenu(aNewMenu), mSelectFirstItem(aSelectFirstItem)\\n+  {\\n+  }\\n+\\n+  NS_IMETHOD Run()\\n+  {\\n+    nsXULPopupManager* pm = nsXULPopupManager::GetInstance();\\n+    if (!pm)\\n+      return NS_ERROR_UNEXPECTED;\\n+\\n+    if (mOldMenu)\\n+      pm->HidePopup(mOldMenu, PR_FALSE, PR_FALSE, PR_FALSE);\\n+    if (mNewMenu)\\n+      pm->ShowMenu(mNewMenu, mSelectFirstItem, PR_FALSE);\\n+\\n+    return NS_OK;\\n+  }\\n+\\n+private:\\n+  nsCOMPtr<nsIContent> mOldMenu;\\n+  nsCOMPtr<nsIContent> mNewMenu;\\n+  PRBool mSelectFirstItem;\\n+};\\n+\\n NS_IMETHODIMP\\n nsMenuBarFrame::ChangeMenuItem(nsMenuFrame* aMenuItem,\\n                                PRBool aSelectFirstItem)\\n@@ -353,6 +383,8 @@ nsMenuBarFrame::ChangeMenuItem(nsMenuFrame* aMenuItem,\\n   if (pm && pm->HasContextMenu(nsnull))\\n     return NS_OK;\\n \\n+  nsIContent* aOldMenu = nsnull, *aNewMenu = nsnull;\\n+  \\n   // Unset the current child.\\n   PRBool wasOpen = PR_FALSE;\\n   if (mCurrentMenu) {\\n@@ -361,7 +393,7 @@ nsMenuBarFrame::ChangeMenuItem(nsMenuFrame* aMenuItem,\\n     if (wasOpen) {\\n       nsMenuPopupFrame* popupFrame = mCurrentMenu->GetPopup();\\n       if (popupFrame)\\n-        pm->HidePopup(popupFrame->GetContent(), PR_FALSE, PR_FALSE, PR_TRUE);\\n+        aOldMenu = popupFrame->GetContent();\\n     }\\n   }\\n \\n@@ -376,10 +408,14 @@ nsMenuBarFrame::ChangeMenuItem(nsMenuFrame* aMenuItem,\\n     NS_ENSURE_TRUE(weakNewMenu.IsAlive(), NS_OK);\\n     mCurrentMenu = aMenuItem;\\n     if (wasOpen && !aMenuItem->IsDisabled())\\n-      pm->ShowMenu(content, aSelectFirstItem, PR_TRUE);\\n+      aNewMenu = content;\\n   }\\n \\n-  return NS_OK;\\n+  // use an event so that hiding and showing can be done synchronously, which\\n+  // avoids flickering\\n+  nsCOMPtr<nsIRunnable> event =\\n+    new nsMenuBarSwitchMenu(aOldMenu, aNewMenu, aSelectFirstItem);\\n+  return NS_DispatchToCurrentThread(event);\\n }\\n \\n nsMenuFrame*\\ndiff --git a/toolkit/content/tests/widgets/window_menubar.xul b/toolkit/content/tests/widgets/window_menubar.xul\\nindex 1f884e0..bb89c87 100644\\n--- a/toolkit/content/tests/widgets/window_menubar.xul\\n+++ b/toolkit/content/tests/widgets/window_menubar.xul\\n@@ -147,8 +147,8 @@ var popupTests = [\\n     var elist = [\\n       // the file menu gets deactivated, the file menu gets hidden, then\\n       // the edit menu is activated\\n-      \\\"DOMMenuItemInactive filemenu\\\", \\\"popuphiding filepopup\\\",\\n-      \\\"popuphidden filepopup\\\", \\\"DOMMenuItemActive editmenu\\\",\\n+      \\\"DOMMenuItemInactive filemenu\\\", \\\"DOMMenuItemActive editmenu\\\",\\n+      \\\"popuphiding filepopup\\\", \\\"popuphidden filepopup\\\",\\n       // the popupshowing event gets fired when showing the edit menu.\\n       // The item from the file menu doesn't get deactivated until the\\n       // next item needs to be selected\\n\""}