{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas39641d3\""},"diff":"\"39641d3 Bug 393646 - Support reading image data off the clipboard on Mac r=josh,bienvenu sr=roc a=mconnor/drivers\\ndiff --git a/editor/libeditor/html/nsHTMLDataTransfer.cpp b/editor/libeditor/html/nsHTMLDataTransfer.cpp\\nindex 656c413..d46c0af 100644\\n--- a/editor/libeditor/html/nsHTMLDataTransfer.cpp\\n+++ b/editor/libeditor/html/nsHTMLDataTransfer.cpp\\n@@ -1118,10 +1118,8 @@ NS_IMETHODIMP nsHTMLEditor::PrepareHTMLTransferable(nsITransferable **aTransfera\\n       }\\n       (*aTransferable)->AddDataFlavor(kHTMLMime);\\n       (*aTransferable)->AddDataFlavor(kFileMime);\\n-#ifdef XP_WIN32\\n-      // image pasting from the clipboard is only implemented on Windows right now.\\n+      // image pasting from the clipboard is only implemented on Windows & Mac right now.\\n       (*aTransferable)->AddDataFlavor(kJPEGImageMime);\\n-#endif\\n     }\\n     (*aTransferable)->AddDataFlavor(kUnicodeMime);\\n   }\\ndiff --git a/widget/src/cocoa/nsClipboard.mm b/widget/src/cocoa/nsClipboard.mm\\nindex b8b31ea..912d1f6 100644\\n--- a/widget/src/cocoa/nsClipboard.mm\\n+++ b/widget/src/cocoa/nsClipboard.mm\\n@@ -45,6 +45,10 @@\\n #include \\\"nsMemory.h\\\"\\n #include \\\"nsIImage.h\\\"\\n #include \\\"nsILocalFile.h\\\"\\n+#include \\\"nsStringStream.h\\\"\\n+\\n+// Screenshots use the (undocumented) png pasteboard type.\\n+#define IMAGE_PASTEBOARD_TYPES NSTIFFPboardType, @\\\"Apple PNG pasteboard type\\\", nil\\n \\n #ifdef MOZ_LOGGING\\n #define FORCE_PR_LOG\\n@@ -196,14 +200,72 @@ nsClipboard::GetNativeClipboardData(nsITransferable* aTransferable, PRInt32 aWhi\\n       free(clipboardDataPtr);\\n       break;\\n     }\\n+    else if (flavorStr.EqualsLiteral(kJPEGImageMime) ||\\n+             flavorStr.EqualsLiteral(kPNGImageMime) ||\\n+             flavorStr.EqualsLiteral(kGIFImageMime)) {\\n+      // Figure out if there's data on the pasteboard we can grab (sanity check)\\n+      NSString *type = [cocoaPasteboard availableTypeFromArray:[NSArray arrayWithObjects:IMAGE_PASTEBOARD_TYPES]];\\n+      if (!type)\\n+        continue;\\n \\n-    /*\\n-    if (flavorStr.EqualsLiteral(kPNGImageMime) || flavorStr.EqualsLiteral(kJPEGImageMime) ||\\n-        flavorStr.EqualsLiteral(kGIFImageMime)) {\\n-      // We have never supported this on Mac OS X, we could someday but nobody does this.\\n-      break;\\n+      // Read data off the clipboard, make sure to catch any exceptions (timeouts)\\n+      // XXX should convert to @try/@catch someday?\\n+      NSData *pasteboardData = nil;\\n+      NS_DURING\\n+        pasteboardData = [cocoaPasteboard dataForType:type];\\n+      NS_HANDLER\\n+        NS_ASSERTION(0, \\\"Exception raised while getting data from the pasteboard.\\\");\\n+      NS_ENDHANDLER\\n+      if (!pasteboardData)\\n+        continue;\\n+\\n+      // Figure out what type we're converting to\\n+      CFStringRef outputType = NULL; \\n+      if (flavorStr.EqualsLiteral(kJPEGImageMime))\\n+        outputType = CFSTR(\\\"public.jpeg\\\");\\n+      else if (flavorStr.EqualsLiteral(kPNGImageMime))\\n+        outputType = CFSTR(\\\"public.png\\\");\\n+      else if (flavorStr.EqualsLiteral(kGIFImageMime))\\n+        outputType = CFSTR(\\\"com.compuserve.gif\\\");\\n+      else\\n+        continue;\\n+\\n+      // Use ImageIO to interpret the data on the clipboard and transcode.\\n+      // Note that ImageIO, like all CF APIs, allows NULLs to propagate freely\\n+      // and safely in most cases (like ObjC). A notable exception is CFRelease.\\n+      NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:\\n+                                (NSNumber*)kCFBooleanTrue, kCGImageSourceShouldAllowFloat,\\n+                                (type == NSTIFFPboardType ? @\\\"public.tiff\\\" : @\\\"public.png\\\"),\\n+                                kCGImageSourceTypeIdentifierHint, nil];\\n+\\n+      CGImageSourceRef source = CGImageSourceCreateWithData((CFDataRef)pasteboardData, \\n+                                                            (CFDictionaryRef)options);\\n+      NSMutableData *encodedData = [NSMutableData data];\\n+      CGImageDestinationRef dest = CGImageDestinationCreateWithData((CFMutableDataRef)encodedData,\\n+                                                                    outputType,\\n+                                                                    1, NULL);\\n+      CGImageDestinationAddImageFromSource(dest, source, 0, NULL);\\n+      PRBool successfullyConverted = CGImageDestinationFinalize(dest);\\n+\\n+      if (successfullyConverted) {\\n+        // Put the converted data in a form Gecko can understand\\n+        nsCOMPtr<nsIInputStream> byteStream;\\n+        NS_NewByteInputStream(getter_AddRefs(byteStream), (const char*)[encodedData bytes],\\n+                                   [encodedData length], NS_ASSIGNMENT_COPY);\\n+  \\n+        aTransferable->SetTransferData(flavorStr, byteStream, sizeof(nsIInputStream*));\\n+      }\\n+\\n+      if (dest)\\n+        CFRelease(dest);\\n+      if (source)\\n+        CFRelease(source);\\n+      \\n+      if (successfullyConverted)\\n+        break;\\n+      else\\n+        continue;\\n     }\\n-    */\\n   }\\n \\n   return NS_OK;\\n@@ -271,6 +333,15 @@ nsClipboard::HasDataMatchingFlavors(nsISupportsArray* aFlavorList, PRInt32 aWhic\\n           *outResult = PR_TRUE;\\n           break;\\n         }\\n+      } else if (flavorStr.EqualsLiteral(kJPEGImageMime) ||\\n+                 flavorStr.EqualsLiteral(kPNGImageMime) ||\\n+                 flavorStr.EqualsLiteral(kGIFImageMime)) {\\n+        NSString* availableType = [generalPBoard availableTypeFromArray:\\n+                                    [NSArray arrayWithObjects:IMAGE_PASTEBOARD_TYPES]];\\n+        if (availableType) {\\n+          *outResult = PR_TRUE;\\n+          break;\\n+        }\\n       }\\n     }      \\n   }\\n@@ -369,28 +440,31 @@ nsClipboard::PasteboardDictFromTransferable(nsITransferable* aTransferable)\\n                                           NULL,\\n                                           0,\\n                                           kCGRenderingIntentDefault);\\n+      CGColorSpaceRelease(colorSpace);\\n       CGDataProviderRelease(dataProvider);\\n \\n       // Convert the CGImageRef to TIFF data.\\n       CFMutableDataRef tiffData = CFDataCreateMutable(kCFAllocatorDefault, 0);\\n       CGImageDestinationRef destRef = CGImageDestinationCreateWithData(tiffData,\\n-                                                                       (CFStringRef)@\\\"public.tiff\\\",\\n+                                                                       CFSTR(\\\"public.tiff\\\"),\\n                                                                        1,\\n-                                                                       nil);\\n-      CGImageDestinationAddImage(destRef, imageRef, nil);\\n-      CGImageDestinationFinalize(destRef);\\n+                                                                       NULL);\\n+      CGImageDestinationAddImage(destRef, imageRef, NULL);\\n+      PRBool successfullyConverted = CGImageDestinationFinalize(destRef);\\n \\n-      CGColorSpaceRelease(colorSpace);\\n       CGImageRelease(imageRef);\\n-      CFRelease(destRef);\\n+      if (destRef)\\n+        CFRelease(destRef);\\n \\n-      if (NS_FAILED(image->UnlockImagePixels(PR_FALSE))) {\\n-        CFRelease(tiffData);\\n+      if (NS_FAILED(image->UnlockImagePixels(PR_FALSE)) || !successfullyConverted) {\\n+        if (tiffData)\\n+          CFRelease(tiffData);\\n         continue;\\n       }\\n \\n       [pasteboardOutputDict setObject:(NSMutableData*)tiffData forKey:NSTIFFPboardType];\\n-      CFRelease(tiffData);\\n+      if (tiffData)\\n+        CFRelease(tiffData);\\n     }\\n     else if (flavorStr.EqualsLiteral(kFilePromiseMime)) {\\n       [pasteboardOutputDict setObject:[NSArray arrayWithObject:@\\\"\\\"] forKey:NSFilesPromisePboardType];      \\ndiff --git a/widget/src/windows/nsImageClipboard.cpp b/widget/src/windows/nsImageClipboard.cpp\\nindex c473d66..0c0f9d3 100644\\n--- a/widget/src/windows/nsImageClipboard.cpp\\n+++ b/widget/src/windows/nsImageClipboard.cpp\\n@@ -43,9 +43,6 @@\\n #include \\\"nsMemory.h\\\"\\n #include \\\"prmem.h\\\"\\n #include \\\"imgIEncoder.h\\\"\\n-#ifdef MOZILLA_1_8_BRANCH\\n-#define imgIEncoder imgIEncoder_MOZILLA_1_8_BRANCH\\n-#endif\\n #include \\\"nsLiteralString.h\\\"\\n \\n /* Things To Do 11/8/00\\n@@ -233,7 +230,7 @@ nsImageFromClipboard ::GetEncodedImageStream (unsigned char * aClipboardData, ns\\n       nsCOMPtr<imgIEncoder> encoder = do_CreateInstance(\\\"@mozilla.org/image/encoder;2?type=image/jpeg\\\", &rv);\\n       if (NS_SUCCEEDED(rv)){\\n         rv = encoder->InitFromData(rgbData, 0, width, height, 3 * width /* RGB * # pixels in a row */, \\n-                                   imgIEncoder::INPUT_FORMAT_RGB, NS_LITERAL_STRING(\\\"transparency=none\\\"));\\n+                                   imgIEncoder::INPUT_FORMAT_RGB, EmptyString());\\n         if (NS_SUCCEEDED(rv))\\n           encoder->QueryInterface(NS_GET_IID(nsIInputStream), (void **) aInputStream);\\n       }\\n\""}