{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas0e64ad9\""},"diff":"\"0e64ad9 Bug 393138 - Drag image code does not deal with pre-multiplied alpha. r+sr=roc\\ndiff --git a/widget/src/cocoa/nsDragService.mm b/widget/src/cocoa/nsDragService.mm\\nindex 7da9d53..7a73044 100644\\n--- a/widget/src/cocoa/nsDragService.mm\\n+++ b/widget/src/cocoa/nsDragService.mm\\n@@ -156,7 +156,7 @@ nsDragService::ConstructDragImage(nsIDOMNode* aDOMNode,\\n   }\\n \\n   if (NS_FAILED(rv) || !surface)\\n-    return nsnull;\\n+    return nil;\\n \\n   PRUint32 width = aDragRect->width;\\n   PRUint32 height = aDragRect->height;\\n@@ -164,11 +164,11 @@ nsDragService::ConstructDragImage(nsIDOMNode* aDOMNode,\\n   nsRefPtr<gfxImageSurface> imgSurface = new gfxImageSurface(\\n     gfxIntSize(width, height), gfxImageSurface::ImageFormatARGB32);\\n   if (!imgSurface)\\n-    return nsnull;\\n+    return nil;\\n \\n   nsRefPtr<gfxContext> context = new gfxContext(imgSurface);\\n   if (!context)\\n-    return nsnull;\\n+    return nil;\\n \\n   context->SetOperator(gfxContext::OPERATOR_SOURCE);\\n   context->SetSource(surface);\\n@@ -192,16 +192,17 @@ nsDragService::ConstructDragImage(nsIDOMNode* aDOMNode,\\n   for (PRUint32 i = 0; i < height; ++i) {\\n     PRUint8* src = (PRUint8 *)imageData + i * stride;\\n     for (PRUint32 j = 0; j < width; ++j) {\\n-      // reduce transparency overall by multipying by a factor\\n+      // Reduce transparency overall by multipying by a factor. Remember, Alpha\\n+      // is premultipled here. Also, Quartz likes RGBA, so do that translation as well.\\n #ifdef IS_BIG_ENDIAN\\n-      dest[0] = src[1];\\n-      dest[1] = src[2];\\n-      dest[2] = src[3];\\n+      dest[0] = PRUint8(src[1] * DRAG_TRANSLUCENCY);\\n+      dest[1] = PRUint8(src[2] * DRAG_TRANSLUCENCY);\\n+      dest[2] = PRUint8(src[3] * DRAG_TRANSLUCENCY);\\n       dest[3] = PRUint8(src[0] * DRAG_TRANSLUCENCY);\\n #else\\n-      dest[0] = src[2];\\n-      dest[1] = src[1];\\n-      dest[2] = src[0];\\n+      dest[0] = PRUint8(src[2] * DRAG_TRANSLUCENCY);\\n+      dest[1] = PRUint8(src[1] * DRAG_TRANSLUCENCY);\\n+      dest[2] = PRUint8(src[0] * DRAG_TRANSLUCENCY);\\n       dest[3] = PRUint8(src[3] * DRAG_TRANSLUCENCY);\\n #endif\\n       src += 4;\\n\""}