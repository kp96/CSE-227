{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas7fc4e1a\""},"diff":"\"7fc4e1a Bug 392303 - Simplify installer changes. r=sspitzer, a1.9=mconnor\\ndiff --git a/browser/installer/windows/nsis/installer.nsi b/browser/installer/windows/nsis/installer.nsi\\nindex b1a829f..492cbf2 100755\\n--- a/browser/installer/windows/nsis/installer.nsi\\n+++ b/browser/installer/windows/nsis/installer.nsi\\n@@ -34,8 +34,8 @@\\n #\\n # ***** END LICENSE BLOCK *****\\n \\n-# Also requires:\\n-# ShellLink plugin http://nsis.sourceforge.net/ShellLink_plug-in\\n+# Required Plugins:\\n+# ShellLink    http://nsis.sourceforge.net/ShellLink_plug-in\\n \\n ; Set verbosity to 3 (e.g. no script) to lessen the noise in the build logs\\n !verbose 3\\n@@ -59,8 +59,6 @@ Var InstallType\\n Var AddStartMenuSC\\n Var AddQuickLaunchSC\\n Var AddDesktopSC\\n-Var fhInstallLog\\n-Var fhUninstallLog\\n \\n ; Other included files may depend upon these includes!\\n ; The following includes are provided by NSIS.\\n@@ -71,16 +69,21 @@ Var fhUninstallLog\\n !include WordFunc.nsh\\n !include MUI.nsh\\n \\n-!insertmacro FileJoin\\n-!insertmacro GetTime\\n-!insertmacro LineFind\\n+; WinVer.nsh was added in the same release that RequestExecutionLevel so check\\n+; if ___WINVER__NSH___ is defined to determine if RequestExecutionLevel is\\n+; available.\\n+!include /NONFATAL WinVer.nsh\\n+!ifdef ___WINVER__NSH___\\n+  RequestExecutionLevel admin\\n+!else\\n+  !warning \\\"Installer will be created without Vista compatibility.$\\\\n            \\\\\\n+            Upgrade your NSIS installation to at least version 2.22 to resolve.\\\"\\n+!endif\\n+\\n !insertmacro StrFilter\\n-!insertmacro TrimNewLines\\n !insertmacro WordFind\\n !insertmacro WordReplace\\n !insertmacro GetSize\\n-!insertmacro GetParameters\\n-!insertmacro GetOptions\\n \\n ; NSIS provided macros that we have overridden\\n !include overrides.nsh\\n@@ -96,14 +99,12 @@ Var fhUninstallLog\\n \\n VIAddVersionKey \\\"FileDescription\\\" \\\"${BrandShortName} Installer\\\"\\n \\n+; Must be inserted before other macros that use logging\\n+!insertmacro _LoggingCommon\\n+\\n !insertmacro AddHandlerValues\\n-!insertmacro CanWriteToInstallDir\\n-!insertmacro CheckDiskSpace\\n-!insertmacro CleanVirtualStore\\n !insertmacro CloseApp\\n !insertmacro CreateRegKey\\n-!insertmacro GetLongPath\\n-!insertmacro GetSingleInstallPath\\n !insertmacro RegCleanMain\\n !insertmacro RegCleanUninstall\\n !insertmacro WriteRegStr2\\n@@ -111,6 +112,14 @@ VIAddVersionKey \\\"FileDescription\\\" \\\"${BrandShortName} Installer\\\"\\n \\n !include shared.nsh\\n \\n+; Helper macros for ui callbacks. Insert these after shared.nsh\\n+!insertmacro CheckCustomCommon\\n+!insertmacro InstallEndCleanupCommon\\n+!insertmacro InstallOnInitCommon\\n+!insertmacro InstallStartCleanupCommon\\n+!insertmacro LeaveDirectoryCommon\\n+!insertmacro PreDirectoryCommon\\n+\\n Name \\\"${BrandFullName}\\\"\\n OutFile \\\"setup.exe\\\"\\n InstallDirRegKey HKLM \\\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\\\\${BrandFullNameInternal} (${AppVersion})\\\" \\\"InstallLocation\\\"\\n@@ -173,7 +182,7 @@ Page custom preShortcuts leaveShortcuts\\n !insertmacro MUI_PAGE_STARTMENU Application $StartMenuDir\\n \\n ; Install Files Page\\n-!define MUI_PAGE_CUSTOMFUNCTION_LEAVE leaveInstFiles\\n+!define MUI_PAGE_CUSTOMFUNCTION_PRE preInstFiles\\n !insertmacro MUI_PAGE_INSTFILES\\n \\n ; Finish Page\\n@@ -188,12 +197,15 @@ Page custom preShortcuts leaveShortcuts\\n ################################################################################\\n # Install Sections\\n \\n-Section \\\"-Application\\\" Section1\\n-  SectionIn 1 RO\\n-  SetDetailsPrint textonly\\n+; Cleanup operations to perform at the start of the installation.\\n+Section \\\"-InstallStartCleanup\\\"\\n+  SetDetailsPrint both\\n   DetailPrint $(STATUS_CLEANUP)\\n   SetDetailsPrint none\\n \\n+  SetOutPath $INSTDIR\\n+  ${StartInstallLog} \\\"${BrandFullName}\\\" \\\"${AB_CD}\\\" \\\"${AppVersion}\\\" \\\"${GREVersion}\\\"\\n+\\n   ; Try to delete the app's main executable and if we can't delete it try to\\n   ; close the app. This allows running an instance that is located in another\\n   ; directory and prevents the launching of the app during the installation.\\n@@ -244,19 +256,7 @@ Section \\\"-Application\\\" Section1\\n   RmDir /r \\\"$TmpVal\\\"\\n   ClearErrors\\n \\n-  ; During an install Vista checks if a new entry is added under the uninstall\\n-  ; registry key (e.g. ARP). When the same version of the app is installed on\\n-  ; top of an existing install the key is deleted / added and the Program\\n-  ; Compatibility Assistant doesn't see this as a new entry and displays an\\n-  ; error to the user. See Bug 354000.\\n-  StrCpy $0 \\\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\\\\${BrandFullNameInternal} (${AppVersion})\\\"\\n-  DeleteRegKey HKLM \\\"$0\\\"\\n-\\n-  ; Remove files that may be left behind by the application in the\\n-  ; VirtualStore directory.\\n-  ${CleanVirtualStore}\\n-\\n-  ${If} $InstallType != 1\\n+  ${If} $InstallType == ${INSTALLTYPE_CUSTOM}\\n     ; Custom installs.\\n     ; If DOMi is installed and this install includes DOMi remove it from\\n     ; the installation directory. This will remove it if the user deselected\\n@@ -267,60 +267,16 @@ Section \\\"-Application\\\" Section1\\n     ${EndIf}\\n   ${EndIf}\\n \\n-  Call CleanupOldLogs\\n-\\n-  ${If} ${FileExists} \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\"\\n-    ; Diff cleanup.log with uninstall.bak\\n-    ${LogHeader} \\\"Updating Uninstall Log With XPInstall Wizard Logs\\\"\\n-    StrCpy $R0 \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\"\\n-    StrCpy $R1 \\\"$INSTDIR\\\\uninstall\\\\cleanup.log\\\"\\n-    GetTempFileName $R2\\n-    FileOpen $R3 $R2 w\\n-    ${TextCompareNoDetails} \\\"$R1\\\" \\\"$R0\\\" \\\"SlowDiff\\\" \\\"GetDiff\\\"\\n-    FileClose $R3\\n-\\n-    ${Unless} ${Errors}\\n-      ${FileJoin} \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\" \\\"$R2\\\" \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\"\\n-    ${EndUnless}\\n-    ${DeleteFile} \\\"$INSTDIR\\\\uninstall\\\\cleanup.log\\\"\\n-    ${DeleteFile} \\\"$R2\\\"\\n-    ${DeleteFile} \\\"$INSTDIR\\\\uninstall\\\\uninstall.bak\\\"\\n-    Rename \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\" \\\"$INSTDIR\\\\uninstall\\\\uninstall.bak\\\"\\n-  ${EndIf}\\n-\\n-  ${Unless} ${FileExists} \\\"$INSTDIR\\\\uninstall\\\"\\n-    CreateDirectory \\\"$INSTDIR\\\\uninstall\\\"\\n-  ${EndUnless}\\n-\\n-  FileOpen $fhUninstallLog \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\" w\\n-  FileOpen $fhInstallLog \\\"$INSTDIR\\\\install.log\\\" w\\n-\\n-  ${GetTime} \\\"\\\" \\\"L\\\" $0 $1 $2 $3 $4 $5 $6\\n-  FileWrite $fhInstallLog \\\"${BrandFullName} Installation Started: $2-$1-$0 $4:$5:$6\\\"\\n-  Call WriteLogSeparator\\n-\\n-  ${LogHeader} \\\"Installation Details\\\"\\n-  ${LogMsg} \\\"Install Dir: $INSTDIR\\\"\\n-  ${LogMsg} \\\"Locale     : ${AB_CD}\\\"\\n-  ${LogMsg} \\\"App Version: ${AppVersion}\\\"\\n-  ${LogMsg} \\\"GRE Version: ${GREVersion}\\\"\\n-\\n-  ${If} ${FileExists} \\\"$EXEDIR\\\\removed-files.log\\\"\\n-    ${LogHeader} \\\"Removing Obsolete Files and Directories\\\"\\n-    ${LineFind} \\\"$EXEDIR\\\\removed-files.log\\\" \\\"/NUL\\\" \\\"1:-1\\\" \\\"onInstallDeleteFile\\\"\\n-    ${LineFind} \\\"$EXEDIR\\\\removed-files.log\\\" \\\"/NUL\\\" \\\"1:-1\\\" \\\"onInstallRemoveDir\\\"\\n-  ${EndIf}\\n-\\n-  ${DeleteFile} \\\"$INSTDIR\\\\install_wizard.log\\\"\\n-  ${DeleteFile} \\\"$INSTDIR\\\\install_status.log\\\"\\n+  ${InstallStartCleanupCommon}\\n+SectionEnd\\n \\n-  RmDir /r \\\"$INSTDIR\\\\updates\\\"\\n-  ${DeleteFile} \\\"$INSTDIR\\\\updates.xml\\\"\\n-  ${DeleteFile} \\\"$INSTDIR\\\\active-update.xml\\\"\\n+Section \\\"-Application\\\" APP_IDX\\n+  ${StartUninstallLog}\\n \\n-  SetDetailsPrint textonly\\n+  SetDetailsPrint both\\n   DetailPrint $(STATUS_INSTALL_APP)\\n   SetDetailsPrint none\\n+\\n   ${LogHeader} \\\"Installing Main Files\\\"\\n   StrCpy $R0 \\\"$EXEDIR\\\\nonlocalized\\\"\\n   StrCpy $R1 \\\"$INSTDIR\\\"\\n@@ -354,20 +310,15 @@ Section \\\"-Application\\\" Section1\\n   ${LogUninstall} \\\"File: \\\\install_wizard.log\\\"\\n   ${LogUninstall} \\\"File: \\\\updates.xml\\\"\\n \\n-  SetDetailsPrint textonly\\n+  SetDetailsPrint both\\n   DetailPrint $(STATUS_INSTALL_LANG)\\n   SetDetailsPrint none\\n+\\n   ${LogHeader} \\\"Installing Localized Files\\\"\\n   StrCpy $R0 \\\"$EXEDIR\\\\localized\\\"\\n   StrCpy $R1 \\\"$INSTDIR\\\"\\n   Call DoCopyFiles\\n \\n-  ${If} $InstallType != 4\\n-    ${If} ${FileExists} \\\"$INSTDIR\\\\extensions\\\\inspector@mozilla.org\\\"\\n-      Call installInspector\\n-    ${EndIf}\\n-  ${EndIf}\\n-\\n   ${LogHeader} \\\"Adding Additional Files\\\"\\n   ; Check if QuickTime is installed and copy the nsIQTScriptablePlugin.xpt from\\n   ; its plugins directory into the app's components directory.\\n@@ -410,13 +361,14 @@ Section \\\"-Application\\\" Section1\\n   ${EndIf}\\n \\n   ; Remove registry entries for non-existent apps and for apps that point to our\\n-  ; install location in the Software\\\\Mozilla key.\\n+  ; install location in the Software\\\\Mozilla key and uninstall registry entries\\n+  ; that point to our install location for both HKCU and HKLM.\\n   SetShellVarContext current  ; Set SHCTX to HKCU\\n   ${RegCleanMain} \\\"Software\\\\Mozilla\\\"\\n+  ${RegCleanUninstall}\\n+\\n   SetShellVarContext all  ; Set SHCTX to HKLM\\n   ${RegCleanMain} \\\"Software\\\\Mozilla\\\"\\n-\\n-  ; Remove uninstall entries that point to our install location\\n   ${RegCleanUninstall}\\n \\n   ${LogHeader} \\\"Adding Registry Entries\\\"\\n@@ -482,43 +434,40 @@ Section \\\"-Application\\\" Section1\\n   ; Create Start Menu shortcuts\\n   ${LogHeader} \\\"Adding Shortcuts\\\"\\n   ${If} $AddStartMenuSC == 1\\n-    CreateDirectory \\\"$SMPROGRAMS\\\\$StartMenuDir\\\"\\n+    ${Unless} ${FileExists} \\\"$SMPROGRAMS\\\\$StartMenuDir\\\"\\n+      CreateDirectory \\\"$SMPROGRAMS\\\\$StartMenuDir\\\"\\n+      ${LogMsg} \\\"Added Start Menu Directory: $SMPROGRAMS\\\\$StartMenuDir\\\"\\n+    ${EndUnless}\\n     CreateShortCut \\\"$SMPROGRAMS\\\\$StartMenuDir\\\\${BrandFullNameInternal}.lnk\\\" \\\"$INSTDIR\\\\${FileMainEXE}\\\" \\\"\\\" \\\"$INSTDIR\\\\${FileMainEXE}\\\" 0\\n     ${LogUninstall} \\\"File: $SMPROGRAMS\\\\$StartMenuDir\\\\${BrandFullNameInternal}.lnk\\\"\\n+    ${LogMsg} \\\"Added Shortcut: $SMPROGRAMS\\\\$StartMenuDir\\\\${BrandFullNameInternal}.lnk\\\"\\n     CreateShortCut \\\"$SMPROGRAMS\\\\$StartMenuDir\\\\${BrandFullNameInternal} ($(SAFE_MODE)).lnk\\\" \\\"$INSTDIR\\\\${FileMainEXE}\\\" \\\"-safe-mode\\\" \\\"$INSTDIR\\\\${FileMainEXE}\\\" 0\\n     ${LogUninstall} \\\"File: $SMPROGRAMS\\\\$StartMenuDir\\\\${BrandFullNameInternal} ($(SAFE_MODE)).lnk\\\"\\n+    ${LogMsg} \\\"Added Shortcut: $SMPROGRAMS\\\\$StartMenuDir\\\\${BrandFullNameInternal} ($(SAFE_MODE)).lnk\\\"\\n   ${EndIf}\\n \\n   ; perhaps use the uninstall keys\\n   ${If} $AddQuickLaunchSC == 1\\n     CreateShortCut \\\"$QUICKLAUNCH\\\\${BrandFullName}.lnk\\\" \\\"$INSTDIR\\\\${FileMainEXE}\\\" \\\"\\\" \\\"$INSTDIR\\\\${FileMainEXE}\\\" 0\\n     ${LogUninstall} \\\"File: $QUICKLAUNCH\\\\${BrandFullName}.lnk\\\"\\n+    ${LogMsg} \\\"Added Shortcut: $QUICKLAUNCH\\\\${BrandFullName}.lnk\\\"\\n   ${EndIf}\\n \\n-  ${LogHeader} \\\"Updating Quick Launch Shortcuts\\\"\\n   ${If} $AddDesktopSC == 1\\n     CreateShortCut \\\"$DESKTOP\\\\${BrandFullName}.lnk\\\" \\\"$INSTDIR\\\\${FileMainEXE}\\\" \\\"\\\" \\\"$INSTDIR\\\\${FileMainEXE}\\\" 0\\n     ${LogUninstall} \\\"File: $DESKTOP\\\\${BrandFullName}.lnk\\\"\\n+    ${LogMsg} \\\"Added Shortcut: $DESKTOP\\\\${BrandFullName}.lnk\\\"\\n   ${EndIf}\\n \\n   !insertmacro MUI_STARTMENU_WRITE_END\\n-\\n-  ; Refresh desktop icons\\n-  System::Call \\\"shell32::SHChangeNotify(i, i, i, i) v (0x08000000, 0, 0, 0)\\\"\\n-SectionEnd\\n-\\n-Section /o \\\"Developer Tools\\\" Section2\\n-  Call installInspector\\n SectionEnd\\n \\n-################################################################################\\n-# Helper Functions\\n-\\n-Function installInspector\\n+Section /o \\\"Developer Tools\\\" DOMI_IDX\\n   ${If} ${FileExists} \\\"$EXEDIR\\\\optional\\\\extensions\\\\inspector@mozilla.org\\\"\\n-    SetDetailsPrint textonly\\n+    SetDetailsPrint both\\n     DetailPrint $(STATUS_INSTALL_OPTIONAL)\\n     SetDetailsPrint none\\n+\\n     ${RemoveDir} \\\"$INSTDIR\\\\extensions\\\\inspector@mozilla.org\\\"\\n     ClearErrors\\n     ${LogHeader} \\\"Installing Developer Tools\\\"\\n@@ -526,7 +475,23 @@ Function installInspector\\n     StrCpy $R1 \\\"$INSTDIR\\\\extensions\\\\inspector@mozilla.org\\\"\\n     Call DoCopyFiles\\n   ${EndIf}\\n-FunctionEnd\\n+SectionEnd\\n+\\n+; Cleanup operations to perform at the end of the installation.\\n+Section \\\"-InstallEndCleanup\\\"\\n+  SetDetailsPrint both\\n+  DetailPrint \\\"$(STATUS_CLEANUP)\\\"\\n+  SetDetailsPrint none\\n+  ${LogHeader} \\\"Updating Uninstall Log With Previous Uninstall Log\\\"\\n+\\n+  ${InstallEndCleanupCommon}\\n+\\n+  ; Refresh desktop icons\\n+  System::Call \\\"shell32::SHChangeNotify(i, i, i, i) v (0x08000000, 0, 0, 0)\\\"\\n+SectionEnd\\n+\\n+################################################################################\\n+# Helper Functions\\n \\n ; Copies a file to a temporary backup directory and then checks if it is in use\\n ; by attempting to delete the file. If the file is in use an error is displayed\\n@@ -553,72 +518,6 @@ Function CheckInUse\\n   ${EndIf}\\n FunctionEnd\\n \\n-; Adds a section divider to the human readable log.\\n-Function WriteLogSeparator\\n-  FileWrite $fhInstallLog \\\"$\\\\r$\\\\n-------------------------------------------------------------------------------$\\\\r$\\\\n\\\"\\n-FunctionEnd\\n-\\n-; Check whether to display the current page (e.g. if we aren't performing a\\n-; custom install don't display the custom pages).\\n-Function CheckCustom\\n-  ${If} $InstallType != 4\\n-    Abort\\n-  ${EndIf}\\n-FunctionEnd\\n-\\n-Function onInstallDeleteFile\\n-  ${TrimNewLines} \\\"$R9\\\" \\\"$R9\\\"\\n-  StrCpy $R1 \\\"$R9\\\" 5\\n-  ${If} $R1 == \\\"File:\\\"\\n-    StrCpy $R9 \\\"$R9\\\" \\\"\\\" 6\\n-    ${If} ${FileExists} \\\"$INSTDIR$R9\\\"\\n-      ClearErrors\\n-      Delete \\\"$INSTDIR$R9\\\"\\n-      ${If} ${Errors}\\n-        ${LogMsg} \\\"** ERROR Deleting File: $INSTDIR$R9 **\\\"\\n-      ${Else}\\n-        ${LogMsg} \\\"Deleted File: $INSTDIR$R9\\\"\\n-      ${EndIf}\\n-    ${EndIf}\\n-  ${EndIf}\\n-  ClearErrors\\n-  Push 0\\n-FunctionEnd\\n-\\n-; The previous installer removed directories even when they aren't empty so this\\n-; function does as well.\\n-Function onInstallRemoveDir\\n-  ${TrimNewLines} \\\"$R9\\\" \\\"$R9\\\"\\n-  StrCpy $R1 \\\"$R9\\\" 4\\n-  ${If} $R1 == \\\"Dir:\\\"\\n-    StrCpy $R9 \\\"$R9\\\" \\\"\\\" 5\\n-    StrCpy $R1 \\\"$R9\\\" \\\"\\\" -1\\n-    ${If} $R1 == \\\"\\\\\\\"\\n-      StrCpy $R9 \\\"$R9\\\" -1\\n-    ${EndIf}\\n-    ${If} ${FileExists} \\\"$INSTDIR$R9\\\"\\n-      ClearErrors\\n-      RmDir /r \\\"$INSTDIR$R9\\\"\\n-      ${If} ${Errors}\\n-        ${LogMsg} \\\"** ERROR Removing Directory: $INSTDIR$R9 **\\\"\\n-      ${Else}\\n-        ${LogMsg} \\\"Removed Directory: $INSTDIR$R9\\\"\\n-      ${EndIf}\\n-    ${EndIf}\\n-  ${EndIf}\\n-  ClearErrors\\n-  Push 0\\n-FunctionEnd\\n-\\n-Function GetDiff\\n-  ${TrimNewLines} \\\"$9\\\" \\\"$9\\\"\\n-  ${If} $9 != \\\"\\\"\\n-    FileWrite $R3 \\\"$9$\\\\r$\\\\n\\\"\\n-    ${LogMsg} \\\"Added To Uninstall Log: $9\\\"\\n-  ${EndIf}\\n-  Push 0\\n-FunctionEnd\\n-\\n Function DoCopyFiles\\n   StrLen $R2 $R0\\n   ${LocateNoDetails} \\\"$R0\\\" \\\"/L=FD\\\" \\\"CopyFile\\\"\\n@@ -668,7 +567,9 @@ Function CopyFile\\n       ${EndIf}\\n     ${EndIf}\\n     ClearErrors\\n+\\n     CopyFiles /SILENT $R9 \\\"$R1$R3\\\"\\n+\\n     ${If} ${Errors}\\n       ${LogMsg} \\\"** ERROR Installing File: $R1$R3\\\\$R7 **\\\"\\n       StrCpy $0 \\\"$R1$R3\\\\$R7\\\"\\n@@ -688,85 +589,6 @@ Function CopyFile\\n   Push 0\\n FunctionEnd\\n \\n-; Clean up the old log files. We only diff the first two found since it is\\n-; possible for there to be several MB and comparing that many would take a very\\n-; long time to diff.\\n-Function CleanupOldLogs\\n-  FindFirst $0 $TmpVal \\\"$INSTDIR\\\\uninstall\\\\*wizard*\\\"\\n-  StrCmp $TmpVal \\\"\\\" done\\n-  StrCpy $TmpVal \\\"$INSTDIR\\\\uninstall\\\\$TmpVal\\\"\\n-\\n-  FindNext $0 $1\\n-  StrCmp $1 \\\"\\\" cleanup\\n-  StrCpy $1 \\\"$INSTDIR\\\\uninstall\\\\$1\\\"\\n-  Push $1\\n-  Call DiffOldLogFiles\\n-  FindClose $0\\n-  ${DeleteFile} \\\"$1\\\"\\n-\\n-  cleanup:\\n-    StrCpy $2 \\\"$INSTDIR\\\\uninstall\\\\cleanup.log\\\"\\n-    ${DeleteFile} \\\"$2\\\"\\n-    FileOpen $R2 $2 w\\n-    Push $TmpVal\\n-    ${LineFind} \\\"$INSTDIR\\\\uninstall\\\\$TmpVal\\\" \\\"/NUL\\\" \\\"1:-1\\\" \\\"CleanOldLogFilesCallback\\\"\\n-    ${DeleteFile} \\\"$INSTDIR\\\\uninstall\\\\$TmpVal\\\"\\n-  done:\\n-    FindClose $0\\n-    FileClose $R2\\n-    FileClose $R3\\n-FunctionEnd\\n-\\n-Function DiffOldLogFiles\\n-  StrCpy $R1 \\\"$1\\\"\\n-  GetTempFileName $R2\\n-  FileOpen $R3 $R2 w\\n-  ${TextCompareNoDetails} \\\"$R1\\\" \\\"$TmpVal\\\" \\\"SlowDiff\\\" \\\"GetDiff\\\"\\n-  FileClose $R3\\n-  ${FileJoin} \\\"$TmpVal\\\" \\\"$R2\\\" \\\"$TmpVal\\\"\\n-  ${DeleteFile} \\\"$R2\\\"\\n-FunctionEnd\\n-\\n-Function CleanOldLogFilesCallback\\n-  ${TrimNewLines} \\\"$R9\\\" $R9\\n-  ${WordReplace} \\\"$R9\\\" \\\"$INSTDIR\\\" \\\"\\\" \\\"+\\\" $R3\\n-  ${WordFind} \\\"$R9\\\" \\\"\\t\\\" \\\"E+1}\\\" $R0\\n-  IfErrors updater 0\\n-\\n-  ${WordFind} \\\"$R0\\\" \\\"Installing: \\\" \\\"E+1}\\\" $R1\\n-  ${Unless} ${Errors}\\n-    FileWrite $R2 \\\"File: $R1$\\\\r$\\\\n\\\"\\n-    GoTo done\\n-  ${EndUnless}\\n-\\n-  ${WordFind} \\\"$R0\\\" \\\"Replacing: \\\" \\\"E+1}\\\" $R1\\n-  ${Unless} ${Errors}\\n-    FileWrite $R2 \\\"File: $R1$\\\\r$\\\\n\\\"\\n-    GoTo done\\n-  ${EndUnless}\\n-\\n-  ${WordFind} \\\"$R0\\\" \\\"Windows Shortcut: \\\" \\\"E+1}\\\" $R1\\n-  ${Unless} ${Errors}\\n-    FileWrite $R2 \\\"File: $R1.lnk$\\\\r$\\\\n\\\"\\n-    GoTo done\\n-  ${EndUnless}\\n-\\n-  ${WordFind} \\\"$R0\\\" \\\"Create Folder: \\\" \\\"E+1}\\\" $R1\\n-  ${Unless} ${Errors}\\n-    FileWrite $R2 \\\"Dir: $R1$\\\\r$\\\\n\\\"\\n-    GoTo done\\n-  ${EndUnless}\\n-\\n-  updater:\\n-    ${WordFind} \\\"$R9\\\" \\\"installing: \\\" \\\"E+1}\\\" $R0\\n-    ${Unless} ${Errors}\\n-      FileWrite $R2 \\\"File: $R0$\\\\r$\\\\n\\\"\\n-    ${EndUnless}\\n-\\n-  done:\\n-    Push 0\\n-FunctionEnd\\n-\\n Function LaunchApp\\n   ${CloseApp} \\\"true\\\" $(WARN_APP_RUNNING_INSTALL)\\n   Exec \\\"$INSTDIR\\\\${FileMainEXE}\\\"\\n@@ -801,14 +623,14 @@ Function leaveOptions\\n   ${EndIf}\\n   ${MUI_INSTALLOPTIONS_READ} $R0 \\\"options.ini\\\" \\\"Field 2\\\" \\\"State\\\"\\n   StrCmp $R0 \\\"1\\\" +1 +2\\n-  StrCpy $InstallType \\\"1\\\"\\n+  StrCpy $InstallType ${INSTALLTYPE_BASIC}\\n   ${MUI_INSTALLOPTIONS_READ} $R0 \\\"options.ini\\\" \\\"Field 3\\\" \\\"State\\\"\\n   StrCmp $R0 \\\"1\\\" +1 +2\\n-  StrCpy $InstallType \\\"4\\\"\\n+  StrCpy $InstallType ${INSTALLTYPE_CUSTOM}\\n FunctionEnd\\n \\n Function preComponents\\n-  Call CheckCustom\\n+  ${CheckCustomCommon}\\n   ; If DOMi isn't available skip the components page\\n   ${Unless} ${FileExists} \\\"$EXEDIR\\\\optional\\\\extensions\\\\inspector@mozilla.org\\\"\\n     Abort\\n@@ -821,48 +643,19 @@ Function leaveComponents\\n   ${MUI_INSTALLOPTIONS_READ} $R0 \\\"components.ini\\\" \\\"Field 2\\\" \\\"State\\\"\\n   ; State will be 1 for checked and 0 for unchecked so we can use that to set\\n   ; the section flags for installation.\\n-  SectionSetFlags 1 $R0\\n+  SectionSetFlags ${DOMI_IDX} $R0\\n FunctionEnd\\n \\n Function preDirectory\\n-  SetShellVarContext all  ; Set SHCTX to HKLM\\n-  ${GetSingleInstallPath} \\\"Software\\\\Mozilla\\\\${BrandFullNameInternal}\\\" $R9\\n-  ${If} $R9 == \\\"false\\\"\\n-    SetShellVarContext current  ; Set SHCTX to HKCU\\n-    ${GetSingleInstallPath} \\\"Software\\\\Mozilla\\\\${BrandFullNameInternal}\\\" $R9\\n-  ${EndIf}\\n-\\n-  ${Unless} $R9 == \\\"false\\\"\\n-    StrCpy $INSTDIR \\\"$R9\\\"\\n-  ${EndUnless}\\n-\\n-  ${If} $InstallType != 4\\n-    ${CheckDiskSpace} $R9\\n-    ${If} $R9 != \\\"false\\\"\\n-      ${CanWriteToInstallDir} $R9\\n-      ${If} $R9 != \\\"false\\\"\\n-        Abort\\n-      ${EndIf}\\n-    ${EndIf}\\n-  ${EndIf}\\n+  ${PreDirectoryCommon}\\n FunctionEnd\\n \\n Function leaveDirectory\\n-  ${CheckDiskSpace} $R9\\n-  ${If} $R9 == \\\"false\\\"\\n-    MessageBox MB_OK \\\"$(WARN_DISK_SPACE)\\\"\\n-    Abort\\n-  ${EndIf}\\n-\\n-  ${CanWriteToInstallDir} $R9\\n-  ${If} $R9 == \\\"false\\\"\\n-    MessageBox MB_OK \\\"$(WARN_WRITE_ACCESS)\\\"\\n-    Abort\\n-  ${EndIf}\\n+  ${LeaveDirectoryCommon} \\\"$(WARN_DISK_SPACE)\\\" \\\"$(WARN_WRITE_ACCESS)\\\"\\n FunctionEnd\\n \\n Function preShortcuts\\n-  Call CheckCustom\\n+  ${CheckCustomCommon}\\n   !insertmacro MUI_HEADER_TEXT \\\"$(SHORTCUTS_PAGE_TITLE)\\\" \\\"$(SHORTCUTS_PAGE_SUBTITLE)\\\"\\n   !insertmacro MUI_INSTALLOPTIONS_DISPLAY \\\"shortcuts.ini\\\"\\n FunctionEnd\\n@@ -878,42 +671,23 @@ Function leaveShortcuts\\n FunctionEnd\\n \\n Function preStartMenu\\n-  Call CheckCustom\\n+  ${CheckCustomCommon}\\n   ${If} $AddStartMenuSC != 1\\n     Abort\\n   ${EndIf}\\n FunctionEnd\\n \\n-Function leaveInstFiles\\n-  FileClose $fhUninstallLog\\n-  ; Diff and add missing entries from the previous file log if it exists\\n-  ${If} ${FileExists} \\\"$INSTDIR\\\\uninstall\\\\uninstall.bak\\\"\\n-    SetDetailsPrint textonly\\n-    DetailPrint $(STATUS_CLEANUP)\\n-    SetDetailsPrint none\\n-    ${LogHeader} \\\"Updating Uninstall Log With Previous Uninstall Log\\\"\\n-    StrCpy $R0 \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\"\\n-    StrCpy $R1 \\\"$INSTDIR\\\\uninstall\\\\uninstall.bak\\\"\\n-    GetTempFileName $R2\\n-    FileOpen $R3 $R2 w\\n-    ${TextCompareNoDetails} \\\"$R1\\\" \\\"$R0\\\" \\\"SlowDiff\\\" \\\"GetDiff\\\"\\n-    FileClose $R3\\n-    ${Unless} ${Errors}\\n-      ${FileJoin} \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\" \\\"$R2\\\" \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\"\\n-    ${EndUnless}\\n-    ${DeleteFile} \\\"$INSTDIR\\\\uninstall\\\\uninstall.bak\\\"\\n-    ${DeleteFile} \\\"$R2\\\"\\n+Function preInstFiles\\n+  ${If} $InstallType != ${INSTALLTYPE_CUSTOM}\\n+    ; Set DOMi to be installed\\n+    SectionSetFlags ${DOMI_IDX} 1\\n   ${EndIf}\\n-\\n-  Call WriteLogSeparator\\n-  ${GetTime} \\\"\\\" \\\"L\\\" $0 $1 $2 $3 $4 $5 $6\\n-  FileWrite $fhInstallLog \\\"${BrandFullName} Installation Finished: $2-$1-$0 $4:$5:$6$\\\\r$\\\\n\\\"\\n-  FileClose $fhInstallLog\\n FunctionEnd\\n \\n ; When we add an optional action to the finish page the cancel button is\\n ; enabled. This disables it and leaves the finish button as the only choice.\\n Function preFinish\\n+  ${EndInstallLog} \\\"${BrandFullName}\\\"\\n   !insertmacro MUI_INSTALLOPTIONS_WRITE \\\"ioSpecial.ini\\\" \\\"settings\\\" \\\"cancelenabled\\\" \\\"0\\\"\\n FunctionEnd\\n \\n@@ -921,124 +695,8 @@ FunctionEnd\\n # Initialization Functions\\n \\n Function .onInit\\n-  ${GetParameters} $R0\\n-  ${If} $R0 != \\\"\\\"\\n-    ClearErrors\\n-    ${GetOptions} \\\"$R0\\\" \\\"-ms\\\" $R1\\n-    ${If} ${Errors}\\n-      ; Default install type\\n-      StrCpy $InstallType \\\"1\\\"\\n-      ; Support for specifying an installation configuration file.\\n-      ClearErrors\\n-      ${GetOptions} \\\"$R0\\\" \\\"/INI=\\\" $R1\\n-      ${Unless} ${Errors}\\n-        ; The configuration file must also exist\\n-        ${If} ${FileExists} \\\"$R1\\\"\\n-          SetSilent silent\\n-          ReadINIStr $0 $R1 \\\"Install\\\" \\\"InstallDirectoryName\\\"\\n-          ${If} $0 != \\\"\\\"\\n-            StrCpy $INSTDIR \\\"$PROGRAMFILES\\\\$0\\\"\\n-          ${Else}\\n-            ReadINIStr $0 $R1 \\\"Install\\\" \\\"InstallDirectoryPath\\\"\\n-            ${If} $$0 != \\\"\\\"\\n-              StrCpy $INSTDIR \\\"$0\\\"\\n-            ${EndIf}\\n-          ${EndIf}\\n-\\n-          ${If} $INSTDIR == \\\"\\\"\\n-            ; Check if there is an existing uninstall registry entry for this\\n-            ; version of the application and if present install into that location\\n-            ReadRegStr $0 HKLM \\\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\\\\${BrandFullNameInternal} (${AppVersion})\\\" \\\"InstallLocation\\\"\\n-            ${If} $0 == \\\"\\\"\\n-              StrCpy $INSTDIR \\\"$PROGRAMFILES\\\\${BrandFullName}\\\"\\n-            ${Else}\\n-              GetFullPathName $INSTDIR \\\"$0\\\"\\n-              ${Unless} ${FileExists} \\\"$INSTDIR\\\"\\n-                StrCpy $INSTDIR \\\"$PROGRAMFILES\\\\${BrandFullName}\\\"\\n-              ${EndUnless}\\n-            ${EndIf}\\n-          ${EndIf}\\n-\\n-          ; Quit if we are unable to create the installation directory or we are\\n-          ; unable to write to a file in the installation directory.\\n-          ClearErrors\\n-          ${If} ${FileExists} \\\"$INSTDIR\\\"\\n-            GetTempFileName $R2 \\\"$INSTDIR\\\"\\n-            FileOpen $R3 $R2 w\\n-            FileWrite $R3 \\\"Write Access Test\\\"\\n-            FileClose $R3\\n-            Delete $R2\\n-            ${If} ${Errors}\\n-              Quit\\n-            ${EndIf}\\n-          ${Else}\\n-            CreateDirectory \\\"$INSTDIR\\\"\\n-            ${If} ${Errors}\\n-              Quit\\n-            ${EndIf}\\n-          ${EndIf}\\n-\\n-          ReadINIStr $0 $R1 \\\"Install\\\" \\\"CloseAppNoPrompt\\\"\\n-          ${If} $0 == \\\"true\\\"\\n-            ; Try to close the app if the exe is in use.\\n-            ClearErrors\\n-            ${If} ${FileExists} \\\"$INSTDIR\\\\${FileMainEXE}\\\"\\n-              ${DeleteFile} \\\"$INSTDIR\\\\${FileMainEXE}\\\"\\n-            ${EndIf}\\n-            ${If} ${Errors}\\n-              ClearErrors\\n-              ${CloseApp} \\\"false\\\" \\\"\\\"\\n-              ClearErrors\\n-              ${DeleteFile} \\\"$INSTDIR\\\\${FileMainEXE}\\\"\\n-              ; If unsuccessful try one more time and if it still fails Quit\\n-              ${If} ${Errors}\\n-                ClearErrors\\n-                ${CloseApp} \\\"false\\\" \\\"\\\"\\n-                ClearErrors\\n-                ${DeleteFile} \\\"$INSTDIR\\\\${FileMainEXE}\\\"\\n-                ${If} ${Errors}\\n-                  Quit\\n-                ${EndIf}\\n-              ${EndIf}\\n-            ${EndIf}\\n-          ${EndIf}\\n-\\n-          ReadINIStr $0 $R1 \\\"Install\\\" \\\"QuickLaunchShortcut\\\"\\n-          ${If} $0 == \\\"false\\\"\\n-            StrCpy $AddQuickLaunchSC \\\"0\\\"\\n-          ${Else}\\n-            StrCpy $AddQuickLaunchSC \\\"1\\\"\\n-          ${EndIf}\\n-\\n-          ReadINIStr $0 $R1 \\\"Install\\\" \\\"DesktopShortcut\\\"\\n-          ${If} $0 == \\\"false\\\"\\n-            StrCpy $AddDesktopSC \\\"0\\\"\\n-          ${Else}\\n-            StrCpy $AddDesktopSC \\\"1\\\"\\n-          ${EndIf}\\n-\\n-          ReadINIStr $0 $R1 \\\"Install\\\" \\\"StartMenuShortcuts\\\"\\n-          ${If} $0 == \\\"false\\\"\\n-            StrCpy $AddStartMenuSC \\\"0\\\"\\n-          ${Else}\\n-            StrCpy $AddStartMenuSC \\\"1\\\"\\n-          ${EndIf}\\n-\\n-          ReadINIStr $0 $R1 \\\"Install\\\" \\\"StartMenuDirectoryName\\\"\\n-          ${If} $0 != \\\"\\\"\\n-            StrCpy $StartMenuDir \\\"$0\\\"\\n-          ${EndIf}\\n-        ${EndIf}\\n-      ${EndUnless}\\n-    ${Else}\\n-      ; Support for the deprecated -ms command line argument. The new command\\n-      ; line arguments are not supported when -ms is used.\\n-      SetSilent silent\\n-    ${EndIf}\\n-  ${EndIf}\\n-  ClearErrors\\n+  ${InstallOnInitCommon} \\\"$(WARN_UNSUPPORTED_MSG)\\\"\\n \\n-  StrCpy $LANGUAGE 0\\n   !insertmacro MUI_INSTALLOPTIONS_EXTRACT \\\"options.ini\\\"\\n   !insertmacro MUI_INSTALLOPTIONS_EXTRACT \\\"components.ini\\\"\\n   !insertmacro MUI_INSTALLOPTIONS_EXTRACT \\\"shortcuts.ini\\\"\\n@@ -1046,18 +704,20 @@ Function .onInit\\n   !insertmacro createComponentsINI\\n   !insertmacro createShortcutsINI\\n \\n+  StrCpy $LANGUAGE 0\\n+\\n   ; There must always be nonlocalized and localized directories.\\n-  ${GetSize} \\\"$EXEDIR\\\\nonlocalized\\\\\\\" \\\"/S=0K\\\" $1 $8 $9\\n-  ${GetSize} \\\"$EXEDIR\\\\localized\\\\\\\" \\\"/S=0K\\\" $2 $8 $9\\n-  IntOp $0 $1 + $2\\n-  SectionSetSize 0 $0\\n+  ${GetSize} \\\"$EXEDIR\\\\nonlocalized\\\\\\\" \\\"/S=0K\\\" $R5 $R7 $R8\\n+  ${GetSize} \\\"$EXEDIR\\\\localized\\\\\\\" \\\"/S=0K\\\" $R6 $R7 $R8\\n+  IntOp $R8 $R5 + $R6\\n+  SectionSetSize ${APP_IDX} $R8\\n \\n   ${If} ${FileExists} \\\"$EXEDIR\\\\optional\\\\extensions\\\\inspector@mozilla.org\\\"\\n     ; Set the section size for DOMi.\\n     ${GetSize} \\\"$EXEDIR\\\\optional\\\\extensions\\\\inspector@mozilla.org\\\" \\\"/S=0K\\\" $0 $8 $9\\n-    SectionSetSize 1 $0\\n+    SectionSetSize ${DOMI_IDX} $0\\n   ${Else}\\n     ; Hide DOMi in the components page if it isn't available.\\n-    SectionSetText 1 \\\"\\\"\\n+    SectionSetText ${DOMI_IDX} \\\"\\\"\\n   ${EndIf}\\n FunctionEnd\\ndiff --git a/browser/installer/windows/nsis/shared.nsh b/browser/installer/windows/nsis/shared.nsh\\nindex d450f66..ef3f689 100755\\n--- a/browser/installer/windows/nsis/shared.nsh\\n+++ b/browser/installer/windows/nsis/shared.nsh\\n@@ -39,13 +39,14 @@\\n   ${SetStartMenuInternet}\\n \\n   ; Remove registry entries for non-existent apps and for apps that point to our\\n-  ; install location in the Software\\\\Mozilla key.\\n+  ; install location in the Software\\\\Mozilla key and uninstall registry entries\\n+  ; that point to our install location for both HKCU and HKLM.\\n   SetShellVarContext current  ; Set SHCTX to HKCU\\n   ${RegCleanMain} \\\"Software\\\\Mozilla\\\"\\n+  ${RegCleanUninstall}\\n+\\n   SetShellVarContext all  ; Set SHCTX to HKLM\\n   ${RegCleanMain} \\\"Software\\\\Mozilla\\\"\\n-\\n-  ; Remove uninstall entries that point to our install location\\n   ${RegCleanUninstall}\\n \\n   ; Add Software\\\\Mozilla\\\\ registry entries\\ndiff --git a/browser/installer/windows/nsis/uninstaller.nsi b/browser/installer/windows/nsis/uninstaller.nsi\\nindex 94ca157..0becc81 100755\\n--- a/browser/installer/windows/nsis/uninstaller.nsi\\n+++ b/browser/installer/windows/nsis/uninstaller.nsi\\n@@ -34,7 +34,7 @@\\n #\\n # ***** END LICENSE BLOCK *****\\n \\n-# Also requires:\\n+# Required Plugins:\\n # ShellLink plugin http://nsis.sourceforge.net/ShellLink_plug-in\\n \\n ; Set verbosity to 3 (e.g. no script) to lessen the noise in the build logs\\n@@ -62,12 +62,22 @@ Var TmpVal\\n !include WordFunc.nsh\\n !include MUI.nsh\\n \\n-!insertmacro GetOptions\\n-!insertmacro GetParameters\\n+; WinVer.nsh was added in the same release that RequestExecutionLevel so check\\n+; if ___WINVER__NSH___ is defined to determine if RequestExecutionLevel is\\n+; available.\\n+!include /NONFATAL WinVer.nsh\\n+!ifdef ___WINVER__NSH___\\n+  RequestExecutionLevel admin\\n+!else\\n+  !warning \\\"Uninstaller will be created without Vista compatibility.$\\\\n            \\\\\\n+            Upgrade your NSIS installation to at least version 2.22 to resolve.\\\"\\n+!endif\\n+\\n !insertmacro StrFilter\\n !insertmacro WordFind\\n !insertmacro WordReplace\\n \\n+!insertmacro un.GetParent\\n !insertmacro un.LineFind\\n !insertmacro un.TrimNewLines\\n \\n@@ -82,24 +92,28 @@ Var TmpVal\\n ; post update cleanup.\\n VIAddVersionKey \\\"FileDescription\\\" \\\"${BrandShortName} Helper\\\"\\n \\n-!insertmacro GetLongPath\\n !insertmacro AddHandlerValues\\n !insertmacro CleanVirtualStore\\n+!insertmacro GetLongPath\\n !insertmacro RegCleanMain\\n !insertmacro RegCleanUninstall\\n-!insertmacro UpdateUninstallLog\\n-!insertmacro WriteRegStr2\\n !insertmacro WriteRegDWORD2\\n+!insertmacro WriteRegStr2\\n \\n-!insertmacro un.GetLongPath\\n-!insertmacro un.RegCleanMain\\n-!insertmacro un.RegCleanUninstall\\n !insertmacro un.CleanVirtualStore\\n !insertmacro un.CloseApp\\n+!insertmacro un.GetLongPath\\n !insertmacro un.GetSecondInstallPath\\n+!insertmacro un.ParseUninstallLog\\n+!insertmacro un.RegCleanMain\\n+!insertmacro un.RegCleanUninstall\\n+!insertmacro un.RemoveQuotesFromPath\\n \\n !include shared.nsh\\n \\n+; Helper macros for ui callbacks. Insert these after shared.nsh\\n+!insertmacro UninstallOnInitCommon\\n+\\n Name \\\"${BrandFullName}\\\"\\n OutFile \\\"helper.exe\\\"\\n InstallDirRegKey HKLM \\\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\\\\${BrandFullNameInternal} (${AppVersion})\\\" \\\"InstallLocation\\\"\\n@@ -164,14 +178,16 @@ Section \\\"Uninstall\\\"\\n   SetDetailsPrint textonly\\n   DetailPrint $(STATUS_UNINSTALL_MAIN)\\n   SetDetailsPrint none\\n+\\n   ; Remove registry entries for non-existent apps and for apps that point to our\\n-  ; install location in the Software\\\\Mozilla key.\\n+  ; install location in the Software\\\\Mozilla key and uninstall registry entries\\n+  ; that point to our install location for both HKCU and HKLM.\\n   SetShellVarContext current  ; Sets SHCTX to HKCU\\n   ${un.RegCleanMain} \\\"Software\\\\Mozilla\\\"\\n+  ${un.RegCleanUninstall}\\n+\\n   SetShellVarContext all  ; Sets SHCTX to HKLM\\n   ${un.RegCleanMain} \\\"Software\\\\Mozilla\\\"\\n-\\n-  ; Remove uninstall entries that point to our install location\\n   ${un.RegCleanUninstall}\\n \\n   SetShellVarContext all  ; Set SHCTX to HKLM\\n@@ -182,13 +198,9 @@ Section \\\"Uninstall\\\"\\n   ${EndIf}\\n \\n   StrCpy $0 \\\"Software\\\\Clients\\\\StartMenuInternet\\\\${FileMainEXE}\\\\shell\\\\open\\\\command\\\"\\n-  ReadRegStr $1 HKLM \\\"$0\\\" \\\"\\\"\\n-  Push $1\\n-  ${GetPathFromRegStr}\\n-  Pop $R0\\n-  Push $R0\\n-  ${GetParentDir}\\n-  Pop $R1\\n+  ReadRegStr $R1 HKLM \\\"$0\\\" \\\"\\\"\\n+  ${un.RemoveQuotesFromPath} \\\"$R1\\\" $R1\\n+  ${un.GetParent} \\\"$R1\\\" $R1\\n \\n   ; Only remove the StartMenuInternet key if it refers to this install location.\\n   ; The StartMenuInternet registry key is independent of the default browser\\n@@ -197,6 +209,7 @@ Section \\\"Uninstall\\\"\\n   ; installing even if there is another install of Firefox that is set as the\\n   ; default browser. Now the key is always updated on install but it is only\\n   ; removed if it refers to this install location.\\n+  MessageBox MB_OK \\\"$INSTDIR$\\\\n$R1\\\"\\n   ${If} \\\"$INSTDIR\\\" == \\\"$R1\\\"\\n     ; XXXrstrong - if there is another installation of the same app ideally we\\n     ; would just modify these values. The GetSecondInstallPath macro could be\\n@@ -215,152 +228,45 @@ Section \\\"Uninstall\\\"\\n     StrCpy $0 \\\"MIME\\\\Database\\\\Content Type\\\\application/x-xpinstall;app=firefox\\\"\\n     DeleteRegKey HKCR \\\"$0\\\"\\n   ${Else}\\n-    ReadRegStr $1 HKLM \\\"$0\\\" \\\"\\\"\\n-    Push $1\\n-    ${GetPathFromRegStr}\\n-    Pop $R0\\n-    Push $R0\\n-    ${GetParentDir}\\n-    Pop $R1\\n+    ReadRegStr $R1 HKLM \\\"$0\\\" \\\"\\\"\\n+    ${un.RemoveQuotesFromPath} \\\"$R1\\\" $R1\\n+    ${un.GetParent} \\\"$R1\\\" $R1\\n     ${If} \\\"$INSTDIR\\\" == \\\"$R1\\\"\\n       WriteRegStr HKLM \\\"$0\\\" \\\"\\\" \\\"$R9\\\"\\n-      Push $R9\\n-      ${GetParentDir}\\n-      Pop $R1\\n+      ${un.GetParent} \\\"$R9\\\" $R1\\n       WriteRegStr HKLM \\\"$0\\\" \\\"Path\\\" \\\"$R1\\\"\\n     ${EndIf}\\n   ${EndIf}\\n \\n-  ; Remove files. If we don't have a log file skip\\n-  ${If} ${FileExists} \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\"\\n-    ; Copy the uninstall log file to a temporary file\\n-    GetTempFileName $TmpVal\\n-    CopyFiles /SILENT /FILESONLY \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\" \\\"$TmpVal\\\"\\n-\\n-    ; Unregister DLL's\\n-    ${un.LineFind} \\\"$TmpVal\\\" \\\"/NUL\\\" \\\"1:-1\\\" \\\"un.UnRegDLLsCallback\\\"\\n+  ; Remove directories and files we always control\\n+  RmDir /r \\\"$INSTDIR\\\\updates\\\"\\n+  RmDir /r \\\"$INSTDIR\\\\defaults\\\\shortcuts\\\"\\n+  RmDir /r \\\"$INSTDIR\\\\distribution\\\"\\n+  Delete \\\"$INSTDIR\\\\removed-files\\\"\\n \\n-    ; Delete files\\n-    ${un.LineFind} \\\"$TmpVal\\\" \\\"/NUL\\\" \\\"1:-1\\\" \\\"un.RemoveFilesCallback\\\"\\n+  ; Parse the uninstall log to unregister dll's and remove all installed\\n+  ; files / directories this install is responsible for.\\n+  ${un.ParseUninstallLog}\\n \\n-    ; Remove directories we always control\\n-    RmDir /r \\\"$INSTDIR\\\\uninstall\\\"\\n-    RmDir /r \\\"$INSTDIR\\\\updates\\\"\\n-    RmDir /r \\\"$INSTDIR\\\\defaults\\\\shortcuts\\\"\\n+  ; Remove the uninstall directory that we control\\n+  RmDir /r \\\"$INSTDIR\\\\uninstall\\\"\\n \\n-    ; Remove empty directories\\n-    ${un.LineFind} \\\"$TmpVal\\\" \\\"/NUL\\\" \\\"1:-1\\\" \\\"un.RemoveDirsCallback\\\"\\n-\\n-    ; Delete the temporary uninstall log file\\n-    ${DeleteFile} \\\"$TmpVal\\\"\\n-\\n-    ; Remove the installation directory if it is empty\\n-    ${RemoveDir} \\\"$INSTDIR\\\"\\n-  ${EndIf}\\n+  ; Remove the installation directory if it is empty\\n+  ${RemoveDir} \\\"$INSTDIR\\\"\\n \\n   ; Remove files that may be left behind by the application in the\\n   ; VirtualStore directory.\\n   ${un.CleanVirtualStore}\\n \\n   ; Refresh desktop icons otherwise the start menu internet item won't be\\n-  ; removed and other ugly things will happen like recreation of the registry\\n-  ; key by the OS under some conditions.\\n+  ; removed and other ugly things will happen like recreation of the app's\\n+  ; clients registry key by the OS under some conditions.\\n   System::Call \\\"shell32::SHChangeNotify(i, i, i, i) v (0x08000000, 0, 0, 0)\\\"\\n SectionEnd\\n \\n ################################################################################\\n # Helper Functions\\n \\n-Function un.RemoveFilesCallback\\n-  ${un.TrimNewLines} \\\"$R9\\\" \\\"$R9\\\"\\n-  StrCpy $R1 \\\"$R9\\\" 5\\n-  ${If} $R1 == \\\"File:\\\"\\n-    StrCpy $R9 \\\"$R9\\\" \\\"\\\" 6\\n-    StrCpy $R0 \\\"$R9\\\" 1\\n-    ; If the path is relative prepend the install directory\\n-    ${If} $R0 == \\\"\\\\\\\"\\n-      StrCpy $R0 \\\"$INSTDIR$R9\\\"\\n-    ${Else}\\n-      StrCpy $R0 \\\"$R9\\\"\\n-    ${EndIf}\\n-    ${If} ${FileExists} \\\"$R0\\\"\\n-      ${DeleteFile} \\\"$R0\\\"\\n-    ${EndIf}\\n-  ${EndIf}\\n-  ClearErrors\\n-  Push 0\\n-FunctionEnd\\n-\\n-; Using locate will leave file handles open to some of the directories which\\n-; will prevent the deletion of these directories. This parses the uninstall.log\\n-; and uses the file entries to find / remove empty directories.\\n-Function un.RemoveDirsCallback\\n-  ${un.TrimNewLines} \\\"$R9\\\" \\\"$R9\\\"\\n-  StrCpy $R1 \\\"$R9\\\" 5\\n-  ${If} $R1 == \\\"File:\\\"\\n-    StrCpy $R9 \\\"$R9\\\" \\\"\\\" 6\\n-    StrCpy $R1 \\\"$R9\\\" 1\\n-    ${If} $R1 == \\\"\\\\\\\"\\n-      StrCpy $R2 \\\"$INSTDIR\\\"\\n-      StrCpy $R1 \\\"$INSTDIR$R9\\\"\\n-    ${Else}\\n-      StrCpy $R2 \\\"\\\"\\n-      StrCpy $R1 \\\"$R9\\\"\\n-    ${EndIf}\\n-    loop:\\n-      Push $R1\\n-      ${GetParentDir}\\n-      Pop $R0\\n-      GetFullPathName $R1 \\\"$R0\\\"\\n-      ; We only try to remove empty directories but the Desktop, StartMenu, and\\n-      ; QuickLaunch directories can be empty so guard against removing them.\\n-      ${If} \\\"$R2\\\" != \\\"$INSTDIR\\\"\\n-        SetShellVarContext all\\n-        ${If} $R1 == \\\"$DESKTOP\\\"\\n-        ${OrIf} $R1 == \\\"$STARTMENU\\\"\\n-          GoTo end\\n-        ${EndIf}\\n-        SetShellVarContext current\\n-        ${If} $R1 == \\\"$QUICKLAUNCH\\\"\\n-        ${OrIf} $R1 == \\\"$DESKTOP\\\"\\n-        ${OrIf} $R1 == \\\"$STARTMENU\\\"\\n-          GoTo end\\n-        ${EndIf}\\n-      ${ElseIf} \\\"$R1\\\" == \\\"$INSTDIR\\\"\\n-        GoTo end\\n-      ${EndIf}\\n-      ${If} ${FileExists} \\\"$R1\\\"\\n-        RmDir \\\"$R1\\\"\\n-      ${EndIf}\\n-      ${If} ${Errors}\\n-      ${OrIf} \\\"$R2\\\" != \\\"$INSTDIR\\\"\\n-        GoTo end\\n-      ${EndIf}\\n-      GoTo loop\\n-  ${EndIf}\\n-\\n-  end:\\n-    ClearErrors\\n-    Push 0\\n-FunctionEnd\\n-\\n-Function un.UnRegDLLsCallback\\n-  ${un.TrimNewLines} \\\"$R9\\\" \\\"$R9\\\"\\n-  StrCpy $R1 \\\"$R9\\\" 7\\n-  ${If} $R1 == \\\"DLLReg:\\\"\\n-    StrCpy $R9 \\\"$R9\\\" \\\"\\\" 8\\n-    StrCpy $R1 \\\"$R9\\\" 1\\n-    ${If} $R1 == \\\"\\\\\\\"\\n-      StrCpy $R1 \\\"$INSTDIR$R9\\\"\\n-    ${Else}\\n-      StrCpy $R1 \\\"$R9\\\"\\n-    ${EndIf}\\n-    UnRegDLL $R1\\n-  ${EndIf}\\n-  ClearErrors\\n-  Push 0\\n-FunctionEnd\\n-\\n ; Setup the survey controls, functions, etc. except when the application has\\n ; defined NO_UNINSTALL_SURVEY\\n !ifndef NO_UNINSTALL_SURVEY\\n@@ -441,88 +347,13 @@ FunctionEnd\\n \\n ################################################################################\\n # Initialization Functions\\n-\\n Function .onInit\\n-  GetFullPathName $INSTDIR \\\"$EXEDIR\\\\..\\\"\\n-  ${Unless} ${FileExists} \\\"$INSTDIR\\\\${FileMainEXE}\\\"\\n-    Abort\\n-  ${EndUnless}\\n-  ${GetParameters} $R0\\n-\\n-  ${Switch} $R0\\n-    ${Case} \\\"/HideShortcuts\\\"\\n-      ${HideShortcuts}\\n-      StrCpy $R1 \\\"true\\\"\\n-      ${Break}\\n-    ${Case} \\\"/ShowShortcuts\\\"\\n-      ${ShowShortcuts}\\n-      StrCpy $R1 \\\"true\\\"\\n-      ${Break}\\n-    ${Case} \\\"/SetAsDefaultAppUser\\\"\\n-      ${SetAsDefaultAppUser}\\n-      StrCpy $R1 \\\"true\\\"\\n-      ${Break}\\n-    ${Case} \\\"/SetAsDefaultAppGlobal\\\"\\n-      ${SetAsDefaultAppGlobal}\\n-      StrCpy $R1 \\\"true\\\"\\n-      ${Break}\\n-    ${Default}\\n-      ClearErrors\\n-      ${Unless} \\\"$R0\\\" == \\\"\\\"\\n-        ${WordReplace} \\\"$R0\\\" \\\"$\\\\\\\"\\\" \\\"\\\" \\\"+\\\" $R0\\n-        ClearErrors\\n-        ${GetOptions} \\\"$R0\\\" \\\"/PostUpdate\\\" $R2\\n-        ${Unless} ${Errors}\\n-          ${PostUpdate}\\n-          ClearErrors\\n-          ${GetOptions} \\\"$R0\\\" \\\"/UninstallLog=\\\" $R2\\n-          ${Unless} ${Errors}\\n-            ${Unless} \\\"$R2\\\" == \\\"\\\"\\n-              GetFullPathName $R3 \\\"$R2\\\"\\n-              ${If} ${FileExists} \\\"$R3\\\"\\n-                Delete \\\"$INSTDIR\\\\uninstall\\\\*wizard*\\\"\\n-                Delete \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\"\\n-                CopyFiles /SILENT /FILESONLY \\\"$R3\\\" \\\"$INSTDIR\\\\uninstall\\\\\\\"\\n-                Push $R3\\n-                ${GetParentDir}\\n-                Pop $R4\\n-                Delete \\\"$R3\\\"\\n-                RmDir \\\"$R4\\\"\\n-              ${EndIf}\\n-            ${EndUnless}\\n-          ${Else}\\n-            ${UpdateUninstallLog}\\n-          ${EndUnless}\\n-          StrCpy $R1 \\\"true\\\"\\n-        ${EndUnless}\\n-      ${EndUnless}\\n-      ${Break}\\n-  ${EndSwitch}\\n-\\n-  ${If} $R1 == \\\"true\\\"\\n-    System::Call \\\"shell32::SHChangeNotify(i, i, i, i) v (0x08000000, 0, 0, 0)\\\"\\n-    Quit\\n-  ${EndIf}\\n-\\n-  ; If we made it this far then this installer is being used as an uninstaller.\\n-  WriteUninstaller \\\"$EXEDIR\\\\uninstaller.exe\\\"\\n-\\n-  ${If} $R0 == \\\"/S\\\"\\n-    StrCpy $TmpVal \\\"$\\\\\\\"$EXEDIR\\\\uninstaller.exe$\\\\\\\" /S\\\"\\n-  ${Else}\\n-    StrCpy $TmpVal \\\"$\\\\\\\"$EXEDIR\\\\uninstaller.exe$\\\\\\\"\\\"\\n-  ${EndIf}\\n-\\n-  ; When the uninstaller is launched it copies itself to the temp directory so\\n-  ; it won't be in use so it can delete itself.\\n-  ExecWait $TmpVal\\n-  ${DeleteFile} \\\"$EXEDIR\\\\uninstaller.exe\\\"\\n-  SetErrorLevel 0\\n-  Quit\\n+  ${UninstallOnInitCommon}\\n FunctionEnd\\n \\n Function un.onInit\\n   GetFullPathName $INSTDIR \\\"$INSTDIR\\\\..\\\"\\n+  ${un.GetLongPath} \\\"$INSTDIR\\\" $INSTDIR\\n   ${Unless} ${FileExists} \\\"$INSTDIR\\\\${FileMainEXE}\\\"\\n     Abort\\n   ${EndUnless}\\ndiff --git a/toolkit/mozapps/installer/windows/nsis/common.nsh b/toolkit/mozapps/installer/windows/nsis/common.nsh\\nindex 050148e..1e1b5d2 100755\\n--- a/toolkit/mozapps/installer/windows/nsis/common.nsh\\n+++ b/toolkit/mozapps/installer/windows/nsis/common.nsh\\n@@ -35,51 +35,139 @@\\n # ***** END LICENSE BLOCK *****\\n \\n ################################################################################\\n-# Helper defines and macros\\n-\\n-/*\\n-Avoid creating macros / functions that overwrite vars! If you decide to do so\\n-document which var is being overwritten (see the GetSecondInstallPath macro for\\n-an example).\\n-\\n-Before using the vars get the passed in params and save existing var values to\\n-the stack.\\n-\\n-Exch $R9 ; exhange the original $R9 with the top of the stack\\n-Exch 1   ; exchange the top of the stack with 1 below the top of the stack\\n-Exch $R8 ; exchange the original $R8 with the top of the stack\\n-Exch 2   ; exchange the top of the stack with 2 below the top of the stack\\n-Exch $R7 ; exchange the original $R7 with the top of the stack\\n-Push $R6 ; push the original $R6 onto the top of the stack\\n-Push $R5 ; push the original $R5 onto the top of the stack\\n-Push $R4 ; push the original $R4 onto the top of the stack\\n-\\n-<do stuff>\\n-\\n-Then restore the values.\\n-Pop $R4  ; restore the value for $R4 from the top of the stack\\n-Pop $R5  ; restore the value for $R5 from the top of the stack\\n-Pop $R6  ; restore the value for $R6 from the top of the stack\\n-Exch $R7 ; exchange the new $R7 value with the top of the stack\\n-Exch 2   ; exchange the top of the stack with 2 below the top of the stack\\n-Exch $R8 ; exchange the new $R8 value with the top of the stack\\n-Exch 1   ; exchange the top of the stack with 2 below the top of the stack\\n-Exch $R9 ; exchange the new $R9 value with the top of the stack\\n-*/\\n+# Helper defines and macros for toolkit applications\\n+\\n+/**\\n+ * Avoid creating macros / functions that overwrite registers (see the\\n+ * GetLongPath macro for one way to avoid this)!\\n+ *\\n+ * Before using the registers exchange the passed in params and save existing\\n+ * register values to the stack.\\n+ *\\n+ * Exch $R9 ; exhange the original $R9 with the top of the stack\\n+ * Exch 1   ; exchange the top of the stack with 1 below the top of the stack\\n+ * Exch $R8 ; exchange the original $R8 with the top of the stack\\n+ * Exch 2   ; exchange the top of the stack with 2 below the top of the stack\\n+ * Exch $R7 ; exchange the original $R7 with the top of the stack\\n+ * Push $R6 ; push the original $R6 onto the top of the stack\\n+ * Push $R5 ; push the original $R5 onto the top of the stack\\n+ * Push $R4 ; push the original $R4 onto the top of the stack\\n+ *\\n+ * <do stuff>\\n+ *\\n+ * ; Restore the values.\\n+ * Pop $R4  ; restore the value for $R4 from the top of the stack\\n+ * Pop $R5  ; restore the value for $R5 from the top of the stack\\n+ * Pop $R6  ; restore the value for $R6 from the top of the stack\\n+ * Exch $R7 ; exchange the new $R7 value with the top of the stack\\n+ * Exch 2   ; exchange the top of the stack with 2 below the top of the stack\\n+ * Exch $R8 ; exchange the new $R8 value with the top of the stack\\n+ * Exch 1   ; exchange the top of the stack with 2 below the top of the stack\\n+ * Exch $R9 ; exchange the new $R9 value with the top of the stack\\n+ *\\n+ *\\n+ * When inserting macros in common.nsh from another macro in common.nsh that\\n+ * can be used from the uninstaller _MOZFUNC_UN will be undefined when it is\\n+ * inserted. Use the following to redefine _MOZFUNC_UN with its original value\\n+ * (see the RegCleanMain macro for an example).\\n+ *\\n+ * !define _MOZFUNC_UN_TMP ${_MOZFUNC_UN}\\n+ * !insertmacro ${_MOZFUNC_UN_TMP}FileJoin\\n+ * !insertmacro ${_MOZFUNC_UN_TMP}LineFind\\n+ * !insertmacro ${_MOZFUNC_UN_TMP}TextCompareNoDetails\\n+ * !insertmacro ${_MOZFUNC_UN_TMP}TrimNewLines\\n+ * !undef _MOZFUNC_UN\\n+ * !define _MOZFUNC_UN ${_MOZFUNC_UN_TMP}\\n+ * !undef _MOZFUNC_UN_TMP\\n+ */\\n \\n ; When including a file provided by NSIS check if its verbose macro is defined\\n ; to prevent loading the file a second time.\\n !ifmacrondef TEXTFUNC_VERBOSE\\n-!include TextFunc.nsh\\n+  !include TextFunc.nsh\\n !endif\\n \\n !ifmacrondef FILEFUNC_VERBOSE\\n-!include FileFunc.nsh\\n+  !include FileFunc.nsh\\n+!endif\\n+\\n+!ifmacrondef LOGICLIB_VERBOSITY\\n+  !include LogicLib.nsh\\n+!endif\\n+\\n+!ifndef MUI_VERBOSE\\n+  !include MUI.nsh\\n+!endif\\n+\\n+; When including WinVer.nsh check if ___WINVER__NSH___ is defined to prevent\\n+; loading the file a second time. NSIS versions prior to 2.21 didn't include\\n+; WinVer.nsh so include it with the /NOFATAL option.\\n+!ifndef ___WINVER__NSH___\\n+  !include /NONFATAL WinVer.nsh\\n !endif\\n \\n ; NSIS provided macros that we have overridden.\\n !include overrides.nsh\\n \\n+################################################################################\\n+# Macros for debugging\\n+\\n+/**\\n+ * The following two macros assist with verifying that a macro doesn't\\n+ * overwrite any registers.\\n+ *\\n+ * Usage:\\n+ * ${debugSetRegisters}\\n+ * <do stuff>\\n+ * ${debugDisplayRegisters}\\n+ */\\n+\\n+/**\\n+ * Sets all register values to their name to assist with verifying that a macro\\n+ * doesn't overwrite any registers.\\n+ */\\n+!macro debugSetRegisters\\n+  StrCpy $0 \\\"$$0\\\"\\n+  StrCpy $1 \\\"$$1\\\"\\n+  StrCpy $2 \\\"$$2\\\"\\n+  StrCpy $3 \\\"$$3\\\"\\n+  StrCpy $4 \\\"$$4\\\"\\n+  StrCpy $5 \\\"$$5\\\"\\n+  StrCpy $6 \\\"$$6\\\"\\n+  StrCpy $7 \\\"$$7\\\"\\n+  StrCpy $8 \\\"$$8\\\"\\n+  StrCpy $9 \\\"$$9\\\"\\n+  StrCpy $R0 \\\"$$R0\\\"\\n+  StrCpy $R1 \\\"$$R1\\\"\\n+  StrCpy $R2 \\\"$$R2\\\"\\n+  StrCpy $R3 \\\"$$R3\\\"\\n+  StrCpy $R4 \\\"$$R4\\\"\\n+  StrCpy $R5 \\\"$$R5\\\"\\n+  StrCpy $R6 \\\"$$R6\\\"\\n+  StrCpy $R7 \\\"$$R7\\\"\\n+  StrCpy $R8 \\\"$$R8\\\"\\n+  StrCpy $R9 \\\"$$R9\\\"\\n+!macroend\\n+!define debugSetRegisters \\\"!insertmacro debugSetRegisters\\\"\\n+\\n+/**\\n+ * Displays all register values to assist with verifying that a macro doesn't\\n+ * overwrite any registers.\\n+ */\\n+!macro debugDisplayRegisters\\n+  MessageBox MB_OK \\\\\\n+      \\\"Register Values:$\\\\n\\\\\\n+       $$0 = $0$\\\\n$$1 = $1$\\\\n$$2 = $2$\\\\n$$3 = $3$\\\\n$$4 = $4$\\\\n\\\\\\n+       $$5 = $5$\\\\n$$6 = $6$\\\\n$$7 = $7$\\\\n$$8 = $8$\\\\n$$9 = $9$\\\\n\\\\\\n+       $$R0 = $R0$\\\\n$$R1 = $R1$\\\\n$$R2 = $R2$\\\\n$$R3 = $R3$\\\\n$$R4 = $R4$\\\\n\\\\\\n+       $$R5 = $R5$\\\\n$$R6 = $R6$\\\\n$$R7 = $R7$\\\\n$$R8 = $R8$\\\\n$$R9 = $R9\\\"\\n+!macroend\\n+!define debugDisplayRegisters \\\"!insertmacro debugDisplayRegisters\\\"\\n+\\n+\\n+################################################################################\\n+# Modern User Interface (MUI) override macros\\n+\\n ; Modified version of the following MUI macros to support Mozilla localization.\\n ; MUI_LANGUAGE\\n ; MUI_LANGUAGEFILE_BEGIN\\n@@ -212,6 +300,10 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n \\n !macroend\\n \\n+\\n+################################################################################\\n+# Macros for creating Install Options ini files\\n+\\n !macro createComponentsINI\\n   WriteINIStr \\\"$PLUGINSDIR\\\\components.ini\\\" \\\"Settings\\\" NumFields \\\"5\\\"\\n \\n@@ -401,6 +493,9 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n   WriteINIStr \\\"$PLUGINSDIR\\\\options.ini\\\" \\\"Field 7\\\" Bottom \\\"117\\\"\\n !macroend\\n \\n+/**\\n+ * DEPRECATED - use GetParent instead.\\n+ */\\n !macro GetParentDir\\n   Exch $R0\\n   Push $R1\\n@@ -427,6 +522,8 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n !define GetParentDir \\\"!insertmacro GetParentDir\\\"\\n \\n /**\\n+ * DEPRECATED - use GetPathFromString and RemoveQuotesFromPath\\n+ *\\n  * Removes quotes and trailing path separator from registry string paths.\\n  * @param   $R0\\n  *          Contains the registry string\\n@@ -463,64 +560,11 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n !macroend\\n !define GetPathFromRegStr \\\"!insertmacro GetPathFromRegStr\\\"\\n \\n-/**\\n- * Attempts to delete a file if it exists. This will fail if the file is in use.\\n- * @param   _FILE\\n- *          The path to the file that is to be deleted.\\n- */\\n-!macro DeleteFile _FILE\\n-  ${If} ${FileExists} \\\"${_FILE}\\\"\\n-    Delete \\\"${_FILE}\\\"\\n-  ${EndIf}\\n-!macroend\\n-!define DeleteFile \\\"!insertmacro DeleteFile\\\"\\n-\\n-/**\\n- * Removes a directory if it exists and is empty.\\n- * @param   _DIR\\n- *          The path to the directory that is to be removed.\\n- */\\n-!macro RemoveDir _DIR\\n-  ${If} ${FileExists} \\\"${_DIR}\\\"\\n-    RmDir \\\"${_DIR}\\\"\\n-  ${EndIf}\\n-!macroend\\n-!define RemoveDir \\\"!insertmacro RemoveDir\\\"\\n-\\n-/**\\n- * Adds a section header to the human readable log.\\n- * @param   _HEADER\\n- *          The header text to write to the log.\\n- */\\n-!macro LogHeader _HEADER\\n-  Call WriteLogSeparator\\n-  FileWrite $fhInstallLog \\\"${_HEADER}\\\"\\n-  Call WriteLogSeparator\\n-!macroend\\n-!define LogHeader \\\"!insertmacro LogHeader\\\"\\n-\\n-/**\\n- * Adds a section message to the human readable log.\\n- * @param   _MSG\\n- *          The message text to write to the log.\\n- */\\n-!macro LogMsg _MSG\\n-  FileWrite $fhInstallLog \\\"  ${_MSG}$\\\\r$\\\\n\\\"\\n-!macroend\\n-!define LogMsg \\\"!insertmacro LogMsg\\\"\\n \\n-/**\\n- * Adds a message to the uninstall log.\\n- * @param   _MSG\\n- *          The message text to write to the log.\\n- */\\n-!macro LogUninstall _MSG\\n-  FileWrite $fhUninstallLog \\\"${_MSG}$\\\\r$\\\\n\\\"\\n-!macroend\\n-!define LogUninstall \\\"!insertmacro LogUninstall\\\"\\n+################################################################################\\n+# Macros for creating Install Options ini files\\n \\n /**\\n- * Common installer macros used by toolkit applications.\\n  * The macros below will automatically prepend un. to the function names when\\n  * they are defined (e.g. !define un.RegCleanMain).\\n  */\\n@@ -544,90 +588,96 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n !macroend\\n \\n /**\\n- * Checks whether we can write to the install directory. If the install\\n- * directory already exists this will attempt to create a temporary file in the\\n- * install directory and then delete it. If it does not exist this will attempt\\n- * to create the directory and then delete it. If we can write to the install\\n- * directory this will return true... if not, this will return false.\\n- *\\n- * IMPORTANT! $R9 will be overwritten by this macro with the return value so\\n- *            protect yourself!\\n+ * Posts WM_QUIT to the application's message window which is found using the\\n+ * message window's class. This macro uses the nsProcess plugin available\\n+ * from http://nsis.sourceforge.net/NsProcess_plugin\\n  *\\n- * @return  _RESULT\\n- *          true if the install directory can be written to otherwise false.\\n+ * @param   _MSG\\n+ *          The message text to display in the message box.\\n+ * @param   _PROMPT\\n+ *          If false don't prompt the user and automatically exit the\\n+ *          application if it is running.\\n  *\\n- * $R7 = temp filename in installation directory returned from GetTempFileName\\n- * $R8 = filehandle to temp file used for writing\\n- * $R9 = _RESULT\\n+ * $R6 = return value for nsProcess::_FindProcess and nsProcess::_KillProcess\\n+ * $R7 = return value from FindWindow\\n+ * $R8 = _PROMPT\\n+ * $R9 = _MSG\\n  */\\n-!macro CanWriteToInstallDir\\n+!macro CloseApp\\n \\n-  !ifndef ${_MOZFUNC_UN}CanWriteToInstallDir\\n+  !ifndef ${_MOZFUNC_UN}CloseApp\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}CanWriteToInstallDir \\\"!insertmacro ${_MOZFUNC_UN}CanWriteToInstallDirCall\\\"\\n+    !define ${_MOZFUNC_UN}CloseApp \\\"!insertmacro ${_MOZFUNC_UN}CloseAppCall\\\"\\n \\n-    Function ${_MOZFUNC_UN}CanWriteToInstallDir\\n-      Push $R8\\n+    Function ${_MOZFUNC_UN}CloseApp\\n+      Exch $R9\\n+      Exch 1\\n+      Exch $R8\\n       Push $R7\\n+      Push $R6\\n \\n-      StrCpy $R9 \\\"true\\\"\\n-      IfFileExists \\\"$INSTDIR\\\" 0 checkCreateDir\\n-      GetTempFileName $R7 \\\"$INSTDIR\\\"\\n-      FileOpen $R8 $R7 w\\n-      FileWrite $R8 \\\"Write Access Test\\\"\\n-      FileClose $R8\\n-      IfFileExists \\\"$R7\\\" +3 0\\n-      StrCpy $R9 \\\"false\\\"\\n-      GoTo end\\n+      loop:\\n+      Push $R6\\n+      nsProcess::_FindProcess /NOUNLOAD \\\"${FileMainEXE}\\\"\\n+      Pop $R6\\n+      StrCmp $R6 0 +1 end\\n \\n-      Delete $R7\\n-      GoTo end\\n+      StrCmp $R8 \\\"false\\\" +2 +1\\n+      MessageBox MB_OKCANCEL|MB_ICONQUESTION \\\"$R9\\\" IDCANCEL exit 0\\n \\n-      checkCreateDir:\\n-      CreateDirectory \\\"$INSTDIR\\\"\\n-      IfFileExists \\\"$INSTDIR\\\" +3 0\\n-      StrCpy $R9 \\\"false\\\"\\n-      GoTo end\\n+      FindWindow $R7 \\\"${WindowClass}\\\"\\n+      IntCmp $R7 0 +4 +1 +1\\n+      System::Call 'user32::PostMessage(i r17, i ${WM_QUIT}, i 0, i 0)'\\n+      # The amount of time to wait for the app to shutdown before prompting again\\n+      Sleep 5000\\n \\n-      RmDir \\\"$INSTDIR\\\"\\n+      Push $R6\\n+      nsProcess::_FindProcess /NOUNLOAD \\\"${FileMainEXE}\\\"\\n+      Pop $R6\\n+      StrCmp $R6 0 +1 end\\n+      Push $R6\\n+      nsProcess::_KillProcess /NOUNLOAD \\\"${FileMainEXE}\\\"\\n+      Pop $R6\\n+      Sleep 2000\\n+\\n+      Goto loop\\n+\\n+      exit:\\n+      nsProcess::_Unload\\n+      Quit\\n \\n       end:\\n-      ClearErrors\\n+      nsProcess::_Unload\\n \\n+      Pop $R6\\n       Pop $R7\\n-      Pop $R8\\n-      Push $R9\\n+      Exch $R8\\n+      Exch 1\\n+      Exch $R9\\n     FunctionEnd\\n \\n     !verbose pop\\n   !endif\\n !macroend\\n \\n-!macro CanWriteToInstallDirCall _RESULT\\n-  !verbose push\\n-  !verbose ${_MOZFUNC_VERBOSE}\\n-  Call CanWriteToInstallDir\\n-  Pop ${_RESULT}\\n-  !verbose pop\\n-!macroend\\n-\\n-!macro un.CanWriteToInstallDirCall _RESULT\\n+!macro CloseAppCall _MSG _PROMPT\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Call un.CanWriteToInstallDir\\n-  Pop ${_RESULT}\\n+  Push \\\"${_MSG}\\\"\\n+  Push \\\"${_PROMPT}\\\"\\n+  Call CloseApp\\n   !verbose pop\\n !macroend\\n \\n-!macro un.CanWriteToInstallDir\\n-  !ifndef un.CanWriteToInstallDir\\n+!macro un.CloseApp\\n+  !ifndef un.CloseApp\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN \\\"un.\\\"\\n \\n-    !insertmacro CanWriteToInstallDir\\n+    !insertmacro CloseApp\\n \\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN\\n@@ -635,113 +685,120 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n   !endif\\n !macroend\\n \\n+!macro un.CloseAppCall _MSG _PROMPT\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Push \\\"${_MSG}\\\"\\n+  Push \\\"${_PROMPT}\\\"\\n+  Call un.CloseApp\\n+  !verbose pop\\n+!macroend\\n+\\n+\\n+################################################################################\\n+# Macros for working with the registry\\n+\\n /**\\n- * Checks whether there is sufficient free space available on the installation\\n- * directory's drive. If there is sufficient free space this will return true...\\n- * if not, this will return false. This will only calculate the size of the\\n- * first three sections.\\n+ * Writes a registry string using SHCTX and the supplied params and logs the\\n+ * action to the install log and the uninstall log if _LOG_UNINSTALL equals 1.\\n  *\\n- * IMPORTANT! $R9 will be overwritten by this macro with the return value so\\n- *            protect yourself!\\n+ * Define NO_LOG to prevent all logging when calling this from the uninstaller.\\n  *\\n- * @return  _RESULT\\n- *          true if there is sufficient free space otherwise false.\\n+ * @param   _ROOT\\n+ *          The registry key root as defined by NSIS (e.g. HKLM, HKCU, etc.).\\n+ *          This will only be used for logging.\\n+ * @param   _KEY\\n+ *          The subkey in relation to the key root.\\n+ * @param   _NAME\\n+ *          The key value name to write to.\\n+ * @param   _STR\\n+ *          The string to write to the key value name.\\n+ * @param   _LOG_UNINSTALL\\n+ *          0 = don't add to uninstall log, 1 = add to uninstall log.\\n  *\\n- * $R2 = return value from greater than comparison (0=false 1=true)\\n- * $R3 = free space for the install directory's drive\\n- * $R4 = install directory root\\n- * $R5 = value returned from SectionGetSize\\n- * $R6 = value returned from 'and' comparison of SectionGetFlags (1=selected)\\n- * $R7 = value returned from SectionGetFlags\\n- * $R8 = size in KB required for this installation\\n- * $R9 = _RESULT\\n+ * $R5 = _ROOT\\n+ * $R6 = _KEY\\n+ * $R7 = _NAME\\n+ * $R8 = _STR\\n+ * $R9 = _LOG_UNINSTALL\\n  */\\n-!macro CheckDiskSpace\\n-\\n-  !insertmacro ${_MOZFUNC_UN}GetRoot\\n-  !insertmacro ${_MOZFUNC_UN}DriveSpace\\n+!macro WriteRegStr2\\n \\n-  !ifndef ${_MOZFUNC_UN}CheckDiskSpace\\n+  !ifndef ${_MOZFUNC_UN}WriteRegStr2\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}CheckDiskSpace \\\"!insertmacro ${_MOZFUNC_UN}CheckDiskSpaceCall\\\"\\n-\\n-    Function ${_MOZFUNC_UN}CheckDiskSpace\\n-      Push $R8\\n-      Push $R7\\n-      Push $R6\\n-      Push $R5\\n-      Push $R4\\n-      Push $R3\\n-      Push $R2\\n-\\n-      StrCpy $R9 \\\"true\\\"\\n-      SectionGetSize 0 $R8\\n+    !define ${_MOZFUNC_UN}WriteRegStr2 \\\"!insertmacro ${_MOZFUNC_UN}WriteRegStr2Call\\\"\\n \\n-      SectionGetFlags 1 $R7\\n-      IntOp $R6 ${SF_SELECTED} & $R7\\n-      IntCmp $R6 0 +3 0\\n-      SectionGetSize 1 $R5\\n-      IntOp $R8 $R8 + $R5\\n-\\n-      SectionGetFlags 2 $R7\\n-      IntOp $R6 ${SF_SELECTED} & $R7\\n-      IntCmp $R6 0 +3 0\\n-      SectionGetSize 2 $R5\\n-      IntOp $R8 $R8 + $R5\\n-\\n-      ${${_MOZFUNC_UN}GetRoot} \\\"$INSTDIR\\\" $R4\\n-      ${${_MOZFUNC_UN}DriveSpace} \\\"$R4\\\" \\\"/D=F /S=K\\\" $R3\\n-\\n-      System::Int64Op $R3 > $R8\\n-      Pop $R2\\n-\\n-      IntCmp $R2 1 end\\n-      StrCpy $R9 \\\"false\\\"\\n+    Function ${_MOZFUNC_UN}WriteRegStr2\\n+      Exch $R9\\n+      Exch 1\\n+      Exch $R8\\n+      Exch 2\\n+      Exch $R7\\n+      Exch 3\\n+      Exch $R6\\n+      Exch 4\\n+      Exch $R5\\n \\n-      end:\\n       ClearErrors\\n+      WriteRegStr SHCTX \\\"$R6\\\" \\\"$R7\\\" \\\"$R8\\\"\\n \\n-      Pop $R2\\n-      Pop $R3\\n-      Pop $R4\\n-      Pop $R5\\n-      Pop $R6\\n-      Pop $R7\\n-      Pop $R8\\n-      Push $R9\\n+      !ifndef NO_LOG\\n+        IfErrors 0 +3\\n+        FileWrite $fhInstallLog \\\"  ** ERROR Adding Registry String: $R5 | $R6 | $R7 | $R8 **$\\\\r$\\\\n\\\"\\n+        GoTo +4\\n+        StrCmp \\\"$R9\\\" \\\"1\\\" +1 +2\\n+        FileWrite $fhUninstallLog \\\"RegVal: $R5 | $R6 | $R7$\\\\r$\\\\n\\\"\\n+        FileWrite $fhInstallLog \\\"  Added Registry String: $R5 | $R6 | $R7 | $R8$\\\\r$\\\\n\\\"\\n+      !endif\\n+\\n+      Exch $R5\\n+      Exch 4\\n+      Exch $R6\\n+      Exch 3\\n+      Exch $R7\\n+      Exch 2\\n+      Exch $R8\\n+      Exch 1\\n+      Exch $R9\\n     FunctionEnd\\n \\n     !verbose pop\\n   !endif\\n !macroend\\n \\n-!macro CheckDiskSpaceCall _RESULT\\n+!macro WriteRegStr2Call _ROOT _KEY _NAME _STR _LOG_UNINSTALL\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Call CheckDiskSpace\\n-  Pop ${_RESULT}\\n+  Push \\\"${_ROOT}\\\"\\n+  Push \\\"${_KEY}\\\"\\n+  Push \\\"${_NAME}\\\"\\n+  Push \\\"${_STR}\\\"\\n+  Push \\\"${_LOG_UNINSTALL}\\\"\\n+  Call WriteRegStr2\\n   !verbose pop\\n !macroend\\n \\n-!macro un.CheckDiskSpaceCall _RESULT\\n+!macro un.WriteRegStr2Call _ROOT _KEY _NAME _STR _LOG_UNINSTALL\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Call un.CheckDiskSpace\\n-  Pop ${_RESULT}\\n+  Push \\\"${_ROOT}\\\"\\n+  Push \\\"${_KEY}\\\"\\n+  Push \\\"${_NAME}\\\"\\n+  Push \\\"${_STR}\\\"\\n+  Push \\\"${_LOG_UNINSTALL}\\\"\\n+  Call un.WriteRegStr2\\n   !verbose pop\\n !macroend\\n \\n-!macro un.CheckDiskSpace\\n-  !ifndef un.CheckDiskSpace\\n+!macro un.WriteRegStr2\\n+  !ifndef un.WriteRegStr2\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN \\\"un.\\\"\\n \\n-    !insertmacro GetRoot\\n-    !insertmacro DriveSpace\\n-    !insertmacro CheckDiskSpace\\n+    !insertmacro WriteRegStr2\\n \\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN\\n@@ -750,113 +807,67 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n !macroend\\n \\n /**\\n- * Removes registry keys that reference this install location and for paths that\\n- * no longer exist. This uses SHCTX to determine the registry hive so you must\\n- * call SetShellVarContext first.\\n+ * Writes a registry dword using SHCTX and the supplied params and logs the\\n+ * action to the install log and the uninstall log if _LOG_UNINSTALL equals 1.\\n  *\\n- * @param   _KEY\\n- *          The registry subkey (typically this will be Software\\\\Mozilla).\\n+ * Define NO_LOG to prevent all logging when calling this from the uninstaller.\\n  *\\n- * XXXrstrong - there is the potential for Key: Software/Mozilla/AppName,\\n- * ValueName: CurrentVersion, ValueData: AppVersion to reference a key that is\\n- * no longer available due to this cleanup. This should be no worse than prior\\n- * to this reg cleanup since the referenced key would be for an app that is no\\n- * longer installed on the system.\\n+ * @param   _ROOT\\n+ *          The registry key root as defined by NSIS (e.g. HKLM, HKCU, etc.).\\n+ *          This will only be used for logging.\\n+ * @param   _KEY\\n+ *          The subkey in relation to the key root.\\n+ * @param   _NAME\\n+ *          The key value name to write to.\\n+ * @param   _DWORD\\n+ *          The dword to write to the key value name.\\n+ * @param   _LOG_UNINSTALL\\n+ *          0 = don't add to uninstall log, 1 = add to uninstall log.\\n  *\\n- * $R1 = stores the long path to $INSTDIR\\n- * $R2 = value returned from the stack from the GetParent and GetLongPath macros\\n- * $R3 = value returned from the outer loop's EnumRegKey\\n- * $R4 = value returned from the inner loop's EnumRegKey\\n- * $R5 = value returned from ReadRegStr\\n- * $R6 = counter for the outer loop's EnumRegKey\\n- * $R7 = counter for the inner loop's EnumRegKey\\n- * $R8 = value returned from the stack from the RemoveQuotesFromPath macro\\n- * $R9 = _KEY\\n+ * $R5 = _ROOT\\n+ * $R6 = _KEY\\n+ * $R7 = _NAME\\n+ * $R8 = _DWORD\\n+ * $R9 = _LOG_UNINSTALL\\n  */\\n-!macro RegCleanMain\\n-\\n-  !insertmacro ${_MOZFUNC_UN}GetLongPath\\n-  !insertmacro ${_MOZFUNC_UN}GetParent\\n-  !insertmacro ${_MOZFUNC_UN}RemoveQuotesFromPath\\n+!macro WriteRegDWORD2\\n \\n-  !ifndef ${_MOZFUNC_UN}RegCleanMain\\n+  !ifndef ${_MOZFUNC_UN}WriteRegDWORD2\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}RegCleanMain \\\"!insertmacro ${_MOZFUNC_UN}RegCleanMainCall\\\"\\n+    !define ${_MOZFUNC_UN}WriteRegDWORD2 \\\"!insertmacro ${_MOZFUNC_UN}WriteRegDWORD2Call\\\"\\n \\n-    Function ${_MOZFUNC_UN}RegCleanMain\\n+    Function ${_MOZFUNC_UN}WriteRegDWORD2\\n       Exch $R9\\n-      Push $R8\\n-      Push $R7\\n-      Push $R6\\n-      Push $R5\\n-      Push $R4\\n-      Push $R3\\n-      Push $R2\\n-      Push $R1\\n-\\n-      ${${_MOZFUNC_UN}GetLongPath} \\\"$INSTDIR\\\" $R1\\n-      StrCpy $R6 0  ; set the counter for the outer loop to 0\\n-\\n-      outerloop:\\n-      EnumRegKey $R3 SHCTX $R9 $R6\\n-      StrCmp $R3 \\\"\\\" end  ; if empty there are no more keys to enumerate\\n-      IntOp $R6 $R6 + 1  ; increment the outer loop's counter\\n-      ClearErrors\\n-      ReadRegStr $R5 SHCTX \\\"$R9\\\\$R3\\\\bin\\\" \\\"PathToExe\\\"\\n-      IfErrors 0 outercontinue\\n-      StrCpy $R7 0  ; set the counter for the inner loop to 0\\n-\\n-      innerloop:\\n-      EnumRegKey $R4 SHCTX \\\"$R9\\\\$R3\\\" $R7\\n-      StrCmp $R4 \\\"\\\" outerloop  ; if empty there are no more keys to enumerate\\n-      IntOp $R7 $R7 + 1  ; increment the inner loop's counter\\n-      ClearErrors\\n-      ReadRegStr $R5 SHCTX \\\"$R9\\\\$R3\\\\$R4\\\\Main\\\" \\\"PathToExe\\\"\\n-      IfErrors innerloop\\n-\\n-      ${${_MOZFUNC_UN}RemoveQuotesFromPath} \\\"$R5\\\" $R8\\n-\\n-      IfFileExists \\\"$R8\\\" +1 +4\\n-      ${${_MOZFUNC_UN}GetParent} \\\"$R8\\\" $R2\\n-      ${${_MOZFUNC_UN}GetLongPath} \\\"$R2\\\" $R2\\n-      StrCmp \\\"$R2\\\" \\\"$R1\\\" +1 innerloop\\n-\\n-      ClearErrors\\n-      DeleteRegKey SHCTX \\\"$R9\\\\$R3\\\\$R4\\\"\\n-      IfErrors innerloop\\n-      IntOp $R7 $R7 - 1 ; decrement the inner loop's counter when the key is deleted successfully.\\n-      ClearErrors\\n-      DeleteRegKey /ifempty SHCTX \\\"$R9\\\\$R3\\\"\\n-      IfErrors innerloop outerdecrement\\n-\\n-      outercontinue:\\n-      ${${_MOZFUNC_UN}RemoveQuotesFromPath} \\\"$R5\\\" $R8\\n-\\n-      IfFileExists \\\"$R8\\\" 0 +4\\n-      ${${_MOZFUNC_UN}GetParent} \\\"$R8\\\" $R2\\n-      ${${_MOZFUNC_UN}GetLongPath} \\\"$R2\\\" $R2\\n-      StrCmp \\\"$R2\\\" \\\"$R1\\\" 0 outerloop\\n+      Exch 1\\n+      Exch $R8\\n+      Exch 2\\n+      Exch $R7\\n+      Exch 3\\n+      Exch $R6\\n+      Exch 4\\n+      Exch $R5\\n \\n       ClearErrors\\n-      DeleteRegKey SHCTX \\\"$R9\\\\$R3\\\"\\n-      IfErrors outerloop\\n-\\n-      outerdecrement:\\n-      IntOp $R6 $R6 - 1 ; decrement the outer loop's counter when the key is deleted successfully.\\n-      GoTo outerloop\\n+      WriteRegDWORD SHCTX \\\"$R6\\\" \\\"$R7\\\" \\\"$R8\\\"\\n \\n-      end:\\n-      ClearErrors\\n+      !ifndef NO_LOG\\n+        IfErrors 0 +3\\n+        FileWrite $fhInstallLog \\\"  ** ERROR Adding Registry DWord: $R5 | $R6 | $R7 | $R8 **$\\\\r$\\\\n\\\"\\n+        GoTo +4\\n+        StrCmp \\\"$R9\\\" \\\"1\\\" +1 +2\\n+        FileWrite $fhUninstallLog \\\"RegVal: $R5 | $R6 | $R7$\\\\r$\\\\n\\\"\\n+        FileWrite $fhInstallLog \\\"  Added Registry DWord: $R5 | $R6 | $R7 | $R8$\\\\r$\\\\n\\\"\\n+      !endif\\n \\n-      Pop $R1\\n-      Pop $R2\\n-      Pop $R3\\n-      Pop $R4\\n-      Pop $R5\\n-      Pop $R6\\n-      Pop $R7\\n-      Pop $R8\\n+      Exch $R5\\n+      Exch 4\\n+      Exch $R6\\n+      Exch 3\\n+      Exch $R7\\n+      Exch 2\\n+      Exch $R8\\n+      Exch 1\\n       Exch $R9\\n     FunctionEnd\\n \\n@@ -864,33 +875,38 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n   !endif\\n !macroend\\n \\n-!macro RegCleanMainCall _KEY\\n+!macro WriteRegDWORD2Call _ROOT _KEY _NAME _DWORD _LOG_UNINSTALL\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n+  Push \\\"${_ROOT}\\\"\\n   Push \\\"${_KEY}\\\"\\n-  Call RegCleanMain\\n+  Push \\\"${_NAME}\\\"\\n+  Push \\\"${_DWORD}\\\"\\n+  Push \\\"${_LOG_UNINSTALL}\\\"\\n+  Call WriteRegDWORD2\\n   !verbose pop\\n !macroend\\n \\n-!macro un.RegCleanMainCall _KEY\\n+!macro un.WriteRegDWORD2Call _ROOT _KEY _NAME _DWORD _LOG_UNINSTALL\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n+  Push \\\"${_ROOT}\\\"\\n   Push \\\"${_KEY}\\\"\\n-  Call un.RegCleanMain\\n+  Push \\\"${_NAME}\\\"\\n+  Push \\\"${_DWORD}\\\"\\n+  Push \\\"${_LOG_UNINSTALL}\\\"\\n+  Call un.WriteRegDWORD2\\n   !verbose pop\\n !macroend\\n \\n-!macro un.RegCleanMain\\n-  !ifndef un.RegCleanMain\\n+!macro un.WriteRegDWORD2\\n+  !ifndef un.WriteRegDWORD2\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN \\\"un.\\\"\\n \\n-    !insertmacro GetLongPath\\n-    !insertmacro GetParent\\n-    !insertmacro RemoveQuotesFromPath\\n-    !insertmacro RegCleanMain\\n+    !insertmacro WriteRegDWORD2\\n \\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN\\n@@ -899,94 +915,106 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n !macroend\\n \\n /**\\n- * Removes all registry keys from HKLM\\\\Software\\\\Windows\\\\CurrentVersion\\\\Uninstall\\n- * that reference this install location.\\n+ * Writes a registry string to HKCR using the supplied params and logs the\\n+ * action to the install log and the uninstall log if _LOG_UNINSTALL equals 1.\\n  *\\n- * $R4 = stores the long path to $INSTDIR\\n- * $R5 = value returned from ReadRegStr\\n- * $R6 = string for the base reg key (e.g. Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall)\\n- * $R7 = value returned from the EnumRegKey\\n- * $R8 = counter for the EnumRegKey\\n- * $R9 = value returned from the stack from the RemoveQuotesFromPath and GetLongPath macros\\n+ * Define NO_LOG to prevent all logging when calling this from the uninstaller.\\n+ *\\n+ * @param   _ROOT\\n+ *          The registry key root as defined by NSIS (e.g. HKLM, HKCU, etc.).\\n+ *          This will only be used for logging.\\n+ * @param   _KEY\\n+ *          The subkey in relation to the key root.\\n+ * @param   _NAME\\n+ *          The key value name to write to.\\n+ * @param   _STR\\n+ *          The string to write to the key value name.\\n+ * @param   _LOG_UNINSTALL\\n+ *          0 = don't add to uninstall log, 1 = add to uninstall log.\\n+ *\\n+ * $R5 = _ROOT\\n+ * $R6 = _KEY\\n+ * $R7 = _NAME\\n+ * $R8 = _STR\\n+ * $R9 = _LOG_UNINSTALL\\n  */\\n-!macro RegCleanUninstall\\n-\\n-  !insertmacro ${_MOZFUNC_UN}GetLongPath\\n-  !insertmacro ${_MOZFUNC_UN}RemoveQuotesFromPath\\n+!macro WriteRegStrHKCR\\n \\n-  !ifndef ${_MOZFUNC_UN}RegCleanUninstall\\n+  !ifndef ${_MOZFUNC_UN}WriteRegStrHKCR\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}RegCleanUninstall \\\"!insertmacro ${_MOZFUNC_UN}RegCleanUninstallCall\\\"\\n-\\n-    Function ${_MOZFUNC_UN}RegCleanUninstall\\n-      Push $R9\\n-      Push $R8\\n-      Push $R7\\n-      Push $R6\\n-      Push $R5\\n-      Push $R4\\n-\\n-      ${${_MOZFUNC_UN}GetLongPath} \\\"$INSTDIR\\\" $R4\\n-      StrCpy $R6 \\\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\\\"\\n-      StrCpy $R7 \\\"\\\"\\n-      StrCpy $R8 0\\n+    !define ${_MOZFUNC_UN}WriteRegStrHKCR \\\"!insertmacro ${_MOZFUNC_UN}WriteRegStrHKCRCall\\\"\\n \\n-      loop:\\n-      EnumRegKey $R7 HKLM $R6 $R8\\n-      StrCmp $R7 \\\"\\\" end\\n-      IntOp $R8 $R8 + 1 ; Increment the counter\\n-      ClearErrors\\n-      ReadRegStr $R5 HKLM \\\"$R6\\\\$R7\\\" \\\"InstallLocation\\\"\\n-      IfErrors loop\\n-      ${${_MOZFUNC_UN}RemoveQuotesFromPath} \\\"$R5\\\" $R9\\n-      ${${_MOZFUNC_UN}GetLongPath} \\\"$R9\\\" $R9\\n-      StrCmp \\\"$R9\\\" \\\"$R4\\\" 0 loop\\n-      ClearErrors\\n-      DeleteRegKey HKLM \\\"$R6\\\\$R7\\\"\\n-      IfErrors loop\\n-      IntOp $R8 $R8 - 1 ; Decrement the counter on successful deletion\\n-      GoTo loop\\n+    Function ${_MOZFUNC_UN}WriteRegStrHKCR\\n+      Exch $R9\\n+      Exch 1\\n+      Exch $R8\\n+      Exch 2\\n+      Exch $R7\\n+      Exch 3\\n+      Exch $R6\\n+      Exch 4\\n+      Exch $R5\\n \\n-      end:\\n       ClearErrors\\n+      WriteRegStr HKCR \\\"$R6\\\" \\\"$R7\\\" \\\"$R8\\\"\\n \\n-      Pop $R4\\n-      Pop $R5\\n-      Pop $R6\\n-      Pop $R7\\n-      Pop $R8\\n-      Pop $R9\\n+      !ifndef NO_LOG\\n+        IfErrors 0 +3\\n+        FileWrite $fhInstallLog \\\"  ** ERROR Adding Registry String: $R5 | $R6 | $R7 | $R8 **$\\\\r$\\\\n\\\"\\n+        GoTo +4\\n+        StrCmp \\\"$R9\\\" \\\"1\\\" +1 +2\\n+        FileWrite $fhUninstallLog \\\"RegVal: $R5 | $R6 | $R7$\\\\r$\\\\n\\\"\\n+        FileWrite $fhInstallLog \\\"  Added Registry String: $R5 | $R6 | $R7 | $R8$\\\\r$\\\\n\\\"\\n+      !endif\\n+\\n+      Exch $R5\\n+      Exch 4\\n+      Exch $R6\\n+      Exch 3\\n+      Exch $R7\\n+      Exch 2\\n+      Exch $R8\\n+      Exch 1\\n+      Exch $R9\\n     FunctionEnd\\n \\n     !verbose pop\\n   !endif\\n !macroend\\n \\n-!macro RegCleanUninstallCall\\n+!macro WriteRegStrHKCRCall _ROOT _KEY _NAME _STR _LOG_UNINSTALL\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Call RegCleanUninstall\\n+  Push \\\"${_ROOT}\\\"\\n+  Push \\\"${_KEY}\\\"\\n+  Push \\\"${_NAME}\\\"\\n+  Push \\\"${_STR}\\\"\\n+  Push \\\"${_LOG_UNINSTALL}\\\"\\n+  Call WriteRegStrHKCR\\n   !verbose pop\\n !macroend\\n \\n-!macro un.RegCleanUninstallCall\\n+!macro un.WriteRegStrHKCRCall _ROOT _KEY _NAME _STR _LOG_UNINSTALL\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Call un.RegCleanUninstall\\n+  Push \\\"${_ROOT}\\\"\\n+  Push \\\"${_KEY}\\\"\\n+  Push \\\"${_NAME}\\\"\\n+  Push \\\"${_STR}\\\"\\n+  Push \\\"${_LOG_UNINSTALL}\\\"\\n+  Call un.WriteRegStrHKCR\\n   !verbose pop\\n !macroend\\n \\n-!macro un.RegCleanUninstall\\n-  !ifndef un.RegCleanUninstall\\n+!macro un.WriteRegStrHKCR\\n+  !ifndef un.WriteRegStrHKCR\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN \\\"un.\\\"\\n \\n-    !insertmacro GetLongPath\\n-    !insertmacro RemoveQuotesFromPath\\n-    !insertmacro RegCleanUninstall\\n+    !insertmacro WriteRegStrHKCR\\n \\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN\\n@@ -995,170 +1023,80 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n !macroend\\n \\n /**\\n- * Posts WM_QUIT to the application's message window which is found using the\\n- * message window's class. This macro uses the nsProcess plugin available\\n- * from http://nsis.sourceforge.net/NsProcess_plugin\\n- *\\n- * @param   _MSG\\n- *          The message text to display in the message box.\\n- * @param   _PROMPT\\n- *          If false don't prompt the user and automatically exit the\\n- *          application if it is running.\\n- *\\n- * $R6 = return value for nsProcess::_FindProcess and nsProcess::_KillProcess\\n- * $R7 = value returned from FindWindow\\n- * $R8 = _PROMPT\\n- * $R9 = _MSG\\n+ * Creates a registry key. NSIS doesn't supply a RegCreateKey method and instead\\n+ * will auto create keys when a reg key name value pair is set.\\n+ * i - int (includes char, byte, short, handles, pointers and so on)\\n+ * t - text, string (LPCSTR, pointer to first character)\\n+ * * - pointer specifier -> the proc needs the pointer to type, affects next\\n+ *     char (parameter) [ex: '*i' - pointer to int]\\n+ * see the NSIS documentation for additional information.\\n  */\\n-!macro CloseApp\\n-\\n-  !ifndef ${_MOZFUNC_UN}CloseApp\\n-    !verbose push\\n-    !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}CloseApp \\\"!insertmacro ${_MOZFUNC_UN}CloseAppCall\\\"\\n-\\n-    Function ${_MOZFUNC_UN}CloseApp\\n-      Exch $R9\\n-      Exch 1\\n-      Exch $R8\\n-      Push $R7\\n-      Push $R6\\n-\\n-      loop:\\n-      Push $R6\\n-      nsProcess::_FindProcess /NOUNLOAD \\\"${FileMainEXE}\\\"\\n-      Pop $R6\\n-      StrCmp $R6 0 0 end\\n-\\n-      StrCmp $R8 \\\"false\\\" +2 0\\n-      MessageBox MB_OKCANCEL|MB_ICONQUESTION \\\"$R9\\\" IDCANCEL exit 0\\n-\\n-      FindWindow $R7 \\\"${WindowClass}\\\"\\n-      IntCmp $R7 0 +4\\n-      System::Call 'user32::PostMessage(i r17, i ${WM_QUIT}, i 0, i 0)'\\n-      # The amount of time to wait for the app to shutdown before prompting again\\n-      Sleep 5000\\n-\\n-      Push $R6\\n-      nsProcess::_FindProcess /NOUNLOAD \\\"${FileMainEXE}\\\"\\n-      Pop $R6\\n-      StrCmp $R6 0 0 end\\n-      Push $R6\\n-      nsProcess::_KillProcess /NOUNLOAD \\\"${FileMainEXE}\\\"\\n-      Pop $R6\\n-      Sleep 2000\\n-\\n-      Goto loop\\n-\\n-      exit:\\n-      nsProcess::_Unload\\n-      Quit\\n-\\n-      end:\\n-      nsProcess::_Unload\\n-\\n-      Pop $R6\\n-      Pop $R7\\n-      Exch $R8\\n-      Exch 1\\n-      Exch $R9\\n-    FunctionEnd\\n-\\n-    !verbose pop\\n-  !endif\\n-!macroend\\n-\\n-!macro CloseAppCall _MSG _PROMPT\\n-  !verbose push\\n-  !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_MSG}\\\"\\n-  Push \\\"${_PROMPT}\\\"\\n-  Call CloseApp\\n-  !verbose pop\\n-!macroend\\n-\\n-!macro un.CloseApp\\n-  !ifndef un.CloseApp\\n-    !verbose push\\n-    !verbose ${_MOZFUNC_VERBOSE}\\n-    !undef _MOZFUNC_UN\\n-    !define _MOZFUNC_UN \\\"un.\\\"\\n-\\n-    !insertmacro CloseApp\\n-\\n-    !undef _MOZFUNC_UN\\n-    !define _MOZFUNC_UN\\n-    !verbose pop\\n-  !endif\\n-!macroend\\n-\\n-!macro un.CloseAppCall _MSG _PROMPT\\n-  !verbose push\\n-  !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_MSG}\\\"\\n-  Push \\\"${_PROMPT}\\\"\\n-  Call un.CloseApp\\n-  !verbose pop\\n-!macroend\\n+!define RegCreateKey \\\"Advapi32::RegCreateKeyA(i, t, *i) i\\\"\\n \\n /**\\n- * Writes a registry string using SHCTX and the supplied params and logs the\\n- * action to the install log and the uninstall log if _LOG_UNINSTALL equals 1.\\n+ * Creates a registry key. This will log the actions to the install and\\n+ * uninstall logs. Alternatively you can set a registry value to create the key\\n+ * and then delete the value.\\n  *\\n  * Define NO_LOG to prevent all logging when calling this from the uninstaller.\\n  *\\n  * @param   _ROOT\\n  *          The registry key root as defined by NSIS (e.g. HKLM, HKCU, etc.).\\n- *          This will only be used for logging.\\n  * @param   _KEY\\n  *          The subkey in relation to the key root.\\n- * @param   _NAME\\n- *          The key value name to write to.\\n- * @param   _STR\\n- *          The string to write to the key value name.\\n  * @param   _LOG_UNINSTALL\\n  *          0 = don't add to uninstall log, 1 = add to uninstall log.\\n  *\\n- * $R5 = _ROOT\\n- * $R6 = _KEY\\n- * $R7 = _NAME\\n- * $R8 = _STR\\n+ * $R4 = [out] handle to newly created registry key. If this is not a key\\n+ *       located in one of the predefined registry keys this must be closed\\n+ *       with RegCloseKey (this should not be needed unless someone decides to\\n+ *       do something extremely squirrelly with NSIS).\\n+ * $R5 = return value from RegCreateKeyA (represented by r15 in the system call).\\n+ * $R6 = [in] hKey passed to RegCreateKeyA.\\n+ * $R7 = _ROOT\\n+ * $R8 = _KEY\\n  * $R9 = _LOG_UNINSTALL\\n  */\\n-!macro WriteRegStr2\\n+!macro CreateRegKey\\n \\n-  !ifndef ${_MOZFUNC_UN}WriteRegStr2\\n+  !ifndef ${_MOZFUNC_UN}CreateRegKey\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}WriteRegStr2 \\\"!insertmacro ${_MOZFUNC_UN}WriteRegStr2Call\\\"\\n+    !define ${_MOZFUNC_UN}CreateRegKey \\\"!insertmacro ${_MOZFUNC_UN}CreateRegKeyCall\\\"\\n \\n-    Function ${_MOZFUNC_UN}WriteRegStr2\\n+    Function ${_MOZFUNC_UN}CreateRegKey\\n       Exch $R9\\n       Exch 1\\n       Exch $R8\\n       Exch 2\\n       Exch $R7\\n-      Exch 3\\n-      Exch $R6\\n-      Exch 4\\n-      Exch $R5\\n+      Push $R6\\n+      Push $R5\\n+      Push $R4\\n \\n-      ClearErrors\\n-      WriteRegStr SHCTX \\\"$R6\\\" \\\"$R7\\\" \\\"$R8\\\"\\n+      StrCmp $R7 \\\"HKCR\\\" +1 +2\\n+      StrCpy $R6 \\\"0x80000000\\\"\\n+      StrCmp $R7 \\\"HKCU\\\" +1 +2\\n+      StrCpy $R6 \\\"0x80000001\\\"\\n+      StrCmp $R7 \\\"HKLM\\\" +1 +2\\n+      StrCpy $R6 \\\"0x80000002\\\"\\n \\n-!ifndef NO_LOG\\n-      IfErrors 0 +3\\n-      FileWrite $fhInstallLog \\\"  ** ERROR Adding Registry String: $R5 | $R6 | $R7 | $R8 **$\\\\r$\\\\n\\\"\\n-      GoTo +4\\n-      IntCmp $R9 1 0 +2\\n-      FileWrite $fhUninstallLog \\\"RegVal: $R5 | $R6 | $R7$\\\\r$\\\\n\\\"\\n-      FileWrite $fhInstallLog \\\"  Added Registry String: $R5 | $R6 | $R7 | $R8$\\\\r$\\\\n\\\"\\n-!endif\\n+      ; see definition of RegCreateKey\\n+      System::Call \\\"${RegCreateKey}($R6, '$R8', .r14) .r15\\\"\\n \\n-      Exch $R5\\n-      Exch 4\\n-      Exch $R6\\n-      Exch 3\\n+      !ifndef NO_LOG\\n+        ; if $R5 is not 0 then there was an error creating the registry key.\\n+        IntCmp $R5 0 +3 +3\\n+        FileWrite $fhInstallLog \\\"  ** ERROR Adding Registry Key: $R7 | $R8 **$\\\\r$\\\\n\\\"\\n+        GoTo +4\\n+        StrCmp \\\"$R9\\\" \\\"1\\\" +1 +2\\n+        FileWrite $fhUninstallLog \\\"RegKey: $R7 | $R8$\\\\r$\\\\n\\\"\\n+        FileWrite $fhInstallLog \\\"  Added Registry Key: $R7 | $R8$\\\\r$\\\\n\\\"\\n+      !endif\\n+\\n+      Pop $R4\\n+      Pop $R5\\n+      Pop $R6\\n       Exch $R7\\n       Exch 2\\n       Exch $R8\\n@@ -1170,38 +1108,34 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n   !endif\\n !macroend\\n \\n-!macro WriteRegStr2Call _ROOT _KEY _NAME _STR _LOG_UNINSTALL\\n+!macro CreateRegKeyCall _ROOT _KEY _LOG_UNINSTALL\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n   Push \\\"${_ROOT}\\\"\\n   Push \\\"${_KEY}\\\"\\n-  Push \\\"${_NAME}\\\"\\n-  Push \\\"${_STR}\\\"\\n   Push \\\"${_LOG_UNINSTALL}\\\"\\n-  Call WriteRegStr2\\n+  Call CreateRegKey\\n   !verbose pop\\n !macroend\\n \\n-!macro un.WriteRegStr2Call _ROOT _KEY _NAME _STR _LOG_UNINSTALL\\n+!macro un.CreateRegKeyCall _ROOT _KEY _LOG_UNINSTALL\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n   Push \\\"${_ROOT}\\\"\\n   Push \\\"${_KEY}\\\"\\n-  Push \\\"${_NAME}\\\"\\n-  Push \\\"${_STR}\\\"\\n   Push \\\"${_LOG_UNINSTALL}\\\"\\n-  Call un.WriteRegStr2\\n+  Call un.CreateRegKey\\n   !verbose pop\\n !macroend\\n \\n-!macro un.WriteRegStr2\\n-  !ifndef un.WriteRegStr2\\n+!macro un.CreateRegKey\\n+  !ifndef un.CreateRegKey\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN \\\"un.\\\"\\n \\n-    !insertmacro WriteRegStr2\\n+    !insertmacro CreateRegKey\\n \\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN\\n@@ -1209,38 +1143,41 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n   !endif\\n !macroend\\n \\n+\\n+################################################################################\\n+# Macros for adding file and protocol handlers\\n+\\n /**\\n- * Writes a registry dword using SHCTX and the supplied params and logs the\\n- * action to the install log and the uninstall log if _LOG_UNINSTALL equals 1.\\n- *\\n- * Define NO_LOG to prevent all logging when calling this from the uninstaller.\\n- *\\n- * @param   _ROOT\\n- *          The registry key root as defined by NSIS (e.g. HKLM, HKCU, etc.).\\n- *          This will only be used for logging.\\n+ * Writes common registry values for a handler using SHCTX.\\n  * @param   _KEY\\n  *          The subkey in relation to the key root.\\n- * @param   _NAME\\n- *          The key value name to write to.\\n- * @param   _DWORD\\n- *          The dword to write to the key value name.\\n- * @param   _LOG_UNINSTALL\\n- *          0 = don't add to uninstall log, 1 = add to uninstall log.\\n+ * @param   _VALOPEN\\n+ *          The path and args to launch the application.\\n+ * @param   _VALICON\\n+ *          The path to an exe that contains an icon and the icon resource id.\\n+ * @param   _DISPNAME\\n+ *          The display name for the handler. If emtpy no value will be set.\\n+ * @param   _ISPROTOCOL\\n+ *          Sets protocol handler specific registry values when \\\"true\\\".\\n+ * @param   _ISDDE\\n+ *          Sets DDE specific registry values when \\\"true\\\".\\n  *\\n- * $R5 = _ROOT\\n- * $R6 = _KEY\\n- * $R7 = _NAME\\n- * $R8 = _DWORD\\n- * $R9 = _LOG_UNINSTALL\\n+ * $R3 = string value of the current registry key path.\\n+ * $R4 = _KEY\\n+ * $R5 = _VALOPEN\\n+ * $R6 = _VALICON\\n+ * $R7 = _DISPNAME\\n+ * $R8 = _ISPROTOCOL\\n+ * $R9 = _ISDDE\\n  */\\n-!macro WriteRegDWORD2\\n+!macro AddHandlerValues\\n \\n-  !ifndef ${_MOZFUNC_UN}WriteRegDWORD2\\n+  !ifndef ${_MOZFUNC_UN}AddHandlerValues\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}WriteRegDWORD2 \\\"!insertmacro ${_MOZFUNC_UN}WriteRegDWORD2Call\\\"\\n+    !define ${_MOZFUNC_UN}AddHandlerValues \\\"!insertmacro ${_MOZFUNC_UN}AddHandlerValuesCall\\\"\\n \\n-    Function ${_MOZFUNC_UN}WriteRegDWORD2\\n+    Function ${_MOZFUNC_UN}AddHandlerValues\\n       Exch $R9\\n       Exch 1\\n       Exch $R8\\n@@ -1250,18 +1187,49 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n       Exch $R6\\n       Exch 4\\n       Exch $R5\\n+      Exch 5\\n+      Exch $R4\\n+      Push $R3\\n+\\n+      StrCmp \\\"$R7\\\" \\\"\\\" +6 +1\\n+      ReadRegStr $R3 SHCTX \\\"$R4\\\" \\\"FriendlyTypeName\\\"\\n+\\n+      StrCmp \\\"$R3\\\" \\\"\\\" +1 +3\\n+      WriteRegStr SHCTX \\\"$R4\\\" \\\"\\\" \\\"$R7\\\"\\n+      WriteRegStr SHCTX \\\"$R4\\\" \\\"FriendlyTypeName\\\" \\\"$R7\\\"\\n \\n+      StrCmp \\\"$R8\\\" \\\"true\\\" +1 +8\\n+      WriteRegStr SHCTX \\\"$R4\\\" \\\"URL Protocol\\\" \\\"\\\"\\n+      StrCpy $R3 \\\"\\\"\\n       ClearErrors\\n-      WriteRegDWORD SHCTX \\\"$R6\\\" \\\"$R7\\\" \\\"$R8\\\"\\n-!ifndef NO_LOG\\n-      IfErrors 0 +3\\n-      FileWrite $fhInstallLog \\\"  ** ERROR Adding Registry DWord: $R5 | $R6 | $R7 | $R8 **$\\\\r$\\\\n\\\"\\n-      GoTo +4\\n-      IntCmp $R5 1 0 +2\\n-      FileWrite $fhUninstallLog \\\"RegVal: $R5 | $R6 | $R7$\\\\r$\\\\n\\\"\\n-      FileWrite $fhInstallLog \\\"  Added Registry DWord: $R5 | $R6 | $R7 | $R8$\\\\r$\\\\n\\\"\\n-!endif\\n+      ReadRegDWord $R3 SHCTX \\\"$R4\\\" \\\"EditFlags\\\"\\n+      StrCmp $R3 \\\"\\\" +1 +3  ; Only add EditFlags if a value doesn't exist\\n+      DeleteRegValue SHCTX \\\"$R4\\\" \\\"EditFlags\\\"\\n+      WriteRegDWord SHCTX \\\"$R4\\\" \\\"EditFlags\\\" 0x00000002\\n+      \\n+      StrCmp \\\"$R6\\\" \\\"\\\" +2 +1\\n+      WriteRegStr SHCTX \\\"$R4\\\\DefaultIcon\\\" \\\"\\\" \\\"$R6\\\"\\n+      \\n+      StrCmp \\\"$R5\\\" \\\"\\\" +2 +1\\n+      WriteRegStr SHCTX \\\"$R4\\\\shell\\\\open\\\\command\\\" \\\"\\\" \\\"$R5\\\"      \\n+\\n+      StrCmp \\\"$R9\\\" \\\"true\\\" +1 +11\\n+      WriteRegStr SHCTX \\\"$R4\\\\shell\\\\open\\\\ddeexec\\\" \\\"\\\" \\\"$\\\\\\\"%1$\\\\\\\",,0,0,,,,\\\"\\n+      WriteRegStr SHCTX \\\"$R4\\\\shell\\\\open\\\\ddeexec\\\" \\\"NoActivateHandler\\\" \\\"\\\"\\n+      WriteRegStr SHCTX \\\"$R4\\\\shell\\\\open\\\\ddeexec\\\\Application\\\" \\\"\\\" \\\"${DDEApplication}\\\"\\n+      WriteRegStr SHCTX \\\"$R4\\\\shell\\\\open\\\\ddeexec\\\\Topic\\\" \\\"\\\" \\\"WWW_OpenURL\\\"\\n+      ; The ifexec key may have been added by another application so try to\\n+      ; delete it to prevent it from breaking this app's shell integration.\\n+      ; Also, IE 6 and below doesn't remove this key when it sets itself as the\\n+      ; default handler and if this key exists IE's shell integration breaks.\\n+      DeleteRegKey HKLM \\\"$R4\\\\shell\\\\open\\\\ddeexec\\\\ifexec\\\"\\n+      DeleteRegKey HKCU \\\"$R4\\\\shell\\\\open\\\\ddeexec\\\\ifexec\\\"\\n \\n+      ClearErrors\\n+\\n+      Pop $R3\\n+      Exch $R4\\n+      Exch 5\\n       Exch $R5\\n       Exch 4\\n       Exch $R6\\n@@ -1277,38 +1245,40 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n   !endif\\n !macroend\\n \\n-!macro WriteRegDWORD2Call _ROOT _KEY _NAME _DWORD _LOG_UNINSTALL\\n+!macro AddHandlerValuesCall _KEY _VALOPEN _VALICON _DISPNAME _ISPROTOCOL _ISDDE\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_ROOT}\\\"\\n   Push \\\"${_KEY}\\\"\\n-  Push \\\"${_NAME}\\\"\\n-  Push \\\"${_DWORD}\\\"\\n-  Push \\\"${_LOG_UNINSTALL}\\\"\\n-  Call WriteRegDWORD2\\n+  Push \\\"${_VALOPEN}\\\"\\n+  Push \\\"${_VALICON}\\\"\\n+  Push \\\"${_DISPNAME}\\\"\\n+  Push \\\"${_ISPROTOCOL}\\\"\\n+  Push \\\"${_ISDDE}\\\"\\n+  Call AddHandlerValues\\n   !verbose pop\\n !macroend\\n \\n-!macro un.WriteRegDWORD2Call _ROOT _KEY _NAME _DWORD _LOG_UNINSTALL\\n+!macro un.AddHandlerValuesCall _KEY _VALOPEN _VALICON _DISPNAME _ISPROTOCOL _ISDDE\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_ROOT}\\\"\\n   Push \\\"${_KEY}\\\"\\n-  Push \\\"${_NAME}\\\"\\n-  Push \\\"${_DWORD}\\\"\\n-  Push \\\"${_LOG_UNINSTALL}\\\"\\n-  Call un.WriteRegDWORD2\\n+  Push \\\"${_VALOPEN}\\\"\\n+  Push \\\"${_VALICON}\\\"\\n+  Push \\\"${_DISPNAME}\\\"\\n+  Push \\\"${_ISPROTOCOL}\\\"\\n+  Push \\\"${_ISDDE}\\\"\\n+  Call un.AddHandlerValues\\n   !verbose pop\\n !macroend\\n \\n-!macro un.WriteRegDWORD2\\n-  !ifndef un.WriteRegDWORD2\\n+!macro un.AddHandlerValues\\n+  !ifndef un.AddHandlerValues\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN \\\"un.\\\"\\n \\n-    !insertmacro WriteRegDWORD2\\n+    !insertmacro AddHandlerValues\\n \\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN\\n@@ -1316,68 +1286,85 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n   !endif\\n !macroend\\n \\n+\\n+################################################################################\\n+# Macros for retrieving existing install paths\\n+\\n /**\\n- * Writes a registry string to HKCR using the supplied params and logs the\\n- * action to the install log and the uninstall log if _LOG_UNINSTALL equals 1.\\n- *\\n- * Define NO_LOG to prevent all logging when calling this from the uninstaller.\\n+ * Finds a second installation of the application so we can make informed\\n+ * decisions about registry operations. This uses SHCTX to determine the\\n+ * registry hive so you must call SetShellVarContext first.\\n  *\\n- * @param   _ROOT\\n- *          The registry key root as defined by NSIS (e.g. HKLM, HKCU, etc.).\\n- *          This will only be used for logging.\\n  * @param   _KEY\\n- *          The subkey in relation to the key root.\\n- * @param   _NAME\\n- *          The key value name to write to.\\n- * @param   _STR\\n- *          The string to write to the key value name.\\n- * @param   _LOG_UNINSTALL\\n- *          0 = don't add to uninstall log, 1 = add to uninstall log.\\n+ *          The registry subkey (typically this will be Software\\\\Mozilla).\\n+ * @return  _RESULT\\n+ *          false if a second install isn't found, path to the main exe if a\\n+ *          second install is found.\\n  *\\n- * $R5 = _ROOT\\n- * $R6 = _KEY\\n- * $R7 = _NAME\\n- * $R8 = _STR\\n- * $R9 = _LOG_UNINSTALL\\n+ * $R3 = stores the long path to $INSTDIR\\n+ * $R4 = counter for the outer loop's EnumRegKey\\n+ * $R5 = return value from ReadRegStr and RemoveQuotesFromPath\\n+ * $R6 = return value from GetParent\\n+ * $R7 = return value from the loop's EnumRegKey\\n+ * $R8 = storage for _KEY\\n+ * $R9 = _KEY and _RESULT\\n  */\\n-!macro WriteRegStrHKCR\\n+!macro GetSecondInstallPath\\n+\\n+  !ifndef ${_MOZFUNC_UN}GetSecondInstallPath\\n+    !define _MOZFUNC_UN_TMP ${_MOZFUNC_UN}\\n+    !insertmacro ${_MOZFUNC_UN_TMP}GetLongPath\\n+    !insertmacro ${_MOZFUNC_UN_TMP}GetParent\\n+    !insertmacro ${_MOZFUNC_UN_TMP}RemoveQuotesFromPath\\n+    !undef _MOZFUNC_UN\\n+    !define _MOZFUNC_UN ${_MOZFUNC_UN_TMP}\\n+    !undef _MOZFUNC_UN_TMP\\n \\n-  !ifndef ${_MOZFUNC_UN}WriteRegStrHKCR\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}WriteRegStrHKCR \\\"!insertmacro ${_MOZFUNC_UN}WriteRegStrHKCRCall\\\"\\n+    !define ${_MOZFUNC_UN}GetSecondInstallPath \\\"!insertmacro ${_MOZFUNC_UN}GetSecondInstallPathCall\\\"\\n \\n-    Function ${_MOZFUNC_UN}WriteRegStrHKCR\\n+    Function ${_MOZFUNC_UN}GetSecondInstallPath\\n       Exch $R9\\n-      Exch 1\\n-      Exch $R8\\n-      Exch 2\\n-      Exch $R7\\n-      Exch 3\\n-      Exch $R6\\n-      Exch 4\\n-      Exch $R5\\n+      Push $R8\\n+      Push $R7\\n+      Push $R6\\n+      Push $R5\\n+      Push $R4\\n+      Push $R3\\n+\\n+      ${${_MOZFUNC_UN}GetLongPath} \\\"$INSTDIR\\\" $R3\\n+\\n+      StrCpy $R4 0       ; set the counter for the loop to 0\\n+      StrCpy $R8 \\\"$R9\\\"   ; Registry key path to search\\n+      StrCpy $R9 \\\"false\\\" ; default return value\\n \\n+      loop:\\n+      EnumRegKey $R7 SHCTX $R8 $R4\\n+      StrCmp $R7 \\\"\\\" end +1  ; if empty there are no more keys to enumerate\\n+      IntOp $R4 $R4 + 1     ; increment the loop's counter\\n       ClearErrors\\n-      WriteRegStr HKCR \\\"$R6\\\" \\\"$R7\\\" \\\"$R8\\\"\\n+      ReadRegStr $R5 SHCTX \\\"$R8\\\\$R7\\\\bin\\\" \\\"PathToExe\\\"\\n+      IfErrors loop\\n \\n-!ifndef NO_LOG\\n-      IfErrors 0 +3\\n-      FileWrite $fhInstallLog \\\"  ** ERROR Adding Registry String: $R5 | $R6 | $R7 | $R8 **$\\\\r$\\\\n\\\"\\n-      GoTo +4\\n-      IntCmp $R5 1 0 +2\\n-      FileWrite $fhUninstallLog \\\"RegVal: $R5 | $R6 | $R7$\\\\r$\\\\n\\\"\\n-      FileWrite $fhInstallLog \\\"  Added Registry String: $R5 | $R6 | $R7 | $R8$\\\\r$\\\\n\\\"\\n-!endif\\n+      ${${_MOZFUNC_UN}RemoveQuotesFromPath} \\\"$R5\\\" $R5\\n \\n-      Exch $R5\\n-      Exch 4\\n-      Exch $R6\\n-      Exch 3\\n-      Exch $R7\\n-      Exch 2\\n-      Exch $R8\\n-      Exch 1\\n+      IfFileExists \\\"$R5\\\" +1 loop\\n+      ${${_MOZFUNC_UN}GetLongPath} \\\"$R5\\\" $R5\\n+      ${${_MOZFUNC_UN}GetParent} \\\"$R5\\\" $R6\\n+      StrCmp \\\"$R6\\\" \\\"$R3\\\" loop +1\\n+      StrCmp \\\"$R6\\\\${FileMainEXE}\\\" \\\"$R5\\\" +1 loop\\n+      StrCpy $R9 \\\"$R5\\\"\\n+\\n+      end:\\n+      ClearErrors\\n+\\n+      Pop $R3\\n+      Pop $R4\\n+      Pop $R5\\n+      Pop $R6\\n+      Pop $R7\\n+      Pop $R8\\n       Exch $R9\\n     FunctionEnd\\n \\n@@ -1385,38 +1372,32 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n   !endif\\n !macroend\\n \\n-!macro WriteRegStrHKCRCall _ROOT _KEY _NAME _STR _LOG_UNINSTALL\\n+!macro GetSecondInstallPathCall _KEY _RESULT\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_ROOT}\\\"\\n   Push \\\"${_KEY}\\\"\\n-  Push \\\"${_NAME}\\\"\\n-  Push \\\"${_STR}\\\"\\n-  Push \\\"${_LOG_UNINSTALL}\\\"\\n-  Call WriteRegStrHKCR\\n+  Call GetSecondInstallPath\\n+  Pop ${_RESULT}\\n   !verbose pop\\n !macroend\\n \\n-!macro un.WriteRegStrHKCRCall _ROOT _KEY _NAME _STR _LOG_UNINSTALL\\n+!macro un.GetSecondInstallPathCall _KEY _RESULT\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_ROOT}\\\"\\n   Push \\\"${_KEY}\\\"\\n-  Push \\\"${_NAME}\\\"\\n-  Push \\\"${_STR}\\\"\\n-  Push \\\"${_LOG_UNINSTALL}\\\"\\n-  Call un.WriteRegStrHKCR\\n+  Call un.GetSecondInstallPath\\n+  Pop ${_RESULT}\\n   !verbose pop\\n !macroend\\n \\n-!macro un.WriteRegStrHKCR\\n-  !ifndef un.WriteRegStrHKCR\\n+!macro un.GetSecondInstallPath\\n+  !ifndef un.GetSecondInstallPath\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN \\\"un.\\\"\\n \\n-    !insertmacro WriteRegStrHKCR\\n+    !insertmacro GetSecondInstallPath\\n \\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN\\n@@ -1424,86 +1405,83 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n   !endif\\n !macroend\\n \\n-\\n-/**\\n- * Creates a registry key. NSIS doesn't supply a RegCreateKey method and instead\\n- * will auto create keys when a reg key name value pair is set.\\n- * i - int (includes char, byte, short, handles, pointers and so on)\\n- * t - text, string (LPCSTR, pointer to first character)\\n- * * - pointer specifier -> the proc needs the pointer to type, affects next\\n- *     char (parameter) [ex: '*i' - pointer to int]\\n- * see the NSIS documentation for additional information.\\n- */\\n-!define RegCreateKey \\\"Advapi32::RegCreateKeyA(i, t, *i) i\\\"\\n-\\n /**\\n- * Creates a registry key. This will log the actions to the install and\\n- * uninstall logs. Alternatively you can set a registry value to create the key\\n- * and then delete the value.\\n- *\\n- * Define NO_LOG to prevent all logging when calling this from the uninstaller.\\n+ * Finds an existing installation path for the application based on the\\n+ * application's executable name so we can default to using this path for the\\n+ * install. If there is zero or more than one installation of the application\\n+ * then we default to the default installation path. This uses SHCTX to\\n+ * determine the registry hive to read from so you must call SetShellVarContext\\n+ * first.\\n  *\\n- * @param   _ROOT\\n- *          The registry key root as defined by NSIS (e.g. HKLM, HKCU, etc.).\\n  * @param   _KEY\\n- *          The subkey in relation to the key root.\\n- * @param   _LOG_UNINSTALL\\n- *          0 = don't add to uninstall log, 1 = add to uninstall log.\\n+ *          The registry subkey (typically this will be Software\\\\Mozilla\\\\App Name).\\n+ * @return  _RESULT\\n+ *          false if a single install location for this app name isn't found,\\n+ *          path to the install directory if a single install location is found.\\n  *\\n- * $R4 = [out] handle to newly created registry key. If this is not a key\\n- *       located in one of the predefined registry keys this must be closed\\n- *       with RegCloseKey (this should not be needed unless someone decides to\\n- *       do something extremely squirrelly with NSIS).\\n- * $R5 = return value from RegCreateKeyA (represented by r15 in the system call).\\n- * $R6 = [in] hKey passed to RegCreateKeyA.\\n- * $R7 = _ROOT\\n- * $R8 = _KEY\\n- * $R9 = _LOG_UNINSTALL\\n+ * $R5 = counter for the loop's EnumRegKey\\n+ * $R6 = return value from EnumRegKey\\n+ * $R7 = return value from ReadRegStr\\n+ * $R8 = storage for _KEY\\n+ * $R9 = _KEY and _RESULT\\n  */\\n-!macro CreateRegKey\\n+!macro GetSingleInstallPath\\n+\\n+  !ifndef ${_MOZFUNC_UN}GetSingleInstallPath\\n+    !define _MOZFUNC_UN_TMP ${_MOZFUNC_UN}\\n+    !insertmacro ${_MOZFUNC_UN_TMP}GetLongPath\\n+    !insertmacro ${_MOZFUNC_UN_TMP}GetParent\\n+    !insertmacro ${_MOZFUNC_UN_TMP}RemoveQuotesFromPath\\n+    !undef _MOZFUNC_UN\\n+    !define _MOZFUNC_UN ${_MOZFUNC_UN_TMP}\\n+    !undef _MOZFUNC_UN_TMP\\n \\n-  !ifndef ${_MOZFUNC_UN}CreateRegKey\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}CreateRegKey \\\"!insertmacro ${_MOZFUNC_UN}CreateRegKeyCall\\\"\\n+    !define ${_MOZFUNC_UN}GetSingleInstallPath \\\"!insertmacro ${_MOZFUNC_UN}GetSingleInstallPathCall\\\"\\n \\n-    Function ${_MOZFUNC_UN}CreateRegKey\\n+    Function ${_MOZFUNC_UN}GetSingleInstallPath\\n       Exch $R9\\n-      Exch 1\\n-      Exch $R8\\n-      Exch 2\\n-      Exch $R7\\n+      Push $R8\\n+      Push $R7\\n       Push $R6\\n       Push $R5\\n-      Push $R4\\n \\n-      StrCmp $R7 \\\"HKCR\\\" 0 +2\\n-      StrCpy $R6 \\\"0x80000000\\\"\\n-      StrCmp $R7 \\\"HKCU\\\" 0 +2\\n-      StrCpy $R6 \\\"0x80000001\\\"\\n-      StrCmp $R7 \\\"HKLM\\\" 0 +2\\n-      StrCpy $R6 \\\"0x80000002\\\"\\n+      StrCpy $R8 $R9\\n+      StrCpy $R9 \\\"false\\\"\\n+      StrCpy $R5 0  ; set the counter for the loop to 0\\n \\n-      ; see definition of RegCreateKey\\n-      System::Call \\\"${RegCreateKey}($R6, '$R8', .r14) .r15\\\"\\n+      loop:\\n+      ClearErrors\\n+      EnumRegKey $R6 SHCTX $R8 $R5\\n+      IfErrors cleanup\\n+      StrCmp $R6 \\\"\\\" cleanup +1  ; if empty there are no more keys to enumerate\\n+      IntOp $R5 $R5 + 1         ; increment the loop's counter\\n+      ClearErrors\\n+      ReadRegStr $R7 SHCTX \\\"$R8\\\\$R6\\\\Main\\\" \\\"PathToExe\\\"\\n+      IfErrors loop\\n+      ${${_MOZFUNC_UN}RemoveQuotesFromPath} \\\"$R7\\\" $R7\\n+      GetFullPathName $R7 \\\"$R7\\\"\\n+      IfErrors loop\\n \\n-!ifndef NO_LOG\\n-      ; if $R5 is not 0 then there was an error creating the registry key.\\n-      IntCmp $R5 0 +3\\n-      FileWrite $fhInstallLog \\\"  ** ERROR Adding Registry Key: $R7 | $R8 **$\\\\r$\\\\n\\\"\\n-      GoTo +4\\n-      IntCmp $R9 1 0 +2\\n-      FileWrite $fhUninstallLog \\\"RegKey: $R7 | $R8$\\\\r$\\\\n\\\"\\n-      FileWrite $fhInstallLog \\\"  Added Registry Key: $R7 | $R8$\\\\r$\\\\n\\\"\\n-!endif\\n+      StrCmp \\\"$R9\\\" \\\"false\\\" +1 +3\\n+      StrCpy $R9 \\\"$R7\\\"\\n+      GoTo Loop\\n+\\n+      StrCpy $R9 \\\"false\\\"\\n+\\n+      cleanup:\\n+      StrCmp $R9 \\\"false\\\" end +1\\n+      ${${_MOZFUNC_UN}GetLongPath} \\\"$R9\\\" $R9\\n+      ${${_MOZFUNC_UN}GetParent} \\\"$R9\\\" $R9\\n+\\n+      end:\\n+      ClearErrors\\n \\n-      Pop $R4\\n       Pop $R5\\n       Pop $R6\\n-      Exch $R7\\n-      Exch 2\\n-      Exch $R8\\n-      Exch 1\\n+      Pop $R7\\n+      Pop $R8\\n       Exch $R9\\n     FunctionEnd\\n \\n@@ -1511,34 +1489,32 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n   !endif\\n !macroend\\n \\n-!macro CreateRegKeyCall _ROOT _KEY _LOG_UNINSTALL\\n+!macro GetSingleInstallPathCall _KEY _RESULT\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_ROOT}\\\"\\n   Push \\\"${_KEY}\\\"\\n-  Push \\\"${_LOG_UNINSTALL}\\\"\\n-  Call CreateRegKey\\n+  Call GetSingleInstallPath\\n+  Pop ${_RESULT}\\n   !verbose pop\\n !macroend\\n \\n-!macro un.CreateRegKeyCall _ROOT _KEY _LOG_UNINSTALL\\n+!macro un.GetSingleInstallPathCall _KEY _RESULT\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_ROOT}\\\"\\n   Push \\\"${_KEY}\\\"\\n-  Push \\\"${_LOG_UNINSTALL}\\\"\\n-  Call un.CreateRegKey\\n+  Call un.GetSingleInstallPath\\n+  Pop ${_RESULT}\\n   !verbose pop\\n !macroend\\n \\n-!macro un.CreateRegKey\\n-  !ifndef un.CreateRegKey\\n+!macro un.GetSingleInstallPath\\n+  !ifndef un.GetSingleInstallPath\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN \\\"un.\\\"\\n \\n-    !insertmacro CreateRegKey\\n+    !insertmacro GetSingleInstallPath\\n \\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN\\n@@ -1546,112 +1522,119 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n   !endif\\n !macroend\\n \\n+\\n+################################################################################\\n+# Macros for working with the file system\\n+\\n /**\\n- * Finds a second installation of the application so we can make informed\\n- * decisions about registry operations. This uses SHCTX to determine the\\n- * registry hive so you must call SetShellVarContext first.\\n+ * Attempts to delete a file if it exists. This will fail if the file is in use.\\n+ *\\n+ * @param   _FILE\\n+ *          The path to the file that is to be deleted.\\n+ */\\n+!macro DeleteFile _FILE\\n+  ${If} ${FileExists} \\\"${_FILE}\\\"\\n+    Delete \\\"${_FILE}\\\"\\n+  ${EndIf}\\n+!macroend\\n+!define DeleteFile \\\"!insertmacro DeleteFile\\\"\\n+\\n+/**\\n+ * Removes a directory if it exists and is empty.\\n  *\\n- * IMPORTANT! $R9 will be overwritten by this macro with the return value so\\n- *            protect yourself!\\n+ * @param   _DIR\\n+ *          The path to the directory that is to be removed.\\n+ */\\n+!macro RemoveDir _DIR\\n+  ${If} ${FileExists} \\\"${_DIR}\\\"\\n+    RmDir \\\"${_DIR}\\\"\\n+  ${EndIf}\\n+!macroend\\n+!define RemoveDir \\\"!insertmacro RemoveDir\\\"\\n+\\n+/**\\n+ * Checks whether we can write to the install directory. If the install\\n+ * directory already exists this will attempt to create a temporary file in the\\n+ * install directory and then delete it. If it does not exist this will attempt\\n+ * to create the directory and then delete it. If we can write to the install\\n+ * directory this will return true... if not, this will return false.\\n  *\\n- * @param   _KEY\\n- *          The registry subkey (typically this will be Software\\\\Mozilla).\\n  * @return  _RESULT\\n- *          false if a second install isn't found, path to the main exe if a\\n- *          second install is found.\\n+ *          true if the install directory can be written to otherwise false.\\n  *\\n- * $R3 = _KEY\\n- * $R4 = value returned from the outer loop's EnumRegKey\\n- * $R5 = value returned from ReadRegStr\\n- * $R6 = counter for the outer loop's EnumRegKey\\n- * $R7 = value returned popped from the stack for GetPathFromRegStr macro\\n- * $R8 = value returned popped from the stack for GetParentDir macro\\n+ * $R7 = temp filename in installation directory returned from GetTempFileName\\n+ * $R8 = filehandle to temp file used for writing\\n  * $R9 = _RESULT\\n  */\\n-!macro GetSecondInstallPath\\n-\\n-  !insertmacro ${_MOZFUNC_UN}GetLongPath\\n-  !insertmacro ${_MOZFUNC_UN}GetParent\\n+!macro CanWriteToInstallDir\\n \\n-  !ifndef ${_MOZFUNC_UN}GetSecondInstallPath\\n+  !ifndef ${_MOZFUNC_UN}CanWriteToInstallDir\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}GetSecondInstallPath \\\"!insertmacro ${_MOZFUNC_UN}GetSecondInstallPathCall\\\"\\n+    !define ${_MOZFUNC_UN}CanWriteToInstallDir \\\"!insertmacro ${_MOZFUNC_UN}CanWriteToInstallDirCall\\\"\\n \\n-    Function ${_MOZFUNC_UN}GetSecondInstallPath\\n-      Exch $R3\\n-      Push $R4\\n-      Push $R5\\n-      Push $R6\\n-      Push $R7\\n+    Function ${_MOZFUNC_UN}CanWriteToInstallDir\\n+      Push $R9\\n       Push $R8\\n+      Push $R7\\n \\n+      StrCpy $R9 \\\"true\\\"\\n+      IfFileExists \\\"$INSTDIR\\\" +1 checkCreateDir\\n+      GetTempFileName $R7 \\\"$INSTDIR\\\"\\n+      FileOpen $R8 $R7 w\\n+      FileWrite $R8 \\\"Write Access Test\\\"\\n+      FileClose $R8\\n+      IfFileExists \\\"$R7\\\" +3 +1\\n       StrCpy $R9 \\\"false\\\"\\n-      StrCpy $R6 0  ; set the counter for the loop to 0\\n-\\n-      loop:\\n-      EnumRegKey $R4 SHCTX $R3 $R6\\n-      StrCmp $R4 \\\"\\\" end  ; if empty there are no more keys to enumerate\\n-      IntOp $R6 $R6 + 1  ; increment the loop's counter\\n-      ClearErrors\\n-      ReadRegStr $R5 SHCTX \\\"$R3\\\\$R4\\\\bin\\\" \\\"PathToExe\\\"\\n-      IfErrors loop\\n+      GoTo end\\n \\n-      ${${_MOZFUNC_UN}RemoveQuotesFromPath} \\\"$R5\\\" $R7\\n+      Delete $R7\\n+      GoTo end\\n \\n-      IfFileExists \\\"$R7\\\" +1 +6\\n-      ${${_MOZFUNC_UN}GetParent} \\\"$R7\\\" $R8\\n-      StrCmp $R8 $INSTDIR +4 +1\\n-      StrCmp \\\"$R8\\\\${FileMainEXE}\\\" \\\"$R7\\\" +1 +3\\n-      StrCpy $R9 \\\"$R7\\\"\\n+      checkCreateDir:\\n+      CreateDirectory \\\"$INSTDIR\\\"\\n+      IfFileExists \\\"$INSTDIR\\\" +3 +1\\n+      StrCpy $R9 \\\"false\\\"\\n       GoTo end\\n \\n-      GoTo loop\\n+      RmDir \\\"$INSTDIR\\\"\\n \\n       end:\\n       ClearErrors\\n \\n-      Pop $R8\\n       Pop $R7\\n-      Pop $R6\\n-      Pop $R5\\n-      Pop $R4\\n-      Exch $R3\\n-      Push $R9\\n+      Pop $R8\\n+      Exch $R9\\n     FunctionEnd\\n \\n     !verbose pop\\n   !endif\\n !macroend\\n \\n-!macro GetSecondInstallPathCall _KEY _RESULT\\n+!macro CanWriteToInstallDirCall _RESULT\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_KEY}\\\"\\n-  Call GetSecondInstallPath\\n+  Call CanWriteToInstallDir\\n   Pop ${_RESULT}\\n   !verbose pop\\n !macroend\\n \\n-!macro un.GetSecondInstallPathCall _KEY _RESULT\\n+!macro un.CanWriteToInstallDirCall _RESULT\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_KEY}\\\"\\n-  Call un.GetSecondInstallPath\\n+  Call un.CanWriteToInstallDir\\n   Pop ${_RESULT}\\n   !verbose pop\\n !macroend\\n \\n-!macro un.GetSecondInstallPath\\n-  !ifndef un.GetSecondInstallPath\\n+!macro un.CanWriteToInstallDir\\n+  !ifndef un.CanWriteToInstallDir\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN \\\"un.\\\"\\n \\n-    !insertmacro GetLongPath\\n-    !insertmacro GetParent\\n-    !insertmacro GetSecondInstallPath\\n+    !insertmacro CanWriteToInstallDir\\n \\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN\\n@@ -1660,114 +1643,112 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n !macroend\\n \\n /**\\n- * Finds an existing installation path of the application based on the\\n- * application name so we can default to using this path for the install. If\\n- * there is zero or more than one installation for the application then we\\n- * default to the normal default path. This uses SHCTX to determine the\\n- * registry hive so you must call SetShellVarContext first.\\n- *\\n- * IMPORTANT! $R9 will be overwritten by this macro with the return value so\\n- *            protect yourself!\\n+ * Checks whether there is sufficient free space available on the installation\\n+ * directory's drive. If there is sufficient free space this will return true...\\n+ * if not, this will return false. This will only calculate the size of the\\n+ * first three sections.\\n  *\\n- * @param   _KEY\\n- *          The registry subkey (typically this will be Software\\\\Mozilla\\\\App Name).\\n  * @return  _RESULT\\n- *          false if a single install location for this app name isn't found,\\n- *          path to the install directory if a single install location is found.\\n+ *          true if there is sufficient free space otherwise false.\\n  *\\n- * $R5 = _KEY\\n- * $R6 = value returned from EnumRegKey\\n- * $R7 = value returned from ReadRegStr\\n- * $R8 = counter for the loop's EnumRegKey\\n+ * $R2 = return value from greater than comparison (0=false 1=true)\\n+ * $R3 = free space for the install directory's drive\\n+ * $R4 = install directory root\\n+ * $R5 = return value from SectionGetSize\\n+ * $R6 = return value from 'and' comparison of SectionGetFlags (1=selected)\\n+ * $R7 = return value from SectionGetFlags\\n+ * $R8 = size in KB required for this installation\\n  * $R9 = _RESULT\\n  */\\n-!macro GetSingleInstallPath\\n+!macro CheckDiskSpace\\n \\n-  !insertmacro ${_MOZFUNC_UN}GetLongPath\\n-  !insertmacro ${_MOZFUNC_UN}GetParent\\n+  !ifndef ${_MOZFUNC_UN}CheckDiskSpace\\n+    !define _MOZFUNC_UN_TMP ${_MOZFUNC_UN}\\n+    !insertmacro ${_MOZFUNC_UN_TMP}GetRoot\\n+    !insertmacro ${_MOZFUNC_UN_TMP}DriveSpace\\n+    !undef _MOZFUNC_UN\\n+    !define _MOZFUNC_UN ${_MOZFUNC_UN_TMP}\\n+    !undef _MOZFUNC_UN_TMP\\n \\n-  !ifndef ${_MOZFUNC_UN}GetSingleInstallPath\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}GetSingleInstallPath \\\"!insertmacro ${_MOZFUNC_UN}GetSingleInstallPathCall\\\"\\n+    !define ${_MOZFUNC_UN}CheckDiskSpace \\\"!insertmacro ${_MOZFUNC_UN}CheckDiskSpaceCall\\\"\\n \\n-    Function ${_MOZFUNC_UN}GetSingleInstallPath\\n-      Exch $R5\\n-      Push $R6\\n-      Push $R7\\n+    Function ${_MOZFUNC_UN}CheckDiskSpace\\n+      Push $R9\\n       Push $R8\\n+      Push $R7\\n+      Push $R6\\n+      Push $R5\\n+      Push $R4\\n+      Push $R3\\n+      Push $R2\\n \\n-      StrCpy $R9 \\\"false\\\"\\n-      StrCpy $R8 0  ; set the counter for the loop to 0\\n+      StrCpy $R9 \\\"true\\\"\\n+      SectionGetSize 0 $R8\\n \\n-      loop:\\n-      ClearErrors\\n-      EnumRegKey $R6 SHCTX $R5 $R8\\n-      IfErrors cleanup\\n-      StrCmp $R6 \\\"\\\" cleanup  ; if empty there are no more keys to enumerate\\n-      IntOp $R8 $R8 + 1      ; increment the loop's counter\\n-      ClearErrors\\n-      ReadRegStr $R7 SHCTX \\\"$R5\\\\$R6\\\\Main\\\" \\\"PathToExe\\\"\\n-      IfErrors loop\\n-      GetFullPathName $R7 \\\"$R7\\\"\\n-      IfErrors loop\\n+      SectionGetFlags 1 $R7\\n+      IntOp $R6 ${SF_SELECTED} & $R7\\n+      IntCmp $R6 0 +3 +1 +1\\n+      SectionGetSize 1 $R5\\n+      IntOp $R8 $R8 + $R5\\n \\n+      SectionGetFlags 2 $R7\\n+      IntOp $R6 ${SF_SELECTED} & $R7\\n+      IntCmp $R6 0 +3 +1 +1\\n+      SectionGetSize 2 $R5\\n+      IntOp $R8 $R8 + $R5\\n \\n-      StrCmp \\\"$R9\\\" \\\"false\\\" 0 +3\\n-      StrCpy $R9 \\\"$R7\\\"\\n-      GoTo Loop\\n+      ${${_MOZFUNC_UN}GetRoot} \\\"$INSTDIR\\\" $R4\\n+      ${${_MOZFUNC_UN}DriveSpace} \\\"$R4\\\" \\\"/D=F /S=K\\\" $R3\\n \\n-      StrCpy $R9 \\\"false\\\"\\n+      System::Int64Op $R3 > $R8\\n+      Pop $R2\\n \\n-      cleanup:\\n-      StrCmp $R9 \\\"false\\\" end\\n-      ${${_MOZFUNC_UN}GetParent} \\\"$R9\\\" $R9\\n-      StrCpy $R8 $R9 \\\"\\\" -1  ; Copy the last char.\\n-      StrCmp $R8 '\\\\' end    ; Is it a \\\\?\\n-      StrCpy $R9 \\\"$R9\\\\\\\"     ; Append \\\\ to the string\\n+      IntCmp $R2 1 end +1 +1\\n+      StrCpy $R9 \\\"false\\\"\\n \\n       end:\\n       ClearErrors\\n \\n-      Pop $R8\\n-      Pop $R7\\n+      Pop $R2\\n+      Pop $R3\\n+      Pop $R4\\n+      Pop $R5\\n       Pop $R6\\n-      Exch $R5\\n-      Push $R9\\n+      Pop $R7\\n+      Pop $R8\\n+      Exch $R9\\n     FunctionEnd\\n \\n     !verbose pop\\n   !endif\\n !macroend\\n \\n-!macro GetSingleInstallPathCall _KEY _RESULT\\n+!macro CheckDiskSpaceCall _RESULT\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_KEY}\\\"\\n-  Call GetSingleInstallPath\\n+  Call CheckDiskSpace\\n   Pop ${_RESULT}\\n   !verbose pop\\n !macroend\\n \\n-!macro un.GetSingleInstallPathCall _KEY _RESULT\\n+!macro un.CheckDiskSpaceCall _RESULT\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_KEY}\\\"\\n-  Call un.GetSingleInstallPath\\n+  Call un.CheckDiskSpace\\n   Pop ${_RESULT}\\n   !verbose pop\\n !macroend\\n \\n-!macro un.GetSingleInstallPath\\n-  !ifndef un.GetSingleInstallPath\\n+!macro un.CheckDiskSpace\\n+  !ifndef un.CheckDiskSpace\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN \\\"un.\\\"\\n \\n-    !insertmacro GetLongPath\\n-    !insertmacro GetParent\\n-    !insertmacro GetSingleInstallPath\\n+    !insertmacro CheckDiskSpace\\n \\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN\\n@@ -1776,96 +1757,86 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n !macroend\\n \\n /**\\n- * Writes common registry values for a handler using SHCTX.\\n- * @param   _KEY\\n- *          The subkey in relation to the key root.\\n- * @param   _VALOPEN\\n- *          The path and args to launch the application.\\n- * @param   _VALICON\\n- *          The path to an exe that contains an icon and the icon resource id.\\n- * @param   _DISPNAME\\n- *          The display name for the handler. If emtpy no value will be set.\\n- * @param   _ISPROTOCOL\\n- *          Sets protocol handler specific registry values when \\\"true\\\".\\n- * @param   _ISDDE\\n- *          Sets DDE specific registry values when \\\"true\\\".\\n- *\\n- * $R3 = string value of the current registry key path.\\n- * $R4 = _KEY\\n- * $R5 = _VALOPEN\\n- * $R6 = _VALICON\\n- * $R7 = _DISPNAME\\n- * $R8 = _ISPROTOCOL\\n- * $R9 = _ISDDE\\n- */\\n-!macro AddHandlerValues\\n+* Returns the path found within a passed in string. The path is quoted or not\\n+* with the exception of an unquoted non 8dot3 path without arguments that is\\n+* also not a DefaultIcon path, is a 8dot3 path or not, has command line\\n+* arguments, or is a registry DefaultIcon path (e.g. <path to binary>,# where #\\n+* is the icon's resuorce id). The string does not need to be a valid path or\\n+* exist. It is up to the caller to pass in a string of one of the forms noted\\n+* above and to verify existence if necessary.\\n+*\\n+* Examples:\\n+* In:  C:\\\\PROGRA~1\\\\MOZILL~1\\\\FIREFOX.EXE -flag \\\"%1\\\"\\n+* In:  C:\\\\PROGRA~1\\\\MOZILL~1\\\\FIREFOX.EXE,0\\n+* In:  C:\\\\PROGRA~1\\\\MOZILL~1\\\\FIREFOX.EXE\\n+* In:  \\\"C:\\\\PROGRA~1\\\\MOZILL~1\\\\FIREFOX.EXE\\\"\\n+* In:  \\\"C:\\\\PROGRA~1\\\\MOZILL~1\\\\FIREFOX.EXE\\\" -flag \\\"%1\\\"\\n+* Out: C:\\\\PROGRA~1\\\\MOZILL~1\\\\FIREFOX.EXE\\n+*\\n+* In:  \\\"C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe\\\" -flag \\\"%1\\\"\\n+* In:  C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe,0\\n+* In:  \\\"C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe\\\"\\n+* Out: C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe\\n+*\\n+* @param   _IN_PATH\\n+*          The string containing the path.\\n+* @param   _OUT_PATH\\n+*          The register to store the path to.\\n+*\\n+* $R7 = counter for the outer loop's EnumRegKey\\n+* $R8 = return value from ReadRegStr\\n+* $R9 = _IN_PATH and _OUT_PATH\\n+*/\\n+!macro GetPathFromString\\n \\n-  !ifndef ${_MOZFUNC_UN}AddHandlerValues\\n+  !ifndef ${_MOZFUNC_UN}GetPathFromString\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}AddHandlerValues \\\"!insertmacro ${_MOZFUNC_UN}AddHandlerValuesCall\\\"\\n+    !define ${_MOZFUNC_UN}GetPathFromString \\\"!insertmacro ${_MOZFUNC_UN}GetPathFromStringCall\\\"\\n \\n-    Function ${_MOZFUNC_UN}AddHandlerValues\\n+    Function ${_MOZFUNC_UN}GetPathFromString\\n       Exch $R9\\n-      Exch 1\\n-      Exch $R8\\n-      Exch 2\\n-      Exch $R7\\n-      Exch 3\\n-      Exch $R6\\n-      Exch 4\\n-      Exch $R5\\n-      Exch 5\\n-      Exch $R4\\n-      Push $R3\\n+      Push $R8\\n+      Push $R7\\n \\n-      StrCmp \\\"$R7\\\" \\\"\\\" +6 0\\n-      ReadRegStr $R3 SHCTX \\\"$R4\\\" \\\"FriendlyTypeName\\\"\\n+      StrCpy $R7 0          ; Set the counter to 0.\\n \\n-      StrCmp \\\"$R3\\\" \\\"\\\" 0 +3\\n-      WriteRegStr SHCTX \\\"$R4\\\" \\\"\\\" \\\"$R7\\\"\\n-      WriteRegStr SHCTX \\\"$R4\\\" \\\"FriendlyTypeName\\\" \\\"$R7\\\"\\n+      ; Handle quoted paths with arguments.\\n+      StrCpy $R8 $R9 1      ; Copy the first char.\\n+      StrCmp $R8 '\\\"' +2 +1  ; Is it a \\\"?\\n+      StrCmp $R8 \\\"'\\\" +1 +9  ; Is it a '?\\n+      StrCpy $R9 $R9 \\\"\\\" 1   ; Remove the first char.\\n+      IntOp $R7 $R7 + 1     ; Increment the counter.\\n+      StrCpy $R8 $R9 1 $R7  ; Starting from the counter copy the next char.\\n+      StrCmp $R8 \\\"\\\" end +1  ; Are there no more chars?\\n+      StrCmp $R8 '\\\"' +2 +1  ; Is it a \\\" char?\\n+      StrCmp $R8 \\\"'\\\" +1 -4  ; Is it a ' char?\\n+      StrCpy $R9 $R9 $R7    ; Copy chars up to the counter.\\n+      GoTo end\\n \\n-      StrCmp \\\"$R8\\\" \\\"true\\\" 0 +8\\n-      WriteRegStr SHCTX \\\"$R4\\\" \\\"URL Protocol\\\" \\\"\\\"\\n-      StrCpy $R3 \\\"\\\"\\n-      ClearErrors\\n-      ReadRegDWord $R3 SHCTX \\\"$R4\\\" \\\"EditFlags\\\"\\n-      StrCmp $R3 \\\"\\\" 0 +3 ; Only add EditFlags if a value doesn't exist\\n-      DeleteRegValue SHCTX \\\"$R4\\\" \\\"EditFlags\\\"\\n-      WriteRegDWord SHCTX \\\"$R4\\\" \\\"EditFlags\\\" 0x00000002\\n-      \\n-      StrCmp \\\"$R6\\\" \\\"\\\" +2 0\\n-      WriteRegStr SHCTX \\\"$R4\\\\DefaultIcon\\\" \\\"\\\" \\\"$R6\\\"\\n-      \\n-      StrCmp \\\"$R5\\\" \\\"\\\" +2 0\\n-      WriteRegStr SHCTX \\\"$R4\\\\shell\\\\open\\\\command\\\" \\\"\\\" \\\"$R5\\\"      \\n+      ; Handle DefaultIcon paths. DefaultIcon paths are not quoted and end with\\n+      ; a , and a number.\\n+      IntOp $R7 $R7 - 1     ; Decrement the counter.\\n+      StrCpy $R8 $R9 1 $R7  ; Copy one char from the end minus the counter.\\n+      StrCmp $R8 '' +4 +1   ; Are there no more chars?\\n+      StrCmp $R8 ',' +1 -3  ; Is it a , char?\\n+      StrCpy $R9 $R9 $R7    ; Copy chars up to the end minus the counter.\\n+      GoTo end\\n \\n-      StrCmp \\\"$R9\\\" \\\"true\\\" 0 +11\\n-      WriteRegStr SHCTX \\\"$R4\\\\shell\\\\open\\\\ddeexec\\\" \\\"\\\" \\\"$\\\\\\\"%1$\\\\\\\",,0,0,,,,\\\"\\n-      WriteRegStr SHCTX \\\"$R4\\\\shell\\\\open\\\\ddeexec\\\" \\\"NoActivateHandler\\\" \\\"\\\"\\n-      WriteRegStr SHCTX \\\"$R4\\\\shell\\\\open\\\\ddeexec\\\\Application\\\" \\\"\\\" \\\"${DDEApplication}\\\"\\n-      WriteRegStr SHCTX \\\"$R4\\\\shell\\\\open\\\\ddeexec\\\\Topic\\\" \\\"\\\" \\\"WWW_OpenURL\\\"\\n-      ; The ifexec key may have been added by another application so try to\\n-      ; delete it to prevent it from breaking this app's shell integration.\\n-      ; Also, IE 6 and below doesn't remove this key when it sets itself as the\\n-      ; default handler and if this key exists IE's shell integration breaks.\\n-      DeleteRegKey HKLM \\\"$R4\\\\shell\\\\open\\\\ddeexec\\\\ifexec\\\"\\n-      DeleteRegKey HKCU \\\"$R4\\\\shell\\\\open\\\\ddeexec\\\\ifexec\\\"\\n+      ; Handle unquoted paths with arguments. An unquoted path with arguments\\n+      ; must be an 8dot3 path.\\n+      StrCpy $R7 -1          ; Set the counter to -1 so it will start at 0.\\n+      IntOp $R7 $R7 + 1      ; Increment the counter.\\n+      StrCpy $R8 $R9 1 $R7   ; Starting from the counter copy the next char.\\n+      StrCmp $R8 \\\"\\\" end +1   ; Are there no more chars?\\n+      StrCmp $R8 \\\" \\\" +1 -3   ; Is it a space char?\\n+      StrCpy $R9 $R9 $R7     ; Copy chars up to the counter.\\n \\n+      end:\\n       ClearErrors\\n \\n-      Pop $R3\\n-      Exch $R4\\n-      Exch 5\\n-      Exch $R5\\n-      Exch 4\\n-      Exch $R6\\n-      Exch 3\\n-      Exch $R7\\n-      Exch 2\\n-      Exch $R8\\n-      Exch 1\\n+      Pop $R7\\n+      Pop $R8\\n       Exch $R9\\n     FunctionEnd\\n \\n@@ -1873,40 +1844,32 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n   !endif\\n !macroend\\n \\n-!macro AddHandlerValuesCall _KEY _VALOPEN _VALICON _DISPNAME _ISPROTOCOL _ISDDE\\n+!macro GetPathFromStringCall _IN_PATH _OUT_PATH\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_KEY}\\\"\\n-  Push \\\"${_VALOPEN}\\\"\\n-  Push \\\"${_VALICON}\\\"\\n-  Push \\\"${_DISPNAME}\\\"\\n-  Push \\\"${_ISPROTOCOL}\\\"\\n-  Push \\\"${_ISDDE}\\\"\\n-  Call AddHandlerValues\\n+  Push \\\"${_IN_PATH}\\\"\\n+  Call GetPathFromString\\n+  Pop ${_OUT_PATH}\\n   !verbose pop\\n !macroend\\n \\n-!macro un.AddHandlerValuesCall _KEY _VALOPEN _VALICON _DISPNAME _ISPROTOCOL _ISDDE\\n+!macro un.GetPathFromStringCall _IN_PATH _OUT_PATH\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_KEY}\\\"\\n-  Push \\\"${_VALOPEN}\\\"\\n-  Push \\\"${_VALICON}\\\"\\n-  Push \\\"${_DISPNAME}\\\"\\n-  Push \\\"${_ISPROTOCOL}\\\"\\n-  Push \\\"${_ISDDE}\\\"\\n-  Call un.AddHandlerValues\\n+  Push \\\"${_IN_PATH}\\\"\\n+  Call un.GetPathFromString\\n+  Pop ${_OUT_PATH}\\n   !verbose pop\\n !macroend\\n \\n-!macro un.AddHandlerValues\\n-  !ifndef un.AddHandlerValues\\n+!macro un.GetPathFromString\\n+  !ifndef un.GetPathFromString\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN \\\"un.\\\"\\n \\n-    !insertmacro AddHandlerValues\\n+    !insertmacro GetPathFromString\\n \\n     !undef _MOZFUNC_UN\\n     !define _MOZFUNC_UN\\n@@ -1915,173 +1878,1212 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n !macroend\\n \\n /**\\n-* Returns the path found within a passed in string. The path is quoted or not\\n-* with the exception of an unquoted non 8dot3 path without arguments that is\\n-* also not a DefaultIcon path, is a 8dot3 path or not, has command line\\n-* arguments, or is a registry DefaultIcon path (e.g. <path to binary>,# where #\\n-* is the icon's resuorce id). The string does not need to be a valid path or\\n-* exist. It is up to the caller to pass in a string of one of the forms noted\\n-* above and to verify existence if necessary.\\n-*\\n-* Examples:\\n-* In:  C:\\\\PROGRA~1\\\\MOZILL~1\\\\FIREFOX.EXE -url \\\"%1\\\" -requestPending\\n-* In:  C:\\\\PROGRA~1\\\\MOZILL~1\\\\FIREFOX.EXE,0\\n-* In:  C:\\\\PROGRA~1\\\\MOZILL~1\\\\FIREFOX.EXE\\n-* In:  \\\"C:\\\\PROGRA~1\\\\MOZILL~1\\\\FIREFOX.EXE\\\"\\n-* In:  \\\"C:\\\\PROGRA~1\\\\MOZILL~1\\\\FIREFOX.EXE\\\" -url \\\"%1\\\" -requestPending\\n-* Out: C:\\\\PROGRA~1\\\\MOZILL~1\\\\FIREFOX.EXE\\n-*\\n-* In:  \\\"C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe\\\" -url \\\"%1\\\" -requestPending\\n-* In:  C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe,0\\n-* In:  \\\"C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe\\\"\\n-* Out: C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe\\n-*\\n-* @param   _IN_PATH\\n-*          The string containing the path.\\n-* @param   _OUT_PATH\\n-*          The register to store the path to.\\n-*\\n-* $R6 = counter for the outer loop's EnumRegKey\\n-* $R7 = value returned from ReadRegStr\\n-* $R8 = _IN_PATH\\n-* $R9 = _OUT_PATH\\n-*/\\n-!macro GetPathFromString\\n+ * Removes the quotes from each end of a string if present.\\n+ *\\n+ * @param   _IN_PATH\\n+ *          The string containing the path.\\n+ * @param   _OUT_PATH\\n+ *          The register to store the long path.\\n+ *\\n+ * $R7 = storage for single character comparison\\n+ * $R8 = storage for _IN_PATH\\n+ * $R9 = _IN_PATH and _OUT_PATH\\n+ */\\n+!macro RemoveQuotesFromPath\\n+\\n+  !ifndef ${_MOZFUNC_UN}RemoveQuotesFromPath\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !define ${_MOZFUNC_UN}RemoveQuotesFromPath \\\"!insertmacro ${_MOZFUNC_UN}RemoveQuotesFromPathCall\\\"\\n+\\n+    Function ${_MOZFUNC_UN}RemoveQuotesFromPath\\n+      Exch $R9\\n+      Push $R8\\n+      Push $R7\\n+\\n+      StrCpy $R7 \\\"$R9\\\" 1\\n+      StrCmp $R7 \\\"$\\\\\\\"\\\" +1 +2\\n+      StrCpy $R9 \\\"$R9\\\" \\\"\\\" 1\\n+\\n+      StrCpy $R7 \\\"$R9\\\" \\\"\\\" -1\\n+      StrCmp $R7 \\\"$\\\\\\\"\\\" +1 +2\\n+      StrCpy $R9 \\\"$R9\\\" -1\\n+\\n+      Pop $R7\\n+      Pop $R8\\n+      Exch $R9\\n+    FunctionEnd\\n+\\n+    !verbose pop\\n+  !endif\\n+!macroend\\n+\\n+!macro RemoveQuotesFromPathCall _IN_PATH _OUT_PATH\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Push \\\"${_IN_PATH}\\\"\\n+  Call RemoveQuotesFromPath\\n+  Pop ${_OUT_PATH}\\n+  !verbose pop\\n+!macroend\\n+\\n+!macro un.RemoveQuotesFromPathCall _IN_PATH _OUT_PATH\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Push \\\"${_IN_PATH}\\\"\\n+  Call un.RemoveQuotesFromPath\\n+  Pop ${_OUT_PATH}\\n+  !verbose pop\\n+!macroend\\n+\\n+!macro un.RemoveQuotesFromPath\\n+  !ifndef un.RemoveQuotesFromPath\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !undef _MOZFUNC_UN\\n+    !define _MOZFUNC_UN \\\"un.\\\"\\n+\\n+    !insertmacro RemoveQuotesFromPath\\n+\\n+    !undef _MOZFUNC_UN\\n+    !define _MOZFUNC_UN\\n+    !verbose pop\\n+  !endif\\n+!macroend\\n+\\n+/**\\n+ * Returns the long path for an existing file or directory. GetLongPathNameA\\n+ * may not be available on Win95 if Microsoft Layer for Unicode is not\\n+ * installed and GetFullPathName only returns a long path for the last file or\\n+ * directory that doesn't end with a \\\\ in the path that it is passed. If the\\n+ * path does not exist on the file system this will return an empty string. To\\n+ * provide a consistent result trailing back-slashes are always removed.\\n+ *\\n+ * Note: 1024 used by GetLongPathNameA is the maximum NSIS string length.\\n+ *\\n+ * @param   _IN_PATH\\n+ *          The string containing the path.\\n+ * @param   _OUT_PATH\\n+ *          The register to store the long path.\\n+ *\\n+ * $R4 = counter value when the previous \\\\ was found\\n+ * $R5 = directory or file name found during loop\\n+ * $R6 = return value from GetLongPathNameA and loop counter\\n+ * $R7 = long path from GetLongPathNameA and single char from path for comparison\\n+ * $R8 = storage for _IN_PATH\\n+ * $R9 = _IN_PATH _OUT_PATH\\n+ */\\n+!macro GetLongPath\\n+\\n+  !ifndef ${_MOZFUNC_UN}GetLongPath\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !define ${_MOZFUNC_UN}GetLongPath \\\"!insertmacro ${_MOZFUNC_UN}GetLongPathCall\\\"\\n+\\n+    Function ${_MOZFUNC_UN}GetLongPath\\n+      Exch $R9\\n+      Push $R8\\n+      Push $R7\\n+      Push $R6\\n+      Push $R5\\n+      Push $R4\\n+\\n+      ClearErrors\\n+\\n+      StrCpy $R8 \\\"$R9\\\"\\n+      StrCpy $R9 \\\"\\\"\\n+      GetFullPathName $R8 \\\"$R8\\\"\\n+      IfErrors end_GetLongPath +1 ; If the path doesn't exist return an empty string.\\n+\\n+      ; Remove trailing \\\\'s from the path.\\n+      StrCpy $R6 \\\"$R8\\\" \\\"\\\" -1\\n+      StrCmp $R6 \\\"\\\\\\\" +1 +2\\n+      StrCpy $R9 \\\"$R8\\\" -1\\n+\\n+      System::Call 'kernel32::GetLongPathNameA(t r18, t .r17, i 1024)i .r16'\\n+      StrCmp \\\"$R7\\\" \\\"\\\" +4 +1 ; Empty string when GetLongPathNameA is not present.\\n+      StrCmp $R6 0 +3 +1    ; Should never equal 0 since the path exists.\\n+      StrCpy $R9 \\\"$R7\\\"\\n+      GoTo end_GetLongPath\\n+\\n+      ; Do it the hard way.\\n+      StrCpy $R4 0     ; Stores the position in the string of the last \\\\ found.\\n+      StrCpy $R6 -1    ; Set the counter to -1 so it will start at 0.\\n+\\n+      loop_GetLongPath:\\n+      IntOp $R6 $R6 + 1      ; Increment the counter.\\n+      StrCpy $R7 $R8 1 $R6   ; Starting from the counter copy the next char.\\n+      StrCmp $R7 \\\"\\\" +2 +1    ; Are there no more chars?\\n+      StrCmp $R7 \\\"\\\\\\\" +1 -3   ; Is it a \\\\?\\n+\\n+      ; Copy chars starting from the previously found \\\\ to the counter.\\n+      StrCpy $R5 $R8 $R6 $R4\\n+\\n+      ; If this is the first \\\\ found we want to swap R9 with R5 so a \\\\ will\\n+      ; be appended to the drive letter and colon (e.g. C: will become C:\\\\).\\n+      StrCmp $R4 0 +1 +3     \\n+      StrCpy $R9 $R5\\n+      StrCpy $R5 \\\"\\\"\\n+\\n+      GetFullPathName $R9 \\\"$R9\\\\$R5\\\"\\n+\\n+      StrCmp $R7 \\\"\\\" end_GetLongPath +1 ; Are there no more chars?\\n+\\n+      ; Store the counter for the current \\\\ and prefix it for StrCpy operations.\\n+      StrCpy $R4 \\\"+$R6\\\"\\n+      IntOp $R6 $R6 + 1      ; Increment the counter so we skip over the \\\\.\\n+      StrCpy $R8 $R8 \\\"\\\" $R6  ; Copy chars starting from the counter to the end.\\n+      StrCpy $R6 -1          ; Reset the counter to -1 so it will start over at 0.\\n+      GoTo loop_GetLongPath\\n+\\n+      end_GetLongPath:\\n+      ClearErrors\\n+\\n+      Pop $R4\\n+      Pop $R5\\n+      Pop $R6\\n+      Pop $R7\\n+      Pop $R8\\n+      Exch $R9\\n+    FunctionEnd\\n+\\n+    !verbose pop\\n+  !endif\\n+!macroend\\n+\\n+!macro GetLongPathCall _IN_PATH _OUT_PATH\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Push \\\"${_IN_PATH}\\\"\\n+  Call GetLongPath\\n+  Pop ${_OUT_PATH}\\n+  !verbose pop\\n+!macroend\\n+\\n+!macro un.GetLongPathCall _IN_PATH _OUT_PATH\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Push \\\"${_IN_PATH}\\\"\\n+  Call un.GetLongPath\\n+  Pop ${_OUT_PATH}\\n+  !verbose pop\\n+!macroend\\n+\\n+!macro un.GetLongPath\\n+  !ifndef un.GetLongPath\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !undef _MOZFUNC_UN\\n+    !define _MOZFUNC_UN \\\"un.\\\"\\n+\\n+    !insertmacro GetLongPath\\n+\\n+    !undef _MOZFUNC_UN\\n+    !define _MOZFUNC_UN\\n+    !verbose pop\\n+  !endif\\n+!macroend\\n+\\n+\\n+################################################################################\\n+# Macros for cleaning up the registry and file system\\n+\\n+/**\\n+ * Removes registry keys that reference this install location and for paths that\\n+ * no longer exist. This uses SHCTX to determine the registry hive so you must\\n+ * call SetShellVarContext first.\\n+ *\\n+ * @param   _KEY\\n+ *          The registry subkey (typically this will be Software\\\\Mozilla).\\n+ *\\n+ * XXXrstrong - there is the potential for Key: Software/Mozilla/AppName,\\n+ * ValueName: CurrentVersion, ValueData: AppVersion to reference a key that is\\n+ * no longer available due to this cleanup. This should be no worse than prior\\n+ * to this reg cleanup since the referenced key would be for an app that is no\\n+ * longer installed on the system.\\n+ *\\n+ * $R1 = stores the long path to $INSTDIR\\n+ * $R2 = return value from the stack from the GetParent and GetLongPath macros\\n+ * $R3 = return value from the outer loop's EnumRegKey\\n+ * $R4 = return value from the inner loop's EnumRegKey\\n+ * $R5 = return value from ReadRegStr\\n+ * $R6 = counter for the outer loop's EnumRegKey\\n+ * $R7 = counter for the inner loop's EnumRegKey\\n+ * $R8 = return value from the stack from the RemoveQuotesFromPath macro\\n+ * $R9 = _KEY\\n+ */\\n+!macro RegCleanMain\\n+\\n+  !ifndef ${_MOZFUNC_UN}RegCleanMain\\n+    !define _MOZFUNC_UN_TMP ${_MOZFUNC_UN}\\n+    !insertmacro ${_MOZFUNC_UN_TMP}GetParent\\n+    !insertmacro ${_MOZFUNC_UN_TMP}GetLongPath\\n+    !insertmacro ${_MOZFUNC_UN_TMP}RemoveQuotesFromPath\\n+    !undef _MOZFUNC_UN\\n+    !define _MOZFUNC_UN ${_MOZFUNC_UN_TMP}\\n+    !undef _MOZFUNC_UN_TMP\\n+\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !define ${_MOZFUNC_UN}RegCleanMain \\\"!insertmacro ${_MOZFUNC_UN}RegCleanMainCall\\\"\\n+\\n+    Function ${_MOZFUNC_UN}RegCleanMain\\n+      Exch $R9\\n+      Push $R8\\n+      Push $R7\\n+      Push $R6\\n+      Push $R5\\n+      Push $R4\\n+      Push $R3\\n+      Push $R2\\n+      Push $R1\\n+\\n+      ${${_MOZFUNC_UN}GetLongPath} \\\"$INSTDIR\\\" $R1\\n+      StrCpy $R6 0  ; set the counter for the outer loop to 0\\n+\\n+      outerloop:\\n+      EnumRegKey $R3 SHCTX $R9 $R6\\n+      StrCmp $R3 \\\"\\\" end +1  ; if empty there are no more keys to enumerate\\n+      IntOp $R6 $R6 + 1     ; increment the outer loop's counter\\n+      ClearErrors\\n+      ReadRegStr $R5 SHCTX \\\"$R9\\\\$R3\\\\bin\\\" \\\"PathToExe\\\"\\n+      IfErrors 0 outercontinue\\n+      StrCpy $R7 0  ; set the counter for the inner loop to 0\\n+\\n+      innerloop:\\n+      EnumRegKey $R4 SHCTX \\\"$R9\\\\$R3\\\" $R7\\n+      StrCmp $R4 \\\"\\\" outerloop +1  ; if empty there are no more keys to enumerate\\n+      IntOp $R7 $R7 + 1  ; increment the inner loop's counter\\n+      ClearErrors\\n+      ReadRegStr $R5 SHCTX \\\"$R9\\\\$R3\\\\$R4\\\\Main\\\" \\\"PathToExe\\\"\\n+      IfErrors innerloop\\n+\\n+      ${${_MOZFUNC_UN}RemoveQuotesFromPath} \\\"$R5\\\" $R8\\n+      ${${_MOZFUNC_UN}GetParent} \\\"$R8\\\" $R2\\n+      ${${_MOZFUNC_UN}GetLongPath} \\\"$R2\\\" $R2\\n+      IfFileExists \\\"$R2\\\" +1 innerloop\\n+      StrCmp \\\"$R2\\\" \\\"$R1\\\" +1 innerloop\\n+\\n+      ClearErrors\\n+      DeleteRegKey SHCTX \\\"$R9\\\\$R3\\\\$R4\\\"\\n+      IfErrors innerloop\\n+      IntOp $R7 $R7 - 1 ; decrement the inner loop's counter when the key is deleted successfully.\\n+      ClearErrors\\n+      DeleteRegKey /ifempty SHCTX \\\"$R9\\\\$R3\\\"\\n+      IfErrors innerloop outerdecrement\\n+\\n+      outercontinue:\\n+      ${${_MOZFUNC_UN}RemoveQuotesFromPath} \\\"$R5\\\" $R8\\n+      ${${_MOZFUNC_UN}GetParent} \\\"$R8\\\" $R2\\n+      ${${_MOZFUNC_UN}GetLongPath} \\\"$R2\\\" $R2\\n+      IfFileExists \\\"$R2\\\" +1 outerloop\\n+      StrCmp \\\"$R2\\\" \\\"$R1\\\" +1 outerloop\\n+\\n+      ClearErrors\\n+      DeleteRegKey SHCTX \\\"$R9\\\\$R3\\\"\\n+      IfErrors outerloop\\n+\\n+      outerdecrement:\\n+      IntOp $R6 $R6 - 1 ; decrement the outer loop's counter when the key is deleted successfully.\\n+      GoTo outerloop\\n+\\n+      end:\\n+      ClearErrors\\n+\\n+      Pop $R1\\n+      Pop $R2\\n+      Pop $R3\\n+      Pop $R4\\n+      Pop $R5\\n+      Pop $R6\\n+      Pop $R7\\n+      Pop $R8\\n+      Exch $R9\\n+    FunctionEnd\\n+\\n+    !verbose pop\\n+  !endif\\n+!macroend\\n+\\n+!macro RegCleanMainCall _KEY\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Push \\\"${_KEY}\\\"\\n+  Call RegCleanMain\\n+  !verbose pop\\n+!macroend\\n+\\n+!macro un.RegCleanMainCall _KEY\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Push \\\"${_KEY}\\\"\\n+  Call un.RegCleanMain\\n+  !verbose pop\\n+!macroend\\n+\\n+!macro un.RegCleanMain\\n+  !ifndef un.RegCleanMain\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !undef _MOZFUNC_UN\\n+    !define _MOZFUNC_UN \\\"un.\\\"\\n+\\n+    !insertmacro RegCleanMain\\n+\\n+    !undef _MOZFUNC_UN\\n+    !define _MOZFUNC_UN\\n+    !verbose pop\\n+  !endif\\n+!macroend\\n+\\n+/**\\n+ * Removes all registry keys from \\\\Software\\\\Windows\\\\CurrentVersion\\\\Uninstall\\n+ * that reference this install location. This uses SHCTX to determine the\\n+ * registry hive so you must call SetShellVarContext first.\\n+ *\\n+ * $R4 = stores the long path to $INSTDIR\\n+ * $R5 = return value from ReadRegStr\\n+ * $R6 = string for the base reg key (e.g. Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall)\\n+ * $R7 = return value from EnumRegKey\\n+ * $R8 = counter for EnumRegKey\\n+ * $R9 = return value from the stack from the RemoveQuotesFromPath and GetLongPath macros\\n+ */\\n+!macro RegCleanUninstall\\n+\\n+  !ifndef ${_MOZFUNC_UN}RegCleanUninstall\\n+    !define _MOZFUNC_UN_TMP ${_MOZFUNC_UN}\\n+    !insertmacro ${_MOZFUNC_UN_TMP}GetLongPath\\n+    !insertmacro ${_MOZFUNC_UN_TMP}RemoveQuotesFromPath\\n+    !undef _MOZFUNC_UN\\n+    !define _MOZFUNC_UN ${_MOZFUNC_UN_TMP}\\n+    !undef _MOZFUNC_UN_TMP\\n+\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !define ${_MOZFUNC_UN}RegCleanUninstall \\\"!insertmacro ${_MOZFUNC_UN}RegCleanUninstallCall\\\"\\n+\\n+    Function ${_MOZFUNC_UN}RegCleanUninstall\\n+      Push $R9\\n+      Push $R8\\n+      Push $R7\\n+      Push $R6\\n+      Push $R5\\n+      Push $R4\\n+\\n+      ${${_MOZFUNC_UN}GetLongPath} \\\"$INSTDIR\\\" $R4\\n+      StrCpy $R6 \\\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\\\"\\n+      StrCpy $R7 \\\"\\\"\\n+      StrCpy $R8 0\\n+\\n+      loop:\\n+      EnumRegKey $R7 SHCTX $R6 $R8\\n+      StrCmp $R7 \\\"\\\" end +1\\n+      IntOp $R8 $R8 + 1 ; Increment the counter\\n+      ClearErrors\\n+      ReadRegStr $R5 SHCTX \\\"$R6\\\\$R7\\\" \\\"InstallLocation\\\"\\n+      IfErrors loop\\n+      ${${_MOZFUNC_UN}RemoveQuotesFromPath} \\\"$R5\\\" $R9\\n+      ${${_MOZFUNC_UN}GetLongPath} \\\"$R9\\\" $R9\\n+      StrCmp \\\"$R9\\\" \\\"$R4\\\" +1 loop\\n+      ClearErrors\\n+      DeleteRegKey SHCTX \\\"$R6\\\\$R7\\\"\\n+      IfErrors loop\\n+      IntOp $R8 $R8 - 1 ; Decrement the counter on successful deletion\\n+      GoTo loop\\n+\\n+      end:\\n+      ClearErrors\\n+\\n+      Pop $R4\\n+      Pop $R5\\n+      Pop $R6\\n+      Pop $R7\\n+      Pop $R8\\n+      Pop $R9\\n+    FunctionEnd\\n+\\n+    !verbose pop\\n+  !endif\\n+!macroend\\n+\\n+!macro RegCleanUninstallCall\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Call RegCleanUninstall\\n+  !verbose pop\\n+!macroend\\n+\\n+!macro un.RegCleanUninstallCall\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Call un.RegCleanUninstall\\n+  !verbose pop\\n+!macroend\\n+\\n+!macro un.RegCleanUninstall\\n+  !ifndef un.RegCleanUninstall\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !undef _MOZFUNC_UN\\n+    !define _MOZFUNC_UN \\\"un.\\\"\\n+\\n+    !insertmacro RegCleanUninstall\\n+\\n+    !undef _MOZFUNC_UN\\n+    !define _MOZFUNC_UN\\n+    !verbose pop\\n+  !endif\\n+!macroend\\n+\\n+/**\\n+ * If present removes the VirtualStore directory for this installation. Uses the\\n+ * program files directory path and the current install location to determine\\n+ * the sub-directory in the VirtualStore directory.\\n+ */\\n+!macro CleanVirtualStore\\n+\\n+  !ifndef ${_MOZFUNC_UN}CleanVirtualStore\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !define ${_MOZFUNC_UN}CleanVirtualStore \\\"!insertmacro ${_MOZFUNC_UN}CleanVirtualStoreCall\\\"\\n+\\n+    Function ${_MOZFUNC_UN}CleanVirtualStore\\n+      Push $R9\\n+      Push $R8\\n+      Push $R7\\n+\\n+      StrLen $R9 \\\"$INSTDIR\\\"\\n+\\n+      ; Get the installation's directory name including the preceding slash\\n+      start:\\n+      IntOp $R8 $R8 - 1\\n+      IntCmp $R8 -$R9 end end +1\\n+      StrCpy $R7 \\\"$INSTDIR\\\" 1 $R8\\n+      StrCmp $R7 \\\"\\\\\\\" +1 start\\n+\\n+      StrCpy $R9 \\\"$INSTDIR\\\" \\\"\\\" $R8\\n+\\n+      ClearErrors\\n+      GetFullPathName $R8 \\\"$PROGRAMFILES$R9\\\"\\n+      IfErrors end\\n+      GetFullPathName $R7 \\\"$INSTDIR\\\"\\n+\\n+      ; Compare the installation's directory path with the path created by\\n+      ; concatenating the installation's directory name and the path to the\\n+      ; program files directory.\\n+      StrCmp \\\"$R7\\\" \\\"$R8\\\" +1 end\\n+\\n+      StrCpy $R8 \\\"$PROGRAMFILES\\\" \\\"\\\" 2 ; Remove the drive letter and colon\\n+      StrCpy $R7 \\\"$PROFILE\\\\AppData\\\\Local\\\\VirtualStore$R8$R9\\\"\\n+\\n+      IfFileExists \\\"$R7\\\" 0 end\\n+      RmDir /r \\\"$R7\\\"\\n+\\n+      end:\\n+      ClearErrors\\n+\\n+      Pop $R7\\n+      Pop $R8\\n+      Pop $R9\\n+    FunctionEnd\\n+\\n+    !verbose pop\\n+  !endif\\n+!macroend\\n+\\n+!macro CleanVirtualStoreCall\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Call CleanVirtualStore\\n+  !verbose pop\\n+!macroend\\n+\\n+!macro un.CleanVirtualStoreCall\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Call un.CleanVirtualStore\\n+  !verbose pop\\n+!macroend\\n+\\n+!macro un.CleanVirtualStore\\n+  !ifndef un.CleanVirtualStore\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !undef _MOZFUNC_UN\\n+    !define _MOZFUNC_UN \\\"un.\\\"\\n+\\n+    !insertmacro CleanVirtualStore\\n+\\n+    !undef _MOZFUNC_UN\\n+    !define _MOZFUNC_UN\\n+    !verbose pop\\n+  !endif\\n+!macroend\\n+\\n+\\n+################################################################################\\n+# Macros for parsing and updating the uninstall.log and removed-files.log\\n+\\n+/**\\n+ * Updates the uninstall.log with new files added by software update.\\n+ *\\n+ * When modifying this macro be aware that LineFind uses all registers except\\n+ * $R0-$R3 so be cautious. Callers of this macro are not affected.\\n+ */\\n+!macro UpdateUninstallLog\\n+\\n+  !ifndef UpdateUninstallLog\\n+    !insertmacro FileJoin\\n+    !insertmacro LineFind\\n+    !insertmacro TextCompareNoDetails\\n+    !insertmacro TrimNewLines\\n+\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !define UpdateUninstallLog \\\"!insertmacro UpdateUninstallLogCall\\\"\\n+\\n+    Function UpdateUninstallLog\\n+      Push $R3\\n+      Push $R2\\n+      Push $R1\\n+      Push $R0\\n+\\n+      ClearErrors\\n+\\n+      GetFullPathName $R3 \\\"$INSTDIR\\\\uninstall\\\"\\n+      IfFileExists \\\"$R3\\\\uninstall.update\\\" +2 0\\n+      Return\\n+\\n+      ${LineFind} \\\"$R3\\\\uninstall.update\\\" \\\"\\\" \\\"1:-1\\\" \\\"CleanupUpdateLog\\\"\\n+\\n+      GetTempFileName $R2 \\\"$R3\\\"\\n+      FileOpen $R1 $R2 w\\n+      ${TextCompareNoDetails} \\\"$R3\\\\uninstall.update\\\" \\\"$R3\\\\uninstall.log\\\" \\\"SlowDiff\\\" \\\"CreateUpdateDiff\\\"\\n+      FileClose $R1\\n+\\n+      IfErrors +2 0\\n+      ${FileJoin} \\\"$R3\\\\uninstall.log\\\" \\\"$R2\\\" \\\"$R3\\\\uninstall.log\\\"\\n+\\n+      ${DeleteFile} \\\"$R2\\\"\\n+\\n+      ClearErrors\\n+\\n+      Pop $R0\\n+      Pop $R1\\n+      Pop $R2\\n+      Pop $R3\\n+    FunctionEnd\\n+\\n+    ; This callback MUST use labels vs. relative line numbers.\\n+    Function CleanupUpdateLog\\n+      StrCpy $R2 \\\"$R9\\\" 12\\n+      StrCmp \\\"$R2\\\" \\\"EXECUTE ADD \\\" +1 skip\\n+      StrCpy $R9 \\\"$R9\\\" \\\"\\\" 12\\n+\\n+      Push $R6\\n+      Push $R5\\n+      Push $R4\\n+      StrCpy $R4 \\\"\\\"         ; Initialize to an empty string.\\n+      StrCpy $R6 -1         ; Set the counter to -1 so it will start at 0.\\n+\\n+      loop:\\n+      IntOp $R6 $R6 + 1     ; Increment the counter.\\n+      StrCpy $R5 $R9 1 $R6  ; Starting from the counter copy the next char.\\n+      StrCmp $R5 \\\"\\\" copy    ; Are there no more chars?\\n+      StrCmp $R5 \\\"/\\\" +1 +2  ; Is the char a /?\\n+      StrCpy $R5 \\\"\\\\\\\"        ; Replace the char with a \\\\.\\n+\\n+      StrCpy $R4 \\\"$R4$R5\\\"\\n+      GoTo loop\\n+\\n+      copy:\\n+      StrCpy $R9 \\\"File: \\\\$R4\\\"\\n+      Pop $R6\\n+      Pop $R5\\n+      Pop $R4\\n+      GoTo end\\n+\\n+      skip:\\n+      StrCpy $0 \\\"SkipWrite\\\"\\n+\\n+      end:\\n+      Push $0\\n+    FunctionEnd\\n+\\n+    Function CreateUpdateDiff\\n+      ${TrimNewLines} \\\"$9\\\" $9\\n+      StrCmp $9 \\\"\\\" +2 +1\\n+      FileWrite $R1 \\\"$9$\\\\r$\\\\n\\\"\\n+\\n+      Push 0\\n+    FunctionEnd\\n+\\n+    !verbose pop\\n+  !endif\\n+!macroend\\n+\\n+!macro UpdateUninstallLogCall\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Call UpdateUninstallLog\\n+  !verbose pop\\n+!macroend\\n+\\n+/**\\n+ * Updates the uninstall.log with entries from uninstall.bak. The uninstall.bak\\n+ * is the uninstall.log renamed to uninstall.bak at the beginning of the\\n+ * installation\\n+ *\\n+ * When modifying this macro be aware that LineFind uses all registers except\\n+ * $R0-$R3 so be cautious. Callers of this macro are not affected.\\n+ */\\n+!macro UpdateFromPreviousLog\\n+\\n+  !ifndef UpdateFromPreviousLog\\n+    !insertmacro FileJoin\\n+    !insertmacro GetTime\\n+    !insertmacro TextCompareNoDetails\\n+    !insertmacro TrimNewLines\\n+\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !define UpdateFromPreviousLog \\\"!insertmacro UpdateFromPreviousLogCall\\\"\\n+\\n+    Function UpdateFromPreviousLog\\n+      Push $R9\\n+      Push $R8\\n+      Push $R7\\n+      Push $R6\\n+      Push $R5\\n+      Push $R4\\n+      Push $R3\\n+      Push $R2\\n+      Push $R1\\n+      Push $R0\\n+      Push $9\\n+\\n+      ; Diff and add missing entries from the previous file log if it exists\\n+      IfFileExists \\\"$INSTDIR\\\\uninstall\\\\uninstall.bak\\\" +1 end\\n+      StrCpy $R0 \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\"\\n+      StrCpy $R1 \\\"$INSTDIR\\\\uninstall\\\\uninstall.bak\\\"\\n+      GetTempFileName $R2\\n+      FileOpen $R3 $R2 w\\n+      ${TextCompareNoDetails} \\\"$R1\\\" \\\"$R0\\\" \\\"SlowDiff\\\" \\\"UpdateFromPreviousLog_AddToLog\\\"\\n+      FileClose $R3\\n+      IfErrors +2\\n+      ${FileJoin} \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\" \\\"$R2\\\" \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\"\\n+\\n+      ${DeleteFile} \\\"$INSTDIR\\\\uninstall\\\\uninstall.bak\\\"\\n+      ${DeleteFile} \\\"$R2\\\"\\n+\\n+      end:\\n+\\n+      Pop $9\\n+      Pop $R0\\n+      Pop $R1\\n+      Pop $R2\\n+      Pop $R3\\n+      Pop $R4\\n+      Pop $R5\\n+      Pop $R6\\n+      Pop $R7\\n+      Pop $R8\\n+      Push $R9\\n+    FunctionEnd\\n+\\n+    Function UpdateFromPreviousLog_AddToLog\\n+      ${TrimNewLines} \\\"$9\\\" $9\\n+      StrCmp $9 \\\"\\\" end +1\\n+      FileWrite $R3 \\\"$9$\\\\r$\\\\n\\\"\\n+      ${LogMsg} \\\"Added To Uninstall Log: $9\\\"\\n+\\n+      end:\\n+      Push 0\\n+    FunctionEnd\\n+\\n+    !verbose pop\\n+  !endif\\n+!macroend\\n+\\n+!macro UpdateFromPreviousLogCall\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Call UpdateFromPreviousLog\\n+  !verbose pop\\n+!macroend\\n+\\n+/**\\n+ * Parses the removed-files.log to remove files, and directories prior to\\n+ * installing.\\n+ *\\n+ * When modifying this macro be aware that LineFind uses all registers except\\n+ * $R0-$R3 so be cautious. Callers of this macro are not affected.\\n+ */\\n+!macro ParseRemovedFilesLog\\n+\\n+  !ifndef ParseRemovedFilesLog\\n+    !insertmacro LineFind\\n+    !insertmacro TrimNewLines\\n+\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !define ParseRemovedFilesLog \\\"!insertmacro ParseRemovedFilesLogCall\\\"\\n+\\n+    Function ParseRemovedFilesLog\\n+      Push $R9\\n+      Push $R8\\n+      Push $R7\\n+      Push $R6\\n+      Push $R5\\n+      Push $R4\\n+      Push $R3\\n+      Push $R2\\n+      Push $R1\\n+      Push $R0\\n+\\n+      IfFileExists \\\"$EXEDIR\\\\removed-files.log\\\" +1 end\\n+      ${LogHeader} \\\"Removing Obsolete Files and Directories\\\"\\n+      ${LineFind} \\\"$EXEDIR\\\\removed-files.log\\\" \\\"/NUL\\\" \\\"1:-1\\\" \\\"ParseRemovedFilesLog_RemoveFile\\\"\\n+      ${LineFind} \\\"$EXEDIR\\\\removed-files.log\\\" \\\"/NUL\\\" \\\"1:-1\\\" \\\"ParseRemovedFilesLog_RemoveDir\\\"\\n+\\n+      end:\\n+\\n+      Pop $R0\\n+      Pop $R1\\n+      Pop $R2\\n+      Pop $R3\\n+      Pop $R4\\n+      Pop $R5\\n+      Pop $R6\\n+      Pop $R7\\n+      Pop $R8\\n+      Pop $R9\\n+    FunctionEnd\\n+\\n+    Function ParseRemovedFilesLog_RemoveFile\\n+      ${TrimNewLines} \\\"$R9\\\" $R9\\n+      StrCpy $R1 \\\"$R9\\\" 5\\n+\\n+      StrCmp $R1 \\\"File:\\\" +1 end\\n+      StrCpy $R9 \\\"$R9\\\" \\\"\\\" 6\\n+      IfFileExists \\\"$INSTDIR$R9\\\" +1 end\\n+      ClearErrors\\n+      Delete \\\"$INSTDIR$R9\\\"\\n+      IfErrors +1 +3\\n+      ${LogMsg} \\\"** ERROR Deleting File: $INSTDIR$R9 **\\\"\\n+      GoTo end\\n+\\n+      ${LogMsg} \\\"Deleted File: $INSTDIR$R9\\\"\\n+\\n+      end:\\n+      ClearErrors\\n+\\n+      Push 0\\n+    FunctionEnd\\n+\\n+    ; The xpinstall based installer removed directories even when they aren't\\n+    ; empty so this does as well.\\n+    Function ParseRemovedFilesLog_RemoveDir\\n+      ${TrimNewLines} \\\"$R9\\\" $R9\\n+      StrCpy $R1 \\\"$R9\\\" 4\\n+      StrCmp \\\"$R1\\\" \\\"Dir:\\\" +1 end\\n+      StrCpy $R9 \\\"$R9\\\" \\\"\\\" 5\\n+      StrCpy $R1 \\\"$R9\\\" \\\"\\\" -1\\n+\\n+      StrCmp \\\"$R1\\\" \\\"\\\\\\\" +1 +2\\n+      StrCpy $R9 \\\"$R9\\\" -1\\n+\\n+      IfFileExists \\\"$INSTDIR$R9\\\" +1 end\\n+      ClearErrors\\n+      RmDir /r \\\"$INSTDIR$R9\\\"\\n+      IfErrors +1 +3\\n+      ${LogMsg} \\\"** ERROR Removing Directory: $INSTDIR$R9 **\\\"\\n+      GoTo end\\n+\\n+      ${LogMsg} \\\"Removed Directory: $INSTDIR$R9\\\"\\n+\\n+      end:\\n+      ClearErrors\\n+\\n+      Push 0\\n+    FunctionEnd\\n+\\n+    !verbose pop\\n+  !endif\\n+!macroend\\n+\\n+!macro ParseRemovedFilesLogCall\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Call ParseRemovedFilesLog\\n+  !verbose pop\\n+!macroend\\n+\\n+/**\\n+ * Parses the uninstall.log to unregister dll's, remove files, and remove\\n+ * empty directories for this installation.\\n+ *\\n+ * When modifying this macro be aware that LineFind uses all registers except\\n+ * $R0-$R3 so be cautious. Callers of this macro are not affected.\\n+ */\\n+!macro un.ParseUninstallLog\\n+\\n+  !ifndef un.ParseUninstallLog\\n+    !insertmacro un.LineFind\\n+    !insertmacro un.TrimNewLines\\n+\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !define un.ParseUninstallLog \\\"!insertmacro un.ParseUninstallLogCall\\\"\\n+\\n+    Function un.ParseUninstallLog\\n+      Push $R9\\n+      Push $R8\\n+      Push $R7\\n+      Push $R6\\n+      Push $R5\\n+      Push $R4\\n+      Push $R3\\n+      Push $R2\\n+      Push $R1\\n+      Push $R0\\n+\\n+      IfFileExists \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\" +1 end\\n+\\n+      ; Copy the uninstall log file to a temporary file\\n+      GetTempFileName $TmpVal\\n+      CopyFiles /SILENT /FILESONLY \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\" \\\"$TmpVal\\\"\\n+\\n+      ; Unregister DLL's\\n+      ${un.LineFind} \\\"$TmpVal\\\" \\\"/NUL\\\" \\\"1:-1\\\" \\\"un.UnRegDLLsCallback\\\"\\n+\\n+      ; Delete files\\n+      ${un.LineFind} \\\"$TmpVal\\\" \\\"/NUL\\\" \\\"1:-1\\\" \\\"un.RemoveFilesCallback\\\"\\n+\\n+      ; Remove empty directories\\n+      ${un.LineFind} \\\"$TmpVal\\\" \\\"/NUL\\\" \\\"1:-1\\\" \\\"un.RemoveDirsCallback\\\"\\n+\\n+      ; Delete the temporary uninstall log file\\n+      ${DeleteFile} \\\"$TmpVal\\\"\\n+\\n+      end:\\n+\\n+      Pop $R0\\n+      Pop $R1\\n+      Pop $R2\\n+      Pop $R3\\n+      Pop $R4\\n+      Pop $R5\\n+      Pop $R6\\n+      Pop $R7\\n+      Pop $R8\\n+      Pop $R9\\n+    FunctionEnd\\n+\\n+    Function un.RemoveFilesCallback\\n+      ${un.TrimNewLines} \\\"$R9\\\" $R9\\n+      StrCpy $R1 \\\"$R9\\\" 5\\n+\\n+      StrCmp \\\"$R1\\\" \\\"File:\\\" +1 end\\n+      StrCpy $R9 \\\"$R9\\\" \\\"\\\" 6\\n+      StrCpy $R0 \\\"$R9\\\" 1\\n+\\n+      StrCpy $R1 \\\"$INSTDIR$R9\\\"\\n+      StrCmp \\\"$R0\\\" \\\"\\\\\\\" +2 +1\\n+      StrCpy $R1 \\\"$R9\\\"\\n \\n-  !ifndef ${_MOZFUNC_UN}GetPathFromString\\n-    !verbose push\\n-    !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}GetPathFromString \\\"!insertmacro ${_MOZFUNC_UN}GetPathFromStringCall\\\"\\n+      ${DeleteFile} \\\"$R1\\\"\\n \\n-    Function ${_MOZFUNC_UN}GetPathFromString\\n-      Exch $R9\\n-      Exch 1\\n-      Exch $R8\\n-      Push $R7\\n-      Push $R6\\n+      end:\\n       ClearErrors\\n \\n-      StrCpy $R9 $R8\\n-      StrCpy $R6 0          ; Set the counter to 0.\\n+      Push 0\\n+    FunctionEnd\\n+\\n+    Function un.UnRegDLLsCallback\\n+      ${un.TrimNewLines} \\\"$R9\\\" $R9\\n+      StrCpy $R1 \\\"$R9\\\" 7\\n+\\n+      StrCmp $R1 \\\"DLLReg:\\\" +1 end\\n+      StrCpy $R9 \\\"$R9\\\" \\\"\\\" 8\\n+      StrCpy $R0 \\\"$R9\\\" 1\\n+\\n+      StrCpy $R1 \\\"$INSTDIR$R9\\\"\\n+      StrCmp $R0 \\\"\\\\\\\" +2 +1\\n+      StrCpy $R1 \\\"$R9\\\"\\n \\n+      UnRegDLL $R1\\n+\\n+      end:\\n       ClearErrors\\n-      ; Handle quoted paths with arguments.\\n-      StrCpy $R7 $R9 1      ; Copy the first char.\\n-      StrCmp $R7 '\\\"' +2 +1  ; Is it a \\\"?\\n-      StrCmp $R7 \\\"'\\\" +1 +9  ; Is it a '?\\n-      StrCpy $R9 $R9 \\\"\\\" 1   ; Remove the first char.\\n-      IntOp $R6 $R6 + 1     ; Increment the counter.\\n-      StrCpy $R7 $R9 1 $R6  ; Starting from the counter copy the next char.\\n-      StrCmp $R7 \\\"\\\" end     ; Are there no more chars?\\n-      StrCmp $R7 '\\\"' +2 +1  ; Is it a \\\" char?\\n-      StrCmp $R7 \\\"'\\\" +1 -4  ; Is it a ' char?\\n-      StrCpy $R9 $R9 $R6    ; Copy chars up to the counter.\\n-      GoTo end\\n \\n-      ; Handle DefaultIcon paths. DefaultIcon paths are not quoted and end with\\n-      ; a , and a number.\\n-      IntOp $R6 $R6 - 1     ; Decrement the counter.\\n-      StrCpy $R7 $R9 1 $R6  ; Copy one char from the end minus the counter.\\n-      StrCmp $R7 '' +4      ; Are there no more chars?\\n-      StrCmp $R7 ',' +1 -3  ; Is it a , char?\\n-      StrCpy $R9 $R9 $R6    ; Copy chars up to the end minus the counter.\\n-      GoTo end\\n+      Push 0\\n+    FunctionEnd\\n \\n-      ; Handle unquoted paths with arguments. An unquoted path with arguments\\n-      ; must be an 8dot3 path.\\n-      StrCpy $R6 -1          ; Set the counter to -1 so it will start at 0.\\n-      IntOp $R6 $R6 + 1      ; Increment the counter.\\n-      StrCpy $R7 $R9 1 $R6   ; Starting from the counter copy the next char.\\n-      StrCmp $R7 \\\"\\\" end      ; Are there no more chars?\\n-      StrCmp $R7 \\\" \\\" +1 -3   ; Is it a space char?\\n-      StrCpy $R9 $R9 $R6     ; Copy chars up to the counter.\\n+    ; Using locate will leave file handles open to some of the directories\\n+    ; which will prevent the deletion of these directories. This parses the\\n+    ; uninstall.log and uses the file entries to find / remove empty\\n+    ; directories.\\n+    Function un.RemoveDirsCallback\\n+      ${un.TrimNewLines} \\\"$R9\\\" $R9\\n+      StrCpy $R0 \\\"$R9\\\" 5          ; Copy the first five chars\\n+      StrCmp \\\"$R0\\\" \\\"File:\\\" +1 end\\n+\\n+      StrCpy $R9 \\\"$R9\\\" \\\"\\\" 6       ; Copy string starting after the 6th char\\n+      StrCpy $R0 \\\"$R9\\\" 1          ; Copy the first char\\n+\\n+      StrCpy $R1 \\\"$INSTDIR$R9\\\"    ; Copy the install dir path and suffix it with the string\\n+      StrCmp \\\"$R0\\\" \\\"\\\\\\\" loop       ; If this is a relative path goto the loop\\n+      StrCpy $R1 \\\"$R9\\\"            ; Already a full path so copy the string\\n+\\n+      loop:\\n+      ${un.GetParent} \\\"$R1\\\" $R1   ; Get the parent directory for the path\\n+      StrCmp \\\"$R1\\\" \\\"$INSTDIR\\\" end ; If the directory is the install dir goto end\\n+\\n+      ; We only try to remove empty directories but the Desktop, StartMenu, and\\n+      ; QuickLaunch directories can be empty so guard against removing them.\\n+      SetShellVarContext all          ; Set context to all users\\n+      StrCmp \\\"$R1\\\" \\\"$DESKTOP\\\" end     ; All users desktop\\n+      StrCmp \\\"$R1\\\" \\\"$STARTMENU\\\" end   ; All users start menu\\n+\\n+      SetShellVarContext current      ; Set context to all users\\n+      StrCmp \\\"$R1\\\" \\\"$DESKTOP\\\" end     ; Current user desktop\\n+      StrCmp \\\"$R1\\\" \\\"$STARTMENU\\\" end   ; Current user start menu\\n+      StrCmp \\\"$R1\\\" \\\"$QUICKLAUNCH\\\" end ; Current user quick launch\\n+\\n+      IfFileExists \\\"$R1\\\" +1 +3  ; Only try to remove the dir if it exists\\n+      ClearErrors\\n+      RmDir \\\"$R1\\\"    ; Remove the dir\\n+      IfErrors end   ; If we fail there is no use trying to remove its parent dir\\n+\\n+      StrCmp \\\"$R0\\\" \\\"\\\\\\\" loop end  ; Only loop when the path is relative to the install dir\\n \\n       end:\\n+      ClearErrors\\n \\n-      Pop $R6\\n-      Pop $R7\\n-      Exch $R8\\n-      Exch 1\\n-      Exch $R9\\n+      Push 0\\n     FunctionEnd\\n \\n     !verbose pop\\n   !endif\\n !macroend\\n \\n-!macro GetPathFromStringCall _IN_PATH _OUT_PATH\\n+!macro un.ParseUninstallLogCall\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_IN_PATH}\\\"\\n-  Push \\\"${_OUT_PATH}\\\"\\n-  Call GetPathFromString\\n-  Pop ${_OUT_PATH}\\n+  Call un.ParseUninstallLog\\n   !verbose pop\\n !macroend\\n \\n-!macro un.GetPathFromStringCall _IN_PATH _OUT_PATH\\n-  !verbose push\\n-  !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_IN_PATH}\\\"\\n-  Push \\\"${_OUT_PATH}\\\"\\n-  Call un.GetPathFromString\\n-  Pop ${_OUT_PATH}\\n-  !verbose pop\\n-!macroend\\n \\n-!macro un.GetPathFromString\\n-  !ifndef un.GetPathFromString\\n+################################################################################\\n+# User interface callback helper defines and macros\\n+\\n+/* Install type defines */\\n+!ifndef INSTALLTYPE_BASIC\\n+  !define INSTALLTYPE_BASIC     1\\n+!endif\\n+\\n+!ifndef INSTALLTYPE_ADVANCED\\n+  !define INSTALLTYPE_ADVANCED  2\\n+!endif\\n+\\n+!ifndef INSTALLTYPE_CUSTOM\\n+  !define INSTALLTYPE_CUSTOM    4\\n+!endif\\n+\\n+/**\\n+ * Checks whether to display the current page (e.g. if not performing a custom\\n+ * install don't display the custom pages).\\n+ */\\n+!macro CheckCustomCommon\\n+\\n+  !ifndef CheckCustomCommon\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !undef _MOZFUNC_UN\\n-    !define _MOZFUNC_UN \\\"un.\\\"\\n+    !define CheckCustomCommon \\\"!insertmacro CheckCustomCommonCall\\\"\\n \\n-    !insertmacro GetPathFromString\\n+    Function CheckCustomCommon\\n+\\n+      ; Abort if not a custom install\\n+      IntCmp $InstallType ${INSTALLTYPE_CUSTOM} +2 +1 +1\\n+      Abort\\n+\\n+    FunctionEnd\\n \\n-    !undef _MOZFUNC_UN\\n-    !define _MOZFUNC_UN\\n     !verbose pop\\n   !endif\\n !macroend\\n \\n+!macro CheckCustomCommonCall\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Call CheckCustomCommon\\n+  !verbose pop\\n+!macroend\\n+\\n /**\\n- * Removes the quotes from each end of a string if present.\\n+ * Called from the installer's .onInit function not to be confused with the\\n+ * uninstaller's .onInit or the uninstaller's un.onInit functions.\\n  *\\n- * @param   _IN_PATH\\n- *          The string containing the path.\\n- * @param   _OUT_PATH\\n- *          The register to store the long path.\\n+ * @param   _WARN_UNSUPPORTED_MSG\\n+ *          Message displayed when the Windows version is not supported.\\n  *\\n- * $R7 = \\n- * $R8 = _IN_PATH\\n- * $R9 = _OUT_PATH\\n+ * $R5 = return value from the GetSize macro\\n+ * $R6 = general string values, return value from GetTempFileName, return\\n+ *       value from the GetSize macro\\n+ * $R7 = full path to the configuration ini file\\n+ * $R8 = return value from the GetParameters macro\\n+ * $R9 = _WARN_UNSUPPORTED_MSG\\n  */\\n-!macro RemoveQuotesFromPath\\n+!macro InstallOnInitCommon\\n+\\n+  !ifndef InstallOnInitCommon\\n+    !insertmacro CloseApp\\n+    !insertmacro GetOptions\\n+    !insertmacro GetParameters\\n+    !insertmacro GetSize\\n \\n-  !ifndef ${_MOZFUNC_UN}RemoveQuotesFromPath\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}RemoveQuotesFromPath \\\"!insertmacro ${_MOZFUNC_UN}RemoveQuotesFromPathCall\\\"\\n+    !define InstallOnInitCommon \\\"!insertmacro InstallOnInitCommonCall\\\"\\n \\n-    Function ${_MOZFUNC_UN}RemoveQuotesFromPath\\n+    Function InstallOnInitCommon\\n       Exch $R9\\n-      Exch 1\\n-      Exch $R8\\n+      Push $R8\\n       Push $R7\\n+      Push $R6\\n+      Push $R5\\n \\n-      StrCpy $R9 \\\"$R8\\\"\\n-\\n-      StrCpy $R7 \\\"$R9\\\" 1\\n-      StrCmp $R7 \\\"$\\\\\\\"\\\" +1 +2\\n-      StrCpy $R9 \\\"$R9\\\" \\\"\\\" 1\\n-\\n-      StrCpy $R7 \\\"$R9\\\" \\\"\\\" -1\\n-      StrCmp $R7 \\\"$\\\\\\\"\\\" +1 +2\\n-      StrCpy $R9 \\\"$R9\\\" -1\\n+      !ifdef ___WINVER__NSH___\\n+        ${Unless} ${AtLeastWin2000}\\n+          MessageBox MB_OK|MB_ICONSTOP \\\"$R9\\\" IDOK\\n+          Quit\\n+        ${EndUnless}\\n+      !endif\\n+\\n+      ${GetParameters} $R8\\n+      ${If} $R8 != \\\"\\\"\\n+        ClearErrors\\n+        ${GetOptions} \\\"$R8\\\" \\\"-ms\\\" $R7\\n+        ${If} ${Errors}\\n+          ; Default install type\\n+          StrCpy $InstallType ${INSTALLTYPE_BASIC}\\n+          ; Support for specifying an installation configuration file.\\n+          ClearErrors\\n+          ${GetOptions} \\\"$R8\\\" \\\"/INI=\\\" $R7\\n+          ${Unless} ${Errors}\\n+            ; The configuration file must also exist\\n+            ${If} ${FileExists} \\\"$R7\\\"\\n+              SetSilent silent\\n+              ReadINIStr $R8 $R7 \\\"Install\\\" \\\"InstallDirectoryName\\\"\\n+              ${If} $R8 != \\\"\\\"\\n+                StrCpy $INSTDIR \\\"$PROGRAMFILES\\\\$R8\\\"\\n+              ${Else}\\n+                ReadINIStr $R8 $R7 \\\"Install\\\" \\\"InstallDirectoryPath\\\"\\n+                ${If} $R8 != \\\"\\\"\\n+                  StrCpy $INSTDIR \\\"$R8\\\"\\n+                ${EndIf}\\n+              ${EndIf}\\n+\\n+              ${If} $INSTDIR == \\\"\\\"\\n+                ; Check if there is an existing uninstall registry entry for this\\n+                ; version of the application and if present install into that location\\n+                StrCpy $R6 \\\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\\\\${BrandFullNameInternal} (${AppVersion})\\\"\\n+                ReadRegStr $R8 HKLM \\\"$R6\\\" \\\"InstallLocation\\\"\\n+                ${If} $R8 == \\\"\\\"\\n+                  StrCpy $INSTDIR \\\"$PROGRAMFILES\\\\${BrandFullName}\\\"\\n+                ${Else}\\n+                  GetFullPathName $INSTDIR \\\"$R8\\\"\\n+                  ${Unless} ${FileExists} \\\"$INSTDIR\\\"\\n+                    StrCpy $INSTDIR \\\"$PROGRAMFILES\\\\${BrandFullName}\\\"\\n+                  ${EndUnless}\\n+                ${EndIf}\\n+              ${EndIf}\\n+\\n+              ; Quit if we are unable to create the installation directory or we are\\n+              ; unable to write to a file in the installation directory.\\n+              ClearErrors\\n+              ${If} ${FileExists} \\\"$INSTDIR\\\"\\n+                GetTempFileName $R6 \\\"$INSTDIR\\\"\\n+                FileOpen $R5 $R6 w\\n+                FileWrite $R5 \\\"Write Access Test\\\"\\n+                FileClose $R5\\n+                Delete $R6\\n+                ${If} ${Errors}\\n+                  Quit\\n+                ${EndIf}\\n+              ${Else}\\n+                CreateDirectory \\\"$INSTDIR\\\"\\n+                ${If} ${Errors}\\n+                  Quit\\n+                ${EndIf}\\n+              ${EndIf}\\n+\\n+              ReadINIStr $R8 $R7 \\\"Install\\\" \\\"CloseAppNoPrompt\\\"\\n+              ${If} $R8 == \\\"true\\\"\\n+                ; Try to close the app if the exe is in use.\\n+                ClearErrors\\n+                ${If} ${FileExists} \\\"$INSTDIR\\\\${FileMainEXE}\\\"\\n+                  ${DeleteFile} \\\"$INSTDIR\\\\${FileMainEXE}\\\"\\n+                ${EndIf}\\n+                ${If} ${Errors}\\n+                  ClearErrors\\n+                  ${CloseApp} \\\"false\\\" \\\"\\\"\\n+                  ClearErrors\\n+                  ${DeleteFile} \\\"$INSTDIR\\\\${FileMainEXE}\\\"\\n+                  ; If unsuccessful try one more time and if it still fails Quit\\n+                  ${If} ${Errors}\\n+                    ClearErrors\\n+                    ${CloseApp} \\\"false\\\" \\\"\\\"\\n+                    ClearErrors\\n+                    ${DeleteFile} \\\"$INSTDIR\\\\${FileMainEXE}\\\"\\n+                    ${If} ${Errors}\\n+                      Quit\\n+                    ${EndIf}\\n+                  ${EndIf}\\n+                ${EndIf}\\n+              ${EndIf}\\n+\\n+              ReadINIStr $R8 $R7 \\\"Install\\\" \\\"QuickLaunchShortcut\\\"\\n+              ${If} $R8 == \\\"false\\\"\\n+                StrCpy $AddQuickLaunchSC \\\"0\\\"\\n+              ${Else}\\n+                StrCpy $AddQuickLaunchSC \\\"1\\\"\\n+              ${EndIf}\\n+\\n+              ReadINIStr $R8 $R7 \\\"Install\\\" \\\"DesktopShortcut\\\"\\n+              ${If} $R8 == \\\"false\\\"\\n+                StrCpy $AddDesktopSC \\\"0\\\"\\n+              ${Else}\\n+                StrCpy $AddDesktopSC \\\"1\\\"\\n+              ${EndIf}\\n+\\n+              ReadINIStr $R8 $R7 \\\"Install\\\" \\\"StartMenuShortcuts\\\"\\n+              ${If} $R8 == \\\"false\\\"\\n+                StrCpy $AddStartMenuSC \\\"0\\\"\\n+              ${Else}\\n+                StrCpy $AddStartMenuSC \\\"1\\\"\\n+              ${EndIf}\\n+\\n+              ReadINIStr $R8 $R7 \\\"Install\\\" \\\"StartMenuDirectoryName\\\"\\n+              ${If} $R8 != \\\"\\\"\\n+                StrCpy $StartMenuDir \\\"$R8\\\"\\n+              ${EndIf}\\n+            ${EndIf}\\n+          ${EndUnless}\\n+        ${Else}\\n+          ; Support for the deprecated -ms command line argument. The new command\\n+          ; line arguments are not supported when -ms is used.\\n+          SetSilent silent\\n+        ${EndIf}\\n+      ${EndIf}\\n+      ClearErrors\\n \\n+      Pop $R5\\n+      Pop $R6\\n       Pop $R7\\n-      Exch $R8\\n-      Exch 1\\n+      Pop $R8\\n       Exch $R9\\n     FunctionEnd\\n \\n@@ -2089,90 +3091,175 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n   !endif\\n !macroend\\n \\n-!macro RemoveQuotesFromPathCall _IN_PATH _OUT_PATH\\n+!macro InstallOnInitCommonCall _WARN_UNSUPPORTED_MSG\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_IN_PATH}\\\"\\n-  Push \\\"${_OUT_PATH}\\\"\\n-  Call RemoveQuotesFromPath\\n-  Pop ${_OUT_PATH}\\n+  Push ${_WARN_UNSUPPORTED_MSG}\\n+  Call InstallOnInitCommon\\n   !verbose pop\\n !macroend\\n \\n-!macro un.RemoveQuotesFromPathCall _IN_PATH _OUT_PATH\\n-  !verbose push\\n-  !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_IN_PATH}\\\"\\n-  Push \\\"${_OUT_PATH}\\\"\\n-  Call un.RemoveQuotesFromPath\\n-  Pop ${_OUT_PATH}\\n-  !verbose pop\\n-!macroend\\n+/**\\n+ * Called from the uninstaller's .onInit function not to be confused with the\\n+ * installer's .onInit or the uninstaller's un.onInit functions.\\n+ */\\n+!macro UninstallOnInitCommon\\n+\\n+  !ifndef UninstallOnInitCommon\\n+    !insertmacro GetLongPath\\n+    !insertmacro GetOptions\\n+    !insertmacro GetParameters\\n+    !insertmacro UpdateUninstallLog\\n \\n-!macro un.RemoveQuotesFromPath\\n-  !ifndef un.RemoveQuotesFromPath\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !undef _MOZFUNC_UN\\n-    !define _MOZFUNC_UN \\\"un.\\\"\\n+    !define UninstallOnInitCommon \\\"!insertmacro UninstallOnInitCommonCall\\\"\\n \\n-    !insertmacro RemoveQuotesFromPath\\n+    Function UninstallOnInitCommon\\n+\\n+      GetFullPathName $INSTDIR \\\"$EXEDIR\\\\..\\\"\\n+      ${GetLongPath} \\\"$INSTDIR\\\" $INSTDIR\\n+      IfFileExists \\\"$INSTDIR\\\\${FileMainEXE}\\\" +2 +1\\n+      Abort\\n+\\n+      ${GetParameters} $R0\\n+\\n+      StrCmp \\\"$R0\\\" \\\"\\\" continue +1\\n+\\n+      StrCmp \\\"$R0\\\" \\\"/HideShortcuts\\\" +1 showshortcuts\\n+      ${HideShortcuts}\\n+      StrCpy $R1 \\\"true\\\"\\n+      StrCmp \\\"$R1\\\" \\\"true\\\" continue\\n+\\n+      showshortcuts:\\n+      StrCmp \\\"$R0\\\" \\\"/ShowShortcuts\\\" +1 defaultappuser\\n+      ${ShowShortcuts}\\n+      StrCpy $R1 \\\"true\\\"\\n+      GoTo continue\\n+\\n+      defaultappuser:\\n+      StrCmp \\\"$R0\\\" \\\"/SetAsDefaultAppUser\\\" +1 defaultappglobal\\n+      ${SetAsDefaultAppUser}\\n+      StrCpy $R1 \\\"true\\\"\\n+      GoTo continue\\n+\\n+      defaultappglobal:\\n+      StrCmp \\\"$R0\\\" \\\"/SetAsDefaultAppGlobal\\\" +1 postupdate\\n+      ${SetAsDefaultAppGlobal}\\n+      StrCpy $R1 \\\"true\\\"\\n+      GoTo continue\\n+\\n+      postupdate:\\n+      ${WordReplace} \\\"$R0\\\" \\\"$\\\\\\\"\\\" \\\"\\\" \\\"+\\\" $R0\\n+      ClearErrors\\n+      ${GetOptions} \\\"$R0\\\" \\\"/PostUpdate\\\" $R2\\n+      IfErrors continue +1\\n+      ${PostUpdate}\\n+      ClearErrors\\n+      ${GetOptions} \\\"$R0\\\" \\\"/UninstallLog=\\\" $R2\\n+      IfErrors +1 +4\\n+      ${UpdateUninstallLog}\\n+      StrCpy $R1 \\\"true\\\"\\n+      GoTo continue\\n+\\n+      StrCmp \\\"$R2\\\" \\\"\\\" continue +1\\n+      GetFullPathName $R3 \\\"$R2\\\"\\n+      IfFileExists \\\"$R3\\\" +1 continue\\n+      Delete \\\"$INSTDIR\\\\uninstall\\\\*wizard*\\\"\\n+      Delete \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\"\\n+      CopyFiles /SILENT /FILESONLY \\\"$R3\\\" \\\"$INSTDIR\\\\uninstall\\\\\\\"\\n+      ${GetParent} \\\"$R3\\\" $R4\\n+      Delete \\\"$R3\\\"\\n+      RmDir \\\"$R4\\\"\\n+      StrCpy $R1 \\\"true\\\"\\n+\\n+      continue:\\n+\\n+      StrCmp $R1 \\\"true\\\" +1 +3\\n+      System::Call \\\"shell32::SHChangeNotify(i, i, i, i) v (0x08000000, 0, 0, 0)\\\"\\n+      Quit\\n+\\n+      ; If we made it this far then this installer is being used as an uninstaller.\\n+      WriteUninstaller \\\"$EXEDIR\\\\uninstaller.exe\\\"\\n+\\n+      StrCpy $R1 \\\"$\\\\\\\"$EXEDIR\\\\uninstaller.exe$\\\\\\\"\\\"\\n+      StrCmp $R0 \\\"/S\\\" +1 +2\\n+      StrCpy $R1 \\\"$\\\\\\\"$EXEDIR\\\\uninstaller.exe$\\\\\\\" /S\\\"\\n+\\n+      ; When the uninstaller is launched it copies itself to the temp directory\\n+      ; so it won't be in use so it can delete itself.\\n+      ExecWait $R1\\n+      ${DeleteFile} \\\"$EXEDIR\\\\uninstaller.exe\\\"\\n+      SetErrorLevel 0\\n+      Quit\\n+\\n+    FunctionEnd\\n \\n-    !undef _MOZFUNC_UN\\n-    !define _MOZFUNC_UN\\n     !verbose pop\\n   !endif\\n !macroend\\n \\n+!macro UninstallOnInitCommonCall\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Call UninstallOnInitCommon\\n+  !verbose pop\\n+!macroend\\n+\\n /**\\n- * If present removes the VirtualStore directory for this installation. Uses the\\n- * program files directory path and the current install location to determine\\n- * the sub-directory in the VirtualStore directory.\\n+ * Called from the MUI preDirectory function\\n+ *\\n+ * $R9 = returned value from GetSingleInstallPath, CheckDiskSpace, and\\n+ *       CanWriteToInstallDir macros\\n  */\\n-!macro CleanVirtualStore\\n+!macro PreDirectoryCommon\\n+\\n+  !ifndef PreDirectoryCommon\\n+    !insertmacro CanWriteToInstallDir\\n+    !insertmacro CheckDiskSpace\\n+    !insertmacro GetLongPath\\n+    !insertmacro GetSingleInstallPath\\n \\n-  !ifndef ${_MOZFUNC_UN}CleanVirtualStore\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}CleanVirtualStore \\\"!insertmacro ${_MOZFUNC_UN}CleanVirtualStoreCall\\\"\\n+    !define PreDirectoryCommon \\\"!insertmacro PreDirectoryCommonCall\\\"\\n \\n-    Function ${_MOZFUNC_UN}CleanVirtualStore\\n+    Function PreDirectoryCommon\\n       Push $R9\\n-      Push $R8\\n-      Push $R7\\n \\n-      StrLen $R9 \\\"$INSTDIR\\\"\\n+      SetShellVarContext all      ; Set SHCTX to HKLM\\n+      ${GetSingleInstallPath} \\\"Software\\\\Mozilla\\\\${BrandFullNameInternal}\\\" $R9\\n \\n-      ; Get the installation's directory name including the preceding slash\\n-      start:\\n-      IntOp $R8 $R8 - 1\\n-      IntCmp $R8 -$R9 end end 0\\n-      StrCpy $R7 \\\"$INSTDIR\\\" 1 $R8\\n-      StrCmp $R7 \\\"\\\\\\\" 0 start\\n+      StrCmp \\\"$R9\\\" \\\"false\\\" +1 fix_install_dir\\n \\n-      StrCpy $R9 \\\"$INSTDIR\\\" \\\"\\\" $R8\\n+      SetShellVarContext current  ; Set SHCTX to HKCU\\n+      ${GetSingleInstallPath} \\\"Software\\\\Mozilla\\\\${BrandFullNameInternal}\\\" $R9\\n \\n-      ClearErrors\\n-      GetFullPathName $R8 \\\"$PROGRAMFILES$R9\\\"\\n-      IfErrors end\\n-      GetFullPathName $R7 \\\"$INSTDIR\\\"\\n+      fix_install_dir:\\n+      StrCmp \\\"$R9\\\" \\\"false\\\" +2 +1\\n+      StrCpy $INSTDIR \\\"$R9\\\"\\n \\n-      ; Compare the installation's directory path with the path created by\\n-      ; concatenating the installation's directory name and the path to the\\n-      ; program files directory.\\n-      StrCmp \\\"$R7\\\" \\\"$R8\\\" 0 end\\n+      IfFileExists \\\"$INSTDIR\\\" +1 check_install_dir\\n \\n-      StrCpy $R8 \\\"$PROGRAMFILES\\\" \\\"\\\" 2 ; Remove the drive letter and colon\\n-      StrCpy $R7 \\\"$PROFILE\\\\AppData\\\\Local\\\\VirtualStore$R8$R9\\\"\\n+      ; Always display the long path if the path already exists.\\n+      ${GetLongPath} \\\"$INSTDIR\\\" $INSTDIR\\n \\n-      IfFileExists \\\"$R7\\\" 0 end\\n-      RmDir /r \\\"$R7\\\"\\n+      ; The call to GetLongPath returns a long path without a trailing\\n+      ; back-slash. Append a \\\\ to the path to prevent the directory\\n+      ; name from being appended when using the NSIS create new folder.\\n+      ; http://www.nullsoft.com/free/nsis/makensis.htm#InstallDir\\n+      StrCpy $INSTDIR \\\"$INSTDIR\\\\\\\"\\n+\\n+      check_install_dir:\\n+      IntCmp $InstallType ${INSTALLTYPE_CUSTOM} end +1 +1\\n+      ${CheckDiskSpace} $R9\\n+      StrCmp $R9 \\\"false\\\" end +1\\n+      ${CanWriteToInstallDir} $R9\\n+      StrCmp $R9 \\\"false\\\" end +1\\n+      Abort\\n \\n       end:\\n-      ClearErrors\\n \\n-      Pop $R7\\n-      Pop $R8\\n       Pop $R9\\n     FunctionEnd\\n \\n@@ -2180,261 +3267,322 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n   !endif\\n !macroend\\n \\n-!macro CleanVirtualStoreCall\\n-  !verbose push\\n-  !verbose ${_MOZFUNC_VERBOSE}\\n-  Call CleanVirtualStore\\n-  !verbose pop\\n-!macroend\\n-\\n-!macro un.CleanVirtualStoreCall\\n+!macro PreDirectoryCommonCall\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Call un.CleanVirtualStore\\n+  Call PreDirectoryCommon\\n   !verbose pop\\n !macroend\\n \\n-!macro un.CleanVirtualStore\\n-  !ifndef un.CleanVirtualStore\\n-    !verbose push\\n-    !verbose ${_MOZFUNC_VERBOSE}\\n-    !undef _MOZFUNC_UN\\n-    !define _MOZFUNC_UN \\\"un.\\\"\\n-\\n-    !insertmacro CleanVirtualStore\\n-\\n-    !undef _MOZFUNC_UN\\n-    !define _MOZFUNC_UN\\n-    !verbose pop\\n-  !endif\\n-!macroend\\n-\\n /**\\n- * Updates the uninstall.log with new files added by software update.\\n+ * Called from the MUI leaveDirectory function\\n+ *\\n+ * @param   _WARN_DISK_SPACE\\n+ *          Message displayed when there isn't enough disk space to perform the\\n+ *          installation.\\n+ *          $INSTDIR.\\n+ * @param   _WARN_WRITE_ACCESS\\n+ *          Message displayed when the installer does not have write access to\\n+ *          $INSTDIR.\\n  *\\n- * IMPORTANT! The LineFind docs claim that it uses all registers except $R0-$R3.\\n- *            Though it appears that this is not true all registers besides\\n- *            $R0-$R3 may be overwritten so protect yourself!\\n+ * $R7 = returned value from CheckDiskSpace and CanWriteToInstallDir macros\\n+ * $R8 = _WARN_DISK_SPACE\\n+ * $R9 = _WARN_WRITE_ACCESS\\n  */\\n-!macro UpdateUninstallLog\\n+!macro LeaveDirectoryCommon\\n \\n-  !insertmacro ${_MOZFUNC_UN}FileJoin\\n-  !insertmacro ${_MOZFUNC_UN}LineFind\\n-  !insertmacro ${_MOZFUNC_UN}TextCompareNoDetails\\n-  !insertmacro ${_MOZFUNC_UN}TrimNewLines\\n+  !ifndef LeaveDirectoryCommon\\n+    !insertmacro CheckDiskSpace\\n+    !insertmacro CanWriteToInstallDir\\n \\n-  !ifndef ${_MOZFUNC_UN}UpdateUninstallLog\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}UpdateUninstallLog \\\"!insertmacro ${_MOZFUNC_UN}UpdateUninstallLogCall\\\"\\n+    !define LeaveDirectoryCommon \\\"!insertmacro LeaveDirectoryCommonCall\\\"\\n \\n-    Function ${_MOZFUNC_UN}UpdateUninstallLog\\n-      Push $R3\\n-      Push $R2\\n-      Push $R1\\n-      Push $R0\\n+    Function LeaveDirectoryCommon\\n+      Exch $R9\\n+      Exch 1\\n+      Exch $R8\\n+      Push $R7\\n \\n-      ClearErrors\\n+      ${CheckDiskSpace} $R7\\n+      StrCmp $R7 \\\"false\\\" +1 +3\\n+      MessageBox MB_OK \\\"$R8\\\"\\n+      Abort\\n \\n-      GetFullPathName $R3 \\\"$INSTDIR\\\\uninstall\\\"\\n-      IfFileExists \\\"$R3\\\\uninstall.update\\\" +2 0\\n-      Return\\n+      ${CanWriteToInstallDir} $R7\\n+      StrCmp $R7 \\\"false\\\" +1 +3\\n+      MessageBox MB_OK \\\"$R9\\\"\\n+      Abort\\n+\\n+      Pop $R7\\n+      Exch $R8\\n+      Exch 1\\n+      Exch $R9\\n+    FunctionEnd\\n \\n-      ${${_MOZFUNC_UN}LineFind} \\\"$R3\\\\uninstall.update\\\" \\\"\\\" \\\"1:-1\\\" \\\"${_MOZFUNC_UN}CleanupUpdateLog\\\"\\n+    !verbose pop\\n+  !endif\\n+!macroend\\n \\n-      GetTempFileName $R2 \\\"$R3\\\"\\n-      FileOpen $R1 $R2 w\\n-      ${${_MOZFUNC_UN}TextCompareNoDetails} \\\"$R3\\\\uninstall.update\\\" \\\"$R3\\\\uninstall.log\\\" \\\"SlowDiff\\\" \\\"${_MOZFUNC_UN}CreateUpdateDiff\\\"\\n-      FileClose $R1\\n+!macro LeaveDirectoryCommonCall _WARN_DISK_SPACE _WARN_WRITE_ACCESS\\n+  !verbose push\\n+  Push \\\"${_WARN_DISK_SPACE}\\\"\\n+  Push \\\"${_WARN_WRITE_ACCESS}\\\"\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Call LeaveDirectoryCommon\\n+  !verbose pop\\n+!macroend\\n \\n-      IfErrors +2 0\\n-      ${${_MOZFUNC_UN}FileJoin} \\\"$R3\\\\uninstall.log\\\" \\\"$R2\\\" \\\"$R3\\\\uninstall.log\\\"\\n \\n-      ${DeleteFile} \\\"$R2\\\"\\n+################################################################################\\n+# Install Section common macros.\\n \\n-      ClearErrors\\n+/**\\n+ * Performs common cleanup operations prior to the actual installation.\\n+ * This macro should be called first when installation starts.\\n+ */\\n+!macro InstallStartCleanupCommon\\n \\n-      Pop $R0\\n-      Pop $R1\\n-      Pop $R2\\n-      Pop $R3\\n-    FunctionEnd\\n+  !ifndef InstallStartCleanupCommon\\n+    !insertmacro CleanVirtualStore\\n+    !insertmacro EndUninstallLog\\n+    !insertmacro ParseRemovedFilesLog\\n+    !insertmacro UpdateFromPreviousLog\\n \\n-    ; This callback MUST use labels vs. relative line numbers.\\n-    Function ${_MOZFUNC_UN}CleanupUpdateLog\\n-      StrCpy $R2 \\\"$R9\\\" 12\\n-      StrCmp \\\"$R2\\\" \\\"EXECUTE ADD \\\" 0 skip\\n-      StrCpy $R9 \\\"$R9\\\" \\\"\\\" 12\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !define InstallStartCleanupCommon \\\"!insertmacro InstallStartCleanupCommonCall\\\"\\n \\n-      Push $R6\\n-      Push $R5\\n-      Push $R4\\n-      StrCpy $R4 \\\"\\\"         ; Initialize to an empty string.\\n-      StrCpy $R6 -1         ; Set the counter to -1 so it will start at 0.\\n+    Function InstallStartCleanupCommon\\n \\n-      loop:\\n-      IntOp $R6 $R6 + 1     ; Increment the counter.\\n-      StrCpy $R5 $R9 1 $R6  ; Starting from the counter copy the next char.\\n-      StrCmp $R5 \\\"\\\" copy    ; Are there no more chars?\\n-      StrCmp $R5 \\\"/\\\" 0 +2   ; Is the char a /?\\n-      StrCpy $R5 \\\"\\\\\\\"        ; Replace the char with a \\\\.\\n+      ; Remove files not removed by parsing the removed-files.log\\n+      Delete \\\"$INSTDIR\\\\install_wizard.log\\\"\\n+      Delete \\\"$INSTDIR\\\\install_status.log\\\"\\n \\n-      StrCpy $R4 \\\"$R4$R5\\\"\\n-      GoTo loop\\n+      RmDir /r \\\"$INSTDIR\\\\updates\\\"\\n+      Delete \\\"$INSTDIR\\\\updates.xml\\\"\\n+      Delete \\\"$INSTDIR\\\\active-update.xml\\\"\\n \\n-      copy:\\n-      StrCpy $R9 \\\"File: \\\\$R4\\\"\\n-      Pop $R6\\n-      Pop $R5\\n-      Pop $R4\\n-      GoTo end\\n+      RmDir /r \\\"$INSTDIR\\\\distribution\\\"\\n \\n-      skip:\\n-      StrCpy $0 \\\"SkipWrite\\\"\\n+      ; Remove files from the uninstall directory.\\n+      IfFileExists \\\"$INSTDIR\\\\uninstall\\\" +1 +7\\n+      Delete \\\"$INSTDIR\\\\uninstall\\\\*wizard*\\\"\\n+      Delete \\\"$INSTDIR\\\\uninstall\\\\uninstall.ini\\\"\\n+      Delete \\\"$INSTDIR\\\\uninstall\\\\cleanup.log\\\"\\n+      Delete \\\"$INSTDIR\\\\uninstall\\\\uninstall.update\\\"\\n+      IfFileExists \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\" +1 +2\\n+      Rename \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\" \\\"$INSTDIR\\\\uninstall\\\\uninstall.bak\\\"\\n \\n-      end:\\n-      Push $0\\n-    FunctionEnd\\n+      ; Since we write to the uninstall.log in this directory during the\\n+      ; installation create the directory if it doesn't already exist.\\n+      IfFileExists \\\"$INSTDIR\\\\uninstall\\\" +2 +1\\n+      CreateDirectory \\\"$INSTDIR\\\\uninstall\\\"\\n \\n-    Function ${_MOZFUNC_UN}CreateUpdateDiff\\n-      ${${_MOZFUNC_UN}TrimNewLines} \\\"$9\\\" \\\"$9\\\"\\n-      StrCmp $9 \\\"\\\" +2 0\\n-      FileWrite $R1 \\\"$9$\\\\r$\\\\n\\\"\\n+      ; Remove files that may be left behind by the application in the\\n+      ; VirtualStore directory.\\n+      ${CleanVirtualStore}\\n \\n-      Push 0\\n+      ; Remove the files and directories in the removed-files.log\\n+      ${ParseRemovedFilesLog}\\n+ \\n     FunctionEnd\\n \\n     !verbose pop\\n   !endif\\n !macroend\\n \\n-!macro UpdateUninstallLogCall\\n+!macro InstallStartCleanupCommonCall\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Call UpdateUninstallLog\\n+  Call InstallStartCleanupCommon\\n   !verbose pop\\n !macroend\\n \\n-!macro un.UpdateUninstallLogCall\\n-  !verbose push\\n-  !verbose ${_MOZFUNC_VERBOSE}\\n-  Call un.UpdateUninstallLog\\n-  !verbose pop\\n-!macroend\\n+/**\\n+ * Performs common cleanup operations after the actual installation.\\n+ * This macro should be called last during the installation.\\n+ */\\n+!macro InstallEndCleanupCommon\\n+\\n+  !ifndef InstallEndCleanupCommon\\n+    !insertmacro EndUninstallLog\\n+    !insertmacro UpdateFromPreviousLog\\n \\n-!macro un.UpdateUninstallLog\\n-  !ifndef un.UpdateUninstallLog\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !undef _MOZFUNC_UN\\n-    !define _MOZFUNC_UN \\\"un.\\\"\\n+    !define InstallEndCleanupCommon \\\"!insertmacro InstallEndCleanupCommonCall\\\"\\n \\n-    !insertmacro FileJoin\\n-    !insertmacro LineFind\\n-    !insertmacro TextCompareNoDetails\\n-    !insertmacro TrimNewLines\\n-    !insertmacro UpdateUninstallLog\\n+    Function InstallEndCleanupCommon\\n+\\n+      ; Close the file handle to the uninstall.log\\n+      ${EndUninstallLog}\\n+      ${UpdateFromPreviousLog}\\n+\\n+    FunctionEnd\\n \\n-    !undef _MOZFUNC_UN\\n-    !define _MOZFUNC_UN\\n     !verbose pop\\n   !endif\\n !macroend\\n \\n+!macro InstallEndCleanupCommonCall\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Call InstallEndCleanupCommon\\n+  !verbose pop\\n+!macroend\\n+\\n+\\n+################################################################################\\n+# Macros for logging\\n+#\\n+# Since these are used by other macros they should be inserted first. All of\\n+# these macros can be easily inserted using the _LoggingCommon macro.\\n+\\n /**\\n- * Returns the long path for an existing file or directory. GetLongPathNameA\\n- * may not be available on Win95 if Microsoft Layer for Unicode is not\\n- * installed and GetFullPathName only returns a long path for the last file or\\n- * directory that doesn't end with a \\\\ in the path that it is passed. If the\\n- * path does not exist on the file system this will return an empty string. To\\n- * provide a consistent result trailing back-slashes are always removed.\\n+ * Adds all logging macros in the correct order in one fell swoop as well as\\n+ * the vars for the install.log and uninstall.log file handles.\\n+ */\\n+!macro _LoggingCommon\\n+  Var /GLOBAL fhInstallLog\\n+  Var /GLOBAL fhUninstallLog\\n+  !insertmacro StartInstallLog\\n+  !insertmacro EndInstallLog\\n+  !insertmacro StartUninstallLog\\n+  !insertmacro EndUninstallLog\\n+!macroend\\n+!define _LoggingCommon \\\"!insertmacro _LoggingCommon\\\"\\n+\\n+/**\\n+ * Creates a file named install.log in the install directory (e.g. $INSTDIR)\\n+ * and adds the installation started message to the install.log for this\\n+ * installation. This also adds the fhInstallLog and fhUninstallLog vars used\\n+ * for logging.\\n  *\\n- * Note: 1024 used by GetLongPathNameA is the maximum NSIS string length.\\n+ * $fhInstallLog   = filehandle for $INSTDIR\\\\install.log\\n  *\\n- * @param   _IN_PATH\\n- *          The string containing the path.\\n- * @param   _OUT_PATH\\n- *          The register to store the long path.\\n+ * @param   _APP_NAME\\n+ *          Typically the BrandFullName\\n+ * @param   _AB_CD\\n+ *          The locale identifier\\n+ * @param   _APP_VERSION\\n+ *          The application version\\n+ * @param   _GRE_VERSION\\n+ *          The Gecko Runtime Engine version\\n  *\\n- * $R4 = counter value when the previous \\\\ was found\\n- * $R5 = directory or file name found during loop\\n- * $R6 = return value from GetLongPathNameA and loop counter\\n- * $R7 = long path from GetLongPathNameA and single char from path for comparison\\n- * $R8 = _IN_PATH\\n- * $R9 = _OUT_PATH\\n+ * $R6 = _APP_NAME\\n+ * $R7 = _AB_CD\\n+ * $R8 = _APP_VERSION\\n+ * $R9 = _GRE_VERSION\\n  */\\n-!macro GetLongPath\\n+!macro StartInstallLog\\n+\\n+  !ifndef StartInstallLog\\n+    !insertmacro GetTime\\n \\n-  !ifndef ${_MOZFUNC_UN}GetLongPath\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !define ${_MOZFUNC_UN}GetLongPath \\\"!insertmacro ${_MOZFUNC_UN}GetLongPathCall\\\"\\n+    !define StartInstallLog \\\"!insertmacro StartInstallLogCall\\\"\\n \\n-    Function ${_MOZFUNC_UN}GetLongPath\\n+    Function StartInstallLog\\n       Exch $R9\\n       Exch 1\\n       Exch $R8\\n-      Push $R7\\n-      Push $R6\\n+      Exch 2\\n+      Exch $R7\\n+      Exch 3\\n+      Exch $R6\\n       Push $R5\\n       Push $R4\\n+      Push $R3\\n+      Push $R2\\n+      Push $R1\\n+      Push $R0\\n+      Push $9\\n \\n-      ClearErrors\\n-\\n-      StrCpy $R9 \\\"\\\"\\n-      GetFullPathName $R8 \\\"$R8\\\"\\n-      IfErrors end_GetLongPath +1 ; If the path doesn't exist return an empty string.\\n-\\n-      ; Remove trailing \\\\'s from the path.\\n-      StrCpy $R6 \\\"$R8\\\" \\\"\\\" -1\\n-      StrCmp $R6 \\\"\\\\\\\" +1 +2\\n-      StrCpy $R9 \\\"$R8\\\" -1\\n+      FileOpen $fhInstallLog \\\"$INSTDIR\\\\install.log\\\" w\\n \\n-      System::Call 'kernel32::GetLongPathNameA(t r18, t .r17, i 1024)i .r16'\\n-      StrCmp \\\"$R7\\\" \\\"\\\" +4 +1 ; Empty string when GetLongPathNameA is not present.\\n-      StrCmp $R6 0 +3 +1    ; Should never equal 0 since the path exists.\\n-      StrCpy $R9 \\\"$R7\\\"\\n-      GoTo end_GetLongPath\\n+      ${GetTime} \\\"\\\" \\\"L\\\" $9 $R0 $R1 $R2 $R3 $R4 $R5\\n+      FileWrite $fhInstallLog \\\"$R6 Installation Started: $R1-$R0-$9 $R3:$R4:$R5\\\"\\n+      ${WriteLogSeparator}\\n \\n-      ; Do it the hard way.\\n-      StrCpy $R4 0     ; Stores the position in the string of the last \\\\ found.\\n-      StrCpy $R6 -1    ; Set the counter to -1 so it will start at 0.\\n+      ${LogHeader} \\\"Installation Details\\\"\\n+      ${LogMsg} \\\"Install Dir: $INSTDIR\\\"\\n+      ${LogMsg} \\\"Locale     : $R7\\\"\\n+      ${LogMsg} \\\"App Version: $R8\\\"\\n+      ${LogMsg} \\\"GRE Version: $R9\\\"\\n \\n-      loop_GetLongPath:\\n-      IntOp $R6 $R6 + 1      ; Increment the counter.\\n-      StrCpy $R7 $R8 1 $R6   ; Starting from the counter copy the next char.\\n-      StrCmp $R7 \\\"\\\" +2       ; Are there no more chars?\\n-      StrCmp $R7 \\\"\\\\\\\" +1 -3   ; Is it a \\\\?\\n+      Pop $9\\n+      Pop $R0\\n+      Pop $R1\\n+      Pop $R2\\n+      Pop $R3\\n+      Pop $R4\\n+      Pop $R5\\n+      Exch $R6\\n+      Exch 3\\n+      Exch $R7\\n+      Exch 2\\n+      Exch $R8\\n+      Exch 1\\n+      Exch $R9\\n+    FunctionEnd\\n \\n-      ; Copy chars starting from the previously found \\\\ to the counter.\\n-      StrCpy $R5 $R8 $R6 $R4\\n+    !verbose pop\\n+  !endif\\n+!macroend\\n \\n-      ; If this is the first \\\\ found we want to swap R9 with R5 so a \\\\ will\\n-      ; be appended to the drive letter and colon (e.g. C: will become C:\\\\).\\n-      StrCmp $R4 0 +1 +3     \\n-      StrCpy $R9 $R5\\n-      StrCpy $R5 \\\"\\\"\\n+!macro StartInstallLogCall _APP_NAME _AB_CD _APP_VERSION _GRE_VERSION\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Push \\\"${_APP_NAME}\\\"\\n+  Push \\\"${_AB_CD}\\\"\\n+  Push \\\"${_APP_VERSION}\\\"\\n+  Push \\\"${_GRE_VERSION}\\\"\\n+  Call StartInstallLog\\n+  !verbose pop\\n+!macroend\\n \\n-      GetFullPathName $R9 \\\"$R9\\\\$R5\\\"\\n+/**\\n+ * Writes the installation finished message to the install.log and closes the\\n+ * file handles to the install.log and uninstall.log\\n+ *\\n+ * @param   _APP_NAME\\n+ *\\n+ * $R9 = _APP_NAME\\n+ */\\n+!macro EndInstallLog\\n \\n-      StrCmp $R7 \\\"\\\" end_GetLongPath ; Are there no more chars?\\n+  !ifndef EndInstallLog\\n+    !insertmacro GetTime\\n \\n-      ; Store the counter for the current \\\\ and prefix it for StrCpy operations.\\n-      StrCpy $R4 \\\"+$R6\\\"\\n-      IntOp $R6 $R6 + 1      ; Increment the counter so we skip over the \\\\.\\n-      StrCpy $R8 $R8 \\\"\\\" $R6  ; Copy chars starting from the counter to the end.\\n-      StrCpy $R6 -1          ; Reset the counter to -1 so it will start over at 0.\\n-      GoTo loop_GetLongPath\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !define EndInstallLog \\\"!insertmacro EndInstallLogCall\\\"\\n \\n-      end_GetLongPath:\\n-      ClearErrors\\n+    Function EndInstallLog\\n+      Exch $R9\\n+      Push $R8\\n+      Push $R7\\n+      Push $R6\\n+      Push $R5\\n+      Push $R4\\n+      Push $R3\\n+      Push $R2\\n+      \\n+      ${WriteLogSeparator}\\n+      ${GetTime} \\\"\\\" \\\"L\\\" $R2 $R3 $R4 $R5 $R6 $R7 $R8\\n+      FileWrite $fhInstallLog \\\"$R9 Installation Finished: $R4-$R3-$R2 $R6:$R7:$R8$\\\\r$\\\\n\\\"\\n+      FileClose $fhInstallLog\\n \\n+      Pop $R2\\n+      Pop $R3\\n       Pop $R4\\n       Pop $R5\\n       Pop $R6\\n       Pop $R7\\n-      Exch $R8\\n-      Exch 1\\n+      Pop $R8\\n       Exch $R9\\n     FunctionEnd\\n \\n@@ -2442,37 +3590,107 @@ Exch $R9 ; exchange the new $R9 value with the top of the stack\\n   !endif\\n !macroend\\n \\n-!macro GetLongPathCall _IN_PATH _OUT_PATH\\n+!macro EndInstallLogCall _APP_NAME\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_IN_PATH}\\\"\\n-  Push \\\"${_OUT_PATH}\\\"\\n-  Call GetLongPath\\n-  Pop ${_OUT_PATH}\\n+  Push \\\"${_APP_NAME}\\\"\\n+  Call EndInstallLog\\n   !verbose pop\\n !macroend\\n \\n-!macro un.GetLongPathCall _IN_PATH _OUT_PATH\\n+/**\\n+ * Opens the file handle to the uninstall.log.\\n+ *\\n+ * $fhUninstallLog = filehandle for $INSTDIR\\\\uninstall\\\\uninstall.log\\n+ */\\n+!macro StartUninstallLog\\n+\\n+  !ifndef StartUninstallLog\\n+    !verbose push\\n+    !verbose ${_MOZFUNC_VERBOSE}\\n+    !define StartUninstallLog \\\"!insertmacro StartUninstallLogCall\\\"\\n+\\n+    Function StartUninstallLog\\n+      FileOpen $fhUninstallLog \\\"$INSTDIR\\\\uninstall\\\\uninstall.log\\\" w\\n+    FunctionEnd\\n+\\n+    !verbose pop\\n+  !endif\\n+!macroend\\n+\\n+!macro StartUninstallLogCall\\n   !verbose push\\n   !verbose ${_MOZFUNC_VERBOSE}\\n-  Push \\\"${_IN_PATH}\\\"\\n-  Push \\\"${_OUT_PATH}\\\"\\n-  Call un.GetLongPath\\n-  Pop ${_OUT_PATH}\\n+  Call StartUninstallLog\\n   !verbose pop\\n !macroend\\n \\n-!macro un.GetLongPath\\n-  !ifndef un.GetLongPath\\n+/**\\n+ * Closes the file handle to the uninstall.log.\\n+ */\\n+!macro EndUninstallLog\\n+\\n+  !ifndef EndUninstallLog\\n+\\n     !verbose push\\n     !verbose ${_MOZFUNC_VERBOSE}\\n-    !undef _MOZFUNC_UN\\n-    !define _MOZFUNC_UN \\\"un.\\\"\\n+    !define EndUninstallLog \\\"!insertmacro EndUninstallLogCall\\\"\\n \\n-    !insertmacro GetLongPath\\n+    Function EndUninstallLog\\n+      FileClose $fhUninstallLog\\n+    FunctionEnd\\n \\n-    !undef _MOZFUNC_UN\\n-    !define _MOZFUNC_UN\\n     !verbose pop\\n   !endif\\n !macroend\\n+\\n+!macro EndUninstallLogCall\\n+  !verbose push\\n+  !verbose ${_MOZFUNC_VERBOSE}\\n+  Call EndUninstallLog\\n+  !verbose pop\\n+!macroend\\n+\\n+/**\\n+ * Adds a section header to the human readable log.\\n+ *\\n+ * @param   _HEADER\\n+ *          The header text to write to the log.\\n+ */\\n+!macro LogHeader _HEADER\\n+  ${WriteLogSeparator}\\n+  FileWrite $fhInstallLog \\\"${_HEADER}\\\"\\n+  ${WriteLogSeparator}\\n+!macroend\\n+!define LogHeader \\\"!insertmacro LogHeader\\\"\\n+\\n+/**\\n+ * Adds a section message to the human readable log.\\n+ *\\n+ * @param   _MSG\\n+ *          The message text to write to the log.\\n+ */\\n+!macro LogMsg _MSG\\n+  FileWrite $fhInstallLog \\\"  ${_MSG}$\\\\r$\\\\n\\\"\\n+!macroend\\n+!define LogMsg \\\"!insertmacro LogMsg\\\"\\n+\\n+/**\\n+ * Adds an uninstall entry to the uninstall log.\\n+ *\\n+ * @param   _MSG\\n+ *          The message text to write to the log.\\n+ */\\n+!macro LogUninstall _MSG\\n+  FileWrite $fhUninstallLog \\\"${_MSG}$\\\\r$\\\\n\\\"\\n+!macroend\\n+!define LogUninstall \\\"!insertmacro LogUninstall\\\"\\n+\\n+/**\\n+ * Adds a section divider to the human readable log.\\n+ */\\n+!macro WriteLogSeparator\\n+  FileWrite $fhInstallLog \\\"$\\\\r$\\\\n----------------------------------------\\\\\\n+                           ---------------------------------------$\\\\r$\\\\n\\\"\\n+!macroend\\n+!define WriteLogSeparator \\\"!insertmacro WriteLogSeparator\\\"\\ndiff --git a/toolkit/mozapps/installer/windows/nsis/makensis.mk b/toolkit/mozapps/installer/windows/nsis/makensis.mk\\nindex 53f783a..76eb58e 100755\\n--- a/toolkit/mozapps/installer/windows/nsis/makensis.mk\\n+++ b/toolkit/mozapps/installer/windows/nsis/makensis.mk\\n@@ -49,6 +49,7 @@ TOOLKIT_NSIS_FILES = \\\\\\n \\tlocales.nsi \\\\\\n \\tnsProcess.dll \\\\\\n \\toverrides.nsh \\\\\\n+\\tRealProgress.dll \\\\\\n \\tShellLink.dll \\\\\\n \\tversion.nsh \\\\\\n \\t$(NULL)\\n\""}