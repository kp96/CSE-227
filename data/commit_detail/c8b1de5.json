{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basc8b1de5\""},"diff":"\"c8b1de5 Relanding bug 372769 with some cycle collection changes to fix leaks. r=mrbkap, sr=sicking, with r=sicking on the leak fixes.\\ndiff --git a/content/xbl/src/Makefile.in b/content/xbl/src/Makefile.in\\nindex 3c4986d..ae32022 100644\\n--- a/content/xbl/src/Makefile.in\\n+++ b/content/xbl/src/Makefile.in\\n@@ -111,6 +111,7 @@ LOCAL_INCLUDES\\t= \\\\\\n \\t\\t-I$(srcdir)/../../xul/document/src \\\\\\n \\t\\t-I$(srcdir)/../../events/src \\\\\\n \\t\\t-I$(srcdir)/../../../layout/style \\\\\\n+\\t\\t-I$(srcdir)/../../../dom/src/base \\\\\\n \\t\\t$(NULL)\\n \\n DEFINES += -D_IMPL_NS_LAYOUT\\ndiff --git a/content/xbl/src/nsXBLBinding.cpp b/content/xbl/src/nsXBLBinding.cpp\\nindex 08b226b..e9f83e7 100644\\n--- a/content/xbl/src/nsXBLBinding.cpp\\n+++ b/content/xbl/src/nsXBLBinding.cpp\\n@@ -102,27 +102,134 @@\\n #include \\\"prprf.h\\\"\\n #include \\\"nsNodeUtils.h\\\"\\n \\n+// Nasty hack.  Maybe we could move some of the classinfo utility methods\\n+// (e.g. WrapNative and ThrowJSException) over to nsContentUtils?\\n+#include \\\"nsDOMClassInfo.h\\\"\\n+#include \\\"nsJSUtils.h\\\"\\n+\\n // Helper classes\\n \\n /***********************************************************************/\\n //\\n // The JS class for XBLBinding\\n //\\n-PR_STATIC_CALLBACK(void)\\n+JS_STATIC_DLL_CALLBACK(void)\\n XBLFinalize(JSContext *cx, JSObject *obj)\\n {\\n+  nsIXBLDocumentInfo* docInfo =\\n+    static_cast<nsIXBLDocumentInfo*>(::JS_GetPrivate(cx, obj));\\n+  NS_RELEASE(docInfo);\\n+  \\n   nsXBLJSClass* c = static_cast<nsXBLJSClass*>(::JS_GetClass(cx, obj));\\n   c->Drop();\\n }\\n \\n+JS_STATIC_DLL_CALLBACK(JSBool)\\n+XBLResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,\\n+           JSObject **objp)\\n+{\\n+  // Note: if we get here, that means that the implementation for some binding\\n+  // was installed, which means that AllowScripts() tested true.  Hence no need\\n+  // to do checks like that here.\\n+  \\n+  // Default to not resolving things.\\n+  NS_ASSERTION(*objp, \\\"Must have starting object\\\");\\n+\\n+  JSObject* origObj = *objp;\\n+  *objp = NULL;\\n+\\n+  if (!JSVAL_IS_STRING(id)) {\\n+    return JS_TRUE;\\n+  }\\n+\\n+  nsDependentJSString fieldName(id);\\n+\\n+  jsval slotVal;\\n+  ::JS_GetReservedSlot(cx, obj, 0, &slotVal);\\n+  NS_ASSERTION(!JSVAL_IS_VOID(slotVal), \\\"How did that happen?\\\");\\n+    \\n+  nsXBLPrototypeBinding* protoBinding =\\n+    static_cast<nsXBLPrototypeBinding*>(JSVAL_TO_PRIVATE(slotVal));\\n+  NS_ASSERTION(protoBinding, \\\"Must have prototype binding!\\\");\\n+\\n+  nsXBLProtoImplField* field = protoBinding->FindField(fieldName);\\n+  if (!field) {\\n+    return JS_TRUE;\\n+  }\\n+\\n+  // We have this field.  Time to install it.  Get our node.\\n+  JSClass* nodeClass = ::JS_GetClass(cx, origObj);\\n+  if (!nodeClass) {\\n+    return JS_FALSE;\\n+  }\\n+  \\n+  if (~nodeClass->flags &\\n+      (JSCLASS_HAS_PRIVATE | JSCLASS_PRIVATE_IS_NSISUPPORTS)) {\\n+    // Looks like whatever |origObj| is it's not our nsIContent.  It might well\\n+    // be the proto our binding installed, however, so just baul out quietly.\\n+    // Do NOT throw an exception here.\\n+    // We could make this stricter by checking the class maybe, but whatever\\n+    return JS_TRUE;\\n+  }\\n+\\n+  nsCOMPtr<nsIXPConnectWrappedNative> xpcWrapper =\\n+    do_QueryInterface(static_cast<nsISupports*>(::JS_GetPrivate(cx, origObj)));\\n+  if (!xpcWrapper) {\\n+    nsDOMClassInfo::ThrowJSException(cx, NS_ERROR_UNEXPECTED);\\n+    return JS_FALSE;\\n+  }\\n+\\n+  nsCOMPtr<nsIContent> content = do_QueryWrappedNative(xpcWrapper);\\n+  if (!content) {\\n+    nsDOMClassInfo::ThrowJSException(cx, NS_ERROR_UNEXPECTED);\\n+    return JS_FALSE;\\n+  }\\n+\\n+  // This mirrors code in nsXBLProtoImpl::InstallImplementation\\n+  nsIDocument* doc = content->GetOwnerDoc();\\n+  if (!doc) {\\n+    return JS_TRUE;\\n+  }\\n+\\n+  nsIScriptGlobalObject* global = doc->GetScriptGlobalObject();\\n+  if (!global) {\\n+    return JS_TRUE;\\n+  }\\n+\\n+  nsCOMPtr<nsIScriptContext> context = global->GetContext();\\n+  if (!context) {\\n+    return JS_TRUE;\\n+  }\\n+\\n+\\n+  // Now we either resolve or fail\\n+  *objp = origObj;\\n+  nsresult rv = field->InstallField(context, origObj,\\n+                                    protoBinding->DocURI());\\n+  if (NS_FAILED(rv)) {\\n+    if (!::JS_IsExceptionPending(cx)) {\\n+      nsDOMClassInfo::ThrowJSException(cx, rv);\\n+    }\\n+\\n+    return JS_FALSE;\\n+  }\\n+\\n+  return JS_TRUE;\\n+}\\n+\\n nsXBLJSClass::nsXBLJSClass(const nsAFlatCString& aClassName)\\n {\\n   memset(this, 0, sizeof(nsXBLJSClass));\\n   next = prev = static_cast<JSCList*>(this);\\n   name = ToNewCString(aClassName);\\n+  flags =\\n+    JSCLASS_HAS_PRIVATE | JSCLASS_PRIVATE_IS_NSISUPPORTS |\\n+    JSCLASS_NEW_RESOLVE | JSCLASS_NEW_RESOLVE_GETS_START |\\n+    // Our one reserved slot holds the relevant nsXBLPrototypeBinding\\n+    JSCLASS_HAS_RESERVED_SLOTS(1);\\n   addProperty = delProperty = setProperty = getProperty = ::JS_PropertyStub;\\n   enumerate = ::JS_EnumerateStub;\\n-  resolve = ::JS_ResolveStub;\\n+  resolve = (JSResolveOp)XBLResolve;\\n   convert = ::JS_ConvertStub;\\n   finalize = XBLFinalize;\\n }\\n@@ -1034,6 +1141,7 @@ nsXBLBinding::WalkRules(nsIStyleRuleProcessor::EnumFunc aFunc, void* aData)\\n nsresult\\n nsXBLBinding::DoInitJSClass(JSContext *cx, JSObject *global, JSObject *obj,\\n                             const nsAFlatCString& aClassName,\\n+                            nsXBLPrototypeBinding* aProtoBinding,\\n                             void **aClassObject)\\n {\\n   // First ensure our JS class is initialized.\\n@@ -1139,6 +1247,20 @@ nsXBLBinding::DoInitJSClass(JSContext *cx, JSObject *global, JSObject *obj,\\n       return NS_ERROR_OUT_OF_MEMORY;\\n     }\\n \\n+    // Keep this proto binding alive while we're alive.  Do this first so that\\n+    // we can guarantee that in XBLFinalize this will be non-null.\\n+    nsIXBLDocumentInfo* docInfo = aProtoBinding->XBLDocumentInfo();\\n+    ::JS_SetPrivate(cx, proto, docInfo);\\n+    NS_ADDREF(docInfo);\\n+\\n+    if (!::JS_SetReservedSlot(cx, proto, 0, PRIVATE_TO_JSVAL(aProtoBinding))) {\\n+      (nsXBLService::gClassTable)->Remove(&key);\\n+\\n+      // |c| will get dropped when |proto| is finalized\\n+\\n+      return NS_ERROR_OUT_OF_MEMORY;\\n+    }\\n+\\n     *aClassObject = (void*)proto;\\n   }\\n   else {\\n@@ -1155,63 +1277,6 @@ nsXBLBinding::DoInitJSClass(JSContext *cx, JSObject *global, JSObject *obj,\\n   return NS_OK;\\n }\\n \\n-\\n-nsresult\\n-nsXBLBinding::InitClass(const nsCString& aClassName,\\n-                        nsIScriptContext* aContext, \\n-                        nsIDocument* aDocument, void** aScriptObject,\\n-                        void** aClassObject)\\n-{\\n-  *aClassObject = nsnull;\\n-  *aScriptObject = nsnull;\\n-\\n-  nsresult rv;\\n-\\n-  // Obtain the bound element's current script object.\\n-  JSContext* cx = (JSContext*)aContext->GetNativeContext();\\n-\\n-  nsIDocument *ownerDoc = mBoundElement->GetOwnerDoc();\\n-  nsIScriptGlobalObject *sgo;\\n-\\n-  if (!ownerDoc || !(sgo = ownerDoc->GetScriptGlobalObject())) {\\n-    NS_ERROR(\\\"Can't find global object for bound content!\\\");\\n-\\n-    return NS_ERROR_UNEXPECTED;\\n-  }\\n-\\n-  nsCOMPtr<nsIXPConnectJSObjectHolder> wrapper;\\n-  rv = nsContentUtils::XPConnect()->WrapNative(cx, sgo->GetGlobalJSObject(),\\n-                                               mBoundElement,\\n-                                               NS_GET_IID(nsISupports),\\n-                                               getter_AddRefs(wrapper));\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  JSObject* object = nsnull;\\n-  rv = wrapper->GetJSObject(&object);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  *aScriptObject = object;\\n-\\n-  // First ensure our JS class is initialized.\\n-\\n-  rv = DoInitJSClass(cx, sgo->GetGlobalJSObject(), object, aClassName,\\n-                     aClassObject);\\n-  NS_ENSURE_SUCCESS(rv, rv);\\n-\\n-  // Root mBoundElement so that it doesn't lose it's binding\\n-  nsIDocument* doc = mBoundElement->GetOwnerDoc();\\n-\\n-  if (doc) {\\n-    nsCOMPtr<nsIXPConnectWrappedNative> native_wrapper =\\n-      do_QueryInterface(wrapper);\\n-    if (native_wrapper) {\\n-      doc->AddReference(mBoundElement, native_wrapper);\\n-    }\\n-  }\\n-\\n-  return NS_OK;\\n-}\\n-\\n PRBool\\n nsXBLBinding::AllowScripts()\\n {\\n@@ -1344,6 +1409,20 @@ nsXBLBinding::GetFirstStyleBinding()\\n   return mNextBinding ? mNextBinding->GetFirstStyleBinding() : nsnull;\\n }\\n \\n+PRBool\\n+nsXBLBinding::ResolveAllFields(JSContext *cx, JSObject *obj) const\\n+{\\n+  if (!mPrototypeBinding->ResolveAllFields(cx, obj)) {\\n+    return PR_FALSE;\\n+  }\\n+\\n+  if (mNextBinding) {\\n+    return mNextBinding->ResolveAllFields(cx, obj);\\n+  }\\n+\\n+  return PR_TRUE;\\n+}\\n+\\n void\\n nsXBLBinding::MarkForDeath()\\n {\\ndiff --git a/content/xbl/src/nsXBLBinding.h b/content/xbl/src/nsXBLBinding.h\\nindex 744c418..55b571f 100644\\n--- a/content/xbl/src/nsXBLBinding.h\\n+++ b/content/xbl/src/nsXBLBinding.h\\n@@ -132,6 +132,10 @@ public:\\n   nsXBLBinding* RootBinding();\\n   nsXBLBinding* GetFirstStyleBinding();\\n \\n+  // Resolve all the fields for this binding and all ancestor bindings on the\\n+  // object |obj|.  False return means a JS exception was set.\\n+  PRBool ResolveAllFields(JSContext *cx, JSObject *obj) const;\\n+\\n   // Get the list of insertion points for aParent. The nsInsertionPointList\\n   // is owned by the binding, you should not delete it.\\n   nsresult GetInsertionPointsFor(nsIContent* aParent,\\n@@ -155,16 +159,11 @@ public:\\n \\n   static nsresult DoInitJSClass(JSContext *cx, JSObject *global, JSObject *obj,\\n                                 const nsAFlatCString& aClassName,\\n+                                nsXBLPrototypeBinding* aProtoBinding,\\n                                 void **aClassObject);\\n \\n   PRBool AllowScripts();  // XXX make const\\n \\n-// Internal member functions\\n-protected:\\n-  nsresult InitClass(const nsCString& aClassName, nsIScriptContext* aContext,\\n-                     nsIDocument* aDocument, void** aScriptObject,\\n-                     void** aClassObject);\\n-\\n // MEMBER VARIABLES\\n protected:\\n   nsAutoRefCnt mRefCnt;\\ndiff --git a/content/xbl/src/nsXBLContentSink.cpp b/content/xbl/src/nsXBLContentSink.cpp\\nindex 19bdf77..ea2ee5c 100644\\n--- a/content/xbl/src/nsXBLContentSink.cpp\\n+++ b/content/xbl/src/nsXBLContentSink.cpp\\n@@ -83,12 +83,13 @@ nsXBLContentSink::nsXBLContentSink()\\n   : mState(eXBL_InDocument),\\n     mSecondaryState(eXBL_None),\\n     mDocInfo(nsnull),\\n-    mFoundFirstBinding(PR_FALSE),    \\n     mIsChromeOrResource(PR_FALSE),\\n+    mFoundFirstBinding(PR_FALSE),    \\n     mBinding(nsnull),\\n     mHandler(nsnull),\\n     mImplementation(nsnull),\\n     mImplMember(nsnull),\\n+    mImplField(nsnull),\\n     mProperty(nsnull),\\n     mMethod(nsnull),\\n     mField(nsnull)\\n@@ -263,6 +264,18 @@ nsXBLContentSink::AddMember(nsXBLProtoImplMember* aMember)\\n   mImplMember = aMember; // Adjust our pointer to point to the new last member in the chain.\\n }\\n \\n+void\\n+nsXBLContentSink::AddField(nsXBLProtoImplField* aField)\\n+{\\n+  // Add this field to our chain.\\n+  if (mImplField)\\n+    mImplField->SetNext(aField); // Already have a chain. Just append to the end.\\n+  else\\n+    mImplementation->SetFieldList(aField); // We're the first member in the chain.\\n+\\n+  mImplField = aField; // Adjust our pointer to point to the new last field in the chain.\\n+}\\n+\\n NS_IMETHODIMP \\n nsXBLContentSink::HandleStartElement(const PRUnichar *aName, \\n                                      const PRUnichar **aAtts, \\n@@ -703,7 +716,8 @@ nsXBLContentSink::ConstructImplementation(const PRUnichar **aAtts)\\n {\\n   mImplementation = nsnull;\\n   mImplMember = nsnull;\\n-      \\n+  mImplField = nsnull;\\n+  \\n   if (!mBinding)\\n     return;\\n \\n@@ -777,7 +791,7 @@ nsXBLContentSink::ConstructField(const PRUnichar **aAtts, PRUint32 aLineNumber)\\n     mField = new nsXBLProtoImplField(name, readonly);\\n     if (mField) {\\n       mField->SetLineNumber(aLineNumber);\\n-      AddMember(mField);\\n+      AddField(mField);\\n     }\\n   }\\n }\\ndiff --git a/content/xbl/src/nsXBLContentSink.h b/content/xbl/src/nsXBLContentSink.h\\nindex 0d59fff..2cb1368 100644\\n--- a/content/xbl/src/nsXBLContentSink.h\\n+++ b/content/xbl/src/nsXBLContentSink.h\\n@@ -157,6 +157,7 @@ protected:\\n   nsresult ReportUnexpectedElement(nsIAtom* aElementName, PRUint32 aLineNumber);\\n \\n   void AddMember(nsXBLProtoImplMember* aMember);\\n+  void AddField(nsXBLProtoImplField* aField);\\n   \\n   XBLPrimaryState mState;\\n   XBLSecondaryState mSecondaryState;\\n@@ -168,6 +169,7 @@ protected:\\n   nsXBLPrototypeHandler* mHandler; // current handler, owned by its PrototypeBinding\\n   nsXBLProtoImpl* mImplementation;\\n   nsXBLProtoImplMember* mImplMember;\\n+  nsXBLProtoImplField* mImplField;\\n   nsXBLProtoImplProperty* mProperty;\\n   nsXBLProtoImplMethod* mMethod;\\n   nsXBLProtoImplField* mField;\\ndiff --git a/content/xbl/src/nsXBLDocumentInfo.cpp b/content/xbl/src/nsXBLDocumentInfo.cpp\\nindex 9fa254c..4da0e37 100644\\n--- a/content/xbl/src/nsXBLDocumentInfo.cpp\\n+++ b/content/xbl/src/nsXBLDocumentInfo.cpp\\n@@ -409,6 +409,8 @@ nsXBLDocGlobalObject::GetPrincipal()\\n {\\n   nsresult rv = NS_OK;\\n   if (!mGlobalObjectOwner) {\\n+    // XXXbz this should really save the principal when\\n+    // ClearGlobalObjectOwner() happens.\\n     return nsnull;\\n   }\\n \\n@@ -442,8 +444,19 @@ TraverseProtos(nsHashKey *aKey, void *aData, void* aClosure)\\n   return kHashEnumerateNext;\\n }\\n \\n+static PRIntn PR_CALLBACK\\n+UnlinkProtos(nsHashKey *aKey, void *aData, void* aClosure)\\n+{\\n+  nsXBLPrototypeBinding *proto = static_cast<nsXBLPrototypeBinding*>(aData);\\n+  proto->Unlink();\\n+  return kHashEnumerateNext;\\n+}\\n+\\n NS_IMPL_CYCLE_COLLECTION_CLASS(nsXBLDocumentInfo)\\n NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsXBLDocumentInfo)\\n+  if (tmp->mBindingTable) {\\n+    tmp->mBindingTable->Enumerate(UnlinkProtos, nsnull);\\n+  }\\n   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDocument)\\n   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mGlobalObject)\\n NS_IMPL_CYCLE_COLLECTION_UNLINK_END\\ndiff --git a/content/xbl/src/nsXBLProtoImpl.cpp b/content/xbl/src/nsXBLProtoImpl.cpp\\nindex 1a1feff..efe7bd2 100644\\n--- a/content/xbl/src/nsXBLProtoImpl.cpp\\n+++ b/content/xbl/src/nsXBLProtoImpl.cpp\\n@@ -47,6 +47,7 @@\\n #include \\\"nsIServiceManager.h\\\"\\n #include \\\"nsIXBLDocumentInfo.h\\\"\\n #include \\\"nsIDOMNode.h\\\"\\n+#include \\\"nsXBLPrototypeBinding.h\\\"\\n \\n nsresult\\n nsXBLProtoImpl::InstallImplementation(nsXBLPrototypeBinding* aBinding, nsIContent* aBoundElement)\\n@@ -55,7 +56,7 @@ nsXBLProtoImpl::InstallImplementation(nsXBLPrototypeBinding* aBinding, nsIConten\\n   // this prototype implementation as a guide.  The prototype implementation is compiled lazily,\\n   // so for the first bound element that needs a concrete implementation, we also build the\\n   // prototype implementation.\\n-  if (!mMembers)  // Constructor and destructor also live in mMembers\\n+  if (!mMembers && !mFields)  // Constructor and destructor also live in mMembers\\n     return NS_OK; // Nothing to do, so let's not waste time.\\n \\n   // If the way this gets the script context changes, fix\\n@@ -215,6 +216,45 @@ nsXBLProtoImpl::Traverse(nsCycleCollectionTraversalCallback &cb) const\\n }\\n \\n void\\n+nsXBLProtoImpl::Unlink()\\n+{\\n+  if (mClassObject) {\\n+    DestroyMembers(nsnull);\\n+  }\\n+}\\n+\\n+nsXBLProtoImplField*\\n+nsXBLProtoImpl::FindField(const nsString& aFieldName) const\\n+{\\n+  for (nsXBLProtoImplField* f = mFields; f; f = f->GetNext()) {\\n+    if (aFieldName.Equals(f->GetName())) {\\n+      return f;\\n+    }\\n+  }\\n+\\n+  return nsnull;\\n+}\\n+\\n+PRBool\\n+nsXBLProtoImpl::ResolveAllFields(JSContext *cx, JSObject *obj) const\\n+{\\n+  for (nsXBLProtoImplField* f = mFields; f; f = f->GetNext()) {\\n+    // Using OBJ_LOOKUP_PROPERTY is a pain, since what we have is a\\n+    // PRUnichar* for the property name.  Let's just use the public API and\\n+    // all.\\n+    nsDependentString name(f->GetName());\\n+    jsval dummy;\\n+    if (!::JS_LookupUCProperty(cx, obj,\\n+                               reinterpret_cast<const jschar*>(name.get()),\\n+                               name.Length(), &dummy)) {\\n+      return PR_FALSE;\\n+    }\\n+  }\\n+\\n+  return PR_TRUE;\\n+}\\n+\\n+void\\n nsXBLProtoImpl::DestroyMembers(nsXBLProtoImplMember* aBrokenMember)\\n {\\n   NS_ASSERTION(mClassObject, \\\"This should never be called when there is no class object\\\");\\ndiff --git a/content/xbl/src/nsXBLProtoImpl.h b/content/xbl/src/nsXBLProtoImpl.h\\nindex 54f36b1..2b4e0ad 100644\\n--- a/content/xbl/src/nsXBLProtoImpl.h\\n+++ b/content/xbl/src/nsXBLProtoImpl.h\\n@@ -42,9 +42,11 @@\\n #include \\\"nsMemory.h\\\"\\n #include \\\"nsXBLPrototypeHandler.h\\\"\\n #include \\\"nsXBLProtoImplMember.h\\\"\\n-#include \\\"nsXBLPrototypeBinding.h\\\"\\n+#include \\\"nsXBLProtoImplField.h\\\"\\n \\n class nsIXPConnectJSObjectHolder;\\n+class nsXBLPrototypeBinding;\\n+class nsXBLProtoImplAnonymousMethod;\\n \\n class nsXBLProtoImpl\\n {\\n@@ -52,6 +54,7 @@ public:\\n   nsXBLProtoImpl() \\n     : mClassObject(nsnull),\\n       mMembers(nsnull),\\n+      mFields(nsnull),\\n       mConstructor(nsnull),\\n       mDestructor(nsnull)\\n   { \\n@@ -64,7 +67,8 @@ public:\\n     // clean them up automatically.\\n     for (nsXBLProtoImplMember* curr = mMembers; curr; curr=curr->GetNext())\\n       curr->Destroy(mClassObject != nsnull);\\n-    delete mMembers; \\n+    delete mMembers;\\n+    delete mFields;\\n   }\\n   \\n   nsresult InstallImplementation(nsXBLPrototypeBinding* aBinding, nsIContent* aBoundElement);\\n@@ -74,9 +78,26 @@ public:\\n                              void** aTargetClassObject);\\n   nsresult CompilePrototypeMembers(nsXBLPrototypeBinding* aBinding);\\n \\n-  void SetMemberList(nsXBLProtoImplMember* aMemberList) { delete mMembers; mMembers = aMemberList; }\\n+  void SetMemberList(nsXBLProtoImplMember* aMemberList)\\n+  {\\n+    delete mMembers;\\n+    mMembers = aMemberList;\\n+  }\\n+\\n+  void SetFieldList(nsXBLProtoImplField* aFieldList)\\n+  {\\n+    delete mFields;\\n+    mFields = aFieldList;\\n+  }\\n \\n   void Traverse(nsCycleCollectionTraversalCallback &cb) const;\\n+  void Unlink();\\n+\\n+  nsXBLProtoImplField* FindField(const nsString& aFieldName) const;\\n+\\n+  // Resolve all the fields for this implementation on the object |obj| False\\n+  // return means a JS exception was set.\\n+  PRBool ResolveAllFields(JSContext *cx, JSObject *obj) const;\\n \\n protected:\\n   // Function to call if compilation of a member fails.  When this is called,\\n@@ -93,6 +114,8 @@ protected:\\n                         // and methods for the binding.\\n \\n   nsXBLProtoImplMember* mMembers; // The members of an implementation are chained in this singly-linked list.\\n+\\n+  nsXBLProtoImplField* mFields; // Our fields\\n   \\n public:\\n   nsXBLProtoImplAnonymousMethod* mConstructor; // Our class constructor.\\ndiff --git a/content/xbl/src/nsXBLProtoImplField.cpp b/content/xbl/src/nsXBLProtoImplField.cpp\\nindex 4c7480a..cf129df 100644\\n--- a/content/xbl/src/nsXBLProtoImplField.cpp\\n+++ b/content/xbl/src/nsXBLProtoImplField.cpp\\n@@ -46,14 +46,17 @@\\n #include \\\"nsXBLProtoImplField.h\\\"\\n #include \\\"nsIScriptContext.h\\\"\\n #include \\\"nsContentUtils.h\\\"\\n+#include \\\"nsIURI.h\\\"\\n \\n nsXBLProtoImplField::nsXBLProtoImplField(const PRUnichar* aName, const PRUnichar* aReadOnly)\\n-  : nsXBLProtoImplMember(aName),\\n+  : mNext(nsnull),\\n     mFieldText(nsnull),\\n     mFieldTextLength(0),\\n     mLineNumber(0)\\n {\\n   MOZ_COUNT_CTOR(nsXBLProtoImplField);\\n+  mName = NS_strdup(aName);  // XXXbz make more sense to use a stringbuffer?\\n+  \\n   mJSAttributes = JSPROP_ENUMERATE;\\n   if (aReadOnly) {\\n     nsAutoString readOnly; readOnly.Assign(*aReadOnly);\\n@@ -67,11 +70,8 @@ nsXBLProtoImplField::~nsXBLProtoImplField()\\n   MOZ_COUNT_DTOR(nsXBLProtoImplField);\\n   if (mFieldText)\\n     nsMemory::Free(mFieldText);\\n-}\\n-\\n-void\\n-nsXBLProtoImplField::Destroy(PRBool aIsCompiled)\\n-{\\n+  NS_Free(mName);\\n+  delete mNext;\\n }\\n \\n void \\n@@ -92,27 +92,15 @@ nsXBLProtoImplField::AppendFieldText(const nsAString& aText)\\n }\\n \\n nsresult\\n-nsXBLProtoImplField::InstallMember(nsIScriptContext* aContext,\\n-                                   nsIContent* aBoundElement, \\n-                                   void* aScriptObject,\\n-                                   void* aTargetClassObject,\\n-                                   const nsCString& aClassStr)\\n+nsXBLProtoImplField::InstallField(nsIScriptContext* aContext,\\n+                                  JSObject* aBoundNode,\\n+                                  nsIURI* aBindingDocURI) const\\n {\\n-  if (mFieldTextLength == 0)\\n-    return NS_OK; // nothing to do.\\n-\\n-  JSContext* cx = (JSContext*) aContext->GetNativeContext();\\n-  NS_ASSERTION(aScriptObject, \\\"uh-oh, script Object should NOT be null or bad things will happen\\\");\\n-  if (!aScriptObject)\\n-    return NS_ERROR_FAILURE;\\n+  NS_PRECONDITION(aBoundNode,\\n+                  \\\"uh-oh, bound node should NOT be null or bad things will \\\"\\n+                  \\\"happen\\\");\\n \\n-  nsCAutoString bindingURI(aClassStr);\\n-  PRInt32 hash = bindingURI.RFindChar('#');\\n-  if (hash != kNotFound)\\n-    bindingURI.Truncate(hash);\\n-  \\n-  // compile the literal string \\n-  jsval result = JSVAL_NULL;\\n+  jsval result = JSVAL_VOID;\\n   \\n   // EvaluateStringWithValue and JS_DefineUCProperty can both trigger GC, so\\n   // protect |result| here.\\n@@ -120,39 +108,40 @@ nsXBLProtoImplField::InstallMember(nsIScriptContext* aContext,\\n   nsAutoGCRoot root(&result, &rv);\\n   if (NS_FAILED(rv))\\n     return rv;\\n-  PRBool undefined;\\n-  // XXX Need a URI here!\\n-  nsCOMPtr<nsIScriptContext> context = aContext;\\n-  rv = context->EvaluateStringWithValue(nsDependentString(mFieldText,\\n-                                                          mFieldTextLength), \\n-                                        aScriptObject,\\n-                                        nsnull, bindingURI.get(),\\n-                                        mLineNumber, nsnull,\\n-                                        (void*) &result, &undefined);\\n-  if (NS_FAILED(rv))\\n-    return rv;\\n \\n-  if (!undefined) {\\n-    // Define the evaluated result as a JS property\\n-    nsDependentString name(mName);\\n-    JSAutoRequest ar(cx);\\n-    if (!::JS_DefineUCProperty(cx, static_cast<JSObject *>(aScriptObject),\\n-                               reinterpret_cast<const jschar*>(mName), \\n-                               name.Length(), result, nsnull, nsnull, mJSAttributes))\\n-      return NS_ERROR_OUT_OF_MEMORY;\\n-  }\\n+  if (mFieldTextLength != 0) {\\n+    nsCAutoString uriSpec;\\n+    aBindingDocURI->GetSpec(uriSpec);\\n   \\n-  return NS_OK;\\n-}\\n+    // compile the literal string\\n+    // XXX Could we produce a better principal here?  Should be able\\n+    // to, really!\\n+    PRBool undefined;\\n+    nsCOMPtr<nsIScriptContext> context = aContext;\\n+    rv = context->EvaluateStringWithValue(nsDependentString(mFieldText,\\n+                                                            mFieldTextLength), \\n+                                          aBoundNode,\\n+                                          nsnull, uriSpec.get(),\\n+                                          mLineNumber, nsnull,\\n+                                          (void*) &result, &undefined);\\n+    if (NS_FAILED(rv))\\n+      return rv;\\n \\n-nsresult \\n-nsXBLProtoImplField::CompileMember(nsIScriptContext* aContext, const nsCString& aClassStr,\\n-                                   void* aClassObject)\\n-{\\n-  return NS_OK;\\n-}\\n+    if (undefined) {\\n+      result = JSVAL_VOID;\\n+    }\\n+  }\\n \\n-void\\n-nsXBLProtoImplField::Traverse(nsCycleCollectionTraversalCallback &cb) const\\n-{\\n+  // Define the evaluated result as a JS property\\n+  nsDependentString name(mName);\\n+  JSContext* cx = (JSContext*) aContext->GetNativeContext();\\n+  JSAutoRequest ar(cx);\\n+  if (!::JS_DefineUCProperty(cx, aBoundNode,\\n+                             reinterpret_cast<const jschar*>(mName), \\n+                             name.Length(), result, nsnull, nsnull,\\n+                             mJSAttributes)) {\\n+    return NS_ERROR_OUT_OF_MEMORY;\\n+  }\\n+  \\n+  return NS_OK;\\n }\\ndiff --git a/content/xbl/src/nsXBLProtoImplField.h b/content/xbl/src/nsXBLProtoImplField.h\\nindex 06758e2..8c1d582 100644\\n--- a/content/xbl/src/nsXBLProtoImplField.h\\n+++ b/content/xbl/src/nsXBLProtoImplField.h\\n@@ -46,30 +46,31 @@\\n #include \\\"nsString.h\\\"\\n #include \\\"nsXBLProtoImplMember.h\\\"\\n \\n-class nsXBLProtoImplField: public nsXBLProtoImplMember\\n+class nsIURI;\\n+\\n+class nsXBLProtoImplField\\n {\\n public:\\n   nsXBLProtoImplField(const PRUnichar* aName, const PRUnichar* aReadOnly);\\n-  virtual ~nsXBLProtoImplField();\\n-  virtual void Destroy(PRBool aIsCompiled);\\n+  ~nsXBLProtoImplField();\\n \\n   void AppendFieldText(const nsAString& aText);\\n   void SetLineNumber(PRUint32 aLineNumber) {\\n     mLineNumber = aLineNumber;\\n   }\\n   \\n-  virtual nsresult InstallMember(nsIScriptContext* aContext,\\n-                                 nsIContent* aBoundElement, \\n-                                 void* aScriptObject,\\n-                                 void* aTargetClassObject,\\n-                                 const nsCString& aClassStr);\\n-  virtual nsresult CompileMember(nsIScriptContext* aContext,\\n-                                 const nsCString& aClassStr,\\n-                                 void* aClassObject);\\n+  nsXBLProtoImplField* GetNext() const { return mNext; }\\n+  void SetNext(nsXBLProtoImplField* aNext) { mNext = aNext; }\\n+\\n+  nsresult InstallField(nsIScriptContext* aContext,\\n+                        JSObject* aBoundNode, nsIURI*\\n+                        aBindingDocURI) const;\\n \\n-  virtual void Traverse(nsCycleCollectionTraversalCallback &cb) const;\\n+  const PRUnichar* GetName() const { return mName; }\\n \\n protected:\\n+  nsXBLProtoImplField* mNext;\\n+  PRUnichar* mName;\\n   PRUnichar* mFieldText;\\n   PRUint32 mFieldTextLength;\\n   PRUint32 mLineNumber;\\ndiff --git a/content/xbl/src/nsXBLPrototypeBinding.cpp b/content/xbl/src/nsXBLPrototypeBinding.cpp\\nindex 24f6205..f41c948 100644\\n--- a/content/xbl/src/nsXBLPrototypeBinding.cpp\\n+++ b/content/xbl/src/nsXBLPrototypeBinding.cpp\\n@@ -366,6 +366,25 @@ nsXBLPrototypeBinding::Traverse(nsCycleCollectionTraversalCallback &cb) const\\n }\\n \\n void\\n+nsXBLPrototypeBinding::Unlink()\\n+{\\n+  mBinding = nsnull;\\n+  if (mImplementation)\\n+    mImplementation->Unlink();\\n+  if (mResources)\\n+    NS_IF_RELEASE(mResources->mLoader);\\n+\\n+  // I'm not sure whether it would be safer to just nuke the tables or to\\n+  // traverse them with unlinking functions...  or whether we even need to\\n+  // unlink them.  I think we need to at least clean up mInsertionPointTable\\n+  // becase it can hold strong refs to nodes in the binding document.\\n+  delete mInsertionPointTable;\\n+  mInsertionPointTable = nsnull;\\n+  delete mInterfaceTable;\\n+  mInterfaceTable = nsnull;\\n+}\\n+\\n+void\\n nsXBLPrototypeBinding::Initialize()\\n {\\n   nsIContent* content = GetImmediateChild(nsGkAtoms::content);\\n@@ -822,7 +841,7 @@ nsXBLPrototypeBinding::InitClass(const nsCString& aClassName,\\n   *aClassObject = nsnull;\\n \\n   return nsXBLBinding::DoInitJSClass(aContext, aGlobal, aScriptObject,\\n-                                     aClassName, aClassObject);\\n+                                     aClassName, this, aClassObject);\\n }\\n \\n nsIContent*\\ndiff --git a/content/xbl/src/nsXBLPrototypeBinding.h b/content/xbl/src/nsXBLPrototypeBinding.h\\nindex ee6e770..3e21c34a 100644\\n--- a/content/xbl/src/nsXBLPrototypeBinding.h\\n+++ b/content/xbl/src/nsXBLPrototypeBinding.h\\n@@ -50,6 +50,7 @@\\n #include \\\"nsHashtable.h\\\"\\n #include \\\"nsIXBLDocumentInfo.h\\\"\\n #include \\\"nsCOMArray.h\\\"\\n+#include \\\"nsXBLProtoImpl.h\\\"\\n \\n class nsIAtom;\\n class nsIDocument;\\n@@ -58,7 +59,7 @@ class nsISupportsArray;\\n class nsSupportsHashtable;\\n class nsIXBLService;\\n class nsFixedSizeAllocator;\\n-class nsXBLProtoImpl;\\n+class nsXBLProtoImplField;\\n class nsXBLBinding;\\n \\n // *********************************************************************/\\n@@ -94,6 +95,22 @@ public:\\n   nsXBLProtoImplAnonymousMethod* GetDestructor();\\n   nsresult SetDestructor(nsXBLProtoImplAnonymousMethod* aDestructor);\\n \\n+  nsXBLProtoImplField* FindField(const nsString& aFieldName) const\\n+  {\\n+    return mImplementation ? mImplementation->FindField(aFieldName) : nsnull;\\n+  }\\n+\\n+  // Resolve all the fields for this binding on the object |obj|.\\n+  // False return means a JS exception was set.\\n+  PRBool ResolveAllFields(JSContext* cx, JSObject* obj) const\\n+  {\\n+    return !mImplementation || mImplementation->ResolveAllFields(cx, obj);\\n+  }\\n+\\n+  const nsCString& ClassName() const {\\n+    return mImplementation ? mImplementation->mClassName : EmptyCString();\\n+  }\\n+\\n   nsresult InitClass(const nsCString& aClassName, JSContext * aContext,\\n                      JSObject * aGlobal, JSObject * aScriptObject,\\n                      void ** aClassObject);\\n@@ -172,6 +189,7 @@ public:\\n                 nsIContent* aElement);\\n \\n   void Traverse(nsCycleCollectionTraversalCallback &cb) const;\\n+  void Unlink();\\n \\n // Static members\\n   static PRUint32 gRefCnt;\\ndiff --git a/content/xbl/src/nsXBLResourceLoader.cpp b/content/xbl/src/nsXBLResourceLoader.cpp\\nindex 26766c7..b349a56 100644\\n--- a/content/xbl/src/nsXBLResourceLoader.cpp\\n+++ b/content/xbl/src/nsXBLResourceLoader.cpp\\n@@ -60,7 +60,9 @@\\n #include \\\"nsContentUtils.h\\\"\\n \\n NS_IMPL_CYCLE_COLLECTION_CLASS(nsXBLResourceLoader)\\n-NS_IMPL_CYCLE_COLLECTION_UNLINK_0(nsXBLResourceLoader)\\n+NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsXBLResourceLoader)\\n+NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mBoundElements)\\n+NS_IMPL_CYCLE_COLLECTION_UNLINK_END\\n NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsXBLResourceLoader)\\n NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mBoundElements)\\n NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END\\ndiff --git a/content/xbl/test/Makefile.in b/content/xbl/test/Makefile.in\\nindex 029ec10..26db993 100644\\n--- a/content/xbl/test/Makefile.in\\n+++ b/content/xbl/test/Makefile.in\\n@@ -50,6 +50,7 @@ _TEST_FILES =\\t\\\\\\n \\t\\ttest_bug296375.xul \\\\\\n \\t\\ttest_bug366770.html \\\\\\n \\t\\ttest_bug371724.xhtml \\\\\\n+\\t\\ttest_bug372769.xhtml \\\\\\n \\t\\t$(NULL)\\n \\n libs:: $(_TEST_FILES)\\ndiff --git a/dom/src/base/nsDOMClassInfo.cpp b/dom/src/base/nsDOMClassInfo.cpp\\nindex 5c18513..0ff7b6a 100644\\n--- a/dom/src/base/nsDOMClassInfo.cpp\\n+++ b/dom/src/base/nsDOMClassInfo.cpp\\n@@ -477,7 +477,8 @@ static const char kDOMStringBundleURL[] =\\n // possible.\\n \\n #define ELEMENT_SCRIPTABLE_FLAGS                                              \\\\\\n-  (NODE_SCRIPTABLE_FLAGS & ~nsIXPCScriptable::CLASSINFO_INTERFACES_ONLY)\\n+  ((NODE_SCRIPTABLE_FLAGS & ~nsIXPCScriptable::CLASSINFO_INTERFACES_ONLY) |   \\\\\\n+   nsIXPCScriptable::WANT_ENUMERATE)\\n \\n #define EXTERNAL_OBJ_SCRIPTABLE_FLAGS                                         \\\\\\n   (ELEMENT_SCRIPTABLE_FLAGS & ~nsIXPCScriptable::USE_JSSTUB_FOR_SETPROPERTY | \\\\\\n@@ -6940,6 +6941,32 @@ nsElementSH::PostCreate(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\\n   return NS_OK;\\n }\\n \\n+NS_IMETHODIMP\\n+nsElementSH::Enumerate(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\\n+                       JSObject *obj, PRBool *_retval)\\n+{\\n+  // Make sure to not call the superclass here!\\n+  nsCOMPtr<nsIContent> content(do_QueryWrappedNative(wrapper));\\n+  NS_ENSURE_TRUE(content, NS_ERROR_UNEXPECTED);\\n+\\n+  nsIDocument* doc = content->GetOwnerDoc();\\n+  if (!doc) {\\n+    // Nothing else to do here\\n+    return NS_OK;\\n+  }\\n+\\n+  nsXBLBinding* binding = doc->BindingManager()->GetBinding(content);\\n+  if (!binding) {\\n+    // Nothing else to do here\\n+    return NS_OK;\\n+  }\\n+\\n+  *_retval = binding->ResolveAllFields(cx, obj);\\n+  \\n+  return NS_OK;\\n+}\\n+  \\n+\\n // Generic array scriptable helper.\\n \\n NS_IMETHODIMP\\ndiff --git a/dom/src/base/nsDOMClassInfo.h b/dom/src/base/nsDOMClassInfo.h\\nindex da0f838..34bbc96 100644\\n--- a/dom/src/base/nsDOMClassInfo.h\\n+++ b/dom/src/base/nsDOMClassInfo.h\\n@@ -563,6 +563,8 @@ protected:\\n public:\\n   NS_IMETHOD PostCreate(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\\n                         JSObject *obj);\\n+  NS_IMETHOD Enumerate(nsIXPConnectWrappedNative *wrapper, JSContext *cx,\\n+                       JSObject *obj, PRBool *_retval);\\n \\n   static nsIClassInfo *doCreate(nsDOMClassInfoData* aData)\\n   {\\n\""}