{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas9bec765\""},"diff":"\"9bec765 more menu cleanup, don't pre-load the help menu since it doesn't do anything any more. b=396520 r=cbarrett sr=roc a=roc\\ndiff --git a/widget/src/cocoa/nsMenuBarX.h b/widget/src/cocoa/nsMenuBarX.h\\nindex 72505b5..46e3d84 100644\\n--- a/widget/src/cocoa/nsMenuBarX.h\\n+++ b/widget/src/cocoa/nsMenuBarX.h\\n@@ -91,9 +91,7 @@ class nsMenuBarX : public nsIMenuBar,\\n public:\\n     nsMenuBarX();\\n     virtual ~nsMenuBarX();\\n-    \\n-    enum {kApplicationMenuID = 1};\\n-    \\n+\\n     // |NSMenuItem|s target Objective-C objects\\n     static NativeMenuItemTarget* sNativeEventTarget;\\n     \\ndiff --git a/widget/src/cocoa/nsMenuBarX.mm b/widget/src/cocoa/nsMenuBarX.mm\\nindex b69b623..f09a613 100644\\n--- a/widget/src/cocoa/nsMenuBarX.mm\\n+++ b/widget/src/cocoa/nsMenuBarX.mm\\n@@ -136,50 +136,34 @@ nsMenuBarX::~nsMenuBarX()\\n nsEventStatus \\n nsMenuBarX::MenuItemSelected(const nsMenuEvent &aMenuEvent)\\n {\\n-  // Dispatch menu event\\n-  nsEventStatus eventStatus = nsEventStatus_eIgnore;\\n-  \\n   for (PRInt32 i = mMenusArray.Count() - 1; i >= 0; i--) {\\n     nsCOMPtr<nsIMenu> menu = mMenusArray.ObjectAt(i);\\n     nsCOMPtr<nsIMenuListener> menuListener = do_QueryInterface(menu);\\n     if (menuListener) {\\n-      eventStatus = menuListener->MenuItemSelected(aMenuEvent);\\n-      if (nsEventStatus_eIgnore != eventStatus)\\n+      nsEventStatus eventStatus = menuListener->MenuItemSelected(aMenuEvent);\\n+      if (eventStatus != nsEventStatus_eIgnore)\\n         return eventStatus;\\n     }\\n   }\\n-  return eventStatus;\\n+  return nsEventStatus_eIgnore;\\n }\\n \\n \\n nsEventStatus \\n nsMenuBarX::MenuSelected(const nsMenuEvent &aMenuEvent)\\n {\\n-  // Dispatch event\\n-  nsEventStatus eventStatus = nsEventStatus_eIgnore;\\n-  \\n-  nsCOMPtr<nsIMenuListener> menuListener;\\n-  if (menuListener) {\\n-    //TODO: MenuSelected is the right thing to call...\\n-    //eventStatus = menuListener->MenuSelected(aMenuEvent);\\n-    eventStatus = menuListener->MenuItemSelected(aMenuEvent);\\n-    if (nsEventStatus_eIgnore != eventStatus)\\n-      return eventStatus;\\n-  }\\n-  else {\\n-    for (PRInt32 i = mMenusArray.Count() - 1; i >= 0; i--) {\\n-      nsCOMPtr<nsIMenu> menu = mMenusArray.ObjectAt(i);\\n-      nsCOMPtr<nsIMenuListener> thisListener = do_QueryInterface(menu);\\n-      if (thisListener) {\\n-        //TODO: MenuSelected is the right thing to call...\\n-        //eventStatus = menuListener->MenuSelected(aMenuEvent);\\n-        eventStatus = thisListener->MenuItemSelected(aMenuEvent);\\n-        if (nsEventStatus_eIgnore != eventStatus)\\n-          return eventStatus;\\n-      }\\n+  for (PRInt32 i = mMenusArray.Count() - 1; i >= 0; i--) {\\n+    nsCOMPtr<nsIMenu> menu = mMenusArray.ObjectAt(i);\\n+    nsCOMPtr<nsIMenuListener> thisListener = do_QueryInterface(menu);\\n+    if (thisListener) {\\n+      //TODO: MenuSelected is the right thing to call...\\n+      //eventStatus = menuListener->MenuSelected(aMenuEvent);\\n+      nsEventStatus eventStatus = thisListener->MenuItemSelected(aMenuEvent);\\n+      if (eventStatus != nsEventStatus_eIgnore)\\n+        return eventStatus;\\n     }\\n   }\\n-  return eventStatus;\\n+  return nsEventStatus_eIgnore;\\n }\\n \\n \\n@@ -205,9 +189,7 @@ nsMenuBarX::SetRebuild(PRBool aNeedsRebuild)\\n }\\n \\n \\n-// Do what's necessary to conform to the Aqua guidelines for menus. Initially, this\\n-// means removing 'Quit' from the file menu and 'Preferences' from the edit menu, along\\n-// with their various separators (if present).\\n+// Do what's necessary to conform to the Aqua guidelines for menus.\\n void\\n nsMenuBarX::AquifyMenuBar()\\n {\\n@@ -380,7 +362,7 @@ nsMenuBarX::MenuConstruct(const nsMenuEvent & aMenuEvent, nsIWidget* aParentWind\\n   if (!mMenuBarContent)\\n     return nsEventStatus_eIgnore;\\n   \\n-  Create(aParentWindow);\\n+  SetParent(aParentWindow);\\n   \\n   AquifyMenuBar();\\n   \\n@@ -396,9 +378,8 @@ nsMenuBarX::MenuConstruct(const nsMenuEvent & aMenuEvent, nsIWidget* aParentWind\\n   doc->AddMutationObserver(this);\\n   mDocument = doc;\\n \\n-  // set this as a nsMenuListener on aParentWindow\\n   aParentWindow->AddMenuListener((nsIMenuListener *)this);\\n-  \\n+\\n   PRUint32 count = mMenuBarContent->GetChildCount();\\n   for (PRUint32 i = 0; i < count; i++) { \\n     nsIContent *menu = mMenuBarContent->GetChildAt(i);\\n@@ -410,31 +391,19 @@ nsMenuBarX::MenuConstruct(const nsMenuEvent & aMenuEvent, nsIWidget* aParentWind\\n         menu->GetAttr(kNameSpaceID_None, nsWidgetAtoms::label, menuName);\\n         menu->GetAttr(kNameSpaceID_None, nsWidgetAtoms::accesskey, menuAccessKey);\\n \\n-        // Don't create the whole menu yet, just add in the top level names\\n-\\n         // Create nsMenu, the menubar will own it\\n         nsCOMPtr<nsIMenu> pnsMenu(do_CreateInstance(kMenuCID));\\n         if (pnsMenu) {\\n           pnsMenu->Create(static_cast<nsIMenuBar*>(this), menuName, menuAccessKey, \\n                           static_cast<nsIChangeManager *>(this), menu);\\n-\\n-          // Make nsMenu a child of nsMenuBar. nsMenuBar takes ownership.\\n           AddMenu(pnsMenu);\\n-          \\n-          if (menu->AttrValueIs(kNameSpaceID_None, nsWidgetAtoms::id,\\n-                                NS_LITERAL_STRING(\\\"menu_Help\\\"), eCaseMatters)) {\\n-            nsMenuEvent event(PR_TRUE, 0, nsnull);\\n-            event.mCommand = (unsigned int)nsnull;\\n-            nsCOMPtr<nsIMenuListener> listener(do_QueryInterface(pnsMenu));\\n-            listener->MenuSelected(event);\\n-          }\\n         }\\n       } \\n     }\\n-  } // for each menu\\n+  }\\n   \\n   // Give the aParentWindow this nsMenuBarX to hold onto.\\n-  // The parent takes ownership\\n+  // The parent takes ownership.\\n   aParentWindow->SetMenuBar(this);\\n   \\n   return nsEventStatus_eIgnore;\\n@@ -768,7 +737,7 @@ NS_IMETHODIMP nsMenuBarX::RemoveAll()\\n \\n NS_IMETHODIMP nsMenuBarX::GetNativeData(void *& aData)\\n {\\n-  aData = (void *) mRootMenu;\\n+  aData = (void*)mRootMenu;\\n   return NS_OK;\\n }\\n \\ndiff --git a/widget/src/cocoa/nsMenuX.mm b/widget/src/cocoa/nsMenuX.mm\\nindex 15feee9..8446faf 100644\\n--- a/widget/src/cocoa/nsMenuX.mm\\n+++ b/widget/src/cocoa/nsMenuX.mm\\n@@ -1159,7 +1159,7 @@ static pascal OSStatus MyMenuEventHandler(EventHandlerCallRef myHandler, EventRe\\n     }\\n   }\\n   else if (kind == kEventMenuOpening || kind == kEventMenuClosed) {\\n-    if (kind == kEventMenuOpening && gRollupListener != nsnull && gRollupWidget != nsnull) {\\n+    if (kind == kEventMenuOpening && gRollupListener && gRollupWidget) {\\n       gRollupListener->Rollup();\\n       return userCanceledErr;\\n     }\\n\""}