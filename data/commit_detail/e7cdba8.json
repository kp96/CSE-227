{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Base7cdba8\""},"diff":"\"e7cdba8 Bug 393184: js_NewGCThing no longer zeros the allocated thing. r=brendan\\ndiff --git a/js/src/jsgc.c b/js/src/jsgc.c\\nindex 30f6d73..de2c9c4 100644\\n--- a/js/src/jsgc.c\\n+++ b/js/src/jsgc.c\\n@@ -1242,12 +1242,6 @@ js_NewGCThing(JSContext *cx, uintN flags, size_t nbytes)\\n     /* We can't fail now, so update flags. */\\n     *flagp = (uint8)flags;\\n \\n-    /*\\n-     * Clear thing before unlocking in case a GC run is about to scan it,\\n-     * finding it via newborn[].\\n-     */\\n-    thing->next = NULL;\\n-    thing->flagp = NULL;\\n #ifdef DEBUG_gchist\\n     gchist[gchpos].lastDitch = doGC;\\n     gchist[gchpos].freeList = rt->gcArenaList[flindex].freeList;\\ndiff --git a/js/src/jsgc.h b/js/src/jsgc.h\\nindex 03d4fb0..bad22b8 100644\\n--- a/js/src/jsgc.h\\n+++ b/js/src/jsgc.h\\n@@ -142,6 +142,12 @@ struct JSGCThing {\\n #define GC_FREELIST_NBYTES(i)   (((i) + 1) * sizeof(JSGCThing))\\n #define GC_FREELIST_INDEX(n)    (((n) / sizeof(JSGCThing)) - 1)\\n \\n+/*\\n+ * Allocates a new GC thing of the given size. After a successful allocation\\n+ * the caller must fully initialize the thing before calling any function that\\n+ * can potentially trigger GC. This will ensure that GC tracing never sees junk\\n+ * values stored in the partially initialized thing.\\n+ */\\n extern void *\\n js_NewGCThing(JSContext *cx, uintN flags, size_t nbytes);\\n \\ndiff --git a/js/src/jsobj.c b/js/src/jsobj.c\\nindex e29c84a..d6f2d4c 100644\\n--- a/js/src/jsobj.c\\n+++ b/js/src/jsobj.c\\n@@ -2465,14 +2465,12 @@ js_NewObject(JSContext *cx, JSClass *clasp, JSObject *proto, JSObject *parent)\\n     if (!obj)\\n         return NULL;\\n \\n-    obj->dslots = NULL;\\n-\\n     /*\\n-     * Root obj to prevent it from being collected out from under this call to\\n-     * js_NewObject. There's a possibilty of GC under the objectHook call-out\\n-     * further below.\\n+     * Initialize all JSObject fields before doing any operation that can\\n+     * potentially trigger GC.\\n      */\\n-    JS_PUSH_TEMP_ROOT_OBJECT(cx, obj, &tvr);\\n+    obj->map = NULL;\\n+    obj->dslots = NULL;\\n \\n     /* Set the proto, parent, and class properties. */\\n     STOBJ_SET_PROTO(obj, proto);\\n@@ -2484,6 +2482,13 @@ js_NewObject(JSContext *cx, JSClass *clasp, JSObject *proto, JSObject *parent)\\n         obj->fslots[i] = JSVAL_VOID;\\n \\n     /*\\n+     * Root obj to prevent it from being collected out from under this call to\\n+     * js_NewObject. There's a possibilty of GC under the objectHook call-out\\n+     * further below.\\n+     */\\n+    JS_PUSH_TEMP_ROOT_OBJECT(cx, obj, &tvr);\\n+\\n+    /*\\n      * Share proto's map only if it has the same JSObjectOps, and only if\\n      * proto's class has the same private and reserved slots as obj's map\\n      * and class have.  We assume that if prototype and object are of the\\n\""}