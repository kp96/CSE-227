{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas1bb706b\""},"diff":"\"1bb706b backing out bug 387990 because it regressed bug 396567\\ndiff --git a/widget/src/gtk2/nsWindow.cpp b/widget/src/gtk2/nsWindow.cpp\\nindex 6558a19..f477b7f 100644\\n--- a/widget/src/gtk2/nsWindow.cpp\\n+++ b/widget/src/gtk2/nsWindow.cpp\\n@@ -227,9 +227,6 @@ static nsresult    initialize_prefs        (void);\\n nsWindow *nsWindow::mLastDragMotionWindow = NULL;\\n PRBool nsWindow::sIsDraggingOutOf = PR_FALSE;\\n \\n-// the last window that had a MOUSE_ENTER event\\n-nsWindow *nsWindow::sLastMouseEnterWindow = nsnull;\\n-\\n // This is the time of the last button press event.  The drag service\\n // uses it as the time to start drags.\\n guint32   nsWindow::mLastButtonPressTime = 0;\\n@@ -422,10 +419,6 @@ nsWindow::Destroy(void)\\n     if (mIsDestroyed || !mCreated)\\n         return NS_OK;\\n \\n-    if (this == sLastMouseEnterWindow) {\\n-        sLastMouseEnterWindow = nsnull;\\n-    }\\n-\\n     LOG((\\\"nsWindow::Destroy [%p]\\\\n\\\", (void *)this));\\n     mIsDestroyed = PR_TRUE;\\n     mCreated = PR_FALSE;\\n@@ -1896,14 +1889,6 @@ nsWindow::OnEnterNotifyEvent(GtkWidget *aWidget, GdkEventCrossing *aEvent)\\n     if (aEvent->subwindow != NULL)\\n         return;\\n \\n-    // Do not fire MOUSE_ENTER event if the mouse pointer is not on it.\\n-    // In this case, enter_notify_event is not triggered by mouse.\\n-    if (aEvent->x < 0 || aEvent->y < 0 ||\\n-        aEvent->x >= mBounds.width || aEvent->y >= mBounds.height) {\\n-        return;\\n-    }\\n-    sLastMouseEnterWindow = this;\\n-\\n     nsMouseEvent event(PR_TRUE, NS_MOUSE_ENTER, this, nsMouseEvent::eReal);\\n \\n     event.refPoint.x = nscoord(aEvent->x);\\n@@ -1924,16 +1909,6 @@ nsWindow::OnLeaveNotifyEvent(GtkWidget *aWidget, GdkEventCrossing *aEvent)\\n     if (aEvent->subwindow != NULL)\\n         return;\\n \\n-    // Do not fire MOUSE_EXIT event if the last MOUSE_ENTER event was not for\\n-    // the leaving window, or the mouse pointer is still on the leaving window.\\n-    // In this case, leave_notify_event is not triggered by mouse.\\n-    if (this != sLastMouseEnterWindow ||\\n-        (aEvent->x >= 0 && aEvent->y >= 0 &&\\n-         aEvent->x < mBounds.width && aEvent->y < mBounds.height)) {\\n-        return;\\n-    }\\n-    sLastMouseEnterWindow = nsnull;\\n-\\n     nsMouseEvent event(PR_TRUE, NS_MOUSE_EXIT, this, nsMouseEvent::eReal);\\n \\n     event.refPoint.x = nscoord(aEvent->x);\\ndiff --git a/widget/src/gtk2/nsWindow.h b/widget/src/gtk2/nsWindow.h\\nindex 6e6ea43..a4842ba 100644\\n--- a/widget/src/gtk2/nsWindow.h\\n+++ b/widget/src/gtk2/nsWindow.h\\n@@ -426,9 +426,6 @@ private:\\n     // drag in progress\\n     static PRBool DragInProgress(void);\\n \\n-    // the last window that had a MOUSE_ENTER event\\n-    static nsWindow  *sLastMouseEnterWindow;\\n-\\n     void         ResetDragMotionTimer     (GtkWidget      *aWidget,\\n                                            GdkDragContext *aDragContext,\\n                                            gint           aX,\\n\""}