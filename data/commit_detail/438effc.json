{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas438effc\""},"diff":"\"438effc Bug 395045. Expire cached content-viewers after they've been unused for 20-30 minutes. r+sr+a=bz\\ndiff --git a/docshell/build/nsDocShellModule.cpp b/docshell/build/nsDocShellModule.cpp\\nindex 75e2f63..fb4acae 100644\\n--- a/docshell/build/nsDocShellModule.cpp\\n+++ b/docshell/build/nsDocShellModule.cpp\\n@@ -80,12 +80,16 @@ Initialize(nsIModule* aSelf)\\n   gInitialized = PR_TRUE;\\n \\n   nsresult rv = nsSHistory::Startup();\\n+  NS_ENSURE_SUCCESS(rv, rv);\\n+\\n+  rv = nsSHEntry::Startup();\\n   return rv;\\n }\\n \\n PR_STATIC_CALLBACK(void)\\n Shutdown(nsIModule* aSelf)\\n {\\n+  nsSHEntry::Shutdown();\\n   gInitialized = PR_FALSE;\\n }\\n \\ndiff --git a/docshell/shistory/public/nsISHistoryInternal.idl b/docshell/shistory/public/nsISHistoryInternal.idl\\nindex 1dfd5961..ea35fc2 100644\\n--- a/docshell/shistory/public/nsISHistoryInternal.idl\\n+++ b/docshell/shistory/public/nsISHistoryInternal.idl\\n@@ -46,12 +46,13 @@ interface nsIDocShell;\\n \\n %{C++\\n #define NS_SHISTORY_INTERNAL_CID \\\\\\n-{0x5b4cba4c, 0xbf67, 0x499a, {0xae, 0x2c, 0x3f, 0x76, 0x65, 0x6f, 0x4a, 0x4e}}\\n+{ 0x9c47c121, 0x1c6e, 0x4d8f, \\\\\\n+  { 0xb9, 0x04, 0x3a, 0xc9, 0x68, 0x11, 0x6e, 0x88 } }\\n \\n #define NS_SHISTORY_INTERNAL_CONTRACTID \\\"@mozilla.org/browser/shistory-internal;1\\\"\\n %}\\n \\n-[scriptable, uuid(df8788d6-c0ed-4517-b47e-c719afc94284)]\\n+[scriptable, uuid(9c47c121-1c6e-4d8f-b904-3ac968116e88)]\\n interface nsISHistoryInternal: nsISupports\\n {\\n   /**\\n@@ -98,4 +99,10 @@ interface nsISHistoryInternal: nsISupports\\n    * the previous viewer.\\n    */\\n    void evictContentViewers(in long previousIndex, in long index);\\n+   \\n+   /**\\n+    * Evict the content viewer associated with a session history entry\\n+    * that has timed out.\\n+    */\\n+   void evictExpiredContentViewerForEntry(in nsISHEntry aEntry);\\n };\\ndiff --git a/docshell/shistory/src/nsSHEntry.cpp b/docshell/shistory/src/nsSHEntry.cpp\\nindex 9095d1a..32a8bc8 100644\\n--- a/docshell/shistory/src/nsSHEntry.cpp\\n+++ b/docshell/shistory/src/nsSHEntry.cpp\\n@@ -51,14 +51,53 @@\\n #include \\\"nsIDOMDocument.h\\\"\\n #include \\\"nsAutoPtr.h\\\"\\n #include \\\"nsThreadUtils.h\\\"\\n+#include \\\"nsIWebNavigation.h\\\"\\n+#include \\\"nsISHistory.h\\\"\\n+#include \\\"nsISHistoryInternal.h\\\"\\n \\n+// Hardcode this to time out unused content viewers after 30 minutes\\n+#define CONTENT_VIEWER_TIMEOUT_SECONDS 30*60\\n \\n+typedef nsExpirationTracker<nsSHEntry,3> HistoryTrackerBase;\\n+class HistoryTracker : public HistoryTrackerBase {\\n+public:\\n+  // Expire cached contentviewers after 20-30 minutes in the cache.\\n+  HistoryTracker() : HistoryTrackerBase((CONTENT_VIEWER_TIMEOUT_SECONDS/2)*1000) {}\\n+  \\n+protected:\\n+  virtual void NotifyExpired(nsSHEntry* aObj) {\\n+    RemoveObject(aObj);\\n+    aObj->Expire();\\n+  }\\n+};\\n+\\n+static HistoryTracker *gHistoryTracker = nsnull;\\n static PRUint32 gEntryID = 0;\\n \\n+nsresult nsSHEntry::Startup()\\n+{\\n+  gHistoryTracker = new HistoryTracker();\\n+  return gHistoryTracker ? NS_OK : NS_ERROR_OUT_OF_MEMORY;\\n+}\\n+\\n+void nsSHEntry::Shutdown()\\n+{\\n+  delete gHistoryTracker;\\n+  gHistoryTracker = nsnull;\\n+}\\n+\\n+static void StopTrackingEntry(nsSHEntry *aEntry)\\n+{\\n+  if (aEntry->GetExpirationState()->IsTracked()) {\\n+    gHistoryTracker->RemoveObject(aEntry);\\n+  }\\n+}\\n+\\n //*****************************************************************************\\n //***    nsSHEntry: Object Management\\n //*****************************************************************************\\n \\n+\\n nsSHEntry::nsSHEntry() \\n   : mLoadType(0)\\n   , mID(gEntryID++)\\n@@ -109,6 +148,8 @@ ClearParentPtr(nsISHEntry* aEntry, void* /* aData */)\\n \\n nsSHEntry::~nsSHEntry()\\n {\\n+  StopTrackingEntry(this);\\n+\\n   // Since we never really remove kids from SHEntrys, we need to null\\n   // out the mParent pointers on all our kids.\\n   mChildren.EnumerateForwards(ClearParentPtr, nsnull);\\n@@ -193,6 +234,8 @@ nsSHEntry::SetContentViewer(nsIContentViewer *aViewer)\\n       mDocument->SetShellsHidden(PR_TRUE);\\n       mDocument->AddMutationObserver(this);\\n     }\\n+    \\n+    gHistoryTracker->AddObject(this);\\n   }\\n \\n   return NS_OK;\\n@@ -637,6 +680,7 @@ nsSHEntry::DropPresentationState()\\n   if (mContentViewer)\\n     mContentViewer->ClearHistoryEntry();\\n \\n+  StopTrackingEntry(this);\\n   mContentViewer = nsnull;\\n   mSticky = PR_TRUE;\\n   mWindowState = nsnull;\\n@@ -645,6 +689,31 @@ nsSHEntry::DropPresentationState()\\n   mRefreshURIList = nsnull;\\n }\\n \\n+void\\n+nsSHEntry::Expire()\\n+{\\n+  // This entry has timed out. If we still have a content viewer, we need to\\n+  // get it evicted.\\n+  if (!mContentViewer)\\n+    return;\\n+  nsCOMPtr<nsISupports> container;\\n+  mContentViewer->GetContainer(getter_AddRefs(container));\\n+  nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryInterface(container);\\n+  if (!treeItem)\\n+    return;\\n+  // We need to find the root DocShell since only that object has an\\n+  // SHistory and we need the SHistory to evict content viewers\\n+  nsCOMPtr<nsIDocShellTreeItem> root;\\n+  treeItem->GetSameTypeRootTreeItem(getter_AddRefs(root));\\n+  nsCOMPtr<nsIWebNavigation> webNav = do_QueryInterface(root);\\n+  nsCOMPtr<nsISHistory> history;\\n+  webNav->GetSessionHistory(getter_AddRefs(history));\\n+  nsCOMPtr<nsISHistoryInternal> historyInt = do_QueryInterface(history);\\n+  if (!historyInt)\\n+    return;\\n+  historyInt->EvictExpiredContentViewerForEntry(this);\\n+}\\n+\\n //*****************************************************************************\\n //    nsSHEntry: nsIMutationObserver\\n //*****************************************************************************\\ndiff --git a/docshell/shistory/src/nsSHEntry.h b/docshell/shistory/src/nsSHEntry.h\\nindex 6819e7d..95de453 100644\\n--- a/docshell/shistory/src/nsSHEntry.h\\n+++ b/docshell/shistory/src/nsSHEntry.h\\n@@ -58,6 +58,7 @@\\n #include \\\"nsRect.h\\\"\\n #include \\\"nsSupportsArray.h\\\"\\n #include \\\"nsIMutationObserver.h\\\"\\n+#include \\\"nsExpirationTracker.h\\\"\\n \\n class nsSHEntry : public nsISHEntry,\\n                   public nsISHContainer,\\n@@ -75,6 +76,13 @@ public:\\n \\n   void DropPresentationState();\\n \\n+  void Expire();\\n+  \\n+  nsExpirationState *GetExpirationState() { return &mExpirationState; }\\n+  \\n+  static nsresult Startup();\\n+  static void Shutdown();\\n+  \\n private:\\n   ~nsSHEntry();\\n   void DocumentMutated();\\n@@ -104,6 +112,7 @@ private:\\n   nsCOMArray<nsIDocShellTreeItem> mChildShells;\\n   nsCOMPtr<nsISupportsArray>      mRefreshURIList;\\n   nsCOMPtr<nsISupports>           mOwner;\\n+  nsExpirationState               mExpirationState;\\n };\\n \\n #endif /* nsSHEntry_h */\\ndiff --git a/docshell/shistory/src/nsSHistory.cpp b/docshell/shistory/src/nsSHistory.cpp\\nindex b3443ff..fd231b6 100644\\n--- a/docshell/shistory/src/nsSHistory.cpp\\n+++ b/docshell/shistory/src/nsSHistory.cpp\\n@@ -789,11 +789,17 @@ nsSHistory::EvictWindowContentViewers(PRInt32 aFromIndex, PRInt32 aToIndex)\\n     }\\n     endIndex = PR_MIN(mLength, aFromIndex + gHistoryMaxViewers);\\n   }\\n+  \\n+  EvictContentViewersInRange(startIndex, endIndex);\\n+}\\n \\n+void\\n+nsSHistory::EvictContentViewersInRange(PRInt32 aStart, PRInt32 aEnd)\\n+{\\n   nsCOMPtr<nsISHTransaction> trans;\\n-  GetTransactionAtIndex(startIndex, getter_AddRefs(trans));\\n+  GetTransactionAtIndex(aStart, getter_AddRefs(trans));\\n \\n-  for (PRInt32 i = startIndex; i < endIndex; ++i) {\\n+  for (PRInt32 i = aStart; i < aEnd; ++i) {\\n     nsCOMPtr<nsISHEntry> entry;\\n     trans->GetSHEntry(getter_AddRefs(entry));\\n     nsCOMPtr<nsIContentViewer> viewer;\\n@@ -941,6 +947,46 @@ nsSHistory::EvictGlobalContentViewer()\\n   }  // while shouldTryEviction\\n }\\n \\n+NS_IMETHODIMP\\n+nsSHistory::EvictExpiredContentViewerForEntry(nsISHEntry *aEntry)\\n+{\\n+  PRInt32 startIndex = PR_MAX(0, mIndex - gHistoryMaxViewers);\\n+  PRInt32 endIndex = PR_MIN(mLength - 1,\\n+                            mIndex + gHistoryMaxViewers);\\n+  nsCOMPtr<nsISHTransaction> trans;\\n+  GetTransactionAtIndex(startIndex, getter_AddRefs(trans));\\n+\\n+  PRInt32 i;\\n+  for (i = startIndex; i <= endIndex; ++i) {\\n+    nsCOMPtr<nsISHEntry> entry;\\n+    trans->GetSHEntry(getter_AddRefs(entry));\\n+    if (entry == aEntry)\\n+      break;\\n+\\n+    nsISHTransaction *temp = trans;\\n+    temp->GetNext(getter_AddRefs(trans));\\n+  }\\n+  if (i > endIndex)\\n+    return NS_OK;\\n+  \\n+  NS_ASSERTION(i != mIndex, \\\"How did the current session entry expire?\\\");\\n+  if (i == mIndex)\\n+    return NS_OK;\\n+  \\n+  // We evict content viewers for the expired entry and any other entries that\\n+  // we would have to go through the expired entry to get to (i.e. the entries\\n+  // that have the expired entry between them and the current entry). Those\\n+  // other entries should have timed out already, actually, but this is just\\n+  // to be on the safe side.\\n+  if (i < mIndex) {\\n+    EvictContentViewersInRange(startIndex, i + 1);\\n+  } else {\\n+    EvictContentViewersInRange(i, endIndex + 1);\\n+  }\\n+  \\n+  return NS_OK;\\n+}\\n+\\n // Evicts all content viewers in all history objects.  This is very\\n // inefficient, because it requires a linear search through all SHistory\\n // objects for each viewer to be evicted.  However, this method is called\\ndiff --git a/docshell/shistory/src/nsSHistory.h b/docshell/shistory/src/nsSHistory.h\\nindex 4bd252e..f5298d7 100644\\n--- a/docshell/shistory/src/nsSHistory.h\\n+++ b/docshell/shistory/src/nsSHistory.h\\n@@ -99,6 +99,7 @@ protected:\\n    nsresult PrintHistory();\\n #endif\\n \\n+  void EvictContentViewersInRange(PRInt32 aStartIndex, PRInt32 aEndIndex);\\n   void EvictWindowContentViewers(PRInt32 aFromIndex, PRInt32 aToIndex);\\n   static void EvictGlobalContentViewer();\\n   static void EvictAllContentViewers();\\n\""}