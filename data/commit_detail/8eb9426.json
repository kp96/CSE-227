{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas8eb9426\""},"diff":"\"8eb9426 Fork tabbrowser to make it back into what I want.\\ndiff --git a/browser/base/content/tabbrowser.xml b/browser/base/content/tabbrowser.xml\\nnew file mode 100644\\nindex 0000000..2caa7c7\\n--- /dev/null\\n+++ b/browser/base/content/tabbrowser.xml\\n@@ -0,0 +1,1180 @@\\n+<?xml version=\\\"1.0\\\"?>\\n+\\n+<!--\\n+   - The contents of this file are subject to the Mozilla Public\\n+   - License Version 1.1 (the \\\"License\\\"); you may not use this file\\n+   - except in compliance with the License. You may obtain a copy of\\n+   - the License at http://www.mozilla.org/MPL/\\n+   -\\n+   - Software distributed under the License is distributed on an \\\"AS\\n+   - IS\\\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\\n+   - implied. See the License for the specific language governing\\n+   - rights and limitations under the License.\\n+   -\\n+   - The Original Code is this file as it was released on\\n+   - March 28, 2001.\\n+   -\\n+   - The Initial Developer of the Original Code is David Hyatt\\n+   - Portions created by David Hyatt are Copyright (C) 2001\\n+   - David Hyatt.  All Rights Reserved.\\n+   -\\n+   - Contributor(s):\\n+   -   David Hyatt <hyatt@netscape.com> (Original Author of <tabbrowser>)\\n+   -\\n+   - Alternatively, the contents of this file may be used under the\\n+   - terms of the GNU General Public License Version 2 or later (the\\n+   - \\\"GPL\\\"), in which case the provisions of the GPL are applicable\\n+   - instead of those above.  If you wish to allow use of your\\n+   - version of this file only under the terms of the GPL and not to\\n+   - allow others to use your version of this file under the MPL,\\n+   - indicate your decision by deleting the provisions above and\\n+   - replace them with the notice and other provisions required by\\n+   - the GPL.  If you do not delete the provisions above, a recipient\\n+   - may use your version of this file under either the MPL or the\\n+   - GPL.\\n+  -->\\n+\\n+<!DOCTYPE bindings [\\n+<!ENTITY % tabBrowserDTD SYSTEM \\\"chrome://global/locale/tabbrowser.dtd\\\" >\\n+%tabBrowserDTD;\\n+]>\\n+\\n+<bindings id=\\\"tabBrowserBindings\\\"\\n+          xmlns=\\\"http://www.mozilla.org/xbl\\\"\\n+          xmlns:xul=\\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\"\\n+          xmlns:xbl=\\\"http://www.mozilla.org/xbl\\\">\\n+ \\n+  <binding id=\\\"tabbrowser\\\">\\n+    <resources>\\n+      <stylesheet src=\\\"chrome://global/skin/browser.css\\\"/>\\n+    </resources>\\n+\\n+    <content>\\n+      <xul:stringbundle src=\\\"chrome://global/locale/tabbrowser.properties\\\"/>\\n+      <xul:tabbox flex=\\\"1\\\"\\n+                  onselect=\\\"if (!('updateCurrentBrowser' in this.parentNode) || event.target.localName != 'tabpanels') return; this.parentNode.updateCurrentBrowser();\\\">\\n+        <xul:hbox class=\\\"tabbrowser-strip chromeclass-toolbar\\\" collapsed=\\\"true\\\" tooltip=\\\"_child\\\" context=\\\"_child\\\">\\n+          <xul:tooltip onpopupshowing=\\\"event.preventBubble(); if (document.tooltipNode.hasAttribute('label')) { this.setAttribute('label', document.tooltipNode.getAttribute('label')); return true; } return false;\\\"/>\\n+          <xul:menupopup onpopupshowing=\\\"this.parentNode.parentNode.parentNode.updatePopupMenu(this);\\\">\\n+            <xul:menuitem label=\\\"&newTab.label;\\\" accesskey=\\\"&newTab.accesskey;\\\"\\n+                          xbl:inherits=\\\"oncommand=onnewtab\\\"/>\\n+            <xul:menuseparator/>\\n+            <xul:menuitem label=\\\"&reloadTab.label;\\\" accesskey=\\\"&reloadTab.accesskey;\\\"\\n+                          oncommand=\\\"var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;\\n+                                     tabbrowser.reloadTab(tabbrowser.mContextTab);\\\"/>\\n+            <xul:menuitem label=\\\"&reloadAllTabs.label;\\\" accesskey=\\\"&reloadAllTabs.accesskey;\\\"\\n+                          tbattr=\\\"tabbrowser-multiple\\\"\\n+                          oncommand=\\\"var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;\\n+                                     tabbrowser.reloadAllTabs(tabbrowser.mContextTab);\\\"/>\\n+            <xul:menuseparator/>\\n+            <xul:menuitem label=\\\"&closeTab.label;\\\" accesskey=\\\"&closeTab.accesskey;\\\"\\n+                          tbattr=\\\"tabbrowser-multiple\\\"\\n+                          oncommand=\\\"var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;\\n+                                     tabbrowser.removeTab(tabbrowser.mContextTab);\\\"/>\\n+            <xul:menuseparator/>\\n+            <xul:menuitem label=\\\"&closeOtherTabs.label;\\\" accesskey=\\\"&closeOtherTabs.accesskey;\\\"\\n+                          tbattr=\\\"tabbrowser-multiple\\\"\\n+                          oncommand=\\\"var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;\\n+                                     tabbrowser.removeAllTabsBut(tabbrowser.mContextTab);\\\"/>\\n+          </xul:menupopup>\\n+\\n+          <xul:tabs class=\\\"tabbrowser-tabs\\\" closebutton=\\\"true\\\" flex=\\\"1\\\"\\n+                    tooltiptextnew=\\\"&newTabButton.tooltip;\\\"\\n+                    onclick=\\\"this.parentNode.parentNode.parentNode.onTabClick(event);\\\"\\n+                    ondragover=\\\"nsDragAndDrop.dragOver(event, this.parentNode.parentNode.parentNode);\\n+                                event.stopPropagation();\\\"\\n+                    ondragdrop=\\\"nsDragAndDrop.drop(event, this.parentNode.parentNode.parentNode);\\n+                                event.stopPropagation();\\\"\\n+                    xbl:inherits=\\\"onnewtab\\\"\\n+                    onclosetab=\\\"var node = this.parentNode;\\n+                                while (node.localName != 'tabbrowser')\\n+                                  node = node.parentNode;\\n+                                node.removeCurrentTab();\\\">\\n+            <xul:tab validate=\\\"never\\\" \\n+                     onerror=\\\"this.parentNode.parentNode.parentNode.parentNode.addToMissedIconCache(this.getAttribute('image'));\\n+                              this.removeAttribute('image');\\\"\\n+                     maxwidth=\\\"250\\\" width=\\\"0\\\" minwidth=\\\"30\\\" flex=\\\"100\\\"\\n+                     class=\\\"tabbrowser-tab\\\" label=\\\"&untitledTab;\\\" crop=\\\"end\\\"/>\\n+          </xul:tabs>\\n+        </xul:hbox>\\n+        <xul:tabpanels flex=\\\"1\\\" class=\\\"plain\\\">\\n+          <xul:browser type=\\\"content-primary\\\" xbl:inherits=\\\"tooltip=contenttooltip,contextmenu=contentcontextmenu\\\"/>\\n+        </xul:tabpanels>\\n+      </xul:tabbox>\\n+      <children/>\\n+    </content>\\n+    <implementation>\\n+      <field name=\\\"mPrefs\\\" readonly=\\\"true\\\">\\n+        Components.classes['@mozilla.org/preferences-service;1']\\n+                  .getService(Components.interfaces.nsIPrefService)\\n+                  .getBranch(null);\\n+      </field>\\n+      <field name=\\\"mTabBox\\\">\\n+        document.getAnonymousNodes(this)[1]\\n+      </field>\\n+      <field name=\\\"mStrip\\\">\\n+        this.mTabBox.firstChild\\n+      </field>\\n+      <field name=\\\"mTabContainer\\\">\\n+        this.mStrip.childNodes[2]\\n+      </field>\\n+      <field name=\\\"mPanelContainer\\\">\\n+        this.mTabBox.childNodes[1]\\n+      </field>\\n+      <field name=\\\"mStringBundle\\\">\\n+        document.getAnonymousNodes(this)[0]\\n+      </field>\\n+      <field name=\\\"mCurrentTab\\\">\\n+        null\\n+      </field>\\n+      <field name=\\\"mCurrentBrowser\\\">\\n+        null\\n+      </field>\\n+      <field name=\\\"mProgressListeners\\\">\\n+        null\\n+      </field>\\n+      <field name=\\\"mTabListeners\\\">\\n+        new Array()\\n+      </field>\\n+      <field name=\\\"mTabFilters\\\">\\n+        new Array()\\n+      </field>\\n+      <field name=\\\"mTabbedMode\\\">\\n+        false\\n+      </field>\\n+      <field name=\\\"mIsBusy\\\">\\n+        false\\n+      </field>\\n+      <field name=\\\"mMissedIconCache\\\">\\n+        null\\n+      </field>\\n+      <field name=\\\"mContextTab\\\">\\n+        null\\n+      </field>\\n+\\n+      <!-- A web progress listener object definition for a given tab. --> \\n+      <method name=\\\"mTabProgressListener\\\">\\n+        <parameter name=\\\"aTabBrowser\\\"/>\\n+        <parameter name=\\\"aTab\\\"/>\\n+        <parameter name=\\\"aStartsBlank\\\"/>\\n+        <body>\\n+        <![CDATA[\\n+          return ({\\n+            mTabBrowser: aTabBrowser,\\n+            mTab: aTab,\\n+            mBlank: aStartsBlank,\\n+            mIcon: \\\"\\\", \\n+\\n+            onProgressChange : function (aWebProgress, aRequest,\\n+                                         aCurSelfProgress, aMaxSelfProgress,\\n+                                         aCurTotalProgress, aMaxTotalProgress) {\\n+              if (!this.mBlank && this.mTabBrowser.mCurrentTab == this.mTab) {\\n+                for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {\\n+                  var p = this.mTabBrowser.mProgressListeners[i];\\n+                  if (p)\\n+                    p.onProgressChange(aWebProgress, aRequest,\\n+                                       aCurSelfProgress, aMaxSelfProgress,\\n+                                       aCurTotalProgress, aMaxTotalProgress);\\n+                }\\n+              }\\n+            },\\n+            \\n+            onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)\\n+            {\\n+              if (!aRequest)\\n+                return;\\n+      \\n+              //ignore local/resource:/chrome: files\\n+              if (aStatus == NS_NET_STATUS_READ_FROM || aStatus == NS_NET_STATUS_WROTE_TO)\\n+                return;\\n+\\n+              var oldBlank = this.mBlank;\\n+\\n+              const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;\\n+              const nsIChannel = Components.interfaces.nsIChannel;\\n+              if (!this.mBlank && aStateFlags & nsIWebProgressListener.STATE_START && \\n+                  aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {\\n+                this.mTab.setAttribute(\\\"busy\\\", \\\"true\\\"); \\n+                this.mTab.label = this.mTabBrowser.mStringBundle.getString(\\\"tabs.loading\\\");\\n+                this.mTab.removeAttribute(\\\"image\\\");\\n+                this.mIcon = \\\"\\\";\\n+\\n+                if (this.mTabBrowser.mCurrentTab == this.mTab)\\n+                  this.mTabBrowser.mIsBusy = true;\\n+              }\\n+              else if (aStateFlags & nsIWebProgressListener.STATE_STOP &&\\n+                       aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {\\n+                if (this.mBlank)\\n+                  this.mBlank = false;\\n+                \\n+                this.mTab.removeAttribute(\\\"busy\\\");\\n+                  \\n+                var location = aRequest.QueryInterface(nsIChannel).URI;\\n+                if (this.mIcon) {\\n+                  this.mTab.setAttribute(\\\"image\\\", this.mIcon);\\n+                  mIcon = \\\"\\\";\\n+                }\\n+                else if (this.mTabBrowser.shouldLoadFavIcon(location))\\n+                  this.mTabBrowser.loadFavIcon(location, \\\"image\\\", this.mTab); \\n+\\n+                if (this.mTab.label == this.mTabBrowser.mStringBundle.getString(\\\"tabs.loading\\\"))\\n+                  this.mTabBrowser.setTabTitle(this.mTab);\\n+\\n+                if (this.mTabBrowser.mCurrentTab == this.mTab)\\n+                  this.mTabBrowser.mIsBusy = false;\\n+              }\\n+\\n+              if (!oldBlank && this.mTabBrowser.mCurrentTab == this.mTab) {\\n+                for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {\\n+                  var p = this.mTabBrowser.mProgressListeners[i];\\n+                  if (p)\\n+                    p.onStateChange(aWebProgress, aRequest, aStateFlags, aStatus);\\n+                }\\n+              }\\n+            }\\n+            ,\\n+\\n+            onLocationChange : function(aWebProgress, aRequest, aLocation) {\\n+              if (!this.mBlank && this.mTabBrowser.mCurrentTab == this.mTab) {\\n+                for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {\\n+                  var p = this.mTabBrowser.mProgressListeners[i];\\n+                  if (p)\\n+                    p.onLocationChange(aWebProgress, aRequest, aLocation);\\n+                }\\n+              }\\n+            },\\n+\\n+            onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage) {\\n+              //ignore local/resource:/chrome: files\\n+              if (this.mBlank || aStatus == NS_NET_STATUS_READ_FROM || aStatus == NS_NET_STATUS_WROTE_TO)\\n+                return;\\n+              \\n+              if (this.mTabBrowser.mCurrentTab == this.mTab) {\\n+                for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {\\n+                  var p = this.mTabBrowser.mProgressListeners[i];\\n+                  if (p)\\n+                    p.onStatusChange(aWebProgress, aRequest, aStatus, aMessage);\\n+                }\\n+              }\\n+            },\\n+\\n+            onSecurityChange : function(aWebProgress, aRequest, aState) { \\n+              if (this.mTabBrowser.mCurrentTab == this.mTab) {\\n+                for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {\\n+                  var p = this.mTabBrowser.mProgressListeners[i];\\n+                  if (p)\\n+                    p.onSecurityChange(aWebProgress, aRequest, aState);\\n+                }\\n+              }\\n+            },\\n+\\n+            QueryInterface : function(aIID)\\n+            {\\n+              if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||\\n+                  aIID.equals(Components.interfaces.nsISupportsWeakReference) ||\\n+                  aIID.equals(Components.interfaces.nsISupports))\\n+                return this;\\n+              throw Components.results.NS_NOINTERFACE;\\n+            }\\n+                  \\n+            });\\n+        ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"buildFavIconString\\\">\\n+        <parameter name=\\\"aURI\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            var end = (aURI.port == -1) ? \\\"/favicon.ico\\\" : (\\\":\\\" + aURI.port + \\\"/favicon.ico\\\");\\n+            return aURI.scheme + \\\"://\\\" + aURI.host + end;\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"shouldLoadFavIcon\\\">\\n+        <parameter name=\\\"aURI\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            return (aURI && this.mPrefs.getBoolPref(\\\"browser.chrome.site_icons\\\") &&\\n+                    this.mPrefs.getBoolPref(\\\"browser.chrome.favicons\\\") && \\n+                    (\\\"schemeIs\\\" in aURI) && (aURI.schemeIs(\\\"http\\\") || aURI.schemeIs(\\\"https\\\")));\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"loadFavIcon\\\">\\n+        <parameter name=\\\"aURI\\\"/>\\n+        <parameter name=\\\"aAttr\\\"/>\\n+        <parameter name=\\\"aElt\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            var iconURL = this.buildFavIconString(aURI);\\n+            if (!this.mMissedIconCache) {\\n+              var cacheService = Components.classes['@mozilla.org/network/cache-service;1'].getService(Components.interfaces.nsICacheService);\\n+              this.mMissedIconCache = cacheService.createSession(\\\"MissedIconCache\\\", Components.interfaces.nsICache.STORE_ANYWHERE, true);\\n+              if (!this.mMissedIconCache)\\n+                return;\\n+            }\\n+        \\n+            try {\\n+              var entry = this.mMissedIconCache.openCacheEntry(iconURL, Components.interfaces.nsICache.ACCESS_READ, true);\\n+            }\\n+            catch (exc) {}\\n+            if (!entry)\\n+              aElt.setAttribute(aAttr, iconURL);\\n+            else {\\n+              entry.close();\\n+              entry = null;\\n+            }\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"addToMissedIconCache\\\">\\n+        <parameter name=\\\"aURI\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            var entry = this.mMissedIconCache.openCacheEntry(aURI, Components.interfaces.nsICache.ACCESS_READ_WRITE, true);\\n+            if (entry.accessGranted == Components.interfaces.nsICache.ACCESS_WRITE)\\n+              // It's a new entry.  Just write a bit of metadata in to the entry.\\n+              entry.setMetaDataElement(\\\"Icon\\\", \\\"Missed\\\");\\n+            entry.markValid();\\n+            entry.close();\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"updateTitlebar\\\">\\n+        <body>\\n+          <![CDATA[\\n+            var newTitle = \\\"\\\";\\n+            var docTitle;\\n+            if (this.docShell.contentViewer)\\n+              docTitle = this.contentDocument.title;\\n+            \\n+            if (docTitle) {\\n+              newTitle += this.ownerDocument.documentElement.getAttribute(\\\"titlepreface\\\");\\n+              newTitle += docTitle;\\n+              newTitle += this.ownerDocument.documentElement.getAttribute(\\\"titlemenuseparator\\\");\\n+            }\\n+            newTitle += this.ownerDocument.documentElement.getAttribute(\\\"titlemodifier\\\");\\n+            window.title = newTitle;\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"updatePopupMenu\\\">\\n+        <parameter name=\\\"aPopupMenu\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            this.mContextTab = document.popupNode;\\n+            var disabled = this.mPanelContainer.childNodes.length == 1;\\n+            var menuItems = aPopupMenu.getElementsByAttribute(\\\"tbattr\\\", \\\"tabbrowser-multiple\\\");\\n+            for (var i = 0; i < menuItems.length; i++)\\n+              menuItems[i].setAttribute(\\\"disabled\\\", disabled);\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"updateCurrentBrowser\\\">\\n+        <body>\\n+          <![CDATA[\\n+            var newBrowser = this.mPanelContainer.childNodes[this.mPanelContainer.selectedIndex];\\n+            if (this.mCurrentBrowser)\\n+              this.mCurrentBrowser.setAttribute(\\\"type\\\", \\\"content\\\");\\n+            \\n+            newBrowser.setAttribute(\\\"type\\\", \\\"content-primary\\\");\\n+            this.mCurrentBrowser = newBrowser;\\n+            this.mCurrentTab = this.selectedTab;\\n+\\n+            // Update the URL bar.\\n+            var loc = this.mCurrentBrowser.currentURI;\\n+            if (!loc)\\n+              loc = ({ spec: \\\"\\\" });\\n+\\n+            var webProgress = this.mCurrentBrowser.webProgress;\\n+            var securityUI = this.mCurrentBrowser.securityUI;\\n+            var i, p;\\n+            for (i = 0; i < this.mProgressListeners.length; i++) {\\n+              p = this.mProgressListeners[i];\\n+              if (p) {\\n+                p.onLocationChange(webProgress, null, loc);\\n+                if (securityUI)\\n+                  p.onSecurityChange(webProgress, null, securityUI.state);\\n+                var listener = this.mTabListeners[this.mPanelContainer.selectedIndex];\\n+                if (listener.mIcon)\\n+                  p.onLinkIconAvailable(listener.mIcon);\\n+              }\\n+            }\\n+\\n+            // Update the window title.\\n+            this.updateTitlebar();\\n+            \\n+            // If the new tab is busy, and our current state is not busy, then\\n+            // we need to fire a start to all progress listeners.\\n+            const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;\\n+            if (this.mCurrentTab.hasAttribute(\\\"busy\\\") && !this.mIsBusy) {\\n+              this.mIsBusy = true;\\n+              webProgress = this.mCurrentBrowser.webProgress;\\n+              for (i = 0; i < this.mProgressListeners.length; i++) {\\n+                p = this.mProgressListeners[i];\\n+                if (p)\\n+                  p.onStateChange(webProgress, null, nsIWebProgressListener.STATE_START | nsIWebProgressListener.STATE_IS_NETWORK, 0);\\n+              }\\n+            }\\n+\\n+            // If the new tab is not busy, and our current state is busy, then\\n+            // we need to fire a stop to all progress listeners.\\n+            if (!this.mCurrentTab.hasAttribute(\\\"busy\\\") && this.mIsBusy) {\\n+              this.mIsBusy = false;\\n+              webProgress = this.mCurrentBrowser.webProgress;\\n+              for (i = 0; i < this.mProgressListeners.length; i++) {\\n+                p = this.mProgressListeners[i];\\n+                if (p)\\n+                  p.onStateChange(webProgress, null, nsIWebProgressListener.STATE_STOP | nsIWebProgressListener.STATE_IS_NETWORK, 0);\\n+              }\\n+            }\\n+\\n+            // Focus our new content area.\\n+            setTimeout(\\\"window._content.focus()\\\", 0);\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"onTabClick\\\">\\n+        <parameter name=\\\"event\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            if (event.button != 1 || event.target.localName != 'tab' ||\\n+                this.mPrefs.getBoolPref(\\\"middlemouse.contentLoadURL\\\"))\\n+              return; \\n+\\n+            this.removeTab(event.target);\\n+            event.stopPropagation();\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"onLinkAdded\\\">\\n+        <parameter name=\\\"event\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            var tabBrowser = this.parentNode.parentNode;\\n+            if (!tabBrowser.mPrefs.getBoolPref(\\\"browser.chrome.site_icons\\\"))\\n+              return;\\n+\\n+            if (!event.target.rel.match((/(?:^|\\\\s)icon(?:\\\\s|$)/i)))\\n+              return;\\n+\\n+            // We have an icon.\\n+            var href = event.target.href;\\n+            if (!href)\\n+              return;\\n+            \\n+            // Verify that the load of this icon is legal.  We use the same\\n+            // content policy that is used for a Web page loading images.\\n+            var contentPolicy = Components.classes['@mozilla.org/layout/content-policy;1'].getService(Components.interfaces.nsIContentPolicy);\\n+            if (!contentPolicy)\\n+              return; // Refuse to load if we can't do a security check.\\n+            \\n+            // Make a URI out of our href.\\n+            var uri = Components.classes['@mozilla.org/network/standard-url;1'].createInstance();\\n+            uri = uri.QueryInterface(Components.interfaces.nsIURI);\\n+  \\n+            var notifyListeners = true;\\n+            var i;\\n+            \\n+            if (tabBrowser.mTabbedMode) {\\n+              // We need to update a tab.\\n+              for (i = 0; i < this.childNodes.length; i++) {\\n+                if (this.childNodes[i].contentDocument == event.target.ownerDocument) {\\n+                  if (!contentPolicy.shouldLoad(Components.interfaces.nsIContentPolicy.IMAGE,\\n+                                                uri, event.target, this.childNodes[i].contentWindow))\\n+                    return;\\n+                                                 \\n+                  var listener = tabBrowser.mTabListeners[i];\\n+                  listener.mIcon = href;\\n+                  break;\\n+                }\\n+              }\\n+\\n+              notifyListeners = (this.childNodes[i] == tabBrowser.mCurrentBrowser);\\n+            }\\n+            else if (!contentPolicy.shouldLoad(Components.interfaces.nsIContentPolicy.IMAGE,\\n+                                               uri, event.target, tabBrowser.mCurrentBrowser.contentWindow))\\n+              return;\\n+\\n+            if (notifyListeners && tabBrowser.mProgressListeners) {\\n+              for (i = 0; i < tabBrowser.mProgressListeners.length; i++) {\\n+                var p = tabBrowser.mProgressListeners[i];\\n+                if (p)\\n+                  p.onLinkIconAvailable(href);\\n+              }\\n+            }\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"onTitleChanged\\\">\\n+        <parameter name=\\\"evt\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            if (evt.target != this.contentDocument)\\n+              return;\\n+\\n+            var i = 0;\\n+            for ( ; i < this.parentNode.childNodes.length; i++) {\\n+              if (this.parentNode.childNodes[i] == this)\\n+                break;\\n+            }\\n+\\n+            var tabBrowser = this.parentNode.parentNode.parentNode;\\n+            var tab = tabBrowser.mTabContainer.childNodes[i];\\n+\\n+            tabBrowser.setTabTitle(tab);\\n+\\n+            if (tab == tabBrowser.mCurrentTab)\\n+              tabBrowser.updateTitlebar();\\n+          ]]> \\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"setTabTitle\\\">\\n+        <parameter name=\\\"aTab\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            var browser = this.getBrowserForTab(aTab);\\n+            var crop = \\\"end\\\";\\n+            var titleViaGetter = browser.contentDocument.__proto__.__lookupGetter__('title').call(browser.contentDocument);\\n+            var title;\\n+\\n+            if (titleViaGetter)\\n+              title = titleViaGetter\\n+            else if (browser.currentURI.spec && browser.currentURI.spec != \\\"about:blank\\\") {\\n+              title = browser.currentURI.spec;\\n+              crop  = \\\"center\\\";\\n+            }\\n+            else\\n+              title = this.mStringBundle.getString(\\\"tabs.untitled\\\");\\n+\\n+            aTab.label = title;\\n+            aTab.setAttribute(\\\"crop\\\", crop);\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"setStripVisibilityTo\\\">\\n+        <parameter name=\\\"aShow\\\"/>\\n+        <body>\\n+        <![CDATA[\\n+          this.mStrip.collapsed = !aShow;\\n+          if (aShow) {\\n+            // XXXdwh temporary unclean dependency on specific menu items in navigator.xul\\n+            document.getElementById(\\\"menu_closeWindow\\\").hidden = false;\\n+            document.getElementById(\\\"menu_close\\\").setAttribute(\\\"label\\\", this.mStringBundle.getString(\\\"tabs.closeTab\\\"));\\n+            if (!this.mTabbedMode)\\n+              this.enterTabbedMode();\\n+          }\\n+          else {\\n+            // XXXdwh temporary unclean dependency on specific menu items in navigator.xul\\n+            document.getElementById(\\\"menu_closeWindow\\\").hidden = true;\\n+            document.getElementById(\\\"menu_close\\\").setAttribute(\\\"label\\\", this.mStringBundle.getString(\\\"tabs.close\\\"));\\n+          }\\n+        ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"getStripVisibility\\\">\\n+        <body>\\n+          return !this.mStrip.collapsed;\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"enterTabbedMode\\\">\\n+        <body>\\n+          <![CDATA[\\n+            this.mTabbedMode = true; // Welcome to multi-tabbed mode.\\n+\\n+            // Get the first tab all hooked up with a title listener.\\n+            this.mCurrentBrowser.addEventListener(\\\"DOMTitleChanged\\\", this.onTitleChanged, false);\\n+\\n+            this.setTabTitle(this.mCurrentTab);\\n+\\n+            // Hook up our favicon.\\n+            var uri = this.mCurrentBrowser.currentURI;\\n+            if (this.shouldLoadFavIcon(uri))\\n+              this.loadFavIcon(uri, \\\"image\\\", this.mCurrentTab);\\n+\\n+            var filter;\\n+            if (this.mTabFilters.length > 0) {\\n+              // Use the filter hooked up in our addProgressListener\\n+              filter = this.mTabFilters[0];\\n+            } else {\\n+              // create a filter and hook it up to our first browser\\n+              filter = Components.classes[\\\"@mozilla.org/appshell/component/browser-status-filter;1\\\"]\\n+                                 .createInstance(Components.interfaces.nsIWebProgress);\\n+              this.mTabFilters[0] = filter;\\n+              this.mCurrentBrowser.webProgress.addProgressListener(filter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);\\n+            }\\n+\\n+            // Remove all our progress listeners from the active browser's filter.\\n+            if (this.mProgressListeners) {\\n+              for (var i = 0; i < this.mProgressListeners.length; i++) {\\n+                var p = this.mProgressListeners[i];\\n+                if (p)\\n+                  filter.removeProgressListener(p);\\n+              }\\n+            }\\n+\\n+            // Wire up a progress listener to our filter.\\n+            const listener = (this.mTabProgressListener)(this, this.mCurrentTab, false);\\n+            filter.addProgressListener(listener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);\\n+            this.mTabListeners[0] = listener;\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"addTab\\\">\\n+        <parameter name=\\\"aURI\\\"/>\\n+        <parameter name=\\\"aReferrerURI\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            var blank = (aURI == \\\"about:blank\\\");\\n+\\n+            if (!this.mTabbedMode)\\n+              this.enterTabbedMode();\\n+\\n+            var b = document.createElementNS(\\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\",\\n+                                             \\\"browser\\\"); \\n+            var t = document.createElementNS(\\\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\\\",\\n+                                             \\\"tab\\\");\\n+\\n+            if (blank)\\n+              t.setAttribute(\\\"label\\\", this.mStringBundle.getString(\\\"tabs.untitled\\\"));\\n+            else\\n+              t.setAttribute(\\\"label\\\", aURI);\\n+            \\n+            t.setAttribute(\\\"crop\\\", \\\"end\\\");\\n+            t.maxWidth = 250;\\n+            t.minWidth = 30;\\n+            t.width = 0;\\n+            t.setAttribute(\\\"flex\\\", \\\"100\\\");\\n+            t.setAttribute(\\\"validate\\\", \\\"never\\\");\\n+            t.setAttribute(\\\"onerror\\\", \\\"this.parentNode.parentNode.parentNode.parentNode.addToMissedIconCache(this.getAttribute('image')); this.removeAttribute('image');\\\");\\n+            this.mTabContainer.appendChild(t);\\n+\\n+            b.setAttribute(\\\"type\\\", \\\"content\\\");\\n+            b.setAttribute(\\\"contextmenu\\\", this.getAttribute(\\\"contentcontextmenu\\\"));\\n+            b.setAttribute(\\\"tooltip\\\", this.getAttribute(\\\"contenttooltip\\\"));\\n+            \\n+            this.mPanelContainer.appendChild(b);\\n+\\n+            b.addEventListener(\\\"DOMTitleChanged\\\", this.onTitleChanged, false);\\n+            \\n+            if (this.mStrip.collapsed)\\n+              this.setStripVisibilityTo(true);\\n+\\n+            this.mPrefs.setBoolPref(\\\"browser.tabs.forceHide\\\", false);\\n+            \\n+            // wire up a progress listener for the new browser object.\\n+            var position = this.mTabContainer.childNodes.length-1;\\n+            var tabListener = (this.mTabProgressListener)(this, t, blank);\\n+            const filter = Components.classes[\\\"@mozilla.org/appshell/component/browser-status-filter;1\\\"]\\n+                                     .createInstance(Components.interfaces.nsIWebProgress);\\n+            filter.addProgressListener(tabListener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);\\n+            b.webProgress.addProgressListener(filter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);\\n+            this.mTabListeners[position] = tabListener;\\n+            this.mTabFilters[position] = filter;\\n+\\n+            if (!blank)\\n+              b.loadURIWithFlags(aURI, nsIWebNavigation.LOAD_FLAGS_NONE,\\n+                                 aReferrerURI, null, null);\\n+\\n+            return t;\\n+          ]]>\\n+        </body>\\n+      </method>\\n+      \\n+      <method name=\\\"removeAllTabsBut\\\">\\n+        <parameter name=\\\"aTab\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            if (aTab.localName != \\\"tab\\\")\\n+              aTab = this.mCurrentTab;\\n+            \\n+            var l = this.mTabContainer.childNodes.length;\\n+            if (l == 1)\\n+              return;\\n+\\n+            for (var i = 0; i < l; i++) {\\n+              var tab = this.mTabContainer.childNodes[i];\\n+              if (tab != aTab) {\\n+                this.removeTab(tab);\\n+                i--;\\n+                l--;\\n+              }\\n+            }\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"removeCurrentTab\\\">\\n+        <body>\\n+          <![CDATA[\\n+            return this.removeTab(this.mCurrentTab);\\n+          ]]>\\n+        </body>\\n+      </method>\\n+         \\n+      <method name=\\\"removeTab\\\">\\n+        <parameter name=\\\"aTab\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            if (aTab.localName != \\\"tab\\\")\\n+              aTab = this.mCurrentTab;\\n+\\n+            var l = this.mTabContainer.childNodes.length;\\n+            if (l == 1) {\\n+              // hide the tab bar\\n+              this.mPrefs.setBoolPref(\\\"browser.tabs.forceHide\\\", true);\\n+              this.setStripVisibilityTo(false);\\n+              return;\\n+            }\\n+\\n+            if (l == 2) {\\n+              var autohide = this.mPrefs.getBoolPref(\\\"browser.tabs.autoHide\\\");\\n+              if (autohide)\\n+                this.setStripVisibilityTo(false);\\n+            }\\n+\\n+            var index = -1;\\n+            if (this.mCurrentTab == aTab)\\n+              index = this.mPanelContainer.selectedIndex;\\n+            else {\\n+              // Find and locate the tab in our list.\\n+              for (var i = 0; i < l; i++)\\n+                if (this.mTabContainer.childNodes[i] == aTab)\\n+                  index = i;\\n+            }\\n+\\n+            // Remove the tab's filter and progress listener.\\n+            const filter = this.mTabFilters[index];\\n+            var oldBrowser = this.mPanelContainer.childNodes[index];\\n+            oldBrowser.webProgress.removeProgressListener(filter);\\n+            filter.removeProgressListener(this.mTabListeners[index]);\\n+            this.mTabFilters.splice(index, 1);\\n+            this.mTabListeners.splice(index, 1);\\n+\\n+            // Remove our title change listener\\n+            oldBrowser.removeEventListener(\\\"DOMTitleChanged\\\", this.onTitleChanged, false);\\n+            \\n+            // We are no longer the primary content area.\\n+            oldBrowser.setAttribute(\\\"type\\\", \\\"content\\\");\\n+\\n+            // Now select the new tab before nuking the old one.\\n+            var currentIndex = this.mPanelContainer.selectedIndex;\\n+            \\n+            var newIndex = -1;\\n+            if (currentIndex > index)\\n+              newIndex = currentIndex-1;\\n+            else if (currentIndex < index)\\n+              newIndex = currentIndex;\\n+            else if (index > 0)\\n+              newIndex = index-1;\\n+            else\\n+              newIndex = index;\\n+\\n+            var oldTab = aTab;\\n+            \\n+            // clean up the before/afterselected attributes before removing the tab\\n+            oldTab.selected = false;\\n+\\n+            this.mTabContainer.removeChild(oldTab);\\n+            this.mPanelContainer.removeChild(oldBrowser);\\n+\\n+            this.selectedTab = this.mTabContainer.childNodes[newIndex];\\n+\\n+            if (newIndex == index) {\\n+              // No select event is going to fire.  We need to just call updateCurrentBrowser()\\n+              // by hand.\\n+              this.updateCurrentBrowser();\\n+            }\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"reloadAllTabs\\\">\\n+        <body>\\n+          <![CDATA[\\n+            var l = this.mPanelContainer.childNodes.length;\\n+            for (var i = 0; i < l; i++)\\n+              this.mPanelContainer.childNodes[i].webNavigation.reload(true);\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"reloadTab\\\">\\n+        <parameter name=\\\"aTab\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            var l = this.mPanelContainer.childNodes.length;\\n+            for (var i = 0; i < l; i++)\\n+              if (this.mTabContainer.childNodes[i] == aTab)\\n+                this.mPanelContainer.childNodes[i].webNavigation.reload(true);\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"addProgressListener\\\">\\n+        <parameter name=\\\"aListener\\\"/>\\n+        <parameter name=\\\"aMask\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            if (!this.mProgressListeners) {\\n+              this.mProgressListeners = [];\\n+              const autoHide = this.mPrefs.getBoolPref(\\\"browser.tabs.autoHide\\\");\\n+              const forceHide = this.mPrefs.getBoolPref(\\\"browser.tabs.forceHide\\\");\\n+              if (!autoHide && !forceHide)\\n+                this.setStripVisibilityTo(true);\\n+\\n+              // Hook up a listener for <link>s.\\n+              this.mPanelContainer.addEventListener(\\\"DOMLinkAdded\\\", this.onLinkAdded, false);\\n+            }\\n+\\n+            this.mProgressListeners.push(aListener);\\n+\\n+            if (!this.mTabbedMode) {\\n+              // hook a filter up to our first browser\\n+              const filter = Components.classes[\\\"@mozilla.org/appshell/component/browser-status-filter;1\\\"]\\n+                                       .createInstance(Components.interfaces.nsIWebProgress);\\n+              this.mTabFilters[0] = filter;\\n+              this.mCurrentBrowser.webProgress.addProgressListener(filter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);\\n+\\n+              // Directly hook the listener up to the filter for better performance\\n+              this.mTabFilters[0].addProgressListener(aListener, aMask);\\n+            }\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"removeProgressListener\\\">\\n+        <parameter name=\\\"aListener\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            if (!this.mProgressListeners) return;\\n+            for (var i = 0; i < this.mProgressListeners.length; i++) {\\n+              if (this.mProgressListeners[i] == aListener) {\\n+                this.mProgressListeners[i] = null;\\n+                break;\\n+              }\\n+            }\\n+\\n+            if (!this.mTabbedMode)\\n+              // Don't forget to remove it from the filter we hooked it up to\\n+              this.mTabFilters[0].removeProgressListener(aListener);\\n+         ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"getBrowserForTab\\\">\\n+        <parameter name=\\\"aTab\\\"/>\\n+        <body>\\n+        <![CDATA[\\n+          if (this.mCurrentTab == aTab)\\n+            return this.mCurrentBrowser;\\n+\\n+          for (var i = 0; i < this.mTabContainer.childNodes.length; i++) {\\n+            if (this.mTabContainer.childNodes[i] == aTab) {\\n+              return this.mPanelContainer.childNodes[i];\\n+            }\\n+          }\\n+\\n+          return null;\\n+        ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <property name=\\\"selectedTab\\\">\\n+        <getter>\\n+          return this.mTabBox.selectedTab;\\n+        </getter>\\n+        <setter>\\n+          <![CDATA[\\n+          // Update the tab\\n+          this.mTabBox.selectedTab = val;\\n+          return val;\\n+          ]]>\\n+        </setter>\\n+      </property>\\n+\\n+      <property name=\\\"selectedBrowser\\\"\\n+                onget=\\\"return this.mCurrentBrowser;\\\"\\n+                readonly=\\\"true\\\"/>\\n+\\n+\\n+      <property name=\\\"browsers\\\"\\n+                onget=\\\"return this.mPanelContainer.childNodes;\\\"\\n+                readonly=\\\"true\\\"/>\\n+\\n+      <!-- Drag and drop observer API -->\\n+      <!--<method name=\\\"onDragStart\\\">\\n+        <parameter name=\\\"aEvent\\\"/>\\n+        <parameter name=\\\"aXferData\\\"/>\\n+        <parameter name=\\\"aDragAction\\\"/>\\n+        <body/>\\n+      </method>-->\\n+\\n+      <method name=\\\"onDragOver\\\">\\n+        <parameter name=\\\"aEvent\\\"/>\\n+        <parameter name=\\\"aFlavour\\\"/>\\n+        <parameter name=\\\"aDragSession\\\"/>\\n+        <body>\\n+        <![CDATA[\\n+          return; // Just having this makes our feedback correct.\\n+        ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"onDrop\\\">\\n+        <parameter name=\\\"aEvent\\\"/>\\n+        <parameter name=\\\"aXferData\\\"/>\\n+        <parameter name=\\\"aDragSession\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            var url = transferUtils.retrieveURLFromData(aXferData.data, aXferData.flavour.contentType);\\n+\\n+            // valid urls don't contain spaces ' '; if we have a space it isn't a valid url so bail out\\n+            if (!url || !url.length || url.indexOf(\\\" \\\", 0) != -1) \\n+              return;\\n+            \\n+            var bgLoad = this.mPrefs.getBoolPref(\\\"browser.tabs.loadInBackground\\\");\\n+\\n+            if (aEvent.target.localName == \\\"tabs\\\") {\\n+              // We're adding a new tab.\\n+              var tab = this.addTab(getShortcutOrURI(url));\\n+              if (!bgLoad)\\n+                this.selectedTab = tab;\\n+            }\\n+            else if (aEvent.target.localName == \\\"tab\\\") {\\n+              // Load in an existing tab.\\n+              this.getBrowserForTab(aEvent.target).loadURI(getShortcutOrURI(url));\\n+              if (this.mCurrentTab != aEvent.target && !bgLoad)\\n+                this.selectedTab = aEvent.target;\\n+            }\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"getSupportedFlavours\\\">\\n+        <body>\\n+        <![CDATA[\\n+          var flavourSet = new FlavourSet();\\n+          flavourSet.appendFlavour(\\\"text/x-moz-url\\\");\\n+          flavourSet.appendFlavour(\\\"text/unicode\\\");\\n+          flavourSet.appendFlavour(\\\"application/x-moz-file\\\", \\\"nsIFile\\\");\\n+          return flavourSet;\\n+        ]]>\\n+        </body>\\n+      </method>\\n+                                                               \\n+      <!-- BEGIN FORWARDED BROWSER PROPERTIES.  IF YOU ADD A PROPERTY TO THE BROWSER ELEMENT\\n+           MAKE SURE TO ADD IT HERE AS WELL. -->\\n+      <property name=\\\"canGoBack\\\"\\n+                onget=\\\"return this.mCurrentBrowser.canGoBack;\\\"\\n+                readonly=\\\"true\\\"/>\\n+\\n+      <property name=\\\"canGoForward\\\"\\n+                onget=\\\"return this.mCurrentBrowser.canGoForward;\\\"\\n+                readonly=\\\"true\\\"/>\\n+\\n+      <method name=\\\"goBack\\\">\\n+        <body>\\n+          <![CDATA[\\n+            return this.mCurrentBrowser.goBack();\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"goForward\\\">\\n+        <body>\\n+          <![CDATA[\\n+            return this.mCurrentBrowser.goForward();\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"reload\\\">\\n+        <body>\\n+          <![CDATA[\\n+            return this.mCurrentBrowser.reload();\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"reloadWithFlags\\\">\\n+        <parameter name=\\\"aFlags\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            return this.mCurrentBrowser.reloadWithFlags(aFlags);\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"stop\\\">\\n+        <body>\\n+          <![CDATA[\\n+            return this.mCurrentBrowser.stop();\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <!-- throws exception for unknown schemes -->\\n+      <method name=\\\"loadURI\\\">\\n+        <parameter name=\\\"aURI\\\"/>\\n+        <parameter name=\\\"aReferrerURI\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            return this.mCurrentBrowser.loadURI(aURI, aReferrerURI);\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <!-- throws exception for unknown schemes -->\\n+      <method name=\\\"loadURIWithFlags\\\">\\n+        <parameter name=\\\"aURI\\\"/>\\n+        <parameter name=\\\"aFlags\\\"/>\\n+        <parameter name=\\\"aReferrerURI\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            return this.mCurrentBrowser.loadURIWithFlags(aURI, aFlags, aReferrerURI);\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <method name=\\\"goHome\\\">\\n+        <body>\\n+          <![CDATA[\\n+            return this.mCurrentBrowser.goHome();\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <property name=\\\"homePage\\\">\\n+        <getter>\\n+          <![CDATA[\\n+            return this.mCurrentBrowser.homePage;\\n+          ]]>\\n+        </getter>\\n+        <setter>\\n+          <![CDATA[\\n+            this.mCurrentBrowser.homePage = val;\\n+            return val;\\n+          ]]>\\n+        </setter>\\n+      </property>\\n+\\n+      <method name=\\\"gotoIndex\\\">\\n+        <parameter name=\\\"aIndex\\\"/>\\n+        <body>\\n+          <![CDATA[\\n+            return this.mCurrentBrowser.gotoIndex(aIndex);\\n+          ]]>\\n+        </body>\\n+      </method>\\n+\\n+      <property name=\\\"currentURI\\\"\\n+                onget=\\\"return this.mCurrentBrowser.currentURI;\\\"\\n+                readonly=\\\"true\\\"/>\\n+\\n+      <property name=\\\"docShell\\\"\\n+                onget=\\\"return this.mCurrentBrowser.docShell\\\"\\n+                readonly=\\\"true\\\"/>\\n+\\n+      <property name=\\\"webNavigation\\\"\\n+                onget=\\\"return this.mCurrentBrowser.webNavigation\\\"\\n+                readonly=\\\"true\\\"/>\\n+\\n+      <property name=\\\"webBrowserFind\\\"\\n+                readonly=\\\"true\\\"\\n+                onget=\\\"return this.mCurrentBrowser.webBrowserFind\\\"/>\\n+\\n+      <property name=\\\"webProgress\\\"\\n+                readonly=\\\"true\\\"\\n+                onget=\\\"return this.mCurrentBrowser.webProgress\\\"/>\\n+\\n+      <property name=\\\"contentWindow\\\"\\n+                readonly=\\\"true\\\"\\n+                onget=\\\"return this.mCurrentBrowser.contentWindow\\\"/>\\n+\\n+      <property name=\\\"sessionHistory\\\"\\n+                onget=\\\"return this.mCurrentBrowser.sessionHistory;\\\"\\n+                readonly=\\\"true\\\"/>\\n+\\n+      <property name=\\\"markupDocumentViewer\\\"\\n+                onget=\\\"return this.mCurrentBrowser.markupDocumentViewer;\\\"\\n+                readonly=\\\"true\\\"/>\\n+\\n+      <property name=\\\"contentViewerEdit\\\"\\n+                onget=\\\"return this.mCurrentBrowser.contentViewerEdit;\\\"\\n+                readonly=\\\"true\\\"/>\\n+\\n+      <property name=\\\"contentViewerFile\\\"\\n+                onget=\\\"return this.mCurrentBrowser.contentViewerFile;\\\"\\n+                readonly=\\\"true\\\"/>\\n+\\n+      <property name=\\\"documentCharsetInfo\\\"\\n+                onget=\\\"return this.mCurrentBrowser.documentCharsetInfo;\\\"\\n+                readonly=\\\"true\\\"/>\\n+\\n+      <property name=\\\"contentDocument\\\"\\n+                onget=\\\"return this.mCurrentBrowser.contentDocument;\\\"\\n+                readonly=\\\"true\\\"/>\\n+\\n+      <property name=\\\"securityUI\\\"\\n+                onget=\\\"return this.mCurrentBrowser.securityUI;\\\"\\n+                readonly=\\\"true\\\"/>\\n+\\n+      <constructor>\\n+        <![CDATA[\\n+        this.mCurrentBrowser = this.mPanelContainer.firstChild;\\n+        this.mCurrentTab = this.mTabContainer.firstChild;\\n+        this.mTabBox.setAttribute(\\\"handleCtrlTab\\\", \\\"false\\\");\\n+        ]]>\\n+      </constructor>\\n+\\n+      <destructor>\\n+        <![CDATA[\\n+          for (var i = 0; i < this.mTabListeners.length; ++i) {\\n+            this.mPanelContainer.childNodes[i].webProgress.removeProgressListener(this.mTabFilters[i]);\\n+            this.mTabFilters[i].removeProgressListener(this.mTabListeners[i]);\\n+            this.mTabFilters[i] = null;\\n+            this.mTabListeners[i] = null;\\n+            this.mPanelContainer.childNodes[i].removeEventListener(\\\"DOMTitleChanged\\\", this.onTitleChanged, false);\\n+          }\\n+          this.mPanelContainer.removeEventListener(\\\"DOMLinkAdded\\\", this.onLinkAdded, false);\\n+        ]]>\\n+      </destructor>\\n+    </implementation>\\n+\\n+    <handlers>\\n+      <handler event=\\\"keypress\\\" modifiers=\\\"control\\\" keycode=\\\"vk_f4\\\" action=\\\"this.removeCurrentTab();\\\"/>\\n+\\n+      <handler event=\\\"DOMWindowClose\\\">\\n+        <![CDATA[\\n+          const browsers = this.browsers;\\n+          if (browsers.length == 1)\\n+            return;\\n+          var i = 0;\\n+          for (; i < browsers.length; ++i) {\\n+            if (browsers[i].contentWindow == event.target)\\n+              break;\\n+          }\\n+          this.removeTab(this.mTabContainer.childNodes[i]);\\n+          event.preventDefault();\\n+        ]]>\\n+      </handler>\\n+    </handlers>\\n+  </binding>\\n+\\n+</bindings>\\n\""}