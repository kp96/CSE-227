{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas24958ce\""},"diff":"\"24958ce Bug 367281 - \\\"Remove SetImageData/SetAlphaData from gfxImageFrame\\\" [p=alfredkayser@nl.ibm.com (Alfred Kayser) r=stuart sr=tor a1.9=stuart]\\ndiff --git a/gfx/idl/gfxIImageFrame.idl b/gfx/idl/gfxIImageFrame.idl\\nindex 9081520..7658a23 100644\\n--- a/gfx/idl/gfxIImageFrame.idl\\n+++ b/gfx/idl/gfxIImageFrame.idl\\n@@ -133,18 +133,6 @@ interface gfxIImageFrame : nsISupports\\n   void getImageData([array, size_is(length)] out PRUint8 bits, out unsigned long length);\\n \\n   /**\\n-   * Sets \\\\a length bytes of \\\\a data in this object.\\n-   * @param offset The offset from the first pixel in bytes.  To set\\n-   *   data beginning with the first (top left) pixel in the image, \\\\a offset\\n-   *   should be 0; to set data beginning with, for example, the sixth pixel in\\n-   *   the first row of a RGBA32 image, the offset should be 20.\\n-   * @attension should we use PRUint32 instead?\\n-   */\\n-  void setImageData([array, size_is(length), const] in PRUint8 data,\\n-                    in unsigned long length,\\n-                    in long offset);\\n-\\n-  /**\\n    * Lock image pixels before addressing the data directly\\n    */\\n   void lockImageData();\\n@@ -155,37 +143,6 @@ interface gfxIImageFrame : nsISupports\\n   void unlockImageData();\\n \\n \\n-\\n-  /* alpha stuff.. used for _A1 and _A8 formated images */\\n-  readonly attribute unsigned long alphaBytesPerRow;\\n-\\n-  /**\\n-   * returns the number of bytes allocated for the alpha mask\\n-   */\\n-  readonly attribute unsigned long alphaDataLength;\\n-\\n-  // XXX do we copy here?  lets not...\\n-  void getAlphaData([array, size_is(length)] out PRUint8 bits, out unsigned long length);\\n-\\n-  /**\\n-   * Sets \\\\a length bytes of \\\\a data in this object.\\n-   */\\n-  void setAlphaData([array, size_is(length), const] in PRUint8 data,\\n-                    in unsigned long length,\\n-                    in long offset);\\n-\\n-  /**\\n-   * Lock alpha pixels before addressing the data directly\\n-   */\\n-  void lockAlphaData();\\n-\\n-  /**\\n-   * Unlock alpha pixels\\n-   */\\n-  void unlockAlphaData();\\n-\\n-\\n-\\n   /* GIF Specific methods.  These should be in a different class or interface. */\\n \\n   /**\\n@@ -199,9 +156,4 @@ interface gfxIImageFrame : nsISupports\\n    * moment\\n    */\\n   attribute long frameDisposalMethod;\\n-\\n-  /* frame background color\\n-   * GIF specific, should be in a GIF specific frame\\n-   */  \\n-  attribute gfx_color backgroundColor;\\n };\\ndiff --git a/gfx/src/shared/gfxImageFrame.cpp b/gfx/src/shared/gfxImageFrame.cpp\\nindex 6194105..060667c 100644\\n--- a/gfx/src/shared/gfxImageFrame.cpp\\n+++ b/gfx/src/shared/gfxImageFrame.cpp\\n@@ -45,9 +45,7 @@ NS_IMPL_ISUPPORTS2(gfxImageFrame, gfxIImageFrame, nsIInterfaceRequestor)\\n gfxImageFrame::gfxImageFrame() :\\n   mInitialized(PR_FALSE),\\n   mMutable(PR_TRUE),\\n-  mHasBackgroundColor(PR_FALSE),\\n   mTimeout(100),\\n-  mBackgroundColor(0),\\n   mDisposalMethod(0)\\n {\\n   /* member initializers and constructor code */\\n@@ -104,7 +102,6 @@ NS_IMETHODIMP gfxImageFrame::Init(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt3\\n   NS_ASSERTION(mImage, \\\"creation of image failed\\\");\\n   if (NS_FAILED(rv)) return rv;\\n \\n-  gfx_depth depth = aDepth;\\n   nsMaskRequirements maskReq;\\n \\n   switch (aFormat) {\\n@@ -135,11 +132,9 @@ NS_IMETHODIMP gfxImageFrame::Init(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt3\\n     break;\\n   }\\n \\n-  rv = mImage->Init(aWidth, aHeight, depth, maskReq);\\n+  rv = mImage->Init(aWidth, aHeight, aDepth, maskReq);\\n   if (NS_FAILED(rv)) return rv;\\n \\n-  mTopToBottom = mImage->GetIsRowOrderTopToBottom();\\n-\\n   mInitialized = PR_TRUE;\\n   return NS_OK;\\n }\\n@@ -276,98 +271,6 @@ NS_IMETHODIMP gfxImageFrame::GetImageData(PRUint8 **aData, PRUint32 *length)\\n   return NS_OK;\\n }\\n \\n-/* void setImageData ([array, size_is (length), const] in PRUint8 data, in unsigned long length, in long offset); */\\n-NS_IMETHODIMP gfxImageFrame::SetImageData(const PRUint8 *aData, PRUint32 aLength, PRInt32 aOffset)\\n-{\\n-  return SetData(aData, aLength, aOffset, PR_FALSE);\\n-}\\n-\\n-nsresult gfxImageFrame::SetData(const PRUint8 *aData, PRUint32 aLength, \\n-                                PRInt32 aOffset, PRBool aSetAlpha)\\n-{\\n-  if (!mInitialized)\\n-    return NS_ERROR_NOT_INITIALIZED;\\n-\\n-  NS_ASSERTION(mMutable, \\\"trying to set data on an immutable frame\\\");\\n-  NS_ASSERTION(!(aOffset<0), \\\"can't have a negative offset\\\");\\n-  if (!mMutable || aOffset < 0)\\n-    return NS_ERROR_FAILURE;\\n-\\n-  if (aSetAlpha && !mImage->GetHasAlphaMask())\\n-    return NS_ERROR_NOT_INITIALIZED;\\n-\\n-  if (aLength == 0)\\n-    return NS_OK;\\n-\\n-  mImage->LockImagePixels(aSetAlpha);\\n-  PRUint8 *imgData = aSetAlpha ? mImage->GetAlphaBits() : mImage->GetBits();\\n-  const PRUint32 rowStride = aSetAlpha ? mImage->GetAlphaLineStride() : mImage->GetLineStride();\\n-  const PRUint32 dataLength = rowStride * mSize.height;\\n-  const PRUint32 numRowsToSet = 1 + ((aLength-1) / rowStride);\\n-  const PRUint32 firstRowToSet = (aOffset / rowStride);\\n-\\n-  // Independent from which order the rows are sorted in, \\n-  // the number of bytes to set + offset should never exceed the image data space\\n-  if ((((PRUint32)aOffset + aLength) > dataLength) || !imgData) {\\n-    mImage->UnlockImagePixels(aSetAlpha);\\n-    return NS_ERROR_FAILURE;\\n-  }\\n-\\n-  if (mTopToBottom) {\\n-    // Easy situation\\n-    if (aData)\\n-      memcpy(imgData + aOffset, aData, aLength);\\n-    else\\n-      memset(imgData + aOffset, 0, aLength);\\n-  } else {\\n-    // Rows are stored in reverse order (BottomToTop) from those supplied (TopToBottom)\\n-    // yOffset is the offset into the reversed image data for firstRowToSet\\n-    PRUint32 xOffset = aOffset % rowStride;\\n-    PRUint32 yOffset = (mSize.height - firstRowToSet - 1) * rowStride;\\n-    if (aData) {\\n-      // Set the image data in reverse order\\n-      for (PRUint32 i=0; i<numRowsToSet; i++) {\\n-        PRUint32 lengthOfRowToSet = rowStride - xOffset;\\n-        lengthOfRowToSet = PR_MIN(lengthOfRowToSet, aLength);\\n-        memcpy(imgData + yOffset + xOffset, aData, lengthOfRowToSet);\\n-        aData += lengthOfRowToSet;\\n-        aLength -= lengthOfRowToSet;\\n-        yOffset -= rowStride;\\n-        xOffset = 0;\\n-      }\\n-    } else {\\n-      // Clear the image data in reverse order\\n-      if (xOffset) {\\n-        // First row, if not starting at first column\\n-        PRUint32 lengthOfRowToSet = rowStride - xOffset;\\n-        lengthOfRowToSet = PR_MIN(lengthOfRowToSet, aLength);\\n-        memset(imgData + yOffset + xOffset, 0, lengthOfRowToSet);\\n-        aLength -= lengthOfRowToSet;\\n-        yOffset -= rowStride;\\n-      }\\n-      if (aLength > rowStride) {\\n-        // Zero all the whole rows\\n-        const PRUint32 wholeRows = rowStride * (PRUint32)(aLength / rowStride);\\n-        memset(imgData + yOffset - (wholeRows - rowStride), 0, wholeRows);\\n-        aLength -= wholeRows;\\n-        yOffset -= wholeRows;\\n-      }\\n-      if (aLength) {\\n-        // Last incomplete row\\n-        memset(imgData + yOffset, 0, aLength);\\n-      }\\n-    }\\n-  }\\n-  mImage->UnlockImagePixels(aSetAlpha);\\n-\\n-  if (!aSetAlpha) {\\n-    // adjust for aLength < rowStride\\n-    nsIntRect r(0, firstRowToSet, mSize.width, numRowsToSet);\\n-    mImage->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);\\n-  }\\n-  return NS_OK;\\n-}\\n-\\n /* void lockImageData (); */\\n NS_IMETHODIMP gfxImageFrame::LockImageData()\\n {\\n@@ -386,64 +289,6 @@ NS_IMETHODIMP gfxImageFrame::UnlockImageData()\\n   return mImage->UnlockImagePixels(PR_FALSE);\\n }\\n \\n-/* readonly attribute unsigned long alphaBytesPerRow; */\\n-NS_IMETHODIMP gfxImageFrame::GetAlphaBytesPerRow(PRUint32 *aBytesPerRow)\\n-{\\n-  if (!mInitialized || !mImage->GetHasAlphaMask())\\n-    return NS_ERROR_NOT_INITIALIZED;\\n-\\n-  *aBytesPerRow = mImage->GetAlphaLineStride();\\n-  return NS_OK;\\n-}\\n-\\n-/* readonly attribute unsigned long alphaDataLength; */\\n-NS_IMETHODIMP gfxImageFrame::GetAlphaDataLength(PRUint32 *aBitsLength)\\n-{\\n-  if (!mInitialized || !mImage->GetHasAlphaMask())\\n-    return NS_ERROR_NOT_INITIALIZED;\\n-\\n-  *aBitsLength = mImage->GetAlphaLineStride() * mSize.height;\\n-  return NS_OK;\\n-}\\n-\\n-/* void getAlphaData([array, size_is(length)] out PRUint8 bits, out unsigned long length); */\\n-NS_IMETHODIMP gfxImageFrame::GetAlphaData(PRUint8 **aData, PRUint32 *length)\\n-{\\n-  if (!mInitialized || !mImage->GetHasAlphaMask())\\n-    return NS_ERROR_NOT_INITIALIZED;\\n-\\n-  NS_ASSERTION(mMutable, \\\"trying to get data on an immutable frame\\\");\\n-\\n-  *aData = mImage->GetAlphaBits();\\n-  *length = mImage->GetAlphaLineStride() * mSize.height;\\n-\\n-  return NS_OK;\\n-}\\n-\\n-/* void setAlphaData ([array, size_is (length), const] in PRUint8 data, in unsigned long length, in long offset); */\\n-NS_IMETHODIMP gfxImageFrame::SetAlphaData(const PRUint8 *aData, PRUint32 aLength, PRInt32 aOffset)\\n-{\\n-  return SetData(aData, aLength, aOffset, PR_TRUE);\\n-}\\n-\\n-/* void lockAlphaData (); */\\n-NS_IMETHODIMP gfxImageFrame::LockAlphaData()\\n-{\\n-  if (!mInitialized || !mImage->GetHasAlphaMask())\\n-    return NS_ERROR_NOT_INITIALIZED;\\n-\\n-  return mImage->LockImagePixels(PR_TRUE);\\n-}\\n-\\n-/* void unlockAlphaData (); */\\n-NS_IMETHODIMP gfxImageFrame::UnlockAlphaData()\\n-{\\n-  if (!mInitialized || !mImage->GetHasAlphaMask())\\n-    return NS_ERROR_NOT_INITIALIZED;\\n-\\n-  return mImage->UnlockImagePixels(PR_TRUE);\\n-}\\n-\\n /* attribute long timeout; */\\n NS_IMETHODIMP gfxImageFrame::GetTimeout(PRInt32 *aTimeout)\\n {\\n@@ -498,25 +343,6 @@ NS_IMETHODIMP gfxImageFrame::SetFrameDisposalMethod(PRInt32 aFrameDisposalMethod\\n   return NS_OK;\\n }\\n \\n-/* attribute gfx_color backgroundColor; */\\n-NS_IMETHODIMP gfxImageFrame::GetBackgroundColor(gfx_color *aBackgroundColor)\\n-{\\n-  if (!mInitialized || !mHasBackgroundColor)\\n-    return NS_ERROR_NOT_INITIALIZED;\\n-\\n-  *aBackgroundColor = mBackgroundColor;\\n-  return NS_OK;\\n-}\\n-NS_IMETHODIMP gfxImageFrame::SetBackgroundColor(gfx_color aBackgroundColor)\\n-{\\n-  if (!mInitialized)\\n-    return NS_ERROR_NOT_INITIALIZED;\\n-\\n-  mBackgroundColor = aBackgroundColor;\\n-  mHasBackgroundColor = PR_TRUE;\\n-  return NS_OK;\\n-}\\n-\\n NS_IMETHODIMP gfxImageFrame::GetInterface(const nsIID & aIID, void * *result)\\n {\\n   if (!mInitialized)\\ndiff --git a/gfx/src/shared/gfxImageFrame.h b/gfx/src/shared/gfxImageFrame.h\\nindex 59aa4cc..d9f2514 100644\\n--- a/gfx/src/shared/gfxImageFrame.h\\n+++ b/gfx/src/shared/gfxImageFrame.h\\n@@ -71,21 +71,13 @@ protected:\\n   nsIntSize mSize;\\n \\n private:\\n-  nsresult  SetData(const PRUint8 *aData, PRUint32 aLength, \\n-                    PRInt32 aOffset, PRBool aSetAlpha);\\n-\\n   nsCOMPtr<nsIImage> mImage;\\n \\n   PRPackedBool mInitialized;\\n   PRPackedBool mMutable;\\n-  PRPackedBool mHasBackgroundColor;\\n-  PRPackedBool mTopToBottom;\\n   gfx_format   mFormat;\\n \\n-  PRInt32 mTimeout; // -1 means display forever\\n-  nsIntPoint mOffset;\\n-\\n-  gfx_color mBackgroundColor;\\n-\\n-  PRInt32   mDisposalMethod;\\n+  PRInt32      mTimeout; // -1 means display forever\\n+  nsIntPoint   mOffset;\\n+  PRInt32      mDisposalMethod;\\n };\\n\""}