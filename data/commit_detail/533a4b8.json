{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas533a4b8\""},"diff":"\"533a4b8 fix for bug #394508:  queries that use maxResults can return incorrect results due to post query filtering. initial patch=Colin Walters <walters@verbum.org> r=dietrich, a=mconnor\\ndiff --git a/toolkit/components/places/src/nsNavHistory.cpp b/toolkit/components/places/src/nsNavHistory.cpp\\nindex f4cf4c6..b74bf49 100644\\n--- a/toolkit/components/places/src/nsNavHistory.cpp\\n+++ b/toolkit/components/places/src/nsNavHistory.cpp\\n@@ -1558,7 +1558,7 @@ nsNavHistory::EvaluateQueryForNode(const nsCOMArray<nsNavHistoryQuery>& aQueries\\n       nsCOMArray<nsNavHistoryQuery> queries;\\n       queries.AppendObject(query);\\n       nsCOMArray<nsNavHistoryResultNode> filteredSet;\\n-      nsresult rv = FilterResultSet(nsnull, inputSet, &filteredSet, queries);\\n+      nsresult rv = FilterResultSet(nsnull, inputSet, &filteredSet, queries, aOptions);\\n       if (NS_FAILED(rv))\\n         continue;\\n       if (! filteredSet.Count())\\n@@ -2144,6 +2144,32 @@ PRBool IsHistoryMenuQuery(const nsCOMArray<nsNavHistoryQuery>& aQueries, nsNavHi\\n   return PR_TRUE;\\n }\\n \\n+static\\n+PRBool NeedToFilterResultSet(const nsCOMArray<nsNavHistoryQuery>& aQueries, \\n+                             nsNavHistoryQueryOptions *aOptions)\\n+{\\n+  // optimize the case where we just want a list with no grouping: this\\n+  // directly fills in the results and we avoid a copy of the whole list\\n+  PRUint32 groupCount;\\n+  const PRUint16 *groupings = aOptions->GroupingMode(&groupCount);\\n+\\n+  if (groupCount != 0 || aOptions->ExcludeQueries())\\n+    return PR_TRUE;\\n+\\n+  PRInt32 i;\\n+  for (i = 0; i < aQueries.Count(); i ++) {\\n+    if (aQueries[i]->Folders().Length() != 0) {\\n+      return PR_TRUE;\\n+    } else {\\n+      PRBool hasSearchTerms;\\n+      nsresult rv = aQueries[i]->GetHasSearchTerms(&hasSearchTerms);\\n+      if (NS_FAILED(rv) || hasSearchTerms)\\n+        return PR_TRUE;\\n+    }\\n+  }\\n+  return PR_FALSE;\\n+}\\n+\\n nsresult\\n nsNavHistory::ConstructQueryString(const nsCOMArray<nsNavHistoryQuery>& aQueries,\\n                                    nsNavHistoryQueryOptions *aOptions, \\n@@ -2155,6 +2181,11 @@ nsNavHistory::ConstructQueryString(const nsCOMArray<nsNavHistoryQuery>& aQueries\\n     return NS_ERROR_INVALID_ARG;\\n   }\\n \\n+  // determine whether we can push maxResults constraints\\n+  // into the queries as LIMIT, or if we need to do result count clamping later\\n+  // using FilterResultSet()\\n+  PRBool canLimitInSQL = !NeedToFilterResultSet(aQueries, aOptions);\\n+\\n   // for the very special query for the history menu \\n   // we generate a super-optimized SQL query\\n   if (IsHistoryMenuQuery(aQueries, aOptions)) {\\n@@ -2169,8 +2200,11 @@ nsNavHistory::ConstructQueryString(const nsCOMArray<nsNavHistoryQuery>& aQueries\\n       \\\"(h.id IN (SELECT DISTINCT h.id FROM moz_historyvisits, \\\"\\n       \\\" moz_places h WHERE place_id = \\\"\\n       \\\" h.id AND hidden <> 1 AND visit_type <> 4 AND visit_type <> 0 \\\"\\n-      \\\" ORDER BY visit_date DESC LIMIT \\\");\\n-    queryString.AppendInt(aOptions->MaxResults());\\n+      \\\" ORDER BY visit_date DESC\\\");\\n+    if (canLimitInSQL) {\\n+      queryString += NS_LITERAL_CSTRING(\\\" LIMIT \\\");\\n+      queryString.AppendInt(aOptions->MaxResults());\\n+    }\\n     queryString += NS_LITERAL_CSTRING(\\\")) GROUP BY h.id ORDER BY 6 DESC\\\"); // v.visit_date\\n     return NS_OK;\\n   }\\n@@ -2238,8 +2272,7 @@ nsNavHistory::ConstructQueryString(const nsCOMArray<nsNavHistoryQuery>& aQueries\\n       \\\"LEFT OUTER JOIN moz_historyvisits v ON b.fk = v.place_id \\\"\\n       \\\"LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id \\\");\\n       groupBy = NS_LITERAL_CSTRING(\\\" GROUP BY b.id\\\");\\n-    }\\n-    else {\\n+    } else {\\n       // XXX: implement support for nsINavHistoryQueryOptions::QUERY_TYPE_UNIFIED \\n       return NS_ERROR_NOT_IMPLEMENTED;\\n     }\\n@@ -2334,8 +2367,8 @@ nsNavHistory::ConstructQueryString(const nsCOMArray<nsNavHistoryQuery>& aQueries\\n       NS_NOTREACHED(\\\"Invalid sorting mode\\\");\\n   }\\n \\n-  // limit clause if there are 'maxResults'\\n-  if (aOptions->MaxResults() > 0) {\\n+  // limit clause if there are 'maxResults' and can use limit in our SQL\\n+  if (canLimitInSQL && aOptions->MaxResults() > 0) {\\n     queryString += NS_LITERAL_CSTRING(\\\" LIMIT \\\");\\n     queryString.AppendInt(aOptions->MaxResults());\\n     queryString.AppendLiteral(\\\" \\\");\\n@@ -2390,55 +2423,30 @@ nsNavHistory::GetQueryResults(nsNavHistoryQueryResultNode *aResultNode,\\n   // bind parameters\\n   PRInt32 numParameters = 0;\\n \\n-  // optimize the case where we just want a list with no grouping: this\\n-  // directly fills in the results and we avoid a copy of the whole list\\n-  PRBool resultAsList = PR_TRUE;\\n-  PRUint32 groupCount;\\n-  const PRUint16 *groupings = aOptions->GroupingMode(&groupCount);\\n-\\n-  if (groupCount != 0 || aOptions->ExcludeQueries()) {\\n-    resultAsList = PR_FALSE;\\n-  }\\n-\\n-  PRInt32 i;\\n-  for (i = 0; i < aQueries.Count(); i ++) {\\n-    PRInt32 clauseParameters = 0;\\n-    rv = BindQueryClauseParameters(statement, numParameters,\\n-                                   aQueries[i], aOptions, &clauseParameters);\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n-    numParameters += clauseParameters;\\n-    if (resultAsList) {\\n-      if (aQueries[i]->Folders().Length() != 0) {\\n-        resultAsList = PR_FALSE;\\n-      } else {\\n-        PRBool hasSearchTerms;\\n-        rv = aQueries[i]->GetHasSearchTerms(&hasSearchTerms);\\n-        if (hasSearchTerms)\\n-          resultAsList = PR_FALSE;\\n-        NS_ENSURE_SUCCESS(rv, rv);\\n-      }\\n-    }\\n-  }\\n-\\n-  if (resultAsList) {\\n-    rv = ResultsAsList(statement, aOptions, aResults);\\n-    NS_ENSURE_SUCCESS(rv, rv);\\n-  } else {\\n+  // optimize the case where we just use the results as is\\n+  // and we don't need to do any post-query filtering\\n+  if (NeedToFilterResultSet(aQueries, aOptions)) {\\n     // generate the toplevel results\\n     nsCOMArray<nsNavHistoryResultNode> toplevel;\\n     rv = ResultsAsList(statement, aOptions, &toplevel);\\n     NS_ENSURE_SUCCESS(rv, rv);\\n \\n+    PRUint32 groupCount;\\n+    const PRUint16 *groupings = aOptions->GroupingMode(&groupCount);\\n+\\n     if (groupCount == 0) {\\n-      FilterResultSet(aResultNode, toplevel, aResults, aQueries);\\n+      FilterResultSet(aResultNode, toplevel, aResults, aQueries, aOptions);\\n     } else {\\n       nsCOMArray<nsNavHistoryResultNode> filteredResults;\\n-      FilterResultSet(aResultNode, toplevel, &filteredResults, aQueries);\\n+      FilterResultSet(aResultNode, toplevel, &filteredResults, aQueries, aOptions);\\n       rv = RecursiveGroup(aResultNode, filteredResults, groupings, groupCount,\\n                           aResults);\\n       NS_ENSURE_SUCCESS(rv, rv);\\n     }\\n-  }\\n+  } else {\\n+    rv = ResultsAsList(statement, aOptions, aResults);\\n+    NS_ENSURE_SUCCESS(rv, rv);\\n+  } \\n \\n   return NS_OK;\\n }\\n@@ -4127,16 +4135,22 @@ nsNavHistory::URIHasTag(nsIURI* aURI, const nsAString& aTag)\\n \\n // nsNavHistory::FilterResultSet\\n //\\n-//    This does some post-query-execution filtering:\\n-//      - searching on title & url\\n-//      - parent folder (recursively)\\n-//      - excludeQueries\\n+// This does some post-query-execution filtering:\\n+//   - searching on title & url\\n+//   - parent folder (recursively)\\n+//   - excludeQueries\\n+//   - tags\\n+//   - limit count\\n+//\\n+// Note:  changes to filtering in FilterResultSet() \\n+// may require changes to NeedToFilterResultSet()\\n \\n nsresult\\n nsNavHistory::FilterResultSet(nsNavHistoryQueryResultNode* aQueryNode,\\n                               const nsCOMArray<nsNavHistoryResultNode>& aSet,\\n                               nsCOMArray<nsNavHistoryResultNode>* aFiltered,\\n-                              const nsCOMArray<nsNavHistoryQuery>& aQueries)\\n+                              const nsCOMArray<nsNavHistoryQuery>& aQueries,\\n+                              nsNavHistoryQueryOptions *aOptions)\\n {\\n   nsresult rv;\\n \\n@@ -4260,6 +4274,9 @@ nsNavHistory::FilterResultSet(nsNavHistoryQueryResultNode* aQueryNode,\\n     }\\n     if (appendNode)\\n       aFiltered->AppendObject(aSet[nodeIndex]);\\n+      \\n+    if (aOptions->MaxResults() > 0 && aFiltered->Count() >= aOptions->MaxResults())\\n+      break;\\n   }\\n \\n   // de-allocate the matrixes\\ndiff --git a/toolkit/components/places/src/nsNavHistory.h b/toolkit/components/places/src/nsNavHistory.h\\nindex 650b0c3..d6f4fbd 100644\\n--- a/toolkit/components/places/src/nsNavHistory.h\\n+++ b/toolkit/components/places/src/nsNavHistory.h\\n@@ -516,7 +516,8 @@ protected:\\n   nsresult FilterResultSet(nsNavHistoryQueryResultNode *aParentNode,\\n                            const nsCOMArray<nsNavHistoryResultNode>& aSet,\\n                            nsCOMArray<nsNavHistoryResultNode>* aFiltered,\\n-                           const nsCOMArray<nsNavHistoryQuery>& aQueries);\\n+                           const nsCOMArray<nsNavHistoryQuery>& aQueries,\\n+                           nsNavHistoryQueryOptions* aOptions);\\n \\n   // observers\\n   nsMaybeWeakPtrArray<nsINavHistoryObserver> mObservers;\\n\""}