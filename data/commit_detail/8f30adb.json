{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Bas8f30adb\""},"diff":"\"8f30adb Bug 394691. Remove nsAutoBuffer.h now that it's unused (use nsAutoTArray instead).\\ndiff --git a/xpcom/ds/nsAutoBuffer.h b/xpcom/ds/nsAutoBuffer.h\\ndeleted file mode 100644\\nindex 2441bcc..0000000\\n--- a/xpcom/ds/nsAutoBuffer.h\\n+++ /dev/null\\n@@ -1,142 +0,0 @@\\n-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\\n-/* ***** BEGIN LICENSE BLOCK *****\\n- * Version: MPL 1.1/GPL 2.0/LGPL 2.1\\n- *\\n- * The contents of this file are subject to the Mozilla Public License Version\\n- * 1.1 (the \\\"License\\\"); you may not use this file except in compliance with\\n- * the License. You may obtain a copy of the License at\\n- * http://www.mozilla.org/MPL/\\n- *\\n- * Software distributed under the License is distributed on an \\\"AS IS\\\" basis,\\n- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\\n- * for the specific language governing rights and limitations under the\\n- * License.\\n- *\\n- * The Original Code is auto buffer template.\\n- *\\n- * The Initial Developer of the Original Code is\\n- * Conrad Carlen <ccarlen@mac.com>.\\n- * Portions created by the Initial Developer are Copyright (C) 2004\\n- * the Initial Developer. All Rights Reserved.\\n- *\\n- * Contributor(s):\\n- *   Jungshik Shin <jshin@mailaps.org>\\n- *\\n- * Alternatively, the contents of this file may be used under the terms of\\n- * either the GNU General Public License Version 2 or later (the \\\"GPL\\\"), or\\n- * the GNU Lesser General Public License Version 2.1 or later (the \\\"LGPL\\\"),\\n- * in which case the provisions of the GPL or the LGPL are applicable instead\\n- * of those above. If you wish to allow use of your version of this file only\\n- * under the terms of either the GPL or the LGPL, and not to allow others to\\n- * use your version of this file under the terms of the MPL, indicate your\\n- * decision by deleting the provisions above and replace them with the notice\\n- * and other provisions required by the GPL or the LGPL. If you do not delete\\n- * the provisions above, a recipient may use your version of this file under\\n- * the terms of any one of the MPL, the GPL or the LGPL.\\n- *\\n- * ***** END LICENSE BLOCK ***** */\\n-\\n-#ifndef nsAutoBuffer_h__\\n-#define nsAutoBuffer_h__\\n-\\n-#ifndef nsMemory_h__\\n-#include \\\"nsMemory.h\\\"\\n-#endif\\n-\\n-/**\\n- * A buffer which will use stack space if the requested size will\\n- * fit in the stack buffer and allocate from the heap if not.\\n- *\\n- * Be careful when you call EnsureElemCapacity/AddElemCapacity: the data\\n- * contained in the buffer is not preserved through this operation.\\n- *\\n- * This class is not intended to be used with types that are not\\n- * POD structures or primitives. The buffer allocated by this class is not\\n- * initialized.\\n- * \\n- * Below is a usage example : \\n- * \\n- * typedef nsAutoBuffer<PRUnichar, 256> nsAutoUnicharBuffer;\\n- *\\n- * nsAutoUnicharBuffer buffer;\\n- *\\n- * if (!buffer.EnsureElemCapacity(initialLength))\\n- *    return NS_ERROR_OUT_OF_MEMORY;\\n- *\\n- * PRUnichar *unicharPtr = buffer.get();\\n- *\\n- * // use the buffer for various stuff\\n- *\\n- * // increase the capacity\\n- * // note that the data will not be preserved through this step\\n- * if (!buffer.AddElemCapacity(extraLength))\\n- *     return NS_ERROR_OUT_OF_MEMORY\\n- *\\n- * // continue to use the buffer for other things\\n- */\\n-\\n-template <class T, PRInt32 sz>\\n-class nsAutoBuffer\\n-{\\n-public:\\n-  nsAutoBuffer() :\\n-    mBufferPtr(mStackBuffer),\\n-    mCurElemCapacity(sz)\\n-  {\\n-  }\\n-\\n-  ~nsAutoBuffer()\\n-  {\\n-    if (mBufferPtr != mStackBuffer)\\n-      NS_Free(mBufferPtr);\\n-  }\\n-\\n-  // Note that this method can forget the data in the array!\\n-  // This is intentional.\\n-  PRBool EnsureElemCapacity(PRInt32 inElemCapacity)\\n-  {\\n-    if (inElemCapacity <= mCurElemCapacity)\\n-      return PR_TRUE;\\n-\\n-    T* newBuffer;\\n-\\n-    if (mBufferPtr != mStackBuffer) {\\n-      newBuffer = static_cast<T*>(NS_Realloc(mBufferPtr, inElemCapacity * sizeof(T)));\\n-    } else {\\n-      newBuffer = static_cast<T*>(NS_Alloc(inElemCapacity * sizeof(T)));\\n-    }\\n-\\n-    if (!newBuffer)\\n-      return PR_FALSE;\\n-\\n-    mBufferPtr = newBuffer; \\n-    mCurElemCapacity = inElemCapacity;\\n-    return PR_TRUE;\\n-  }\\n-\\n-  PRBool AddElemCapacity(PRInt32 inElemCapacity)\\n-  {\\n-    return EnsureElemCapacity(mCurElemCapacity + inElemCapacity);\\n-  }\\n-\\n-  T*          get()             const  { return mBufferPtr; }\\n-  PRInt32     GetElemCapacity() const  { return mCurElemCapacity;  }\\n-\\n-  T& operator[](PRUint32 i)\\n-  {\\n-    return mBufferPtr[i];\\n-  }\\n-\\n-  const T& operator[](PRUint32 i) const\\n-  {\\n-    return mBufferPtr[i];\\n-  }\\n-\\n-protected:\\n-\\n-  T             *mBufferPtr;\\n-  T             mStackBuffer[sz];\\n-  PRInt32       mCurElemCapacity;\\n-};\\n-\\n-#endif // nsAutoBuffer_h__\\n\""}