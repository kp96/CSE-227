{"sha":"\"47e7bc67f932866e4467f7ab8a23bb167405bebd\"","commit":{"author":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"committer":{"name":"\"Nicolas Silva\"","email":"\"nsilva@mozilla.com\"","date":"\"2016-09-01T15:51:09+02:00\""},"message":"\"Bug 1298345 - Refactor CanvasRenderingContext2D's texture allocation code. r=Basf3304b2\""},"diff":"\"f3304b2 393845 Stop plugins from content instead of from layout. Also, reget the frame after stopping the plugin, as that may process events. Finally, make the object frame not touch member variables after stopping the plugin. r+sr=bz a=jst\\ndiff --git a/content/base/src/nsObjectLoadingContent.cpp b/content/base/src/nsObjectLoadingContent.cpp\\nindex 004fa1f..9671af1b 100644\\n--- a/content/base/src/nsObjectLoadingContent.cpp\\n+++ b/content/base/src/nsObjectLoadingContent.cpp\\n@@ -142,6 +142,8 @@ nsAsyncInstantiateEvent::Run()\\n            mContent, mContentType.get(), mURI.get(), spec.get()));\\n     }\\n \\n+    // We don't have to stop the plugin because we only use the event\\n+    // for newly created frames that don't have a plugin loaded yet.\\n     nsresult rv = mContent->Instantiate(frame, mContentType, mURI);\\n     if (NS_FAILED(rv)) {\\n       mContent->Fallback(PR_TRUE);\\n@@ -484,6 +486,8 @@ nsObjectLoadingContent::OnStartRequest(nsIRequest *aRequest, nsISupports *aConte\\n         mInstantiating = PR_FALSE;\\n         return NS_BINDING_ABORTED;\\n       }\\n+      // We came here via eState_Loading. Therefore, our frame is newly\\n+      // created, thus we don't have to stop the plugin.\\n       rv = frame->Instantiate(chan, getter_AddRefs(mFinalListener));\\n       mInstantiating = PR_FALSE;\\n       break;\\n@@ -1468,6 +1472,21 @@ nsObjectLoadingContent::TryInstantiate(const nsACString& aMIMEType,\\n     LOG((\\\"OBJLC [%p]: Frame hasn't been reflown yet\\\\n\\\", this));\\n     return NS_OK; // Not a failure to have no frame\\n   }\\n+  // Stop the plugin first. Since that might destroy the frame,\\n+  // we have to get it again.\\n+  frame->StopPlugin();\\n+\\n+  frame = GetFrame(PR_FALSE);\\n+  if (!frame) {\\n+    LOG((\\\"OBJLC [%p]: No frame anymore\\\\n\\\", this));\\n+    return NS_OK; // Not a failure to have no frame\\n+  }\\n+  CallQueryInterface(frame, &iframe);\\n+  if (iframe->GetStateBits() & NS_FRAME_FIRST_REFLOW) {\\n+    LOG((\\\"OBJLC [%p]: New frame hasn't been reflown yet\\\\n\\\", this));\\n+    return NS_OK; // Not a failure to have no frame\\n+  }\\n+\\n   return Instantiate(frame, aMIMEType, aURI);\\n }\\n \\ndiff --git a/layout/generic/nsObjectFrame.cpp b/layout/generic/nsObjectFrame.cpp\\nindex 44062e3..c3a6628 100644\\n--- a/layout/generic/nsObjectFrame.cpp\\n+++ b/layout/generic/nsObjectFrame.cpp\\n@@ -1374,9 +1374,8 @@ nsresult nsObjectFrame::GetPluginInstance(nsIPluginInstance*& aPluginInstance)\\n nsresult\\n nsObjectFrame::PrepareInstanceOwner()\\n {\\n-  // First, have to stop any possibly running plugins.\\n-  StopPluginInternal(PR_FALSE);\\n-\\n+  // Our content node should have taken care of stopping the\\n+  // previously loaded plugin (if any)\\n   NS_ASSERTION(!mInstanceOwner, \\\"Must not have an instance owner here\\\");\\n \\n   mInstanceOwner = new nsPluginInstanceOwner();\\n@@ -1545,7 +1544,10 @@ nsObjectFrame::StopPluginInternal(PRBool aDelayedStop)\\n     return;\\n   }\\n \\n-  mInstanceOwner->PrepareToStop(aDelayedStop);\\n+  nsRefPtr<nsPluginInstanceOwner> owner;\\n+  owner.swap(mInstanceOwner);\\n+\\n+  owner->PrepareToStop(aDelayedStop);\\n \\n #ifdef XP_WIN\\n   // We only deal with delayed stopping of plugins on Win32 for now,\\n@@ -1553,8 +1555,8 @@ nsObjectFrame::StopPluginInternal(PRBool aDelayedStop)\\n   // unclear how safe widget parenting is on other platforms.\\n   if (aDelayedStop) {\\n     // nsStopPluginRunnable will hold a strong reference to\\n-    // mInstanceOwner, and thus keep it alive as long as it needs it.\\n-    nsCOMPtr<nsIRunnable> evt = new nsStopPluginRunnable(mInstanceOwner);\\n+    // owner, and thus keep it alive as long as it needs it.\\n+    nsCOMPtr<nsIRunnable> evt = new nsStopPluginRunnable(owner);\\n     NS_DispatchToCurrentThread(evt);\\n \\n     // If we're asked to do a delayed stop it means we're stopping the\\n@@ -1568,13 +1570,13 @@ nsObjectFrame::StopPluginInternal(PRBool aDelayedStop)\\n   } else\\n #endif\\n   {\\n-    DoStopPlugin(mInstanceOwner);\\n+    DoStopPlugin(owner);\\n+    // Stopping the plugin may have destroyed the frame.\\n+    // Do not touch any member variables after this line.\\n   }\\n \\n   // Break relationship between frame and plugin instance owner\\n-  mInstanceOwner->SetOwner(nsnull);\\n-\\n-  NS_RELEASE(mInstanceOwner);\\n+  owner->SetOwner(nsnull);\\n }\\n \\n void\\n\""}